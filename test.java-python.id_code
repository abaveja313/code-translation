{"id": "codeforces_1004_A", "sol": 0, "python_code": "import sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\nn , d = map ( int , input ( ).split ( ) )\nx = list ( map ( int , input ( ).split ( ) ) )\nx.sort ( )\nans = 2\nfor i in range ( n - 1 ) :\n    if x [ i + 1 ] - x [ i ] == 2 * d :\n        ans += 1\n    elif x [ i + 1 ] - x [ i ] >= 2 * d :\n        ans += 2\nprint ( ans )\n", "python_code_tokenized": "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE n , d = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x . sort ( ) NEW_LINE ans = 2 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if x [ i + 1 ] - x [ i ] == 2 * d : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif x [ i + 1 ] - x [ i ] >= 2 * d : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_2278_A", "sol": 0, "python_code": "def findK ( n , k ) :\n    a = list ( )\n    i = 1\n    while i < n :\n        a.append ( i )\n        i = i + 2\n    i = 2\n    while i < n :\n        a.append ( i )\n        i = i + 2\n    return ( a [ k - 1 ] )\nn = 10\nk = 3\nprint ( findK ( n , k ) )\n", "python_code_tokenized": "def findK ( n , k ) : NEW_LINE INDENT a = list ( ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT a . append ( i ) NEW_LINE i = i + 2 NEW_LINE DEDENT i = 2 NEW_LINE while i < n : NEW_LINE INDENT a . append ( i ) NEW_LINE i = i + 2 NEW_LINE DEDENT return ( a [ k - 1 ] ) NEW_LINE DEDENT n = 10 NEW_LINE k = 3 NEW_LINE print ( findK ( n , k ) ) NEW_LINE"}
{"id": "codeforces_1047_A", "sol": 0, "python_code": "n = int ( input ( ) )\nx = 1\ny = 1\nz = n - 2\nif z % 3 == 0 :\n    z -= 1\n    y += 1\nprint ( x , y , z )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE x = 1 NEW_LINE y = 1 NEW_LINE z = n - 2 NEW_LINE if z % 3 == 0 : NEW_LINE INDENT z -= 1 NEW_LINE y += 1 NEW_LINE DEDENT print ( x , y , z ) NEW_LINE"}
{"id": "codeforces_1248_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    n = int ( input ( ) )\n    p = list ( map ( int , input ( ).split ( ) ) )\n    m = int ( input ( ) )\n    q = list ( map ( int , input ( ).split ( ) ) )\n    even_p = [ x for x in p if x % 2 == 0 ]\n    odd_p = [ x for x in p if x % 2 != 0 ]\n    even_q = [ x for x in q if x % 2 == 0 ]\n    odd_q = [ x for x in q if x % 2 != 0 ]\n    print ( len ( even_q ) * len ( even_p ) + len ( odd_q ) * len ( odd_p ) )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE q = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE even_p = [ x for x in p if x % 2 == 0 ] NEW_LINE odd_p = [ x for x in p if x % 2 != 0 ] NEW_LINE even_q = [ x for x in q if x % 2 == 0 ] NEW_LINE odd_q = [ x for x in q if x % 2 != 0 ] NEW_LINE print ( len ( even_q ) * len ( even_p ) + len ( odd_q ) * len ( odd_p ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00365_A", "sol": 0, "python_code": "a = sorted ( [ tuple ( map ( int , input ( ).split ( ) ) ) for _ in [ 0 , 0 ] ] )\nprint ( a [ 1 ] [ 0 ] - a [ 0 ] [ 0 ] + ( 1 if a [ 1 ] [ 1 ] > a [ 0 ] [ 1 ] or ( a [ 1 ] [ 1 ] == a [ 0 ] [ 1 ] and a [ 1 ] [ 2 ] > a [ 0 ] [ 2 ] ) else 0 ) )\n", "python_code_tokenized": "a = sorted ( [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 , 0 ] ] ) NEW_LINE print ( a [ 1 ] [ 0 ] - a [ 0 ] [ 0 ] + ( 1 if a [ 1 ] [ 1 ] > a [ 0 ] [ 1 ] or ( a [ 1 ] [ 1 ] == a [ 0 ] [ 1 ] and a [ 1 ] [ 2 ] > a [ 0 ] [ 2 ] ) else 0 ) ) NEW_LINE"}
{"id": "codeforces_1284_A", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\ns = input ( ).split ( )\nt = input ( ).split ( )\nfor _ in range ( int ( input ( ) ) ) :\n    x = int ( input ( ) )\n    ans = s [ x % n - 1 ] + t [ x % m - 1 ]\n    print ( ans )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) . split ( ) NEW_LINE t = input ( ) . split ( ) NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE ans = s [ x % n - 1 ] + t [ x % m - 1 ] NEW_LINE print ( ans ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_353_A", "sol": 0, "python_code": "import sys\ndef minCoins ( coins , m , V ) :\n    if ( V == 0 ) :\n        return 0\n    res = sys.maxsize\n    for i in range ( 0 , m ) :\n        if ( coins [ i ] <= V ) :\n            sub_res = minCoins ( coins , m , V - coins [ i ] )\n            if ( sub_res != sys.maxsize and sub_res + 1 < res ) :\n                res = sub_res + 1\n    return res\ncoins = [ 9 , 6 , 5 , 1 ]\nm = len ( coins )\nV = 11\nprint ( \"Minimum coins required is\" , minCoins ( coins , m , V ) )\n", "python_code_tokenized": "import sys NEW_LINE def minCoins ( coins , m , V ) : NEW_LINE INDENT if ( V == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = sys . maxsize NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if ( coins [ i ] <= V ) : NEW_LINE INDENT sub_res = minCoins ( coins , m , V - coins [ i ] ) NEW_LINE if ( sub_res != sys . maxsize and sub_res + 1 < res ) : NEW_LINE INDENT res = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT coins = [ 9 , 6 , 5 , 1 ] NEW_LINE m = len ( coins ) NEW_LINE V = 11 NEW_LINE print ( \" Minimum \u2581 coins \u2581 required \u2581 is \" , minCoins ( coins , m , V ) ) NEW_LINE"}
{"id": "geeksforgeeks_3974_A", "sol": 0, "python_code": "def search ( arr , n , x ) :\n    front = 0 ; back = n - 1\n    while ( front <= back ) :\n        if ( arr [ front ] == x or arr [ back ] == x ) :\n            return True\n        front += 1\n        back -= 1\n    return False\narr = [ 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 ]\nx = 130\nn = len ( arr )\nif ( search ( arr , n , x ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def search ( arr , n , x ) : NEW_LINE INDENT front = 0 ; back = n - 1 NEW_LINE while ( front <= back ) : NEW_LINE INDENT if ( arr [ front ] == x or arr [ back ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT front += 1 NEW_LINE back -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 ] NEW_LINE x = 130 NEW_LINE n = len ( arr ) NEW_LINE if ( search ( arr , n , x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4307_A", "sol": 0, "python_code": "def display ( n ) :\n    for i in range ( 1 , n + 1 ) :\n        k = i\n        for j in range ( 1 , i + 1 ) :\n            if k % 2 == 0 :\n                print ( j , end = '' )\n            else :\n                print ( '*' , end = '' )\n            k -= 1\n        print ( )\nn = 5\ndisplay ( n )\n", "python_code_tokenized": "def display ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = i NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT print ( j , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' * ' , end = ' ' ) NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE display ( n ) NEW_LINE"}
{"id": "atcoder_ABC175_D", "sol": 0, "python_code": "N , K = map ( int , input ( ).split ( ) )\nP = list ( map ( int , input ( ).split ( ) ) )\nC = list ( map ( int , input ( ).split ( ) ) )\nlim = 60\nnex = [ [ 0 ] * N for _ in range ( lim ) ]\nval = [ [ 0 ] * N for _ in range ( lim ) ]\ncnd = [ [ 0 ] * N for _ in range ( lim ) ]\nfor i in range ( N ) :\n    nex [ 0 ] [ i ] = P [ i ] - 1\n    val [ 0 ] [ i ] = C [ i ]\n    cnd [ 0 ] [ i ] = C [ i ]\nfor d in range ( lim - 1 ) :\n    for i in range ( N ) :\n        nex [ d + 1 ] [ i ] = nex [ d ] [ nex [ d ] [ i ] ]\n        val [ d + 1 ] [ i ] = val [ d ] [ i ] + val [ d ] [ nex [ d ] [ i ] ]\n        cnd [ d + 1 ] [ i ] = max ( cnd [ d ] [ i ] , val [ d ] [ i ] + cnd [ d ] [ nex [ d ] [ i ] ] )\nres = - 10 ** 9\nfor i in range ( N ) :\n    sum_ = 0\n    offset = i\n    for d in reversed ( range ( lim ) ) :\n        if K & 1 << d :\n            res = max ( res , sum_ + cnd [ d ] [ offset ] )\n            sum_ += val [ d ] [ offset ]\n            offset = nex [ d ] [ offset ]\nprint ( res )\n", "python_code_tokenized": "N , K = map ( int , input ( ) . split ( ) ) NEW_LINE P = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lim = 60 NEW_LINE nex = [ [ 0 ] * N for _ in range ( lim ) ] NEW_LINE val = [ [ 0 ] * N for _ in range ( lim ) ] NEW_LINE cnd = [ [ 0 ] * N for _ in range ( lim ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT nex [ 0 ] [ i ] = P [ i ] - 1 NEW_LINE val [ 0 ] [ i ] = C [ i ] NEW_LINE cnd [ 0 ] [ i ] = C [ i ] NEW_LINE DEDENT for d in range ( lim - 1 ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT nex [ d + 1 ] [ i ] = nex [ d ] [ nex [ d ] [ i ] ] NEW_LINE val [ d + 1 ] [ i ] = val [ d ] [ i ] + val [ d ] [ nex [ d ] [ i ] ] NEW_LINE cnd [ d + 1 ] [ i ] = max ( cnd [ d ] [ i ] , val [ d ] [ i ] + cnd [ d ] [ nex [ d ] [ i ] ] ) NEW_LINE DEDENT DEDENT res = - 10 ** 9 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum_ = 0 NEW_LINE offset = i NEW_LINE for d in reversed ( range ( lim ) ) : NEW_LINE INDENT if K & 1 << d : NEW_LINE INDENT res = max ( res , sum_ + cnd [ d ] [ offset ] ) NEW_LINE sum_ += val [ d ] [ offset ] NEW_LINE offset = nex [ d ] [ offset ] NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE"}
{"id": "geeksforgeeks_2195_A", "sol": 0, "python_code": "def smallestSum ( n ) :\n    if ( n == 1 ) :\n        return 0\n    return ( 2 * pow ( 10 , n - 1 ) )\ndef largestSum ( n ) :\n    return ( 2 * ( pow ( 10 , n ) - 1 ) )\nn = 4\nprint ( \"Largest = \" , largestSum ( n ) )\nprint ( \"Smallest = \" , smallestSum ( n ) )\n", "python_code_tokenized": "def smallestSum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 2 * pow ( 10 , n - 1 ) ) NEW_LINE DEDENT def largestSum ( n ) : NEW_LINE INDENT return ( 2 * ( pow ( 10 , n ) - 1 ) ) NEW_LINE DEDENT n = 4 NEW_LINE print ( \" Largest \u2581 = \u2581 \" , largestSum ( n ) ) NEW_LINE print ( \" Smallest \u2581 = \u2581 \" , smallestSum ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_430_A", "sol": 0, "python_code": "def findPairs ( arr , n ) :\n    cntEven = 0 ; cntOdd = 0 ;\n    for i in range ( n ) :\n        if ( arr [ i ] % 2 == 0 ) :\n            cntEven += 1 ;\n        else :\n            cntOdd += 1 ;\n    evenPairs = 0 ;\n    evenPairs += ( ( cntEven * ( cntEven - 1 ) ) // 2 ) ;\n    evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) // 2 ) ;\n    oddPairs = 0 ;\n    oddPairs += ( cntEven * cntOdd ) ;\n    print ( \"Odd pairs = \" , oddPairs ) ;\n    print ( \"Even pairs = \" , evenPairs ) ;\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 3 , 4 , 5 ] ;\n    n = len ( arr ) ;\n    findPairs ( arr , n ) ;\n", "python_code_tokenized": "def findPairs ( arr , n ) : NEW_LINE INDENT cntEven = 0 ; cntOdd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT cntEven += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cntOdd += 1 ; NEW_LINE DEDENT DEDENT evenPairs = 0 ; NEW_LINE evenPairs += ( ( cntEven * ( cntEven - 1 ) ) // 2 ) ; NEW_LINE evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) // 2 ) ; NEW_LINE oddPairs = 0 ; NEW_LINE oddPairs += ( cntEven * cntOdd ) ; NEW_LINE print ( \" Odd \u2581 pairs \u2581 = \u2581 \" , oddPairs ) ; NEW_LINE print ( \" Even \u2581 pairs \u2581 = \u2581 \" , evenPairs ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findPairs ( arr , n ) ; NEW_LINE DEDENT"}
{"id": "codeforces_581_B", "sol": 0, "python_code": "n = int ( input ( ) )\narr = list ( map ( int , input ( ).strip ( ).split ( ) ) ) [ : n ]\nans = [ 0 ] * n\nmx = arr [ - 1 ]\nfor i in range ( n - 2 , - 1 , - 1 ) :\n    ans [ i ] = max ( 0 , mx - arr [ i ] + 1 )\n    if arr [ i ] > mx :\n        mx = arr [ i ]\nprint ( * ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) [ : n ] NEW_LINE ans = [ 0 ] * n NEW_LINE mx = arr [ - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT ans [ i ] = max ( 0 , mx - arr [ i ] + 1 ) NEW_LINE if arr [ i ] > mx : NEW_LINE INDENT mx = arr [ i ] NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE"}
{"id": "geeksforgeeks_1173_A", "sol": 0, "python_code": "def index ( i ) :\n    return 1 + ( i >> 31 ) - ( - i >> 31 )\ndef check ( n ) :\n    s = \"negative\" , \"zero\" , \"positive\"\n    val = index ( n )\n    print ( n , \"is\" , s [ val ] )\ncheck ( 30 )\ncheck ( - 20 )\ncheck ( 0 )\n", "python_code_tokenized": "def index ( i ) : NEW_LINE INDENT return 1 + ( i >> 31 ) - ( - i >> 31 ) NEW_LINE DEDENT def check ( n ) : NEW_LINE INDENT s = \" negative \" , \" zero \" , \" positive \" NEW_LINE val = index ( n ) NEW_LINE print ( n , \" is \" , s [ val ] ) NEW_LINE DEDENT check ( 30 ) NEW_LINE check ( - 20 ) NEW_LINE check ( 0 ) NEW_LINE"}
{"id": "codeforces_253_A", "sol": 0, "python_code": "with open ( \"input.txt\" , \"r\" ) as inp :\n    n , m = map ( int , inp.read ( ).split ( ) )\nres = \"\"\nif m >= n :\n    for i in range ( n ) :\n        res += \"GB\"\n    res += \"G\" * ( m - n )\nelse :\n    for i in range ( m ) :\n        res += \"BG\"\n    res += \"B\" * ( n - m )\nwith open ( \"output.txt\" , \"w\" ) as out :\n    out.write ( res )\n", "python_code_tokenized": "with open ( \" input . txt \" , \" r \" ) as inp : NEW_LINE INDENT n , m = map ( int , inp . read ( ) . split ( ) ) NEW_LINE DEDENT res = \" \" NEW_LINE if m >= n : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT res += \" GB \" NEW_LINE DEDENT res += \" G \" * ( m - n ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res += \" BG \" NEW_LINE DEDENT res += \" B \" * ( n - m ) NEW_LINE DEDENT with open ( \" output . txt \" , \" w \" ) as out : NEW_LINE INDENT out . write ( res ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_845_A", "sol": 0, "python_code": "def prMultiples ( N ) :\n    for i in range ( 1 , N + 1 ) :\n        for j in range ( 1 , i + 1 ) :\n            print ( ( i * j ) , end = \" \" )\n        print ( )\nif __name__ == '__main__' :\n    N = 5\n    prMultiples ( N )\n", "python_code_tokenized": "def prMultiples ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( ( i * j ) , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE prMultiples ( N ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4320_A", "sol": 0, "python_code": "def multiply ( a , n ) :\n    if n == 0 :\n        return ( a [ n ] )\n    else :\n        return ( a [ n ] * multiply ( a , n - 1 ) )\narray = [ 1 , 2 , 3 , 4 , 5 , 6 ]\nn = len ( array )\nprint ( multiply ( array , n - 1 ) )\n", "python_code_tokenized": "def multiply ( a , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return ( a [ n ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( a [ n ] * multiply ( a , n - 1 ) ) NEW_LINE DEDENT DEDENT array = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( array ) NEW_LINE print ( multiply ( array , n - 1 ) ) NEW_LINE"}
{"id": "codeforces_1055_B", "sol": 0, "python_code": "n , m , l = map ( int , input ( ).split ( ) )\ni = 0\ntim = 0\nres = [ ]\na = list ( map ( int , input ( ).split ( ) ) )\nwhile i < n :\n    while i < n and a [ i ] <= l :\n        i += 1 ;\n    if i == n :\n        break\n    tim += 1 ;\n    while i < n and a [ i ] > l :\n        i += 1 ;\nfor i in range ( m ) :\n    s = input ( )\n    if s == '0' :\n        res.append ( str ( tim ) )\n        continue\n    w , p , d = map ( int , s.split ( ) )\n    p -= 1 ;\n    if a [ p ] > l :\n        continue\n    a [ p ] += d ;\n    if a [ p ] <= l :\n        continue\n    if p > 0 and a [ p - 1 ] > l and p < n - 1 and a [ p + 1 ] > l :\n        tim -= 1 ;\n    elif ( p > 0 and a [ p - 1 ] > l ) or ( p < n - 1 and a [ p + 1 ] > l ) :\n        continue\n    else :\n        tim += 1 ;\nfor i in res :\n    print ( i )\n", "python_code_tokenized": "n , m , l = map ( int , input ( ) . split ( ) ) NEW_LINE i = 0 NEW_LINE tim = 0 NEW_LINE res = [ ] NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE while i < n : NEW_LINE INDENT while i < n and a [ i ] <= l : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT if i == n : NEW_LINE INDENT break NEW_LINE DEDENT tim += 1 ; NEW_LINE while i < n and a [ i ] > l : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s == '0' : NEW_LINE INDENT res . append ( str ( tim ) ) NEW_LINE continue NEW_LINE DEDENT w , p , d = map ( int , s . split ( ) ) NEW_LINE p -= 1 ; NEW_LINE if a [ p ] > l : NEW_LINE INDENT continue NEW_LINE DEDENT a [ p ] += d ; NEW_LINE if a [ p ] <= l : NEW_LINE INDENT continue NEW_LINE DEDENT if p > 0 and a [ p - 1 ] > l and p < n - 1 and a [ p + 1 ] > l : NEW_LINE INDENT tim -= 1 ; NEW_LINE DEDENT elif ( p > 0 and a [ p - 1 ] > l ) or ( p < n - 1 and a [ p + 1 ] > l ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT tim += 1 ; NEW_LINE DEDENT DEDENT for i in res : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC032_D", "sol": 0, "python_code": "N , A , B = map ( int , input ( ).split ( ) )\np = list ( map ( int , input ( ).split ( ) ) )\np = [ p [ i ] - 1 for i in range ( N ) ]\ndp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N ) ]\nfor j in range ( N + 1 ) :\n    if p [ 0 ] <= j :\n        dp [ 0 ] [ j ] = 0\n    else :\n        dp [ 0 ] [ j ] = A\nfor i in range ( 1 , N ) :\n    for j in range ( N + 1 ) :\n        if p [ i ] <= j :\n            dp [ i ] [ j ] = min ( dp [ i - 1 ] [ p [ i ] ] , dp [ i - 1 ] [ j ] + B )\n        else :\n            dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + A\nprint ( dp [ - 1 ] [ N ] )\n", "python_code_tokenized": "N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p = [ p [ i ] - 1 for i in range ( N ) ] NEW_LINE dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N ) ] NEW_LINE for j in range ( N + 1 ) : NEW_LINE INDENT if p [ 0 ] <= j : NEW_LINE INDENT dp [ 0 ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ j ] = A NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT if p [ i ] <= j : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i - 1 ] [ p [ i ] ] , dp [ i - 1 ] [ j ] + B ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + A NEW_LINE DEDENT DEDENT DEDENT print ( dp [ - 1 ] [ N ] ) NEW_LINE"}
{"id": "geeksforgeeks_3204_A", "sol": 0, "python_code": "max = 50009\ndef find_Indices ( arr , n ) :\n    sum = [ 0 for i in range ( max ) ]\n    k = 0\n    for i in range ( 1 , n + 1 ) :\n        sum [ i ] = sum [ i - 1 ] + arr [ k ] ;\n        k += 1\n    ans = - ( 1e15 )\n    index_1 = index_2 = index_3 = - 1\n    for l in range ( n + 1 ) :\n        index = 0\n        vmin = ( 1e15 )\n        for r in range ( l , n + 1 ) :\n            if ( sum [ r ] < vmin ) :\n                vmin = sum [ r ]\n                index = r\n            if ( sum [ l ] + sum [ r ] - vmin > ans ) :\n                ans = sum [ l ] + sum [ r ] - vmin\n                index_1 = l\n                index_2 = index\n                index_3 = r\n    print ( index_1 , \" \" , index_2 , \" \" , index_3 )\narr = [ - 1 , 2 , 3 ]\nn = len ( arr )\nfind_Indices ( arr , n )\n", "python_code_tokenized": "max = 50009 NEW_LINE def find_Indices ( arr , n ) : NEW_LINE INDENT sum = [ 0 for i in range ( max ) ] NEW_LINE k = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ k ] ; NEW_LINE k += 1 NEW_LINE DEDENT ans = - ( 1e15 ) NEW_LINE index_1 = index_2 = index_3 = - 1 NEW_LINE for l in range ( n + 1 ) : NEW_LINE INDENT index = 0 NEW_LINE vmin = ( 1e15 ) NEW_LINE for r in range ( l , n + 1 ) : NEW_LINE INDENT if ( sum [ r ] < vmin ) : NEW_LINE INDENT vmin = sum [ r ] NEW_LINE index = r NEW_LINE DEDENT if ( sum [ l ] + sum [ r ] - vmin > ans ) : NEW_LINE INDENT ans = sum [ l ] + sum [ r ] - vmin NEW_LINE index_1 = l NEW_LINE index_2 = index NEW_LINE index_3 = r NEW_LINE DEDENT DEDENT DEDENT print ( index_1 , \" \u2581 \" , index_2 , \" \u2581 \" , index_3 ) NEW_LINE DEDENT arr = [ - 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE find_Indices ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_2509_A", "sol": 0, "python_code": "def maxDistance ( array ) :\n    max1 = - 2147483648\n    min1 = + 2147483647\n    max2 = - 2147483648\n    min2 = + 2147483647\n    for i in range ( len ( array ) ) :\n        max1 = max ( max1 , array [ i ] + i )\n        min1 = min ( min1 , array [ i ] + i )\n        max2 = max ( max2 , array [ i ] - i )\n        min2 = min ( min2 , array [ i ] - i )\n    return max ( max1 - min1 , max2 - min2 )\narray = [ - 70 , - 64 , - 6 , - 56 , 64 , 61 , - 57 , 16 , 48 , - 98 ]\nprint ( maxDistance ( array ) )\n", "python_code_tokenized": "def maxDistance ( array ) : NEW_LINE INDENT max1 = - 2147483648 NEW_LINE min1 = + 2147483647 NEW_LINE max2 = - 2147483648 NEW_LINE min2 = + 2147483647 NEW_LINE for i in range ( len ( array ) ) : NEW_LINE INDENT max1 = max ( max1 , array [ i ] + i ) NEW_LINE min1 = min ( min1 , array [ i ] + i ) NEW_LINE max2 = max ( max2 , array [ i ] - i ) NEW_LINE min2 = min ( min2 , array [ i ] - i ) NEW_LINE DEDENT return max ( max1 - min1 , max2 - min2 ) NEW_LINE DEDENT array = [ - 70 , - 64 , - 6 , - 56 , 64 , 61 , - 57 , 16 , 48 , - 98 ] NEW_LINE print ( maxDistance ( array ) ) NEW_LINE"}
{"id": "atcoder_AGC003_C", "sol": 0, "python_code": "N = int ( input ( ) )\nA = [ int ( input ( ) ) * N + i for i in range ( N ) ]\nA.sort ( )\ncnt = 0\nfor i in range ( N ) :\n    d = ( A [ i ] % N ) % 2\n    if d % 2 != i % 2 :\n        cnt += 1\nprint ( cnt // 2 )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE A = [ int ( input ( ) ) * N + i for i in range ( N ) ] NEW_LINE A . sort ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT d = ( A [ i ] % N ) % 2 NEW_LINE if d % 2 != i % 2 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt // 2 ) NEW_LINE"}
{"id": "geeksforgeeks_1540_A", "sol": 0, "python_code": "def countRotations ( arr , n ) :\n    min = arr [ 0 ]\n    for i in range ( 0 , n ) :\n        if ( min > arr [ i ] ) :\n            min = arr [ i ]\n            min_index = i\n    return min_index ;\narr = [ 15 , 18 , 2 , 3 , 6 , 12 ]\nn = len ( arr )\nprint ( countRotations ( arr , n ) )\n", "python_code_tokenized": "def countRotations ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( min > arr [ i ] ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE min_index = i NEW_LINE DEDENT DEDENT return min_index ; NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , n ) ) NEW_LINE"}
{"id": "aizu_p00600_A", "sol": 0, "python_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nimport heapq\nwhile True :\n    s , d = map ( int , input ( ).split ( ) )\n    if s == 0 : break\n    visited = [ 0 ] * 100\n    Q = [ ]\n    to = [ [ ] for i in range ( 100 ) ]\n    for i in range ( s ) :\n        visited [ i ] = 1\n        c = list ( map ( int , input ( ).split ( ) ) )\n        for j in range ( d ) :\n            if c [ j ] > 0 : heapq.heappush ( Q , ( c [ j ] , i , s + j ) )\n    for i in range ( d - 1 ) :\n        c = list ( map ( int , input ( ).split ( ) ) )\n        for j in range ( i + 1 , d ) :\n            if c [ j - i - 1 ] > 0 :\n                to [ s + i ].append ( ( s + j , c [ j - i - 1 ] ) )\n                to [ s + j ].append ( ( s + i , c [ j - i - 1 ] ) )\n    ans = k = 0\n    while k < d :\n        while True :\n            c , a , b = heapq.heappop ( Q )\n            if visited [ a ] == 0 or visited [ b ] == 0 : break\n        ans , k = ans + c , k + 1\n        if visited [ a ] : a = b\n        visited [ a ] = 1 ;\n        for e , c in to [ a ] :\n            if visited [ e ] == 0 : heapq.heappush ( Q , ( c , a , e ) )\n    print ( ans )\n", "python_code_tokenized": "import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE import heapq NEW_LINE while True : NEW_LINE INDENT s , d = map ( int , input ( ) . split ( ) ) NEW_LINE if s == 0 : break NEW_LINE visited = [ 0 ] * 100 NEW_LINE Q = [ ] NEW_LINE to = [ [ ] for i in range ( 100 ) ] NEW_LINE for i in range ( s ) : NEW_LINE INDENT visited [ i ] = 1 NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( d ) : NEW_LINE INDENT if c [ j ] > 0 : heapq . heappush ( Q , ( c [ j ] , i , s + j ) ) NEW_LINE DEDENT DEDENT for i in range ( d - 1 ) : NEW_LINE INDENT c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( i + 1 , d ) : NEW_LINE INDENT if c [ j - i - 1 ] > 0 : NEW_LINE INDENT to [ s + i ] . append ( ( s + j , c [ j - i - 1 ] ) ) NEW_LINE to [ s + j ] . append ( ( s + i , c [ j - i - 1 ] ) ) NEW_LINE DEDENT DEDENT DEDENT ans = k = 0 NEW_LINE while k < d : NEW_LINE INDENT while True : NEW_LINE INDENT c , a , b = heapq . heappop ( Q ) NEW_LINE if visited [ a ] == 0 or visited [ b ] == 0 : break NEW_LINE DEDENT ans , k = ans + c , k + 1 NEW_LINE if visited [ a ] : a = b NEW_LINE visited [ a ] = 1 ; NEW_LINE for e , c in to [ a ] : NEW_LINE INDENT if visited [ e ] == 0 : heapq . heappush ( Q , ( c , a , e ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "aizu_p00147_A", "sol": 0, "python_code": "S = 17\nseat = [ [ 0 for t in range ( 27 ) ] for id in range ( 27 ) ]\nans = [ 0 ] * 105\nid = 0\nQ = [ ]\nfor i in range ( S ) : seat [ i ] [ 0 ] = - 1\nt = - 1\nwhile ans [ 99 ] == 0 :\n    t += 1\n    if t % 5 == 0 and id <= 99 :\n        n = 5 if ( id % 5 ) == 1 else 2\n        Q.append ( ( id , n , t ) )\n        id += 1\n    for i in range ( S ) :\n        if seat [ i ] [ 1 ] == 0 : continue\n        seat [ i ] [ 1 ] -= 1\n        if seat [ i ] [ 1 ] == 0 : seat [ i ] [ 0 ] = - 1\n    f = len ( Q )\n    while f > 0 :\n        i , n = Q [ 0 ] [ 0 ] , Q [ 0 ] [ 1 ]\n        f = 0 ;\n        for j in range ( S ) :\n            g = 0\n            for k in range ( n ) :\n                if seat [ j + k ] [ 0 ] >= 0 :\n                    g = 1\n                    break\n            if g : continue\n            ans [ i ] = t - Q [ 0 ] [ 2 ]\n            del Q [ 0 ]\n            f = len ( Q )\n            for k in range ( n ) :\n                seat [ j + k ] [ 0 ] = i\n                seat [ j + k ] [ 1 ] = 17 * ( i & 1 ) + 3 * ( i % 3 ) + 19\n            break\nwhile 1 :\n    try : n = int ( input ( ) )\n    except : break\n    print ( ans [ n ] )\n", "python_code_tokenized": "S = 17 NEW_LINE seat = [ [ 0 for t in range ( 27 ) ] for id in range ( 27 ) ] NEW_LINE ans = [ 0 ] * 105 NEW_LINE id = 0 NEW_LINE Q = [ ] NEW_LINE for i in range ( S ) : seat [ i ] [ 0 ] = - 1 NEW_LINE t = - 1 NEW_LINE while ans [ 99 ] == 0 : NEW_LINE INDENT t += 1 NEW_LINE if t % 5 == 0 and id <= 99 : NEW_LINE INDENT n = 5 if ( id % 5 ) == 1 else 2 NEW_LINE Q . append ( ( id , n , t ) ) NEW_LINE id += 1 NEW_LINE DEDENT for i in range ( S ) : NEW_LINE INDENT if seat [ i ] [ 1 ] == 0 : continue NEW_LINE seat [ i ] [ 1 ] -= 1 NEW_LINE if seat [ i ] [ 1 ] == 0 : seat [ i ] [ 0 ] = - 1 NEW_LINE DEDENT f = len ( Q ) NEW_LINE while f > 0 : NEW_LINE INDENT i , n = Q [ 0 ] [ 0 ] , Q [ 0 ] [ 1 ] NEW_LINE f = 0 ; NEW_LINE for j in range ( S ) : NEW_LINE INDENT g = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if seat [ j + k ] [ 0 ] >= 0 : NEW_LINE INDENT g = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if g : continue NEW_LINE ans [ i ] = t - Q [ 0 ] [ 2 ] NEW_LINE del Q [ 0 ] NEW_LINE f = len ( Q ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT seat [ j + k ] [ 0 ] = i NEW_LINE seat [ j + k ] [ 1 ] = 17 * ( i & 1 ) + 3 * ( i % 3 ) + 19 NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT DEDENT while 1 : NEW_LINE INDENT try : n = int ( input ( ) ) NEW_LINE except : break NEW_LINE print ( ans [ n ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3888_A", "sol": 0, "python_code": "class Queue :\n    def __init__ ( self ) :\n        self.items = [ ]\n    def isEmpty ( self ) :\n        return self.items == [ ]\n    def add ( self , item ) :\n        self.items.append ( item )\n    def pop ( self ) :\n        return self.items.pop ( 0 )\n    def front ( self ) :\n        return self.items [ 0 ]\n    def printQueue ( self ) :\n        for i in self.items :\n            print ( i , end = \"\" )\n        print ( \"\" )\ndef reverseQueue ( q ) :\n    if ( q.isEmpty ( ) ) :\n        return\n    data = q.front ( ) ;\n    q.pop ( ) ;\n    reverseQueue ( q )\n    q.add ( data )\nq = Queue ( )\nq.add ( 56 )\nq.add ( 27 )\nq.add ( 30 )\nq.add ( 45 )\nq.add ( 85 )\nq.add ( 92 )\nq.add ( 58 )\nq.add ( 80 )\nq.add ( 90 )\nq.add ( 100 )\nreverseQueue ( q )\nq.printQueue ( )\n", "python_code_tokenized": "class Queue : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . items = [ ] NEW_LINE DEDENT def isEmpty ( self ) : NEW_LINE INDENT return self . items == [ ] NEW_LINE DEDENT def add ( self , item ) : NEW_LINE INDENT self . items . append ( item ) NEW_LINE DEDENT def pop ( self ) : NEW_LINE INDENT return self . items . pop ( 0 ) NEW_LINE DEDENT def front ( self ) : NEW_LINE INDENT return self . items [ 0 ] NEW_LINE DEDENT def printQueue ( self ) : NEW_LINE INDENT for i in self . items : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT DEDENT def reverseQueue ( q ) : NEW_LINE INDENT if ( q . isEmpty ( ) ) : NEW_LINE INDENT return NEW_LINE DEDENT data = q . front ( ) ; NEW_LINE q . pop ( ) ; NEW_LINE reverseQueue ( q ) NEW_LINE q . add ( data ) NEW_LINE DEDENT q = Queue ( ) NEW_LINE q . add ( 56 ) NEW_LINE q . add ( 27 ) NEW_LINE q . add ( 30 ) NEW_LINE q . add ( 45 ) NEW_LINE q . add ( 85 ) NEW_LINE q . add ( 92 ) NEW_LINE q . add ( 58 ) NEW_LINE q . add ( 80 ) NEW_LINE q . add ( 90 ) NEW_LINE q . add ( 100 ) NEW_LINE reverseQueue ( q ) NEW_LINE q . printQueue ( ) NEW_LINE"}
{"id": "geeksforgeeks_4_A", "sol": 0, "python_code": "def func ( a , k , n ) :\n    for i in range ( 0 , n ) :\n        if ( a [ i ] % k == 0 ) :\n            return True\na = [ 14 , 27 , 38 , 76 , 84 ]\nk = 19\nres = func ( a , k , 5 )\nif ( res ) :\n    print ( \"true\" )\nelse :\n    print ( \"false\" )\n", "python_code_tokenized": "def func ( a , k , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT a = [ 14 , 27 , 38 , 76 , 84 ] NEW_LINE k = 19 NEW_LINE res = func ( a , k , 5 ) NEW_LINE if ( res ) : NEW_LINE INDENT print ( \" true \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" false \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4325_A", "sol": 0, "python_code": "N = 4\ndef areSame ( A , B ) :\n    for i in range ( N ) :\n        for j in range ( N ) :\n            if ( A [ i ] [ j ] != B [ i ] [ j ] ) :\n                return 0\n    return 1\nA = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ]\nB = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ]\nif ( areSame ( A , B ) == 1 ) :\n    print ( \"Matrices are identical\" )\nelse :\n    print ( \"Matrices are not identical\" )\n", "python_code_tokenized": "N = 4 NEW_LINE def areSame ( A , B ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( A [ i ] [ j ] != B [ i ] [ j ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return 1 NEW_LINE DEDENT A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE if ( areSame ( A , B ) == 1 ) : NEW_LINE INDENT print ( \" Matrices \u2581 are \u2581 identical \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Matrices \u2581 are \u2581 not \u2581 identical \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4936_A", "sol": 0, "python_code": "MAX = 1005\ndef shortestSeq ( S : list , T : list ) :\n    m = len ( S )\n    n = len ( T )\n    dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ]\n    for i in range ( m + 1 ) :\n        dp [ i ] [ 0 ] = 1\n    for i in range ( n + 1 ) :\n        dp [ 0 ] [ i ] = MAX\n    for i in range ( 1 , m + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            ch = S [ i - 1 ]\n            k = j - 1\n            while k >= 0 :\n                if T [ k ] == ch :\n                    break\n                k -= 1\n            if k == - 1 :\n                dp [ i ] [ j ] = 1\n            else :\n                dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 )\n    ans = dp [ m ] [ n ]\n    if ans >= MAX :\n        ans = - 1\n    return ans\nif __name__ == \"__main__\" :\n    S = \"babab\"\n    T = \"babba\"\n    print ( \"Length of shortest subsequence is:\" , shortestSeq ( S , T ) )\n", "python_code_tokenized": "MAX = 1005 NEW_LINE def shortestSeq ( S : list , T : list ) : NEW_LINE INDENT m = len ( S ) NEW_LINE n = len ( T ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = MAX NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT ch = S [ i - 1 ] NEW_LINE k = j - 1 NEW_LINE while k >= 0 : NEW_LINE INDENT if T [ k ] == ch : NEW_LINE INDENT break NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT if k == - 1 : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT ans = dp [ m ] [ n ] NEW_LINE if ans >= MAX : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" babab \" NEW_LINE T = \" babba \" NEW_LINE print ( \" Length \u2581 of \u2581 shortest \u2581 subsequence \u2581 is : \" , shortestSeq ( S , T ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_197_A", "sol": 0, "python_code": "def makePolygon ( a ) :\n    n = 360 / ( 180 - a )\n    if n == int ( n ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\nif __name__ == \"__main__\" :\n    a = 90\n    makePolygon ( a )\n", "python_code_tokenized": "def makePolygon ( a ) : NEW_LINE INDENT n = 360 / ( 180 - a ) NEW_LINE if n == int ( n ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 90 NEW_LINE makePolygon ( a ) NEW_LINE DEDENT"}
{"id": "codeforces_1508_B", "sol": 0, "python_code": "for s in [ * open ( 0 ) ] [ 1 : ] :\n    n , k = map ( int , s.split ( ) ) ; v = bin ( k - 1 ) [ 2 : ]\n    if k > 1 : v += '0'\n    if len ( v ) > n : print ( - 1 ) ; continue\n    v = v.rjust ( n , '0' ) ; a = [ ] ; t = [ ]\n    for i in range ( n ) :\n        t += str ( i + 1 ) ,\n        if v [ i ] < '1' : a += t [ : : - 1 ] ; t = [ ]\n    print ( * a )\n", "python_code_tokenized": "for s in [ * open ( 0 ) ] [ 1 : ] : NEW_LINE INDENT n , k = map ( int , s . split ( ) ) ; v = bin ( k - 1 ) [ 2 : ] NEW_LINE if k > 1 : v += '0' NEW_LINE if len ( v ) > n : print ( - 1 ) ; continue NEW_LINE v = v . rjust ( n , '0' ) ; a = [ ] ; t = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT t += str ( i + 1 ) , NEW_LINE if v [ i ] < '1' : a += t [ : : - 1 ] ; t = [ ] NEW_LINE DEDENT print ( * a ) NEW_LINE DEDENT"}
{"id": "aizu_p00335_A", "sol": 0, "python_code": "import sys\nsys.setrecursionlimit ( 10 ** 6 )\nn = int ( input ( ) )\n* P , = map ( int , input ( ).split ( ) )\nmemo = { ( n - 1 , i ) : i for i in range ( P [ - 1 ] + 1 ) }\ndef dfs ( pos , t ) :\n    if ( pos , t ) in memo :\n        return memo [ pos , t ]\n    res = memo [ pos , t ] = dfs ( pos + 1 , max ( 0 , P [ pos + 1 ] - t ) ) + t * 2\n    return res\nprint ( min ( dfs ( 0 , P [ 0 ] - i ) + i for i in range ( P [ 0 ] + 1 ) ) )\n", "python_code_tokenized": "import sys NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE n = int ( input ( ) ) NEW_LINE * P , = map ( int , input ( ) . split ( ) ) NEW_LINE memo = { ( n - 1 , i ) : i for i in range ( P [ - 1 ] + 1 ) } NEW_LINE def dfs ( pos , t ) : NEW_LINE INDENT if ( pos , t ) in memo : NEW_LINE INDENT return memo [ pos , t ] NEW_LINE DEDENT res = memo [ pos , t ] = dfs ( pos + 1 , max ( 0 , P [ pos + 1 ] - t ) ) + t * 2 NEW_LINE return res NEW_LINE DEDENT print ( min ( dfs ( 0 , P [ 0 ] - i ) + i for i in range ( P [ 0 ] + 1 ) ) ) NEW_LINE"}
{"id": "codeforces_433_B", "sol": 0, "python_code": "def solve ( ) :\n    n = int ( input ( ) )\n    stones = [ int ( x ) for x in input ( ).split ( \" \" , n ) ]\n    total1 = [ 0 ] * ( len ( stones ) + 1 )\n    for i in range ( 1 , len ( stones ) + 1 ) :\n        total1 [ i ] = stones [ i - 1 ] + total1 [ i - 1 ]\n    total2 = [ 0 ] * ( len ( stones ) + 1 )\n    stones.sort ( )\n    for i in range ( 1 , len ( stones ) + 1 ) :\n        total2 [ i ] = stones [ i - 1 ] + total2 [ i - 1 ]\n    m = int ( input ( ) )\n    for i in range ( m ) :\n        x = [ int ( x ) for x in input ( ).split ( \" \" , 3 ) ]\n        if x [ 0 ] == 1 :\n            print ( total1 [ x [ 2 ] ] - total1 [ x [ 1 ] - 1 ] )\n        else :\n            print ( total2 [ x [ 2 ] ] - total2 [ x [ 1 ] - 1 ] )\nsolve ( )\n", "python_code_tokenized": "def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE stones = [ int ( x ) for x in input ( ) . split ( \" \u2581 \" , n ) ] NEW_LINE total1 = [ 0 ] * ( len ( stones ) + 1 ) NEW_LINE for i in range ( 1 , len ( stones ) + 1 ) : NEW_LINE INDENT total1 [ i ] = stones [ i - 1 ] + total1 [ i - 1 ] NEW_LINE DEDENT total2 = [ 0 ] * ( len ( stones ) + 1 ) NEW_LINE stones . sort ( ) NEW_LINE for i in range ( 1 , len ( stones ) + 1 ) : NEW_LINE INDENT total2 [ i ] = stones [ i - 1 ] + total2 [ i - 1 ] NEW_LINE DEDENT m = int ( input ( ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT x = [ int ( x ) for x in input ( ) . split ( \" \u2581 \" , 3 ) ] NEW_LINE if x [ 0 ] == 1 : NEW_LINE INDENT print ( total1 [ x [ 2 ] ] - total1 [ x [ 1 ] - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( total2 [ x [ 2 ] ] - total2 [ x [ 1 ] - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT solve ( ) NEW_LINE"}
{"id": "geeksforgeeks_1940_A", "sol": 0, "python_code": "def largestSubStr ( s ) :\n    while ( len ( s ) and s [ len ( s ) - 1 ] == '1' ) :\n        s = s [ : len ( s ) - 1 ] ;\n    if ( len ( s ) == 0 ) :\n        return \"-1\" ;\n    else :\n        return s ;\nif __name__ == \"__main__\" :\n    s = \"11001\" ;\n    print ( largestSubStr ( s ) ) ;\n", "python_code_tokenized": "def largestSubStr ( s ) : NEW_LINE INDENT while ( len ( s ) and s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT s = s [ : len ( s ) - 1 ] ; NEW_LINE DEDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return \" - 1\" ; NEW_LINE DEDENT else : NEW_LINE INDENT return s ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"11001\" ; NEW_LINE print ( largestSubStr ( s ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_954_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = input ( )\nminn = 101\nfor i in range ( n // 2 + 1 ) :\n    s = a [ : i ] * 2 + a [ i * 2 : ]\n    if ( s == a ) :\n        minn = min ( minn , i + 1 * int ( i != 0 ) + ( n - i * 2 ) )\nprint ( minn )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = input ( ) NEW_LINE minn = 101 NEW_LINE for i in range ( n // 2 + 1 ) : NEW_LINE INDENT s = a [ : i ] * 2 + a [ i * 2 : ] NEW_LINE if ( s == a ) : NEW_LINE INDENT minn = min ( minn , i + 1 * int ( i != 0 ) + ( n - i * 2 ) ) NEW_LINE DEDENT DEDENT print ( minn ) NEW_LINE"}
{"id": "aizu_p02497_A", "sol": 0, "python_code": "while True :\n    m , f , r = map ( int , raw_input ( ).split ( ) )\n    s = m + f\n    if m == f == r == - 1 :\n        break\n    elif m == - 1 or f == - 1 or s < 30 :\n        print ( 'F' )\n    elif s >= 80 :\n        print ( 'A' )\n    elif 65 <= s < 80 :\n        print ( 'B' )\n    elif 50 <= s < 65 :\n        print ( 'C' )\n    elif 30 <= s < 50 and r >= 50 :\n        print ( 'C' )\n    else :\n        print ( 'D' )\n", "python_code_tokenized": "while True : NEW_LINE INDENT m , f , r = map ( int , raw_input ( ) . split ( ) ) NEW_LINE s = m + f NEW_LINE if m == f == r == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT elif m == - 1 or f == - 1 or s < 30 : NEW_LINE INDENT print ( ' F ' ) NEW_LINE DEDENT elif s >= 80 : NEW_LINE INDENT print ( ' A ' ) NEW_LINE DEDENT elif 65 <= s < 80 : NEW_LINE INDENT print ( ' B ' ) NEW_LINE DEDENT elif 50 <= s < 65 : NEW_LINE INDENT print ( ' C ' ) NEW_LINE DEDENT elif 30 <= s < 50 and r >= 50 : NEW_LINE INDENT print ( ' C ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' D ' ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2383_A", "sol": 0, "python_code": "def isTidy ( num ) :\n    prev = 10\n    while ( num ) :\n        rem = num % 10\n        num /= 10\n        if rem > prev :\n            return False\n        prev = rem\n    return True\nnum = 1556\nif isTidy ( num ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def isTidy ( num ) : NEW_LINE INDENT prev = 10 NEW_LINE while ( num ) : NEW_LINE INDENT rem = num % 10 NEW_LINE num /= 10 NEW_LINE if rem > prev : NEW_LINE INDENT return False NEW_LINE DEDENT prev = rem NEW_LINE DEDENT return True NEW_LINE DEDENT num = 1556 NEW_LINE if isTidy ( num ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1515_A", "sol": 0, "python_code": "for i in range ( int ( input ( ) ) ) :\n    n , x = map ( int , input ( ).split ( ) )\n    w = list ( map ( int , input ( ).split ( ) ) )\n    if sum ( w ) == x :\n        print ( 'NO' )\n    else :\n        print ( 'YES' )\n        j = 0\n        s = 0\n        while j < n :\n            s += w [ j ]\n            if s == x :\n                w [ j ] , w [ j + 1 ] = w [ j + 1 ] , w [ j ]\n                break\n            j += 1\n        print ( * w )\n", "python_code_tokenized": "for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , x = map ( int , input ( ) . split ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if sum ( w ) == x : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE j = 0 NEW_LINE s = 0 NEW_LINE while j < n : NEW_LINE INDENT s += w [ j ] NEW_LINE if s == x : NEW_LINE INDENT w [ j ] , w [ j + 1 ] = w [ j + 1 ] , w [ j ] NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT print ( * w ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4028_A", "sol": 0, "python_code": "def isRectangle ( a , b , c , d ) :\n    if a == b == c == d :\n        return True\n    elif a == b and c == d :\n        return True\n    elif a == d and c == b :\n        return True\n    elif a == c and d == b :\n        return True\n    return False\na , b , c , d = 1 , 2 , 3 , 4\nprint ( \"Yes\" if isRectangle ( a , b , c , d ) else \"No\" )\n", "python_code_tokenized": "def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if a == b == c == d : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == b and c == d : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == d and c == b : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == c and d == b : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a , b , c , d = 1 , 2 , 3 , 4 NEW_LINE print ( \" Yes \" if isRectangle ( a , b , c , d ) else \" No \" ) NEW_LINE"}
{"id": "geeksforgeeks_5115_A", "sol": 0, "python_code": "def isPrime ( a , lower , upper ) :\n    n = 0\n    for i in range ( lower - 1 , upper ) :\n        n = n + a [ i ]\n    if ( n <= 1 ) :\n        return False\n    for i in range ( 2 , n ) :\n        if ( n % i == 0 ) :\n            return False\n    return True\na = [ 1 , 2 , 3 , 5 , 5 , 4 , 7 , 8 , 9 ]\nlower = 3\nupper = 6\nif ( isPrime ( a , lower , upper ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def isPrime ( a , lower , upper ) : NEW_LINE INDENT n = 0 NEW_LINE for i in range ( lower - 1 , upper ) : NEW_LINE INDENT n = n + a [ i ] NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = [ 1 , 2 , 3 , 5 , 5 , 4 , 7 , 8 , 9 ] NEW_LINE lower = 3 NEW_LINE upper = 6 NEW_LINE if ( isPrime ( a , lower , upper ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC127_B", "sol": 0, "python_code": "r , D , x = map ( int , input ( ).split ( ) )\nfor i in range ( 10 ) :\n    x = r * x - D\n    print ( x )\n", "python_code_tokenized": "r , D , x = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT x = r * x - D NEW_LINE print ( x ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_914_A", "sol": 0, "python_code": "def countDigitsToBeRemoved ( N , K ) :\n    s = str ( N ) ;\n    res = 0 ;\n    f_zero = 0 ;\n    for i in range ( len ( s ) - 1 , - 1 , - 1 ) :\n        if ( K == 0 ) :\n            return res ;\n        if ( s [ i ] == '0' ) :\n            f_zero = 1 ;\n            K -= 1 ;\n        else :\n            res += 1 ;\n    if ( K == 0 ) :\n        return res ;\n    elif ( f_zero > 0 ) :\n        return len ( s ) - 1 ;\n    return - 1 ;\nN = 10904025 ;\nK = 2 ;\nprint ( countDigitsToBeRemoved ( N , K ) ) ;\nN = 1000 ;\nK = 5 ;\nprint ( countDigitsToBeRemoved ( N , K ) ) ;\nN = 23985 ;\nK = 2 ;\nprint ( countDigitsToBeRemoved ( N , K ) ) ;\n", "python_code_tokenized": "def countDigitsToBeRemoved ( N , K ) : NEW_LINE INDENT s = str ( N ) ; NEW_LINE res = 0 ; NEW_LINE f_zero = 0 ; NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT f_zero = 1 ; NEW_LINE K -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT res += 1 ; NEW_LINE DEDENT DEDENT if ( K == 0 ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT elif ( f_zero > 0 ) : NEW_LINE INDENT return len ( s ) - 1 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT N = 10904025 ; NEW_LINE K = 2 ; NEW_LINE print ( countDigitsToBeRemoved ( N , K ) ) ; NEW_LINE N = 1000 ; NEW_LINE K = 5 ; NEW_LINE print ( countDigitsToBeRemoved ( N , K ) ) ; NEW_LINE N = 23985 ; NEW_LINE K = 2 ; NEW_LINE print ( countDigitsToBeRemoved ( N , K ) ) ; NEW_LINE"}
{"id": "projecteuler_p074_A", "sol": 0, "python_code": "import math\ndef compute ( ) :\n    LIMIT = 10 ** 6\n    ans = sum ( 1 for i in range ( LIMIT ) if get_chain_length ( i ) == 60 )\n    return str ( ans )\ndef get_chain_length ( n ) :\n    seen = set ( )\n    while True :\n        seen.add ( n )\n        n = factorialize ( n )\n        if n in seen :\n            return len ( seen )\ndef factorialize ( n ) :\n    result = 0\n    while n != 0 :\n        result += FACTORIAL [ n % 10 ]\n        n //= 10\n    return result\nFACTORIAL = [ math.factorial ( i ) for i in range ( 10 ) ]\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import math NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE ans = sum ( 1 for i in range ( LIMIT ) if get_chain_length ( i ) == 60 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def get_chain_length ( n ) : NEW_LINE INDENT seen = set ( ) NEW_LINE while True : NEW_LINE INDENT seen . add ( n ) NEW_LINE n = factorialize ( n ) NEW_LINE if n in seen : NEW_LINE INDENT return len ( seen ) NEW_LINE DEDENT DEDENT DEDENT def factorialize ( n ) : NEW_LINE INDENT result = 0 NEW_LINE while n != 0 : NEW_LINE INDENT result += FACTORIAL [ n % 10 ] NEW_LINE n //= 10 NEW_LINE DEDENT return result NEW_LINE DEDENT FACTORIAL = [ math . factorial ( i ) for i in range ( 10 ) ] NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3180_A", "sol": 0, "python_code": "from math import sqrt\ndef isPrime ( n ) :\n    if ( n == 0 or n == 1 ) :\n        return False ;\n    for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) :\n        if ( n % i == 0 ) :\n            return False ;\n    return True ;\ndef sumAscii ( string , n ) :\n    sum = 0 ;\n    for i in range ( n ) :\n        if ( isPrime ( i + 1 ) ) :\n            sum += ord ( string [ i ] ) ;\n    return sum ;\nif __name__ == \"__main__\" :\n    string = \"geeksforgeeks\" ;\n    n = len ( string ) ;\n    print ( sumAscii ( string , n ) ) ;\n", "python_code_tokenized": "from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def sumAscii ( string , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPrime ( i + 1 ) ) : NEW_LINE INDENT sum += ord ( string [ i ] ) ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( sumAscii ( string , n ) ) ; NEW_LINE DEDENT"}
{"id": "aizu_p02468_A", "sol": 0, "python_code": "m , n = map ( int , input ( ).split ( ) )\nmod = 1000000007\nres = 1\nwhile n > 0 :\n    if n & 1 == 1 :\n        res = res * m % mod\n    m = m * m % mod\n    n >>= 1\nprint ( res )\n", "python_code_tokenized": "m , n = map ( int , input ( ) . split ( ) ) NEW_LINE mod = 1000000007 NEW_LINE res = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if n & 1 == 1 : NEW_LINE INDENT res = res * m % mod NEW_LINE DEDENT m = m * m % mod NEW_LINE n >>= 1 NEW_LINE DEDENT print ( res ) NEW_LINE"}
{"id": "geeksforgeeks_4457_A", "sol": 0, "python_code": "def fact ( n ) :\n    res = 1\n    for i in range ( 2 , n + 1 , 1 ) :\n        res = res * i\n    return res\ndef nCr ( n , r ) :\n    return fact ( n ) // ( fact ( r ) * fact ( n - r ) )\ndef NumberOfWays ( X , Y , M , N ) :\n    return fact ( X + Y ) * nCr ( M , X ) * nCr ( N , Y )\nif __name__ == '__main__' :\n    X = 2\n    Y = 2\n    M = 3\n    N = 3\n    print ( NumberOfWays ( X , Y , M , N ) )\n", "python_code_tokenized": "def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) // ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT def NumberOfWays ( X , Y , M , N ) : NEW_LINE INDENT return fact ( X + Y ) * nCr ( M , X ) * nCr ( N , Y ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 2 NEW_LINE Y = 2 NEW_LINE M = 3 NEW_LINE N = 3 NEW_LINE print ( NumberOfWays ( X , Y , M , N ) ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC021_E", "sol": 0, "python_code": "mod = 998244353\ndef comb ( n , r ) :\n    if n < r : return 0\n    if n < 0 or r < 0 : return 0\n    return fa [ n ] * fi [ r ] % mod * fi [ n - r ] % mod\nn , k = map ( int , input ( ).split ( ) )\nfa = [ 1 ] * ( k + 1 )\nfi = [ 1 ] * ( k + 1 )\nfor i in range ( 1 , k + 1 ) :\n    fa [ i ] = fa [ i - 1 ] * i % mod\n    fi [ i ] = pow ( fa [ i ] , mod - 2 , mod )\nans = 0\nfor i in range ( k - n + 1 ) :\n    ans += comb ( k - 1 , n + i - 1 )\n    ans %= mod\nprint ( ans )\n", "python_code_tokenized": "mod = 998244353 NEW_LINE def comb ( n , r ) : NEW_LINE INDENT if n < r : return 0 NEW_LINE if n < 0 or r < 0 : return 0 NEW_LINE return fa [ n ] * fi [ r ] % mod * fi [ n - r ] % mod NEW_LINE DEDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE fa = [ 1 ] * ( k + 1 ) NEW_LINE fi = [ 1 ] * ( k + 1 ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT fa [ i ] = fa [ i - 1 ] * i % mod NEW_LINE fi [ i ] = pow ( fa [ i ] , mod - 2 , mod ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( k - n + 1 ) : NEW_LINE INDENT ans += comb ( k - 1 , n + i - 1 ) NEW_LINE ans %= mod NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_999_A", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nl = list ( map ( int , input ( ).split ( ) ) )\nc = 0\nm = l [ : : - 1 ]\nh = list ( filter ( lambda x : x > k , l ) )\nfor i in range ( n ) :\n    if l [ 0 ] <= k :\n        c += 1\n        l.pop ( 0 )\n    else :\n        break\nif len ( h ) > 0 :\n    for j in range ( n ) :\n        if m [ 0 ] <= k :\n            c += 1\n            m.pop ( 0 )\n        else :\n            break\nprint ( c )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE m = l [ : : - 1 ] NEW_LINE h = list ( filter ( lambda x : x > k , l ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ 0 ] <= k : NEW_LINE INDENT c += 1 NEW_LINE l . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if len ( h ) > 0 : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if m [ 0 ] <= k : NEW_LINE INDENT c += 1 NEW_LINE m . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( c ) NEW_LINE"}
{"id": "geeksforgeeks_1810_A", "sol": 0, "python_code": "import math\ndef sumofFactors ( n ) :\n    if ( n % 2 != 0 ) :\n        return 0\n    res = 1\n    for i in range ( 2 , ( int ) ( math.sqrt ( n ) ) + 1 ) :\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while ( n % i == 0 ) :\n            count = count + 1\n            n = n // i\n            if ( i == 2 and count == 1 ) :\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if ( n >= 2 ) :\n        res = res * ( 1 + n )\n    return res\nn = 18\nprint ( sumofFactors ( n ) )\n", "python_code_tokenized": "import math NEW_LINE def sumofFactors ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE n = n // i NEW_LINE if ( i == 2 and count == 1 ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE DEDENT curr_term = curr_term * i NEW_LINE curr_sum = curr_sum + curr_term NEW_LINE DEDENT res = res * curr_sum NEW_LINE DEDENT if ( n >= 2 ) : NEW_LINE INDENT res = res * ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 18 NEW_LINE print ( sumofFactors ( n ) ) NEW_LINE"}
{"id": "codeforces_1032_A", "sol": 0, "python_code": "I = lambda : map ( int , input ( ).split ( ) )\nn , k = I ( )\na = * I ( ) ,\nm = len ( { * a } )\nx = 0 - - max ( a.count ( x ) for x in { * a } ) // k\nprint ( m * x * k - n )\n", "python_code_tokenized": "I = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE n , k = I ( ) NEW_LINE a = * I ( ) , NEW_LINE m = len ( { * a } ) NEW_LINE x = 0 - - max ( a . count ( x ) for x in { * a } ) // k NEW_LINE print ( m * x * k - n ) NEW_LINE"}
{"id": "codeforces_462_B", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\ns = input ( )\ncount = [ 0 ] * 26\nfor c in s :\n    count [ ord ( c ) - ord ( \"A\" ) ] += 1\ncount.sort ( reverse = True )\nres = 0\nfor i in range ( 26 ) :\n    if count [ i ] >= k :\n        res += k * k\n        print ( res )\n        exit ( )\n    k -= count [ i ]\n    res += count [ i ] ** 2\nprint ( res )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE count = [ 0 ] * 26 NEW_LINE for c in s : NEW_LINE INDENT count [ ord ( c ) - ord ( \" A \" ) ] += 1 NEW_LINE DEDENT count . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if count [ i ] >= k : NEW_LINE INDENT res += k * k NEW_LINE print ( res ) NEW_LINE exit ( ) NEW_LINE DEDENT k -= count [ i ] NEW_LINE res += count [ i ] ** 2 NEW_LINE DEDENT print ( res ) NEW_LINE"}
{"id": "geeksforgeeks_776_A", "sol": 0, "python_code": "def findNumbers ( N ) :\n    v = [ ] ;\n    while ( N ) :\n        n , m , p = N , 0 , 1\n        while ( n ) :\n            if ( n % 10 ) :\n                m += p\n            n //= 10\n            p *= 10\n        v.append ( m ) ;\n        N -= m\n    for i in range ( len ( v ) ) :\n        print ( v [ i ] , end = \" \" )\nif __name__ == \"__main__\" :\n    N = 31\n    findNumbers ( N )\n", "python_code_tokenized": "def findNumbers ( N ) : NEW_LINE INDENT v = [ ] ; NEW_LINE while ( N ) : NEW_LINE INDENT n , m , p = N , 0 , 1 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n % 10 ) : NEW_LINE INDENT m += p NEW_LINE DEDENT n //= 10 NEW_LINE p *= 10 NEW_LINE DEDENT v . append ( m ) ; NEW_LINE N -= m NEW_LINE DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT print ( v [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 31 NEW_LINE findNumbers ( N ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1838_A", "sol": 0, "python_code": "N = 1000\ndef lastElement ( a , n ) :\n    steps = 1\n    v = [ [ ] for i in range ( n ) ]\n    if n == 1 : return a [ 0 ]\n    for i in range ( 0 , n , 2 ) :\n        v [ steps ].append ( a [ i ] | a [ i + 1 ] )\n    while len ( v [ steps ] ) > 1 :\n        steps += 1\n        for i in range ( 0 , len ( v [ steps - 1 ] ) , 2 ) :\n            if steps & 1 :\n                v [ steps ].append ( v [ steps - 1 ] [ i ] | v [ steps - 1 ] [ i + 1 ] )\n            else :\n                v [ steps ].append ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] )\n    return v [ steps ] [ 0 ]\nif __name__ == \"__main__\" :\n    a = [ 1 , 4 , 5 , 6 ]\n    n = len ( a )\n    index , value , a [ 0 ] = 0 , 2 , 2\n    print ( lastElement ( a , n ) )\n    index , value = 3 , 5\n    value = 5\n    a [ index ] = value\n    print ( lastElement ( a , n ) )\n", "python_code_tokenized": "N = 1000 NEW_LINE def lastElement ( a , n ) : NEW_LINE INDENT steps = 1 NEW_LINE v = [ [ ] for i in range ( n ) ] NEW_LINE if n == 1 : return a [ 0 ] NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT v [ steps ] . append ( a [ i ] | a [ i + 1 ] ) NEW_LINE DEDENT while len ( v [ steps ] ) > 1 : NEW_LINE INDENT steps += 1 NEW_LINE for i in range ( 0 , len ( v [ steps - 1 ] ) , 2 ) : NEW_LINE INDENT if steps & 1 : NEW_LINE INDENT v [ steps ] . append ( v [ steps - 1 ] [ i ] | v [ steps - 1 ] [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v [ steps ] . append ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return v [ steps ] [ 0 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE index , value , a [ 0 ] = 0 , 2 , 2 NEW_LINE print ( lastElement ( a , n ) ) NEW_LINE index , value = 3 , 5 NEW_LINE value = 5 NEW_LINE a [ index ] = value NEW_LINE print ( lastElement ( a , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2105_A", "sol": 0, "python_code": "def getFirstDigit ( x ) :\n    while ( x >= 10 ) :\n        x /= 10\n    return x\ndef getCountWithSameStartAndEndFrom1 ( x ) :\n    if ( x < 10 ) :\n        return x\n    tens = x / 10\n    res = tens + 9\n    firstDigit = getFirstDigit ( x )\n    lastDigit = x % 10\n    if ( lastDigit < firstDigit ) :\n        res = res - 1\n    return res\ndef getCountWithSameStartAndEnd ( start , end ) :\n    return ( getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) )\nstart = 5\nend = 40\nprint ( getCountWithSameStartAndEnd ( start , end ) )\n", "python_code_tokenized": "def getFirstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x /= 10 NEW_LINE DEDENT return x NEW_LINE DEDENT def getCountWithSameStartAndEndFrom1 ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT tens = x / 10 NEW_LINE res = tens + 9 NEW_LINE firstDigit = getFirstDigit ( x ) NEW_LINE lastDigit = x % 10 NEW_LINE if ( lastDigit < firstDigit ) : NEW_LINE INDENT res = res - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def getCountWithSameStartAndEnd ( start , end ) : NEW_LINE INDENT return ( getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ) NEW_LINE DEDENT start = 5 NEW_LINE end = 40 NEW_LINE print ( getCountWithSameStartAndEnd ( start , end ) ) NEW_LINE"}
{"id": "codeforces_1389_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n , k , z = map ( int , input ( ).split ( ) )\n    a = [ int ( x ) for x in input ( ).split ( ) ]\n    ans = 0\n    s = 0\n    mx = 0\n    for i in range ( k + 1 ) :\n        if i < n - 1 :\n            mx = max ( mx , a [ i ] + a [ i + 1 ] )\n        s += a [ i ]\n        if i % 2 == k % 2 :\n            tmp = ( k - i ) // 2\n            if tmp <= z :\n                ans = max ( ans , s + mx * tmp )\n    print ( ans )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k , z = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE s = 0 NEW_LINE mx = 0 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT if i < n - 1 : NEW_LINE INDENT mx = max ( mx , a [ i ] + a [ i + 1 ] ) NEW_LINE DEDENT s += a [ i ] NEW_LINE if i % 2 == k % 2 : NEW_LINE INDENT tmp = ( k - i ) // 2 NEW_LINE if tmp <= z : NEW_LINE INDENT ans = max ( ans , s + mx * tmp ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC063_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\nprint ( a + b if a + b < 10 else \"error\" )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + b if a + b < 10 else \" error \" ) NEW_LINE"}
{"id": "geeksforgeeks_558_A", "sol": 0, "python_code": "import math\ndef complement ( num ) :\n    i = 0 ;\n    len = 0 ;\n    comp = 0 ;\n    temp = num ;\n    while ( 1 ) :\n        len += 1 ;\n        num = int ( num / 10 ) ;\n        if ( abs ( num ) == 0 ) :\n            break ;\n    num = temp ;\n    comp = math.pow ( 10 , len ) - num ;\n    return int ( comp ) ;\nprint ( complement ( 25 ) ) ;\nprint ( complement ( 456 ) ) ;\n", "python_code_tokenized": "import math NEW_LINE def complement ( num ) : NEW_LINE INDENT i = 0 ; NEW_LINE len = 0 ; NEW_LINE comp = 0 ; NEW_LINE temp = num ; NEW_LINE while ( 1 ) : NEW_LINE INDENT len += 1 ; NEW_LINE num = int ( num / 10 ) ; NEW_LINE if ( abs ( num ) == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT num = temp ; NEW_LINE comp = math . pow ( 10 , len ) - num ; NEW_LINE return int ( comp ) ; NEW_LINE DEDENT print ( complement ( 25 ) ) ; NEW_LINE print ( complement ( 456 ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_4014_A", "sol": 0, "python_code": "def getMedian ( ar1 , ar2 , n ) :\n    i = 0\n    j = 0\n    m1 = - 1\n    m2 = - 1\n    count = 0\n    while count < n + 1 :\n        count += 1\n        if i == n :\n            m1 = m2\n            m2 = ar2 [ 0 ]\n            break\n        elif j == n :\n            m1 = m2\n            m2 = ar1 [ 0 ]\n            break\n        if ar1 [ i ] < ar2 [ j ] :\n            m1 = m2\n            m2 = ar1 [ i ]\n            i += 1\n        else :\n            m1 = m2\n            m2 = ar2 [ j ]\n            j += 1\n    return ( m1 + m2 ) / 2\nar1 = [ 1 , 12 , 15 , 26 , 38 ]\nar2 = [ 2 , 13 , 17 , 30 , 45 ]\nn1 = len ( ar1 )\nn2 = len ( ar2 )\nif n1 == n2 :\n    print ( \"Median is \" , getMedian ( ar1 , ar2 , n1 ) )\nelse :\n    print ( \"Doesn't work for arrays of unequal size\" )\n", "python_code_tokenized": "def getMedian ( ar1 , ar2 , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE m1 = - 1 NEW_LINE m2 = - 1 NEW_LINE count = 0 NEW_LINE while count < n + 1 : NEW_LINE INDENT count += 1 NEW_LINE if i == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ 0 ] NEW_LINE break NEW_LINE DEDENT elif j == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ 0 ] NEW_LINE break NEW_LINE DEDENT if ar1 [ i ] < ar2 [ j ] : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ( m1 + m2 ) / 2 NEW_LINE DEDENT ar1 = [ 1 , 12 , 15 , 26 , 38 ] NEW_LINE ar2 = [ 2 , 13 , 17 , 30 , 45 ] NEW_LINE n1 = len ( ar1 ) NEW_LINE n2 = len ( ar2 ) NEW_LINE if n1 == n2 : NEW_LINE INDENT print ( \" Median \u2581 is \u2581 \" , getMedian ( ar1 , ar2 , n1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Doesn ' t \u2581 work \u2581 for \u2581 arrays \u2581 of \u2581 unequal \u2581 size \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1085_A", "sol": 0, "python_code": "def maxSelectionCount ( a , n ) :\n    res = 0 ;\n    a.sort ( ) ;\n    select = 1 ;\n    for i in range ( n ) :\n        if ( a [ i ] >= select ) :\n            res += 1 ;\n            select += 1 ;\n    return res ;\narr = [ 4 , 2 , 1 , 3 , 5 , 1 , 4 ] ;\nN = len ( arr ) ;\nprint ( maxSelectionCount ( arr , N ) ) ;\n", "python_code_tokenized": "def maxSelectionCount ( a , n ) : NEW_LINE INDENT res = 0 ; NEW_LINE a . sort ( ) ; NEW_LINE select = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= select ) : NEW_LINE INDENT res += 1 ; NEW_LINE select += 1 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT arr = [ 4 , 2 , 1 , 3 , 5 , 1 , 4 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE print ( maxSelectionCount ( arr , N ) ) ; NEW_LINE"}
{"id": "codeforces_1338_A", "sol": 0, "python_code": "import math\nt = int ( input ( ) )\nwhile t :\n    n = int ( input ( ) )\n    lst = input ( ).split ( )\n    prev = int ( lst [ 0 ] )\n    maxdiff = 0\n    for i in range ( 1 , n ) :\n        curr = int ( lst [ i ] )\n        maxdiff = max ( maxdiff , prev - curr )\n        prev = max ( prev , curr )\n    if maxdiff == 0 :\n        print ( 0 )\n    else : print ( int ( math.log2 ( maxdiff ) ) + 1 )\n    t = t - 1\n", "python_code_tokenized": "import math NEW_LINE t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE lst = input ( ) . split ( ) NEW_LINE prev = int ( lst [ 0 ] ) NEW_LINE maxdiff = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = int ( lst [ i ] ) NEW_LINE maxdiff = max ( maxdiff , prev - curr ) NEW_LINE prev = max ( prev , curr ) NEW_LINE DEDENT if maxdiff == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : print ( int ( math . log2 ( maxdiff ) ) + 1 ) NEW_LINE t = t - 1 NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3016_A", "sol": 0, "python_code": "dig = [ 1 , 1 , 2 , 6 , 4 , 2 , 2 , 4 , 2 , 8 ]\ndef lastNon0Digit ( n ) :\n    if ( n < 10 ) :\n        return dig [ n ]\n    if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) :\n        return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10\n    else :\n        return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10\n    return 0\nn = 14\nprint ( lastNon0Digit ( n ) )\n", "python_code_tokenized": "dig = [ 1 , 1 , 2 , 6 , 4 , 2 , 2 , 4 , 2 , 8 ] NEW_LINE def lastNon0Digit ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return dig [ n ] NEW_LINE DEDENT if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) : NEW_LINE INDENT return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT n = 14 NEW_LINE print ( lastNon0Digit ( n ) ) NEW_LINE"}
{"id": "aizu_p00424_A", "sol": 0, "python_code": "while 1 :\n    n = int ( input ( ) )\n    if n == 0 : break\n    d = { }\n    for _ in [ 0 ] * n :\n        k , v = input ( ).strip ( ).split ( )\n        d [ k ] = v\n    for _ in [ 0 ] * int ( input ( ) ) :\n        e = input ( ).strip ( )\n        print ( d [ e ] if e in d else e , end = '' )\n    print ( )\n", "python_code_tokenized": "while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE d = { } NEW_LINE for _ in [ 0 ] * n : NEW_LINE INDENT k , v = input ( ) . strip ( ) . split ( ) NEW_LINE d [ k ] = v NEW_LINE DEDENT for _ in [ 0 ] * int ( input ( ) ) : NEW_LINE INDENT e = input ( ) . strip ( ) NEW_LINE print ( d [ e ] if e in d else e , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"id": "codejam_17_41", "sol": 0, "python_code": "import numpy as np\ninname = \"input.txt\"\noutname = \"output.txt\"\nwith open ( inname , 'r' ) as f :\n    cases = int ( f.readline ( ) )\n    for tc in range ( 1 , cases + 1 ) :\n        line = f.readline ( ).strip ( ).split ( ' ' )\n        N = int ( line [ 0 ] )\n        P = int ( line [ 1 ] )\n        Pi = [ ]\n        R = [ 0 ] * P\n        line = f.readline ( ).strip ( ).split ( ' ' )\n        for i in range ( N ) :\n            Pi.append ( int ( line [ i ] ) )\n            R [ Pi [ i ] % P ] += 1\n        ans = 0\n        if P == 2 :\n            ans = R [ 0 ] + ( R [ 1 ] + 1 ) // 2\n        elif P == 3 :\n            ans = R [ 0 ]\n            if R [ 1 ] < R [ 2 ] :\n                a = R [ 1 ]\n                b = R [ 2 ]\n            else :\n                a = R [ 2 ]\n                b = R [ 1 ]\n            ans += a\n            b -= a\n            ans += ( b + 2 ) // 3\n        else :\n            ans = R [ 0 ]\n            if R [ 1 ] < R [ 3 ] :\n                a = R [ 1 ]\n                b = R [ 3 ]\n            else :\n                a = R [ 3 ]\n                b = R [ 1 ]\n            c = R [ 2 ]\n            ans += c // 2\n            c %= 2\n            ans += a\n            b -= a\n            if c == 1 and b >= 2 :\n                c -= 1\n                b -= 2\n                ans += 1\n            ans += b // 4\n            b %= 4\n            if c + b > 0 :\n                ans += 1\n        print ( \"Case #%d: %d\" % ( tc , ans ) )\n", "python_code_tokenized": "import numpy as np NEW_LINE inname = \" input . txt \" NEW_LINE outname = \" output . txt \" NEW_LINE with open ( inname , ' r ' ) as f : NEW_LINE INDENT cases = int ( f . readline ( ) ) NEW_LINE for tc in range ( 1 , cases + 1 ) : NEW_LINE INDENT line = f . readline ( ) . strip ( ) . split ( ' \u2581 ' ) NEW_LINE N = int ( line [ 0 ] ) NEW_LINE P = int ( line [ 1 ] ) NEW_LINE Pi = [ ] NEW_LINE R = [ 0 ] * P NEW_LINE line = f . readline ( ) . strip ( ) . split ( ' \u2581 ' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT Pi . append ( int ( line [ i ] ) ) NEW_LINE R [ Pi [ i ] % P ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE if P == 2 : NEW_LINE INDENT ans = R [ 0 ] + ( R [ 1 ] + 1 ) // 2 NEW_LINE DEDENT elif P == 3 : NEW_LINE INDENT ans = R [ 0 ] NEW_LINE if R [ 1 ] < R [ 2 ] : NEW_LINE INDENT a = R [ 1 ] NEW_LINE b = R [ 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT a = R [ 2 ] NEW_LINE b = R [ 1 ] NEW_LINE DEDENT ans += a NEW_LINE b -= a NEW_LINE ans += ( b + 2 ) // 3 NEW_LINE DEDENT else : NEW_LINE INDENT ans = R [ 0 ] NEW_LINE if R [ 1 ] < R [ 3 ] : NEW_LINE INDENT a = R [ 1 ] NEW_LINE b = R [ 3 ] NEW_LINE DEDENT else : NEW_LINE INDENT a = R [ 3 ] NEW_LINE b = R [ 1 ] NEW_LINE DEDENT c = R [ 2 ] NEW_LINE ans += c // 2 NEW_LINE c %= 2 NEW_LINE ans += a NEW_LINE b -= a NEW_LINE if c == 1 and b >= 2 : NEW_LINE INDENT c -= 1 NEW_LINE b -= 2 NEW_LINE ans += 1 NEW_LINE DEDENT ans += b // 4 NEW_LINE b %= 4 NEW_LINE if c + b > 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # % d : \u2581 % d \" % ( tc , ans ) ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC140_E", "sol": 0, "python_code": "import bisect\nn = int ( input ( ) )\np = [ int ( x ) - 1 for x in input ( ).split ( ) ]\np2 = sorted ( enumerate ( p ) , key = lambda x : x [ 1 ] , reverse = True )\nans = 0\ns = [ - 1 , - 1 , n , n ]\nfor i , ( idx , p ) in enumerate ( p2 ) :\n    t = bisect.bisect_left ( s , idx )\n    s.insert ( t , idx )\n    l1 = s [ t - 1 ]\n    l2 = s [ t - 2 ]\n    r1 = s [ t + 1 ]\n    r2 = s [ t + 2 ]\n    ans += ( p + 1 ) * ( ( idx - l1 ) * ( r2 - r1 ) + ( r1 - idx ) * ( l1 - l2 ) )\nprint ( ans )\n", "python_code_tokenized": "import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE p = [ int ( x ) - 1 for x in input ( ) . split ( ) ] NEW_LINE p2 = sorted ( enumerate ( p ) , key = lambda x : x [ 1 ] , reverse = True ) NEW_LINE ans = 0 NEW_LINE s = [ - 1 , - 1 , n , n ] NEW_LINE for i , ( idx , p ) in enumerate ( p2 ) : NEW_LINE INDENT t = bisect . bisect_left ( s , idx ) NEW_LINE s . insert ( t , idx ) NEW_LINE l1 = s [ t - 1 ] NEW_LINE l2 = s [ t - 2 ] NEW_LINE r1 = s [ t + 1 ] NEW_LINE r2 = s [ t + 2 ] NEW_LINE ans += ( p + 1 ) * ( ( idx - l1 ) * ( r2 - r1 ) + ( r1 - idx ) * ( l1 - l2 ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "projecteuler_p346_A", "sol": 0, "python_code": "import itertools\ndef compute ( ) :\n    LIMIT = 10 ** 12\n    strongrepunits = { 1 }\n    for length in range ( 3 , LIMIT.bit_length ( ) + 1 ) :\n        for base in itertools.count ( 2 ) :\n            value = ( base ** length - 1 ) // ( base - 1 )\n            if value >= LIMIT :\n                break\n            strongrepunits.add ( value )\n    ans = sum ( strongrepunits )\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 12 NEW_LINE strongrepunits = { 1 } NEW_LINE for length in range ( 3 , LIMIT . bit_length ( ) + 1 ) : NEW_LINE INDENT for base in itertools . count ( 2 ) : NEW_LINE INDENT value = ( base ** length - 1 ) // ( base - 1 ) NEW_LINE if value >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT strongrepunits . add ( value ) NEW_LINE DEDENT DEDENT ans = sum ( strongrepunits ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2671_A", "sol": 0, "python_code": "MAX_CHAR = 26\ndef printCommon ( s1 , s2 ) :\n    a1 = [ 0 for i in range ( MAX_CHAR ) ]\n    a2 = [ 0 for i in range ( MAX_CHAR ) ]\n    length1 = len ( s1 )\n    length2 = len ( s2 )\n    for i in range ( 0 , length1 ) :\n        a1 [ ord ( s1 [ i ] ) - ord ( 'a' ) ] += 1\n    for i in range ( 0 , length2 ) :\n        a2 [ ord ( s2 [ i ] ) - ord ( 'a' ) ] += 1\n    for i in range ( 0 , MAX_CHAR ) :\n        if ( a1 [ i ] != 0 and a2 [ i ] != 0 ) :\n            for j in range ( 0 , min ( a1 [ i ] , a2 [ i ] ) ) :\n                ch = chr ( ord ( 'a' ) + i )\n                print ( ch , end = '' )\nif __name__ == \"__main__\" :\n    s1 = \"geeksforgeeks\"\n    s2 = \"practiceforgeeks\"\n    printCommon ( s1 , s2 ) ;\n", "python_code_tokenized": "MAX_CHAR = 26 NEW_LINE def printCommon ( s1 , s2 ) : NEW_LINE INDENT a1 = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE a2 = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE length1 = len ( s1 ) NEW_LINE length2 = len ( s2 ) NEW_LINE for i in range ( 0 , length1 ) : NEW_LINE INDENT a1 [ ord ( s1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , length2 ) : NEW_LINE INDENT a2 [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( a1 [ i ] != 0 and a2 [ i ] != 0 ) : NEW_LINE INDENT for j in range ( 0 , min ( a1 [ i ] , a2 [ i ] ) ) : NEW_LINE INDENT ch = chr ( ord ( ' a ' ) + i ) NEW_LINE print ( ch , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeksforgeeks \" NEW_LINE s2 = \" practiceforgeeks \" NEW_LINE printCommon ( s1 , s2 ) ; NEW_LINE DEDENT"}
{"id": "codeforces_784_B", "sol": 0, "python_code": "v = [ 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 2 , 1 , 1 , 2 , 0 , 1 , 0 , 0 ]\nn = int ( input ( ) )\na = 1 if n == 0 else 0\nwhile n > 0 :\n    a += v [ n % 16 ]\n    n //= 16\nprint ( a )\n", "python_code_tokenized": "v = [ 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 2 , 1 , 1 , 2 , 0 , 1 , 0 , 0 ] NEW_LINE n = int ( input ( ) ) NEW_LINE a = 1 if n == 0 else 0 NEW_LINE while n > 0 : NEW_LINE INDENT a += v [ n % 16 ] NEW_LINE n //= 16 NEW_LINE DEDENT print ( a ) NEW_LINE"}
{"id": "atcoder_ABC085_C", "sol": 0, "python_code": "n , y = ( int ( num ) for num in input ( ).split ( ) )\nans = '-1 -1 -1'\nfor i in range ( n + 1 ) :\n    if ans != '-1 -1 -1' :\n        break\n    for j in range ( n + 1 ) :\n        n_10 = n - i\n        n_5 = n - j\n        n_1 = ( y - 10000 * n_10 - 5000 * n_5 ) // 1000\n        if n_10 + n_5 + n_1 == n and n_1 >= 0 :\n            ans = str ( n_10 ) + ' ' + str ( n_5 ) + ' ' + str ( n_1 )\n            break\nprint ( ans )\n", "python_code_tokenized": "n , y = ( int ( num ) for num in input ( ) . split ( ) ) NEW_LINE ans = ' - 1 \u2581 - 1 \u2581 - 1' NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ans != ' - 1 \u2581 - 1 \u2581 - 1' : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( n + 1 ) : NEW_LINE INDENT n_10 = n - i NEW_LINE n_5 = n - j NEW_LINE n_1 = ( y - 10000 * n_10 - 5000 * n_5 ) // 1000 NEW_LINE if n_10 + n_5 + n_1 == n and n_1 >= 0 : NEW_LINE INDENT ans = str ( n_10 ) + ' \u2581 ' + str ( n_5 ) + ' \u2581 ' + str ( n_1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_2632_A", "sol": 0, "python_code": "import math\ndef getValue ( n ) :\n    result = int ( math.floor ( math.log ( n + 1 ) / math.log ( 2 ) ) )\n    return int ( math.pow ( 2 , result ) )\nn = 9\nprint ( getValue ( n ) )\nn = 1025\nprint ( getValue ( n ) )\n", "python_code_tokenized": "import math NEW_LINE def getValue ( n ) : NEW_LINE INDENT result = int ( math . floor ( math . log ( n + 1 ) / math . log ( 2 ) ) ) NEW_LINE return int ( math . pow ( 2 , result ) ) NEW_LINE DEDENT n = 9 NEW_LINE print ( getValue ( n ) ) NEW_LINE n = 1025 NEW_LINE print ( getValue ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2284_A", "sol": 0, "python_code": "def recaman ( n ) :\n    if ( n <= 0 ) :\n        return\n    print ( 0 , \",\" , end = '' )\n    s = set ( [ ] )\n    s.add ( 0 )\n    prev = 0\n    for i in range ( 1 , n ) :\n        curr = prev - i\n        if ( curr < 0 or curr in s ) :\n            curr = prev + i\n        s.add ( curr )\n        print ( curr , \",\" , end = '' )\n        prev = curr\nif __name__ == '__main__' :\n    n = 17\n    recaman ( n )\n", "python_code_tokenized": "def recaman ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( 0 , \" , \" , end = ' ' ) NEW_LINE s = set ( [ ] ) NEW_LINE s . add ( 0 ) NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = prev - i NEW_LINE if ( curr < 0 or curr in s ) : NEW_LINE INDENT curr = prev + i NEW_LINE DEDENT s . add ( curr ) NEW_LINE print ( curr , \" , \" , end = ' ' ) NEW_LINE prev = curr NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 17 NEW_LINE recaman ( n ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC121_A", "sol": 0, "python_code": "H , W = map ( int , input ( ).split ( ) )\nh , w = map ( int , input ( ).split ( ) )\nprint ( ( H - h ) * ( W - w ) )\n", "python_code_tokenized": "H , W = map ( int , input ( ) . split ( ) ) NEW_LINE h , w = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( H - h ) * ( W - w ) ) NEW_LINE"}
{"id": "geeksforgeeks_755_A", "sol": 0, "python_code": "def maxCount ( A , N , K ) :\n    maximum = 0\n    start = 0\n    end = 0\n    j = 0\n    A.sort ( )\n    for i in range ( 0 , N ) :\n        while ( j < N and A [ j ] <= A [ i ] + K ) :\n            j += 1\n        if maximum < ( j - i ) :\n            maximum = ( j - i )\n            start = i ;\n            end = j ;\n    return maximum\nA = [ 1 , 26 , 17 , 12 , 15 , 2 ]\nN = len ( A )\nK = 5\nprint ( maxCount ( A , N , K ) )\n", "python_code_tokenized": "def maxCount ( A , N , K ) : NEW_LINE INDENT maximum = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE j = 0 NEW_LINE A . sort ( ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT while ( j < N and A [ j ] <= A [ i ] + K ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if maximum < ( j - i ) : NEW_LINE INDENT maximum = ( j - i ) NEW_LINE start = i ; NEW_LINE end = j ; NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT A = [ 1 , 26 , 17 , 12 , 15 , 2 ] NEW_LINE N = len ( A ) NEW_LINE K = 5 NEW_LINE print ( maxCount ( A , N , K ) ) NEW_LINE"}
{"id": "geeksforgeeks_2582_A", "sol": 0, "python_code": "def findNth ( n ) :\n    count = 0 ;\n    curr = 19 ;\n    while ( True ) :\n        sum = 0 ;\n        x = curr ;\n        while ( x > 0 ) :\n            sum = sum + x % 10 ;\n            x = int ( x / 10 ) ;\n        if ( sum == 10 ) :\n            count += 1 ;\n        if ( count == n ) :\n            return curr ;\n        curr += 9 ;\n    return - 1 ;\nprint ( findNth ( 5 ) ) ;\n", "python_code_tokenized": "def findNth ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE curr = 19 ; NEW_LINE while ( True ) : NEW_LINE INDENT sum = 0 ; NEW_LINE x = curr ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT sum = sum + x % 10 ; NEW_LINE x = int ( x / 10 ) ; NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr ; NEW_LINE DEDENT curr += 9 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT print ( findNth ( 5 ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_2581_A", "sol": 0, "python_code": "import itertools\ndef findNth ( n ) :\n    count = 0\n    for curr in itertools.count ( ) :\n        sum = 0\n        x = curr\n        while ( x ) :\n            sum = sum + x % 10\n            x = x // 10\n        if ( sum == 10 ) :\n            count = count + 1\n        if ( count == n ) :\n            return curr\n    return - 1\nif __name__ == '__main__' :\n    print ( findNth ( 5 ) )\n", "python_code_tokenized": "import itertools NEW_LINE def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for curr in itertools . count ( ) : NEW_LINE INDENT sum = 0 NEW_LINE x = curr NEW_LINE while ( x ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( findNth ( 5 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4580_A", "sol": 0, "python_code": "import sys\nR = 4\nC = 4\ndef first ( arr , low , high ) :\n    if ( high >= low ) :\n        mid = low + ( high - low ) // 2 ;\n        if ( ( mid == 0 or arr [ mid - 1 ] == 0 ) and arr [ mid ] == 1 ) :\n            return mid ;\n        elif ( arr [ mid ] == 0 ) :\n            return first ( arr , ( mid + 1 ) , high ) ;\n        else :\n            return first ( arr , low , ( mid - 1 ) ) ;\n    return - 1 ;\ndef rowWith0s ( mat ) :\n    row_index = 0 ; max = - ( sys.maxsize - 1 ) ;\n    min_row_index = 0 ; min = sys.maxsize ;\n    for i in range ( R ) :\n        index = first ( mat [ i ] , 0 , C - 1 ) ;\n        cntZeroes = 0 ;\n        if ( index == - 1 ) :\n            cntZeroes = C ;\n        else :\n            cntZeroes = index ;\n        if ( max < cntZeroes ) :\n            max = cntZeroes ;\n            max_row_index = i ;\n        if ( min > cntZeroes ) :\n            min = cntZeroes ;\n            min_row_index = i ;\n    print ( \"Row with min 0s:\" , min_row_index + 1 ) ;\n    print ( \"Row with max 0s:\" , max_row_index + 1 ) ;\nif __name__ == \"__main__\" :\n    mat = [ [ 0 , 0 , 0 , 1 ] , [ 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 0 ] ] ;\n    rowWith0s ( mat ) ;\n", "python_code_tokenized": "import sys NEW_LINE R = 4 NEW_LINE C = 4 NEW_LINE def first ( arr , low , high ) : NEW_LINE INDENT if ( high >= low ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 ; NEW_LINE if ( ( mid == 0 or arr [ mid - 1 ] == 0 ) and arr [ mid ] == 1 ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT elif ( arr [ mid ] == 0 ) : NEW_LINE INDENT return first ( arr , ( mid + 1 ) , high ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return first ( arr , low , ( mid - 1 ) ) ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT def rowWith0s ( mat ) : NEW_LINE INDENT row_index = 0 ; max = - ( sys . maxsize - 1 ) ; NEW_LINE min_row_index = 0 ; min = sys . maxsize ; NEW_LINE for i in range ( R ) : NEW_LINE INDENT index = first ( mat [ i ] , 0 , C - 1 ) ; NEW_LINE cntZeroes = 0 ; NEW_LINE if ( index == - 1 ) : NEW_LINE INDENT cntZeroes = C ; NEW_LINE DEDENT else : NEW_LINE INDENT cntZeroes = index ; NEW_LINE DEDENT if ( max < cntZeroes ) : NEW_LINE INDENT max = cntZeroes ; NEW_LINE max_row_index = i ; NEW_LINE DEDENT if ( min > cntZeroes ) : NEW_LINE INDENT min = cntZeroes ; NEW_LINE min_row_index = i ; NEW_LINE DEDENT DEDENT print ( \" Row \u2581 with \u2581 min \u2581 0s : \" , min_row_index + 1 ) ; NEW_LINE print ( \" Row \u2581 with \u2581 max \u2581 0s : \" , max_row_index + 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 0 , 0 , 0 , 1 ] , [ 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 0 ] ] ; NEW_LINE rowWith0s ( mat ) ; NEW_LINE DEDENT"}
{"id": "aizu_p00577_A", "sol": 0, "python_code": "def solve ( ) :\n    N = int ( input ( ) )\n    S = input ( )\n    stomp = 0\n    for i in range ( 1 , len ( S ) ) :\n        pass\n    i = 0\n    while True :\n        if i >= len ( S ) - 1 :\n            break\n        if S [ i ] != S [ i + 1 ] :\n            stomp += 1\n            i += 1\n        i += 1\n    print ( stomp )\nif __name__ == '__main__' :\n    solve ( )\n", "python_code_tokenized": "def solve ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE S = input ( ) NEW_LINE stomp = 0 NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT pass NEW_LINE DEDENT i = 0 NEW_LINE while True : NEW_LINE INDENT if i >= len ( S ) - 1 : NEW_LINE INDENT break NEW_LINE DEDENT if S [ i ] != S [ i + 1 ] : NEW_LINE INDENT stomp += 1 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( stomp ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1901_A", "sol": 0, "python_code": "def no_of_ways ( a , n ) :\n    count_0 = 0\n    count_1 = 0\n    for i in range ( 0 , n ) :\n        if ( a [ i ] == 0 ) :\n            count_0 += 1\n        else :\n            count_1 += 1\n    if ( count_1 % 2 == 0 ) :\n        return count_0\n    else :\n        return count_1\nif __name__ == '__main__' :\n    n = 4\n    a1 = [ 1 , 1 , 0 , 0 ]\n    print ( no_of_ways ( a1 , n ) )\n    n = 5\n    a2 = [ 1 , 1 , 1 , 0 , 0 ]\n    print ( no_of_ways ( a2 , n ) )\n    n = 5\n    a3 = [ 1 , 1 , 0 , 0 , 0 ]\n    print ( no_of_ways ( a3 , n ) )\n    n = 6\n    a4 = [ 1 , 1 , 1 , 0 , 0 , 0 ]\n    print ( no_of_ways ( a4 , n ) )\n", "python_code_tokenized": "def no_of_ways ( a , n ) : NEW_LINE INDENT count_0 = 0 NEW_LINE count_1 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count_0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT DEDENT if ( count_1 % 2 == 0 ) : NEW_LINE INDENT return count_0 NEW_LINE DEDENT else : NEW_LINE INDENT return count_1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE a1 = [ 1 , 1 , 0 , 0 ] NEW_LINE print ( no_of_ways ( a1 , n ) ) NEW_LINE n = 5 NEW_LINE a2 = [ 1 , 1 , 1 , 0 , 0 ] NEW_LINE print ( no_of_ways ( a2 , n ) ) NEW_LINE n = 5 NEW_LINE a3 = [ 1 , 1 , 0 , 0 , 0 ] NEW_LINE print ( no_of_ways ( a3 , n ) ) NEW_LINE n = 6 NEW_LINE a4 = [ 1 , 1 , 1 , 0 , 0 , 0 ] NEW_LINE print ( no_of_ways ( a4 , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_244_A", "sol": 0, "python_code": "def Diffs ( a , k ) :\n    out , inc , dec = [ ] , [ 0 ] * len ( a ) , [ 0 ] * len ( a )\n    inc_sum , dec_sum = 0 , 0\n    for i in range ( 0 , len ( a ) ) :\n        j = i - 1\n        while ( j >= 0 and j > i - k and a [ j + 1 ] > a [ j ] ) :\n            inc [ j ] += 1\n            inc_sum += 1\n            j -= 1\n        j = i - 1\n        while ( j >= 0 and j > i - k and a [ j + 1 ] < a [ j ] ) :\n            dec [ j ] += 1\n            dec_sum += 1\n            j -= 1\n        if i >= k - 1 :\n            if i >= k :\n                inc_sum -= inc [ i - k ]\n                dec_sum -= dec [ i - k ]\n            out.append ( inc_sum - dec_sum )\n    return out\nif __name__ == \"__main__\" :\n    out = Diffs ( [ 10 , 20 , 30 , 15 , 15 ] , 3 )\n    for n in out :\n        print ( n , end = \", \" )\n", "python_code_tokenized": "def Diffs ( a , k ) : NEW_LINE INDENT out , inc , dec = [ ] , [ 0 ] * len ( a ) , [ 0 ] * len ( a ) NEW_LINE inc_sum , dec_sum = 0 , 0 NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT j = i - 1 NEW_LINE while ( j >= 0 and j > i - k and a [ j + 1 ] > a [ j ] ) : NEW_LINE INDENT inc [ j ] += 1 NEW_LINE inc_sum += 1 NEW_LINE j -= 1 NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j >= 0 and j > i - k and a [ j + 1 ] < a [ j ] ) : NEW_LINE INDENT dec [ j ] += 1 NEW_LINE dec_sum += 1 NEW_LINE j -= 1 NEW_LINE DEDENT if i >= k - 1 : NEW_LINE INDENT if i >= k : NEW_LINE INDENT inc_sum -= inc [ i - k ] NEW_LINE dec_sum -= dec [ i - k ] NEW_LINE DEDENT out . append ( inc_sum - dec_sum ) NEW_LINE DEDENT DEDENT return out NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT out = Diffs ( [ 10 , 20 , 30 , 15 , 15 ] , 3 ) NEW_LINE for n in out : NEW_LINE INDENT print ( n , end = \" , \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC178_B", "sol": 0, "python_code": "a , b , c , d = map ( int , input ( ).split ( ) )\nans = max ( a * c , a * d , b * c , b * d )\nprint ( ans )\n", "python_code_tokenized": "a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE ans = max ( a * c , a * d , b * c , b * d ) NEW_LINE print ( ans ) NEW_LINE"}
{"id": "atcoder_ABC173_C", "sol": 0, "python_code": "import itertools\nH , W , K = map ( int , input ( ).split ( ) )\nC = [ ]\nfor i in range ( H ) :\n    C.append ( input ( ) )\nans = 0\nfor i in range ( H + 1 ) :\n    for j in range ( W + 1 ) :\n        for n in itertools.combinations ( list ( range ( H ) ) , i ) :\n            for m in itertools.combinations ( list ( range ( W ) ) , j ) :\n                count = 0\n                for a in n :\n                    for b in m :\n                        if ( C [ a ] [ b ] == \"#\" ) : count += 1\n                if ( count == K ) :\n                    ans += 1\nprint ( ans )\n", "python_code_tokenized": "import itertools NEW_LINE H , W , K = map ( int , input ( ) . split ( ) ) NEW_LINE C = [ ] NEW_LINE for i in range ( H ) : NEW_LINE INDENT C . append ( input ( ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( H + 1 ) : NEW_LINE INDENT for j in range ( W + 1 ) : NEW_LINE INDENT for n in itertools . combinations ( list ( range ( H ) ) , i ) : NEW_LINE INDENT for m in itertools . combinations ( list ( range ( W ) ) , j ) : NEW_LINE INDENT count = 0 NEW_LINE for a in n : NEW_LINE INDENT for b in m : NEW_LINE INDENT if ( C [ a ] [ b ] == \" # \" ) : count += 1 NEW_LINE DEDENT DEDENT if ( count == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_89_A", "sol": 0, "python_code": "def findSubsequence ( arr , n ) :\n    sign = [ 0 ] * n\n    for i in range ( n ) :\n        if ( arr [ i ] > 0 ) :\n            sign [ i ] = 1\n        else :\n            sign [ i ] = - 1\n    k = 0\n    result = [ 0 ] * n\n    i = 0\n    while i < n :\n        cur = arr [ i ]\n        j = i\n        while ( j < n and sign [ i ] == sign [ j ] ) :\n            cur = max ( cur , arr [ j ] )\n            j += 1\n        result [ k ] = cur\n        k += 1\n        i = j - 1\n        i += 1\n    for i in range ( k ) :\n        print ( result [ i ] , end = \" \" )\nif __name__ == '__main__' :\n    arr = [ - 4 , 9 , 4 , 11 , - 5 , - 17 , 9 , - 3 , - 5 , 2 ]\n    n = len ( arr )\n    findSubsequence ( arr , n )\n", "python_code_tokenized": "def findSubsequence ( arr , n ) : NEW_LINE INDENT sign = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT sign [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT sign [ i ] = - 1 NEW_LINE DEDENT DEDENT k = 0 NEW_LINE result = [ 0 ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT cur = arr [ i ] NEW_LINE j = i NEW_LINE while ( j < n and sign [ i ] == sign [ j ] ) : NEW_LINE INDENT cur = max ( cur , arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT result [ k ] = cur NEW_LINE k += 1 NEW_LINE i = j - 1 NEW_LINE i += 1 NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( result [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ - 4 , 9 , 4 , 11 , - 5 , - 17 , 9 , - 3 , - 5 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE findSubsequence ( arr , n ) NEW_LINE DEDENT"}
{"id": "codejam_15_33", "sol": 0, "python_code": "import sys\niFile = open ( sys.argv [ 1 ] , \"r\" )\nT = int ( iFile.readline ( ).strip ( ) )\nfor t in range ( T ) :\n    line = iFile.readline ( ).strip ( ).split ( )\n    C = int ( line [ 0 ] )\n    D = int ( line [ 1 ] )\n    V = int ( line [ 2 ] )\n    denominations = [ int ( x ) for x in iFile.readline ( ).strip ( ).split ( ) ]\n    denominations.append ( V + 1 )\n    covered = 0\n    additions = 0\n    for denom in denominations :\n        while denom > covered + 1 :\n            additions += 1\n            covered += C * ( covered + 1 )\n        covered += C * denom\n    answer = additions\n    output = str ( answer )\n    print ( \"Case #\" + str ( t + 1 ) + \": \" + output )\n", "python_code_tokenized": "import sys NEW_LINE iFile = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE T = int ( iFile . readline ( ) . strip ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT line = iFile . readline ( ) . strip ( ) . split ( ) NEW_LINE C = int ( line [ 0 ] ) NEW_LINE D = int ( line [ 1 ] ) NEW_LINE V = int ( line [ 2 ] ) NEW_LINE denominations = [ int ( x ) for x in iFile . readline ( ) . strip ( ) . split ( ) ] NEW_LINE denominations . append ( V + 1 ) NEW_LINE covered = 0 NEW_LINE additions = 0 NEW_LINE for denom in denominations : NEW_LINE INDENT while denom > covered + 1 : NEW_LINE INDENT additions += 1 NEW_LINE covered += C * ( covered + 1 ) NEW_LINE DEDENT covered += C * denom NEW_LINE DEDENT answer = additions NEW_LINE output = str ( answer ) NEW_LINE print ( \" Case \u2581 # \" + str ( t + 1 ) + \" : \u2581 \" + output ) NEW_LINE DEDENT"}
{"id": "codeforces_599_B", "sol": 0, "python_code": "from sys import *\ninp = lambda : stdin.readline ( )\ndef main ( ) :\n    n , m = [ int ( i ) for i in inp ( ).split ( ) ]\n    f , b = [ int ( i ) for i in inp ( ).split ( ) ] , [ int ( i ) for i in inp ( ).split ( ) ]\n    d = { }\n    for i in range ( len ( f ) ) :\n        if f [ i ] not in d :\n            d [ f [ i ] ] = [ ]\n        d [ f [ i ] ].append ( i + 1 )\n    sb , fb = set ( b ) , set ( f )\n    ans = [ ]\n    if not sb.issubset ( fb ) :\n        print ( \"Impossible\" )\n    else :\n        for i in b :\n            if len ( d [ i ] ) > 1 :\n                print ( \"Ambiguity\" )\n                exit ( 0 )\n            else :\n                ans.append ( d [ i ] [ 0 ] )\n        print ( \"Possible\" )\n        print ( \" \".join ( [ str ( i ) for i in ans ] ) )\nif __name__ == \"__main__\" :\n    main ( )\n", "python_code_tokenized": "from sys import * NEW_LINE inp = lambda : stdin . readline ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n , m = [ int ( i ) for i in inp ( ) . split ( ) ] NEW_LINE f , b = [ int ( i ) for i in inp ( ) . split ( ) ] , [ int ( i ) for i in inp ( ) . split ( ) ] NEW_LINE d = { } NEW_LINE for i in range ( len ( f ) ) : NEW_LINE INDENT if f [ i ] not in d : NEW_LINE INDENT d [ f [ i ] ] = [ ] NEW_LINE DEDENT d [ f [ i ] ] . append ( i + 1 ) NEW_LINE DEDENT sb , fb = set ( b ) , set ( f ) NEW_LINE ans = [ ] NEW_LINE if not sb . issubset ( fb ) : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in b : NEW_LINE INDENT if len ( d [ i ] ) > 1 : NEW_LINE INDENT print ( \" Ambiguity \" ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( d [ i ] [ 0 ] ) NEW_LINE DEDENT DEDENT print ( \" Possible \" ) NEW_LINE print ( \" \u2581 \" . join ( [ str ( i ) for i in ans ] ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_173_A", "sol": 0, "python_code": "n , a1 , a2 = int ( input ( ) ) , input ( ) , input ( )\nx , y = 0 , 0\nk1 , k2 = len ( a1 ) , len ( a2 )\nfor i in range ( k1 * k2 ) :\n    if i >= n :\n        break\n    c1 , c2 = a1 [ i % k1 ] , a2 [ i % k2 ]\n    if c1 == c2 :\n        continue\n    elif c1 == \"R\" and c2 == \"S\" or c1 == \"P\" and c2 == \"R\" or c1 == 'S' and c2 == \"P\" :\n        x += ( n - i + k1 * k2 - 1 ) // ( k1 * k2 )\n    else :\n        y += ( n - i + k1 * k2 - 1 ) // ( k1 * k2 )\nprint ( y , x )\n", "python_code_tokenized": "n , a1 , a2 = int ( input ( ) ) , input ( ) , input ( ) NEW_LINE x , y = 0 , 0 NEW_LINE k1 , k2 = len ( a1 ) , len ( a2 ) NEW_LINE for i in range ( k1 * k2 ) : NEW_LINE INDENT if i >= n : NEW_LINE INDENT break NEW_LINE DEDENT c1 , c2 = a1 [ i % k1 ] , a2 [ i % k2 ] NEW_LINE if c1 == c2 : NEW_LINE INDENT continue NEW_LINE DEDENT elif c1 == \" R \" and c2 == \" S \" or c1 == \" P \" and c2 == \" R \" or c1 == ' S ' and c2 == \" P \" : NEW_LINE INDENT x += ( n - i + k1 * k2 - 1 ) // ( k1 * k2 ) NEW_LINE DEDENT else : NEW_LINE INDENT y += ( n - i + k1 * k2 - 1 ) // ( k1 * k2 ) NEW_LINE DEDENT DEDENT print ( y , x ) NEW_LINE"}
{"id": "geeksforgeeks_3938_A", "sol": 0, "python_code": "MAX = 1000\ndef numofArray ( n , m ) :\n    dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ]\n    di = [ [ ] for i in range ( MAX ) ]\n    mu = [ [ ] for i in range ( MAX ) ]\n    for i in range ( 1 , m + 1 ) :\n        for j in range ( 2 * i , m + 1 , i ) :\n            di [ j ].append ( i )\n            mu [ i ].append ( j )\n        di [ i ].append ( i )\n    for i in range ( 1 , m + 1 ) :\n        dp [ 1 ] [ i ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( 1 , m + 1 ) :\n            dp [ i ] [ j ] = 0\n            for x in di [ j ] :\n                dp [ i ] [ j ] += dp [ i - 1 ] [ x ]\n            for x in mu [ j ] :\n                dp [ i ] [ j ] += dp [ i - 1 ] [ x ]\n    ans = 0\n    for i in range ( 1 , m + 1 ) :\n        ans += dp [ n ] [ i ]\n        di [ i ].clear ( )\n        mu [ i ].clear ( )\n    return ans\nif __name__ == \"__main__\" :\n    n = m = 3\n    print ( numofArray ( n , m ) )\n", "python_code_tokenized": "MAX = 1000 NEW_LINE def numofArray ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE di = [ [ ] for i in range ( MAX ) ] NEW_LINE mu = [ [ ] for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 2 * i , m + 1 , i ) : NEW_LINE INDENT di [ j ] . append ( i ) NEW_LINE mu [ i ] . append ( j ) NEW_LINE DEDENT di [ i ] . append ( i ) NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE for x in di [ j ] : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT for x in mu [ j ] : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ i ] NEW_LINE di [ i ] . clear ( ) NEW_LINE mu [ i ] . clear ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = m = 3 NEW_LINE print ( numofArray ( n , m ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC107_A", "sol": 0, "python_code": "n , i = map ( int , input ( ).split ( ) )\nprint ( n - i + 1 )\n", "python_code_tokenized": "n , i = map ( int , input ( ) . split ( ) ) NEW_LINE print ( n - i + 1 ) NEW_LINE"}
{"id": "atcoder_AGC007_A", "sol": 0, "python_code": "import sys , math , copy\nHUGE = 2147483647\nHUGEL = 9223372036854775807\nABC = \"abcdefghijklmnopqrstuvwxyz\"\ndef main ( ) :\n    h , w = map ( int , input ( ).split ( ) )\n    su = 0\n    for i in range ( h ) :\n        line = input ( )\n        su += line.count ( \"#\" )\n    print ( \"Possible\" if su == h + w - 1 else \"Impossible\" )\nmain ( )\n", "python_code_tokenized": "import sys , math , copy NEW_LINE HUGE = 2147483647 NEW_LINE HUGEL = 9223372036854775807 NEW_LINE ABC = \" abcdefghijklmnopqrstuvwxyz \" NEW_LINE def main ( ) : NEW_LINE INDENT h , w = map ( int , input ( ) . split ( ) ) NEW_LINE su = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT line = input ( ) NEW_LINE su += line . count ( \" # \" ) NEW_LINE DEDENT print ( \" Possible \" if su == h + w - 1 else \" Impossible \" ) NEW_LINE DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_3775_A", "sol": 0, "python_code": "def removeDulipcates ( arr ) :\n    s = dict ( )\n    d = [ ]\n    for i in arr :\n        if i not in s.keys ( ) :\n            d.append ( i )\n            s [ i ] = 1\n    print ( d )\narr = [ 1 , 2 , 5 , 1 , 7 , 2 , 4 , 2 ]\nremoveDulipcates ( arr )\n", "python_code_tokenized": "def removeDulipcates ( arr ) : NEW_LINE INDENT s = dict ( ) NEW_LINE d = [ ] NEW_LINE for i in arr : NEW_LINE INDENT if i not in s . keys ( ) : NEW_LINE INDENT d . append ( i ) NEW_LINE s [ i ] = 1 NEW_LINE DEDENT DEDENT print ( d ) NEW_LINE DEDENT arr = [ 1 , 2 , 5 , 1 , 7 , 2 , 4 , 2 ] NEW_LINE removeDulipcates ( arr ) NEW_LINE"}
{"id": "geeksforgeeks_1274_A", "sol": 0, "python_code": "class Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.left = None\n        self.right = None\ndef PrintLeafLeftToRight ( root ) :\n    s1 = [ ]\n    s2 = [ ]\n    s1.append ( root )\n    while len ( s1 ) != 0 :\n        curr = s1.pop ( )\n        if curr.left :\n            s1.append ( curr.left )\n        if curr.right :\n            s1.append ( curr.right )\n        elif not curr.left and not curr.right :\n            s2.append ( curr )\n    while len ( s2 ) != 0 :\n        print ( s2.pop ( ).data , end = \" \" )\nif __name__ == \"__main__\" :\n    root = Node ( 1 )\n    root.left = Node ( 2 )\n    root.right = Node ( 3 )\n    root.left.left = Node ( 4 )\n    root.right.left = Node ( 5 )\n    root.right.right = Node ( 7 )\n    root.left.left.left = Node ( 10 )\n    root.left.left.right = Node ( 11 )\n    root.right.right.left = Node ( 8 )\n    PrintLeafLeftToRight ( root )\n", "python_code_tokenized": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def PrintLeafLeftToRight ( root ) : NEW_LINE INDENT s1 = [ ] NEW_LINE s2 = [ ] NEW_LINE s1 . append ( root ) NEW_LINE while len ( s1 ) != 0 : NEW_LINE INDENT curr = s1 . pop ( ) NEW_LINE if curr . left : NEW_LINE INDENT s1 . append ( curr . left ) NEW_LINE DEDENT if curr . right : NEW_LINE INDENT s1 . append ( curr . right ) NEW_LINE DEDENT elif not curr . left and not curr . right : NEW_LINE INDENT s2 . append ( curr ) NEW_LINE DEDENT DEDENT while len ( s2 ) != 0 : NEW_LINE INDENT print ( s2 . pop ( ) . data , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . right . left = Node ( 5 ) NEW_LINE root . right . right = Node ( 7 ) NEW_LINE root . left . left . left = Node ( 10 ) NEW_LINE root . left . left . right = Node ( 11 ) NEW_LINE root . right . right . left = Node ( 8 ) NEW_LINE PrintLeafLeftToRight ( root ) NEW_LINE DEDENT"}
{"id": "leetcode_680_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def validPalindrome ( self , s ) :\n        return self.validPalindromeHelper ( s , 0 , len ( s ) - 1 , 1 )\n    def validPalindromeHelper ( self , s , left , right , budget ) :\n        while left < len ( s ) and right >= 0 and left <= right and s [ left ] == s [ right ] :\n            left += 1\n            right -= 1\n        if left >= len ( s ) or right < 0 or left >= right :\n            return True\n        if budget == 0 :\n            return False\n        budget -= 1\n        return self.validPalindromeHelper ( s , left + 1 , right , budget ) or self.validPalindromeHelper ( s , left , right - 1 , budget )\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def validPalindrome ( self , s ) : NEW_LINE INDENT return self . validPalindromeHelper ( s , 0 , len ( s ) - 1 , 1 ) NEW_LINE DEDENT def validPalindromeHelper ( self , s , left , right , budget ) : NEW_LINE INDENT while left < len ( s ) and right >= 0 and left <= right and s [ left ] == s [ right ] : NEW_LINE INDENT left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT if left >= len ( s ) or right < 0 or left >= right : NEW_LINE INDENT return True NEW_LINE DEDENT if budget == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT budget -= 1 NEW_LINE return self . validPalindromeHelper ( s , left + 1 , right , budget ) or self . validPalindromeHelper ( s , left , right - 1 , budget ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1097_A", "sol": 0, "python_code": "from math import sqrt , floor\npref = [ 0 ] * 100010 ;\ndef isPerfectSquare ( x ) :\n    sr = sqrt ( x ) ;\n    rslt = x if ( sr - floor ( sr ) == 0 ) else 0 ;\n    return rslt ;\ndef compute ( ) :\n    for i in range ( 1 , 100001 ) :\n        pref [ i ] = pref [ i - 1 ] + isPerfectSquare ( i ) ;\ndef printSum ( L , R ) :\n    sum = pref [ R ] - pref [ L - 1 ] ;\n    print ( sum , end = \" \" ) ;\nif __name__ == \"__main__\" :\n    compute ( ) ;\n    Q = 4 ;\n    arr = [ [ 1 , 10 ] , [ 1 , 100 ] , [ 2 , 25 ] , [ 4 , 50 ] ] ;\n    for i in range ( Q ) :\n        printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ;\n", "python_code_tokenized": "from math import sqrt , floor NEW_LINE pref = [ 0 ] * 100010 ; NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) ; NEW_LINE rslt = x if ( sr - floor ( sr ) == 0 ) else 0 ; NEW_LINE return rslt ; NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + isPerfectSquare ( i ) ; NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT sum = pref [ R ] - pref [ L - 1 ] ; NEW_LINE print ( sum , end = \" \u2581 \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT compute ( ) ; NEW_LINE Q = 4 ; NEW_LINE arr = [ [ 1 , 10 ] , [ 1 , 100 ] , [ 2 , 25 ] , [ 4 , 50 ] ] ; NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2151_A", "sol": 0, "python_code": "def Conversion ( n ) :\n    return ( n - 32.0 ) * 5.0 / 9.0\nn = 40\nx = Conversion ( n )\nprint ( x )\n", "python_code_tokenized": "def Conversion ( n ) : NEW_LINE INDENT return ( n - 32.0 ) * 5.0 / 9.0 NEW_LINE DEDENT n = 40 NEW_LINE x = Conversion ( n ) NEW_LINE print ( x ) NEW_LINE"}
{"id": "geeksforgeeks_3174_A", "sol": 0, "python_code": "def ways ( n ) :\n    return n // 2\nn = 2\nprint ( ways ( n ) )\n", "python_code_tokenized": "def ways ( n ) : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT n = 2 NEW_LINE print ( ways ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3541_A", "sol": 0, "python_code": "def maxPrmimes ( n ) :\n    return n // 2\nn = 17\nprint ( maxPrmimes ( n ) )\n", "python_code_tokenized": "def maxPrmimes ( n ) : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT n = 17 NEW_LINE print ( maxPrmimes ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2150_A", "sol": 0, "python_code": "def Cel_To_Fah ( n ) :\n    return ( n * 1.8 ) + 32\nn = 20\nprint ( int ( Cel_To_Fah ( n ) ) )\n", "python_code_tokenized": "def Cel_To_Fah ( n ) : NEW_LINE INDENT return ( n * 1.8 ) + 32 NEW_LINE DEDENT n = 20 NEW_LINE print ( int ( Cel_To_Fah ( n ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_4349_A", "sol": 0, "python_code": "def nthEven ( n ) :\n    return ( 2 * n )\nif __name__ == '__main__' :\n    n = 10\n    print ( nthEven ( n ) )\n", "python_code_tokenized": "def nthEven ( n ) : NEW_LINE INDENT return ( 2 * n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( nthEven ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4348_A", "sol": 0, "python_code": "def nthOdd ( n ) :\n    return ( 2 * n - 1 )\nif __name__ == '__main__' :\n    n = 10\n    print ( nthOdd ( n ) )\n", "python_code_tokenized": "def nthOdd ( n ) : NEW_LINE INDENT return ( 2 * n - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( nthOdd ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1301_A", "sol": 0, "python_code": "def countNumbers ( n ) :\n    return n // 2520\nn = 3000\nprint ( countNumbers ( n ) )\n", "python_code_tokenized": "def countNumbers ( n ) : NEW_LINE INDENT return n // 2520 NEW_LINE DEDENT n = 3000 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3690_A", "sol": 0, "python_code": "def cntSquares ( n ) :\n    return int ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 )\nif __name__ == \"__main__\" :\n    print ( cntSquares ( 4 ) ) ;\n", "python_code_tokenized": "def cntSquares ( n ) : NEW_LINE INDENT return int ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( cntSquares ( 4 ) ) ; NEW_LINE DEDENT"}
{"id": "aizu_p02370_A", "sol": 0, "python_code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\nN , M = map ( int , input ( ).split ( ) )\nG = [ [ ] for _ in [ 0 ] * N ]\ndeg = [ 0 ] * N\nfor _ in [ 0 ] * M :\n    a , b = map ( int , input ( ).split ( ) )\n    G [ a ].append ( b )\n    deg [ b ] += 1\nq = deque ( )\nfor v , d in enumerate ( deg ) :\n    if d == 0 :\n        print ( v )\n        q.append ( v )\nwhile q :\n    v = q.popleft ( )\n    for u in G [ v ] :\n        deg [ u ] -= 1\n        if deg [ u ] == 0 :\n            print ( u )\n            q.append ( u )\n", "python_code_tokenized": "from collections import deque NEW_LINE import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE G = [ [ ] for _ in [ 0 ] * N ] NEW_LINE deg = [ 0 ] * N NEW_LINE for _ in [ 0 ] * M : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE G [ a ] . append ( b ) NEW_LINE deg [ b ] += 1 NEW_LINE DEDENT q = deque ( ) NEW_LINE for v , d in enumerate ( deg ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT print ( v ) NEW_LINE q . append ( v ) NEW_LINE DEDENT DEDENT while q : NEW_LINE INDENT v = q . popleft ( ) NEW_LINE for u in G [ v ] : NEW_LINE INDENT deg [ u ] -= 1 NEW_LINE if deg [ u ] == 0 : NEW_LINE INDENT print ( u ) NEW_LINE q . append ( u ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "codeforces_144_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\ni = a.index ( max ( a ) )\na = a [ : : - 1 ]\nk = ( - ( a.index ( min ( a ) ) ) ) - 1\na = a [ : : - 1 ]\nk1 = a [ 0 ]\nind = 0\nfor j in range ( 1 , n ) :\n    if a [ j ] <= k1 :\n        ind = j\n        k1 = a [ j ]\nif a [ 0 ] == max ( a ) and a [ - 1 ] == min ( a ) :\n    print ( 0 )\nelif i < ind :\n    print ( i + abs ( k ) - 1 )\nelse :\n    print ( i + abs ( k ) - 2 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = a . index ( max ( a ) ) NEW_LINE a = a [ : : - 1 ] NEW_LINE k = ( - ( a . index ( min ( a ) ) ) ) - 1 NEW_LINE a = a [ : : - 1 ] NEW_LINE k1 = a [ 0 ] NEW_LINE ind = 0 NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if a [ j ] <= k1 : NEW_LINE INDENT ind = j NEW_LINE k1 = a [ j ] NEW_LINE DEDENT DEDENT if a [ 0 ] == max ( a ) and a [ - 1 ] == min ( a ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif i < ind : NEW_LINE INDENT print ( i + abs ( k ) - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i + abs ( k ) - 2 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_756_A", "sol": 0, "python_code": "def maxAbsDiff ( arr , n ) :\n    minEle = arr [ 0 ]\n    maxEle = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        minEle = min ( minEle , arr [ i ] )\n        maxEle = max ( maxEle , arr [ i ] )\n    return ( maxEle - minEle )\narr = [ 2 , 1 , 5 , 3 ]\nn = len ( arr )\nprint ( maxAbsDiff ( arr , n ) )\n", "python_code_tokenized": "def maxAbsDiff ( arr , n ) : NEW_LINE INDENT minEle = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minEle = min ( minEle , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT return ( maxEle - minEle ) NEW_LINE DEDENT arr = [ 2 , 1 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxAbsDiff ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_399_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    if ( a == 0 ) :\n        return b ;\n    return gcd ( b % a , a ) ;\ndef lcm ( a , b ) :\n    return ( a * b ) / gcd ( a , b ) ;\ndef countPairs ( arr , n ) :\n    ans = 0 ;\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            if ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) :\n                ans += 1 ;\n    return ans ;\nif __name__ == '__main__' :\n    arr = [ 1 , 1 , 1 ] ;\n    n = len ( arr ) ;\n    print ( countPairs ( arr , n ) ) ;\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) / gcd ( a , b ) ; NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPairs ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1955_A", "sol": 0, "python_code": "def countNums ( l , r ) :\n    cnt = 0 ;\n    for i in range ( l , r + 1 ) :\n        lastDigit = ( i % 10 ) ;\n        if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) :\n            cnt += 1 ;\n    return cnt ;\nif __name__ == \"__main__\" :\n    l = 11 ; r = 33 ;\n    print ( countNums ( l , r ) ) ;\n", "python_code_tokenized": "def countNums ( l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT lastDigit = ( i % 10 ) ; NEW_LINE if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 11 ; r = 33 ; NEW_LINE print ( countNums ( l , r ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4258_A", "sol": 0, "python_code": "def permutatedRows ( mat , m , n , r ) :\n    s = set ( )\n    for j in range ( n ) :\n        s.add ( mat [ r ] [ j ] )\n    for i in range ( m ) :\n        if i == r :\n            continue\n        for j in range ( n ) :\n            if mat [ i ] [ j ] not in s :\n                j = j - 2\n                break ;\n        if j + 1 != n :\n            continue\n        print ( i )\nm = 4\nn = 4\nr = 3\nmat = [ [ 3 , 1 , 4 , 2 ] , [ 1 , 6 , 9 , 3 ] , [ 1 , 2 , 3 , 4 ] , [ 4 , 3 , 2 , 1 ] ]\npermutatedRows ( mat , m , n , r )\n", "python_code_tokenized": "def permutatedRows ( mat , m , n , r ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT s . add ( mat [ r ] [ j ] ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if i == r : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] not in s : NEW_LINE INDENT j = j - 2 NEW_LINE break ; NEW_LINE DEDENT DEDENT if j + 1 != n : NEW_LINE INDENT continue NEW_LINE DEDENT print ( i ) NEW_LINE DEDENT DEDENT m = 4 NEW_LINE n = 4 NEW_LINE r = 3 NEW_LINE mat = [ [ 3 , 1 , 4 , 2 ] , [ 1 , 6 , 9 , 3 ] , [ 1 , 2 , 3 , 4 ] , [ 4 , 3 , 2 , 1 ] ] NEW_LINE permutatedRows ( mat , m , n , r ) NEW_LINE"}
{"id": "geeksforgeeks_3899_A", "sol": 0, "python_code": "def isReachable ( sx , sy , dx , dy ) :\n    if ( sx > dx or sy > dy ) :\n        return False\n    if ( sx == dx and sy == dy ) :\n        return True\n    return ( isReachable ( sx + sy , sy , dx , dy ) or isReachable ( sx , sy + sx , dx , dy ) )\nsource_x , source_y = 2 , 10\ndest_x , dest_y = 26 , 12\nif ( isReachable ( source_x , source_y , dest_x , dest_y ) ) :\n    print ( \"True\" )\nelse :\n    print ( \"False\" )\n", "python_code_tokenized": "def isReachable ( sx , sy , dx , dy ) : NEW_LINE INDENT if ( sx > dx or sy > dy ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( sx == dx and sy == dy ) : NEW_LINE INDENT return True NEW_LINE DEDENT return ( isReachable ( sx + sy , sy , dx , dy ) or isReachable ( sx , sy + sx , dx , dy ) ) NEW_LINE DEDENT source_x , source_y = 2 , 10 NEW_LINE dest_x , dest_y = 26 , 12 NEW_LINE if ( isReachable ( source_x , source_y , dest_x , dest_y ) ) : NEW_LINE INDENT print ( \" True \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC134_F", "sol": 0, "python_code": "import sys\nfrom itertools import product\nMOD = 1000000007\ndef solve ( N : int , K : int ) :\n    if K % 2 == 1 :\n        print ( 0 )\n        return\n    dp = [ [ [ 0 for k in range ( K + 1 ) ] for j in range ( N + 2 ) ] for i in range ( N + 1 ) ]\n    dp [ 0 ] [ 0 ] [ 0 ] = 1\n    for i , j , k in product ( range ( 1 , N + 1 ) , range ( N + 1 ) , range ( K + 1 ) ) :\n        prev_k = k - 2 * j\n        if prev_k < 0 :\n            continue\n        dp [ i ] [ j ] [ k ] += dp [ i - 1 ] [ j ] [ prev_k ]\n        dp [ i ] [ j ] [ k ] += 2 * j * dp [ i - 1 ] [ j ] [ prev_k ]\n        dp [ i ] [ j ] [ k ] += ( j + 1 ) * ( j + 1 ) * dp [ i - 1 ] [ j + 1 ] [ prev_k ]\n        if j > 0 : dp [ i ] [ j ] [ k ] += dp [ i - 1 ] [ j - 1 ] [ prev_k ]\n        dp [ i ] [ j ] [ k ] %= MOD\n    print ( dp [ N ] [ 0 ] [ K ] )\n    return\ndef main ( ) :\n    def iterate_tokens ( ) :\n        for line in sys.stdin :\n            for word in line.split ( ) :\n                yield word\n    tokens = iterate_tokens ( )\n    n = int ( next ( tokens ) )\n    k = int ( next ( tokens ) )\n    solve ( n , k )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "import sys NEW_LINE from itertools import product NEW_LINE MOD = 1000000007 NEW_LINE def solve ( N : int , K : int ) : NEW_LINE INDENT if K % 2 == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT dp = [ [ [ 0 for k in range ( K + 1 ) ] for j in range ( N + 2 ) ] for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i , j , k in product ( range ( 1 , N + 1 ) , range ( N + 1 ) , range ( K + 1 ) ) : NEW_LINE INDENT prev_k = k - 2 * j NEW_LINE if prev_k < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i ] [ j ] [ k ] += dp [ i - 1 ] [ j ] [ prev_k ] NEW_LINE dp [ i ] [ j ] [ k ] += 2 * j * dp [ i - 1 ] [ j ] [ prev_k ] NEW_LINE dp [ i ] [ j ] [ k ] += ( j + 1 ) * ( j + 1 ) * dp [ i - 1 ] [ j + 1 ] [ prev_k ] NEW_LINE if j > 0 : dp [ i ] [ j ] [ k ] += dp [ i - 1 ] [ j - 1 ] [ prev_k ] NEW_LINE dp [ i ] [ j ] [ k ] %= MOD NEW_LINE DEDENT print ( dp [ N ] [ 0 ] [ K ] ) NEW_LINE return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE n = int ( next ( tokens ) ) NEW_LINE k = int ( next ( tokens ) ) NEW_LINE solve ( n , k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "projecteuler_p142_A", "sol": 0, "python_code": "import eulerlib , itertools\ndef compute ( ) :\n    def find_sum ( limit ) :\n        for a in itertools.count ( 1 ) :\n            if a * a >= limit :\n                break\n            for b in reversed ( range ( 1 , a ) ) :\n                if ( a + b ) % 2 != 0 :\n                    continue\n                x = ( a * a + b * b ) // 2\n                y = ( a * a - b * b ) // 2\n                if x + y + 1 >= limit :\n                    continue\n                zlimit = min ( y , limit - x - y )\n                for c in itertools.count ( eulerlib.sqrt ( y ) + 1 ) :\n                    z = c * c - y\n                    if z >= zlimit :\n                        break\n                    if issquare [ x + z ] and issquare [ x - z ] and issquare [ y - z ] :\n                        return x + y + z\n        return None\n    sumlimit = 10\n    while True :\n        issquare = [ False ] * sumlimit\n        for i in range ( eulerlib.sqrt ( len ( issquare ) - 1 ) + 1 ) :\n            issquare [ i * i ] = True\n        sum = find_sum ( sumlimit )\n        if sum is not None :\n            sum = sumlimit\n            break\n        sumlimit *= 10\n    while True :\n        sum = find_sum ( sumlimit )\n        if sum is None :\n            return str ( sumlimit )\n        sumlimit = sum\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT def find_sum ( limit ) : NEW_LINE INDENT for a in itertools . count ( 1 ) : NEW_LINE INDENT if a * a >= limit : NEW_LINE INDENT break NEW_LINE DEDENT for b in reversed ( range ( 1 , a ) ) : NEW_LINE INDENT if ( a + b ) % 2 != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT x = ( a * a + b * b ) // 2 NEW_LINE y = ( a * a - b * b ) // 2 NEW_LINE if x + y + 1 >= limit : NEW_LINE INDENT continue NEW_LINE DEDENT zlimit = min ( y , limit - x - y ) NEW_LINE for c in itertools . count ( eulerlib . sqrt ( y ) + 1 ) : NEW_LINE INDENT z = c * c - y NEW_LINE if z >= zlimit : NEW_LINE INDENT break NEW_LINE DEDENT if issquare [ x + z ] and issquare [ x - z ] and issquare [ y - z ] : NEW_LINE INDENT return x + y + z NEW_LINE DEDENT DEDENT DEDENT DEDENT return None NEW_LINE DEDENT sumlimit = 10 NEW_LINE while True : NEW_LINE INDENT issquare = [ False ] * sumlimit NEW_LINE for i in range ( eulerlib . sqrt ( len ( issquare ) - 1 ) + 1 ) : NEW_LINE INDENT issquare [ i * i ] = True NEW_LINE DEDENT sum = find_sum ( sumlimit ) NEW_LINE if sum is not None : NEW_LINE INDENT sum = sumlimit NEW_LINE break NEW_LINE DEDENT sumlimit *= 10 NEW_LINE DEDENT while True : NEW_LINE INDENT sum = find_sum ( sumlimit ) NEW_LINE if sum is None : NEW_LINE INDENT return str ( sumlimit ) NEW_LINE DEDENT sumlimit = sum NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5158_A", "sol": 0, "python_code": "def calculateSum ( arr , n ) :\n    if ( n == 0 ) :\n        return 0\n    s = arr [ 0 ]\n    value = int ( s )\n    sum = value\n    for i in range ( 2 , n , 2 ) :\n        s = arr [ i ]\n        value = int ( s )\n        operation = arr [ i - 1 ] [ 0 ]\n        if ( operation == '+' ) :\n            sum += value\n        else :\n            sum -= value\n    return sum\narr = [ \"3\" , \"+\" , \"4\" , \"-\" , \"7\" , \"+\" , \"13\" ]\nn = len ( arr )\nprint ( calculateSum ( arr , n ) )\n", "python_code_tokenized": "def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = int ( s ) NEW_LINE sum = value NEW_LINE for i in range ( 2 , n , 2 ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( s ) NEW_LINE operation = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ \"3\" , \" + \" , \"4\" , \" - \" , \"7\" , \" + \" , \"13\" ] NEW_LINE n = len ( arr ) NEW_LINE print ( calculateSum ( arr , n ) ) NEW_LINE"}
{"id": "aizu_p00729_A", "sol": 0, "python_code": "while True :\n    n , m = map ( int , input ( ).split ( ) )\n    if n == m == 0 :\n        break\n    l = int ( input ( ) )\n    v = [ [ ] for i in range ( m + 1 ) ]\n    for _ in range ( l ) :\n        t , nn , m , s = map ( int , input ( ).split ( ) )\n        s = 1 if s else - 1\n        v [ m ].append ( ( t , s ) )\n    q = int ( input ( ) )\n    for _ in range ( q ) :\n        s , e , m = map ( int , input ( ).split ( ) )\n        v [ m ].sort ( )\n        arr = [ 0 ] * 1261\n        for i , j in v [ m ] :\n            arr [ i ] += j\n        for i in range ( 540 , len ( arr ) - 1 ) :\n            arr [ i + 1 ] += arr [ i ]\n        res = 0\n        for i in range ( s , e ) :\n            if arr [ i ] > 0 :\n                res += 1\n        print ( res )\n", "python_code_tokenized": "while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT l = int ( input ( ) ) NEW_LINE v = [ [ ] for i in range ( m + 1 ) ] NEW_LINE for _ in range ( l ) : NEW_LINE INDENT t , nn , m , s = map ( int , input ( ) . split ( ) ) NEW_LINE s = 1 if s else - 1 NEW_LINE v [ m ] . append ( ( t , s ) ) NEW_LINE DEDENT q = int ( input ( ) ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT s , e , m = map ( int , input ( ) . split ( ) ) NEW_LINE v [ m ] . sort ( ) NEW_LINE arr = [ 0 ] * 1261 NEW_LINE for i , j in v [ m ] : NEW_LINE INDENT arr [ i ] += j NEW_LINE DEDENT for i in range ( 540 , len ( arr ) - 1 ) : NEW_LINE INDENT arr [ i + 1 ] += arr [ i ] NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( s , e ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1028_A", "sol": 0, "python_code": "n , m = [ int ( x ) for x in input ( ).split ( \" \" ) ]\nlists = [ ]\nsq = 0\nl = k = 0\nfor i in range ( n ) :\n    lists.append ( input ( ) )\nfor i in range ( n ) :\n    sq = lists [ i ].count ( \"B\" )\n    if sq != 0 :\n        sq = ( sq + 1 ) // 2\n        l = i\n        k = lists [ i ].find ( \"B\" )\n        break\nprint ( l + sq , k + sq )\n", "python_code_tokenized": "n , m = [ int ( x ) for x in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE lists = [ ] NEW_LINE sq = 0 NEW_LINE l = k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lists . append ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sq = lists [ i ] . count ( \" B \" ) NEW_LINE if sq != 0 : NEW_LINE INDENT sq = ( sq + 1 ) // 2 NEW_LINE l = i NEW_LINE k = lists [ i ] . find ( \" B \" ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( l + sq , k + sq ) NEW_LINE"}
{"id": "codeforces_900_B", "sol": 0, "python_code": "def calculateFraction ( num , den ) :\n    if ( num == 0 ) :\n        return \"0\"\n    sign = - 1 if ( num < 0 ) ^ ( den < 0 ) else 1\n    num = abs ( num )\n    den = abs ( den )\n    initial = num // den\n    res = \"\"\n    if ( sign == - 1 ) :\n        res += \"-\"\n    res += str ( initial )\n    if ( num % den == 0 ) :\n        return res\n    res += \".\"\n    rem = num % den\n    mp = { }\n    index = 0\n    repeating = False\n    while ( rem > 0 and not repeating ) :\n        if ( rem in mp ) :\n            index = mp [ rem ]\n            repeating = True\n            break\n        else :\n            mp [ rem ] = len ( res )\n        rem = rem * 10\n        temp = rem // den\n        res += str ( temp )\n        rem = rem % den\n    if ( repeating ) :\n        x = res [ : index ]\n        x += res [ index : ]\n        res = x\n    else :\n        res += \"0\"\n    return res\ndef find_decimal ( decimal , c ) :\n    for i in range ( 2 , len ( decimal ) ) :\n        if decimal [ i ] == str ( c ) :\n            print ( i - 1 )\n            return\n    print ( - 1 )\nn = input ( )\nnumbers = n.split ( )\nnum = int ( numbers [ 0 ] )\nden = int ( numbers [ 1 ] )\ndigit = int ( numbers [ 2 ] )\nfraction = calculateFraction ( num , den )\nfind_decimal ( fraction , digit )\n", "python_code_tokenized": "def calculateFraction ( num , den ) : NEW_LINE INDENT if ( num == 0 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT sign = - 1 if ( num < 0 ) ^ ( den < 0 ) else 1 NEW_LINE num = abs ( num ) NEW_LINE den = abs ( den ) NEW_LINE initial = num // den NEW_LINE res = \" \" NEW_LINE if ( sign == - 1 ) : NEW_LINE INDENT res += \" - \" NEW_LINE DEDENT res += str ( initial ) NEW_LINE if ( num % den == 0 ) : NEW_LINE INDENT return res NEW_LINE DEDENT res += \" . \" NEW_LINE rem = num % den NEW_LINE mp = { } NEW_LINE index = 0 NEW_LINE repeating = False NEW_LINE while ( rem > 0 and not repeating ) : NEW_LINE INDENT if ( rem in mp ) : NEW_LINE INDENT index = mp [ rem ] NEW_LINE repeating = True NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT mp [ rem ] = len ( res ) NEW_LINE DEDENT rem = rem * 10 NEW_LINE temp = rem // den NEW_LINE res += str ( temp ) NEW_LINE rem = rem % den NEW_LINE DEDENT if ( repeating ) : NEW_LINE INDENT x = res [ : index ] NEW_LINE x += res [ index : ] NEW_LINE res = x NEW_LINE DEDENT else : NEW_LINE INDENT res += \"0\" NEW_LINE DEDENT return res NEW_LINE DEDENT def find_decimal ( decimal , c ) : NEW_LINE INDENT for i in range ( 2 , len ( decimal ) ) : NEW_LINE INDENT if decimal [ i ] == str ( c ) : NEW_LINE INDENT print ( i - 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT n = input ( ) NEW_LINE numbers = n . split ( ) NEW_LINE num = int ( numbers [ 0 ] ) NEW_LINE den = int ( numbers [ 1 ] ) NEW_LINE digit = int ( numbers [ 2 ] ) NEW_LINE fraction = calculateFraction ( num , den ) NEW_LINE find_decimal ( fraction , digit ) NEW_LINE"}
{"id": "geeksforgeeks_40_A", "sol": 0, "python_code": "def reverse ( num ) :\n    rev_num = 0\n    while ( num > 0 ) :\n        rev_num = rev_num * 10 + num % 10\n        num = num // 10\n    return rev_num\ndef countReverse ( arr , n ) :\n    res = 0\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            if ( reverse ( arr [ i ] ) == arr [ j ] ) :\n                res += 1\n    return res\nif __name__ == '__main__' :\n    a = [ 16 , 61 , 12 , 21 , 25 ]\n    n = len ( a )\n    print ( countReverse ( a , n ) )\n", "python_code_tokenized": "def reverse ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT def countReverse ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( reverse ( arr [ i ] ) == arr [ j ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 16 , 61 , 12 , 21 , 25 ] NEW_LINE n = len ( a ) NEW_LINE print ( countReverse ( a , n ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02405_A", "sol": 0, "python_code": "ls = [ ]\ncnt = 2\nwhile 1 :\n    ls1 = list ( map ( int , input ( ).split ( ) ) )\n    if ls1 [ 0 ] == 0 and ls1 [ 1 ] == 0 :\n        break\n    else :\n        ls.append ( list ( ls1 ) )\n        ls1.clear ( )\nfor i in range ( len ( ls ) ) :\n    for j in range ( ls [ i ] [ 0 ] ) :\n        for l in range ( ls [ i ] [ 1 ] ) :\n            if j % 2 == 0 :\n                if cnt % 2 == 0 :\n                    print ( \"#\" , end = \"\" )\n                    cnt += 1\n                else :\n                    print ( \".\" , end = \"\" )\n                    cnt += 1\n            else :\n                if cnt % 2 == 0 :\n                    print ( \".\" , end = \"\" )\n                    cnt += 1\n                else :\n                    print ( \"#\" , end = \"\" )\n                    cnt += 1\n        cnt = 2\n        print ( )\n    print ( )\n", "python_code_tokenized": "ls = [ ] NEW_LINE cnt = 2 NEW_LINE while 1 : NEW_LINE INDENT ls1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ls1 [ 0 ] == 0 and ls1 [ 1 ] == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT ls . append ( list ( ls1 ) ) NEW_LINE ls1 . clear ( ) NEW_LINE DEDENT DEDENT for i in range ( len ( ls ) ) : NEW_LINE INDENT for j in range ( ls [ i ] [ 0 ] ) : NEW_LINE INDENT for l in range ( ls [ i ] [ 1 ] ) : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT if cnt % 2 == 0 : NEW_LINE INDENT print ( \" # \" , end = \" \" ) NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" . \" , end = \" \" ) NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if cnt % 2 == 0 : NEW_LINE INDENT print ( \" . \" , end = \" \" ) NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" # \" , end = \" \" ) NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT DEDENT cnt = 2 NEW_LINE print ( ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3463_A", "sol": 0, "python_code": "INF = 99999\nsize = 10\ndef getSetBitsFromOneToN ( N ) :\n    two , ans = 2 , 0\n    n = N\n    while ( n > 0 ) :\n        ans += ( N // two ) * ( two >> 1 )\n        if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) :\n            ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1\n        two <<= 1\n        n >>= 1\n    return ans\ndef findMinimum ( x ) :\n    low = 0\n    high = 100000\n    ans = high\n    while ( low <= high ) :\n        mid = ( low + high ) >> 1\n        if ( getSetBitsFromOneToN ( mid ) >= x ) :\n            ans = min ( ans , mid )\n            high = mid - 1\n        else :\n            low = mid + 1\n    return ans\nx = 20\nprint ( findMinimum ( x ) )\n", "python_code_tokenized": "INF = 99999 NEW_LINE size = 10 NEW_LINE def getSetBitsFromOneToN ( N ) : NEW_LINE INDENT two , ans = 2 , 0 NEW_LINE n = N NEW_LINE while ( n > 0 ) : NEW_LINE INDENT ans += ( N // two ) * ( two >> 1 ) NEW_LINE if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) : NEW_LINE INDENT ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 NEW_LINE DEDENT two <<= 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def findMinimum ( x ) : NEW_LINE INDENT low = 0 NEW_LINE high = 100000 NEW_LINE ans = high NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( getSetBitsFromOneToN ( mid ) >= x ) : NEW_LINE INDENT ans = min ( ans , mid ) NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT x = 20 NEW_LINE print ( findMinimum ( x ) ) NEW_LINE"}
{"id": "geeksforgeeks_4932_A", "sol": 0, "python_code": "def countWords ( str , l ) :\n    count = 1 ;\n    if ( l == 1 ) :\n        return count\n    if ( str [ 0 ] == str [ 1 ] ) :\n        count *= 1\n    else :\n        count *= 2\n    for j in range ( 1 , l - 1 ) :\n        if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) :\n            count *= 1\n        elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) :\n            count *= 2\n        else :\n            count *= 3\n    if ( str [ l - 1 ] == str [ l - 2 ] ) :\n        count *= 1\n    else :\n        count *= 2\n    return count\nif __name__ == \"__main__\" :\n    str = \"abc\"\n    l = len ( str )\n    print ( countWords ( str , l ) )\n", "python_code_tokenized": "def countWords ( str , l ) : NEW_LINE INDENT count = 1 ; NEW_LINE if ( l == 1 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( str [ 0 ] == str [ 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT for j in range ( 1 , l - 1 ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if ( str [ l - 1 ] == str [ l - 2 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" abc \" NEW_LINE l = len ( str ) NEW_LINE print ( countWords ( str , l ) ) NEW_LINE DEDENT"}
{"id": "codeforces_279_A", "sol": 0, "python_code": "l = input ( ).split ( ' ' )\nx , y = int ( l [ 0 ] ) , int ( l [ 1 ] )\nif y <= 0 and x >= 1 + y and x <= 1 - y :\n    print ( ( - y ) * 4 )\nelif x > 0 and y >= 2 - x and y <= x :\n    print ( x * 4 - 3 )\nelif y > 0 and x >= - y and x <= y - 1 :\n    print ( y * 4 - 2 )\nelif x < 0 and y >= x and y <= - 1 - x :\n    print ( ( - x ) * 4 - 1 )\nelse :\n    print ( 0 )\n", "python_code_tokenized": "l = input ( ) . split ( ' \u2581 ' ) NEW_LINE x , y = int ( l [ 0 ] ) , int ( l [ 1 ] ) NEW_LINE if y <= 0 and x >= 1 + y and x <= 1 - y : NEW_LINE INDENT print ( ( - y ) * 4 ) NEW_LINE DEDENT elif x > 0 and y >= 2 - x and y <= x : NEW_LINE INDENT print ( x * 4 - 3 ) NEW_LINE DEDENT elif y > 0 and x >= - y and x <= y - 1 : NEW_LINE INDENT print ( y * 4 - 2 ) NEW_LINE DEDENT elif x < 0 and y >= x and y <= - 1 - x : NEW_LINE INDENT print ( ( - x ) * 4 - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT"}
{"id": "aizu_p00387_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\nprint ( ( b + a - 1 ) // a )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( b + a - 1 ) // a ) NEW_LINE"}
{"id": "aizu_p00274_A", "sol": 0, "python_code": "while True :\n    n = int ( input ( ) )\n    if n == 0 :\n        break\n    s = list ( map ( int , input ( ).split ( ) ) )\n    if max ( s ) < 2 :\n        print ( 'NA' )\n    else :\n        t = s.count ( 0 )\n        print ( n - t + 1 )\n", "python_code_tokenized": "while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if max ( s ) < 2 : NEW_LINE INDENT print ( ' NA ' ) NEW_LINE DEDENT else : NEW_LINE INDENT t = s . count ( 0 ) NEW_LINE print ( n - t + 1 ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_406_A", "sol": 0, "python_code": "def find_max ( A , N , K ) :\n    Count = dict ( )\n    for i in range ( K - 1 ) :\n        Count [ A [ i ] ] = Count.get ( A [ i ] , 0 ) + 1\n    Myset = dict ( )\n    for x in Count :\n        if ( Count [ x ] == 1 ) :\n            Myset [ x ] = 1\n    for i in range ( K - 1 , N ) :\n        Count [ A [ i ] ] = Count.get ( A [ i ] , 0 ) + 1\n        if ( Count [ A [ i ] ] == 1 ) :\n            Myset [ A [ i ] ] = 1\n        else :\n            del Myset [ A [ i ] ]\n        if ( len ( Myset ) == 0 ) :\n            print ( \"Nothing\" )\n        else :\n            maxm = - 10 ** 9\n            for i in Myset :\n                maxm = max ( i , maxm )\n            print ( maxm )\n        x = A [ i - K + 1 ]\n        if x in Count.keys ( ) :\n            Count [ x ] -= 1\n            if ( Count [ x ] == 1 ) :\n                Myset [ x ] = 1\n            if ( Count [ x ] == 0 ) :\n                del Myset [ x ]\na = [ 1 , 2 , 2 , 3 , 3 ]\nn = len ( a )\nk = 3\nfind_max ( a , n , k )\n", "python_code_tokenized": "def find_max ( A , N , K ) : NEW_LINE INDENT Count = dict ( ) NEW_LINE for i in range ( K - 1 ) : NEW_LINE INDENT Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 NEW_LINE DEDENT Myset = dict ( ) NEW_LINE for x in Count : NEW_LINE INDENT if ( Count [ x ] == 1 ) : NEW_LINE INDENT Myset [ x ] = 1 NEW_LINE DEDENT DEDENT for i in range ( K - 1 , N ) : NEW_LINE INDENT Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 NEW_LINE if ( Count [ A [ i ] ] == 1 ) : NEW_LINE INDENT Myset [ A [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT del Myset [ A [ i ] ] NEW_LINE DEDENT if ( len ( Myset ) == 0 ) : NEW_LINE INDENT print ( \" Nothing \" ) NEW_LINE DEDENT else : NEW_LINE INDENT maxm = - 10 ** 9 NEW_LINE for i in Myset : NEW_LINE INDENT maxm = max ( i , maxm ) NEW_LINE DEDENT print ( maxm ) NEW_LINE DEDENT x = A [ i - K + 1 ] NEW_LINE if x in Count . keys ( ) : NEW_LINE INDENT Count [ x ] -= 1 NEW_LINE if ( Count [ x ] == 1 ) : NEW_LINE INDENT Myset [ x ] = 1 NEW_LINE DEDENT if ( Count [ x ] == 0 ) : NEW_LINE INDENT del Myset [ x ] NEW_LINE DEDENT DEDENT DEDENT DEDENT a = [ 1 , 2 , 2 , 3 , 3 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE find_max ( a , n , k ) NEW_LINE"}
{"id": "codeforces_58_A", "sol": 0, "python_code": "def main ( ) :\n    txt = input ( )\n    if hello ( txt ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\ndef hello ( txt , n = 0 ) :\n    list = [ \"h\" , \"e\" , \"l\" , \"l\" , \"o\" ]\n    for s in txt :\n        if s == list [ n ] :\n            n += 1\n            if n < 5 :\n                hello ( txt [ txt.index ( s ) + 1 : ] , n )\n            else :\n                break\n    if n == 5 :\n        return True\n    else :\n        return False\nmain ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT txt = input ( ) NEW_LINE if hello ( txt ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT def hello ( txt , n = 0 ) : NEW_LINE INDENT list = [ \" h \" , \" e \" , \" l \" , \" l \" , \" o \" ] NEW_LINE for s in txt : NEW_LINE INDENT if s == list [ n ] : NEW_LINE INDENT n += 1 NEW_LINE if n < 5 : NEW_LINE INDENT hello ( txt [ txt . index ( s ) + 1 : ] , n ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if n == 5 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_2228_A", "sol": 0, "python_code": "def getProduct ( n ) :\n    product = 1\n    while ( n != 0 ) :\n        product = product * ( n % 10 )\n        n = n // 10\n    return product\nn = 4513\nprint ( getProduct ( n ) )\n", "python_code_tokenized": "def getProduct ( n ) : NEW_LINE INDENT product = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT product = product * ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n = 4513 NEW_LINE print ( getProduct ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4100_A", "sol": 0, "python_code": "def printGroups ( n ) :\n    x = 1\n    y = n * n\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , n // 2 + 1 ) :\n            print ( \"{\" , x , \",\" , y , \"}\" , end = \" \" )\n            x += 1\n            y -= 1\n        print ( )\nif __name__ == \"__main__\" :\n    n = 4\n    printGroups ( n )\n", "python_code_tokenized": "def printGroups ( n ) : NEW_LINE INDENT x = 1 NEW_LINE y = n * n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT print ( \" { \" , x , \" , \" , y , \" } \" , end = \" \u2581 \" ) NEW_LINE x += 1 NEW_LINE y -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE printGroups ( n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1277_A", "sol": 0, "python_code": "class newNode :\n    def __init__ ( self , data ) :\n        self.data = data ;\n        self.left = None ;\n        self.right = None ;\ndef insert ( root , data ) :\n    if ( root == None ) :\n        return newNode ( data ) ;\n    else :\n        if ( data < root.data ) :\n            root.left = insert ( root.left , data ) ;\n        if ( data > root.data ) :\n            root.right = insert ( root.right , data ) ;\n        return root ;\ndef inOrder ( root ) :\n    if ( root == None ) :\n        return ;\n    else :\n        inOrder ( root.left ) ;\n        print ( root.data , end = \" \" ) ;\n        inOrder ( root.right ) ;\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 3 , 2 , 5 , 4 , 4 ] ;\n    n = len ( arr ) ;\n    root = None ;\n    for i in range ( n ) :\n        root = insert ( root , arr [ i ] ) ;\n    inOrder ( root ) ;\n", "python_code_tokenized": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data ; NEW_LINE self . left = None ; NEW_LINE self . right = None ; NEW_LINE DEDENT DEDENT def insert ( root , data ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return newNode ( data ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( data < root . data ) : NEW_LINE INDENT root . left = insert ( root . left , data ) ; NEW_LINE DEDENT if ( data > root . data ) : NEW_LINE INDENT root . right = insert ( root . right , data ) ; NEW_LINE DEDENT return root ; NEW_LINE DEDENT DEDENT def inOrder ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return ; NEW_LINE DEDENT else : NEW_LINE INDENT inOrder ( root . left ) ; NEW_LINE print ( root . data , end = \" \u2581 \" ) ; NEW_LINE inOrder ( root . right ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 5 , 4 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE root = None ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT root = insert ( root , arr [ i ] ) ; NEW_LINE DEDENT inOrder ( root ) ; NEW_LINE DEDENT"}
{"id": "atcoder_ARC071_B", "sol": 0, "python_code": "import sys\nreadline = sys.stdin.readline\nN , M = map ( int , readline ( ).split ( ) )\nMOD = 10 ** 9 + 7\nN -= 1\nM -= 1\nX = list ( map ( int , readline ( ).split ( ) ) )\nCX = [ x2 - x1 for x1 , x2 in zip ( X , X [ 1 : ] ) ]\nCX = [ CX [ i ] * ( N - i ) * ( i + 1 ) for i in range ( N ) ]\nY = list ( map ( int , readline ( ).split ( ) ) )\nCY = [ y2 - y1 for y1 , y2 in zip ( Y , Y [ 1 : ] ) ]\nCY = [ CY [ j ] * ( M - j ) * ( j + 1 ) for j in range ( M ) ]\nprint ( sum ( CX ) % MOD * sum ( CY ) % MOD )\n", "python_code_tokenized": "import sys NEW_LINE readline = sys . stdin . readline NEW_LINE N , M = map ( int , readline ( ) . split ( ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N -= 1 NEW_LINE M -= 1 NEW_LINE X = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE CX = [ x2 - x1 for x1 , x2 in zip ( X , X [ 1 : ] ) ] NEW_LINE CX = [ CX [ i ] * ( N - i ) * ( i + 1 ) for i in range ( N ) ] NEW_LINE Y = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE CY = [ y2 - y1 for y1 , y2 in zip ( Y , Y [ 1 : ] ) ] NEW_LINE CY = [ CY [ j ] * ( M - j ) * ( j + 1 ) for j in range ( M ) ] NEW_LINE print ( sum ( CX ) % MOD * sum ( CY ) % MOD ) NEW_LINE"}
{"id": "geeksforgeeks_1554_A", "sol": 0, "python_code": "from collections import defaultdict\ndef longLenSub ( arr , n ) :\n    um = defaultdict ( lambda : 0 )\n    longLen = 0\n    for i in range ( n ) :\n        len1 = 0\n        if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] - 1 ] ) :\n            len1 = um [ arr [ i ] - 1 ]\n        if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] + 1 ] ) :\n            len1 = um [ arr [ i ] + 1 ]\n        um [ arr [ i ] ] = len1 + 1\n        if longLen < um [ arr [ i ] ] :\n            longLen = um [ arr [ i ] ]\n    return longLen\narr = [ 1 , 2 , 3 , 4 , 5 , 3 , 2 ]\nn = len ( arr )\nprint ( \"Longest length subsequence =\" , longLenSub ( arr , n ) )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE def longLenSub ( arr , n ) : NEW_LINE INDENT um = defaultdict ( lambda : 0 ) NEW_LINE longLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len1 = 0 NEW_LINE if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] - 1 ] ) : NEW_LINE INDENT len1 = um [ arr [ i ] - 1 ] NEW_LINE DEDENT if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] + 1 ] ) : NEW_LINE INDENT len1 = um [ arr [ i ] + 1 ] NEW_LINE DEDENT um [ arr [ i ] ] = len1 + 1 NEW_LINE if longLen < um [ arr [ i ] ] : NEW_LINE INDENT longLen = um [ arr [ i ] ] NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Longest \u2581 length \u2581 subsequence \u2581 = \" , longLenSub ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4456_A", "sol": 0, "python_code": "def checkIfAllVowels ( string ) :\n    hash = [ 0 ] * 5 ;\n    for i in range ( len ( string ) ) :\n        if ( string [ i ] == 'A' or string [ i ] == 'a' ) :\n            hash [ 0 ] = 1 ;\n        elif ( string [ i ] == 'E' or string [ i ] == 'e' ) :\n            hash [ 1 ] = 1 ;\n        elif ( string [ i ] == 'I' or string [ i ] == 'i' ) :\n            hash [ 2 ] = 1 ;\n        elif ( string [ i ] == 'O' or string [ i ] == 'o' ) :\n            hash [ 3 ] = 1 ;\n        elif ( string [ i ] == 'U' or string [ i ] == 'u' ) :\n            hash [ 4 ] = 1 ;\n    for i in range ( 5 ) :\n        if ( hash [ i ] == 0 ) :\n            return 1 ;\n    return 0 ;\ndef checkIfAllVowelsArePresent ( string ) :\n    if ( checkIfAllVowels ( string ) ) :\n        print ( \"Not Accepted\" ) ;\n    else :\n        print ( \"Accepted\" ) ;\nif __name__ == \"__main__\" :\n    string = \"aeioubc\" ;\n    checkIfAllVowelsArePresent ( string ) ;\n", "python_code_tokenized": "def checkIfAllVowels ( string ) : NEW_LINE INDENT hash = [ 0 ] * 5 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ' A ' or string [ i ] == ' a ' ) : NEW_LINE INDENT hash [ 0 ] = 1 ; NEW_LINE DEDENT elif ( string [ i ] == ' E ' or string [ i ] == ' e ' ) : NEW_LINE INDENT hash [ 1 ] = 1 ; NEW_LINE DEDENT elif ( string [ i ] == ' I ' or string [ i ] == ' i ' ) : NEW_LINE INDENT hash [ 2 ] = 1 ; NEW_LINE DEDENT elif ( string [ i ] == ' O ' or string [ i ] == ' o ' ) : NEW_LINE INDENT hash [ 3 ] = 1 ; NEW_LINE DEDENT elif ( string [ i ] == ' U ' or string [ i ] == ' u ' ) : NEW_LINE INDENT hash [ 4 ] = 1 ; NEW_LINE DEDENT DEDENT for i in range ( 5 ) : NEW_LINE INDENT if ( hash [ i ] == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT def checkIfAllVowelsArePresent ( string ) : NEW_LINE INDENT if ( checkIfAllVowels ( string ) ) : NEW_LINE INDENT print ( \" Not \u2581 Accepted \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Accepted \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" aeioubc \" ; NEW_LINE checkIfAllVowelsArePresent ( string ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4869_A", "sol": 0, "python_code": "def printArray ( arr , n ) :\n    arr.sort ( )\n    l = 0\n    r = n - 1\n    flag = 0\n    k = 2\n    while ( l <= r ) :\n        if ( flag == 0 ) :\n            i = l\n            while i < l + k and i <= r :\n                print ( arr [ i ] , end = \" \" )\n                i += 1\n            flag = 1\n            l = i\n        else :\n            i = r\n            while i > r - k and i >= l :\n                print ( arr [ i ] , end = \" \" )\n                i -= 1\n            flag = 0\n            r = i\n        k += 1\nif __name__ == \"__main__\" :\n    n = 6\n    arr = [ 1 , 2 , 3 , 4 , 5 , 6 ]\n    printArray ( arr , n )\n", "python_code_tokenized": "def printArray ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE flag = 0 NEW_LINE k = 2 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( flag == 0 ) : NEW_LINE INDENT i = l NEW_LINE while i < l + k and i <= r : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE i += 1 NEW_LINE DEDENT flag = 1 NEW_LINE l = i NEW_LINE DEDENT else : NEW_LINE INDENT i = r NEW_LINE while i > r - k and i >= l : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE i -= 1 NEW_LINE DEDENT flag = 0 NEW_LINE r = i NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5058_A", "sol": 0, "python_code": "import math as mt\ndef countPairs ( arr , n ) :\n    mp = dict ( )\n    for i in range ( n ) :\n        if arr [ i ] in mp.keys ( ) :\n            mp [ arr [ i ] ] += 1\n        else :\n            mp [ arr [ i ] ] = 1\n    ans = 0\n    for it in mp :\n        count = mp [ it ]\n        ans += ( count * ( count - 1 ) ) // 2\n    return ans\narr = [ 1 , 1 , 2 ]\nn = len ( arr )\nprint ( countPairs ( arr , n ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def countPairs ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for it in mp : NEW_LINE INDENT count = mp [ it ] NEW_LINE ans += ( count * ( count - 1 ) ) // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3517_A", "sol": 0, "python_code": "import math ;\ndef reverseNum ( n ) :\n    rev = 0 ;\n    while ( n ) :\n        rem = n % 10 ;\n        rev = ( rev * 10 ) + rem ;\n        n = int ( n / 10 ) ;\n    return rev ;\ndef isPalindrom ( num ) :\n    return num == reverseNum ( num ) ;\ndef nthPalindrome ( n , k ) :\n    num = math.pow ( 10 , k - 1 ) ;\n    while ( True ) :\n        if ( isPalindrom ( num ) ) :\n            n -= 1 ;\n        if ( not n ) :\n            break ;\n        num += 1 ;\n    return int ( num ) ;\nn = 6 ;\nk = 5 ;\nprint ( n , \"th palindrome of\" , k , \"digit =\" , nthPalindrome ( n , k ) ) ;\nn = 10 ;\nk = 6 ;\nprint ( n , \"th palindrome of\" , k , \"digit =\" , nthPalindrome ( n , k ) ) ;\n", "python_code_tokenized": "import math ; NEW_LINE def reverseNum ( n ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT rem = n % 10 ; NEW_LINE rev = ( rev * 10 ) + rem ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def isPalindrom ( num ) : NEW_LINE INDENT return num == reverseNum ( num ) ; NEW_LINE DEDENT def nthPalindrome ( n , k ) : NEW_LINE INDENT num = math . pow ( 10 , k - 1 ) ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPalindrom ( num ) ) : NEW_LINE INDENT n -= 1 ; NEW_LINE DEDENT if ( not n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT num += 1 ; NEW_LINE DEDENT return int ( num ) ; NEW_LINE DEDENT n = 6 ; NEW_LINE k = 5 ; NEW_LINE print ( n , \" th \u2581 palindrome \u2581 of \" , k , \" digit \u2581 = \" , nthPalindrome ( n , k ) ) ; NEW_LINE n = 10 ; NEW_LINE k = 6 ; NEW_LINE print ( n , \" th \u2581 palindrome \u2581 of \" , k , \" digit \u2581 = \" , nthPalindrome ( n , k ) ) ; NEW_LINE"}
{"id": "codeforces_867_A", "sol": 0, "python_code": "length , tour = input ( ) , input ( )\nprint ( 'YES' if tour.count ( 'SF' ) > tour.count ( 'FS' ) else 'NO' )\n", "python_code_tokenized": "length , tour = input ( ) , input ( ) NEW_LINE print ( ' YES ' if tour . count ( ' SF ' ) > tour . count ( ' FS ' ) else ' NO ' ) NEW_LINE"}
{"id": "geeksforgeeks_5000_A", "sol": 0, "python_code": "MAX = 100002 ;\ndef printUniqueElementsInSuffix ( arr , n , q , m ) :\n    aux = [ 0 ] * MAX ;\n    mark = [ 0 ] * MAX ;\n    aux [ n - 1 ] = 1 ;\n    mark [ arr [ n - 1 ] ] = 1 ;\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if ( mark [ arr [ i ] ] == 0 ) :\n            aux [ i ] = aux [ i + 1 ] + 1 ;\n            mark [ arr [ i ] ] = 1 ;\n        else :\n            aux [ i ] = aux [ i + 1 ] ;\n    for i in range ( m ) :\n        print ( aux [ q [ i ] - 1 ] ) ;\nif __name__ == '__main__' :\n    arr = [ 1 , 2 , 3 , 4 , 1 , 2 , 3 , 4 , 10000 , 999 ] ;\n    n = len ( arr ) ;\n    q = [ 1 , 3 , 6 ] ;\n    m = len ( q ) ;\n    printUniqueElementsInSuffix ( arr , n , q , m ) ;\n", "python_code_tokenized": "MAX = 100002 ; NEW_LINE def printUniqueElementsInSuffix ( arr , n , q , m ) : NEW_LINE INDENT aux = [ 0 ] * MAX ; NEW_LINE mark = [ 0 ] * MAX ; NEW_LINE aux [ n - 1 ] = 1 ; NEW_LINE mark [ arr [ n - 1 ] ] = 1 ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( mark [ arr [ i ] ] == 0 ) : NEW_LINE INDENT aux [ i ] = aux [ i + 1 ] + 1 ; NEW_LINE mark [ arr [ i ] ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT aux [ i ] = aux [ i + 1 ] ; NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT print ( aux [ q [ i ] - 1 ] ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 1 , 2 , 3 , 4 , 10000 , 999 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE q = [ 1 , 3 , 6 ] ; NEW_LINE m = len ( q ) ; NEW_LINE printUniqueElementsInSuffix ( arr , n , q , m ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3908_A", "sol": 0, "python_code": "def findLength ( str ) :\n    n = len ( str )\n    maxlen = 0\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n , 2 ) :\n            length = j - i + 1\n            leftsum = 0\n            rightsum = 0\n            for k in range ( 0 , int ( length / 2 ) ) :\n                leftsum += ( int ( str [ i + k ] ) - int ( '0' ) )\n                rightsum += ( int ( str [ i + k + int ( length / 2 ) ] ) - int ( '0' ) )\n            if ( leftsum == rightsum and maxlen < length ) :\n                maxlen = length\n    return maxlen\nstr = \"1538023\"\nprint ( \"Length of the substring is\" , findLength ( str ) )\n", "python_code_tokenized": "def findLength ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 2 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for k in range ( 0 , int ( length / 2 ) ) : NEW_LINE INDENT leftsum += ( int ( str [ i + k ] ) - int ( '0' ) ) NEW_LINE rightsum += ( int ( str [ i + k + int ( length / 2 ) ] ) - int ( '0' ) ) NEW_LINE DEDENT if ( leftsum == rightsum and maxlen < length ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT str = \"1538023\" NEW_LINE print ( \" Length \u2581 of \u2581 the \u2581 substring \u2581 is \" , findLength ( str ) ) NEW_LINE"}
{"id": "geeksforgeeks_1062_A", "sol": 0, "python_code": "def calculate ( a ) :\n    a.sort ( )\n    count = 1\n    answer = 0\n    for i in range ( 1 , len ( a ) ) :\n        if a [ i ] == a [ i - 1 ] :\n            count += 1\n        else :\n            answer = answer + count * ( count - 1 ) // 2\n            count = 1\n    answer = answer + count * ( count - 1 ) // 2\n    return answer\nif __name__ == '__main__' :\n    a = [ 1 , 2 , 1 , 2 , 4 ]\n    print ( calculate ( a ) )\n", "python_code_tokenized": "def calculate ( a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE count = 1 NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE count = 1 NEW_LINE DEDENT DEDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 2 , 1 , 2 , 4 ] NEW_LINE print ( calculate ( a ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1222_A", "sol": 0, "python_code": "def surfaceArea ( a , b , h ) :\n    return 5 * a * b + 5 * b * h\ndef volume ( b , h ) :\n    return ( 5 * b * h ) / 2\nif __name__ == '__main__' :\n    a = 5\n    b = 3\n    h = 7\n    print ( \"surface area =\" , surfaceArea ( a , b , h ) , \",\" , \"volume =\" , volume ( b , h ) )\n", "python_code_tokenized": "def surfaceArea ( a , b , h ) : NEW_LINE INDENT return 5 * a * b + 5 * b * h NEW_LINE DEDENT def volume ( b , h ) : NEW_LINE INDENT return ( 5 * b * h ) / 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE b = 3 NEW_LINE h = 7 NEW_LINE print ( \" surface \u2581 area \u2581 = \" , surfaceArea ( a , b , h ) , \" , \" , \" volume \u2581 = \" , volume ( b , h ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2330_A", "sol": 0, "python_code": "import math\ndef calculateSum ( n ) :\n    a = int ( n )\n    return ( 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) )\nif __name__ == '__main__' :\n    n = 1.4142\n    print ( math.ceil ( calculateSum ( n ) ) )\n", "python_code_tokenized": "import math NEW_LINE def calculateSum ( n ) : NEW_LINE INDENT a = int ( n ) NEW_LINE return ( 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1.4142 NEW_LINE print ( math . ceil ( calculateSum ( n ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1836_A", "sol": 0, "python_code": "def sameSetBits ( arr , n ) :\n    v = [ ]\n    for i in range ( 0 , n , 1 ) :\n        v.append ( bin ( arr [ i ] ).count ( '1' ) )\n    current_count = 1\n    max_count = 1\n    for i in range ( 1 , len ( v ) - 1 , 1 ) :\n        if ( v [ i + 1 ] == v [ i ] ) :\n            current_count += 1\n        else :\n            current_count = 1\n        max_count = max ( max_count , current_count )\n    return max_count\nif __name__ == '__main__' :\n    arr = [ 9 , 75 , 14 , 7 , 13 , 11 ]\n    n = len ( arr )\n    print ( sameSetBits ( arr , n ) )\n", "python_code_tokenized": "def sameSetBits ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT v . append ( bin ( arr [ i ] ) . count ( '1' ) ) NEW_LINE DEDENT current_count = 1 NEW_LINE max_count = 1 NEW_LINE for i in range ( 1 , len ( v ) - 1 , 1 ) : NEW_LINE INDENT if ( v [ i + 1 ] == v [ i ] ) : NEW_LINE INDENT current_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT current_count = 1 NEW_LINE DEDENT max_count = max ( max_count , current_count ) NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 75 , 14 , 7 , 13 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sameSetBits ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_232_A", "sol": 0, "python_code": "MAX = 1000\nf = [ 0 ] * MAX\ndef fib ( n ) :\n    if ( n == 0 ) :\n        return 0\n    if ( n == 1 or n == 2 ) :\n        f [ n ] = 1\n        return ( f [ n ] )\n    if ( f [ n ] ) :\n        return f [ n ]\n    if ( n & 1 ) :\n        k = ( n + 1 ) // 2\n    else :\n        k = n // 2\n    if ( ( n & 1 ) ) :\n        f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) )\n    else :\n        f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k )\n    return f [ n ]\nn = 9\nprint ( fib ( n ) )\n", "python_code_tokenized": "MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return ( f [ n ] ) NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT k = ( n + 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT k = n // 2 NEW_LINE DEDENT if ( ( n & 1 ) ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT n = 9 NEW_LINE print ( fib ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2848_A", "sol": 0, "python_code": "def find ( dividend , divisor , start , end ) :\n    if ( start > end ) :\n        return ( 0 , dividend ) ;\n    mid = start + ( end - start ) // 2 ;\n    n = dividend - divisor * mid ;\n    if ( n > divisor ) :\n        start = mid + 1 ;\n    elif ( n < 0 ) :\n        end = mid - 1 ;\n    else :\n        if ( n == divisor ) :\n            mid += 1 ;\n            n = 0 ;\n        return ( mid , n ) ;\n    return find ( dividend , divisor , start , end ) ;\ndef divide ( dividend , divisor ) :\n    return find ( dividend , divisor , 1 , dividend ) ;\nif __name__ == \"__main__\" :\n    dividend = 10 ; divisor = 3 ;\n    ans = divide ( dividend , divisor ) ;\n    print ( ans [ 0 ] , \", \" , ans [ 1 ] )\n", "python_code_tokenized": "def find ( dividend , divisor , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return ( 0 , dividend ) ; NEW_LINE DEDENT mid = start + ( end - start ) // 2 ; NEW_LINE n = dividend - divisor * mid ; NEW_LINE if ( n > divisor ) : NEW_LINE INDENT start = mid + 1 ; NEW_LINE DEDENT elif ( n < 0 ) : NEW_LINE INDENT end = mid - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( n == divisor ) : NEW_LINE INDENT mid += 1 ; NEW_LINE n = 0 ; NEW_LINE DEDENT return ( mid , n ) ; NEW_LINE DEDENT return find ( dividend , divisor , start , end ) ; NEW_LINE DEDENT def divide ( dividend , divisor ) : NEW_LINE INDENT return find ( dividend , divisor , 1 , dividend ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT dividend = 10 ; divisor = 3 ; NEW_LINE ans = divide ( dividend , divisor ) ; NEW_LINE print ( ans [ 0 ] , \" , \u2581 \" , ans [ 1 ] ) NEW_LINE DEDENT"}
{"id": "codeforces_557_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nb = list ( map ( int , input ( ).split ( ) ) )\nc = list ( map ( int , input ( ).split ( ) ) )\np1 , p2 , p3 = a [ 0 ] , b [ 0 ] , c [ 0 ]\nn -= p1 + p2 + p3\na [ 1 ] = a [ 1 ] - a [ 0 ]\nb [ 1 ] = b [ 1 ] - b [ 0 ]\nc [ 1 ] = c [ 1 ] - c [ 0 ]\nif a [ 1 ] > n :\n    p1 += n\n    n = 0\nelse :\n    p1 += a [ 1 ]\n    n -= a [ 1 ]\nif b [ 1 ] > n :\n    p2 += n\n    n = 0\nelse :\n    p2 += b [ 1 ]\n    n -= b [ 1 ]\nif c [ 1 ] > n :\n    p3 += n\n    n = 0\nelse :\n    p3 += c [ 1 ]\n    n -= c [ 1 ]\nprint ( p1 , p2 , p3 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p1 , p2 , p3 = a [ 0 ] , b [ 0 ] , c [ 0 ] NEW_LINE n -= p1 + p2 + p3 NEW_LINE a [ 1 ] = a [ 1 ] - a [ 0 ] NEW_LINE b [ 1 ] = b [ 1 ] - b [ 0 ] NEW_LINE c [ 1 ] = c [ 1 ] - c [ 0 ] NEW_LINE if a [ 1 ] > n : NEW_LINE INDENT p1 += n NEW_LINE n = 0 NEW_LINE DEDENT else : NEW_LINE INDENT p1 += a [ 1 ] NEW_LINE n -= a [ 1 ] NEW_LINE DEDENT if b [ 1 ] > n : NEW_LINE INDENT p2 += n NEW_LINE n = 0 NEW_LINE DEDENT else : NEW_LINE INDENT p2 += b [ 1 ] NEW_LINE n -= b [ 1 ] NEW_LINE DEDENT if c [ 1 ] > n : NEW_LINE INDENT p3 += n NEW_LINE n = 0 NEW_LINE DEDENT else : NEW_LINE INDENT p3 += c [ 1 ] NEW_LINE n -= c [ 1 ] NEW_LINE DEDENT print ( p1 , p2 , p3 ) NEW_LINE"}
{"id": "codeforces_1525_A", "sol": 0, "python_code": "import math\nfor i in range ( int ( input ( ) ) ) : k = int ( input ( ) ) ; print ( 100 // math.gcd ( 100 , k ) )\n", "python_code_tokenized": "import math NEW_LINE for i in range ( int ( input ( ) ) ) : k = int ( input ( ) ) ; print ( 100 // math . gcd ( 100 , k ) ) NEW_LINE"}
{"id": "codeforces_1038_B", "sol": 0, "python_code": "n = int ( input ( ) )\nif n <= 2 :\n    print ( 'No' )\nelse :\n    print ( 'Yes' )\n    print ( 1 , n )\n    ans = [ ]\n    for i in range ( 1 , n ) :\n        ans.append ( i )\n    print ( n - 1 , ' '.join ( map ( str , ans ) ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE if n <= 2 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE print ( 1 , n ) NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT print ( n - 1 , ' \u2581 ' . join ( map ( str , ans ) ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1550_A", "sol": 0, "python_code": "import math\nt = int ( input ( ) )\nsolutions = [ ]\nfor i in range ( t ) :\n    s = int ( input ( ) )\n    solutions.append ( math.ceil ( s ** ( 1 / 2 ) ) )\nfor x in solutions :\n    print ( x )\n", "python_code_tokenized": "import math NEW_LINE t = int ( input ( ) ) NEW_LINE solutions = [ ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = int ( input ( ) ) NEW_LINE solutions . append ( math . ceil ( s ** ( 1 / 2 ) ) ) NEW_LINE DEDENT for x in solutions : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4264_A", "sol": 0, "python_code": "def isPrime ( n ) :\n    if n <= 1 :\n        return False\n    for i in range ( 2 , n ) :\n        if n % i == 0 :\n            return False\n    return True\ndef findPrime ( n ) :\n    num = n + 1\n    while ( num ) :\n        if isPrime ( num ) :\n            return num\n        num += 1\n    return 0\ndef minNumber ( arr ) :\n    s = 0\n    for i in range ( 0 , len ( arr ) ) :\n        s += arr [ i ]\n    if isPrime ( s ) :\n        return 0\n    num = findPrime ( s )\n    return num - s\narr = [ 2 , 4 , 6 , 8 , 12 ]\nprint ( minNumber ( arr ) )\n", "python_code_tokenized": "def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num ) : NEW_LINE INDENT if isPrime ( num ) : NEW_LINE INDENT return num NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT if isPrime ( s ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( s ) NEW_LINE return num - s NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE print ( minNumber ( arr ) ) NEW_LINE"}
{"id": "aizu_p00060_A", "sol": 0, "python_code": "import sys\nfor s in sys.stdin :\n    A = map ( int , s.split ( ) )\n    x = 20 - A [ 0 ] - A [ 1 ]\n    f = 3\n    for e in A :\n        if x < e : f -= 1\n    print [ \"NO\" , \"YES\" ] [ x - f >= 4 ]\n", "python_code_tokenized": "import sys NEW_LINE for s in sys . stdin : NEW_LINE INDENT A = map ( int , s . split ( ) ) NEW_LINE x = 20 - A [ 0 ] - A [ 1 ] NEW_LINE f = 3 NEW_LINE for e in A : NEW_LINE INDENT if x < e : f -= 1 NEW_LINE DEDENT print [ \" NO \" , \" YES \" ] [ x - f >= 4 ] NEW_LINE DEDENT"}
{"id": "aizu_p01627_A", "sol": 0, "python_code": "def f ( t , _t ) :\n    h , m = [ int ( _t [ i : i + 2 ] ) - int ( t [ i : i + 2 ] ) for i in [ 0 , 3 ] ]\n    return 60 * h + m\nn , t = map ( int , input ( ).split ( ) )\nprv = input ( ).split ( )\na = [ ]\nfor _ in [ 0 ] * ( n - 1 ) :\n    now = input ( ).split ( )\n    d = f ( prv [ 2 ] , now [ 0 ] )\n    if d >= t :\n        a.append ( now [ 1 ] + ' ' + str ( d ) )\n    prv = now\nprint ( len ( a ) )\nfor x in a : print ( x )\n", "python_code_tokenized": "def f ( t , _t ) : NEW_LINE INDENT h , m = [ int ( _t [ i : i + 2 ] ) - int ( t [ i : i + 2 ] ) for i in [ 0 , 3 ] ] NEW_LINE return 60 * h + m NEW_LINE DEDENT n , t = map ( int , input ( ) . split ( ) ) NEW_LINE prv = input ( ) . split ( ) NEW_LINE a = [ ] NEW_LINE for _ in [ 0 ] * ( n - 1 ) : NEW_LINE INDENT now = input ( ) . split ( ) NEW_LINE d = f ( prv [ 2 ] , now [ 0 ] ) NEW_LINE if d >= t : NEW_LINE INDENT a . append ( now [ 1 ] + ' \u2581 ' + str ( d ) ) NEW_LINE DEDENT prv = now NEW_LINE DEDENT print ( len ( a ) ) NEW_LINE for x in a : print ( x ) NEW_LINE"}
{"id": "geeksforgeeks_117_A", "sol": 0, "python_code": "def rangesum ( n , l , r ) :\n    arr = [ 0 ] * n ;\n    c = 1 ; i = 0 ;\n    while ( c <= n ) :\n        arr [ i ] = c ;\n        i += 1 ;\n        c += 2 ;\n    c = 2 ;\n    while ( c <= n ) :\n        arr [ i ] = c ;\n        i += 1 ;\n        c += 2 ;\n    sum = 0 ;\n    for i in range ( l - 1 , r , 1 ) :\n        sum += arr [ i ] ;\n    return sum ;\nif __name__ == '__main__' :\n    n = 12 ;\n    l , r = 1 , 11 ;\n    print ( rangesum ( n , l , r ) ) ;\n", "python_code_tokenized": "def rangesum ( n , l , r ) : NEW_LINE INDENT arr = [ 0 ] * n ; NEW_LINE c = 1 ; i = 0 ; NEW_LINE while ( c <= n ) : NEW_LINE INDENT arr [ i ] = c ; NEW_LINE i += 1 ; NEW_LINE c += 2 ; NEW_LINE DEDENT c = 2 ; NEW_LINE while ( c <= n ) : NEW_LINE INDENT arr [ i ] = c ; NEW_LINE i += 1 ; NEW_LINE c += 2 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for i in range ( l - 1 , r , 1 ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 ; NEW_LINE l , r = 1 , 11 ; NEW_LINE print ( rangesum ( n , l , r ) ) ; NEW_LINE DEDENT"}
{"id": "atcoder_ABC115_B", "sol": 0, "python_code": "N = int ( input ( ) )\np = [ ]\ntotal = 0\nfor i in range ( N ) :\n    p.append ( int ( input ( ) ) )\np = sorted ( p )\nfor i in range ( N ) :\n    total += p [ i ]\nprint ( int ( total - p [ N - 1 ] / 2 ) )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE p = [ ] NEW_LINE total = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT p . append ( int ( input ( ) ) ) NEW_LINE DEDENT p = sorted ( p ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT total += p [ i ] NEW_LINE DEDENT print ( int ( total - p [ N - 1 ] / 2 ) ) NEW_LINE"}
{"id": "aizu_p01892_A", "sol": 0, "python_code": "INF = 2 ** 63 - 1\ndef solve ( a , b , n ) :\n    x = INF\n    for l in range ( 1 , n + 1 ) :\n        d , m = divmod ( b , l )\n        if not m :\n            for k in range ( 1 , n + 1 ) :\n                x = min ( x , abs ( k * d - a ) )\n    return x\ndef main ( ) :\n    a , b , n = map ( int , input ( ).split ( ) )\n    print ( solve ( a , b , n ) )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "INF = 2 ** 63 - 1 NEW_LINE def solve ( a , b , n ) : NEW_LINE INDENT x = INF NEW_LINE for l in range ( 1 , n + 1 ) : NEW_LINE INDENT d , m = divmod ( b , l ) NEW_LINE if not m : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT x = min ( x , abs ( k * d - a ) ) NEW_LINE DEDENT DEDENT DEDENT return x NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a , b , n = map ( int , input ( ) . split ( ) ) NEW_LINE print ( solve ( a , b , n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_1557_A", "sol": 0, "python_code": "t = int ( input ( ) )\nsolutions = [ ]\nfor i in range ( t ) :\n    n = int ( input ( ) )\n    arr = list ( map ( int , input ( ).split ( ) ) )\n    arr.sort ( )\n    subarr = arr [ : - 1 ]\n    solutions.append ( sum ( subarr ) / len ( subarr ) + arr [ - 1 ] )\nfor x in solutions :\n    print ( x )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE solutions = [ ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE subarr = arr [ : - 1 ] NEW_LINE solutions . append ( sum ( subarr ) / len ( subarr ) + arr [ - 1 ] ) NEW_LINE DEDENT for x in solutions : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC005_B", "sol": 0, "python_code": "N = int ( input ( ) )\nA = list ( map ( int , input ( ).split ( ) ) )\na_to_i = { a : i for i , a in enumerate ( A , start = 1 ) }\nL = [ i - 1 for i in range ( N + 2 ) ]\nR = [ i + 1 for i in range ( N + 2 ) ]\nans = 0\nfor a in range ( N , 0 , - 1 ) :\n    i = a_to_i [ a ]\n    ans += a * ( R [ i ] - i ) * ( i - L [ i ] )\n    L [ R [ i ] ] = L [ i ]\n    R [ L [ i ] ] = R [ i ]\nprint ( ans )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a_to_i = { a : i for i , a in enumerate ( A , start = 1 ) } NEW_LINE L = [ i - 1 for i in range ( N + 2 ) ] NEW_LINE R = [ i + 1 for i in range ( N + 2 ) ] NEW_LINE ans = 0 NEW_LINE for a in range ( N , 0 , - 1 ) : NEW_LINE INDENT i = a_to_i [ a ] NEW_LINE ans += a * ( R [ i ] - i ) * ( i - L [ i ] ) NEW_LINE L [ R [ i ] ] = L [ i ] NEW_LINE R [ L [ i ] ] = R [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_2993_A", "sol": 0, "python_code": "def binomialCoeff ( n , k ) :\n    C = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ]\n    for i in range ( n + 1 ) :\n        for j in range ( min ( i , k ) + 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1 ;\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ;\n    return C [ n ] [ k ] ;\ndef maxcoefficientvalue ( n ) :\n    if ( n % 2 == 0 ) :\n        return binomialCoeff ( n , int ( n / 2 ) ) ;\n    else :\n        return binomialCoeff ( n , int ( ( n + 1 ) / 2 ) ) ;\nif __name__ == '__main__' :\n    n = 4 ;\n    print ( maxcoefficientvalue ( n ) ) ;\n", "python_code_tokenized": "def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] ; NEW_LINE DEDENT def maxcoefficientvalue ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return binomialCoeff ( n , int ( n / 2 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return binomialCoeff ( n , int ( ( n + 1 ) / 2 ) ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 ; NEW_LINE print ( maxcoefficientvalue ( n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3551_A", "sol": 0, "python_code": "INF = 2147483647\nN = 4\ndef minCost ( cost ) :\n    dist = [ 0 for i in range ( N ) ]\n    for i in range ( N ) :\n        dist [ i ] = INF\n    dist [ 0 ] = 0\n    for i in range ( N ) :\n        for j in range ( i + 1 , N ) :\n            if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) :\n                dist [ j ] = dist [ i ] + cost [ i ] [ j ]\n    return dist [ N - 1 ]\ncost = [ [ 0 , 15 , 80 , 90 ] , [ INF , 0 , 40 , 50 ] , [ INF , INF , 0 , 70 ] , [ INF , INF , INF , 0 ] ]\nprint ( \"The Minimum cost to reach station \" , N , \" is \" , minCost ( cost ) )\n", "python_code_tokenized": "INF = 2147483647 NEW_LINE N = 4 NEW_LINE def minCost ( cost ) : NEW_LINE INDENT dist = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE DEDENT dist [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : NEW_LINE INDENT dist [ j ] = dist [ i ] + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dist [ N - 1 ] NEW_LINE DEDENT cost = [ [ 0 , 15 , 80 , 90 ] , [ INF , 0 , 40 , 50 ] , [ INF , INF , 0 , 70 ] , [ INF , INF , INF , 0 ] ] NEW_LINE print ( \" The \u2581 Minimum \u2581 cost \u2581 to \u2581 reach \u2581 station \u2581 \" , N , \" \u2581 is \u2581 \" , minCost ( cost ) ) NEW_LINE"}
{"id": "codeforces_771_B", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nb = [ x != 'YES' for x in input ( ).split ( ) ]\nq = { chr ( ord ( 'A' ) + x ) for x in range ( 26 ) } | { chr ( ord ( 'A' ) + x ) + chr ( ord ( 'a' ) + y ) for x in range ( 26 ) for y in range ( 26 ) }\nls = [ ]\nc = k\nfor x in q :\n    if c :\n        ls.append ( x )\n        c -= 1\n    else :\n        break\nif b [ 0 ] :\n    ls [ - 1 ] = ls [ 0 ]\nfor j in range ( 1 , n - k + 1 ) :\n    if b [ j ] :\n        ls.append ( ls [ j ] )\n    else :\n        v = set ( ls [ j : j + k ] )\n        for x in q :\n            if x not in v :\n                ls.append ( x )\n                break\nprint ( ' '.join ( ls ) )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE b = [ x != ' YES ' for x in input ( ) . split ( ) ] NEW_LINE q = { chr ( ord ( ' A ' ) + x ) for x in range ( 26 ) } | { chr ( ord ( ' A ' ) + x ) + chr ( ord ( ' a ' ) + y ) for x in range ( 26 ) for y in range ( 26 ) } NEW_LINE ls = [ ] NEW_LINE c = k NEW_LINE for x in q : NEW_LINE INDENT if c : NEW_LINE INDENT ls . append ( x ) NEW_LINE c -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if b [ 0 ] : NEW_LINE INDENT ls [ - 1 ] = ls [ 0 ] NEW_LINE DEDENT for j in range ( 1 , n - k + 1 ) : NEW_LINE INDENT if b [ j ] : NEW_LINE INDENT ls . append ( ls [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v = set ( ls [ j : j + k ] ) NEW_LINE for x in q : NEW_LINE INDENT if x not in v : NEW_LINE INDENT ls . append ( x ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' \u2581 ' . join ( ls ) ) NEW_LINE"}
{"id": "geeksforgeeks_4619_A", "sol": 0, "python_code": "def countFibs ( low , high ) :\n    f1 , f2 , f3 = 0 , 1 , 1\n    result = 0\n    while ( f1 <= high ) :\n        if ( f1 >= low ) :\n            result += 1\n        f1 = f2\n        f2 = f3\n        f3 = f1 + f2\n    return result\nlow , high = 10 , 100\nprint ( \"Count of Fibonacci Numbers is\" , countFibs ( low , high ) )\n", "python_code_tokenized": "def countFibs ( low , high ) : NEW_LINE INDENT f1 , f2 , f3 = 0 , 1 , 1 NEW_LINE result = 0 NEW_LINE while ( f1 <= high ) : NEW_LINE INDENT if ( f1 >= low ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE f3 = f1 + f2 NEW_LINE DEDENT return result NEW_LINE DEDENT low , high = 10 , 100 NEW_LINE print ( \" Count \u2581 of \u2581 Fibonacci \u2581 Numbers \u2581 is \" , countFibs ( low , high ) ) NEW_LINE"}
{"id": "codeforces_430_B", "sol": 0, "python_code": "n , k , x = map ( int , input ( ).split ( ) )\nA = [ int ( x ) for x in input ( ).split ( ) ]\nms = [ ]\nfor i in range ( n ) :\n    if A [ i ] == x :\n        l = i\n        j = i\n        while j < n and A [ j ] == x :\n            j += 1\n        if j - l >= 2 :\n            ms.append ( ( l , j - 1 ) )\nans = 0\nfor l , r in ms :\n    tt = r - l + 1\n    l -= 1\n    r += 1\n    while l >= 0 or r < n :\n        if l >= 0 :\n            x = A [ l ]\n        if r < n :\n            x = A [ r ]\n        c = 0\n        while l >= 0 and A [ l ] == x :\n            c += 1\n            l -= 1\n        while r < n and A [ r ] == x :\n            c += 1\n            r += 1\n        if c >= 3 :\n            tt += c\n        else :\n            break\n    ans = max ( ans , tt )\nprint ( ans )\n", "python_code_tokenized": "n , k , x = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ms = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if A [ i ] == x : NEW_LINE INDENT l = i NEW_LINE j = i NEW_LINE while j < n and A [ j ] == x : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if j - l >= 2 : NEW_LINE INDENT ms . append ( ( l , j - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for l , r in ms : NEW_LINE INDENT tt = r - l + 1 NEW_LINE l -= 1 NEW_LINE r += 1 NEW_LINE while l >= 0 or r < n : NEW_LINE INDENT if l >= 0 : NEW_LINE INDENT x = A [ l ] NEW_LINE DEDENT if r < n : NEW_LINE INDENT x = A [ r ] NEW_LINE DEDENT c = 0 NEW_LINE while l >= 0 and A [ l ] == x : NEW_LINE INDENT c += 1 NEW_LINE l -= 1 NEW_LINE DEDENT while r < n and A [ r ] == x : NEW_LINE INDENT c += 1 NEW_LINE r += 1 NEW_LINE DEDENT if c >= 3 : NEW_LINE INDENT tt += c NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT ans = max ( ans , tt ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_437_B", "sol": 0, "python_code": "s , li = map ( int , input ( ).split ( ) )\nl = [ ]\nfor i in range ( li , 0 , - 1 ) :\n    if s == 0 : break\n    x = i & ( - i )\n    if x <= s : l.append ( i ) ; s -= x\nif s == 0 : print ( len ( l ) ) ; print ( * l )\nelse : print ( - 1 )\n", "python_code_tokenized": "s , li = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( li , 0 , - 1 ) : NEW_LINE INDENT if s == 0 : break NEW_LINE x = i & ( - i ) NEW_LINE if x <= s : l . append ( i ) ; s -= x NEW_LINE DEDENT if s == 0 : print ( len ( l ) ) ; print ( * l ) NEW_LINE else : print ( - 1 ) NEW_LINE"}
{"id": "geeksforgeeks_1123_A", "sol": 0, "python_code": "def getMaxMedian ( arr , n , k ) :\n    size = n + k\n    arr.sort ( reverse = False )\n    if ( size % 2 == 0 ) :\n        median = ( arr [ int ( size / 2 ) - 1 ] + arr [ int ( size / 2 ) ] ) / 2\n        return median\n    median = arr [ int ( size / 2 ) ]\n    return median\nif __name__ == '__main__' :\n    arr = [ 3 , 2 , 3 , 4 , 2 ]\n    n = len ( arr )\n    k = 2\n    print ( getMaxMedian ( arr , n , k ) )\n", "python_code_tokenized": "def getMaxMedian ( arr , n , k ) : NEW_LINE INDENT size = n + k NEW_LINE arr . sort ( reverse = False ) NEW_LINE if ( size % 2 == 0 ) : NEW_LINE INDENT median = ( arr [ int ( size / 2 ) - 1 ] + arr [ int ( size / 2 ) ] ) / 2 NEW_LINE return median NEW_LINE DEDENT median = arr [ int ( size / 2 ) ] NEW_LINE return median NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( getMaxMedian ( arr , n , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_892_A", "sol": 0, "python_code": "def isPowerOfK ( n , k ) :\n    oneSeen = False\n    while ( n > 0 ) :\n        digit = n % k\n        if ( digit > 1 ) :\n            return False\n        if ( digit == 1 ) :\n            if ( oneSeen ) :\n                return False\n            oneSeen = True\n        n //= k\n    return True\nn = 64\nk = 4\nif ( isPowerOfK ( n , k ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def isPowerOfK ( n , k ) : NEW_LINE INDENT oneSeen = False NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % k NEW_LINE if ( digit > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( digit == 1 ) : NEW_LINE INDENT if ( oneSeen ) : NEW_LINE INDENT return False NEW_LINE DEDENT oneSeen = True NEW_LINE DEDENT n //= k NEW_LINE DEDENT return True NEW_LINE DEDENT n = 64 NEW_LINE k = 4 NEW_LINE if ( isPowerOfK ( n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "aizu_p02236_A", "sol": 0, "python_code": "import sys\ndef input ( ) :\n    return sys.stdin.readline ( ) [ : - 1 ]\nn = int ( input ( ) )\np = [ None ] + list ( map ( float , input ( ).split ( ) ) )\nq = list ( map ( float , input ( ).split ( ) ) )\nT = [ [ 500 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]\npsum = [ 0 ] * ( n + 1 )\nqsum = [ 0 ] * ( n + 1 )\nqsum [ 0 ] = q [ 0 ]\nfor i in range ( 1 , n + 1 ) :\n    psum [ i ] = psum [ i - 1 ] + p [ i ]\n    qsum [ i ] = qsum [ i - 1 ] + q [ i ]\nfor i in range ( 1 , n + 1 ) :\n    T [ i ] [ i ] = p [ i ] + ( q [ i - 1 ] + q [ i ] ) * 2\nfor l in range ( 2 , n + 1 ) :\n    for i in range ( 1 , n - l + 1 + 1 ) :\n        val_list = [ T [ i ] [ j ] + T [ j + 2 ] [ i + l - 1 ] for j in range ( i , i + l - 2 ) ]\n        val_list.append ( T [ i ] [ i + l - 2 ] + q [ i + l - 1 ] )\n        val_list.append ( T [ i + 1 ] [ i + l - 1 ] + q [ i - 1 ] )\n        if i - 2 >= 0 :\n            w = psum [ i + l - 1 ] - psum [ i - 1 ] + qsum [ i + l - 1 ] - qsum [ i - 2 ]\n        else :\n            w = psum [ i + l - 1 ] - psum [ i - 1 ] + qsum [ i + l - 1 ]\n        T [ i ] [ i + l - 1 ] = min ( val_list ) + w\nprint ( T [ 1 ] [ n ] )\n", "python_code_tokenized": "import sys NEW_LINE def input ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) [ : - 1 ] NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE p = [ None ] + list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE q = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE T = [ [ 500 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE psum = [ 0 ] * ( n + 1 ) NEW_LINE qsum = [ 0 ] * ( n + 1 ) NEW_LINE qsum [ 0 ] = q [ 0 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT psum [ i ] = psum [ i - 1 ] + p [ i ] NEW_LINE qsum [ i ] = qsum [ i - 1 ] + q [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT T [ i ] [ i ] = p [ i ] + ( q [ i - 1 ] + q [ i ] ) * 2 NEW_LINE DEDENT for l in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( 1 , n - l + 1 + 1 ) : NEW_LINE INDENT val_list = [ T [ i ] [ j ] + T [ j + 2 ] [ i + l - 1 ] for j in range ( i , i + l - 2 ) ] NEW_LINE val_list . append ( T [ i ] [ i + l - 2 ] + q [ i + l - 1 ] ) NEW_LINE val_list . append ( T [ i + 1 ] [ i + l - 1 ] + q [ i - 1 ] ) NEW_LINE if i - 2 >= 0 : NEW_LINE INDENT w = psum [ i + l - 1 ] - psum [ i - 1 ] + qsum [ i + l - 1 ] - qsum [ i - 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT w = psum [ i + l - 1 ] - psum [ i - 1 ] + qsum [ i + l - 1 ] NEW_LINE DEDENT T [ i ] [ i + l - 1 ] = min ( val_list ) + w NEW_LINE DEDENT DEDENT print ( T [ 1 ] [ n ] ) NEW_LINE"}
{"id": "codeforces_1592_B", "sol": 0, "python_code": "import sys\ndef R ( ) : return map ( int , next ( sys.stdin ).split ( ) )\nt , = R ( )\nwhile t :\n    t -= 1\n    n , x = R ( )\n    * a , = R ( )\n    print ( 'YNEOS' [ a [ - x : x ] != sorted ( a ) [ - x : x ] : : 2 ] )\n", "python_code_tokenized": "import sys NEW_LINE def R ( ) : return map ( int , next ( sys . stdin ) . split ( ) ) NEW_LINE t , = R ( ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE n , x = R ( ) NEW_LINE * a , = R ( ) NEW_LINE print ( ' YNEOS ' [ a [ - x : x ] != sorted ( a ) [ - x : x ] : : 2 ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3695_A", "sol": 0, "python_code": "def distancesum ( arr , n ) :\n    arr.sort ( )\n    res = 0\n    sum = 0\n    for i in range ( n ) :\n        res += ( arr [ i ] * i - sum )\n        sum += arr [ i ]\n    return res\ndef totaldistancesum ( x , y , n ) :\n    return distancesum ( x , n ) + distancesum ( y , n )\nx = [ - 1 , 1 , 3 , 2 ]\ny = [ 5 , 6 , 5 , 3 ]\nn = len ( x )\nprint ( totaldistancesum ( x , y , n ) )\n", "python_code_tokenized": "def distancesum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( arr [ i ] * i - sum ) NEW_LINE sum += arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT def totaldistancesum ( x , y , n ) : NEW_LINE INDENT return distancesum ( x , n ) + distancesum ( y , n ) NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( totaldistancesum ( x , y , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2206_A", "sol": 0, "python_code": "def countSubSeq ( strr , lenn ) :\n    ans = 0\n    mul = 1\n    for i in range ( lenn ) :\n        if ( strr [ i ] == '0' ) :\n            ans += mul\n        mul *= 2\n    return ans\nstrr = \"10010\"\nlenn = len ( strr )\nprint ( countSubSeq ( strr , lenn ) )\n", "python_code_tokenized": "def countSubSeq ( strr , lenn ) : NEW_LINE INDENT ans = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( strr [ i ] == '0' ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT strr = \"10010\" NEW_LINE lenn = len ( strr ) NEW_LINE print ( countSubSeq ( strr , lenn ) ) NEW_LINE"}
{"id": "codeforces_313_A", "sol": 0, "python_code": "a = int ( input ( ) )\nif a > 0 :\n    print ( a )\nelse :\n    x = abs ( a )\n    if x == 10 :\n        print ( 0 )\n    else :\n        y = x // 10\n        z = ( x // 100 ) * 10 + x % 10\n        print ( min ( y , z ) * ( - 1 ) )\n", "python_code_tokenized": "a = int ( input ( ) ) NEW_LINE if a > 0 : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT x = abs ( a ) NEW_LINE if x == 10 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT y = x // 10 NEW_LINE z = ( x // 100 ) * 10 + x % 10 NEW_LINE print ( min ( y , z ) * ( - 1 ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_549_A", "sol": 0, "python_code": "def sieveOfEratosthenes ( N , s ) :\n    prime = [ False ] * ( N + 1 )\n    for i in range ( 2 , N + 1 , 2 ) :\n        s [ i ] = 2\n    for i in range ( 3 , N + 1 , 2 ) :\n        if ( prime [ i ] == False ) :\n            s [ i ] = i\n            for j in range ( i , int ( N / i ) + 1 , 2 ) :\n                if ( prime [ i * j ] == False ) :\n                    prime [ i * j ] = True\n                    s [ i * j ] = i\ndef generatePrimeFactors ( N ) :\n    s = [ 0 ] * ( N + 1 )\n    sieveOfEratosthenes ( N , s )\n    print ( \"Factor Power\" )\n    curr = s [ N ]\n    cnt = 1\n    while ( N > 1 ) :\n        N //= s [ N ]\n        if ( curr == s [ N ] ) :\n            cnt += 1\n            continue\n        print ( str ( curr ) + \"\\t\" + str ( cnt ) )\n        curr = s [ N ]\n        cnt = 1\nN = 360\ngeneratePrimeFactors ( N )\n", "python_code_tokenized": "def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , int ( N / i ) + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def generatePrimeFactors ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE print ( \" Factor \u2581 Power \" ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE while ( N > 1 ) : NEW_LINE INDENT N //= s [ N ] NEW_LINE if ( curr == s [ N ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT print ( str ( curr ) + \" \\ t \" + str ( cnt ) ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT N = 360 NEW_LINE generatePrimeFactors ( N ) NEW_LINE"}
{"id": "geeksforgeeks_4853_A", "sol": 0, "python_code": "def vietaFormula ( roots , n ) :\n    coeff = [ 0 ] * ( n + 1 )\n    coeff [ n ] = 1\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( n - i - 1 , n ) :\n            coeff [ j ] += ( ( - 1 ) * roots [ i - 1 ] * coeff [ j + 1 ] )\n    coeff = coeff [ : : - 1 ]\n    print ( \"Polynomial Coefficients : \" , end = \"\" )\n    for i in coeff :\n        print ( i , end = \" \" )\n    print ( )\nif __name__ == \"__main__\" :\n    n = 4\n    roots = [ - 1 , 2 , - 3 , 7 ]\n    vietaFormula ( roots , n )\n", "python_code_tokenized": "def vietaFormula ( roots , n ) : NEW_LINE INDENT coeff = [ 0 ] * ( n + 1 ) NEW_LINE coeff [ n ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( n - i - 1 , n ) : NEW_LINE INDENT coeff [ j ] += ( ( - 1 ) * roots [ i - 1 ] * coeff [ j + 1 ] ) NEW_LINE DEDENT DEDENT coeff = coeff [ : : - 1 ] NEW_LINE print ( \" Polynomial \u2581 Coefficients \u2581 : \u2581 \" , end = \" \" ) NEW_LINE for i in coeff : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE roots = [ - 1 , 2 , - 3 , 7 ] NEW_LINE vietaFormula ( roots , n ) NEW_LINE DEDENT"}
{"id": "codeforces_194_A", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nprint ( max ( 0 , 3 * n - k ) )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( 0 , 3 * n - k ) ) NEW_LINE"}
{"id": "atcoder_AGC034_B", "sol": 0, "python_code": "S = str ( input ( ) )\nS = S.replace ( \"BC\" , \"D\" )\nA_count = 0\nans = 0\nfor i in range ( len ( S ) ) :\n    if S [ i ] == 'A' :\n        A_count += 1\n    elif S [ i ] == 'D' :\n        ans += A_count\n    else :\n        A_count = 0\nprint ( ans )\n", "python_code_tokenized": "S = str ( input ( ) ) NEW_LINE S = S . replace ( \" BC \" , \" D \" ) NEW_LINE A_count = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if S [ i ] == ' A ' : NEW_LINE INDENT A_count += 1 NEW_LINE DEDENT elif S [ i ] == ' D ' : NEW_LINE INDENT ans += A_count NEW_LINE DEDENT else : NEW_LINE INDENT A_count = 0 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_5237_A", "sol": 0, "python_code": "from math import sqrt , pow\ndef rhombusAreaPeri ( d1 , d2 ) :\n    area = ( d1 * d2 ) / 2\n    perimeter = 2 * sqrt ( pow ( d1 , 2 ) + pow ( d2 , 2 ) )\n    print ( \"The area of rhombus with diagonals\" , d1 , \"and\" , d2 , \"is\" , area , \".\" )\n    print ( \"The perimeter of rhombus with diagonals\" , d1 , \"and\" , d2 , \"is\" , perimeter , \".\" )\nif __name__ == '__main__' :\n    d1 = 2\n    d2 = 4\n    rhombusAreaPeri ( d1 , d2 )\n", "python_code_tokenized": "from math import sqrt , pow NEW_LINE def rhombusAreaPeri ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 NEW_LINE perimeter = 2 * sqrt ( pow ( d1 , 2 ) + pow ( d2 , 2 ) ) NEW_LINE print ( \" The \u2581 area \u2581 of \u2581 rhombus \u2581 with \u2581 diagonals \" , d1 , \" and \" , d2 , \" is \" , area , \" . \" ) NEW_LINE print ( \" The \u2581 perimeter \u2581 of \u2581 rhombus \u2581 with \u2581 diagonals \" , d1 , \" and \" , d2 , \" is \" , perimeter , \" . \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT d1 = 2 NEW_LINE d2 = 4 NEW_LINE rhombusAreaPeri ( d1 , d2 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1523_A", "sol": 0, "python_code": "def minSwaps ( arr , n ) :\n    noOfOnes = 0\n    for i in range ( n ) :\n        if ( arr [ i ] == 1 ) :\n            noOfOnes = noOfOnes + 1\n    x = noOfOnes\n    maxOnes = - 2147483648\n    preCompute = { }\n    if ( arr [ 0 ] == 1 ) :\n        preCompute [ 0 ] = 1\n    for i in range ( 1 , n ) :\n        if ( arr [ i ] == 1 ) :\n            preCompute [ i ] = preCompute [ i - 1 ] + 1\n        else :\n            preCompute [ i ] = preCompute [ i - 1 ]\n    for i in range ( x - 1 , n ) :\n        if ( i == ( x - 1 ) ) :\n            noOfOnes = preCompute [ i ]\n        else :\n            noOfOnes = preCompute [ i ] - preCompute [ i - x ]\n        if ( maxOnes < noOfOnes ) :\n            maxOnes = noOfOnes\n    noOfZeroes = x - maxOnes\n    return noOfZeroes\na = [ 1 , 0 , 1 , 0 , 1 ]\nn = len ( a )\nprint ( minSwaps ( a , n ) )\n", "python_code_tokenized": "def minSwaps ( arr , n ) : NEW_LINE INDENT noOfOnes = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT noOfOnes = noOfOnes + 1 NEW_LINE DEDENT DEDENT x = noOfOnes NEW_LINE maxOnes = - 2147483648 NEW_LINE preCompute = { } NEW_LINE if ( arr [ 0 ] == 1 ) : NEW_LINE INDENT preCompute [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT preCompute [ i ] = preCompute [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT preCompute [ i ] = preCompute [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( x - 1 , n ) : NEW_LINE INDENT if ( i == ( x - 1 ) ) : NEW_LINE INDENT noOfOnes = preCompute [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT noOfOnes = preCompute [ i ] - preCompute [ i - x ] NEW_LINE DEDENT if ( maxOnes < noOfOnes ) : NEW_LINE INDENT maxOnes = noOfOnes NEW_LINE DEDENT DEDENT noOfZeroes = x - maxOnes NEW_LINE return noOfZeroes NEW_LINE DEDENT a = [ 1 , 0 , 1 , 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( minSwaps ( a , n ) ) NEW_LINE"}
{"id": "aizu_p02443_A", "sol": 0, "python_code": "if __name__ == '__main__' :\n    n = int ( input ( ) )\n    A = input ( ).split ( )\n    n2 = int ( input ( ) )\n    for i in range ( n2 ) :\n        a , b = map ( int , input ( ).split ( ) )\n        B = list ( reversed ( A [ a : b ] ) )\n        A = A [ 0 : a ] + B + A [ b : n ]\n    print ( * A )\n", "python_code_tokenized": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE A = input ( ) . split ( ) NEW_LINE n2 = int ( input ( ) ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE B = list ( reversed ( A [ a : b ] ) ) NEW_LINE A = A [ 0 : a ] + B + A [ b : n ] NEW_LINE DEDENT print ( * A ) NEW_LINE DEDENT"}
{"id": "aizu_p02445_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nq = int ( input ( ) )\nfor i in range ( q ) :\n    b , e , t = map ( int , input ( ).split ( ) )\n    s = t + e - b\n    if t > b :\n        a = a [ : b ] + a [ t : s ] + a [ e : t ] + a [ b : e ] + a [ s : ]\n    else :\n        a = a [ : t ] + a [ b : e ] + a [ s : b ] + a [ t : s ] + a [ e : ]\nprint ( * a )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT b , e , t = map ( int , input ( ) . split ( ) ) NEW_LINE s = t + e - b NEW_LINE if t > b : NEW_LINE INDENT a = a [ : b ] + a [ t : s ] + a [ e : t ] + a [ b : e ] + a [ s : ] NEW_LINE DEDENT else : NEW_LINE INDENT a = a [ : t ] + a [ b : e ] + a [ s : b ] + a [ t : s ] + a [ e : ] NEW_LINE DEDENT DEDENT print ( * a ) NEW_LINE"}
{"id": "geeksforgeeks_254_A", "sol": 0, "python_code": "def checkPrime ( number ) :\n    num = int ( number )\n    for i in range ( 2 , int ( num ** 0.5 ) ) :\n        if ( ( num % i ) == 0 ) :\n            return False\n    return True\ndef splitIntoPrimes ( number ) :\n    if ( number == '' ) :\n        return 0\n    if ( len ( number ) <= 6 and checkPrime ( number ) ) :\n        return 1\n    else :\n        numLen = len ( number )\n        ans = 1000000\n        for i in range ( 1 , ( min ( 6 , numLen ) + 1 ) ) :\n            if ( checkPrime ( number [ : i ] ) ) :\n                val = splitIntoPrimes ( number [ i : ] )\n                if ( val != - 1 ) :\n                    ans = min ( ans , 1 + val )\n        if ( ans == 1000000 ) :\n            return - 1\n        return ans\nprint ( splitIntoPrimes ( \"13499315\" ) )\nprint ( splitIntoPrimes ( \"43\" ) )\n", "python_code_tokenized": "def checkPrime ( number ) : NEW_LINE INDENT num = int ( number ) NEW_LINE for i in range ( 2 , int ( num ** 0.5 ) ) : NEW_LINE INDENT if ( ( num % i ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def splitIntoPrimes ( number ) : NEW_LINE INDENT if ( number == ' ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( number ) <= 6 and checkPrime ( number ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT numLen = len ( number ) NEW_LINE ans = 1000000 NEW_LINE for i in range ( 1 , ( min ( 6 , numLen ) + 1 ) ) : NEW_LINE INDENT if ( checkPrime ( number [ : i ] ) ) : NEW_LINE INDENT val = splitIntoPrimes ( number [ i : ] ) NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT ans = min ( ans , 1 + val ) NEW_LINE DEDENT DEDENT DEDENT if ( ans == 1000000 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT print ( splitIntoPrimes ( \"13499315\" ) ) NEW_LINE print ( splitIntoPrimes ( \"43\" ) ) NEW_LINE"}
{"id": "geeksforgeeks_1656_A", "sol": 0, "python_code": "import sys\ndef solve ( arr , n , k ) :\n    minx = sys.maxsize ;\n    for i in range ( n ) :\n        minx = min ( minx , arr [ i ] ) ;\n    decrements = 0 ;\n    for i in range ( n ) :\n        if ( ( arr [ i ] - minx ) % k != 0 ) :\n            return - 1 ;\n        else :\n            decrements += ( ( arr [ i ] - minx ) // k ) ;\n    return decrements ;\nif __name__ == \"__main__\" :\n    n = 3 ;\n    k = 3 ;\n    arr = [ 12 , 9 , 15 ] ;\n    print ( solve ( arr , n , k ) ) ;\n", "python_code_tokenized": "import sys NEW_LINE def solve ( arr , n , k ) : NEW_LINE INDENT minx = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT minx = min ( minx , arr [ i ] ) ; NEW_LINE DEDENT decrements = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] - minx ) % k != 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT decrements += ( ( arr [ i ] - minx ) // k ) ; NEW_LINE DEDENT DEDENT return decrements ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE k = 3 ; NEW_LINE arr = [ 12 , 9 , 15 ] ; NEW_LINE print ( solve ( arr , n , k ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4653_A", "sol": 0, "python_code": "def findNextWord ( s , m ) :\n    m += 97\n    n = len ( s )\n    i = len ( s ) - 1\n    s [ i ] = chr ( ord ( s [ i ] ) + 1 )\n    while i >= 0 and i <= n - 1 :\n        if ord ( s [ i ] ) >= m :\n            s [ i ] = 'a'\n            i -= 1\n            s [ i ] = chr ( ord ( s [ i ] ) + 1 )\n        elif s [ i ] == s [ i - 1 ] or s [ i ] == s [ i - 2 ] :\n            s [ i ] = chr ( ord ( s [ i ] ) + 1 )\n        else :\n            i += 1\n    if i <= - 1 :\n        print ( \"-1\" )\n    else :\n        print ( ''.join ( s ) )\nif __name__ == \"__main__\" :\n    string = \"abcd\"\n    k = 4\n    findNextWord ( list ( string ) , k )\n", "python_code_tokenized": "def findNextWord ( s , m ) : NEW_LINE INDENT m += 97 NEW_LINE n = len ( s ) NEW_LINE i = len ( s ) - 1 NEW_LINE s [ i ] = chr ( ord ( s [ i ] ) + 1 ) NEW_LINE while i >= 0 and i <= n - 1 : NEW_LINE INDENT if ord ( s [ i ] ) >= m : NEW_LINE INDENT s [ i ] = ' a ' NEW_LINE i -= 1 NEW_LINE s [ i ] = chr ( ord ( s [ i ] ) + 1 ) NEW_LINE DEDENT elif s [ i ] == s [ i - 1 ] or s [ i ] == s [ i - 2 ] : NEW_LINE INDENT s [ i ] = chr ( ord ( s [ i ] ) + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if i <= - 1 : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' ' . join ( s ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcd \" NEW_LINE k = 4 NEW_LINE findNextWord ( list ( string ) , k ) NEW_LINE DEDENT"}
{"id": "codeforces_1728_A", "sol": 0, "python_code": "t = int ( input ( ) )\nwhile t :\n    n = int ( input ( ) )\n    k = list ( ( input ( ) ).split ( ) )\n    k = [ int ( i ) for i in k ]\n    print ( k.index ( max ( k ) ) + 1 )\n    t -= 1\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE k = list ( ( input ( ) ) . split ( ) ) NEW_LINE k = [ int ( i ) for i in k ] NEW_LINE print ( k . index ( max ( k ) ) + 1 ) NEW_LINE t -= 1 NEW_LINE DEDENT"}
{"id": "aizu_p00181_A", "sol": 0, "python_code": "import sys\n_allinput = [ ]\nfor inp in sys.stdin :\n    _allinput += inp.strip ( ).split ( \" \" )\ndef _input ( ) :\n    for put in _allinput :\n        yield put\n_obj = _input ( ) ;\ndef __input ( ) :\n    return _obj.__next__ ( )\ndef nextInt ( ) :\n    return int ( __input ( ) )\ndef check ( lst , L ) :\n    tot = 1\n    curSum = 0\n    for i in lst :\n        if curSum + i <= L :\n            curSum += i\n        else :\n            curSum = i\n            tot += 1\n    return tot\ndef solve ( lst , m ) :\n    l = max ( lst )\n    r = 1000000 * m ;\n    while l != r :\n        mid = int ( ( l + r ) / 2 ) ;\n        if check ( lst , mid ) <= m : r = mid\n        else : l = mid + 1\n    return l\ntry :\n    while True :\n        m , n = nextInt ( ) , nextInt ( )\n        if m > 0 or n > 0 :\n            lst = [ nextInt ( ) for i in range ( 0 , n ) ]\n            print ( solve ( lst , m ) )\n        else :\n            break\nexcept :\n", "python_code_tokenized": "import sys NEW_LINE _allinput = [ ] NEW_LINE for inp in sys . stdin : NEW_LINE INDENT _allinput += inp . strip ( ) . split ( \" \u2581 \" ) NEW_LINE DEDENT def _input ( ) : NEW_LINE INDENT for put in _allinput : NEW_LINE INDENT yield put NEW_LINE DEDENT DEDENT _obj = _input ( ) ; NEW_LINE def __input ( ) : NEW_LINE INDENT return _obj . __next__ ( ) NEW_LINE DEDENT def nextInt ( ) : NEW_LINE INDENT return int ( __input ( ) ) NEW_LINE DEDENT def check ( lst , L ) : NEW_LINE INDENT tot = 1 NEW_LINE curSum = 0 NEW_LINE for i in lst : NEW_LINE INDENT if curSum + i <= L : NEW_LINE INDENT curSum += i NEW_LINE DEDENT else : NEW_LINE INDENT curSum = i NEW_LINE tot += 1 NEW_LINE DEDENT DEDENT return tot NEW_LINE DEDENT def solve ( lst , m ) : NEW_LINE INDENT l = max ( lst ) NEW_LINE r = 1000000 * m ; NEW_LINE while l != r : NEW_LINE INDENT mid = int ( ( l + r ) / 2 ) ; NEW_LINE if check ( lst , mid ) <= m : r = mid NEW_LINE else : l = mid + 1 NEW_LINE DEDENT return l NEW_LINE DEDENT try : NEW_LINE INDENT while True : NEW_LINE INDENT m , n = nextInt ( ) , nextInt ( ) NEW_LINE if m > 0 or n > 0 : NEW_LINE INDENT lst = [ nextInt ( ) for i in range ( 0 , n ) ] NEW_LINE print ( solve ( lst , m ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT except : NEW_LINE"}
{"id": "geeksforgeeks_4647_A", "sol": 0, "python_code": "def pattern ( n ) :\n    k = 1\n    for i in range ( 1 , n + 1 ) :\n        p = k\n        for j in range ( 1 , i + 1 ) :\n            print ( p , end = \"\" )\n            p = p - ( n + j - i )\n        print ( \"\" )\n        k = k + 1 + n - i\nn = 5\npattern ( n )\n", "python_code_tokenized": "def pattern ( n ) : NEW_LINE INDENT k = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = k NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( p , end = \" \u2581 \" ) NEW_LINE p = p - ( n + j - i ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE k = k + 1 + n - i NEW_LINE DEDENT DEDENT n = 5 NEW_LINE pattern ( n ) NEW_LINE"}
{"id": "codeforces_977_A", "sol": 0, "python_code": "( num , a ) = map ( int , input ( ).split ( ) )\nfor i in range ( a ) :\n    if num % 10 == 0 :\n        num = int ( num / 10 )\n    else :\n        num = num - 1\nprint ( num )\n", "python_code_tokenized": "( num , a ) = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( a ) : NEW_LINE INDENT if num % 10 == 0 : NEW_LINE INDENT num = int ( num / 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT num = num - 1 NEW_LINE DEDENT DEDENT print ( num ) NEW_LINE"}
{"id": "codeforces_1629_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    l , r , k = map ( int , input ( ).split ( ) )\n    e = ( r + 1 ) // 2 - l // 2\n    if k >= e or l == r != 1 : print ( \"YES\" )\n    else : print ( \"NO\" )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT l , r , k = map ( int , input ( ) . split ( ) ) NEW_LINE e = ( r + 1 ) // 2 - l // 2 NEW_LINE if k >= e or l == r != 1 : print ( \" YES \" ) NEW_LINE else : print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC043_A", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nH , W = map ( int , input ( ).split ( ) )\nS = [ list ( input ( ) ) for i in range ( H ) ]\ndp = [ 0 ] * W\nif S [ 0 ] [ 0 ] == '#' :\n    dp [ 0 ] = 1\nfor j in range ( 1 , W ) :\n    if S [ 0 ] [ j ] != S [ 0 ] [ j - 1 ] and S [ 0 ] [ j - 1 ] == '.' :\n        dp [ j ] = dp [ j - 1 ] + 1\n    else :\n        dp [ j ] = dp [ j - 1 ]\nfor i in range ( 1 , H ) :\n    if S [ i ] [ 0 ] != S [ i - 1 ] [ 0 ] and S [ i - 1 ] [ 0 ] == '.' :\n        dp [ 0 ] = dp [ 0 ] + 1\n    for j in range ( 1 , W ) :\n        hidari = 1 if S [ i ] [ j ] != S [ i ] [ j - 1 ] and S [ i ] [ j - 1 ] == '.' else 0\n        ue = 1 if S [ i ] [ j ] != S [ i - 1 ] [ j ] and S [ i - 1 ] [ j ] == '.' else 0\n        dp [ j ] = min ( dp [ j - 1 ] + hidari , dp [ j ] + ue )\nprint ( dp [ - 1 ] )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE H , W = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ list ( input ( ) ) for i in range ( H ) ] NEW_LINE dp = [ 0 ] * W NEW_LINE if S [ 0 ] [ 0 ] == ' # ' : NEW_LINE INDENT dp [ 0 ] = 1 NEW_LINE DEDENT for j in range ( 1 , W ) : NEW_LINE INDENT if S [ 0 ] [ j ] != S [ 0 ] [ j - 1 ] and S [ 0 ] [ j - 1 ] == ' . ' : NEW_LINE INDENT dp [ j ] = dp [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ j ] = dp [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , H ) : NEW_LINE INDENT if S [ i ] [ 0 ] != S [ i - 1 ] [ 0 ] and S [ i - 1 ] [ 0 ] == ' . ' : NEW_LINE INDENT dp [ 0 ] = dp [ 0 ] + 1 NEW_LINE DEDENT for j in range ( 1 , W ) : NEW_LINE INDENT hidari = 1 if S [ i ] [ j ] != S [ i ] [ j - 1 ] and S [ i ] [ j - 1 ] == ' . ' else 0 NEW_LINE ue = 1 if S [ i ] [ j ] != S [ i - 1 ] [ j ] and S [ i - 1 ] [ j ] == ' . ' else 0 NEW_LINE dp [ j ] = min ( dp [ j - 1 ] + hidari , dp [ j ] + ue ) NEW_LINE DEDENT DEDENT print ( dp [ - 1 ] ) NEW_LINE"}
{"id": "codeforces_1282_A", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nt = int ( input ( ) )\nfor testcases in range ( t ) :\n    a , b , c , r = map ( int , input ( ).split ( ) )\n    MINC = c - r\n    MAXC = c + r\n    if a == b :\n        print ( 0 )\n    elif a < b :\n        if a <= c <= b :\n            print ( max ( 0 , MINC - a ) + max ( 0 , b - MAXC ) )\n        elif c < a :\n            print ( min ( b - a , max ( 0 , b - MAXC ) ) )\n        elif c > b :\n            print ( min ( b - a , max ( 0 , MINC - a ) ) )\n    else :\n        if a >= c >= b :\n            print ( max ( 0 , MINC - b ) + max ( 0 , a - MAXC ) )\n        elif c < b :\n            print ( min ( a - b , max ( 0 , a - MAXC ) ) )\n        elif c > a :\n            print ( min ( a - b , max ( 0 , MINC - b ) ) )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE t = int ( input ( ) ) NEW_LINE for testcases in range ( t ) : NEW_LINE INDENT a , b , c , r = map ( int , input ( ) . split ( ) ) NEW_LINE MINC = c - r NEW_LINE MAXC = c + r NEW_LINE if a == b : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif a < b : NEW_LINE INDENT if a <= c <= b : NEW_LINE INDENT print ( max ( 0 , MINC - a ) + max ( 0 , b - MAXC ) ) NEW_LINE DEDENT elif c < a : NEW_LINE INDENT print ( min ( b - a , max ( 0 , b - MAXC ) ) ) NEW_LINE DEDENT elif c > b : NEW_LINE INDENT print ( min ( b - a , max ( 0 , MINC - a ) ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a >= c >= b : NEW_LINE INDENT print ( max ( 0 , MINC - b ) + max ( 0 , a - MAXC ) ) NEW_LINE DEDENT elif c < b : NEW_LINE INDENT print ( min ( a - b , max ( 0 , a - MAXC ) ) ) NEW_LINE DEDENT elif c > a : NEW_LINE INDENT print ( min ( a - b , max ( 0 , MINC - b ) ) ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_3649_A", "sol": 0, "python_code": "import math\ndef lengthSquare ( X , Y ) :\n    xDiff = X [ 0 ] - Y [ 0 ]\n    yDiff = X [ 1 ] - Y [ 1 ]\n    return xDiff * xDiff + yDiff * yDiff\ndef printAngle ( A , B , C ) :\n    a2 = lengthSquare ( B , C )\n    b2 = lengthSquare ( A , C )\n    c2 = lengthSquare ( A , B )\n    a = math.sqrt ( a2 ) ;\n    b = math.sqrt ( b2 ) ;\n    c = math.sqrt ( c2 ) ;\n    alpha = math.acos ( ( b2 + c2 - a2 ) / ( 2 * b * c ) ) ;\n    betta = math.acos ( ( a2 + c2 - b2 ) / ( 2 * a * c ) ) ;\n    gamma = math.acos ( ( a2 + b2 - c2 ) / ( 2 * a * b ) ) ;\n    alpha = alpha * 180 / math.pi ;\n    betta = betta * 180 / math.pi ;\n    gamma = gamma * 180 / math.pi ;\n    print ( \"alpha : %f\" % ( alpha ) )\n    print ( \"betta : %f\" % ( betta ) )\n    print ( \"gamma : %f\" % ( gamma ) )\nA = ( 0 , 0 )\nB = ( 0 , 1 )\nC = ( 1 , 0 )\nprintAngle ( A , B , C ) ;\n", "python_code_tokenized": "import math NEW_LINE def lengthSquare ( X , Y ) : NEW_LINE INDENT xDiff = X [ 0 ] - Y [ 0 ] NEW_LINE yDiff = X [ 1 ] - Y [ 1 ] NEW_LINE return xDiff * xDiff + yDiff * yDiff NEW_LINE DEDENT def printAngle ( A , B , C ) : NEW_LINE INDENT a2 = lengthSquare ( B , C ) NEW_LINE b2 = lengthSquare ( A , C ) NEW_LINE c2 = lengthSquare ( A , B ) NEW_LINE a = math . sqrt ( a2 ) ; NEW_LINE b = math . sqrt ( b2 ) ; NEW_LINE c = math . sqrt ( c2 ) ; NEW_LINE alpha = math . acos ( ( b2 + c2 - a2 ) / ( 2 * b * c ) ) ; NEW_LINE betta = math . acos ( ( a2 + c2 - b2 ) / ( 2 * a * c ) ) ; NEW_LINE gamma = math . acos ( ( a2 + b2 - c2 ) / ( 2 * a * b ) ) ; NEW_LINE alpha = alpha * 180 / math . pi ; NEW_LINE betta = betta * 180 / math . pi ; NEW_LINE gamma = gamma * 180 / math . pi ; NEW_LINE print ( \" alpha \u2581 : \u2581 % f \" % ( alpha ) ) NEW_LINE print ( \" betta \u2581 : \u2581 % f \" % ( betta ) ) NEW_LINE print ( \" gamma \u2581 : \u2581 % f \" % ( gamma ) ) NEW_LINE DEDENT A = ( 0 , 0 ) NEW_LINE B = ( 0 , 1 ) NEW_LINE C = ( 1 , 0 ) NEW_LINE printAngle ( A , B , C ) ; NEW_LINE"}
{"id": "aizu_p01380_A", "sol": 0, "python_code": "N = int ( input ( ) )\nlis = [ ]\nlis_append = lis.append\nfor i in range ( N ) :\n    a , b = map ( int , input ( ).split ( \" \" ) )\n    lis_append ( ( b , a ) )\nlis.sort ( )\ndp = [ 2 ** 60 ] * ( N + 1 )\ndp [ 0 ] = 0\nfor b , a in lis :\n    tmp = list ( dp )\n    for i in range ( 1 , N + 1 ) :\n        if dp [ i - 1 ] + a <= b :\n            tmp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + a )\n    dp = tmp\nans = 0\nfor i in range ( N + 1 ) :\n    if dp [ i ] < 2 ** 60 :\n        ans = i\nprint ( ans )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE lis = [ ] NEW_LINE lis_append = lis . append NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( \" \u2581 \" ) ) NEW_LINE lis_append ( ( b , a ) ) NEW_LINE DEDENT lis . sort ( ) NEW_LINE dp = [ 2 ** 60 ] * ( N + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for b , a in lis : NEW_LINE INDENT tmp = list ( dp ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if dp [ i - 1 ] + a <= b : NEW_LINE INDENT tmp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + a ) NEW_LINE DEDENT DEDENT dp = tmp NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if dp [ i ] < 2 ** 60 : NEW_LINE INDENT ans = i NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_1462_A", "sol": 0, "python_code": "def solve ( n , b ) :\n    i = 0\n    j = n - 1\n    ans = [ ]\n    while i < j :\n        ans.append ( b [ i ] )\n        ans.append ( b [ j ] )\n        i += 1\n        j -= 1\n    if n % 2 == 1 :\n        ans.append ( b [ i ] )\n    return ans\nt = int ( input ( ) )\nwhile t > 0 :\n    n = int ( input ( ) )\n    b = [ int ( x ) for x in input ( ).split ( ) ]\n    print ( * solve ( n , b ) , sep = ' ' )\n    t -= 1\n", "python_code_tokenized": "def solve ( n , b ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE ans = [ ] NEW_LINE while i < j : NEW_LINE INDENT ans . append ( b [ i ] ) NEW_LINE ans . append ( b [ j ] ) NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT if n % 2 == 1 : NEW_LINE INDENT ans . append ( b [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( * solve ( n , b ) , sep = ' \u2581 ' ) NEW_LINE t -= 1 NEW_LINE DEDENT"}
{"id": "atcoder_ABC091_C", "sol": 0, "python_code": "n = int ( input ( ) )\nr = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( n ) ]\nb = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( n ) ]\nr.sort ( )\nb.sort ( )\ns = [ ]\nk = 0\nans = 0\nfor i in range ( n ) :\n    while True :\n        if k >= n :\n            break\n        if b [ i ] [ 0 ] > r [ k ] [ 0 ] :\n            s.append ( r [ k ] [ 1 ] )\n            k += 1\n        else :\n            s.sort ( )\n            break\n    for j in range ( len ( s ) - 1 , - 1 , - 1 ) :\n        if s [ j ] < b [ i ] [ 1 ] :\n            ans += 1\n            s.remove ( s [ j ] )\n            break\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE r = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE b = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE r . sort ( ) NEW_LINE b . sort ( ) NEW_LINE s = [ ] NEW_LINE k = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while True : NEW_LINE INDENT if k >= n : NEW_LINE INDENT break NEW_LINE DEDENT if b [ i ] [ 0 ] > r [ k ] [ 0 ] : NEW_LINE INDENT s . append ( r [ k ] [ 1 ] ) NEW_LINE k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s . sort ( ) NEW_LINE break NEW_LINE DEDENT DEDENT for j in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ j ] < b [ i ] [ 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE s . remove ( s [ j ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_209_A", "sol": 0, "python_code": "from math import sqrt\ndef findTriplets ( x ) :\n    fact = [ ] ;\n    factors = set ( ) ;\n    for i in range ( 2 , int ( sqrt ( x ) ) ) :\n        if ( x % i == 0 ) :\n            fact.append ( i ) ;\n            if ( x / i != i ) :\n                fact.append ( x // i ) ;\n            factors.add ( i ) ;\n            factors.add ( x // i ) ;\n    found = False ;\n    k = len ( fact ) ;\n    for i in range ( k ) :\n        a = fact [ i ] ;\n        for j in range ( k ) :\n            b = fact [ j ] ;\n            if ( ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) ) :\n                print ( a , b , x // ( a * b ) ) ;\n                found = True ;\n                break ;\n        if ( found ) :\n            break ;\n    if ( not found ) :\n        print ( \"-1\" ) ;\nif __name__ == \"__main__\" :\n    x = 105 ;\n    findTriplets ( x ) ;\n", "python_code_tokenized": "from math import sqrt NEW_LINE def findTriplets ( x ) : NEW_LINE INDENT fact = [ ] ; NEW_LINE factors = set ( ) ; NEW_LINE for i in range ( 2 , int ( sqrt ( x ) ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT fact . append ( i ) ; NEW_LINE if ( x / i != i ) : NEW_LINE INDENT fact . append ( x // i ) ; NEW_LINE DEDENT factors . add ( i ) ; NEW_LINE factors . add ( x // i ) ; NEW_LINE DEDENT DEDENT found = False ; NEW_LINE k = len ( fact ) ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT a = fact [ i ] ; NEW_LINE for j in range ( k ) : NEW_LINE INDENT b = fact [ j ] ; NEW_LINE if ( ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) ) : NEW_LINE INDENT print ( a , b , x // ( a * b ) ) ; NEW_LINE found = True ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( not found ) : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 105 ; NEW_LINE findTriplets ( x ) ; NEW_LINE DEDENT"}
{"id": "atcoder_ABC076_B", "sol": 0, "python_code": "N , K = map ( int , open ( 0 ) ) ; L = 1\nfor i in range ( N ) : L += min ( L , K )\nprint ( L )\n", "python_code_tokenized": "N , K = map ( int , open ( 0 ) ) ; L = 1 NEW_LINE for i in range ( N ) : L += min ( L , K ) NEW_LINE print ( L ) NEW_LINE"}
{"id": "geeksforgeeks_11_A", "sol": 0, "python_code": "def sumOfDivisblePowers ( L , R , P ) :\n    res = 0\n    for i in range ( L , R + 1 ) :\n        x = i\n        while ( x % P == 0 ) :\n            res += 1\n            x /= P\n    return res\nL = 1\nR = 10\nP = 2\nprint ( sumOfDivisblePowers ( L , R , P ) )\n", "python_code_tokenized": "def sumOfDivisblePowers ( L , R , P ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT x = i NEW_LINE while ( x % P == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE x /= P NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT L = 1 NEW_LINE R = 10 NEW_LINE P = 2 NEW_LINE print ( sumOfDivisblePowers ( L , R , P ) ) NEW_LINE"}
{"id": "geeksforgeeks_12_A", "sol": 0, "python_code": "def largestPower ( x , P ) :\n    res = 0\n    while ( x ) :\n        x = int ( x / P )\n        res += x\n    return res\ndef sumOfDivisblePowers ( L , R , P ) :\n    return largestPower ( R , P ) - largestPower ( L - 1 , P )\nL = 1\nR = 10\nP = 2\nprint ( sumOfDivisblePowers ( L , R , P ) )\n", "python_code_tokenized": "def largestPower ( x , P ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x = int ( x / P ) NEW_LINE res += x NEW_LINE DEDENT return res NEW_LINE DEDENT def sumOfDivisblePowers ( L , R , P ) : NEW_LINE INDENT return largestPower ( R , P ) - largestPower ( L - 1 , P ) NEW_LINE DEDENT L = 1 NEW_LINE R = 10 NEW_LINE P = 2 NEW_LINE print ( sumOfDivisblePowers ( L , R , P ) ) NEW_LINE"}
{"id": "aizu_p00200_A", "sol": 0, "python_code": "import heapq\nimport sys\nfrom collections import defaultdict\ndef dijkstra ( graph , size , start ) :\n    d = [ float ( 'inf' ) ] * size\n    d [ start ] = 0\n    q = [ ( 0 , start ) ]\n    while len ( q ) :\n        du , u = heapq.heappop ( q )\n        for length , v in graph [ u ] :\n            if d [ v ] > du + length :\n                d [ v ] = du + length\n                heapq.heappush ( q , ( d [ v ] , v ) )\n    return d\nf = sys.stdin\nwhile True :\n    n , m = map ( int , f.readline ( ).split ( ) )\n    if n == 0 :\n        break\n    abct = [ map ( int , f.readline ( ).split ( ) ) for _ in range ( n ) ]\n    d = [ defaultdict ( list ) , defaultdict ( list ) ]\n    for ai , bi , ci , ti in abct :\n        ai -= 1\n        bi -= 1\n        d [ 0 ] [ ai ].append ( ( ci , bi ) )\n        d [ 0 ] [ bi ].append ( ( ci , ai ) )\n        d [ 1 ] [ ai ].append ( ( ti , bi ) )\n        d [ 1 ] [ bi ].append ( ( ti , ai ) )\n    dist = { }\n    for i in range ( int ( f.readline ( ) ) ) :\n        p , q , r = map ( int , f.readline ( ).split ( ) )\n        p -= 1\n        q -= 1\n        try :\n            print ( dist [ ( q , r ) ] [ p ] )\n        except KeyError :\n            try :\n                print ( dist [ ( p , r ) ] [ q ] )\n            except :\n                dist [ ( p , r ) ] = dijkstra ( d [ r ] , m , p )\n                print ( dist [ ( p , r ) ] [ q ] )\n", "python_code_tokenized": "import heapq NEW_LINE import sys NEW_LINE from collections import defaultdict NEW_LINE def dijkstra ( graph , size , start ) : NEW_LINE INDENT d = [ float ( ' inf ' ) ] * size NEW_LINE d [ start ] = 0 NEW_LINE q = [ ( 0 , start ) ] NEW_LINE while len ( q ) : NEW_LINE INDENT du , u = heapq . heappop ( q ) NEW_LINE for length , v in graph [ u ] : NEW_LINE INDENT if d [ v ] > du + length : NEW_LINE INDENT d [ v ] = du + length NEW_LINE heapq . heappush ( q , ( d [ v ] , v ) ) NEW_LINE DEDENT DEDENT DEDENT return d NEW_LINE DEDENT f = sys . stdin NEW_LINE while True : NEW_LINE INDENT n , m = map ( int , f . readline ( ) . split ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT abct = [ map ( int , f . readline ( ) . split ( ) ) for _ in range ( n ) ] NEW_LINE d = [ defaultdict ( list ) , defaultdict ( list ) ] NEW_LINE for ai , bi , ci , ti in abct : NEW_LINE INDENT ai -= 1 NEW_LINE bi -= 1 NEW_LINE d [ 0 ] [ ai ] . append ( ( ci , bi ) ) NEW_LINE d [ 0 ] [ bi ] . append ( ( ci , ai ) ) NEW_LINE d [ 1 ] [ ai ] . append ( ( ti , bi ) ) NEW_LINE d [ 1 ] [ bi ] . append ( ( ti , ai ) ) NEW_LINE DEDENT dist = { } NEW_LINE for i in range ( int ( f . readline ( ) ) ) : NEW_LINE INDENT p , q , r = map ( int , f . readline ( ) . split ( ) ) NEW_LINE p -= 1 NEW_LINE q -= 1 NEW_LINE try : NEW_LINE INDENT print ( dist [ ( q , r ) ] [ p ] ) NEW_LINE DEDENT except KeyError : NEW_LINE INDENT try : NEW_LINE INDENT print ( dist [ ( p , r ) ] [ q ] ) NEW_LINE DEDENT except : NEW_LINE INDENT dist [ ( p , r ) ] = dijkstra ( d [ r ] , m , p ) NEW_LINE print ( dist [ ( p , r ) ] [ q ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_1981_A", "sol": 0, "python_code": "def bitCount ( n ) :\n    count = 0\n    while ( n ) :\n        if ( n & 1 ) :\n            count += 1\n        n >>= 1\n    return count\ndef countPairsWithKDiff ( arr , n , k ) :\n    ans = 0\n    for i in range ( 0 , n - 1 , 1 ) :\n        for j in range ( i + 1 , n , 1 ) :\n            xoredNum = arr [ i ] ^ arr [ j ]\n            if ( k == bitCount ( xoredNum ) ) :\n                ans += 1\n    return ans\nif __name__ == '__main__' :\n    k = 2\n    arr = [ 2 , 4 , 1 , 3 , 1 ]\n    n = len ( arr )\n    print ( \"Total pairs for k =\" , k , \"are\" , countPairsWithKDiff ( arr , n , k ) )\n", "python_code_tokenized": "def bitCount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countPairsWithKDiff ( arr , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT xoredNum = arr [ i ] ^ arr [ j ] NEW_LINE if ( k == bitCount ( xoredNum ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 2 NEW_LINE arr = [ 2 , 4 , 1 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Total \u2581 pairs \u2581 for \u2581 k \u2581 = \" , k , \" are \" , countPairsWithKDiff ( arr , n , k ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC119_D", "sol": 0, "python_code": "from bisect import bisect_left\ndef main ( ) :\n    A , B , q = map ( int , input ( ).split ( ) )\n    INF = 10 ** 18\n    s = [ - INF ] + [ int ( input ( ) ) for _ in range ( A ) ] + [ INF ]\n    t = [ - INF ] + [ int ( input ( ) ) for _ in range ( B ) ] + [ INF ]\n    for _ in range ( q ) :\n        x = int ( input ( ) )\n        sind = bisect_left ( s , x )\n        tind = bisect_left ( t , x )\n        res = INF\n        for S in [ s [ sind - 1 ] , s [ sind ] ] :\n            for T in [ t [ tind - 1 ] , t [ tind ] ] :\n                d1 = abs ( x - S ) + abs ( S - T )\n                d2 = abs ( x - T ) + abs ( T - S )\n                res = min ( [ res , d1 , d2 ] )\n        print ( res )\nmain ( )\n", "python_code_tokenized": "from bisect import bisect_left NEW_LINE def main ( ) : NEW_LINE INDENT A , B , q = map ( int , input ( ) . split ( ) ) NEW_LINE INF = 10 ** 18 NEW_LINE s = [ - INF ] + [ int ( input ( ) ) for _ in range ( A ) ] + [ INF ] NEW_LINE t = [ - INF ] + [ int ( input ( ) ) for _ in range ( B ) ] + [ INF ] NEW_LINE for _ in range ( q ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE sind = bisect_left ( s , x ) NEW_LINE tind = bisect_left ( t , x ) NEW_LINE res = INF NEW_LINE for S in [ s [ sind - 1 ] , s [ sind ] ] : NEW_LINE INDENT for T in [ t [ tind - 1 ] , t [ tind ] ] : NEW_LINE INDENT d1 = abs ( x - S ) + abs ( S - T ) NEW_LINE d2 = abs ( x - T ) + abs ( T - S ) NEW_LINE res = min ( [ res , d1 , d2 ] ) NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "atcoder_ABC079_D", "sol": 0, "python_code": "h , w = map ( int , input ( ).split ( ) )\nc = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( 10 ) ]\na = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( h ) ]\nINF = 10 ** 10\ndist = [ [ c [ i ] [ j ] for j in range ( 10 ) ] for i in range ( 10 ) ]\nfor k in range ( 10 ) :\n    for i in range ( 10 ) :\n        for j in range ( 10 ) :\n            dist [ i ] [ j ] = min ( dist [ i ] [ j ] , dist [ i ] [ k ] + dist [ k ] [ j ] )\nans = 0\nfor i in range ( h ) :\n    for j in range ( w ) :\n        if a [ i ] [ j ] != - 1 :\n            ans += dist [ a [ i ] [ j ] ] [ 1 ]\nprint ( ans )\n", "python_code_tokenized": "h , w = map ( int , input ( ) . split ( ) ) NEW_LINE c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 10 ) ] NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( h ) ] NEW_LINE INF = 10 ** 10 NEW_LINE dist = [ [ c [ i ] [ j ] for j in range ( 10 ) ] for i in range ( 10 ) ] NEW_LINE for k in range ( 10 ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT dist [ i ] [ j ] = min ( dist [ i ] [ j ] , dist [ i ] [ k ] + dist [ k ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if a [ i ] [ j ] != - 1 : NEW_LINE INDENT ans += dist [ a [ i ] [ j ] ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_2568_A", "sol": 0, "python_code": "import math\ndef findPowerPrime ( fact , p ) :\n    res = 0\n    while fact :\n        res += fact // p\n        fact //= p\n    return res\ndef findPowerComposite ( fact , n ) :\n    res = math.inf\n    for i in range ( 2 , int ( n ** 0.5 ) + 1 ) :\n        count = 0\n        if not n % i :\n            count += 1\n            n = n // i\n        if count :\n            curr_pow = findPowerPrime ( fact , i ) // count\n            res = min ( res , curr_pow )\n    if n >= 2 :\n        curr_pow = findPowerPrime ( fact , n )\n        res = min ( res , curr_pow )\n    return res\nfact = 146 ; n = 5\nprint ( findPowerComposite ( fact , n ) )\n", "python_code_tokenized": "import math NEW_LINE def findPowerPrime ( fact , p ) : NEW_LINE INDENT res = 0 NEW_LINE while fact : NEW_LINE INDENT res += fact // p NEW_LINE fact //= p NEW_LINE DEDENT return res NEW_LINE DEDENT def findPowerComposite ( fact , n ) : NEW_LINE INDENT res = math . inf NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE if not n % i : NEW_LINE INDENT count += 1 NEW_LINE n = n // i NEW_LINE DEDENT if count : NEW_LINE INDENT curr_pow = findPowerPrime ( fact , i ) // count NEW_LINE res = min ( res , curr_pow ) NEW_LINE DEDENT DEDENT if n >= 2 : NEW_LINE INDENT curr_pow = findPowerPrime ( fact , n ) NEW_LINE res = min ( res , curr_pow ) NEW_LINE DEDENT return res NEW_LINE DEDENT fact = 146 ; n = 5 NEW_LINE print ( findPowerComposite ( fact , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3424_A", "sol": 0, "python_code": "def removeZero ( n ) :\n    res = 0\n    d = 1\n    while ( n > 0 ) :\n        if ( n % 10 != 0 ) :\n            res += ( n % 10 ) * d\n            d *= 10\n        n //= 10\n    return res\ndef isEqual ( a , b ) :\n    if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) :\n        return True\n    return False\na = 105\nb = 106\nif ( isEqual ( a , b ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def removeZero ( n ) : NEW_LINE INDENT res = 0 NEW_LINE d = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 != 0 ) : NEW_LINE INDENT res += ( n % 10 ) * d NEW_LINE d *= 10 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def isEqual ( a , b ) : NEW_LINE INDENT if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a = 105 NEW_LINE b = 106 NEW_LINE if ( isEqual ( a , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "codeforces_593_B", "sol": 0, "python_code": "import sys\nimport time\nimport math\nfrom collections import defaultdict\nfrom functools import lru_cache\nINF = 10 ** 18 + 3\nEPS = 1e-10\nMAX_CACHE = 10 ** 9\ndef time_it ( function , output = sys.stderr ) :\n    def wrapped ( * args , ** kwargs ) :\n        start = time.time ( )\n        res = function ( * args , ** kwargs )\n        elapsed_time = time.time ( ) - start\n        print ( '\"%s\" took %f ms' % ( function.__name__ , elapsed_time * 1000 ) , file = output )\n        return res\n    return wrapped\n@ time_it\ndef main ( ) :\n    n = int ( input ( ) )\n    x1 , x2 = map ( int , input ( ).split ( ) )\n    funcs = [ ]\n    for _ in range ( n ) :\n        k , b = map ( int , input ( ).split ( ) )\n        funcs.append ( lambda x , k = k , b = b : k * x + b )\n    comp = lambda x : lambda i : funcs [ i ] ( x )\n    sorted1 = sorted ( range ( n ) , key = comp ( x1 + EPS ) )\n    sorted2 = sorted ( range ( n ) , key = comp ( x2 - EPS ) )\n    print ( \"Yes\" if sorted1 != sorted2 else \"No\" )\ndef set_input ( file ) :\n    global input\n    input = lambda : file.readline ( ).strip ( )\ndef set_output ( file ) :\n    global print\n    local_print = print\n    def print ( * args , ** kwargs ) :\n        kwargs [ \"file\" ] = kwargs.get ( \"file\" , file )\n        return local_print ( * args , ** kwargs )\nif __name__ == '__main__' :\n    set_input ( open ( \"input.txt\" , \"r\" ) if \"MINE\" in sys.argv else sys.stdin )\n    set_output ( sys.stdout )\n    main ( )\n", "python_code_tokenized": "import sys NEW_LINE import time NEW_LINE import math NEW_LINE from collections import defaultdict NEW_LINE from functools import lru_cache NEW_LINE INF = 10 ** 18 + 3 NEW_LINE EPS = 1e-10 NEW_LINE MAX_CACHE = 10 ** 9 NEW_LINE def time_it ( function , output = sys . stderr ) : NEW_LINE INDENT def wrapped ( * args , ** kwargs ) : NEW_LINE INDENT start = time . time ( ) NEW_LINE res = function ( * args , ** kwargs ) NEW_LINE elapsed_time = time . time ( ) - start NEW_LINE print ( ' \" % s \" \u2581 took \u2581 % f \u2581 ms ' % ( function . __name__ , elapsed_time * 1000 ) , file = output ) NEW_LINE return res NEW_LINE DEDENT return wrapped NEW_LINE DEDENT @ time_it NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x1 , x2 = map ( int , input ( ) . split ( ) ) NEW_LINE funcs = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT k , b = map ( int , input ( ) . split ( ) ) NEW_LINE funcs . append ( lambda x , k = k , b = b : k * x + b ) NEW_LINE DEDENT comp = lambda x : lambda i : funcs [ i ] ( x ) NEW_LINE sorted1 = sorted ( range ( n ) , key = comp ( x1 + EPS ) ) NEW_LINE sorted2 = sorted ( range ( n ) , key = comp ( x2 - EPS ) ) NEW_LINE print ( \" Yes \" if sorted1 != sorted2 else \" No \" ) NEW_LINE DEDENT def set_input ( file ) : NEW_LINE INDENT global input NEW_LINE input = lambda : file . readline ( ) . strip ( ) NEW_LINE DEDENT def set_output ( file ) : NEW_LINE INDENT global print NEW_LINE local_print = print NEW_LINE def print ( * args , ** kwargs ) : NEW_LINE INDENT kwargs [ \" file \" ] = kwargs . get ( \" file \" , file ) NEW_LINE return local_print ( * args , ** kwargs ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT set_input ( open ( \" input . txt \" , \" r \" ) if \" MINE \" in sys . argv else sys . stdin ) NEW_LINE set_output ( sys . stdout ) NEW_LINE main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1926_A", "sol": 0, "python_code": "def findCount ( s , n , a , b ) :\n    res = 0\n    for i in range ( b ) :\n        if ( i == a ) :\n            res += ( s [ n - i - 1 ] != '1' )\n        else :\n            res += ( s [ n - i - 1 ] != '0' )\n    return res\nif __name__ == '__main__' :\n    str = \"1001011001\"\n    N = len ( str )\n    A = 3\n    B = 6\n    print ( findCount ( str , N , A , B ) )\n", "python_code_tokenized": "def findCount ( s , n , a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( b ) : NEW_LINE INDENT if ( i == a ) : NEW_LINE INDENT res += ( s [ n - i - 1 ] != '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT res += ( s [ n - i - 1 ] != '0' ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"1001011001\" NEW_LINE N = len ( str ) NEW_LINE A = 3 NEW_LINE B = 6 NEW_LINE print ( findCount ( str , N , A , B ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1541_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    n = int ( input ( ) )\n    if n % 2 == 0 :\n        a = [ i + ( 2 * ( i % 2 ) - 1 ) for i in range ( 1 , n + 1 ) ]\n    else :\n        a = [ i + ( 2 * ( i % 2 ) - 1 ) for i in range ( 1 , n - 2 ) ] + [ n , n - 2 , n - 1 ]\n    print ( * a )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT a = [ i + ( 2 * ( i % 2 ) - 1 ) for i in range ( 1 , n + 1 ) ] NEW_LINE DEDENT else : NEW_LINE INDENT a = [ i + ( 2 * ( i % 2 ) - 1 ) for i in range ( 1 , n - 2 ) ] + [ n , n - 2 , n - 1 ] NEW_LINE DEDENT print ( * a ) NEW_LINE DEDENT"}
{"id": "aizu_p00133_A", "sol": 0, "python_code": "m = [ input ( ) for _ in range ( 8 ) ]\nprint ( 90 )\na = - 1\nfor j in range ( 8 ) :\n    for i in range ( 7 , a , a ) :\n        print ( m [ i ] [ j ] , end = '' )\n    print ( )\nprint ( 180 )\nfor i in range ( 7 , a , a ) :\n    for j in range ( 7 , a , a ) :\n        print ( m [ i ] [ j ] , end = '' )\n    print ( )\nprint ( 270 )\nfor j in range ( 7 , a , a ) :\n    for i in range ( 8 ) :\n        print ( m [ i ] [ j ] , end = '' )\n    print ( )\n", "python_code_tokenized": "m = [ input ( ) for _ in range ( 8 ) ] NEW_LINE print ( 90 ) NEW_LINE a = - 1 NEW_LINE for j in range ( 8 ) : NEW_LINE INDENT for i in range ( 7 , a , a ) : NEW_LINE INDENT print ( m [ i ] [ j ] , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT print ( 180 ) NEW_LINE for i in range ( 7 , a , a ) : NEW_LINE INDENT for j in range ( 7 , a , a ) : NEW_LINE INDENT print ( m [ i ] [ j ] , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT print ( 270 ) NEW_LINE for j in range ( 7 , a , a ) : NEW_LINE INDENT for i in range ( 8 ) : NEW_LINE INDENT print ( m [ i ] [ j ] , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3653_A", "sol": 0, "python_code": "from math import radians , cos , sin , asin , sqrt\ndef distance ( lat1 , lat2 , lon1 , lon2 ) :\n    lon1 = radians ( lon1 )\n    lon2 = radians ( lon2 )\n    lat1 = radians ( lat1 )\n    lat2 = radians ( lat2 )\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    a = sin ( dlat / 2 ) ** 2 + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) ** 2\n    c = 2 * asin ( sqrt ( a ) )\n    r = 6371\n    return ( c * r )\nlat1 = 53.32055555555556\nlat2 = 53.31861111111111\nlon1 = - 1.7297222222222221\nlon2 = - 1.6997222222222223\nprint ( distance ( lat1 , lat2 , lon1 , lon2 ) , \"K.M\" )\n", "python_code_tokenized": "from math import radians , cos , sin , asin , sqrt NEW_LINE def distance ( lat1 , lat2 , lon1 , lon2 ) : NEW_LINE INDENT lon1 = radians ( lon1 ) NEW_LINE lon2 = radians ( lon2 ) NEW_LINE lat1 = radians ( lat1 ) NEW_LINE lat2 = radians ( lat2 ) NEW_LINE dlon = lon2 - lon1 NEW_LINE dlat = lat2 - lat1 NEW_LINE a = sin ( dlat / 2 ) ** 2 + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) ** 2 NEW_LINE c = 2 * asin ( sqrt ( a ) ) NEW_LINE r = 6371 NEW_LINE return ( c * r ) NEW_LINE DEDENT lat1 = 53.32055555555556 NEW_LINE lat2 = 53.31861111111111 NEW_LINE lon1 = - 1.7297222222222221 NEW_LINE lon2 = - 1.6997222222222223 NEW_LINE print ( distance ( lat1 , lat2 , lon1 , lon2 ) , \" K . M \" ) NEW_LINE"}
{"id": "leetcode_716_A", "sol": 0, "python_code": "class MaxStack ( object ) :\n    def __init__ ( self ) :\n        self.stack = [ ]\n        self.max_stack = [ ]\n    def push ( self , x ) :\n        self.stack.append ( x )\n        if len ( self.max_stack ) == 0 :\n            self.max_stack.append ( x )\n            return\n        if self.max_stack [ - 1 ] > x :\n            self.max_stack.append ( self.max_stack [ - 1 ] )\n        else :\n            self.max_stack.append ( x )\n    def pop ( self ) :\n        if len ( self.stack ) != 0 :\n            self.max_stack.pop ( - 1 )\n            return self.stack.pop ( - 1 )\n    def top ( self ) :\n        return self.stack [ - 1 ]\n    def peekMax ( self ) :\n        if len ( self.max_stack ) != 0 :\n            return self.max_stack [ - 1 ]\n    def popMax ( self ) :\n        val = self.peekMax ( )\n        buff = [ ]\n        while self.top ( ) != val :\n            buff.append ( self.pop ( ) )\n        self.pop ( )\n        while len ( buff ) != 0 :\n            self.push ( buff.pop ( - 1 ) )\n        return val\n", "python_code_tokenized": "class MaxStack ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE self . max_stack = [ ] NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT self . stack . append ( x ) NEW_LINE if len ( self . max_stack ) == 0 : NEW_LINE INDENT self . max_stack . append ( x ) NEW_LINE return NEW_LINE DEDENT if self . max_stack [ - 1 ] > x : NEW_LINE INDENT self . max_stack . append ( self . max_stack [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT self . max_stack . append ( x ) NEW_LINE DEDENT DEDENT def pop ( self ) : NEW_LINE INDENT if len ( self . stack ) != 0 : NEW_LINE INDENT self . max_stack . pop ( - 1 ) NEW_LINE return self . stack . pop ( - 1 ) NEW_LINE DEDENT DEDENT def top ( self ) : NEW_LINE INDENT return self . stack [ - 1 ] NEW_LINE DEDENT def peekMax ( self ) : NEW_LINE INDENT if len ( self . max_stack ) != 0 : NEW_LINE INDENT return self . max_stack [ - 1 ] NEW_LINE DEDENT DEDENT def popMax ( self ) : NEW_LINE INDENT val = self . peekMax ( ) NEW_LINE buff = [ ] NEW_LINE while self . top ( ) != val : NEW_LINE INDENT buff . append ( self . pop ( ) ) NEW_LINE DEDENT self . pop ( ) NEW_LINE while len ( buff ) != 0 : NEW_LINE INDENT self . push ( buff . pop ( - 1 ) ) NEW_LINE DEDENT return val NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1209_A", "sol": 0, "python_code": "def TrialDivision ( N ) :\n    i = 2\n    k = int ( N ** 0.5 )\n    while ( i <= k ) :\n        if ( N % i == 0 ) :\n            return 0\n        i += 1\n    return 1\nif __name__ == \"__main__\" :\n    N = 49\n    p = TrialDivision ( N )\n    if ( p ) :\n        print ( \"Prime\" )\n    else :\n        print ( \"Composite\" )\n", "python_code_tokenized": "def TrialDivision ( N ) : NEW_LINE INDENT i = 2 NEW_LINE k = int ( N ** 0.5 ) NEW_LINE while ( i <= k ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 49 NEW_LINE p = TrialDivision ( N ) NEW_LINE if ( p ) : NEW_LINE INDENT print ( \" Prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Composite \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1600_A", "sol": 0, "python_code": "def PrintBothArrays ( a , n ) :\n    v1 , v2 = [ ] , [ ] ;\n    mpp = dict.fromkeys ( a , 0 ) ;\n    for i in range ( n ) :\n        mpp [ a [ i ] ] += 1 ;\n        if ( mpp [ a [ i ] ] == 1 ) :\n            v1.append ( a [ i ] ) ;\n        elif ( mpp [ a [ i ] ] == 2 ) :\n            v2.append ( a [ i ] ) ;\n        else :\n            print ( \"Not possible\" ) ;\n            return ;\n    v1.sort ( ) ;\n    print ( \"Strictly increasing array is:\" ) ;\n    for it in v1 :\n        print ( it , end = \" \" ) ;\n    v2.sort ( reverse = True ) ;\n    print ( \"\\nStrictly decreasing array is:\" ) ;\n    for it in v2 :\n        print ( it , end = \" \" )\nif __name__ == \"__main__\" :\n    a = [ 7 , 2 , 7 , 3 , 3 , 1 , 4 ] ;\n    n = len ( a ) ;\n    PrintBothArrays ( a , n ) ;\n", "python_code_tokenized": "def PrintBothArrays ( a , n ) : NEW_LINE INDENT v1 , v2 = [ ] , [ ] ; NEW_LINE mpp = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mpp [ a [ i ] ] += 1 ; NEW_LINE if ( mpp [ a [ i ] ] == 1 ) : NEW_LINE INDENT v1 . append ( a [ i ] ) ; NEW_LINE DEDENT elif ( mpp [ a [ i ] ] == 2 ) : NEW_LINE INDENT v2 . append ( a [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 possible \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT v1 . sort ( ) ; NEW_LINE print ( \" Strictly \u2581 increasing \u2581 array \u2581 is : \" ) ; NEW_LINE for it in v1 : NEW_LINE INDENT print ( it , end = \" \u2581 \" ) ; NEW_LINE DEDENT v2 . sort ( reverse = True ) ; NEW_LINE print ( \" \\n Strictly \u2581 decreasing \u2581 array \u2581 is : \" ) ; NEW_LINE for it in v2 : NEW_LINE INDENT print ( it , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 2 , 7 , 3 , 3 , 1 , 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE PrintBothArrays ( a , n ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1599_A", "sol": 0, "python_code": "N = 20\nfact = [ 0 ] * N ;\ndef pre ( ) :\n    fact [ 0 ] = 1 ;\n    for i in range ( 1 , N ) :\n        fact [ i ] = i * fact [ i - 1 ] ;\ndef CountPermutation ( a , n ) :\n    ways = 1 ;\n    a.sort ( ) ;\n    size = 1 ;\n    for i in range ( 1 , n ) :\n        if ( a [ i ] == a [ i - 1 ] ) :\n            size += 1 ;\n        else :\n            ways *= fact [ size ] ;\n            size = 1 ;\n    ways *= fact [ size ] ;\n    return ways ;\nif __name__ == \"__main__\" :\n    a = [ 1 , 2 , 4 , 4 , 2 , 4 ] ;\n    n = len ( a ) ;\n    pre ( ) ;\n    print ( CountPermutation ( a , n ) ) ;\n", "python_code_tokenized": "N = 20 NEW_LINE fact = [ 0 ] * N ; NEW_LINE def pre ( ) : NEW_LINE INDENT fact [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] ; NEW_LINE DEDENT DEDENT def CountPermutation ( a , n ) : NEW_LINE INDENT ways = 1 ; NEW_LINE a . sort ( ) ; NEW_LINE size = 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] ) : NEW_LINE INDENT size += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ways *= fact [ size ] ; NEW_LINE size = 1 ; NEW_LINE DEDENT DEDENT ways *= fact [ size ] ; NEW_LINE return ways ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 4 , 4 , 2 , 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE pre ( ) ; NEW_LINE print ( CountPermutation ( a , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3524_A", "sol": 0, "python_code": "def subsetPairNotDivisibleByK ( arr , N , K ) :\n    f = [ 0 for i in range ( K ) ]\n    for i in range ( N ) :\n        f [ arr [ i ] % K ] += 1\n    if ( K % 2 == 0 ) :\n        f [ K // 2 ] = min ( f [ K // 2 ] , 1 )\n    res = min ( f [ 0 ] , 1 )\n    for i in range ( 1 , ( K // 2 ) + 1 ) :\n        res += max ( f [ i ] , f [ K - i ] )\n    return res\narr = [ 3 , 7 , 2 , 9 , 1 ]\nN = len ( arr )\nK = 3\nprint ( subsetPairNotDivisibleByK ( arr , N , K ) )\n", "python_code_tokenized": "def subsetPairNotDivisibleByK ( arr , N , K ) : NEW_LINE INDENT f = [ 0 for i in range ( K ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT f [ arr [ i ] % K ] += 1 NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT f [ K // 2 ] = min ( f [ K // 2 ] , 1 ) NEW_LINE DEDENT res = min ( f [ 0 ] , 1 ) NEW_LINE for i in range ( 1 , ( K // 2 ) + 1 ) : NEW_LINE INDENT res += max ( f [ i ] , f [ K - i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 3 , 7 , 2 , 9 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( subsetPairNotDivisibleByK ( arr , N , K ) ) NEW_LINE"}
{"id": "atcoder_ABC143_C", "sol": 0, "python_code": "n = int ( input ( ) )\ns = str ( input ( ) )\nans = 1\nfor i in range ( n - 1 ) :\n    if s [ i ] != s [ i + 1 ] :\n        ans += 1\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = str ( input ( ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] != s [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "aizu_p01172_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    while b : a , b = b , a % b\n    return a\ndef f ( n , m ) :\n    if m == 1 : return 0\n    x = 1\n    for i in range ( m ) :\n        x = ( x * n ) % m\n        if x == 1 : return i + 1\nwhile 1 :\n    a , b = map ( int , input ( ).split ( ) )\n    if a == 0 : break\n    c = gcd ( a , b )\n    a //= c ; b //= c\n    cnt = 0 ; d = gcd ( b , 10 )\n    while d != 1 :\n        b //= d\n        cnt += 1\n        d = gcd ( b , 10 )\n    print ( cnt , f ( 10 , b ) )\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT while b : a , b = b , a % b NEW_LINE return a NEW_LINE DEDENT def f ( n , m ) : NEW_LINE INDENT if m == 1 : return 0 NEW_LINE x = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT x = ( x * n ) % m NEW_LINE if x == 1 : return i + 1 NEW_LINE DEDENT DEDENT while 1 : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : break NEW_LINE c = gcd ( a , b ) NEW_LINE a //= c ; b //= c NEW_LINE cnt = 0 ; d = gcd ( b , 10 ) NEW_LINE while d != 1 : NEW_LINE INDENT b //= d NEW_LINE cnt += 1 NEW_LINE d = gcd ( b , 10 ) NEW_LINE DEDENT print ( cnt , f ( 10 , b ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2944_A", "sol": 0, "python_code": "def printMultiples ( n ) :\n    unit_digit = n % 10\n    if ( unit_digit == 0 ) :\n        unit_digit = 10\n    for i in range ( unit_digit , n + 1 , unit_digit ) :\n        print ( i , end = \" \" )\nn = 39\nprintMultiples ( n )\n", "python_code_tokenized": "def printMultiples ( n ) : NEW_LINE INDENT unit_digit = n % 10 NEW_LINE if ( unit_digit == 0 ) : NEW_LINE INDENT unit_digit = 10 NEW_LINE DEDENT for i in range ( unit_digit , n + 1 , unit_digit ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT n = 39 NEW_LINE printMultiples ( n ) NEW_LINE"}
{"id": "geeksforgeeks_1220_A", "sol": 0, "python_code": "def Area ( b1 , b2 , h ) :\n    return ( ( b1 + b2 ) / 2 ) * h\nbase1 = 8 ; base2 = 10 ; height = 6\narea = Area ( base1 , base2 , height )\nprint ( \"Area is:\" , area )\n", "python_code_tokenized": "def Area ( b1 , b2 , h ) : NEW_LINE INDENT return ( ( b1 + b2 ) / 2 ) * h NEW_LINE DEDENT base1 = 8 ; base2 = 10 ; height = 6 NEW_LINE area = Area ( base1 , base2 , height ) NEW_LINE print ( \" Area \u2581 is : \" , area ) NEW_LINE"}
{"id": "leetcode_509_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def __init__ ( self ) :\n        self.memo = [ ]\n        self.memo.append ( 0 )\n        self.memo.append ( 1 )\n    def fib ( self , N ) :\n        if N < len ( self.memo ) :\n            return self.memo [ N ]\n        for i in range ( len ( self.memo ) , N + 1 ) :\n            self.memo.append ( self.memo [ i - 1 ] + self.memo [ i - 2 ] )\n        return self.memo [ N ]\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . memo = [ ] NEW_LINE self . memo . append ( 0 ) NEW_LINE self . memo . append ( 1 ) NEW_LINE DEDENT def fib ( self , N ) : NEW_LINE INDENT if N < len ( self . memo ) : NEW_LINE INDENT return self . memo [ N ] NEW_LINE DEDENT for i in range ( len ( self . memo ) , N + 1 ) : NEW_LINE INDENT self . memo . append ( self . memo [ i - 1 ] + self . memo [ i - 2 ] ) NEW_LINE DEDENT return self . memo [ N ] NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3713_A", "sol": 0, "python_code": "def findExtra ( arr1 , arr2 , n ) :\n    index = n\n    left = 0\n    right = n - 1\n    while ( left <= right ) :\n        mid = ( int ) ( ( left + right ) / 2 )\n        if ( arr2 [ mid ] == arr1 [ mid ] ) :\n            left = mid + 1\n        else :\n            index = mid\n            right = mid - 1\n    return index\narr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ]\narr2 = [ 2 , 4 , 6 , 8 , 10 , 12 ]\nn = len ( arr2 )\nprint ( findExtra ( arr1 , arr2 , n ) )\n", "python_code_tokenized": "def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT index = n NEW_LINE left = 0 NEW_LINE right = n - 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( int ) ( ( left + right ) / 2 ) NEW_LINE if ( arr2 [ mid ] == arr1 [ mid ] ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT index = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT arr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ] NEW_LINE arr2 = [ 2 , 4 , 6 , 8 , 10 , 12 ] NEW_LINE n = len ( arr2 ) NEW_LINE print ( findExtra ( arr1 , arr2 , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1175_A", "sol": 0, "python_code": "def russianPeasant ( a , b ) :\n    res = 0\n    while ( b > 0 ) :\n        if ( b & 1 ) :\n            res = res + a\n        a = a << 1\n        b = b >> 1\n    return res\nprint ( russianPeasant ( 18 , 1 ) )\nprint ( russianPeasant ( 20 , 12 ) )\n", "python_code_tokenized": "def russianPeasant ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( russianPeasant ( 18 , 1 ) ) NEW_LINE print ( russianPeasant ( 20 , 12 ) ) NEW_LINE"}
{"id": "geeksforgeeks_3710_A", "sol": 0, "python_code": "def findMinimumK ( a , n , s ) :\n    maximum = a [ 0 ]\n    for i in range ( n ) :\n        maximum = max ( maximum , a [ i ] )\n    low = 1\n    high = maximum + 1\n    ans = high\n    while ( low <= high ) :\n        mid = ( low + high ) // 2\n        sum = 0\n        for i in range ( n ) :\n            sum += ( a [ i ] // mid )\n        if ( sum > s ) :\n            low = mid + 1\n        else :\n            ans = min ( ans , mid )\n            high = mid - 1\n    return ans\na = [ 10 , 7 , 8 , 10 , 12 , 19 ]\nn = len ( a )\ns = 27\nprint ( findMinimumK ( a , n , s ) )\n", "python_code_tokenized": "def findMinimumK ( a , n , s ) : NEW_LINE INDENT maximum = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT maximum = max ( maximum , a [ i ] ) NEW_LINE DEDENT low = 1 NEW_LINE high = maximum + 1 NEW_LINE ans = high NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ( a [ i ] // mid ) NEW_LINE DEDENT if ( sum > s ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , mid ) NEW_LINE high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT a = [ 10 , 7 , 8 , 10 , 12 , 19 ] NEW_LINE n = len ( a ) NEW_LINE s = 27 NEW_LINE print ( findMinimumK ( a , n , s ) ) NEW_LINE"}
{"id": "geeksforgeeks_2368_A", "sol": 0, "python_code": "def newvol ( x ) :\n    print ( \"percentage increase in the volume of the cylinder is \" , x , \"%\" )\nx = 10.0\nnewvol ( x )\n", "python_code_tokenized": "def newvol ( x ) : NEW_LINE INDENT print ( \" percentage \u2581 increase \u2581 in \u2581 the \u2581 volume \u2581 of \u2581 the \u2581 cylinder \u2581 is \u2581 \" , x , \" % \" ) NEW_LINE DEDENT x = 10.0 NEW_LINE newvol ( x ) NEW_LINE"}
{"id": "geeksforgeeks_2369_A", "sol": 0, "python_code": "def newvol ( x ) :\n    print ( \"percentage increase in the\" , pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 , \"%\" ) DEDENT x = 10.0\n    newvol ( x )\n    ", "python_code_tokenized": "def newvol ( x ) : NEW_LINE INDENT print ( \" percentage \u2581 increase \u2581 in \u2581 the \" , pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 , \" % \" ) DEDENT x = 10.0 NEW_LINE newvol ( x ) NEW_LINE"}
{"id": "geeksforgeeks_2371_A", "sol": 0, "python_code": "def newvol ( x ) :\n    print ( \"percentage increase\" \"in the volume of the cube is \" , ( ( x ** ( 3 ) ) / 10000 + 3 * x + ( 3 * ( x ** ( 2 ) ) ) / 100 ) , \"%\" ) ;\nx = 10 ;\nnewvol ( x ) ;\n", "python_code_tokenized": "def newvol ( x ) : NEW_LINE INDENT print ( \" percentage \u2581 increase \" \" in \u2581 the \u2581 volume \u2581 of \u2581 the \u2581 cube \u2581 is \u2581 \" , ( ( x ** ( 3 ) ) / 10000 + 3 * x + ( 3 * ( x ** ( 2 ) ) ) / 100 ) , \" % \" ) ; NEW_LINE DEDENT x = 10 ; NEW_LINE newvol ( x ) ; NEW_LINE"}
{"id": "geeksforgeeks_661_A", "sol": 0, "python_code": "def solve ( n ) :\n    if ( n == 1 ) :\n        print ( - 1 ) ;\n    else :\n        num = 2 ;\n        for i in range ( n - 1 ) :\n            num = ( num * 10 ) + 3 ;\n        print ( num ) ;\nif __name__ == \"__main__\" :\n    n = 4 ;\n    solve ( n ) ;\n", "python_code_tokenized": "def solve ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT num = 2 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT num = ( num * 10 ) + 3 ; NEW_LINE DEDENT print ( num ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE solve ( n ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1948_A", "sol": 0, "python_code": "maxN = 10\nfact = [ 0 ] * maxN ;\ndef ncr ( n , r ) :\n    return ( fact [ n ] // fact [ r ] ) // fact [ n - r ] ;\ndef findSum ( arr , n ) :\n    fact [ 0 ] = 1 ;\n    for i in range ( 1 , n ) :\n        fact [ i ] = i * fact [ i - 1 ] ;\n    mul = 0 ;\n    for i in range ( n ) :\n        mul += ( 2 ** i ) * ncr ( n - 1 , i ) ;\n    ans = 0 ;\n    for i in range ( n ) :\n        ans += mul * arr [ i ] ;\n    return ans ;\nif __name__ == \"__main__\" :\n    arr = [ 1 , 1 ] ;\n    n = len ( arr ) ;\n    print ( findSum ( arr , n ) ) ;\n", "python_code_tokenized": "maxN = 10 NEW_LINE fact = [ 0 ] * maxN ; NEW_LINE def ncr ( n , r ) : NEW_LINE INDENT return ( fact [ n ] // fact [ r ] ) // fact [ n - r ] ; NEW_LINE DEDENT def findSum ( arr , n ) : NEW_LINE INDENT fact [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] ; NEW_LINE DEDENT mul = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mul += ( 2 ** i ) * ncr ( n - 1 , i ) ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += mul * arr [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findSum ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_336_A", "sol": 0, "python_code": "x , y = map ( int , input ( ).split ( ) )\nc = abs ( x ) + abs ( y )\nif x > 0 and y > 0 :\n    print ( 0 , c , c , 0 )\nif x < 0 and y > 0 :\n    print ( - c , 0 , 0 , c )\nif x > 0 and y < 0 :\n    print ( 0 , - c , c , 0 )\nif x < 0 and y < 0 :\n    print ( - c , 0 , 0 , - c )\n", "python_code_tokenized": "x , y = map ( int , input ( ) . split ( ) ) NEW_LINE c = abs ( x ) + abs ( y ) NEW_LINE if x > 0 and y > 0 : NEW_LINE INDENT print ( 0 , c , c , 0 ) NEW_LINE DEDENT if x < 0 and y > 0 : NEW_LINE INDENT print ( - c , 0 , 0 , c ) NEW_LINE DEDENT if x > 0 and y < 0 : NEW_LINE INDENT print ( 0 , - c , c , 0 ) NEW_LINE DEDENT if x < 0 and y < 0 : NEW_LINE INDENT print ( - c , 0 , 0 , - c ) NEW_LINE DEDENT"}
{"id": "atcoder_ARC082_A", "sol": 0, "python_code": "from collections import Counter\nif __name__ == '__main__' :\n    n = int ( input ( ) )\n    a = [ int ( s ) for s in input ( ).split ( ) ]\n    print ( max ( Counter ( a + [ x - 1 for x in a ] + [ x + 1 for x in a ] ).values ( ) ) )\n", "python_code_tokenized": "from collections import Counter NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE print ( max ( Counter ( a + [ x - 1 for x in a ] + [ x + 1 for x in a ] ) . values ( ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3676_A", "sol": 0, "python_code": "from sys import maxsize as INT_MAX\nMX = 2001\nOFF = 1000\nclass point :\n    def __init__ ( self , x , y ) :\n        self.x = x\n        self.y = y\ndef countPoints ( n : int , points : list ) -> int :\n    minx = [ INT_MAX ] * MX\n    miny = [ INT_MAX ] * MX\n    maxx = [ 0 ] * MX\n    maxy = [ 0 ] * MX\n    x , y = 0 , 0\n    for i in range ( n ) :\n        points [ i ].x += OFF\n        points [ i ].y += OFF\n        x = points [ i ].x\n        y = points [ i ].y\n        minx [ y ] = min ( minx [ y ] , x )\n        maxx [ y ] = max ( maxx [ y ] , x )\n        miny [ x ] = min ( miny [ x ] , y )\n        maxy [ x ] = max ( maxy [ x ] , y )\n    count = 0\n    for i in range ( n ) :\n        x = points [ i ].x\n        y = points [ i ].y\n        if ( x > minx [ y ] and x < maxx [ y ] ) :\n            if ( y > miny [ x ] and y < maxy [ x ] ) :\n                count += 1\n    return count\nif __name__ == \"__main__\" :\n    points = [ point ( 0 , 0 ) , point ( 0 , 1 ) , point ( 1 , 0 ) , point ( 0 , - 1 ) , point ( - 1 , 0 ) ]\n    n = len ( points )\n    print ( countPoints ( n , points ) )\n", "python_code_tokenized": "from sys import maxsize as INT_MAX NEW_LINE MX = 2001 NEW_LINE OFF = 1000 NEW_LINE class point : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def countPoints ( n : int , points : list ) -> int : NEW_LINE INDENT minx = [ INT_MAX ] * MX NEW_LINE miny = [ INT_MAX ] * MX NEW_LINE maxx = [ 0 ] * MX NEW_LINE maxy = [ 0 ] * MX NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT points [ i ] . x += OFF NEW_LINE points [ i ] . y += OFF NEW_LINE x = points [ i ] . x NEW_LINE y = points [ i ] . y NEW_LINE minx [ y ] = min ( minx [ y ] , x ) NEW_LINE maxx [ y ] = max ( maxx [ y ] , x ) NEW_LINE miny [ x ] = min ( miny [ x ] , y ) NEW_LINE maxy [ x ] = max ( maxy [ x ] , y ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = points [ i ] . x NEW_LINE y = points [ i ] . y NEW_LINE if ( x > minx [ y ] and x < maxx [ y ] ) : NEW_LINE INDENT if ( y > miny [ x ] and y < maxy [ x ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT points = [ point ( 0 , 0 ) , point ( 0 , 1 ) , point ( 1 , 0 ) , point ( 0 , - 1 ) , point ( - 1 , 0 ) ] NEW_LINE n = len ( points ) NEW_LINE print ( countPoints ( n , points ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_134_A", "sol": 0, "python_code": "import sys\ndp = [ [ [ - 1 for i in range ( 100 ) ] for j in range ( 100 ) ] for k in range ( 100 ) ]\ndef countString ( m , n , arr , i ) :\n    if ( m < 0 or n < 0 ) :\n        return - sys.maxsize - 1\n    if ( i >= len ( arr ) ) :\n        return 0\n    if ( dp [ m ] [ n ] [ i ] != - 1 ) :\n        return dp [ m ] [ n ] [ i ]\n    zero = 0\n    one = 0\n    for c in arr [ i ] :\n        if ( c == '0' ) :\n            zero += 1\n        else :\n            one += 1\n    x = 1 + countString ( m - zero , n - one , arr , i + 1 )\n    y = countString ( m , n , arr , i + 1 )\n    dp [ m ] [ n ] [ i ] = max ( x , y )\n    return dp [ m ] [ n ] [ i ]\nif __name__ == '__main__' :\n    arr = [ \"10\" , \"0001\" , \"1\" , \"111001\" , \"0\" ]\n    N = 3\n    M = 5\n    print ( countString ( M , N , arr , 0 ) )\n", "python_code_tokenized": "import sys NEW_LINE dp = [ [ [ - 1 for i in range ( 100 ) ] for j in range ( 100 ) ] for k in range ( 100 ) ] NEW_LINE def countString ( m , n , arr , i ) : NEW_LINE INDENT if ( m < 0 or n < 0 ) : NEW_LINE INDENT return - sys . maxsize - 1 NEW_LINE DEDENT if ( i >= len ( arr ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ m ] [ n ] [ i ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] [ i ] NEW_LINE DEDENT zero = 0 NEW_LINE one = 0 NEW_LINE for c in arr [ i ] : NEW_LINE INDENT if ( c == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT x = 1 + countString ( m - zero , n - one , arr , i + 1 ) NEW_LINE y = countString ( m , n , arr , i + 1 ) NEW_LINE dp [ m ] [ n ] [ i ] = max ( x , y ) NEW_LINE return dp [ m ] [ n ] [ i ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \"10\" , \"0001\" , \"1\" , \"111001\" , \"0\" ] NEW_LINE N = 3 NEW_LINE M = 5 NEW_LINE print ( countString ( M , N , arr , 0 ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC057_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\nprint ( ( a + b ) % 24 )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a + b ) % 24 ) NEW_LINE"}
{"id": "geeksforgeeks_4466_A", "sol": 0, "python_code": "def count ( n ) :\n    count = 0\n    while ( n ) :\n        count += n & 1\n        n >>= 1\n    return count\ndef findSetBits ( n ) :\n    for i in range ( n + 1 ) :\n        print ( count ( i ) , end = \" \" )\nif __name__ == '__main__' :\n    n = 5\n    findSetBits ( n )\n", "python_code_tokenized": "def count ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def findSetBits ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( count ( i ) , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE findSetBits ( n ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC108_B", "sol": 0, "python_code": "x1 , y1 , x2 , y2 = map ( int , input ( ).split ( ) )\na = x2 - x1\nb = y2 - y1\nprint ( x2 - b , y2 + a , x1 - b , y1 + a )\n", "python_code_tokenized": "x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE a = x2 - x1 NEW_LINE b = y2 - y1 NEW_LINE print ( x2 - b , y2 + a , x1 - b , y1 + a ) NEW_LINE"}
{"id": "atcoder_ABC131_C", "sol": 0, "python_code": "import math\ndef lcm ( x , y ) :\n    return ( x * y ) // math.gcd ( x , y )\na , b , c , d = map ( int , input ( ).split ( ) )\ne = lcm ( c , d )\nn = ( b // c ) - ( ( a - 1 ) // c )\nm = ( b // d ) - ( ( a - 1 ) // d )\no = ( b // e ) - ( ( a - 1 ) // e )\nprint ( b - a + 1 - n - m + o )\n", "python_code_tokenized": "import math NEW_LINE def lcm ( x , y ) : NEW_LINE INDENT return ( x * y ) // math . gcd ( x , y ) NEW_LINE DEDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE e = lcm ( c , d ) NEW_LINE n = ( b // c ) - ( ( a - 1 ) // c ) NEW_LINE m = ( b // d ) - ( ( a - 1 ) // d ) NEW_LINE o = ( b // e ) - ( ( a - 1 ) // e ) NEW_LINE print ( b - a + 1 - n - m + o ) NEW_LINE"}
{"id": "atcoder_ABC059_A", "sol": 0, "python_code": "A , B , C = map ( str , input ( ).split ( ) )\nprint ( ( A [ 0 ] + B [ 0 ] + C [ 0 ] ).upper ( ) )\n", "python_code_tokenized": "A , B , C = map ( str , input ( ) . split ( ) ) NEW_LINE print ( ( A [ 0 ] + B [ 0 ] + C [ 0 ] ) . upper ( ) ) NEW_LINE"}
{"id": "codeforces_930_A", "sol": 0, "python_code": "import collections\nfrom functools import partial\nn = int ( input ( ) )\nparents = [ 0 ]\nparents.extend ( int ( i ) - 1 for i in input ( ).split ( ) )\nchildren = [ set ( ) for _ in range ( n ) ]\nfor index , parent in enumerate ( parents ) :\n    if index > 0 :\n        children [ parent ].add ( index )\ndepth = [ set ( ) for _ in range ( n ) ]\ndef discover ( index : int , depth_stat : int = 0 ) -> None :\n    depth [ depth_stat ].add ( index )\n    for child in children [ index ] :\n        queue.append ( partial ( discover , child , depth_stat + 1 ) )\nqueue = collections.deque ( [ partial ( discover , 0 ) ] )\nwhile queue :\n    func = queue.popleft ( )\n    func ( )\nresult = 0\nfor children in depth :\n    result += len ( children ) % 2\nprint ( result )\n", "python_code_tokenized": "import collections NEW_LINE from functools import partial NEW_LINE n = int ( input ( ) ) NEW_LINE parents = [ 0 ] NEW_LINE parents . extend ( int ( i ) - 1 for i in input ( ) . split ( ) ) NEW_LINE children = [ set ( ) for _ in range ( n ) ] NEW_LINE for index , parent in enumerate ( parents ) : NEW_LINE INDENT if index > 0 : NEW_LINE INDENT children [ parent ] . add ( index ) NEW_LINE DEDENT DEDENT depth = [ set ( ) for _ in range ( n ) ] NEW_LINE def discover ( index : int , depth_stat : int = 0 ) -> None : NEW_LINE INDENT depth [ depth_stat ] . add ( index ) NEW_LINE for child in children [ index ] : NEW_LINE INDENT queue . append ( partial ( discover , child , depth_stat + 1 ) ) NEW_LINE DEDENT DEDENT queue = collections . deque ( [ partial ( discover , 0 ) ] ) NEW_LINE while queue : NEW_LINE INDENT func = queue . popleft ( ) NEW_LINE func ( ) NEW_LINE DEDENT result = 0 NEW_LINE for children in depth : NEW_LINE INDENT result += len ( children ) % 2 NEW_LINE DEDENT print ( result ) NEW_LINE"}
{"id": "codeforces_765_A", "sol": 0, "python_code": "num = int ( input ( ) )\nhome = input ( )\nflights = [ ]\nwhile num > 0 :\n    s , t = input ( ).split ( \"->\" )\n    flights.append ( s )\n    flights.append ( t )\n    num -= 1\ncount = 0\nfor flight in flights :\n    if flight == home :\n        count += 1\nif count % 2 == 0 :\n    print ( \"home\" )\nelse :\n    print ( \"contest\" )\n", "python_code_tokenized": "num = int ( input ( ) ) NEW_LINE home = input ( ) NEW_LINE flights = [ ] NEW_LINE while num > 0 : NEW_LINE INDENT s , t = input ( ) . split ( \" - > \" ) NEW_LINE flights . append ( s ) NEW_LINE flights . append ( t ) NEW_LINE num -= 1 NEW_LINE DEDENT count = 0 NEW_LINE for flight in flights : NEW_LINE INDENT if flight == home : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count % 2 == 0 : NEW_LINE INDENT print ( \" home \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" contest \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5032_A", "sol": 0, "python_code": "def smallestPermute ( n ) :\n    res = [ \"\" ] * ( n + 1 )\n    if ( n % 2 == 0 ) :\n        for i in range ( n ) :\n            if ( i % 2 == 0 ) :\n                res [ i ] = chr ( 48 + i + 2 )\n            else :\n                res [ i ] = chr ( 48 + i )\n    else :\n        for i in range ( n - 2 ) :\n            if ( i % 2 == 0 ) :\n                res [ i ] = chr ( 48 + i + 2 )\n            else :\n                res [ i ] = chr ( 48 + i )\n        res [ n - 1 ] = chr ( 48 + n - 2 )\n        res [ n - 2 ] = chr ( 48 + n )\n        res [ n - 3 ] = chr ( 48 + n - 1 )\n    res = ''.join ( res )\n    return res\nif __name__ == \"__main__\" :\n    n = 7\n    print ( smallestPermute ( n ) )\n", "python_code_tokenized": "def smallestPermute ( n ) : NEW_LINE INDENT res = [ \" \" ] * ( n + 1 ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( 48 + i + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 48 + i ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( 48 + i + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 48 + i ) NEW_LINE DEDENT DEDENT res [ n - 1 ] = chr ( 48 + n - 2 ) NEW_LINE res [ n - 2 ] = chr ( 48 + n ) NEW_LINE res [ n - 3 ] = chr ( 48 + n - 1 ) NEW_LINE DEDENT res = ' ' . join ( res ) NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 7 NEW_LINE print ( smallestPermute ( n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_560_A", "sol": 0, "python_code": "n = int ( input ( ) )\nx = [ int ( x ) for x in input ( ).split ( ) ]\nx.sort ( )\nif 1 in x :\n    print ( - 1 )\nelse :\n    print ( 1 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE x = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE x . sort ( ) NEW_LINE if 1 in x : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT"}
{"id": "codeforces_1567_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    s = input ( )\n    out = ''\n    for i in s :\n        if i == 'U' :\n            out += 'D'\n        elif i == 'D' :\n            out += 'U'\n        else :\n            out += i\n    print ( out )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE out = ' ' NEW_LINE for i in s : NEW_LINE INDENT if i == ' U ' : NEW_LINE INDENT out += ' D ' NEW_LINE DEDENT elif i == ' D ' : NEW_LINE INDENT out += ' U ' NEW_LINE DEDENT else : NEW_LINE INDENT out += i NEW_LINE DEDENT DEDENT print ( out ) NEW_LINE DEDENT"}
{"id": "codeforces_1567_B", "sol": 0, "python_code": "for _ in range ( 0 , int ( input ( ) ) ) :\n    m , x = map ( int , input ( ).split ( ) )\n    n = m - 1\n    w = n\n    r = n % 4\n    if r == 0 :\n        w = n\n    elif r == 1 :\n        w = 1\n    elif r == 2 :\n        w = n + 1\n    elif r == 3 :\n        w = 0\n    t = x ^ w\n    a = 0\n    if w != x :\n        a += 1\n        a += ( m == t )\n    print ( m + a )\n", "python_code_tokenized": "for _ in range ( 0 , int ( input ( ) ) ) : NEW_LINE INDENT m , x = map ( int , input ( ) . split ( ) ) NEW_LINE n = m - 1 NEW_LINE w = n NEW_LINE r = n % 4 NEW_LINE if r == 0 : NEW_LINE INDENT w = n NEW_LINE DEDENT elif r == 1 : NEW_LINE INDENT w = 1 NEW_LINE DEDENT elif r == 2 : NEW_LINE INDENT w = n + 1 NEW_LINE DEDENT elif r == 3 : NEW_LINE INDENT w = 0 NEW_LINE DEDENT t = x ^ w NEW_LINE a = 0 NEW_LINE if w != x : NEW_LINE INDENT a += 1 NEW_LINE a += ( m == t ) NEW_LINE DEDENT print ( m + a ) NEW_LINE DEDENT"}
{"id": "projecteuler_p549_A", "sol": 0, "python_code": "import itertools\ndef compute ( ) :\n    LIMIT = 10 ** 8\n    smallestdivisiblefactorials = [ 0 ] * ( LIMIT + 1 )\n    for i in range ( 2 , len ( smallestdivisiblefactorials ) ) :\n        if smallestdivisiblefactorials [ i ] == 0 :\n            power = 1\n            for j in itertools.count ( i , i ) :\n                power *= i\n                if power > LIMIT :\n                    break\n                for k in range ( power , len ( smallestdivisiblefactorials ) , power ) :\n                    smallestdivisiblefactorials [ k ] = max ( j , smallestdivisiblefactorials [ k ] )\n                temp = j // i\n                while temp % i == 0 :\n                    power *= i\n                    temp //= i\n    ans = sum ( smallestdivisiblefactorials )\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE smallestdivisiblefactorials = [ 0 ] * ( LIMIT + 1 ) NEW_LINE for i in range ( 2 , len ( smallestdivisiblefactorials ) ) : NEW_LINE INDENT if smallestdivisiblefactorials [ i ] == 0 : NEW_LINE INDENT power = 1 NEW_LINE for j in itertools . count ( i , i ) : NEW_LINE INDENT power *= i NEW_LINE if power > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT for k in range ( power , len ( smallestdivisiblefactorials ) , power ) : NEW_LINE INDENT smallestdivisiblefactorials [ k ] = max ( j , smallestdivisiblefactorials [ k ] ) NEW_LINE DEDENT temp = j // i NEW_LINE while temp % i == 0 : NEW_LINE INDENT power *= i NEW_LINE temp //= i NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = sum ( smallestdivisiblefactorials ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "aizu_p01558_A", "sol": 0, "python_code": "def main ( ) :\n    n , m = map ( int , input ( ).split ( ) )\n    s = input ( )\n    mem = set ( )\n    base = ord ( \"a\" ) - 1\n    mod1 = 1000000007\n    mod2 = 2147483647\n    h1 = [ 0 ]\n    h2 = [ 0 ]\n    for c in s :\n        h1.append ( ( h1 [ - 1 ] * 27 + ord ( c ) - base ) % mod1 )\n        h2.append ( ( h2 [ - 1 ] * 27 + ord ( c ) - base ) % mod2 )\n    pow_mem1 = { 0 : 1 }\n    pow_mem2 = { 0 : 1 }\n    def my_pow1 ( x ) :\n        if x in pow_mem1 : return pow_mem1 [ x ]\n        pow_mem1 [ x ] = my_pow1 ( x - 1 ) * 27 % mod1\n        return pow_mem1 [ x ]\n    def my_pow2 ( x ) :\n        if x in pow_mem2 : return pow_mem2 [ x ]\n        pow_mem2 [ x ] = my_pow2 ( x - 1 ) * 27 % mod2\n        return pow_mem2 [ x ]\n    left = right = 1\n    for _ in range ( m ) :\n        com = input ( )\n        if com == \"L++\" :\n            left += 1\n        if com == \"L--\" :\n            left -= 1\n        if com == \"R++\" :\n            right += 1\n        if com == \"R--\" :\n            right -= 1\n        x = ( h1 [ right ] - h1 [ left - 1 ] * my_pow1 ( right - left + 1 ) ) % mod1\n        y = ( h2 [ right ] - h2 [ left - 1 ] * my_pow2 ( right - left + 1 ) ) % mod2\n        mem.add ( ( x , y ) )\n    print ( len ( mem ) )\nmain ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE mem = set ( ) NEW_LINE base = ord ( \" a \" ) - 1 NEW_LINE mod1 = 1000000007 NEW_LINE mod2 = 2147483647 NEW_LINE h1 = [ 0 ] NEW_LINE h2 = [ 0 ] NEW_LINE for c in s : NEW_LINE INDENT h1 . append ( ( h1 [ - 1 ] * 27 + ord ( c ) - base ) % mod1 ) NEW_LINE h2 . append ( ( h2 [ - 1 ] * 27 + ord ( c ) - base ) % mod2 ) NEW_LINE DEDENT pow_mem1 = { 0 : 1 } NEW_LINE pow_mem2 = { 0 : 1 } NEW_LINE def my_pow1 ( x ) : NEW_LINE INDENT if x in pow_mem1 : return pow_mem1 [ x ] NEW_LINE pow_mem1 [ x ] = my_pow1 ( x - 1 ) * 27 % mod1 NEW_LINE return pow_mem1 [ x ] NEW_LINE DEDENT def my_pow2 ( x ) : NEW_LINE INDENT if x in pow_mem2 : return pow_mem2 [ x ] NEW_LINE pow_mem2 [ x ] = my_pow2 ( x - 1 ) * 27 % mod2 NEW_LINE return pow_mem2 [ x ] NEW_LINE DEDENT left = right = 1 NEW_LINE for _ in range ( m ) : NEW_LINE INDENT com = input ( ) NEW_LINE if com == \" L + + \" : NEW_LINE INDENT left += 1 NEW_LINE DEDENT if com == \" L - - \" : NEW_LINE INDENT left -= 1 NEW_LINE DEDENT if com == \" R + + \" : NEW_LINE INDENT right += 1 NEW_LINE DEDENT if com == \" R - - \" : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT x = ( h1 [ right ] - h1 [ left - 1 ] * my_pow1 ( right - left + 1 ) ) % mod1 NEW_LINE y = ( h2 [ right ] - h2 [ left - 1 ] * my_pow2 ( right - left + 1 ) ) % mod2 NEW_LINE mem . add ( ( x , y ) ) NEW_LINE DEDENT print ( len ( mem ) ) NEW_LINE DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_1019_A", "sol": 0, "python_code": "def countOperations ( arr , n ) :\n    count = 0 ;\n    for i in range ( n - 1 ) :\n        if ( arr [ i ] & 1 ) :\n            arr [ i ] += 1 ;\n            arr [ i + 1 ] += 1 ;\n            count += 2 ;\n    for i in range ( n ) :\n        if ( arr [ i ] & 1 ) :\n            return - 1 ;\n    return count ;\nif __name__ == \"__main__\" :\n    arr = [ 2 , 3 , 4 , 5 , 6 ] ;\n    n = len ( arr ) ;\n    print ( countOperations ( arr , n ) ) ;\n", "python_code_tokenized": "def countOperations ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] += 1 ; NEW_LINE arr [ i + 1 ] += 1 ; NEW_LINE count += 2 ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countOperations ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_227_B", "sol": 0, "python_code": "index = [ 0 ] * 100001\nn = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nfor i in range ( n ) :\n    index [ a [ i ] ] = i + 1\nm = int ( input ( ) )\nb = list ( map ( int , input ( ).split ( ) ) )\nvasya = petya = 0\nfor i in range ( m ) :\n    vasya += index [ b [ i ] ]\n    petya += ( n + 1 - index [ b [ i ] ] )\nprint ( vasya , petya )\n", "python_code_tokenized": "index = [ 0 ] * 100001 NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT index [ a [ i ] ] = i + 1 NEW_LINE DEDENT m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE vasya = petya = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT vasya += index [ b [ i ] ] NEW_LINE petya += ( n + 1 - index [ b [ i ] ] ) NEW_LINE DEDENT print ( vasya , petya ) NEW_LINE"}
{"id": "projecteuler_p127_A", "sol": 0, "python_code": "import fractions\ndef compute ( ) :\n    LIMIT = 120000\n    rads = [ 0 ] + [ 1 ] * ( LIMIT - 1 )\n    for i in range ( 2 , len ( rads ) ) :\n        if rads [ i ] == 1 :\n            for j in range ( i , len ( rads ) , i ) :\n                rads [ j ] *= i\n    sortedrads = sorted ( ( rad , n ) for ( n , rad ) in enumerate ( rads ) )\n    sortedrads = sortedrads [ 1 : ]\n    ans = 0\n    for c in range ( 2 , LIMIT ) :\n        for ( rad , a ) in sortedrads :\n            rad *= rads [ c ]\n            if rad >= c :\n                break\n            b = c - a\n            if a < b and rad * rads [ b ] < c and fractions.gcd ( a , b ) == 1 :\n                ans += c\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import fractions NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 120000 NEW_LINE rads = [ 0 ] + [ 1 ] * ( LIMIT - 1 ) NEW_LINE for i in range ( 2 , len ( rads ) ) : NEW_LINE INDENT if rads [ i ] == 1 : NEW_LINE INDENT for j in range ( i , len ( rads ) , i ) : NEW_LINE INDENT rads [ j ] *= i NEW_LINE DEDENT DEDENT DEDENT sortedrads = sorted ( ( rad , n ) for ( n , rad ) in enumerate ( rads ) ) NEW_LINE sortedrads = sortedrads [ 1 : ] NEW_LINE ans = 0 NEW_LINE for c in range ( 2 , LIMIT ) : NEW_LINE INDENT for ( rad , a ) in sortedrads : NEW_LINE INDENT rad *= rads [ c ] NEW_LINE if rad >= c : NEW_LINE INDENT break NEW_LINE DEDENT b = c - a NEW_LINE if a < b and rad * rads [ b ] < c and fractions . gcd ( a , b ) == 1 : NEW_LINE INDENT ans += c NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00460_A", "sol": 0, "python_code": "while True :\n    n , m , s = map ( int , input ( ).split ( ) )\n    if not n :\n        break\n    n2 = n ** 2\n    dpp = [ 0 ] * ( s + 1 )\n    dpp [ 0 ] = 1\n    for i in range ( 1 , n2 + 1 ) :\n        dpn = [ 0 ] * ( s + 1 )\n        for j in range ( i * ( i + 1 ) // 2 , s + 1 ) :\n            dpn [ j ] += dpp [ j - i ] + dpn [ j - i ]\n            if j - m - 1 >= 0 :\n                dpn [ j ] -= dpp [ j - m - 1 ]\n            dpn [ j ] %= 100000\n        dpp = dpn\n    print ( dpp [ s ] )\n", "python_code_tokenized": "while True : NEW_LINE INDENT n , m , s = map ( int , input ( ) . split ( ) ) NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT n2 = n ** 2 NEW_LINE dpp = [ 0 ] * ( s + 1 ) NEW_LINE dpp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n2 + 1 ) : NEW_LINE INDENT dpn = [ 0 ] * ( s + 1 ) NEW_LINE for j in range ( i * ( i + 1 ) // 2 , s + 1 ) : NEW_LINE INDENT dpn [ j ] += dpp [ j - i ] + dpn [ j - i ] NEW_LINE if j - m - 1 >= 0 : NEW_LINE INDENT dpn [ j ] -= dpp [ j - m - 1 ] NEW_LINE DEDENT dpn [ j ] %= 100000 NEW_LINE DEDENT dpp = dpn NEW_LINE DEDENT print ( dpp [ s ] ) NEW_LINE DEDENT"}
{"id": "aizu_p00435_A", "sol": 0, "python_code": "text = raw_input ( )\npr = ''\nfor i in text :\n    if ord ( i ) - 3 < ord ( 'A' ) :\n        i = chr ( ord ( i ) + ord ( 'Z' ) - ord ( 'A' ) + 1 )\n    pr += chr ( ord ( i ) - 3 )\nprint ( pr )\n", "python_code_tokenized": "text = raw_input ( ) NEW_LINE pr = ' ' NEW_LINE for i in text : NEW_LINE INDENT if ord ( i ) - 3 < ord ( ' A ' ) : NEW_LINE INDENT i = chr ( ord ( i ) + ord ( ' Z ' ) - ord ( ' A ' ) + 1 ) NEW_LINE DEDENT pr += chr ( ord ( i ) - 3 ) NEW_LINE DEDENT print ( pr ) NEW_LINE"}
{"id": "codeforces_1097_A", "sol": 0, "python_code": "n = input ( )\nlst = list ( map ( str , input ( ).split ( ) ) )\nl1 , l2 = [ ] , [ ]\nfor i in range ( len ( lst ) ) :\n    l1.append ( lst [ i ] [ 0 ] )\n    l2.append ( lst [ i ] [ 1 ] )\nif n [ 0 ] in l1 or n [ 1 ] in l2 :\n    print ( 'YES' )\nelse :\n    print ( 'NO' )\n", "python_code_tokenized": "n = input ( ) NEW_LINE lst = list ( map ( str , input ( ) . split ( ) ) ) NEW_LINE l1 , l2 = [ ] , [ ] NEW_LINE for i in range ( len ( lst ) ) : NEW_LINE INDENT l1 . append ( lst [ i ] [ 0 ] ) NEW_LINE l2 . append ( lst [ i ] [ 1 ] ) NEW_LINE DEDENT if n [ 0 ] in l1 or n [ 1 ] in l2 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1423_A", "sol": 0, "python_code": "def totalDigits ( n ) :\n    number_of_digits = 0 ;\n    for i in range ( 1 , n , 10 ) :\n        number_of_digits = ( number_of_digits + ( n - i + 1 ) ) ;\n    return number_of_digits ;\nn = 13 ;\ns = totalDigits ( n ) + 1 ;\nprint ( s ) ;\n", "python_code_tokenized": "def totalDigits ( n ) : NEW_LINE INDENT number_of_digits = 0 ; NEW_LINE for i in range ( 1 , n , 10 ) : NEW_LINE INDENT number_of_digits = ( number_of_digits + ( n - i + 1 ) ) ; NEW_LINE DEDENT return number_of_digits ; NEW_LINE DEDENT n = 13 ; NEW_LINE s = totalDigits ( n ) + 1 ; NEW_LINE print ( s ) ; NEW_LINE"}
{"id": "geeksforgeeks_5255_A", "sol": 0, "python_code": "def record_sum ( record , l , r , n , adder ) :\n    for i in range ( l , r + 1 ) :\n        record [ i ] += adder\nn = 5\nm = 5\narr = [ 0 ] * n\nquery = [ [ 1 , 1 , 2 ] , [ 1 , 4 , 5 ] , [ 2 , 1 , 2 ] , [ 2 , 1 , 3 ] , [ 2 , 3 , 4 ] ]\nrecord = [ 0 ] * m\nfor i in range ( m - 1 , - 1 , - 1 ) :\n    if ( query [ i ] [ 0 ] == 2 ) :\n        record_sum ( record , query [ i ] [ 1 ] - 1 , query [ i ] [ 2 ] - 1 , m , record [ i ] + 1 )\n    else :\n        record_sum ( record , i , i , m , 1 )\nfor i in range ( m ) :\n    if ( query [ i ] [ 0 ] == 1 ) :\n        record_sum ( arr , query [ i ] [ 1 ] - 1 , query [ i ] [ 2 ] - 1 , n , record [ i ] )\nfor i in range ( n ) :\n    print ( arr [ i ] , end = ' ' )\n", "python_code_tokenized": "def record_sum ( record , l , r , n , adder ) : NEW_LINE INDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT record [ i ] += adder NEW_LINE DEDENT DEDENT n = 5 NEW_LINE m = 5 NEW_LINE arr = [ 0 ] * n NEW_LINE query = [ [ 1 , 1 , 2 ] , [ 1 , 4 , 5 ] , [ 2 , 1 , 2 ] , [ 2 , 1 , 3 ] , [ 2 , 3 , 4 ] ] NEW_LINE record = [ 0 ] * m NEW_LINE for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( query [ i ] [ 0 ] == 2 ) : NEW_LINE INDENT record_sum ( record , query [ i ] [ 1 ] - 1 , query [ i ] [ 2 ] - 1 , m , record [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT record_sum ( record , i , i , m , 1 ) NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( query [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT record_sum ( arr , query [ i ] [ 1 ] - 1 , query [ i ] [ 2 ] - 1 , n , record [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' \u2581 ' ) NEW_LINE DEDENT"}
{"id": "leetcode_766_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def isToeplitzMatrix ( self , matrix ) :\n        for r in range ( len ( matrix ) - 1 ) :\n            for c in range ( len ( matrix [ 0 ] ) - 1 ) :\n                if matrix [ r ] [ c ] != matrix [ r + 1 ] [ c + 1 ] :\n                    return False\n        return True\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def isToeplitzMatrix ( self , matrix ) : NEW_LINE INDENT for r in range ( len ( matrix ) - 1 ) : NEW_LINE INDENT for c in range ( len ( matrix [ 0 ] ) - 1 ) : NEW_LINE INDENT if matrix [ r ] [ c ] != matrix [ r + 1 ] [ c + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00936_A", "sol": 0, "python_code": "def solve ( ) :\n    N = int ( input ( ) )\n    c = [ int ( i ) for i in input ( ).split ( ) ]\n    if N == 1 :\n        return c [ 0 ] * 2\n    r = c [ 0 ] * 2\n    x = [ c [ 0 ] ]\n    for i in range ( 1 , N ) :\n        r_ = c [ i ]\n        r_n = r_\n        for j in range ( i ) :\n            b = c [ j ]\n            x_ = x [ j ]\n            dt = 2 * ( ( r_ * b ) ** ( 1 / 2 ) )\n            x_ += dt\n            r_n = max ( r_n , x_ )\n        x.append ( r_n )\n        if r < r_n + r_ :\n            r = r_n + r_\n    return r\nprint ( solve ( ) )\n", "python_code_tokenized": "def solve ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE c = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if N == 1 : NEW_LINE INDENT return c [ 0 ] * 2 NEW_LINE DEDENT r = c [ 0 ] * 2 NEW_LINE x = [ c [ 0 ] ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT r_ = c [ i ] NEW_LINE r_n = r_ NEW_LINE for j in range ( i ) : NEW_LINE INDENT b = c [ j ] NEW_LINE x_ = x [ j ] NEW_LINE dt = 2 * ( ( r_ * b ) ** ( 1 / 2 ) ) NEW_LINE x_ += dt NEW_LINE r_n = max ( r_n , x_ ) NEW_LINE DEDENT x . append ( r_n ) NEW_LINE if r < r_n + r_ : NEW_LINE INDENT r = r_n + r_ NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT print ( solve ( ) ) NEW_LINE"}
{"id": "geeksforgeeks_3523_A", "sol": 0, "python_code": "import numpy as np\narrSize = 51\nmaxSum = 201\nMAX = 100\ninf = 999999\ndp = np.zeros ( ( arrSize , maxSum ) ) ;\nvisit = np.zeros ( ( arrSize , maxSum ) ) ;\ndef RetClose ( a , b , s ) :\n    if ( abs ( a - s ) < abs ( b - s ) ) :\n        return a ;\n    else :\n        return b ;\ndef MinDiff ( i , sum , arr , n ) :\n    if ( i == n ) :\n        return 0 ;\n    if ( visit [ i ] [ sum + MAX ] ) :\n        return dp [ i ] [ sum + MAX ] ;\n    visit [ i ] [ sum + MAX ] = 1 ;\n    dp [ i ] [ sum + MAX ] = RetClose ( arr [ i ] + MinDiff ( i + 1 , sum + arr [ i ] , arr , n ) , MinDiff ( i + 1 , sum , arr , n ) , - 1 * sum ) ;\n    return dp [ i ] [ sum + MAX ] ;\ndef FindClose ( arr , n ) :\n    ans = inf ;\n    for i in range ( 1 , n + 1 ) :\n        ans = RetClose ( arr [ i - 1 ] + MinDiff ( i , arr [ i - 1 ] , arr , n ) , ans , 0 ) ;\n    print ( ans ) ;\nif __name__ == \"__main__\" :\n    arr = [ 25 , - 9 , - 10 , - 4 , - 7 , - 33 ] ;\n    n = len ( arr ) ;\n    FindClose ( arr , n ) ;\n", "python_code_tokenized": "import numpy as np NEW_LINE arrSize = 51 NEW_LINE maxSum = 201 NEW_LINE MAX = 100 NEW_LINE inf = 999999 NEW_LINE dp = np . zeros ( ( arrSize , maxSum ) ) ; NEW_LINE visit = np . zeros ( ( arrSize , maxSum ) ) ; NEW_LINE def RetClose ( a , b , s ) : NEW_LINE INDENT if ( abs ( a - s ) < abs ( b - s ) ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return b ; NEW_LINE DEDENT DEDENT def MinDiff ( i , sum , arr , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( visit [ i ] [ sum + MAX ] ) : NEW_LINE INDENT return dp [ i ] [ sum + MAX ] ; NEW_LINE DEDENT visit [ i ] [ sum + MAX ] = 1 ; NEW_LINE dp [ i ] [ sum + MAX ] = RetClose ( arr [ i ] + MinDiff ( i + 1 , sum + arr [ i ] , arr , n ) , MinDiff ( i + 1 , sum , arr , n ) , - 1 * sum ) ; NEW_LINE return dp [ i ] [ sum + MAX ] ; NEW_LINE DEDENT def FindClose ( arr , n ) : NEW_LINE INDENT ans = inf ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = RetClose ( arr [ i - 1 ] + MinDiff ( i , arr [ i - 1 ] , arr , n ) , ans , 0 ) ; NEW_LINE DEDENT print ( ans ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 25 , - 9 , - 10 , - 4 , - 7 , - 33 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE FindClose ( arr , n ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1221_B", "sol": 0, "python_code": "n = int ( input ( ) )\nfor i in range ( n ) :\n    print ( ''.join ( [ 'W' if ( i + j ) % 2 == 0 else 'B' for j in range ( n ) ] ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( ' ' . join ( [ ' W ' if ( i + j ) % 2 == 0 else ' B ' for j in range ( n ) ] ) ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC017_B", "sol": 0, "python_code": "def main ( ) :\n    N , A , B , C , D = map ( int , input ( ).split ( ) )\n    diff = B - A\n    for i in range ( N - 1 ) :\n        if - D * i + C * ( N - 1 - i ) <= diff <= - C * i + D * ( N - 1 - i ) :\n            print ( \"YES\" )\n            return\n    print ( \"NO\" )\nif __name__ == \"__main__\" :\n    main ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT N , A , B , C , D = map ( int , input ( ) . split ( ) ) NEW_LINE diff = B - A NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if - D * i + C * ( N - 1 - i ) <= diff <= - C * i + D * ( N - 1 - i ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" NO \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4610_A", "sol": 0, "python_code": "def printParenthesis ( str , n ) :\n    if ( n > 0 ) :\n        _printParenthesis ( str , 0 , n , 0 , 0 ) ;\n    return ;\ndef _printParenthesis ( str , pos , n , open , close ) :\n    if ( close == n ) :\n        for i in str :\n            print ( i , end = \"\" ) ;\n        print ( ) ;\n        return ;\n    else :\n        if ( open > close ) :\n            str [ pos ] = '}' ;\n            _printParenthesis ( str , pos + 1 , n , open , close + 1 ) ;\n        if ( open < n ) :\n            str [ pos ] = '{' ;\n            _printParenthesis ( str , pos + 1 , n , open + 1 , close ) ;\nn = 3 ;\nstr = [ \"\" ] * 2 * n ;\nprintParenthesis ( str , n ) ;\n", "python_code_tokenized": "def printParenthesis ( str , n ) : NEW_LINE INDENT if ( n > 0 ) : NEW_LINE INDENT _printParenthesis ( str , 0 , n , 0 , 0 ) ; NEW_LINE DEDENT return ; NEW_LINE DEDENT def _printParenthesis ( str , pos , n , open , close ) : NEW_LINE INDENT if ( close == n ) : NEW_LINE INDENT for i in str : NEW_LINE INDENT print ( i , end = \" \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE return ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( open > close ) : NEW_LINE INDENT str [ pos ] = ' } ' ; NEW_LINE _printParenthesis ( str , pos + 1 , n , open , close + 1 ) ; NEW_LINE DEDENT if ( open < n ) : NEW_LINE INDENT str [ pos ] = ' { ' ; NEW_LINE _printParenthesis ( str , pos + 1 , n , open + 1 , close ) ; NEW_LINE DEDENT DEDENT DEDENT n = 3 ; NEW_LINE str = [ \" \" ] * 2 * n ; NEW_LINE printParenthesis ( str , n ) ; NEW_LINE"}
{"id": "aizu_p00127_A", "sol": 0, "python_code": "a = [ '' ] * 100\na [ 11 ] , a [ 12 ] , a [ 13 ] , a [ 14 ] , a [ 15 ] = 'a' , 'b' , 'c' , 'd' , 'e'\na [ 21 ] , a [ 22 ] , a [ 23 ] , a [ 24 ] , a [ 25 ] = 'f' , 'g' , 'h' , 'i' , 'j'\na [ 31 ] , a [ 32 ] , a [ 33 ] , a [ 34 ] , a [ 35 ] = 'k' , 'l' , 'm' , 'n' , 'o'\na [ 41 ] , a [ 42 ] , a [ 43 ] , a [ 44 ] , a [ 45 ] = 'p' , 'q' , 'r' , 's' , 't'\na [ 51 ] , a [ 52 ] , a [ 53 ] , a [ 54 ] , a [ 55 ] = 'u' , 'v' , 'w' , 'x' , 'y'\na [ 61 ] , a [ 62 ] , a [ 63 ] , a [ 64 ] , a [ 65 ] = 'z' , '.' , '?' , '!' , ''\nwhile True :\n    try : buf = list ( input ( ) )\n    except : break\n    f = True\n    ans = ''\n    for i in range ( 0 , len ( buf ) , 2 ) :\n        if i + 1 >= len ( buf ) :\n            f = False\n            break\n        if buf [ i ].isdigit ( ) and buf [ i + 1 ].isdigit ( ) :\n            k = int ( buf [ i ] + buf [ i + 1 ] )\n            if a [ k ] != '' : ans += a [ k ]\n            else :\n                f = False\n                break\n    print ( ans if f else \"NA\" )\n", "python_code_tokenized": "a = [ ' ' ] * 100 NEW_LINE a [ 11 ] , a [ 12 ] , a [ 13 ] , a [ 14 ] , a [ 15 ] = ' a ' , ' b ' , ' c ' , ' d ' , ' e ' NEW_LINE a [ 21 ] , a [ 22 ] , a [ 23 ] , a [ 24 ] , a [ 25 ] = ' f ' , ' g ' , ' h ' , ' i ' , ' j ' NEW_LINE a [ 31 ] , a [ 32 ] , a [ 33 ] , a [ 34 ] , a [ 35 ] = ' k ' , ' l ' , ' m ' , ' n ' , ' o ' NEW_LINE a [ 41 ] , a [ 42 ] , a [ 43 ] , a [ 44 ] , a [ 45 ] = ' p ' , ' q ' , ' r ' , ' s ' , ' t ' NEW_LINE a [ 51 ] , a [ 52 ] , a [ 53 ] , a [ 54 ] , a [ 55 ] = ' u ' , ' v ' , ' w ' , ' x ' , ' y ' NEW_LINE a [ 61 ] , a [ 62 ] , a [ 63 ] , a [ 64 ] , a [ 65 ] = ' z ' , ' . ' , ' ? ' , ' ! ' , ' \u2581 ' NEW_LINE while True : NEW_LINE INDENT try : buf = list ( input ( ) ) NEW_LINE except : break NEW_LINE f = True NEW_LINE ans = ' ' NEW_LINE for i in range ( 0 , len ( buf ) , 2 ) : NEW_LINE INDENT if i + 1 >= len ( buf ) : NEW_LINE INDENT f = False NEW_LINE break NEW_LINE DEDENT if buf [ i ] . isdigit ( ) and buf [ i + 1 ] . isdigit ( ) : NEW_LINE INDENT k = int ( buf [ i ] + buf [ i + 1 ] ) NEW_LINE if a [ k ] != ' ' : ans += a [ k ] NEW_LINE else : NEW_LINE INDENT f = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( ans if f else \" NA \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4628_A", "sol": 0, "python_code": "def seriesSum ( calculated , current , N ) :\n    i = calculated ;\n    cur = 1 ;\n    if ( current == N + 1 ) :\n        return 0 ;\n    while ( i < calculated + current ) :\n        cur *= i ;\n        i += 1 ;\n    return cur + seriesSum ( i , current + 1 , N ) ;\nN = 5 ;\nprint ( seriesSum ( 1 , 1 , N ) ) ;\n", "python_code_tokenized": "def seriesSum ( calculated , current , N ) : NEW_LINE INDENT i = calculated ; NEW_LINE cur = 1 ; NEW_LINE if ( current == N + 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( i < calculated + current ) : NEW_LINE INDENT cur *= i ; NEW_LINE i += 1 ; NEW_LINE DEDENT return cur + seriesSum ( i , current + 1 , N ) ; NEW_LINE DEDENT N = 5 ; NEW_LINE print ( seriesSum ( 1 , 1 , N ) ) ; NEW_LINE"}
{"id": "codeforces_711_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = 0\nr , c = 0 , - 1\ndl = [ ]\nfor i in range ( n ) :\n    tl = list ( map ( int , input ( ).split ( ) ) )\n    if c < 0 and tl.count ( 0 ) :\n        r = i\n        c = tl.index ( 0 )\n    dl += [ tl ]\ns = sum ( dl [ ( r + 1 ) % n ] )\na = s - sum ( dl [ r ] )\ndl [ r ] [ c ] = a\nif n > 1 and a < 1 :\n    print ( - 1 )\n    exit ( )\nfor i in range ( n ) :\n    if s != sum ( dl [ i ] ) :\n        print ( - 1 )\n        exit ( )\ndl = list ( map ( list , zip ( * dl ) ) )\nfor i in range ( n ) :\n    if s != sum ( dl [ i ] ) :\n        print ( - 1 )\n        exit ( )\ns1 = s2 = 0\nfor i in range ( n ) :\n    s1 += dl [ i ] [ i ]\n    s2 += dl [ i ] [ n - i - 1 ]\nif not ( s1 == s2 == s ) :\n    print ( - 1 )\n    exit ( )\nif n == 1 :\n    a = 1\nprint ( a )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = 0 NEW_LINE r , c = 0 , - 1 NEW_LINE dl = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT tl = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if c < 0 and tl . count ( 0 ) : NEW_LINE INDENT r = i NEW_LINE c = tl . index ( 0 ) NEW_LINE DEDENT dl += [ tl ] NEW_LINE DEDENT s = sum ( dl [ ( r + 1 ) % n ] ) NEW_LINE a = s - sum ( dl [ r ] ) NEW_LINE dl [ r ] [ c ] = a NEW_LINE if n > 1 and a < 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if s != sum ( dl [ i ] ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT dl = list ( map ( list , zip ( * dl ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s != sum ( dl [ i ] ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT s1 = s2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s1 += dl [ i ] [ i ] NEW_LINE s2 += dl [ i ] [ n - i - 1 ] NEW_LINE DEDENT if not ( s1 == s2 == s ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT a = 1 NEW_LINE DEDENT print ( a ) NEW_LINE"}
{"id": "geeksforgeeks_2112_A", "sol": 0, "python_code": "def has0 ( x ) :\n    while ( x != 0 ) :\n        if ( x % 10 == 0 ) :\n            return 1\n        x = x // 10\n    return 0\ndef getCount ( n ) :\n    count = 0\n    for i in range ( 1 , n + 1 ) :\n        count = count + has0 ( i )\n    return count\nn = 107\nprint ( \"Count of numbers from 1\" , \" to \" , n , \" is \" , getCount ( n ) )\n", "python_code_tokenized": "def has0 ( x ) : NEW_LINE INDENT while ( x != 0 ) : NEW_LINE INDENT if ( x % 10 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def getCount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count = count + has0 ( i ) NEW_LINE DEDENT return count NEW_LINE DEDENT n = 107 NEW_LINE print ( \" Count \u2581 of \u2581 numbers \u2581 from \u2581 1\" , \" \u2581 to \u2581 \" , n , \" \u2581 is \u2581 \" , getCount ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3721_A", "sol": 0, "python_code": "def indexOfFirstOne ( arr , low , high ) :\n    while ( low <= high ) :\n        mid = int ( ( low + high ) / 2 )\n        if ( arr [ mid ] == 1 and ( mid == 0 or arr [ mid - 1 ] == 0 ) ) :\n            return mid\n        elif ( arr [ mid ] == 1 ) :\n            high = mid - 1\n        else :\n            low = mid + 1\n    return - 1 ;\narr = [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ]\nn = len ( arr )\nans = indexOfFirstOne ( arr , 0 , n - 1 )\nprint ( ans )\n", "python_code_tokenized": "def indexOfFirstOne ( arr , low , high ) : NEW_LINE INDENT while ( low <= high ) : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( arr [ mid ] == 1 and ( mid == 0 or arr [ mid - 1 ] == 0 ) ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( arr [ mid ] == 1 ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT arr = [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE ans = indexOfFirstOne ( arr , 0 , n - 1 ) NEW_LINE print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_920_A", "sol": 0, "python_code": "def kthdigit ( a , b , k ) :\n    p = a ** b\n    count = 0\n    while ( p > 0 and count < k ) :\n        rem = p % 10\n        count = count + 1\n        if ( count == k ) :\n            return rem\n        p = p / 10 ;\na = 5\nb = 2\nk = 1\nans = kthdigit ( a , b , k )\nprint ( ans )\n", "python_code_tokenized": "def kthdigit ( a , b , k ) : NEW_LINE INDENT p = a ** b NEW_LINE count = 0 NEW_LINE while ( p > 0 and count < k ) : NEW_LINE INDENT rem = p % 10 NEW_LINE count = count + 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT return rem NEW_LINE DEDENT p = p / 10 ; NEW_LINE DEDENT DEDENT a = 5 NEW_LINE b = 2 NEW_LINE k = 1 NEW_LINE ans = kthdigit ( a , b , k ) NEW_LINE print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_581_A", "sol": 0, "python_code": "if name == '__main__' :\n    for first in range ( 1 , 6 ) :\n        for second in range ( 1 , 6 ) :\n            print ( 5 * first + second - 5 )\n", "python_code_tokenized": "if name == ' _ _ main _ _ ' : NEW_LINE INDENT for first in range ( 1 , 6 ) : NEW_LINE INDENT for second in range ( 1 , 6 ) : NEW_LINE INDENT print ( 5 * first + second - 5 ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_1922_A", "sol": 0, "python_code": "def getRemainder ( num , divisor ) :\n    return ( num - divisor * ( num // divisor ) )\nnum = 100\ndivisor = 7\nprint ( getRemainder ( num , divisor ) )\n", "python_code_tokenized": "def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num // divisor ) ) NEW_LINE DEDENT num = 100 NEW_LINE divisor = 7 NEW_LINE print ( getRemainder ( num , divisor ) ) NEW_LINE"}
{"id": "aizu_p02267_A", "sol": 0, "python_code": "def linear_search ( A , key ) :\n    N = len ( A )\n    A [ N - 1 ] = key\n    i = 0\n    while A [ i ] != key :\n        i += 1\n    return i != ( N - 1 )\nif __name__ == \"__main__\" :\n    N = int ( input ( ) )\n    num_list = list ( map ( int , input ( ).split ( ) ) )\n    M = int ( input ( ) )\n    target_list = list ( map ( int , input ( ).split ( ) ) )\n    count = 0\n    for target in target_list :\n        if ( linear_search ( num_list , target ) ) :\n            count += 1\n    print ( count )\n", "python_code_tokenized": "def linear_search ( A , key ) : NEW_LINE INDENT N = len ( A ) NEW_LINE A [ N - 1 ] = key NEW_LINE i = 0 NEW_LINE while A [ i ] != key : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return i != ( N - 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE num_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE M = int ( input ( ) ) NEW_LINE target_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE for target in target_list : NEW_LINE INDENT if ( linear_search ( num_list , target ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT"}
{"id": "codeforces_519_A", "sol": 0, "python_code": "lineCounter = 0\nwhiteCounter = 0\nblackCounter = 0\nwhile lineCounter != 8 :\n    line = input ( )\n    lineCounter = lineCounter + 1\n    for i in line :\n        if i == \"Q\" :\n            whiteCounter = whiteCounter + 9\n        elif i == \"R\" :\n            whiteCounter = whiteCounter + 5\n        elif i == \"B\" :\n            whiteCounter = whiteCounter + 3\n        elif i == \"N\" :\n            whiteCounter = whiteCounter + 3\n        elif i == \"P\" :\n            whiteCounter = whiteCounter + 1\n        elif i == \"q\" :\n            blackCounter = blackCounter + 9\n        elif i == \"r\" :\n            blackCounter = blackCounter + 5\n        elif i == \"b\" :\n            blackCounter = blackCounter + 3\n        elif i == \"n\" :\n            blackCounter = blackCounter + 3\n        elif i == \"p\" :\n            blackCounter = blackCounter + 1\nif whiteCounter > blackCounter :\n    print ( \"White\" )\nif blackCounter > whiteCounter :\n    print ( \"Black\" )\nif blackCounter == whiteCounter :\n    print ( \"Draw\" )\n", "python_code_tokenized": "lineCounter = 0 NEW_LINE whiteCounter = 0 NEW_LINE blackCounter = 0 NEW_LINE while lineCounter != 8 : NEW_LINE INDENT line = input ( ) NEW_LINE lineCounter = lineCounter + 1 NEW_LINE for i in line : NEW_LINE INDENT if i == \" Q \" : NEW_LINE INDENT whiteCounter = whiteCounter + 9 NEW_LINE DEDENT elif i == \" R \" : NEW_LINE INDENT whiteCounter = whiteCounter + 5 NEW_LINE DEDENT elif i == \" B \" : NEW_LINE INDENT whiteCounter = whiteCounter + 3 NEW_LINE DEDENT elif i == \" N \" : NEW_LINE INDENT whiteCounter = whiteCounter + 3 NEW_LINE DEDENT elif i == \" P \" : NEW_LINE INDENT whiteCounter = whiteCounter + 1 NEW_LINE DEDENT elif i == \" q \" : NEW_LINE INDENT blackCounter = blackCounter + 9 NEW_LINE DEDENT elif i == \" r \" : NEW_LINE INDENT blackCounter = blackCounter + 5 NEW_LINE DEDENT elif i == \" b \" : NEW_LINE INDENT blackCounter = blackCounter + 3 NEW_LINE DEDENT elif i == \" n \" : NEW_LINE INDENT blackCounter = blackCounter + 3 NEW_LINE DEDENT elif i == \" p \" : NEW_LINE INDENT blackCounter = blackCounter + 1 NEW_LINE DEDENT DEDENT DEDENT if whiteCounter > blackCounter : NEW_LINE INDENT print ( \" White \" ) NEW_LINE DEDENT if blackCounter > whiteCounter : NEW_LINE INDENT print ( \" Black \" ) NEW_LINE DEDENT if blackCounter == whiteCounter : NEW_LINE INDENT print ( \" Draw \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1722_A", "sol": 0, "python_code": "def centered_cube ( n ) :\n    return ( 2 * n + 1 ) * ( n * n + n + 1 )\nif __name__ == '__main__' :\n    n = 3\n    print ( n , \"th Centered cube \" + \"number : \" , centered_cube ( n ) )\n    n = 10\n    print ( n , \"th Centered cube \" + \"number : \" , centered_cube ( n ) )\n", "python_code_tokenized": "def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , \" th \u2581 Centered \u2581 cube \u2581 \" + \" number \u2581 : \u2581 \" , centered_cube ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , \" th \u2581 Centered \u2581 cube \u2581 \" + \" number \u2581 : \u2581 \" , centered_cube ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2408_A", "sol": 0, "python_code": "def permutation ( arr , n ) :\n    s = set ( )\n    maxEle = 0 ;\n    for i in range ( n ) :\n        s.add ( arr [ i ] ) ;\n        maxEle = max ( maxEle , arr [ i ] ) ;\n    if ( maxEle != n ) :\n        return False\n    if ( len ( s ) == n ) :\n        return True ;\n    return False ;\nif __name__ == '__main__' :\n    arr = [ 1 , 2 , 5 , 3 , 2 ]\n    n = len ( arr )\n    if ( permutation ( arr , n ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def permutation ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE maxEle = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) ; NEW_LINE maxEle = max ( maxEle , arr [ i ] ) ; NEW_LINE DEDENT if ( maxEle != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( s ) == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( permutation ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_53_A", "sol": 0, "python_code": "a = input ( )\nb = [ ]\nfor i in range ( int ( input ( ) ) ) :\n    b.append ( input ( ) )\nb = sorted ( b )\nfor j in range ( len ( b ) ) :\n    if b [ j ] [ 0 : len ( a ) ] == a :\n        print ( b [ j ] )\n        break\nelse :\n    print ( a )\n", "python_code_tokenized": "a = input ( ) NEW_LINE b = [ ] NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT b . append ( input ( ) ) NEW_LINE DEDENT b = sorted ( b ) NEW_LINE for j in range ( len ( b ) ) : NEW_LINE INDENT if b [ j ] [ 0 : len ( a ) ] == a : NEW_LINE INDENT print ( b [ j ] ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT"}
{"id": "codeforces_1236_B", "sol": 0, "python_code": "s = input ( ).split ( )\nn = int ( s [ 0 ] )\nm = int ( s [ 1 ] )\nmod = 10 ** 9 + 7\nprint ( pow ( ( pow ( 2 , m , mod ) - 1 ) , n , mod ) )\n", "python_code_tokenized": "s = input ( ) . split ( ) NEW_LINE n = int ( s [ 0 ] ) NEW_LINE m = int ( s [ 1 ] ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE print ( pow ( ( pow ( 2 , m , mod ) - 1 ) , n , mod ) ) NEW_LINE"}
{"id": "codeforces_20_B", "sol": 0, "python_code": "a , b , c = [ int ( x ) for x in input ( ).split ( ) ]\nif a == 0 and b == 0 :\n    if c == 0 :\n        print ( - 1 )\n    else :\n        print ( 0 )\nelif a == 0 :\n    print ( 1 )\n    print ( \"{0:.5f}\".format ( - c / b ) )\nelse :\n    root1 = ( - b + ( b ** 2 - 4 * a * c ) ** 0.5 ) / ( 2 * a )\n    root2 = ( - b - ( b ** 2 - 4 * a * c ) ** 0.5 ) / ( 2 * a )\n    if root1 == root2 :\n        print ( 1 )\n        print ( \"{0:.5f}\".format ( root1 ) )\n    elif type ( root1 ) == complex and type ( root2 ) == complex :\n        print ( 0 )\n    elif type ( root1 ) == complex :\n        print ( 1 )\n        print ( \"{0:.5f}\".format ( root2 ) )\n    elif type ( root2 ) == complex :\n        print ( 1 )\n        print ( \"{0:.5f}\".format ( root1 ) )\n    elif root1 > root2 :\n        print ( 2 )\n        print ( \"{0:.5f}\".format ( root2 ) )\n        print ( \"{0:.5f}\".format ( root1 ) )\n    else :\n        print ( 2 )\n        print ( \"{0:.5f}\".format ( root1 ) )\n        print ( \"{0:.5f}\".format ( root2 ) )\n", "python_code_tokenized": "a , b , c = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT if c == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT elif a == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( \" { 0 : . 5f } \" . format ( - c / b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT root1 = ( - b + ( b ** 2 - 4 * a * c ) ** 0.5 ) / ( 2 * a ) NEW_LINE root2 = ( - b - ( b ** 2 - 4 * a * c ) ** 0.5 ) / ( 2 * a ) NEW_LINE if root1 == root2 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( \" { 0 : . 5f } \" . format ( root1 ) ) NEW_LINE DEDENT elif type ( root1 ) == complex and type ( root2 ) == complex : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif type ( root1 ) == complex : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( \" { 0 : . 5f } \" . format ( root2 ) ) NEW_LINE DEDENT elif type ( root2 ) == complex : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( \" { 0 : . 5f } \" . format ( root1 ) ) NEW_LINE DEDENT elif root1 > root2 : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( \" { 0 : . 5f } \" . format ( root2 ) ) NEW_LINE print ( \" { 0 : . 5f } \" . format ( root1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( \" { 0 : . 5f } \" . format ( root1 ) ) NEW_LINE print ( \" { 0 : . 5f } \" . format ( root2 ) ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_123_B", "sol": 0, "python_code": "from math import ceil\na , b , x1 , y1 , x2 , y2 = map ( int , input ( ).split ( ) )\na1 = ( x1 + y1 ) // ( 2 * a )\na2 = ( x2 + y2 ) // ( 2 * a )\nb1 = ( x1 - y1 ) // ( 2 * b )\nb2 = ( x2 - y2 ) // ( 2 * b )\nprint ( max ( abs ( a1 - a2 ) , abs ( b1 - b2 ) ) )\n", "python_code_tokenized": "from math import ceil NEW_LINE a , b , x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE a1 = ( x1 + y1 ) // ( 2 * a ) NEW_LINE a2 = ( x2 + y2 ) // ( 2 * a ) NEW_LINE b1 = ( x1 - y1 ) // ( 2 * b ) NEW_LINE b2 = ( x2 - y2 ) // ( 2 * b ) NEW_LINE print ( max ( abs ( a1 - a2 ) , abs ( b1 - b2 ) ) ) NEW_LINE"}
{"id": "codeforces_583_B", "sol": 0, "python_code": "n = int ( input ( ) )\narr = list ( map ( int , input ( ).split ( ) ) )\nans = - 1\ntemp = 0\nseen = set ( )\np = 0\nwhile len ( seen ) != n :\n    ans += 1\n    if p % 2 == 0 :\n        for i in range ( n ) :\n            if i not in seen and arr [ i ] <= temp :\n                seen.add ( i )\n                temp += 1\n        p += 1\n    else :\n        for i in range ( n - 1 , - 1 , - 1 ) :\n            if i not in seen and arr [ i ] <= temp :\n                seen.add ( i )\n                temp += 1\n        p += 1\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = - 1 NEW_LINE temp = 0 NEW_LINE seen = set ( ) NEW_LINE p = 0 NEW_LINE while len ( seen ) != n : NEW_LINE INDENT ans += 1 NEW_LINE if p % 2 == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if i not in seen and arr [ i ] <= temp : NEW_LINE INDENT seen . add ( i ) NEW_LINE temp += 1 NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if i not in seen and arr [ i ] <= temp : NEW_LINE INDENT seen . add ( i ) NEW_LINE temp += 1 NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "atcoder_AGC032_B", "sol": 0, "python_code": "N = int ( input ( ) )\nn = N // 2\nS = N + ( N % 2 == 0 )\ngroups = [ [ i , S - i ] for i in range ( 1 , n + 1 ) ]\nif N % 2 == 1 :\n    groups.append ( [ S ] )\nans = [ ]\nfrom itertools import *\nfor g1 , g2 in combinations ( groups , 2 ) :\n    for s , t in product ( g1 , g2 ) :\n        ans.append ( ( s , t ) )\nprint ( len ( ans ) )\nfor s , t in ans :\n    print ( s , t )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE n = N // 2 NEW_LINE S = N + ( N % 2 == 0 ) NEW_LINE groups = [ [ i , S - i ] for i in range ( 1 , n + 1 ) ] NEW_LINE if N % 2 == 1 : NEW_LINE INDENT groups . append ( [ S ] ) NEW_LINE DEDENT ans = [ ] NEW_LINE from itertools import * NEW_LINE for g1 , g2 in combinations ( groups , 2 ) : NEW_LINE INDENT for s , t in product ( g1 , g2 ) : NEW_LINE INDENT ans . append ( ( s , t ) ) NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE for s , t in ans : NEW_LINE INDENT print ( s , t ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC150_A", "sol": 0, "python_code": "k , x = map ( int , input ( ).split ( ) )\nif k * 500 >= x :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "k , x = map ( int , input ( ) . split ( ) ) NEW_LINE if k * 500 >= x : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_646_A", "sol": 0, "python_code": "def findMinRemoval ( arr , n ) :\n    value = 0\n    maximum = 0\n    if ( n == 1 ) :\n        return 0\n    for i in range ( n ) :\n        if ( i != 0 and i != n - 1 ) :\n            value = value + abs ( arr [ i ] - arr [ i + 1 ] )\n            temp = ( abs ( arr [ i ] - arr [ i + 1 ] ) + abs ( arr [ i ] - arr [ i - 1 ] ) - abs ( arr [ i - 1 ] - arr [ i + 1 ] ) )\n        elif ( i == 0 ) :\n            value = value + abs ( arr [ i ] - arr [ i + 1 ] )\n            temp = abs ( arr [ i ] - arr [ i + 1 ] )\n        else :\n            temp = abs ( arr [ i ] - arr [ i - 1 ] )\n        maximum = max ( maximum , temp )\n    return ( value - maximum )\nif __name__ == \"__main__\" :\n    arr = [ 1 , 5 , 3 , 2 , 10 ]\n    n = len ( arr )\n    print ( findMinRemoval ( arr , n ) )\n", "python_code_tokenized": "def findMinRemoval ( arr , n ) : NEW_LINE INDENT value = 0 NEW_LINE maximum = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i != 0 and i != n - 1 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = ( abs ( arr [ i ] - arr [ i + 1 ] ) + abs ( arr [ i ] - arr [ i - 1 ] ) - abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ) NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT maximum = max ( maximum , temp ) NEW_LINE DEDENT return ( value - maximum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 2 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinRemoval ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2073_A", "sol": 0, "python_code": "import random\ndef power ( x , y , p ) :\n    res = 1 ;\n    x = x % p ;\n    while ( y > 0 ) :\n        if ( y & 1 ) :\n            res = ( res * x ) % p ;\n        y = y >> 1 ;\n        x = ( x * x ) % p ;\n    return res ;\ndef miillerTest ( d , n ) :\n    a = 2 + random.randint ( 1 , n - 4 ) ;\n    x = power ( a , d , n ) ;\n    if ( x == 1 or x == n - 1 ) :\n        return True ;\n    while ( d != n - 1 ) :\n        x = ( x * x ) % n ;\n        d *= 2 ;\n        if ( x == 1 ) :\n            return False ;\n        if ( x == n - 1 ) :\n            return True ;\n    return False ;\ndef isPrime ( n , k ) :\n    if ( n <= 1 or n == 4 ) :\n        return False ;\n    if ( n <= 3 ) :\n        return True ;\n    d = n - 1 ;\n    while ( d % 2 == 0 ) :\n        d //= 2 ;\n    for i in range ( k ) :\n        if ( miillerTest ( d , n ) == False ) :\n            return False ;\n    return True ;\nk = 4 ;\nprint ( \"All primes smaller than 100: \" ) ;\nfor n in range ( 1 , 100 ) :\n    if ( isPrime ( n , k ) ) :\n        print ( n , end = \" \" ) ;\n", "python_code_tokenized": "import random NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT y = y >> 1 ; NEW_LINE x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def miillerTest ( d , n ) : NEW_LINE INDENT a = 2 + random . randint ( 1 , n - 4 ) ; NEW_LINE x = power ( a , d , n ) ; NEW_LINE if ( x == 1 or x == n - 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT while ( d != n - 1 ) : NEW_LINE INDENT x = ( x * x ) % n ; NEW_LINE d *= 2 ; NEW_LINE if ( x == 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT def isPrime ( n , k ) : NEW_LINE INDENT if ( n <= 1 or n == 4 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT d = n - 1 ; NEW_LINE while ( d % 2 == 0 ) : NEW_LINE INDENT d //= 2 ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT if ( miillerTest ( d , n ) == False ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT k = 4 ; NEW_LINE print ( \" All \u2581 primes \u2581 smaller \u2581 than \u2581 100 : \u2581 \" ) ; NEW_LINE for n in range ( 1 , 100 ) : NEW_LINE INDENT if ( isPrime ( n , k ) ) : NEW_LINE INDENT print ( n , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC106_B", "sol": 0, "python_code": "N = int ( input ( ) )\nans = 0\nfor i in range ( 1 , N + 1 , 2 ) :\n    cnt = 0\n    for j in range ( 1 , i + 1 ) :\n        if i % j == 0 :\n            cnt += 1\n    if cnt == 8 :\n        ans += 1\nprint ( ans )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , N + 1 , 2 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt == 8 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_742_A", "sol": 0, "python_code": "n = int ( input ( ) )\ns = pow ( 8 , n , 10 )\nprint ( s )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = pow ( 8 , n , 10 ) NEW_LINE print ( s ) NEW_LINE"}
{"id": "codeforces_90_A", "sol": 0, "python_code": "arr = list ( map ( int , input ( ).split ( ) ) )\ncounter = 0\ntime = 29\nwhile arr [ 0 ] > 0 or arr [ 1 ] > 0 or arr [ 2 ] > 0 :\n    index = counter % 3\n    if arr [ index ] > 1 :\n        arr [ index ] -= 2\n    elif arr [ index ] == 1 :\n        arr [ index ] -= 1\n    counter += 1\n    time += 1\nprint ( time )\n", "python_code_tokenized": "arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE counter = 0 NEW_LINE time = 29 NEW_LINE while arr [ 0 ] > 0 or arr [ 1 ] > 0 or arr [ 2 ] > 0 : NEW_LINE INDENT index = counter % 3 NEW_LINE if arr [ index ] > 1 : NEW_LINE INDENT arr [ index ] -= 2 NEW_LINE DEDENT elif arr [ index ] == 1 : NEW_LINE INDENT arr [ index ] -= 1 NEW_LINE DEDENT counter += 1 NEW_LINE time += 1 NEW_LINE DEDENT print ( time ) NEW_LINE"}
{"id": "geeksforgeeks_2479_A", "sol": 0, "python_code": "class Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.next = next\nhead = None\ndef push ( head_ref , new_data ) :\n    global head\n    new_node = Node ( 0 )\n    new_node.data = new_data\n    new_node.next = ( head_ref )\n    ( head_ref ) = new_node\n    head = head_ref\ndef productOfLastN_NodesUtil ( head , n ) :\n    if ( n <= 0 ) :\n        return 0\n    st = [ ]\n    prod = 1\n    while ( head != None ) :\n        st.append ( head.data )\n        head = head.next\n    while ( n > 0 ) :\n        n = n - 1\n        prod *= st [ - 1 ]\n        st.pop ( )\n    return prod\nhead = None\npush ( head , 12 )\npush ( head , 4 )\npush ( head , 8 )\npush ( head , 6 )\npush ( head , 10 )\nn = 2\nprint ( productOfLastN_NodesUtil ( head , n ) )\n", "python_code_tokenized": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = next NEW_LINE DEDENT DEDENT head = None NEW_LINE def push ( head_ref , new_data ) : NEW_LINE INDENT global head NEW_LINE new_node = Node ( 0 ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE head = head_ref NEW_LINE DEDENT def productOfLastN_NodesUtil ( head , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT st = [ ] NEW_LINE prod = 1 NEW_LINE while ( head != None ) : NEW_LINE INDENT st . append ( head . data ) NEW_LINE head = head . next NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT n = n - 1 NEW_LINE prod *= st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE DEDENT return prod NEW_LINE DEDENT head = None NEW_LINE push ( head , 12 ) NEW_LINE push ( head , 4 ) NEW_LINE push ( head , 8 ) NEW_LINE push ( head , 6 ) NEW_LINE push ( head , 10 ) NEW_LINE n = 2 NEW_LINE print ( productOfLastN_NodesUtil ( head , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1229_A", "sol": 0, "python_code": "r = 3\nR = 7\npi = 3.14159\nVolume = ( float ) ( 2 * pi * pi * R * r * r ) ;\nprint ( \"Volume: \" , Volume ) ;\nSurface = ( float ) ( 4 * pi * pi * R * r ) ;\nprint ( \"Surface: \" , Surface ) ;\n", "python_code_tokenized": "r = 3 NEW_LINE R = 7 NEW_LINE pi = 3.14159 NEW_LINE Volume = ( float ) ( 2 * pi * pi * R * r * r ) ; NEW_LINE print ( \" Volume : \u2581 \" , Volume ) ; NEW_LINE Surface = ( float ) ( 4 * pi * pi * R * r ) ; NEW_LINE print ( \" Surface : \u2581 \" , Surface ) ; NEW_LINE"}
{"id": "geeksforgeeks_2200_A", "sol": 0, "python_code": "def findMax ( arr , n ) :\n    res = 0\n    for i in range ( 1 , n ) :\n        count = 0\n        for j in range ( 0 , i ) :\n            if arr [ j ] % arr [ i ] == 0 :\n                count += 1\n        res = max ( count , res )\n    return res\narr = [ 8 , 1 , 28 , 4 , 2 , 6 , 7 ]\nn = len ( arr )\nprint ( findMax ( arr , n ) )\n", "python_code_tokenized": "def findMax ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if arr [ j ] % arr [ i ] == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT res = max ( count , res ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 8 , 1 , 28 , 4 , 2 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMax ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2201_A", "sol": 0, "python_code": "def findMax ( arr , n ) :\n    divisible = [ False ] * n ;\n    res = 0 ;\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        if ( divisible [ i ] ) :\n            continue ;\n        cnt = 0 ;\n        for j in range ( i ) :\n            if ( ( arr [ j ] % arr [ i ] ) == 0 ) :\n                divisible [ j ] = True ;\n                cnt += 1 ;\n        res = max ( res , cnt ) ;\n    return res ;\nif __name__ == \"__main__\" :\n    arr = [ 8 , 1 , 28 , 4 , 2 , 6 , 7 ] ;\n    n = len ( arr ) ;\n    print ( findMax ( arr , n ) ) ;\n", "python_code_tokenized": "def findMax ( arr , n ) : NEW_LINE INDENT divisible = [ False ] * n ; NEW_LINE res = 0 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( divisible [ i ] ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT cnt = 0 ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( ( arr [ j ] % arr [ i ] ) == 0 ) : NEW_LINE INDENT divisible [ j ] = True ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT DEDENT res = max ( res , cnt ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 1 , 28 , 4 , 2 , 6 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findMax ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3033_A", "sol": 0, "python_code": "def isPossible ( a , n ) :\n    cur = a [ 0 ] ;\n    cur -= 1 ;\n    for i in range ( 1 , n ) :\n        nxt = a [ i ] ;\n        if ( nxt > cur ) :\n            nxt -= 1 ;\n        elif ( nxt < cur ) :\n            return False ;\n        cur = nxt ;\n    return True ;\nif __name__ == \"__main__\" :\n    a = [ 1 , 2 , 1 , 2 , 3 ] ;\n    n = len ( a ) ;\n    if ( isPossible ( a , n ) ) :\n        print ( \"Yes\" ) ;\n    else :\n        print ( \"No\" ) ;\n", "python_code_tokenized": "def isPossible ( a , n ) : NEW_LINE INDENT cur = a [ 0 ] ; NEW_LINE cur -= 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT nxt = a [ i ] ; NEW_LINE if ( nxt > cur ) : NEW_LINE INDENT nxt -= 1 ; NEW_LINE DEDENT elif ( nxt < cur ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT cur = nxt ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 1 , 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( isPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p01052_A", "sol": 0, "python_code": "n = int ( input ( ) )\ntbl = [ ]\nfor i in range ( n ) :\n    a , b = map ( int , input ( ).split ( ) )\n    tbl.append ( [ b , a ] )\ntbl.sort ( )\nans = saw = 0\nseen = [ 0 ] * 101\nfor i in range ( 1 , 32 ) :\n    for j in range ( n ) :\n        if i < tbl [ j ] [ 1 ] or tbl [ j ] [ 0 ] < i : continue\n        if seen [ j ] : continue\n        ans += 100 ; seen [ j ] = 1 ; saw += 1\n        break ;\nprint ( ans + ( 31 - saw ) * 50 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE tbl = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE tbl . append ( [ b , a ] ) NEW_LINE DEDENT tbl . sort ( ) NEW_LINE ans = saw = 0 NEW_LINE seen = [ 0 ] * 101 NEW_LINE for i in range ( 1 , 32 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i < tbl [ j ] [ 1 ] or tbl [ j ] [ 0 ] < i : continue NEW_LINE if seen [ j ] : continue NEW_LINE ans += 100 ; seen [ j ] = 1 ; saw += 1 NEW_LINE break ; NEW_LINE DEDENT DEDENT print ( ans + ( 31 - saw ) * 50 ) NEW_LINE"}
{"id": "codeforces_553_A", "sol": 0, "python_code": "maxn = 1010\nmod = 1000000007\ncomb = [ [ 0 for i in range ( maxn ) ] for i in range ( maxn ) ]\ncomb [ 0 ] [ 0 ] = 1\nfor i in range ( 1 , maxn ) :\n    comb [ i ] [ 0 ] = 1\n    for j in range ( 1 , i + 1 ) :\n        comb [ i ] [ j ] = comb [ i - 1 ] [ j ] + comb [ i - 1 ] [ j - 1 ] % mod\nk = int ( input ( ) )\ncolor = [ int ( input ( ) ) for i in range ( k ) ]\nres = 1\ntotal = 0\nfor i in range ( k ) :\n    res = ( res * comb [ total + color [ i ] - 1 ] [ color [ i ] - 1 ] ) % mod\n    total += color [ i ] % mod\nprint ( res % mod )\n", "python_code_tokenized": "maxn = 1010 NEW_LINE mod = 1000000007 NEW_LINE comb = [ [ 0 for i in range ( maxn ) ] for i in range ( maxn ) ] NEW_LINE comb [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , maxn ) : NEW_LINE INDENT comb [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT comb [ i ] [ j ] = comb [ i - 1 ] [ j ] + comb [ i - 1 ] [ j - 1 ] % mod NEW_LINE DEDENT DEDENT k = int ( input ( ) ) NEW_LINE color = [ int ( input ( ) ) for i in range ( k ) ] NEW_LINE res = 1 NEW_LINE total = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = ( res * comb [ total + color [ i ] - 1 ] [ color [ i ] - 1 ] ) % mod NEW_LINE total += color [ i ] % mod NEW_LINE DEDENT print ( res % mod ) NEW_LINE"}
{"id": "geeksforgeeks_3495_A", "sol": 0, "python_code": "def solve ( A , B , C ) :\n    i = len ( A ) - 1\n    j = len ( B ) - 1\n    k = len ( C ) - 1\n    min_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) )\n    while i != - 1 and j != - 1 and k != - 1 :\n        current_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) )\n        if current_diff < min_diff :\n            min_diff = current_diff\n        max_term = max ( A [ i ] , B [ j ] , C [ k ] )\n        if A [ i ] == max_term :\n            i -= 1\n        elif B [ j ] == max_term :\n            j -= 1\n        else :\n            k -= 1\n    return min_diff\nA = [ 5 , 8 , 10 , 15 ]\nB = [ 6 , 9 , 15 , 78 , 89 ]\nC = [ 2 , 3 , 6 , 6 , 8 , 8 , 10 ]\nprint ( solve ( A , B , C ) )\n", "python_code_tokenized": "def solve ( A , B , C ) : NEW_LINE INDENT i = len ( A ) - 1 NEW_LINE j = len ( B ) - 1 NEW_LINE k = len ( C ) - 1 NEW_LINE min_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE while i != - 1 and j != - 1 and k != - 1 : NEW_LINE INDENT current_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE if current_diff < min_diff : NEW_LINE INDENT min_diff = current_diff NEW_LINE DEDENT max_term = max ( A [ i ] , B [ j ] , C [ k ] ) NEW_LINE if A [ i ] == max_term : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif B [ j ] == max_term : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT return min_diff NEW_LINE DEDENT A = [ 5 , 8 , 10 , 15 ] NEW_LINE B = [ 6 , 9 , 15 , 78 , 89 ] NEW_LINE C = [ 2 , 3 , 6 , 6 , 8 , 8 , 10 ] NEW_LINE print ( solve ( A , B , C ) ) NEW_LINE"}
{"id": "geeksforgeeks_1759_A", "sol": 0, "python_code": "def getParity ( n ) :\n    parity = 0\n    while n :\n        parity = ~ parity\n        n = n & ( n - 1 )\n    return parity\nn = 7\nprint ( \"Parity of no \" , n , \" = \" , ( \"odd\" if getParity ( n ) else \"even\" ) )\n", "python_code_tokenized": "def getParity ( n ) : NEW_LINE INDENT parity = 0 NEW_LINE while n : NEW_LINE INDENT parity = ~ parity NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return parity NEW_LINE DEDENT n = 7 NEW_LINE print ( \" Parity \u2581 of \u2581 no \u2581 \" , n , \" \u2581 = \u2581 \" , ( \" odd \" if getParity ( n ) else \" even \" ) ) NEW_LINE"}
{"id": "geeksforgeeks_1991_A", "sol": 0, "python_code": "import math as mt\ndef gcd ( a , b ) :\n    if ( b == 0 ) :\n        return a\n    else :\n        return gcd ( b , a % b )\ndef coPrime ( n1 , n2 ) :\n    if ( gcd ( n1 , n2 ) == 1 ) :\n        return True\n    else :\n        return False\ndef largestCoprime ( N ) :\n    half = mt.floor ( N / 2 )\n    while ( coPrime ( N , half ) == False ) :\n        half -= 1\n    return half\nn = 50\nprint ( largestCoprime ( n ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def coPrime ( n1 , n2 ) : NEW_LINE INDENT if ( gcd ( n1 , n2 ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def largestCoprime ( N ) : NEW_LINE INDENT half = mt . floor ( N / 2 ) NEW_LINE while ( coPrime ( N , half ) == False ) : NEW_LINE INDENT half -= 1 NEW_LINE DEDENT return half NEW_LINE DEDENT n = 50 NEW_LINE print ( largestCoprime ( n ) ) NEW_LINE"}
{"id": "aizu_p01731_A", "sol": 0, "python_code": "import sys\nsys.setrecursionlimit ( 10000 )\nn = int ( input ( ) )\na = [ ]\nb = [ [ ] for _ in [ 0 ] * n ]\ndef f ( i , x ) :\n    print ( '.' * x + a [ i ] )\n    for j in b [ i ] :\n        f ( j , x + 1 )\nfor i in range ( n ) :\n    c = int ( input ( ) )\n    a += [ input ( ) ]\n    if c != 0 : b [ c - 1 ] += [ i ]\nf ( 0 , 0 )\n", "python_code_tokenized": "import sys NEW_LINE sys . setrecursionlimit ( 10000 ) NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ [ ] for _ in [ 0 ] * n ] NEW_LINE def f ( i , x ) : NEW_LINE INDENT print ( ' . ' * x + a [ i ] ) NEW_LINE for j in b [ i ] : NEW_LINE INDENT f ( j , x + 1 ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT c = int ( input ( ) ) NEW_LINE a += [ input ( ) ] NEW_LINE if c != 0 : b [ c - 1 ] += [ i ] NEW_LINE DEDENT f ( 0 , 0 ) NEW_LINE"}
{"id": "atcoder_ABC136_E", "sol": 0, "python_code": "N , K = map ( int , input ( ).split ( ) )\nA = list ( map ( int , input ( ).split ( ) ) )\nS = sum ( A )\nans = 0\nfor i in range ( 1 , int ( S ** 0.5 ) + 1 ) :\n    if S % i != 0 :\n        continue\n    for j in range ( 2 ) :\n        d = i if j else S // i\n        B = sorted ( map ( lambda a : a % d , A ) )\n        C = [ 0 ]\n        for k in range ( N ) :\n            C.append ( C [ - 1 ] + B [ k ] )\n        for k in range ( N + 1 ) :\n            if ( ( N - k ) * d - ( C [ - 1 ] - C [ k ] ) - C [ k ] ) % d == 0 :\n                if max ( C [ k ] , ( N - k ) * d - ( C [ - 1 ] - C [ k ] ) ) <= K :\n                    ans = max ( ans , d )\nprint ( ans )\n", "python_code_tokenized": "N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE S = sum ( A ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , int ( S ** 0.5 ) + 1 ) : NEW_LINE INDENT if S % i != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( 2 ) : NEW_LINE INDENT d = i if j else S // i NEW_LINE B = sorted ( map ( lambda a : a % d , A ) ) NEW_LINE C = [ 0 ] NEW_LINE for k in range ( N ) : NEW_LINE INDENT C . append ( C [ - 1 ] + B [ k ] ) NEW_LINE DEDENT for k in range ( N + 1 ) : NEW_LINE INDENT if ( ( N - k ) * d - ( C [ - 1 ] - C [ k ] ) - C [ k ] ) % d == 0 : NEW_LINE INDENT if max ( C [ k ] , ( N - k ) * d - ( C [ - 1 ] - C [ k ] ) ) <= K : NEW_LINE INDENT ans = max ( ans , d ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_1046_A", "sol": 0, "python_code": "def maxPrefix ( s , t ) :\n    count = 0\n    for i in range ( 0 , len ( t ) ) :\n        if ( count == len ( s ) ) :\n            break\n        if ( t [ i ] == s [ count ] ) :\n            count = count + 1\n    return count\nS = \"digger\"\nT = \"biggerdiagram\"\nprint ( maxPrefix ( S , T ) )\n", "python_code_tokenized": "def maxPrefix ( s , t ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , len ( t ) ) : NEW_LINE INDENT if ( count == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( t [ i ] == s [ count ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT S = \" digger \" NEW_LINE T = \" biggerdiagram \" NEW_LINE print ( maxPrefix ( S , T ) ) NEW_LINE"}
{"id": "geeksforgeeks_2002_A", "sol": 0, "python_code": "from math import gcd as __gcd\ndef findTwoNumbers ( sum , gcd ) :\n    if ( __gcd ( gcd , sum - gcd ) == gcd and sum != gcd ) :\n        print ( \"a =\" , min ( gcd , sum - gcd ) , \", b =\" , sum - min ( gcd , sum - gcd ) )\n    else :\n        print ( - 1 )\nif __name__ == '__main__' :\n    sum = 8\n    gcd = 2\n    findTwoNumbers ( sum , gcd )\n", "python_code_tokenized": "from math import gcd as __gcd NEW_LINE def findTwoNumbers ( sum , gcd ) : NEW_LINE INDENT if ( __gcd ( gcd , sum - gcd ) == gcd and sum != gcd ) : NEW_LINE INDENT print ( \" a \u2581 = \" , min ( gcd , sum - gcd ) , \" , \u2581 b \u2581 = \" , sum - min ( gcd , sum - gcd ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sum = 8 NEW_LINE gcd = 2 NEW_LINE findTwoNumbers ( sum , gcd ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3277_A", "sol": 0, "python_code": "def totalWays ( N , M , X ) :\n    dp = [ [ 0 for i in range ( 2 ) ] for j in range ( N + 1 ) ]\n    if ( X == 1 ) :\n        dp [ 0 ] [ 0 ] = 1\n    else :\n        dp [ 0 ] [ 1 ] = 0\n    if ( X == 1 ) :\n        dp [ 1 ] [ 0 ] = 0\n        dp [ 1 ] [ 1 ] = M - 1\n    else :\n        dp [ 1 ] [ 0 ] = 1\n        dp [ 1 ] [ 1 ] = ( M - 2 )\n    for i in range ( 2 , N ) :\n        dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ]\n        dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 )\n    return dp [ N - 1 ] [ 0 ]\nif __name__ == '__main__' :\n    N = 4\n    M = 3\n    X = 2\n    print ( totalWays ( N , M , X ) )\n", "python_code_tokenized": "def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 1 ] = 0 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = M - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE M = 3 NEW_LINE X = 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1385_A", "sol": 0, "python_code": "t = int ( input ( \" \" ) )\nfor i in range ( t ) :\n    x , y , z = input ( \" \" ).split ( )\n    x = int ( x )\n    y = int ( y )\n    z = int ( z )\n    if x == y and y == z and x == z :\n        print ( \"YES\" )\n        print ( x , \" \" , y , \" \" , z )\n    elif x == y or x == z or y == z :\n        M = max ( x , y , z )\n        m = min ( x , y , z )\n        if x + y + z == 2 * M + m :\n            print ( \"YES\" )\n            print ( M , \" \" , m , \" \" , m )\n        else :\n            print ( \"NO\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "t = int ( input ( \" \u2581 \" ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT x , y , z = input ( \" \u2581 \" ) . split ( ) NEW_LINE x = int ( x ) NEW_LINE y = int ( y ) NEW_LINE z = int ( z ) NEW_LINE if x == y and y == z and x == z : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE print ( x , \" \u2581 \" , y , \" \u2581 \" , z ) NEW_LINE DEDENT elif x == y or x == z or y == z : NEW_LINE INDENT M = max ( x , y , z ) NEW_LINE m = min ( x , y , z ) NEW_LINE if x + y + z == 2 * M + m : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE print ( M , \" \u2581 \" , m , \" \u2581 \" , m ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3015_A", "sol": 0, "python_code": "def oddNumSum ( n ) :\n    return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15\nn = 4\nprint ( int ( oddNumSum ( n ) ) )\n", "python_code_tokenized": "def oddNumSum ( n ) : NEW_LINE INDENT return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( oddNumSum ( n ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_530_A", "sol": 0, "python_code": "def odd_digits ( n ) :\n    if ( n < 10 ) :\n        return n ;\n    elif ( n / 10 < 10 ) :\n        return 9 ;\n    elif ( n / 100 < 10 ) :\n        return 9 + n - 99 ;\n    elif ( n / 1000 < 10 ) :\n        return 9 + 900 ;\n    elif ( n / 10000 < 10 ) :\n        return 909 + n - 9999 ;\n    else :\n        return 90909 ;\nif __name__ == \"__main__\" :\n    n = 893 ;\n    print ( odd_digits ( n ) ) ;\n", "python_code_tokenized": "def odd_digits ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT elif ( n / 10 < 10 ) : NEW_LINE INDENT return 9 ; NEW_LINE DEDENT elif ( n / 100 < 10 ) : NEW_LINE INDENT return 9 + n - 99 ; NEW_LINE DEDENT elif ( n / 1000 < 10 ) : NEW_LINE INDENT return 9 + 900 ; NEW_LINE DEDENT elif ( n / 10000 < 10 ) : NEW_LINE INDENT return 909 + n - 9999 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 90909 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 893 ; NEW_LINE print ( odd_digits ( n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1474_A", "sol": 0, "python_code": "arr = [ 1 , 3 , 5 , 2 , 4 , 6 ]\ndef rearrange ( n ) :\n    global arr\n    if ( n % 2 == 1 ) :\n        return\n    currIdx = int ( ( n - 1 ) / 2 )\n    while ( currIdx > 0 ) :\n        count = currIdx\n        swapIdx = currIdx\n        while ( count > 0 ) :\n            temp = arr [ swapIdx + 1 ]\n            arr [ swapIdx + 1 ] = arr [ swapIdx ]\n            arr [ swapIdx ] = temp\n            swapIdx = swapIdx + 1\n            count = count - 1\n        currIdx = currIdx - 1\nn = len ( arr )\nrearrange ( n )\nfor i in range ( 0 , n ) :\n    print ( \"{} \".format ( arr [ i ] ) , end = \"\" )\n", "python_code_tokenized": "arr = [ 1 , 3 , 5 , 2 , 4 , 6 ] NEW_LINE def rearrange ( n ) : NEW_LINE INDENT global arr NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT currIdx = int ( ( n - 1 ) / 2 ) NEW_LINE while ( currIdx > 0 ) : NEW_LINE INDENT count = currIdx NEW_LINE swapIdx = currIdx NEW_LINE while ( count > 0 ) : NEW_LINE INDENT temp = arr [ swapIdx + 1 ] NEW_LINE arr [ swapIdx + 1 ] = arr [ swapIdx ] NEW_LINE arr [ swapIdx ] = temp NEW_LINE swapIdx = swapIdx + 1 NEW_LINE count = count - 1 NEW_LINE DEDENT currIdx = currIdx - 1 NEW_LINE DEDENT DEDENT n = len ( arr ) NEW_LINE rearrange ( n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( \" { } \u2581 \" . format ( arr [ i ] ) , end = \" \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3335_A", "sol": 0, "python_code": "def findCost ( s1 , s2 , a , b , c , d , n ) :\n    cost = 0\n    for i in range ( n ) :\n        if ( s1 [ i ] == s2 [ i ] ) :\n            continue\n        else :\n            if ( ( s1 [ i ] == '1' and s2 [ i ] == '2' ) or ( s2 [ i ] == '1' and s1 [ i ] == '2' ) ) :\n                cost += min ( d , min ( a , b + c ) )\n            elif ( ( s1 [ i ] == '2' and s2 [ i ] == '3' ) or ( s2 [ i ] == '2' and s1 [ i ] == '3' ) ) :\n                cost += min ( d , min ( b , a + c ) )\n            elif ( ( s1 [ i ] == '1' and s2 [ i ] == '3' ) or ( s2 [ i ] == '1' and s1 [ i ] == '3' ) ) :\n                cost += min ( d , min ( c , a + b ) )\n    return cost\nif __name__ == '__main__' :\n    s1 = \"121\"\n    s2 = \"223\"\n    a = 2\n    b = 3\n    c = 4\n    d = 10\n    n = len ( s1 )\n    print ( findCost ( s1 , s2 , a , b , c , d , n ) )\n", "python_code_tokenized": "def findCost ( s1 , s2 , a , b , c , d , n ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( s1 [ i ] == '1' and s2 [ i ] == '2' ) or ( s2 [ i ] == '1' and s1 [ i ] == '2' ) ) : NEW_LINE INDENT cost += min ( d , min ( a , b + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '2' and s2 [ i ] == '3' ) or ( s2 [ i ] == '2' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( b , a + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '1' and s2 [ i ] == '3' ) or ( s2 [ i ] == '1' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( c , a + b ) ) NEW_LINE DEDENT DEDENT DEDENT return cost NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \"121\" NEW_LINE s2 = \"223\" NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE d = 10 NEW_LINE n = len ( s1 ) NEW_LINE print ( findCost ( s1 , s2 , a , b , c , d , n ) ) NEW_LINE DEDENT"}
{"id": "aizu_p01418_A", "sol": 0, "python_code": "import sys\nsys.setrecursionlimit ( 10 ** 9 )\ndef input ( ) :\n    return sys.stdin.readline ( ) [ : - 1 ]\nEPS = 1e-10\nk , L , R = map ( int , input ( ).split ( ) )\np = float ( input ( ) )\ne = float ( input ( ) )\nt = float ( input ( ) )\ndef search ( l , r , prob , depth ) :\n    if depth == k :\n        h = ( l + r ) / 2\n        if abs ( h - t ) + EPS < e :\n            return prob\n        else :\n            return 0\n    else :\n        if l - EPS > t + e or r + EPS < t - e :\n            return 0\n        elif l + EPS > t - e and t + e > r - EPS :\n            return prob\n        else :\n            h = ( l + r ) / 2\n            if h >= t :\n                return search ( h , r , prob * p , depth + 1 ) + search ( l , h , prob * ( 1 - p ) , depth + 1 )\n            else :\n                return search ( h , r , prob * ( 1 - p ) , depth + 1 ) + search ( l , h , prob * p , depth + 1 )\nans = search ( L , R , 1 , 0 )\nprint ( '{:.12f}'.format ( ans ) )\n", "python_code_tokenized": "import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE def input ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) [ : - 1 ] NEW_LINE DEDENT EPS = 1e-10 NEW_LINE k , L , R = map ( int , input ( ) . split ( ) ) NEW_LINE p = float ( input ( ) ) NEW_LINE e = float ( input ( ) ) NEW_LINE t = float ( input ( ) ) NEW_LINE def search ( l , r , prob , depth ) : NEW_LINE INDENT if depth == k : NEW_LINE INDENT h = ( l + r ) / 2 NEW_LINE if abs ( h - t ) + EPS < e : NEW_LINE INDENT return prob NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if l - EPS > t + e or r + EPS < t - e : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif l + EPS > t - e and t + e > r - EPS : NEW_LINE INDENT return prob NEW_LINE DEDENT else : NEW_LINE INDENT h = ( l + r ) / 2 NEW_LINE if h >= t : NEW_LINE INDENT return search ( h , r , prob * p , depth + 1 ) + search ( l , h , prob * ( 1 - p ) , depth + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return search ( h , r , prob * ( 1 - p ) , depth + 1 ) + search ( l , h , prob * p , depth + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = search ( L , R , 1 , 0 ) NEW_LINE print ( ' { : . 12f } ' . format ( ans ) ) NEW_LINE"}
{"id": "geeksforgeeks_4182_A", "sol": 0, "python_code": "def countXorPair ( arr , n ) :\n    odd = 0\n    even = 0\n    for i in range ( n ) :\n        if arr [ i ] % 2 == 0 :\n            even += 1\n        else :\n            odd += 1\n    return odd * even\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 3 ]\n    n = len ( arr )\n    print ( countXorPair ( arr , n ) )\n", "python_code_tokenized": "def countXorPair ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT return odd * even NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countXorPair ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "projecteuler_p017_A", "sol": 0, "python_code": "def compute ( ) :\n    ans = sum ( len ( to_english ( i ) ) for i in range ( 1 , 1001 ) )\n    return str ( ans )\ndef to_english ( n ) :\n    if 0 <= n < 20 :\n        return ONES [ n ]\n    elif 20 <= n < 100 :\n        return TENS [ n // 10 ] + ( ONES [ n % 10 ] if ( n % 10 != 0 ) else \"\" )\n    elif 100 <= n < 1000 :\n        return ONES [ n // 100 ] + \"hundred\" + ( ( \"and\" + to_english ( n % 100 ) ) if ( n % 100 != 0 ) else \"\" )\n    elif 1000 <= n < 1000000 :\n        return to_english ( n // 1000 ) + \"thousand\" + ( to_english ( n % 1000 ) if ( n % 1000 != 0 ) else \"\" )\n    else :\n        raise ValueError ( )\nONES = [ \"zero\" , \"one\" , \"two\" , \"three\" , \"four\" , \"five\" , \"six\" , \"seven\" , \"eight\" , \"nine\" , \"ten\" , \"eleven\" , \"twelve\" , \"thirteen\" , \"fourteen\" , \"fifteen\" , \"sixteen\" , \"seventeen\" , \"eighteen\" , \"nineteen\" ]\nTENS = [ \"\" , \"\" , \"twenty\" , \"thirty\" , \"forty\" , \"fifty\" , \"sixty\" , \"seventy\" , \"eighty\" , \"ninety\" ]\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT ans = sum ( len ( to_english ( i ) ) for i in range ( 1 , 1001 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def to_english ( n ) : NEW_LINE INDENT if 0 <= n < 20 : NEW_LINE INDENT return ONES [ n ] NEW_LINE DEDENT elif 20 <= n < 100 : NEW_LINE INDENT return TENS [ n // 10 ] + ( ONES [ n % 10 ] if ( n % 10 != 0 ) else \" \" ) NEW_LINE DEDENT elif 100 <= n < 1000 : NEW_LINE INDENT return ONES [ n // 100 ] + \" hundred \" + ( ( \" and \" + to_english ( n % 100 ) ) if ( n % 100 != 0 ) else \" \" ) NEW_LINE DEDENT elif 1000 <= n < 1000000 : NEW_LINE INDENT return to_english ( n // 1000 ) + \" thousand \" + ( to_english ( n % 1000 ) if ( n % 1000 != 0 ) else \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT DEDENT ONES = [ \" zero \" , \" one \" , \" two \" , \" three \" , \" four \" , \" five \" , \" six \" , \" seven \" , \" eight \" , \" nine \" , \" ten \" , \" eleven \" , \" twelve \" , \" thirteen \" , \" fourteen \" , \" fifteen \" , \" sixteen \" , \" seventeen \" , \" eighteen \" , \" nineteen \" ] NEW_LINE TENS = [ \" \" , \" \" , \" twenty \" , \" thirty \" , \" forty \" , \" fifty \" , \" sixty \" , \" seventy \" , \" eighty \" , \" ninety \" ] NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1844_A", "sol": 0, "python_code": "def computeXOR ( n ) :\n    switch = { 0 : n , 1 : 1 , 2 : n + 1 , 3 : 0 , }\n    return switch.get ( n & 3 , \"\" )\nl = 1\nr = 4\nprint ( computeXOR ( r ) ^ computeXOR ( l - 1 ) )\n", "python_code_tokenized": "def computeXOR ( n ) : NEW_LINE INDENT switch = { 0 : n , 1 : 1 , 2 : n + 1 , 3 : 0 , } NEW_LINE return switch . get ( n & 3 , \" \" ) NEW_LINE DEDENT l = 1 NEW_LINE r = 4 NEW_LINE print ( computeXOR ( r ) ^ computeXOR ( l - 1 ) ) NEW_LINE"}
{"id": "codeforces_441_A", "sol": 0, "python_code": "n , v = list ( map ( int , input ( ).split ( ) ) )\nans = [ ]\nfor x in range ( n ) :\n    lst = list ( map ( int , input ( ).split ( ) ) )\n    k = lst [ 0 ]\n    lst = lst [ 1 : ]\n    f = 0\n    for i in range ( k ) :\n        if v > lst [ i ] :\n            f = 1\n    if f :\n        ans.append ( x )\nprint ( len ( ans ) )\nfor i in ans :\n    print ( i + 1 , end = ' ' )\n", "python_code_tokenized": "n , v = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for x in range ( n ) : NEW_LINE INDENT lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = lst [ 0 ] NEW_LINE lst = lst [ 1 : ] NEW_LINE f = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if v > lst [ i ] : NEW_LINE INDENT f = 1 NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT ans . append ( x ) NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE for i in ans : NEW_LINE INDENT print ( i + 1 , end = ' \u2581 ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3641_A", "sol": 0, "python_code": "def Perimeter ( s , n ) :\n    perimeter = 1\n    perimeter = n * s\n    return perimeter\nif __name__ == '__main__' :\n    n = 5\n    s = 2.5\n    peri = Perimeter ( s , n )\n    print ( \"Perimeter of Regular Polygon with\" , n , \"sides of length\" , s , \"=\" , peri )\n", "python_code_tokenized": "def Perimeter ( s , n ) : NEW_LINE INDENT perimeter = 1 NEW_LINE perimeter = n * s NEW_LINE return perimeter NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE s = 2.5 NEW_LINE peri = Perimeter ( s , n ) NEW_LINE print ( \" Perimeter \u2581 of \u2581 Regular \u2581 Polygon \u2581 with \" , n , \" sides \u2581 of \u2581 length \" , s , \" = \" , peri ) NEW_LINE DEDENT"}
{"id": "codeforces_1409_A", "sol": 0, "python_code": "a = int ( input ( ) )\nfor i in range ( a ) :\n    b , c = map ( int , input ( ).split ( ) )\n    d = abs ( b - c )\n    if d % 10 != 0 :\n        print ( d // 10 + 1 )\n    else :\n        print ( d // 10 )\n", "python_code_tokenized": "a = int ( input ( ) ) NEW_LINE for i in range ( a ) : NEW_LINE INDENT b , c = map ( int , input ( ) . split ( ) ) NEW_LINE d = abs ( b - c ) NEW_LINE if d % 10 != 0 : NEW_LINE INDENT print ( d // 10 + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d // 10 ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_804_A", "sol": 0, "python_code": "import math\ndef getArea ( base , hypotenuse ) :\n    height = math.sqrt ( hypotenuse * hypotenuse - base * base ) ;\n    return 0.5 * base * height\ndef printRightAngleTriangle ( hypotenuse , area ) :\n    hsquare = hypotenuse * hypotenuse\n    sideForMaxArea = math.sqrt ( hsquare / 2.0 )\n    maxArea = getArea ( sideForMaxArea , hypotenuse )\n    if ( area > maxArea ) :\n        print ( \"Not possiblen\" )\n        return\n    low = 0.0\n    high = sideForMaxArea\n    while ( abs ( high - low ) > 1e-6 ) :\n        base = ( low + high ) / 2.0\n        if ( getArea ( base , hypotenuse ) >= area ) :\n            high = base\n        else :\n            low = base\n    height = math.ceil ( math.sqrt ( hsquare - base * base ) )\n    base = math.floor ( base )\n    print ( base , height )\nif __name__ == '__main__' :\n    hypotenuse = 5\n    area = 6\n    printRightAngleTriangle ( hypotenuse , area )\n", "python_code_tokenized": "import math NEW_LINE def getArea ( base , hypotenuse ) : NEW_LINE INDENT height = math . sqrt ( hypotenuse * hypotenuse - base * base ) ; NEW_LINE return 0.5 * base * height NEW_LINE DEDENT def printRightAngleTriangle ( hypotenuse , area ) : NEW_LINE INDENT hsquare = hypotenuse * hypotenuse NEW_LINE sideForMaxArea = math . sqrt ( hsquare / 2.0 ) NEW_LINE maxArea = getArea ( sideForMaxArea , hypotenuse ) NEW_LINE if ( area > maxArea ) : NEW_LINE INDENT print ( \" Not \u2581 possiblen \" ) NEW_LINE return NEW_LINE DEDENT low = 0.0 NEW_LINE high = sideForMaxArea NEW_LINE while ( abs ( high - low ) > 1e-6 ) : NEW_LINE INDENT base = ( low + high ) / 2.0 NEW_LINE if ( getArea ( base , hypotenuse ) >= area ) : NEW_LINE INDENT high = base NEW_LINE DEDENT else : NEW_LINE INDENT low = base NEW_LINE DEDENT DEDENT height = math . ceil ( math . sqrt ( hsquare - base * base ) ) NEW_LINE base = math . floor ( base ) NEW_LINE print ( base , height ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT hypotenuse = 5 NEW_LINE area = 6 NEW_LINE printRightAngleTriangle ( hypotenuse , area ) NEW_LINE DEDENT"}
{"id": "codeforces_1680_B", "sol": 0, "python_code": "def test ( ) :\n    nrow , ncol = map ( int , input ( ).split ( ) )\n    arr = [ ]\n    val = 100000000000\n    lr , lc = 0 , 0\n    for row_id in range ( nrow ) :\n        temp = list ( input ( ) )\n        arr.append ( [ ] )\n        for col_id in range ( ncol ) :\n            if temp [ col_id ] == \"R\" :\n                temp2 = row_id + col_id\n                arr [ row_id ].append ( temp2 )\n                if temp2 < val :\n                    val = temp2\n                    lr , lc = row_id , col_id\n            else :\n                arr [ row_id ].append ( 0 )\n    for i in range ( lr ) :\n        temp = arr [ i ]\n        if max ( temp ) > 0 :\n            return False\n    for i in range ( nrow ) :\n        for j in range ( lc ) :\n            if arr [ i ] [ j ] > 0 :\n                return False\n    return True\nnum_test_cases = int ( input ( ) )\nfor test_case in range ( num_test_cases ) :\n    val = test ( )\n    if val :\n        print ( 'YES' )\n    else :\n        print ( 'NO' )\n", "python_code_tokenized": "def test ( ) : NEW_LINE INDENT nrow , ncol = map ( int , input ( ) . split ( ) ) NEW_LINE arr = [ ] NEW_LINE val = 100000000000 NEW_LINE lr , lc = 0 , 0 NEW_LINE for row_id in range ( nrow ) : NEW_LINE INDENT temp = list ( input ( ) ) NEW_LINE arr . append ( [ ] ) NEW_LINE for col_id in range ( ncol ) : NEW_LINE INDENT if temp [ col_id ] == \" R \" : NEW_LINE INDENT temp2 = row_id + col_id NEW_LINE arr [ row_id ] . append ( temp2 ) NEW_LINE if temp2 < val : NEW_LINE INDENT val = temp2 NEW_LINE lr , lc = row_id , col_id NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT arr [ row_id ] . append ( 0 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( lr ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE if max ( temp ) > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( nrow ) : NEW_LINE INDENT for j in range ( lc ) : NEW_LINE INDENT if arr [ i ] [ j ] > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT num_test_cases = int ( input ( ) ) NEW_LINE for test_case in range ( num_test_cases ) : NEW_LINE INDENT val = test ( ) NEW_LINE if val : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_AGC029_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\na.sort ( reverse = True )\nd = { }\ncount = 0\nfor x in a :\n    if x not in d : d [ x ] = 0\n    d [ x ] += 1\nfor i in range ( len ( a ) ) :\n    if d [ a [ i ] ] == 0 :\n        continue\n    d [ a [ i ] ] -= 1\n    y = 2 ** a [ i ].bit_length ( ) - a [ i ]\n    if y in d and d [ y ] > 0 :\n        count += 1\n        d [ y ] -= 1\nprint ( count )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE d = { } NEW_LINE count = 0 NEW_LINE for x in a : NEW_LINE INDENT if x not in d : d [ x ] = 0 NEW_LINE d [ x ] += 1 NEW_LINE DEDENT for i in range ( len ( a ) ) : NEW_LINE INDENT if d [ a [ i ] ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT d [ a [ i ] ] -= 1 NEW_LINE y = 2 ** a [ i ] . bit_length ( ) - a [ i ] NEW_LINE if y in d and d [ y ] > 0 : NEW_LINE INDENT count += 1 NEW_LINE d [ y ] -= 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"}
{"id": "geeksforgeeks_1533_A", "sol": 0, "python_code": "def createSorted ( a : list , n : int ) :\n    b = [ ]\n    for j in range ( n ) :\n        if len ( b ) == 0 :\n            b.append ( a [ j ] )\n        else :\n            start = 0\n            end = len ( b ) - 1\n            pos = 0\n            while start <= end :\n                mid = start + ( end - start ) // 2\n                if b [ mid ] == a [ j ] :\n                    b.insert ( max ( 0 , mid + 1 ) , a [ j ] )\n                    break\n                elif b [ mid ] > a [ j ] :\n                    pos = end = mid - 1\n                else :\n                    pos = start = mid + 1\n                if start > end :\n                    pos = start\n                    b.insert ( max ( 0 , pos ) , a [ j ] )\n                    break\n    for i in range ( n ) :\n        print ( b [ i ] , end = \" \" )\nif __name__ == \"__main__\" :\n    a = [ 2 , 5 , 4 , 9 , 8 ]\n    n = len ( a )\n    createSorted ( a , n )\n", "python_code_tokenized": "def createSorted ( a : list , n : int ) : NEW_LINE INDENT b = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if len ( b ) == 0 : NEW_LINE INDENT b . append ( a [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT start = 0 NEW_LINE end = len ( b ) - 1 NEW_LINE pos = 0 NEW_LINE while start <= end : NEW_LINE INDENT mid = start + ( end - start ) // 2 NEW_LINE if b [ mid ] == a [ j ] : NEW_LINE INDENT b . insert ( max ( 0 , mid + 1 ) , a [ j ] ) NEW_LINE break NEW_LINE DEDENT elif b [ mid ] > a [ j ] : NEW_LINE INDENT pos = end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = start = mid + 1 NEW_LINE DEDENT if start > end : NEW_LINE INDENT pos = start NEW_LINE b . insert ( max ( 0 , pos ) , a [ j ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 5 , 4 , 9 , 8 ] NEW_LINE n = len ( a ) NEW_LINE createSorted ( a , n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1127_A", "sol": 0, "python_code": "def Odd_Sum ( n ) :\n    total = ( n + 1 ) // 2\n    odd = total * total\n    return odd\ndef Even_Sum ( n ) :\n    total = n // 2\n    even = total * ( total + 1 )\n    return even\ndef sumLtoR ( L , R ) :\n    odd_sum = Odd_Sum ( R ) - Odd_Sum ( L - 1 )\n    even_sum = Even_Sum ( R ) - Even_Sum ( L - 1 )\n    return even_sum - odd_sum\nL = 1 ; R = 5\nprint ( sumLtoR ( L , R ) )\n", "python_code_tokenized": "def Odd_Sum ( n ) : NEW_LINE INDENT total = ( n + 1 ) // 2 NEW_LINE odd = total * total NEW_LINE return odd NEW_LINE DEDENT def Even_Sum ( n ) : NEW_LINE INDENT total = n // 2 NEW_LINE even = total * ( total + 1 ) NEW_LINE return even NEW_LINE DEDENT def sumLtoR ( L , R ) : NEW_LINE INDENT odd_sum = Odd_Sum ( R ) - Odd_Sum ( L - 1 ) NEW_LINE even_sum = Even_Sum ( R ) - Even_Sum ( L - 1 ) NEW_LINE return even_sum - odd_sum NEW_LINE DEDENT L = 1 ; R = 5 NEW_LINE print ( sumLtoR ( L , R ) ) NEW_LINE"}
{"id": "codeforces_1056_A", "sol": 0, "python_code": "n = int ( input ( ) )\nres = set ( range ( 1 , 101 ) )\nfor _ in range ( n ) :\n    r , * lines = ( int ( i ) for i in input ( ).split ( ) )\n    res &= set ( lines )\nprint ( * res )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE res = set ( range ( 1 , 101 ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT r , * lines = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE res &= set ( lines ) NEW_LINE DEDENT print ( * res ) NEW_LINE"}
{"id": "geeksforgeeks_4278_A", "sol": 0, "python_code": "def repUnitValue ( n ) :\n    if ( n % 2 == 0 or n % 5 == 0 ) :\n        return 0\n    rem = 1\n    power = 1\n    k = 1\n    while ( rem % n != 0 ) :\n        k += 1\n        power = power * 10 % n\n        rem = ( rem + power ) % n\n    return k\nn = 13\nprint ( repUnitValue ( n ) )\n", "python_code_tokenized": "def repUnitValue ( n ) : NEW_LINE INDENT if ( n % 2 == 0 or n % 5 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT rem = 1 NEW_LINE power = 1 NEW_LINE k = 1 NEW_LINE while ( rem % n != 0 ) : NEW_LINE INDENT k += 1 NEW_LINE power = power * 10 % n NEW_LINE rem = ( rem + power ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT n = 13 NEW_LINE print ( repUnitValue ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1503_A", "sol": 0, "python_code": "def getFrequencies ( string ) :\n    freq = [ 0 ] * 26\n    for i in range ( len ( string ) ) :\n        freq [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1\n    return freq\ndef countMinParts ( string ) :\n    n = len ( string )\n    freq = getFrequencies ( string )\n    oddFreq = [ ]\n    evenFreq = [ ]\n    sumEven = 0\n    for i in range ( 26 ) :\n        if freq [ i ] == 0 :\n            continue\n        if freq [ i ] % 2 == 0 :\n            evenFreq.append ( freq [ i ] )\n        else :\n            oddFreq.append ( freq [ i ] )\n    for i in range ( len ( evenFreq ) ) :\n        sumEven += evenFreq [ i ]\n    if len ( oddFreq ) == 0 :\n        return 1\n    if sumEven == 0 :\n        if len ( oddFreq ) == 1 :\n            return 1\n        return 0\n    i = 0\n    while ( i < len ( oddFreq ) ) :\n        if ( ( sumEven / 2 ) % len ( oddFreq ) == 0 ) :\n            return len ( oddFreq )\n        if ( oddFreq [ i ] == 1 ) :\n            i += 1\n            continue\n        sumEven += 2\n        oddFreq [ i ] = oddFreq [ i ] - 2\n    return n\nif __name__ == \"__main__\" :\n    s = \"noonpeep\"\n    print ( countMinParts ( s ) )\n", "python_code_tokenized": "def getFrequencies ( string ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT return freq NEW_LINE DEDENT def countMinParts ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE freq = getFrequencies ( string ) NEW_LINE oddFreq = [ ] NEW_LINE evenFreq = [ ] NEW_LINE sumEven = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if freq [ i ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if freq [ i ] % 2 == 0 : NEW_LINE INDENT evenFreq . append ( freq [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddFreq . append ( freq [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( evenFreq ) ) : NEW_LINE INDENT sumEven += evenFreq [ i ] NEW_LINE DEDENT if len ( oddFreq ) == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if sumEven == 0 : NEW_LINE INDENT if len ( oddFreq ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT i = 0 NEW_LINE while ( i < len ( oddFreq ) ) : NEW_LINE INDENT if ( ( sumEven / 2 ) % len ( oddFreq ) == 0 ) : NEW_LINE INDENT return len ( oddFreq ) NEW_LINE DEDENT if ( oddFreq [ i ] == 1 ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT sumEven += 2 NEW_LINE oddFreq [ i ] = oddFreq [ i ] - 2 NEW_LINE DEDENT return n NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" noonpeep \" NEW_LINE print ( countMinParts ( s ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1459_B", "sol": 0, "python_code": "k = int ( input ( ) )\nif k == 1 :\n    print ( 4 )\nelif ( k % 2 == 0 ) :\n    tmp = ( k + 2 ) // 2\n    print ( tmp ** 2 )\nelse :\n    print ( ( k + 1 ) * ( k + 3 ) // 2 )\n", "python_code_tokenized": "k = int ( input ( ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif ( k % 2 == 0 ) : NEW_LINE INDENT tmp = ( k + 2 ) // 2 NEW_LINE print ( tmp ** 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( k + 1 ) * ( k + 3 ) // 2 ) NEW_LINE DEDENT"}
{"id": "codeforces_809_B", "sol": 0, "python_code": "import sys\ndef ask ( x , y ) :\n    print ( \"1\" , x , y )\n    sys.stdout.flush ( )\n    return input ( )\ndef solve ( L , R ) :\n    while L < R :\n        mid = ( L + R ) >> 1\n        if ask ( mid , mid + 1 ) == \"TAK\" :\n            R = mid\n        else :\n            L = mid + 1\n    return L\nn , k = list ( map ( int , input ( ).split ( ) ) )\na = solve ( 1 , n )\nb , c = a , a\nif a > 1 :\n    b = solve ( 1 , a - 1 )\nif a < n :\n    c = solve ( a + 1 , n )\nif ask ( b , c ) == \"NIE\" :\n    b , c = c , b\nif a == b :\n    b , c = c , b\nprint ( \"2\" , a , b )\nsys.stdout.flush ( )\n", "python_code_tokenized": "import sys NEW_LINE def ask ( x , y ) : NEW_LINE INDENT print ( \"1\" , x , y ) NEW_LINE sys . stdout . flush ( ) NEW_LINE return input ( ) NEW_LINE DEDENT def solve ( L , R ) : NEW_LINE INDENT while L < R : NEW_LINE INDENT mid = ( L + R ) >> 1 NEW_LINE if ask ( mid , mid + 1 ) == \" TAK \" : NEW_LINE INDENT R = mid NEW_LINE DEDENT else : NEW_LINE INDENT L = mid + 1 NEW_LINE DEDENT DEDENT return L NEW_LINE DEDENT n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = solve ( 1 , n ) NEW_LINE b , c = a , a NEW_LINE if a > 1 : NEW_LINE INDENT b = solve ( 1 , a - 1 ) NEW_LINE DEDENT if a < n : NEW_LINE INDENT c = solve ( a + 1 , n ) NEW_LINE DEDENT if ask ( b , c ) == \" NIE \" : NEW_LINE INDENT b , c = c , b NEW_LINE DEDENT if a == b : NEW_LINE INDENT b , c = c , b NEW_LINE DEDENT print ( \"2\" , a , b ) NEW_LINE sys . stdout . flush ( ) NEW_LINE"}
{"id": "aizu_p00178_A", "sol": 0, "python_code": "def v_block ( ) :\n    block.insert ( 0 , [ ' ' ] * 5 )\n    for l , line in enumerate ( block ) :\n        if line [ q - 1 : q + p - 1 ] != [ ' ' ] * p :\n            break\n    else :\n        l += 1\n    block [ l - 1 ] [ q - 1 : q + p - 1 ] = [ '*' ] * p\n    return delete ( )\ndef h_block ( ) :\n    for _p in range ( p ) :\n        block.insert ( 0 , [ ' ' ] * 5 )\n    for l , line in enumerate ( block ) :\n        if line [ q - 1 ] == '*' :\n            break\n    else :\n        l += 1\n    for _l in range ( l - 1 , l - p - 1 , - 1 ) :\n        block [ _l ] [ q - 1 ] = '*'\n    return delete ( )\ndef delete ( ) :\n    l = 0\n    while True :\n        if block [ l ] == [ ' ' ] * 5 or block [ l ] == [ '*' ] * 5 :\n            del block [ l ]\n        else :\n            l += 1\n        if len ( block ) == l :\n            return\ndef count ( ) :\n    x = 0\n    for line in block :\n        for b in line :\n            if b == '*' :\n                x += 1\n    else :\n        print ( x )\nwhile True :\n    n = int ( input ( ) )\n    if n == 0 :\n        break\n    block = [ [ ' ' ] * 5 ]\n    for i in range ( n ) :\n        d , p , q = map ( int , input ( ).split ( ) )\n        if d == 1 :\n            v_block ( )\n        else :\n            h_block ( )\n    else :\n        count ( )\n", "python_code_tokenized": "def v_block ( ) : NEW_LINE INDENT block . insert ( 0 , [ ' \u2581 ' ] * 5 ) NEW_LINE for l , line in enumerate ( block ) : NEW_LINE INDENT if line [ q - 1 : q + p - 1 ] != [ ' \u2581 ' ] * p : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT block [ l - 1 ] [ q - 1 : q + p - 1 ] = [ ' * ' ] * p NEW_LINE return delete ( ) NEW_LINE DEDENT def h_block ( ) : NEW_LINE INDENT for _p in range ( p ) : NEW_LINE INDENT block . insert ( 0 , [ ' \u2581 ' ] * 5 ) NEW_LINE DEDENT for l , line in enumerate ( block ) : NEW_LINE INDENT if line [ q - 1 ] == ' * ' : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT for _l in range ( l - 1 , l - p - 1 , - 1 ) : NEW_LINE INDENT block [ _l ] [ q - 1 ] = ' * ' NEW_LINE DEDENT return delete ( ) NEW_LINE DEDENT def delete ( ) : NEW_LINE INDENT l = 0 NEW_LINE while True : NEW_LINE INDENT if block [ l ] == [ ' \u2581 ' ] * 5 or block [ l ] == [ ' * ' ] * 5 : NEW_LINE INDENT del block [ l ] NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT if len ( block ) == l : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT DEDENT def count ( ) : NEW_LINE INDENT x = 0 NEW_LINE for line in block : NEW_LINE INDENT for b in line : NEW_LINE INDENT if b == ' * ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT block = [ [ ' \u2581 ' ] * 5 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT d , p , q = map ( int , input ( ) . split ( ) ) NEW_LINE if d == 1 : NEW_LINE INDENT v_block ( ) NEW_LINE DEDENT else : NEW_LINE INDENT h_block ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT count ( ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_378_A", "sol": 0, "python_code": "def expect ( m , n ) :\n    ans = 0.0\n    i = m\n    while ( i ) :\n        ans += ( pow ( i / m , n ) - pow ( ( i - 1 ) / m , n ) ) * i\n        i -= 1\n    return ans\nif __name__ == \"__main__\" :\n    m , n = 6 , 3\n    print ( expect ( m , n ) )\n", "python_code_tokenized": "def expect ( m , n ) : NEW_LINE INDENT ans = 0.0 NEW_LINE i = m NEW_LINE while ( i ) : NEW_LINE INDENT ans += ( pow ( i / m , n ) - pow ( ( i - 1 ) / m , n ) ) * i NEW_LINE i -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m , n = 6 , 3 NEW_LINE print ( expect ( m , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4981_A", "sol": 0, "python_code": "def average ( arr , n , k ) :\n    total = 0\n    if ( 2 * k >= n ) :\n        return 0\n    arr.sort ( )\n    start , end = k , n - k - 1\n    for i in range ( start , end + 1 ) :\n        total += arr [ i ]\n    return ( total / ( n - 2 * k ) )\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 4 , 4 , 5 , 6 ]\n    n = len ( arr )\n    k = 2\n    print ( average ( arr , n , k ) )\n", "python_code_tokenized": "def average ( arr , n , k ) : NEW_LINE INDENT total = 0 NEW_LINE if ( 2 * k >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE start , end = k , n - k - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT total += arr [ i ] NEW_LINE DEDENT return ( total / ( n - 2 * k ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( average ( arr , n , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2009_A", "sol": 0, "python_code": "import math\ndef sumOfDiv ( x ) :\n    sum = 1 ;\n    for i in range ( 2 , int ( math.sqrt ( x ) ) ) :\n        if x % i == 0 :\n            sum += i\n            if i != x / i :\n                sum += x / i\n    return int ( sum ) ;\ndef isAmbicle ( a , b ) :\n    return ( sumOfDiv ( a ) == b and sumOfDiv ( b ) == a )\ndef countPairs ( arr , n ) :\n    s = set ( )\n    count = 0\n    for i in range ( n ) :\n        s.add ( arr [ i ] )\n    for i in range ( n ) :\n        if sumOfDiv ( arr [ i ] ) in s :\n            sum = sumOfDiv ( arr [ i ] )\n            if isAmbicle ( arr [ i ] , sum ) :\n                count += 1\n    return int ( count / 2 ) ;\narr1 = [ 220 , 284 , 1184 , 1210 , 2 , 5 ]\nn1 = len ( arr1 )\nprint ( countPairs ( arr1 , n1 ) )\narr2 = [ 2620 , 2924 , 5020 , 5564 , 6232 , 6368 ]\nn2 = len ( arr2 )\nprint ( countPairs ( arr2 , n2 ) )\n", "python_code_tokenized": "import math NEW_LINE def sumOfDiv ( x ) : NEW_LINE INDENT sum = 1 ; NEW_LINE for i in range ( 2 , int ( math . sqrt ( x ) ) ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT sum += i NEW_LINE if i != x / i : NEW_LINE INDENT sum += x / i NEW_LINE DEDENT DEDENT DEDENT return int ( sum ) ; NEW_LINE DEDENT def isAmbicle ( a , b ) : NEW_LINE INDENT return ( sumOfDiv ( a ) == b and sumOfDiv ( b ) == a ) NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if sumOfDiv ( arr [ i ] ) in s : NEW_LINE INDENT sum = sumOfDiv ( arr [ i ] ) NEW_LINE if isAmbicle ( arr [ i ] , sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( count / 2 ) ; NEW_LINE DEDENT arr1 = [ 220 , 284 , 1184 , 1210 , 2 , 5 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( countPairs ( arr1 , n1 ) ) NEW_LINE arr2 = [ 2620 , 2924 , 5020 , 5564 , 6232 , 6368 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( countPairs ( arr2 , n2 ) ) NEW_LINE"}
{"id": "codeforces_357_A", "sol": 0, "python_code": "n = int ( input ( ) )\nlst = list ( map ( int , input ( ).split ( ) ) )\nx , y = list ( map ( int , input ( ).split ( ) ) )\nans = 0\na = 0\nb = sum ( lst )\nfor i in range ( len ( lst ) ) :\n    a += lst [ i ]\n    b -= lst [ i ]\n    if a >= x and a <= y and b >= x and b <= y :\n        ans = i + 2\n        break\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x , y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE a = 0 NEW_LINE b = sum ( lst ) NEW_LINE for i in range ( len ( lst ) ) : NEW_LINE INDENT a += lst [ i ] NEW_LINE b -= lst [ i ] NEW_LINE if a >= x and a <= y and b >= x and b <= y : NEW_LINE INDENT ans = i + 2 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_922_A", "sol": 0, "python_code": "x , y = map ( int , input ( ).split ( ) )\nprint ( [ 'No' , 'Yes' ] [ ( x , y ) == ( 0 , 1 ) or x + 2 > y > 1 and ( x - y ) % 2 ] )\n", "python_code_tokenized": "x , y = map ( int , input ( ) . split ( ) ) NEW_LINE print ( [ ' No ' , ' Yes ' ] [ ( x , y ) == ( 0 , 1 ) or x + 2 > y > 1 and ( x - y ) % 2 ] ) NEW_LINE"}
{"id": "codeforces_1428_A", "sol": 0, "python_code": "from cmath import *\nfrom decimal import *\nfrom opcode import HAVE_ARGUMENT\nfrom re import I\nimport sys\nfrom tkinter import N\ninput_ = sys.stdin.readline\ndef _input ( ) : return map ( int , input ( ).split ( ) )\ndef _list ( ) : return list ( map ( int , input ( ).split ( ) ) )\na = [ ]\ndef solves ( a ) :\n    a , b , c , d = _input ( )\n    ans = abs ( a - c ) + abs ( b - d )\n    if ( a != c and b != d ) :\n        ans += 2\n    print ( ans )\nt = 1\nt = int ( input ( ) )\nfor _ in range ( 0 , t ) :\n    solves ( a )\n", "python_code_tokenized": "from cmath import * NEW_LINE from decimal import * NEW_LINE from opcode import HAVE_ARGUMENT NEW_LINE from re import I NEW_LINE import sys NEW_LINE from tkinter import N NEW_LINE input_ = sys . stdin . readline NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def _list ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = [ ] NEW_LINE def solves ( a ) : NEW_LINE INDENT a , b , c , d = _input ( ) NEW_LINE ans = abs ( a - c ) + abs ( b - d ) NEW_LINE if ( a != c and b != d ) : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT t = 1 NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( 0 , t ) : NEW_LINE INDENT solves ( a ) NEW_LINE DEDENT"}
{"id": "codeforces_10_A", "sol": 0, "python_code": "def calculate ( s , e , m ) :\n    t = e - s\n    c = 0\n    if t > m [ 4 ] :\n        c += m [ 4 ] * m [ 1 ]\n        t = t - m [ 4 ]\n    else :\n        c += m [ 1 ] * t\n        t = 0\n    if t > m [ 5 ] :\n        c += m [ 5 ] * m [ 2 ]\n        t = t - m [ 5 ]\n    else :\n        c += m [ 2 ] * t\n        t = 0\n    c += m [ 3 ] * t\n    return c\nwork = [ ]\nm = [ int ( i ) for i in input ( ).split ( \" \" ) ]\nfor i in range ( 0 , m [ 0 ] ) :\n    l = [ int ( i ) for i in input ( ).split ( \" \" ) ]\n    work.append ( l )\nn = len ( work )\npower = 0\nfor i in range ( len ( work ) ) :\n    if i == n - 1 :\n        power += ( work [ i ] [ 1 ] - work [ i ] [ 0 ] ) * m [ 1 ]\n    else :\n        power += calculate ( work [ i ] [ 1 ] , work [ i + 1 ] [ 0 ] , m ) + ( work [ i ] [ 1 ] - work [ i ] [ 0 ] ) * m [ 1 ]\nprint ( power )\n", "python_code_tokenized": "def calculate ( s , e , m ) : NEW_LINE INDENT t = e - s NEW_LINE c = 0 NEW_LINE if t > m [ 4 ] : NEW_LINE INDENT c += m [ 4 ] * m [ 1 ] NEW_LINE t = t - m [ 4 ] NEW_LINE DEDENT else : NEW_LINE INDENT c += m [ 1 ] * t NEW_LINE t = 0 NEW_LINE DEDENT if t > m [ 5 ] : NEW_LINE INDENT c += m [ 5 ] * m [ 2 ] NEW_LINE t = t - m [ 5 ] NEW_LINE DEDENT else : NEW_LINE INDENT c += m [ 2 ] * t NEW_LINE t = 0 NEW_LINE DEDENT c += m [ 3 ] * t NEW_LINE return c NEW_LINE DEDENT work = [ ] NEW_LINE m = [ int ( i ) for i in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE for i in range ( 0 , m [ 0 ] ) : NEW_LINE INDENT l = [ int ( i ) for i in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE work . append ( l ) NEW_LINE DEDENT n = len ( work ) NEW_LINE power = 0 NEW_LINE for i in range ( len ( work ) ) : NEW_LINE INDENT if i == n - 1 : NEW_LINE INDENT power += ( work [ i ] [ 1 ] - work [ i ] [ 0 ] ) * m [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT power += calculate ( work [ i ] [ 1 ] , work [ i + 1 ] [ 0 ] , m ) + ( work [ i ] [ 1 ] - work [ i ] [ 0 ] ) * m [ 1 ] NEW_LINE DEDENT DEDENT print ( power ) NEW_LINE"}
{"id": "aizu_p00196_A", "sol": 0, "python_code": "while True :\n    num = int ( input ( ) )\n    if num == 0 :\n        break\n    L = [ ]\n    for i in range ( num ) :\n        n , * k = input ( ).split ( )\n        L.append ( ( n , k.count ( \"0\" ) , k.count ( \"1\" ) , i ) )\n    L.sort ( key = lambda x : ( - x [ 1 ] , x [ 2 ] , x [ 3 ] ) )\n    for x in L :\n        print ( x [ 0 ] )\n", "python_code_tokenized": "while True : NEW_LINE INDENT num = int ( input ( ) ) NEW_LINE if num == 0 : NEW_LINE INDENT break NEW_LINE DEDENT L = [ ] NEW_LINE for i in range ( num ) : NEW_LINE INDENT n , * k = input ( ) . split ( ) NEW_LINE L . append ( ( n , k . count ( \"0\" ) , k . count ( \"1\" ) , i ) ) NEW_LINE DEDENT L . sort ( key = lambda x : ( - x [ 1 ] , x [ 2 ] , x [ 3 ] ) ) NEW_LINE for x in L : NEW_LINE INDENT print ( x [ 0 ] ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2651_A", "sol": 0, "python_code": "def printPalindrome ( left , mid , right ) :\n    for x in left :\n        print ( x , end = \"\" )\n    print ( mid , end = \"\" )\n    right = right [ : : - 1 ]\n    for x in right :\n        print ( x , end = \"\" )\n    print ( '\\n' , end = \"\" )\ndef findPalindrome ( S , N , M ) :\n    d = set ( )\n    for i in range ( M ) :\n        d.add ( S [ i ] )\n    left = [ ]\n    right = [ ]\n    mid = \"\"\n    for i in range ( N ) :\n        t = S [ i ]\n        t = t [ : : - 1 ]\n        if ( t == S [ i ] ) :\n            mid = t\n        elif ( t in d ) :\n            left.append ( S [ i ] )\n            right.append ( t )\n            d.remove ( S [ i ] )\n            d.remove ( t )\n    printPalindrome ( left , mid , right )\nif __name__ == '__main__' :\n    S = [ \"tab\" , \"one\" , \"bat\" ]\n    M = 3\n    N = len ( S )\n    findPalindrome ( S , N , M )\n", "python_code_tokenized": "def printPalindrome ( left , mid , right ) : NEW_LINE INDENT for x in left : NEW_LINE INDENT print ( x , end = \" \" ) NEW_LINE DEDENT print ( mid , end = \" \" ) NEW_LINE right = right [ : : - 1 ] NEW_LINE for x in right : NEW_LINE INDENT print ( x , end = \" \" ) NEW_LINE DEDENT print ( ' \\n ' , end = \" \" ) NEW_LINE DEDENT def findPalindrome ( S , N , M ) : NEW_LINE INDENT d = set ( ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT d . add ( S [ i ] ) NEW_LINE DEDENT left = [ ] NEW_LINE right = [ ] NEW_LINE mid = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = S [ i ] NEW_LINE t = t [ : : - 1 ] NEW_LINE if ( t == S [ i ] ) : NEW_LINE INDENT mid = t NEW_LINE DEDENT elif ( t in d ) : NEW_LINE INDENT left . append ( S [ i ] ) NEW_LINE right . append ( t ) NEW_LINE d . remove ( S [ i ] ) NEW_LINE d . remove ( t ) NEW_LINE DEDENT DEDENT printPalindrome ( left , mid , right ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = [ \" tab \" , \" one \" , \" bat \" ] NEW_LINE M = 3 NEW_LINE N = len ( S ) NEW_LINE findPalindrome ( S , N , M ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2157_A", "sol": 0, "python_code": "from math import sqrt , log\ndef isPowerful ( n ) :\n    while ( n % 2 == 0 ) :\n        power = 0\n        while ( n % 2 == 0 ) :\n            n /= 2\n            power += 1\n        if ( power == 1 ) :\n            return False\n    p = int ( sqrt ( n ) ) + 1\n    for factor in range ( 3 , p , 2 ) :\n        power = 0\n        while ( n % factor == 0 ) :\n            n = n / factor\n            power += 1\n        if ( power == 1 ) :\n            return False\n    return ( n == 1 )\ndef isPower ( a ) :\n    if ( a == 1 ) :\n        return True\n    p = int ( sqrt ( a ) ) + 1\n    for i in range ( 2 , a , 1 ) :\n        val = log ( a ) / log ( i )\n        if ( ( val - int ( val ) ) < 0.00000001 ) :\n            return True\n    return False\ndef isAchillesNumber ( n ) :\n    if ( isPowerful ( n ) == True and isPower ( n ) == False ) :\n        return True\n    else :\n        return False\nif __name__ == '__main__' :\n    n = 72\n    if ( isAchillesNumber ( n ) ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n    n = 36\n    if ( isAchillesNumber ( n ) ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "from math import sqrt , log NEW_LINE def isPowerful ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n /= 2 NEW_LINE power += 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT p = int ( sqrt ( n ) ) + 1 NEW_LINE for factor in range ( 3 , p , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % factor == 0 ) : NEW_LINE INDENT n = n / factor NEW_LINE power += 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return ( n == 1 ) NEW_LINE DEDENT def isPower ( a ) : NEW_LINE INDENT if ( a == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT p = int ( sqrt ( a ) ) + 1 NEW_LINE for i in range ( 2 , a , 1 ) : NEW_LINE INDENT val = log ( a ) / log ( i ) NEW_LINE if ( ( val - int ( val ) ) < 0.00000001 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def isAchillesNumber ( n ) : NEW_LINE INDENT if ( isPowerful ( n ) == True and isPower ( n ) == False ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 72 NEW_LINE if ( isAchillesNumber ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT n = 36 NEW_LINE if ( isAchillesNumber ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4047_A", "sol": 0, "python_code": "def countTriplets ( A , B , C ) :\n    ans = 0\n    for i in range ( 1 , A + 1 ) :\n        for j in range ( 1 , B + 1 ) :\n            for k in range ( 1 , C + 1 ) :\n                if ( i * k > j * j ) :\n                    ans += 1\n    return ans\nA = 3\nB = 2\nC = 2\nprint ( countTriplets ( A , B , C ) )\n", "python_code_tokenized": "def countTriplets ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT if ( i * k > j * j ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT A = 3 NEW_LINE B = 2 NEW_LINE C = 2 NEW_LINE print ( countTriplets ( A , B , C ) ) NEW_LINE"}
{"id": "codeforces_1395_A", "sol": 0, "python_code": "for s in [ * open ( 0 ) ] [ 1 : ] :\n    a = s.split ( )\n    n = sum ( int ( x ) % 2 for x in a )\n    print ( 'YNeos' [ n == 2 or n > 2 and '0' in a [ : 3 ] : : 2 ] )\n", "python_code_tokenized": "for s in [ * open ( 0 ) ] [ 1 : ] : NEW_LINE INDENT a = s . split ( ) NEW_LINE n = sum ( int ( x ) % 2 for x in a ) NEW_LINE print ( ' YNeos ' [ n == 2 or n > 2 and '0' in a [ : 3 ] : : 2 ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1852_A", "sol": 0, "python_code": "def isAMultipleOf4 ( n ) :\n    if ( ( n & 3 ) == 0 ) :\n        return \"Yes\"\n    return \"No\"\nif __name__ == \"__main__\" :\n    n = 16\n    print ( isAMultipleOf4 ( n ) )\n", "python_code_tokenized": "def isAMultipleOf4 ( n ) : NEW_LINE INDENT if ( ( n & 3 ) == 0 ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT return \" No \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 16 NEW_LINE print ( isAMultipleOf4 ( n ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00159_A", "sol": 0, "python_code": "while True :\n    N = input ( )\n    if not N :\n        break\n    a , b = - 1 , 100000000\n    for j in range ( N ) :\n        i , h , w = map ( int , raw_input ( ).split ( ) )\n        h /= 100.00\n        bmi = w / ( h * h )\n        if abs ( bmi - 22 ) < b :\n            b = abs ( bmi - 22 )\n            a = i\n    print ( a )\n", "python_code_tokenized": "while True : NEW_LINE INDENT N = input ( ) NEW_LINE if not N : NEW_LINE INDENT break NEW_LINE DEDENT a , b = - 1 , 100000000 NEW_LINE for j in range ( N ) : NEW_LINE INDENT i , h , w = map ( int , raw_input ( ) . split ( ) ) NEW_LINE h /= 100.00 NEW_LINE bmi = w / ( h * h ) NEW_LINE if abs ( bmi - 22 ) < b : NEW_LINE INDENT b = abs ( bmi - 22 ) NEW_LINE a = i NEW_LINE DEDENT DEDENT print ( a ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2246_A", "sol": 0, "python_code": "import numpy as np\nmax_size = 20\nmax_k = 20\ndp = np.zeros ( ( max_size , max_k ) ) ;\nv = np.zeros ( ( max_size , max_k ) ) ;\nsum = 0 ;\ndef findSum ( arr , n ) :\n    global sum\n    for i in range ( n ) :\n        sum += arr [ i ] ;\ndef cntWays ( arr , i , ck , k , n , curr_sum ) :\n    if ( sum % k != 0 ) :\n        return 0 ;\n    if ( i != n and ck == k + 1 ) :\n        return 0 ;\n    if ( i == n ) :\n        if ( ck == k + 1 ) :\n            return 1 ;\n        else :\n            return 0 ;\n    if ( v [ i ] [ ck ] ) :\n        return dp [ i ] [ ck ] ;\n    curr_sum += arr [ i ] ;\n    v [ i ] [ ck ] = 1 ;\n    dp [ i ] [ ck ] = cntWays ( arr , i + 1 , ck , k , n , curr_sum ) ;\n    if ( curr_sum == ( sum / k ) * ck ) :\n        dp [ i ] [ ck ] += cntWays ( arr , i + 1 , ck + 1 , k , n , curr_sum ) ;\n    return dp [ i ] [ ck ] ;\nif __name__ == \"__main__\" :\n    arr = [ 1 , - 1 , 1 , - 1 , 1 , - 1 ] ;\n    n = len ( arr ) ;\n    k = 2 ;\n    findSum ( arr , n ) ;\n    print ( cntWays ( arr , 0 , 1 , k , n , 0 ) ) ;\n", "python_code_tokenized": "import numpy as np NEW_LINE max_size = 20 NEW_LINE max_k = 20 NEW_LINE dp = np . zeros ( ( max_size , max_k ) ) ; NEW_LINE v = np . zeros ( ( max_size , max_k ) ) ; NEW_LINE sum = 0 ; NEW_LINE def findSum ( arr , n ) : NEW_LINE INDENT global sum NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT DEDENT def cntWays ( arr , i , ck , k , n , curr_sum ) : NEW_LINE INDENT if ( sum % k != 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( i != n and ck == k + 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT if ( ck == k + 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ ck ] ) : NEW_LINE INDENT return dp [ i ] [ ck ] ; NEW_LINE DEDENT curr_sum += arr [ i ] ; NEW_LINE v [ i ] [ ck ] = 1 ; NEW_LINE dp [ i ] [ ck ] = cntWays ( arr , i + 1 , ck , k , n , curr_sum ) ; NEW_LINE if ( curr_sum == ( sum / k ) * ck ) : NEW_LINE INDENT dp [ i ] [ ck ] += cntWays ( arr , i + 1 , ck + 1 , k , n , curr_sum ) ; NEW_LINE DEDENT return dp [ i ] [ ck ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , - 1 , 1 , - 1 , 1 , - 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE findSum ( arr , n ) ; NEW_LINE print ( cntWays ( arr , 0 , 1 , k , n , 0 ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_163_A", "sol": 0, "python_code": "import math\ndef findLargestDivisor ( n ) :\n    for i in range ( 2 , int ( math.sqrt ( n ) ) + 1 ) :\n        while ( n % ( i * i ) == 0 ) :\n            n = n // i\n    return n\nif __name__ == \"__main__\" :\n    n = 12\n    print ( findLargestDivisor ( n ) )\n    n = 97\n    print ( findLargestDivisor ( n ) )\n", "python_code_tokenized": "import math NEW_LINE def findLargestDivisor ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT while ( n % ( i * i ) == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 12 NEW_LINE print ( findLargestDivisor ( n ) ) NEW_LINE n = 97 NEW_LINE print ( findLargestDivisor ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_797_A", "sol": 0, "python_code": "import math\ndef findCount ( d ) :\n    return 9 * ( pow ( 10 , d - 1 ) - pow ( 9 , d - 1 ) ) ;\ndef findCountUpto ( d ) :\n    totalCount = 0\n    for i in range ( 1 , d + 1 ) :\n        totalCount = totalCount + findCount ( i )\n    return totalCount\nd = 1\nprint ( findCountUpto ( d ) )\nd = 2\nprint ( findCountUpto ( d ) )\nd = 4\nprint ( findCountUpto ( d ) )\n", "python_code_tokenized": "import math NEW_LINE def findCount ( d ) : NEW_LINE INDENT return 9 * ( pow ( 10 , d - 1 ) - pow ( 9 , d - 1 ) ) ; NEW_LINE DEDENT def findCountUpto ( d ) : NEW_LINE INDENT totalCount = 0 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT totalCount = totalCount + findCount ( i ) NEW_LINE DEDENT return totalCount NEW_LINE DEDENT d = 1 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE d = 2 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE d = 4 NEW_LINE print ( findCountUpto ( d ) ) NEW_LINE"}
{"id": "geeksforgeeks_4114_A", "sol": 0, "python_code": "MAX_CHAR = [ 26 ]\ndef minChanges ( str ) :\n    n = len ( str )\n    if ( n > MAX_CHAR [ 0 ] ) :\n        return - 1\n    dist_count = 0\n    count = [ 0 ] * MAX_CHAR [ 0 ]\n    for i in range ( n ) :\n        if ( count [ ord ( str [ i ] ) - ord ( 'a' ) ] == 0 ) :\n            dist_count += 1\n        count [ ( ord ( str [ i ] ) - ord ( 'a' ) ) ] += 1\n    return ( n - dist_count )\nif __name__ == '__main__' :\n    str = \"aebaecedabbee\"\n    print ( minChanges ( str ) )\n", "python_code_tokenized": "MAX_CHAR = [ 26 ] NEW_LINE def minChanges ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n > MAX_CHAR [ 0 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE count = [ 0 ] * MAX_CHAR [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( count [ ord ( str [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT count [ ( ord ( str [ i ] ) - ord ( ' a ' ) ) ] += 1 NEW_LINE DEDENT return ( n - dist_count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" aebaecedabbee \" NEW_LINE print ( minChanges ( str ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1657_B", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\ninf = float ( 'inf' )\ndef getInt ( ) :\n    return int ( input ( ) )\ndef getStr ( ) :\n    return input ( ).strip ( )\ndef getList ( split = True ) :\n    s = getStr ( )\n    if split :\n        s = s.split ( )\n    return map ( int , s )\nt = getInt ( )\ndef solve ( ) :\n    n , B , x , y = getList ( )\n    c = res = 0\n    for i in range ( n ) :\n        if c + x <= B :\n            c += x\n        else :\n            c -= y\n        res += c\n    print ( res )\nfor _ in range ( t ) :\n    solve ( )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE inf = float ( ' inf ' ) NEW_LINE def getInt ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def getStr ( ) : NEW_LINE INDENT return input ( ) . strip ( ) NEW_LINE DEDENT def getList ( split = True ) : NEW_LINE INDENT s = getStr ( ) NEW_LINE if split : NEW_LINE INDENT s = s . split ( ) NEW_LINE DEDENT return map ( int , s ) NEW_LINE DEDENT t = getInt ( ) NEW_LINE def solve ( ) : NEW_LINE INDENT n , B , x , y = getList ( ) NEW_LINE c = res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if c + x <= B : NEW_LINE INDENT c += x NEW_LINE DEDENT else : NEW_LINE INDENT c -= y NEW_LINE DEDENT res += c NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT for _ in range ( t ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1370_A", "sol": 0, "python_code": "import math\ndef maxCommonFactors ( a , b ) :\n    gcd = math.gcd ( a , b )\n    ans = 1 ;\n    i = 2\n    while ( i * i <= gcd ) :\n        if ( gcd % i == 0 ) :\n            ans += 1\n            while ( gcd % i == 0 ) :\n                gcd = gcd // i\n        i += 1\n    if ( gcd != 1 ) :\n        ans += 1\n    return ans\na = 12\nb = 18\nprint ( maxCommonFactors ( a , b ) )\n", "python_code_tokenized": "import math NEW_LINE def maxCommonFactors ( a , b ) : NEW_LINE INDENT gcd = math . gcd ( a , b ) NEW_LINE ans = 1 ; NEW_LINE i = 2 NEW_LINE while ( i * i <= gcd ) : NEW_LINE INDENT if ( gcd % i == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE while ( gcd % i == 0 ) : NEW_LINE INDENT gcd = gcd // i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( gcd != 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT a = 12 NEW_LINE b = 18 NEW_LINE print ( maxCommonFactors ( a , b ) ) NEW_LINE"}
{"id": "aizu_p02429_A", "sol": 0, "python_code": "n = int ( input ( ) )\nk , * b = map ( int , input ( ).split ( ) )\nt = sum ( 1 << i for i in b )\nfor i in range ( 1 << k ) :\n    tmp = 0\n    rs = [ ]\n    for j in range ( k ) :\n        if i & ( 1 << j ) != 0 :\n            tmp |= 1 << b [ j ]\n            rs.append ( b [ j ] )\n    print ( str ( tmp ) + \":\" , * rs )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE k , * b = map ( int , input ( ) . split ( ) ) NEW_LINE t = sum ( 1 << i for i in b ) NEW_LINE for i in range ( 1 << k ) : NEW_LINE INDENT tmp = 0 NEW_LINE rs = [ ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT if i & ( 1 << j ) != 0 : NEW_LINE INDENT tmp |= 1 << b [ j ] NEW_LINE rs . append ( b [ j ] ) NEW_LINE DEDENT DEDENT print ( str ( tmp ) + \" : \" , * rs ) NEW_LINE DEDENT"}
{"id": "codeforces_1296_B", "sol": 0, "python_code": "for t in range ( int ( input ( ) ) ) :\n    s = int ( input ( ) )\n    t = 0\n    while ( s >= 10 ) :\n        r = s % 10\n        t += s - r\n        s = s // 10 + r\n    print ( t + s )\n", "python_code_tokenized": "for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = int ( input ( ) ) NEW_LINE t = 0 NEW_LINE while ( s >= 10 ) : NEW_LINE INDENT r = s % 10 NEW_LINE t += s - r NEW_LINE s = s // 10 + r NEW_LINE DEDENT print ( t + s ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1609_A", "sol": 0, "python_code": "N = 3\nM = 7\ndef printOriginalMatrix ( a , b , mat ) :\n    for i in range ( N ) :\n        for j in range ( M ) :\n            if ( mat [ i ] [ j ] == 1 ) :\n                print ( min ( a [ i ] , b [ j ] ) , end = \" \" ) ;\n            else :\n                print ( 0 , end = \" \" ) ;\n        print ( )\nif __name__ == \"__main__\" :\n    a = [ 2 , 1 , 3 ]\n    b = [ 2 , 3 , 0 , 0 , 2 , 0 , 1 ]\n    mat = [ [ 1 , 0 , 0 , 0 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 1 ] , [ 1 , 1 , 0 , 0 , 0 , 0 , 0 ] ] ;\n    printOriginalMatrix ( a , b , mat ) ;\n", "python_code_tokenized": "N = 3 NEW_LINE M = 7 NEW_LINE def printOriginalMatrix ( a , b , mat ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT print ( min ( a [ i ] , b [ j ] ) , end = \" \u2581 \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 1 , 3 ] NEW_LINE b = [ 2 , 3 , 0 , 0 , 2 , 0 , 1 ] NEW_LINE mat = [ [ 1 , 0 , 0 , 0 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 1 ] , [ 1 , 1 , 0 , 0 , 0 , 0 , 0 ] ] ; NEW_LINE printOriginalMatrix ( a , b , mat ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4738_A", "sol": 0, "python_code": "def PositionRightmostSetbit ( n ) :\n    position = 1\n    m = 1\n    while ( not ( n & m ) ) :\n        m = m << 1\n        position += 1\n    return position\nn = 16\nprint ( PositionRightmostSetbit ( n ) )\n", "python_code_tokenized": "def PositionRightmostSetbit ( n ) : NEW_LINE INDENT position = 1 NEW_LINE m = 1 NEW_LINE while ( not ( n & m ) ) : NEW_LINE INDENT m = m << 1 NEW_LINE position += 1 NEW_LINE DEDENT return position NEW_LINE DEDENT n = 16 NEW_LINE print ( PositionRightmostSetbit ( n ) ) NEW_LINE"}
{"id": "codeforces_1546_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    n = int ( input ( ) )\n    a = [ int ( i ) for i in input ( ).split ( ) ]\n    b = [ int ( i ) for i in input ( ).split ( ) ]\n    if sum ( a ) != sum ( b ) :\n        print ( \"-1\" )\n        continue\n    for i in range ( n ) :\n        a [ i ] -= b [ i ]\n    p = sum ( a [ i ] for i in range ( n ) if a [ i ] > 0 )\n    print ( p )\n    i , j = 0 , 0\n    while p :\n        while i < n and a [ i ] <= 0 :\n            i += 1\n        while j < n and a [ j ] >= 0 :\n            j += 1\n        a [ i ] -= 1\n        a [ j ] += 1\n        print ( i + 1 , j + 1 )\n        p -= 1\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if sum ( a ) != sum ( b ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE continue NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] -= b [ i ] NEW_LINE DEDENT p = sum ( a [ i ] for i in range ( n ) if a [ i ] > 0 ) NEW_LINE print ( p ) NEW_LINE i , j = 0 , 0 NEW_LINE while p : NEW_LINE INDENT while i < n and a [ i ] <= 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while j < n and a [ j ] >= 0 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT a [ i ] -= 1 NEW_LINE a [ j ] += 1 NEW_LINE print ( i + 1 , j + 1 ) NEW_LINE p -= 1 NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3885_A", "sol": 0, "python_code": "from math import gcd , sqrt\ndef coprime ( a , b ) :\n    if ( gcd ( a , b ) == 1 ) :\n        return True ;\n    else :\n        return False ;\ndef isPrime ( n ) :\n    if ( n <= 1 ) :\n        return False ;\n    if ( n == 2 or n == 3 ) :\n        return True ;\n    for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) :\n        if ( n % i == 0 ) :\n            return False ;\n    return True ;\ndef findNumbers ( a , b , n ) :\n    possible = True ;\n    if ( not coprime ( a , b ) ) :\n        possible = False ;\n    c1 = 1 ;\n    c2 = 1 ;\n    num1 = 0 ;\n    num2 = 0 ;\n    st = set ( ) ;\n    if ( possible ) :\n        while ( len ( st ) != n ) :\n            num1 = a + ( c1 * b ) ;\n            if ( isPrime ( num1 ) ) :\n                st.add ( num1 ) ;\n            c1 += 1 ;\n            num2 = b + ( c2 * a ) ;\n            if ( isPrime ( num2 ) ) :\n                st.add ( num2 ) ;\n            c2 += 1 ;\n        for i in st :\n            print ( i , end = \" \" ) ;\n    else :\n        print ( \"-1\" ) ;\nif __name__ == \"__main__\" :\n    a = 3 ;\n    b = 5 ;\n    n = 4 ;\n    findNumbers ( a , b , n ) ;\n", "python_code_tokenized": "from math import gcd , sqrt NEW_LINE def coprime ( a , b ) : NEW_LINE INDENT if ( gcd ( a , b ) == 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( n == 2 or n == 3 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def findNumbers ( a , b , n ) : NEW_LINE INDENT possible = True ; NEW_LINE if ( not coprime ( a , b ) ) : NEW_LINE INDENT possible = False ; NEW_LINE DEDENT c1 = 1 ; NEW_LINE c2 = 1 ; NEW_LINE num1 = 0 ; NEW_LINE num2 = 0 ; NEW_LINE st = set ( ) ; NEW_LINE if ( possible ) : NEW_LINE INDENT while ( len ( st ) != n ) : NEW_LINE INDENT num1 = a + ( c1 * b ) ; NEW_LINE if ( isPrime ( num1 ) ) : NEW_LINE INDENT st . add ( num1 ) ; NEW_LINE DEDENT c1 += 1 ; NEW_LINE num2 = b + ( c2 * a ) ; NEW_LINE if ( isPrime ( num2 ) ) : NEW_LINE INDENT st . add ( num2 ) ; NEW_LINE DEDENT c2 += 1 ; NEW_LINE DEDENT for i in st : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 ; NEW_LINE b = 5 ; NEW_LINE n = 4 ; NEW_LINE findNumbers ( a , b , n ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1942_A", "sol": 0, "python_code": "def convertToString ( sum ) :\n    str1 = \"\"\n    while ( sum ) :\n        str1 = str1 + chr ( ( sum % 10 ) + ord ( '0' ) )\n        sum = sum // 10\n    return str1\ndef GetIndividulaDigitSum ( str1 , len1 ) :\n    sum = 0\n    for i in range ( len1 ) :\n        sum = sum + ord ( str1 [ i ] ) - ord ( '0' )\n    return convertToString ( sum )\ndef GetDigitalRoot ( str1 ) :\n    if ( len ( str1 ) == 1 ) :\n        return ord ( str1 [ 0 ] ) - ord ( '0' )\n    str1 = GetIndividulaDigitSum ( str1 , len ( str1 ) )\n    return GetDigitalRoot ( str1 )\nif __name__ == '__main__' :\n    str1 = \"675987890789756545689070986776987\"\n    print ( GetDigitalRoot ( str1 ) )\n", "python_code_tokenized": "def convertToString ( sum ) : NEW_LINE INDENT str1 = \" \" NEW_LINE while ( sum ) : NEW_LINE INDENT str1 = str1 + chr ( ( sum % 10 ) + ord ( '0' ) ) NEW_LINE sum = sum // 10 NEW_LINE DEDENT return str1 NEW_LINE DEDENT def GetIndividulaDigitSum ( str1 , len1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT sum = sum + ord ( str1 [ i ] ) - ord ( '0' ) NEW_LINE DEDENT return convertToString ( sum ) NEW_LINE DEDENT def GetDigitalRoot ( str1 ) : NEW_LINE INDENT if ( len ( str1 ) == 1 ) : NEW_LINE INDENT return ord ( str1 [ 0 ] ) - ord ( '0' ) NEW_LINE DEDENT str1 = GetIndividulaDigitSum ( str1 , len ( str1 ) ) NEW_LINE return GetDigitalRoot ( str1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \"675987890789756545689070986776987\" NEW_LINE print ( GetDigitalRoot ( str1 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1497_A", "sol": 0, "python_code": "def splitStrings ( st , dl ) :\n    word = \"\"\n    num = 0\n    st += dl\n    l = len ( st )\n    substr_list = [ ]\n    for i in range ( l ) :\n        if ( st [ i ] != dl ) :\n            word += st [ i ]\n        else :\n            if ( len ( word ) != 0 ) :\n                substr_list.append ( word )\n            word = \"\"\n    return substr_list\nif __name__ == '__main__' :\n    str = \"geeks;for;geeks\"\n    dl = ';'\n    res = splitStrings ( str , dl )\n    for x in range ( len ( res ) ) :\n        print ( res [ x ] )\n", "python_code_tokenized": "def splitStrings ( st , dl ) : NEW_LINE INDENT word = \" \" NEW_LINE num = 0 NEW_LINE st += dl NEW_LINE l = len ( st ) NEW_LINE substr_list = [ ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( st [ i ] != dl ) : NEW_LINE INDENT word += st [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( word ) != 0 ) : NEW_LINE INDENT substr_list . append ( word ) NEW_LINE DEDENT word = \" \" NEW_LINE DEDENT DEDENT return substr_list NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeks ; for ; geeks \" NEW_LINE dl = ' ; ' NEW_LINE res = splitStrings ( str , dl ) NEW_LINE for x in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ x ] ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC144_F", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nN , M = map ( int , input ( ).split ( ) )\nu = [ [ ] for i in range ( N - 1 ) ]\nfor i in range ( M ) :\n    s , t = map ( int , input ( ).split ( ) )\n    u [ s - 1 ].append ( t - 1 )\np = [ 0 ] * N\np [ 0 ] = 1\nfor x , y in enumerate ( u ) :\n    for z in y :\n        p [ z ] += p [ x ] / len ( y )\nq = [ 0 ] * N\nq [ N - 1 ] = 0\nfor x , y in list ( enumerate ( u ) ) [ : : - 1 ] :\n    q [ x ] = sum ( q [ z ] for z in y ) / len ( y ) + 1\nv = [ 0 ] * N\nfor i in range ( N - 1 ) :\n    a = len ( u [ i ] )\n    if a > 1 :\n        b = max ( q [ c ] for c in u [ i ] )\n        v [ i ] = p [ i ] * ( q [ i ] - ( 1 + b ) ) / ( a - 1 )\nprint ( q [ 0 ] + min ( v ) )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE u = [ [ ] for i in range ( N - 1 ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT s , t = map ( int , input ( ) . split ( ) ) NEW_LINE u [ s - 1 ] . append ( t - 1 ) NEW_LINE DEDENT p = [ 0 ] * N NEW_LINE p [ 0 ] = 1 NEW_LINE for x , y in enumerate ( u ) : NEW_LINE INDENT for z in y : NEW_LINE INDENT p [ z ] += p [ x ] / len ( y ) NEW_LINE DEDENT DEDENT q = [ 0 ] * N NEW_LINE q [ N - 1 ] = 0 NEW_LINE for x , y in list ( enumerate ( u ) ) [ : : - 1 ] : NEW_LINE INDENT q [ x ] = sum ( q [ z ] for z in y ) / len ( y ) + 1 NEW_LINE DEDENT v = [ 0 ] * N NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT a = len ( u [ i ] ) NEW_LINE if a > 1 : NEW_LINE INDENT b = max ( q [ c ] for c in u [ i ] ) NEW_LINE v [ i ] = p [ i ] * ( q [ i ] - ( 1 + b ) ) / ( a - 1 ) NEW_LINE DEDENT DEDENT print ( q [ 0 ] + min ( v ) ) NEW_LINE"}
{"id": "geeksforgeeks_411_A", "sol": 0, "python_code": "MOD = 1000000007\nmax = 101\nC = [ [ 0 for i in range ( max ) ] for j in range ( max ) ]\ndef power ( x , y ) :\n    res = 1\n    x = x % MOD\n    while ( y > 0 ) :\n        if ( y & 1 ) :\n            res = ( res * x ) % MOD\n        y = y >> 1\n        x = ( x * x ) % MOD\n    return res % MOD\ndef combi ( n , k ) :\n    for i in range ( n + 1 ) :\n        for j in range ( min ( i , k ) + 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] % MOD + C [ i - 1 ] [ j ] % MOD ) % MOD\ndef product ( a , n , k ) :\n    ans = 1\n    a.sort ( reverse = False )\n    powa = C [ n - 1 ] [ k - 1 ]\n    for i in range ( n ) :\n        powla = C [ i ] [ k - 1 ]\n        powfa = C [ n - i - 1 ] [ k - 1 ]\n        powe = ( ( powa % MOD ) - ( powla + powfa ) % MOD + MOD ) % MOD\n        mul = power ( a [ i ] , powe ) % MOD\n        ans = ( ( ans % MOD ) * ( mul % MOD ) ) % MOD\n    return ans % MOD\nif __name__ == '__main__' :\n    combi ( 100 , 100 )\n    arr = [ 1 , 2 , 3 , 4 ]\n    n = len ( arr )\n    k = 3\n    ans = product ( arr , n , k )\n    print ( ans )\n", "python_code_tokenized": "MOD = 1000000007 NEW_LINE max = 101 NEW_LINE C = [ [ 0 for i in range ( max ) ] for j in range ( max ) ] NEW_LINE def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % MOD NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % MOD NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % MOD NEW_LINE DEDENT return res % MOD NEW_LINE DEDENT def combi ( n , k ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] % MOD + C [ i - 1 ] [ j ] % MOD ) % MOD NEW_LINE DEDENT DEDENT DEDENT DEDENT def product ( a , n , k ) : NEW_LINE INDENT ans = 1 NEW_LINE a . sort ( reverse = False ) NEW_LINE powa = C [ n - 1 ] [ k - 1 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT powla = C [ i ] [ k - 1 ] NEW_LINE powfa = C [ n - i - 1 ] [ k - 1 ] NEW_LINE powe = ( ( powa % MOD ) - ( powla + powfa ) % MOD + MOD ) % MOD NEW_LINE mul = power ( a [ i ] , powe ) % MOD NEW_LINE ans = ( ( ans % MOD ) * ( mul % MOD ) ) % MOD NEW_LINE DEDENT return ans % MOD NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT combi ( 100 , 100 ) NEW_LINE arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE ans = product ( arr , n , k ) NEW_LINE print ( ans ) NEW_LINE DEDENT"}
{"id": "codeforces_1688_B", "sol": 0, "python_code": "for i in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    values = list ( map ( int , input ( ).split ( ) ) )\n    od = 0\n    ev = 0\n    o = [ ]\n    e = [ ]\n    for val in values :\n        if val % 2 == 0 :\n            e.append ( val )\n            ev += 1\n        else :\n            o.append ( val )\n            od += 1\n    if ev == od :\n        print ( od )\n    elif od > ev :\n        print ( ev )\n    else :\n        if od != 0 :\n            print ( ev )\n        else :\n            total = ev - 1\n            mi = 1000000000\n            for val in e :\n                x = 0\n                while val % 2 == 0 :\n                    val /= 2\n                    x += 1\n                mi = min ( mi , x )\n            print ( total + mi )\n", "python_code_tokenized": "for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE values = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE od = 0 NEW_LINE ev = 0 NEW_LINE o = [ ] NEW_LINE e = [ ] NEW_LINE for val in values : NEW_LINE INDENT if val % 2 == 0 : NEW_LINE INDENT e . append ( val ) NEW_LINE ev += 1 NEW_LINE DEDENT else : NEW_LINE INDENT o . append ( val ) NEW_LINE od += 1 NEW_LINE DEDENT DEDENT if ev == od : NEW_LINE INDENT print ( od ) NEW_LINE DEDENT elif od > ev : NEW_LINE INDENT print ( ev ) NEW_LINE DEDENT else : NEW_LINE INDENT if od != 0 : NEW_LINE INDENT print ( ev ) NEW_LINE DEDENT else : NEW_LINE INDENT total = ev - 1 NEW_LINE mi = 1000000000 NEW_LINE for val in e : NEW_LINE INDENT x = 0 NEW_LINE while val % 2 == 0 : NEW_LINE INDENT val /= 2 NEW_LINE x += 1 NEW_LINE DEDENT mi = min ( mi , x ) NEW_LINE DEDENT print ( total + mi ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_1843_A", "sol": 0, "python_code": "def msb ( x ) :\n    ret = 0\n    while ( ( x >> ( ret + 1 ) ) != 0 ) :\n        ret = ret + 1\n    return ret\ndef xorRange ( l , r ) :\n    max_bit = msb ( r )\n    mul = 2\n    ans = 0\n    for i in range ( 1 , max_bit + 1 ) :\n        if ( ( l // mul ) * mul == ( r // mul ) * mul ) :\n            if ( ( ( ( l & ( 1 << i ) ) != 0 ) and ( r - l + 1 ) % 2 == 1 ) ) :\n                ans = ans + mul\n            mul = mul * 2\n            continue\n        odd_c = 0\n        if ( ( ( l & ( 1 << i ) ) != 0 ) and l % 2 == 1 ) :\n            odd_c = ( odd_c ^ 1 )\n        if ( ( ( r & ( 1 << i ) ) != 0 ) and r % 2 == 0 ) :\n            odd_c = ( odd_c ^ 1 )\n        if ( odd_c ) :\n            ans = ans + mul\n        mul = mul * 2\n    zero_bit_cnt = ( r - l + 1 ) // 2\n    if ( ( l % 2 == 1 ) and ( r % 2 == 1 ) ) :\n        zero_bit_cnt = zero_bit_cnt + 1\n    if ( zero_bit_cnt % 2 == 1 ) :\n        ans = ans + 1\n    return ans\nl = 1\nr = 4\nprint ( xorRange ( l , r ) )\n", "python_code_tokenized": "def msb ( x ) : NEW_LINE INDENT ret = 0 NEW_LINE while ( ( x >> ( ret + 1 ) ) != 0 ) : NEW_LINE INDENT ret = ret + 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT def xorRange ( l , r ) : NEW_LINE INDENT max_bit = msb ( r ) NEW_LINE mul = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , max_bit + 1 ) : NEW_LINE INDENT if ( ( l // mul ) * mul == ( r // mul ) * mul ) : NEW_LINE INDENT if ( ( ( ( l & ( 1 << i ) ) != 0 ) and ( r - l + 1 ) % 2 == 1 ) ) : NEW_LINE INDENT ans = ans + mul NEW_LINE DEDENT mul = mul * 2 NEW_LINE continue NEW_LINE DEDENT odd_c = 0 NEW_LINE if ( ( ( l & ( 1 << i ) ) != 0 ) and l % 2 == 1 ) : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( ( ( r & ( 1 << i ) ) != 0 ) and r % 2 == 0 ) : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( odd_c ) : NEW_LINE INDENT ans = ans + mul NEW_LINE DEDENT mul = mul * 2 NEW_LINE DEDENT zero_bit_cnt = ( r - l + 1 ) // 2 NEW_LINE if ( ( l % 2 == 1 ) and ( r % 2 == 1 ) ) : NEW_LINE INDENT zero_bit_cnt = zero_bit_cnt + 1 NEW_LINE DEDENT if ( zero_bit_cnt % 2 == 1 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT l = 1 NEW_LINE r = 4 NEW_LINE print ( xorRange ( l , r ) ) NEW_LINE"}
{"id": "geeksforgeeks_3365_A", "sol": 0, "python_code": "def isPalindrome ( str ) :\n    l = 0\n    h = len ( str ) - 1\n    while ( h > l ) :\n        if ( str [ l ] != str [ h ] ) :\n            return 0\n        l = l + 1\n        h = h - 1\n    return 1\ndef minRemovals ( str ) :\n    if ( str [ 0 ] == '' ) :\n        return 0\n    if ( isPalindrome ( str ) ) :\n        return 1\n    return 2\nprint ( minRemovals ( \"010010\" ) )\nprint ( minRemovals ( \"0100101\" ) )\n", "python_code_tokenized": "def isPalindrome ( str ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( str ) - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ h ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = l + 1 NEW_LINE h = h - 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def minRemovals ( str ) : NEW_LINE INDENT if ( str [ 0 ] == ' ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( isPalindrome ( str ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT print ( minRemovals ( \"010010\" ) ) NEW_LINE print ( minRemovals ( \"0100101\" ) ) NEW_LINE"}
{"id": "codeforces_1445_B", "sol": 0, "python_code": "cases = int ( input ( ) )\nfor i in range ( cases ) :\n    a , b , c , d = map ( int , input ( ).split ( ) )\n    print ( max ( a + b , c + d ) )\n", "python_code_tokenized": "cases = int ( input ( ) ) NEW_LINE for i in range ( cases ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( a + b , c + d ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3289_A", "sol": 0, "python_code": "def countSubStr ( st , n ) :\n    m = 0\n    for i in range ( 0 , n ) :\n        if ( st [ i ] == '1' ) :\n            m = m + 1\n    return m * ( m - 1 ) // 2\nst = \"00100101\" ;\nlist ( st )\nn = len ( st )\nprint ( countSubStr ( st , n ) , end = \"\" )\n", "python_code_tokenized": "def countSubStr ( st , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT m = m + 1 NEW_LINE DEDENT DEDENT return m * ( m - 1 ) // 2 NEW_LINE DEDENT st = \"00100101\" ; NEW_LINE list ( st ) NEW_LINE n = len ( st ) NEW_LINE print ( countSubStr ( st , n ) , end = \" \" ) NEW_LINE"}
{"id": "geeksforgeeks_5056_A", "sol": 0, "python_code": "NO_OF_CHARS = 256\ndef areAnagram ( str1 : str , str2 : str ) -> bool :\n    count = [ 0 ] * NO_OF_CHARS\n    i = 0\n    while i < len ( str1 ) and i < len ( str2 ) :\n        count [ ord ( str1 [ i ] ) ] += 1\n        count [ ord ( str2 [ i ] ) ] -= 1\n        i += 1\n    if len ( str1 ) != len ( str2 ) :\n        return False\n    for i in range ( NO_OF_CHARS ) :\n        if count [ i ] :\n            return False\n        return True\ndef findAllAnagrams ( arr : list , n : int ) :\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            if areAnagram ( arr [ i ] , arr [ j ] ) :\n                print ( arr [ i ] , \"is anagram of\" , arr [ j ] )\nif __name__ == \"__main__\" :\n    arr = [ \"geeksquiz\" , \"geeksforgeeks\" , \"abcd\" , \"forgeeksgeeks\" , \"zuiqkeegs\" ]\n    n = len ( arr )\n    findAllAnagrams ( arr , n )\n", "python_code_tokenized": "NO_OF_CHARS = 256 NEW_LINE def areAnagram ( str1 : str , str2 : str ) -> bool : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) and i < len ( str2 ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) ] += 1 NEW_LINE count [ ord ( str2 [ i ] ) ] -= 1 NEW_LINE i += 1 NEW_LINE DEDENT if len ( str1 ) != len ( str2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if count [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT def findAllAnagrams ( arr : list , n : int ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if areAnagram ( arr [ i ] , arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , \" is \u2581 anagram \u2581 of \" , arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeksquiz \" , \" geeksforgeeks \" , \" abcd \" , \" forgeeksgeeks \" , \" zuiqkeegs \" ] NEW_LINE n = len ( arr ) NEW_LINE findAllAnagrams ( arr , n ) NEW_LINE DEDENT"}
{"id": "codeforces_1491_A", "sol": 0, "python_code": "n , q = map ( int , input ( ).split ( ) )\nli = list ( map ( int , input ( ).split ( ) ) )\nones = li.count ( 1 )\nfor _ in range ( q ) :\n    t , xork = map ( int , input ( ).split ( ) )\n    if t == 1 :\n        temp = 1 - li [ xork - 1 ]\n        li [ xork - 1 ] = temp\n        if temp == 0 :\n            ones -= 1\n        else :\n            ones += 1\n    else :\n        print ( 1 if xork <= ones else 0 )\n", "python_code_tokenized": "n , q = map ( int , input ( ) . split ( ) ) NEW_LINE li = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ones = li . count ( 1 ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT t , xork = map ( int , input ( ) . split ( ) ) NEW_LINE if t == 1 : NEW_LINE INDENT temp = 1 - li [ xork - 1 ] NEW_LINE li [ xork - 1 ] = temp NEW_LINE if temp == 0 : NEW_LINE INDENT ones -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( 1 if xork <= ones else 0 ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4732_A", "sol": 0, "python_code": "def MinOfCubed ( k ) :\n    if ( k < 8 ) :\n        return k ;\n    res = k ;\n    for i in range ( 1 , k + 1 ) :\n        if ( ( i * i * i ) > k ) :\n            return res ;\n        res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ;\n    return res ;\nnum = 15 ;\nprint ( MinOfCubed ( num ) ) ;\n", "python_code_tokenized": "def MinOfCubed ( k ) : NEW_LINE INDENT if ( k < 8 ) : NEW_LINE INDENT return k ; NEW_LINE DEDENT res = k ; NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ( i * i * i ) > k ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT num = 15 ; NEW_LINE print ( MinOfCubed ( num ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_915_A", "sol": 0, "python_code": "def lastFiveDigits ( n ) :\n    n = ( ( int ) ( n / 10000 ) * 10000 + ( ( int ) ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( int ) ( n / 10 ) % 10 ) * 10 + ( int ) ( n / 1000 ) % 10 )\n    ans = 1\n    for i in range ( 5 ) :\n        ans *= n\n        ans %= 100000\n    print ( ans )\nif __name__ == '__main__' :\n    n = 12345\n    lastFiveDigits ( n )\n", "python_code_tokenized": "def lastFiveDigits ( n ) : NEW_LINE INDENT n = ( ( int ) ( n / 10000 ) * 10000 + ( ( int ) ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( int ) ( n / 10 ) % 10 ) * 10 + ( int ) ( n / 1000 ) % 10 ) NEW_LINE ans = 1 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ans *= n NEW_LINE ans %= 100000 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12345 NEW_LINE lastFiveDigits ( n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1616_A", "sol": 0, "python_code": "MAX = 100 ;\nmat = [ [ 0 for x in range ( MAX ) ] for y in range ( MAX ) ] ;\ndef fillRemaining ( i , j , n ) :\n    x = 2 ;\n    for k in range ( i + 1 , n ) :\n        mat [ k ] [ j ] = x ;\n        x += 1 ;\n    for k in range ( i ) :\n        mat [ k ] [ j ] = x ;\n        x += 1 ;\ndef constructMatrix ( n ) :\n    right = n - 1 ;\n    left = 0 ;\n    for i in range ( n ) :\n        if ( i % 2 == 0 ) :\n            mat [ i ] [ right ] = 1 ;\n            fillRemaining ( i , right , n ) ;\n            right -= 1 ;\n        else :\n            mat [ i ] [ left ] = 1 ;\n            fillRemaining ( i , left , n ) ;\n            left += 1 ;\nn = 5 ;\nconstructMatrix ( n ) ;\nfor i in range ( n ) :\n    for j in range ( n ) :\n        print ( mat [ i ] [ j ] , end = \"\" ) ;\n    print ( \"\" ) ;\n", "python_code_tokenized": "MAX = 100 ; NEW_LINE mat = [ [ 0 for x in range ( MAX ) ] for y in range ( MAX ) ] ; NEW_LINE def fillRemaining ( i , j , n ) : NEW_LINE INDENT x = 2 ; NEW_LINE for k in range ( i + 1 , n ) : NEW_LINE INDENT mat [ k ] [ j ] = x ; NEW_LINE x += 1 ; NEW_LINE DEDENT for k in range ( i ) : NEW_LINE INDENT mat [ k ] [ j ] = x ; NEW_LINE x += 1 ; NEW_LINE DEDENT DEDENT def constructMatrix ( n ) : NEW_LINE INDENT right = n - 1 ; NEW_LINE left = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT mat [ i ] [ right ] = 1 ; NEW_LINE fillRemaining ( i , right , n ) ; NEW_LINE right -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ left ] = 1 ; NEW_LINE fillRemaining ( i , left , n ) ; NEW_LINE left += 1 ; NEW_LINE DEDENT DEDENT DEDENT n = 5 ; NEW_LINE constructMatrix ( n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2678_A", "sol": 0, "python_code": "def isPrime ( n ) :\n    if n <= 1 :\n        return False\n    for i in range ( 2 , n ) :\n        if n % i == 0 :\n            return False\n    return True\ndef isEmirp ( n ) :\n    n = int ( n )\n    if isPrime ( n ) == False :\n        return False\n    rev = 0\n    while n != 0 :\n        d = n % 10\n        rev = rev * 10 + d\n        n = int ( n / 10 )\n    return isPrime ( rev )\nn = 13\nif isEmirp ( n ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isEmirp ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if isPrime ( n ) == False : NEW_LINE INDENT return False NEW_LINE DEDENT rev = 0 NEW_LINE while n != 0 : NEW_LINE INDENT d = n % 10 NEW_LINE rev = rev * 10 + d NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return isPrime ( rev ) NEW_LINE DEDENT n = 13 NEW_LINE if isEmirp ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1060_A", "sol": 0, "python_code": "n = int ( input ( ) )\ns = input ( )\nprint ( min ( n // 11 , s.count ( '8' ) ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE print ( min ( n // 11 , s . count ( '8' ) ) ) NEW_LINE"}
{"id": "codeforces_1521_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    a , b = list ( map ( int , input ( ).split ( ) ) )\n    if b == 1 :\n        print ( \"NO\" )\n    else :\n        print ( \"YES\" )\n        print ( a , a * b , a * b + a )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if b == 1 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE print ( a , a * b , a * b + a ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2041_A", "sol": 0, "python_code": "N = 1000000\nphi = [ 0 for i in range ( N + 5 ) ]\ndef computeTotient ( ) :\n    for i in range ( 1 , N + 1 ) :\n        phi [ i ] = i\n    for p in range ( 2 , N + 1 ) :\n        if ( phi [ p ] == p ) :\n            phi [ p ] = p - 1\n            for i in range ( 2 * p , N + 1 , p ) :\n                phi [ i ] = ( phi [ i ] // p ) * ( p - 1 )\ndef power ( x , y , p ) :\n    res = 1\n    x = x % p\n    while ( y > 0 ) :\n        if ( y & 1 ) :\n            res = ( res * x ) % p\n        y = y >> 1\n        x = ( x * x ) % p\n    return res\ndef calculate ( x , k , mod ) :\n    arr = [ 0 for i in range ( N ) ]\n    count = 0\n    while ( mod > 1 ) :\n        arr [ count ] = mod\n        count += 1\n        mod = phi [ mod ]\n    result = 1\n    loop = count + 1\n    arr [ count ] = 1\n    for i in range ( min ( k , loop ) , - 1 , - 1 ) :\n        result = power ( x , result , arr [ i ] )\n    return result\ncomputeTotient ( )\nx = 3\nk = 2\nm = 3\nprint ( calculate ( x , k , m ) )\n", "python_code_tokenized": "N = 1000000 NEW_LINE phi = [ 0 for i in range ( N + 5 ) ] NEW_LINE def computeTotient ( ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , N + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def calculate ( x , k , mod ) : NEW_LINE INDENT arr = [ 0 for i in range ( N ) ] NEW_LINE count = 0 NEW_LINE while ( mod > 1 ) : NEW_LINE INDENT arr [ count ] = mod NEW_LINE count += 1 NEW_LINE mod = phi [ mod ] NEW_LINE DEDENT result = 1 NEW_LINE loop = count + 1 NEW_LINE arr [ count ] = 1 NEW_LINE for i in range ( min ( k , loop ) , - 1 , - 1 ) : NEW_LINE INDENT result = power ( x , result , arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT computeTotient ( ) NEW_LINE x = 3 NEW_LINE k = 2 NEW_LINE m = 3 NEW_LINE print ( calculate ( x , k , m ) ) NEW_LINE"}
{"id": "geeksforgeeks_2119_A", "sol": 0, "python_code": "def maxSubarrayLength ( A , N ) :\n    maxLen = 0 ;\n    curr_sum = 0 ;\n    hash = { } ;\n    for i in range ( N ) :\n        if ( A [ i ] % 2 == 0 ) :\n            curr_sum -= 1 ;\n        else :\n            curr_sum += 1 ;\n        if ( curr_sum == 0 ) :\n            maxLen = max ( maxLen , i + 1 ) ;\n        if curr_sum in hash :\n            maxLen = max ( maxLen , i - hash [ curr_sum ] ) ;\n        else :\n            hash [ curr_sum ] = i ;\n    return maxLen ;\nif __name__ == \"__main__\" :\n    arr = [ 12 , 4 , 7 , 8 , 9 , 2 , 11 , 0 , 2 , 13 ] ;\n    n = len ( arr ) ;\n    print ( maxSubarrayLength ( arr , n ) ) ;\n", "python_code_tokenized": "def maxSubarrayLength ( A , N ) : NEW_LINE INDENT maxLen = 0 ; NEW_LINE curr_sum = 0 ; NEW_LINE hash = { } ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT curr_sum -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT curr_sum += 1 ; NEW_LINE DEDENT if ( curr_sum == 0 ) : NEW_LINE INDENT maxLen = max ( maxLen , i + 1 ) ; NEW_LINE DEDENT if curr_sum in hash : NEW_LINE INDENT maxLen = max ( maxLen , i - hash [ curr_sum ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT hash [ curr_sum ] = i ; NEW_LINE DEDENT DEDENT return maxLen ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , 4 , 7 , 8 , 9 , 2 , 11 , 0 , 2 , 13 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxSubarrayLength ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3381_A", "sol": 0, "python_code": "def minCost ( str1 , K ) :\n    n = len ( str1 )\n    res = 999999999\n    count = 0\n    cnt = [ 0 for i in range ( 27 ) ]\n    for i in range ( n ) :\n        cnt [ ord ( str1 [ i ] ) - ord ( 'a' ) + 1 ] += 1\n    for i in range ( 1 , 26 - K + 1 , 1 ) :\n        a = i\n        b = i + K\n        count = 0\n        for j in range ( 1 , 27 , 1 ) :\n            if ( cnt [ j ] > 0 ) :\n                if ( j >= a and j >= b ) :\n                    count = count + ( min ( j - b , 25 - j + a + 1 ) ) * cnt [ j ]\n                elif ( j <= a and j <= b ) :\n                    count = count + ( min ( a - j , 25 + j - b + 1 ) ) * cnt [ j ]\n        res = min ( res , count )\n    for i in range ( 26 - K + 1 , 27 , 1 ) :\n        a = i\n        b = ( i + K ) % 26\n        count = 0\n        for j in range ( 1 , 27 , 1 ) :\n            if ( cnt [ j ] > 0 ) :\n                if ( j >= b and j <= a ) :\n                    count = count + ( min ( j - b , a - j ) ) * cnt [ j ]\n        res = min ( res , count )\n    return res\nif __name__ == '__main__' :\n    str1 = \"abcdefghi\"\n    K = 2\n    print ( minCost ( str1 , K ) )\n", "python_code_tokenized": "def minCost ( str1 , K ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 999999999 NEW_LINE count = 0 NEW_LINE cnt = [ 0 for i in range ( 27 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ ord ( str1 [ i ] ) - ord ( ' a ' ) + 1 ] += 1 NEW_LINE DEDENT for i in range ( 1 , 26 - K + 1 , 1 ) : NEW_LINE INDENT a = i NEW_LINE b = i + K NEW_LINE count = 0 NEW_LINE for j in range ( 1 , 27 , 1 ) : NEW_LINE INDENT if ( cnt [ j ] > 0 ) : NEW_LINE INDENT if ( j >= a and j >= b ) : NEW_LINE INDENT count = count + ( min ( j - b , 25 - j + a + 1 ) ) * cnt [ j ] NEW_LINE DEDENT elif ( j <= a and j <= b ) : NEW_LINE INDENT count = count + ( min ( a - j , 25 + j - b + 1 ) ) * cnt [ j ] NEW_LINE DEDENT DEDENT DEDENT res = min ( res , count ) NEW_LINE DEDENT for i in range ( 26 - K + 1 , 27 , 1 ) : NEW_LINE INDENT a = i NEW_LINE b = ( i + K ) % 26 NEW_LINE count = 0 NEW_LINE for j in range ( 1 , 27 , 1 ) : NEW_LINE INDENT if ( cnt [ j ] > 0 ) : NEW_LINE INDENT if ( j >= b and j <= a ) : NEW_LINE INDENT count = count + ( min ( j - b , a - j ) ) * cnt [ j ] NEW_LINE DEDENT DEDENT DEDENT res = min ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" abcdefghi \" NEW_LINE K = 2 NEW_LINE print ( minCost ( str1 , K ) ) NEW_LINE DEDENT"}
{"id": "codeforces_197_A", "sol": 0, "python_code": "a , b , r = map ( int , input ( ).split ( ) )\nif ( r * 2 > a or r * 2 > b ) :\n    print ( \"Second\" )\nelse :\n    print ( \"First\" )\n", "python_code_tokenized": "a , b , r = map ( int , input ( ) . split ( ) ) NEW_LINE if ( r * 2 > a or r * 2 > b ) : NEW_LINE INDENT print ( \" Second \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT"}
{"id": "codeforces_233_A", "sol": 0, "python_code": "import sys\na = int ( input ( ) )\nif a % 2 == 1 :\n    print ( \"-1\" )\nelse :\n    for i in range ( 1 , a + 1 ) :\n        if i % 2 == 1 :\n            sys.stdout.write ( str ( i + 1 ) + \" \" )\n        else :\n            sys.stdout.write ( str ( i - 1 ) + \" \" )\n", "python_code_tokenized": "import sys NEW_LINE a = int ( input ( ) ) NEW_LINE if a % 2 == 1 : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT sys . stdout . write ( str ( i + 1 ) + \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( str ( i - 1 ) + \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_779_A", "sol": 0, "python_code": "import math\ndef nonsquare ( n ) :\n    return n + ( int ) ( 0.5 + math.sqrt ( n ) )\ndef printNonSquare ( n ) :\n    for i in range ( 1 , n + 1 ) :\n        print ( nonsquare ( i ) , end = \" \" )\nn = 10\nprintNonSquare ( n )\n", "python_code_tokenized": "import math NEW_LINE def nonsquare ( n ) : NEW_LINE INDENT return n + ( int ) ( 0.5 + math . sqrt ( n ) ) NEW_LINE DEDENT def printNonSquare ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( nonsquare ( i ) , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE"}
{"id": "projecteuler_p108_A", "sol": 0, "python_code": "import eulerlib , itertools\ndef compute ( ) :\n    for n in itertools.count ( 1 ) :\n        if ( count_divisors_squared ( n ) + 1 ) // 2 > 1000 :\n            return str ( n )\ndef count_divisors_squared ( n ) :\n    count = 1\n    end = eulerlib.sqrt ( n )\n    for i in itertools.count ( 2 ) :\n        if i > end :\n            break\n        if n % i == 0 :\n            j = 0\n            while True :\n                n //= i\n                j += 1\n                if n % i != 0 :\n                    break\n            count *= j * 2 + 1\n            end = eulerlib.sqrt ( n )\n    if n != 1 :\n        count *= 3\n    return count\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT for n in itertools . count ( 1 ) : NEW_LINE INDENT if ( count_divisors_squared ( n ) + 1 ) // 2 > 1000 : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT def count_divisors_squared ( n ) : NEW_LINE INDENT count = 1 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE for i in itertools . count ( 2 ) : NEW_LINE INDENT if i > end : NEW_LINE INDENT break NEW_LINE DEDENT if n % i == 0 : NEW_LINE INDENT j = 0 NEW_LINE while True : NEW_LINE INDENT n //= i NEW_LINE j += 1 NEW_LINE if n % i != 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT count *= j * 2 + 1 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE DEDENT DEDENT if n != 1 : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4805_A", "sol": 0, "python_code": "def maxModValue ( arr , n ) :\n    ans = 0\n    arr = sorted ( arr )\n    for j in range ( n - 2 , - 1 , - 1 ) :\n        if ( ans >= arr [ j ] ) :\n            break\n        if ( arr [ j ] == arr [ j + 1 ] ) :\n            continue\n        i = 2 * arr [ j ]\n        while ( i <= arr [ n - 1 ] + arr [ j ] ) :\n            ind = 0\n            for k in arr :\n                if k >= i :\n                    ind = arr.index ( k )\n            ans = max ( ans , arr [ ind - 1 ] % arr [ j ] )\n            i += arr [ j ]\n    return ans\narr = [ 3 , 4 , 5 , 9 , 11 ]\nn = 5\nprint ( maxModValue ( arr , n ) )\n", "python_code_tokenized": "def maxModValue ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( ans >= arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ j ] == arr [ j + 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT i = 2 * arr [ j ] NEW_LINE while ( i <= arr [ n - 1 ] + arr [ j ] ) : NEW_LINE INDENT ind = 0 NEW_LINE for k in arr : NEW_LINE INDENT if k >= i : NEW_LINE INDENT ind = arr . index ( k ) NEW_LINE DEDENT DEDENT ans = max ( ans , arr [ ind - 1 ] % arr [ j ] ) NEW_LINE i += arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 4 , 5 , 9 , 11 ] NEW_LINE n = 5 NEW_LINE print ( maxModValue ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_405_B", "sol": 0, "python_code": "n = int ( input ( ) )\ns = input ( )\nans = 0\ndef knocked ( left , right , s , n , idx ) :\n    if left == - 1 and right == n :\n        return False\n    if left == - 1 :\n        return s [ right ] == 'L'\n    if right == n :\n        return s [ left ] == 'R'\n    if s [ left ] == 'R' and s [ right ] == 'L' :\n        if ( right - left ) % 2 == 0 and right - ( right - left ) // 2 == idx :\n            return False\n        else :\n            return True\n    elif s [ left ] == 'R' or s [ right ] == 'L' :\n        return True\n    else :\n        return False\nfor i in range ( n ) :\n    if s [ i ] != '.' : continue ;\n    dl = i - 1\n    dr = i + 1\n    while dl >= 0 and s [ dl ] == '.' :\n        dl -= 1\n    while dr < n and s [ dr ] == '.' :\n        dr += 1\n    if not knocked ( dl , dr , s , n , i ) :\n        ans += 1\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE def knocked ( left , right , s , n , idx ) : NEW_LINE INDENT if left == - 1 and right == n : NEW_LINE INDENT return False NEW_LINE DEDENT if left == - 1 : NEW_LINE INDENT return s [ right ] == ' L ' NEW_LINE DEDENT if right == n : NEW_LINE INDENT return s [ left ] == ' R ' NEW_LINE DEDENT if s [ left ] == ' R ' and s [ right ] == ' L ' : NEW_LINE INDENT if ( right - left ) % 2 == 0 and right - ( right - left ) // 2 == idx : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT elif s [ left ] == ' R ' or s [ right ] == ' L ' : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] != ' . ' : continue ; NEW_LINE dl = i - 1 NEW_LINE dr = i + 1 NEW_LINE while dl >= 0 and s [ dl ] == ' . ' : NEW_LINE INDENT dl -= 1 NEW_LINE DEDENT while dr < n and s [ dr ] == ' . ' : NEW_LINE INDENT dr += 1 NEW_LINE DEDENT if not knocked ( dl , dr , s , n , i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_3494_A", "sol": 0, "python_code": "def findMin ( arr , n ) :\n    sum = 0\n    for i in range ( 0 , n ) :\n        sum = sum + arr [ i ]\n    arr.sort ( )\n    min = arr [ 0 ]\n    max = 0\n    for i in range ( n - 1 , 0 , - 1 ) :\n        num = arr [ i ]\n        total = num + min\n        for j in range ( 2 , num + 1 ) :\n            if ( num % j == 0 ) :\n                d = j\n                now = ( num // d ) + ( min * d )\n                reduce = total - now\n                if ( reduce > max ) :\n                    max = reduce\n    print ( sum - max )\narr = [ 1 , 2 , 3 , 4 , 5 ]\nn = len ( arr )\nfindMin ( arr , n )\n", "python_code_tokenized": "def findMin ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE min = arr [ 0 ] NEW_LINE max = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT num = arr [ i ] NEW_LINE total = num + min NEW_LINE for j in range ( 2 , num + 1 ) : NEW_LINE INDENT if ( num % j == 0 ) : NEW_LINE INDENT d = j NEW_LINE now = ( num // d ) + ( min * d ) NEW_LINE reduce = total - now NEW_LINE if ( reduce > max ) : NEW_LINE INDENT max = reduce NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( sum - max ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findMin ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_3734_A", "sol": 0, "python_code": "def increaseInVol ( l , b , h ) :\n    percentInc = ( ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) )\n    percentInc -= 1\n    percentInc *= 100\n    return percentInc\nl = 50\nb = 20\nh = 10\nprint ( increaseInVol ( l , b , h ) , \"%\" )\n", "python_code_tokenized": "def increaseInVol ( l , b , h ) : NEW_LINE INDENT percentInc = ( ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ) NEW_LINE percentInc -= 1 NEW_LINE percentInc *= 100 NEW_LINE return percentInc NEW_LINE DEDENT l = 50 NEW_LINE b = 20 NEW_LINE h = 10 NEW_LINE print ( increaseInVol ( l , b , h ) , \" % \" ) NEW_LINE"}
{"id": "geeksforgeeks_1803_A", "sol": 0, "python_code": "def sameLength ( A , B ) :\n    while ( A > 0 and B > 0 ) :\n        A = A / 10 ;\n        B = B / 10 ;\n    if ( A == 0 and B == 0 ) :\n        return True ;\n    return False ;\nA = 21 ; B = 1 ;\nif ( sameLength ( A , B ) ) :\n    print ( \"Yes\" ) ;\nelse :\n    print ( \"No\" ) ;\n", "python_code_tokenized": "def sameLength ( A , B ) : NEW_LINE INDENT while ( A > 0 and B > 0 ) : NEW_LINE INDENT A = A / 10 ; NEW_LINE B = B / 10 ; NEW_LINE DEDENT if ( A == 0 and B == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT A = 21 ; B = 1 ; NEW_LINE if ( sameLength ( A , B ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2850_A", "sol": 0, "python_code": "def largestPalinSub ( s ) :\n    res = \"\"\n    mx = s [ 0 ]\n    for i in range ( 1 , len ( s ) ) :\n        mx = max ( mx , s [ i ] )\n    for i in range ( 0 , len ( s ) ) :\n        if s [ i ] == mx :\n            res += s [ i ]\n    return res\nif __name__ == \"__main__\" :\n    s = \"geeksforgeeks\"\n    print ( largestPalinSub ( s ) )\n", "python_code_tokenized": "def largestPalinSub ( s ) : NEW_LINE INDENT res = \" \" NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == mx : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( largestPalinSub ( s ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02459_A", "sol": 0, "python_code": "d = { }\nfor _ in range ( int ( input ( ) ) ) :\n    op , key , x = ( input ( ).split ( ) + [ '' ] ) [ : 3 ]\n    if op == '0' :\n        d [ key ] = x\n    else :\n        print ( d [ key ] )\n", "python_code_tokenized": "d = { } NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT op , key , x = ( input ( ) . split ( ) + [ ' ' ] ) [ : 3 ] NEW_LINE if op == '0' : NEW_LINE INDENT d [ key ] = x NEW_LINE DEDENT else : NEW_LINE INDENT print ( d [ key ] ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p02460_A", "sol": 0, "python_code": "M = { }\nfor i in range ( int ( input ( ) ) ) :\n    query = input ( ).split ( )\n    if query [ 0 ] == '0' : M [ query [ 1 ] ] = query [ 2 ]\n    elif query [ 0 ] == '1' :\n        if query [ 1 ] in M : print ( M [ query [ 1 ] ] )\n        else : print ( 0 )\n    else : M [ query [ 1 ] ] = 0\n", "python_code_tokenized": "M = { } NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT query = input ( ) . split ( ) NEW_LINE if query [ 0 ] == '0' : M [ query [ 1 ] ] = query [ 2 ] NEW_LINE elif query [ 0 ] == '1' : NEW_LINE INDENT if query [ 1 ] in M : print ( M [ query [ 1 ] ] ) NEW_LINE else : print ( 0 ) NEW_LINE DEDENT else : M [ query [ 1 ] ] = 0 NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2005_A", "sol": 0, "python_code": "def SieveOfEratosthenes ( n , isPrime ) :\n    isPrime [ 0 ] = isPrime [ 1 ] = False\n    for i in range ( 2 , n + 1 ) :\n        isPrime [ i ] = True\n    p = 2\n    while ( p * p <= n ) :\n        if ( isPrime [ p ] == True ) :\n            i = p * p\n            while ( i <= n ) :\n                isPrime [ i ] = False\n                i += p\n        p += 1\ndef findPrimePair ( n ) :\n    isPrime = [ 0 ] * ( n + 1 )\n    SieveOfEratosthenes ( n , isPrime )\n    for i in range ( 0 , n ) :\n        if ( isPrime [ i ] and isPrime [ n - i ] ) :\n            print ( i , ( n - i ) )\n            return\nn = 74\nfindPrimePair ( n )\n", "python_code_tokenized": "def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT i = p * p NEW_LINE while ( i <= n ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def findPrimePair ( n ) : NEW_LINE INDENT isPrime = [ 0 ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( isPrime [ i ] and isPrime [ n - i ] ) : NEW_LINE INDENT print ( i , ( n - i ) ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT n = 74 NEW_LINE findPrimePair ( n ) NEW_LINE"}
{"id": "codejam_16_54", "sol": 0, "python_code": "def run ( ) :\n    n , l = tuple ( int ( x ) for x in input ( ).split ( ) )\n    G = input ( ).split ( )\n    B = input ( ).strip ( )\n    if B in G :\n        return \"IMPOSSIBLE\"\n    if l == 1 :\n        p1 = \"?\"\n        p2 = \"0\"\n    else :\n        p1 = \"?\" * ( l - 1 )\n        p2 = \"10?\" + \"10\" * l\n    return \"%s %s\" % ( p1 , p2 )\ntc = int ( input ( ) )\nfor i in range ( tc ) :\n    res = run ( )\n    print ( \"Case #%d: %s\" % ( i + 1 , res ) )\n", "python_code_tokenized": "def run ( ) : NEW_LINE INDENT n , l = tuple ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE G = input ( ) . split ( ) NEW_LINE B = input ( ) . strip ( ) NEW_LINE if B in G : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT if l == 1 : NEW_LINE INDENT p1 = \" ? \" NEW_LINE p2 = \"0\" NEW_LINE DEDENT else : NEW_LINE INDENT p1 = \" ? \" * ( l - 1 ) NEW_LINE p2 = \"10 ? \" + \"10\" * l NEW_LINE DEDENT return \" % s \u2581 % s \" % ( p1 , p2 ) NEW_LINE DEDENT tc = int ( input ( ) ) NEW_LINE for i in range ( tc ) : NEW_LINE INDENT res = run ( ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( i + 1 , res ) ) NEW_LINE DEDENT"}
{"id": "codeforces_588_B", "sol": 0, "python_code": "import math\nn = int ( input ( ) )\nnDivisible = [ ]\nfor i in range ( 1 , int ( math.sqrt ( n ) ) + 1 ) :\n    if n % i == 0 :\n        nDivisible.append ( i )\n        nDivisible.append ( n // i )\nnDivisible.sort ( )\nflag = True\nfor i in range ( len ( nDivisible ) - 1 , - 1 , - 1 ) :\n    flag = True\n    maxDivisible = nDivisible [ i ]\n    for j in range ( 2 , int ( math.sqrt ( maxDivisible ) ) + 1 ) :\n        if maxDivisible % ( j * j ) == 0 :\n            flag = False\n            break\n    if flag == True :\n        print ( maxDivisible )\n        break\n", "python_code_tokenized": "import math NEW_LINE n = int ( input ( ) ) NEW_LINE nDivisible = [ ] NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT nDivisible . append ( i ) NEW_LINE nDivisible . append ( n // i ) NEW_LINE DEDENT DEDENT nDivisible . sort ( ) NEW_LINE flag = True NEW_LINE for i in range ( len ( nDivisible ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT flag = True NEW_LINE maxDivisible = nDivisible [ i ] NEW_LINE for j in range ( 2 , int ( math . sqrt ( maxDivisible ) ) + 1 ) : NEW_LINE INDENT if maxDivisible % ( j * j ) == 0 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag == True : NEW_LINE INDENT print ( maxDivisible ) NEW_LINE break NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1735_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    l = list ( map ( int , input ( ).split ( ) ) )\n    if n == 1 : print ( 0 ) ; continue\n    l.sort ( )\n    c = 0\n    x = l [ 0 ]\n    for i in l [ 1 : : ] :\n        c += ( i - 1 ) // ( 2 * x - 1 )\n    print ( c )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : print ( 0 ) ; continue NEW_LINE l . sort ( ) NEW_LINE c = 0 NEW_LINE x = l [ 0 ] NEW_LINE for i in l [ 1 : : ] : NEW_LINE INDENT c += ( i - 1 ) // ( 2 * x - 1 ) NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4174_A", "sol": 0, "python_code": "def manipulateString ( str ) :\n    for i in range ( len ( str ) ) :\n        asc = ord ( str [ i ] )\n        rem = asc - ( 26 - ( ord ( str [ i ] ) - ord ( 'a' ) ) )\n        m = rem % 26\n        str [ i ] = chr ( m + ord ( 'a' ) )\n    print ( ''.join ( str ) )\nif __name__ == \"__main__\" :\n    str = \"geeksforgeeks\"\n    str = list ( str )\n    manipulateString ( str )\n", "python_code_tokenized": "def manipulateString ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT asc = ord ( str [ i ] ) NEW_LINE rem = asc - ( 26 - ( ord ( str [ i ] ) - ord ( ' a ' ) ) ) NEW_LINE m = rem % 26 NEW_LINE str [ i ] = chr ( m + ord ( ' a ' ) ) NEW_LINE DEDENT print ( ' ' . join ( str ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE str = list ( str ) NEW_LINE manipulateString ( str ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_988_A", "sol": 0, "python_code": "def LISusingLCS ( seq ) :\n    n = len ( seq )\n    L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]\n    sortedseq = sorted ( seq )\n    for i in range ( n + 1 ) :\n        for j in range ( n + 1 ) :\n            if ( i == 0 or j == 0 ) :\n                L [ i ] [ j ] = 0\n            elif ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) :\n                L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1\n            else :\n                L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] )\n    return L [ n ] [ n ]\nsequence = [ 12 , 34 , 1 , 5 , 40 , 80 ]\nprint ( LISusingLCS ( sequence ) )\n", "python_code_tokenized": "def LISusingLCS ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE sortedseq = sorted ( seq ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ n ] [ n ] NEW_LINE DEDENT sequence = [ 12 , 34 , 1 , 5 , 40 , 80 ] NEW_LINE print ( LISusingLCS ( sequence ) ) NEW_LINE"}
{"id": "codeforces_1129_B", "sol": 0, "python_code": "import sys\nreadline = sys.stdin.readline\nK = int ( readline ( ) )\nN = 2000\nfor x in range ( 10 ** 6 , - 1 , - 1 ) :\n    if ( K + x ) % 2000 == 0 and ( K + x ) // N < x :\n        ans_lst = [ 0 ] * ( N - 2 ) + [ ( K + x ) // N - x , x ]\nprint ( N )\nprint ( * ans_lst )\n", "python_code_tokenized": "import sys NEW_LINE readline = sys . stdin . readline NEW_LINE K = int ( readline ( ) ) NEW_LINE N = 2000 NEW_LINE for x in range ( 10 ** 6 , - 1 , - 1 ) : NEW_LINE INDENT if ( K + x ) % 2000 == 0 and ( K + x ) // N < x : NEW_LINE INDENT ans_lst = [ 0 ] * ( N - 2 ) + [ ( K + x ) // N - x , x ] NEW_LINE DEDENT DEDENT print ( N ) NEW_LINE print ( * ans_lst ) NEW_LINE"}
{"id": "codeforces_1543_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    l = list ( map ( int , input ( ).split ( ) ) )\n    s = sum ( l )\n    k = s % n\n    print ( k * ( n - k ) )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( l ) NEW_LINE k = s % n NEW_LINE print ( k * ( n - k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1891_A", "sol": 0, "python_code": "str = \"abcb\"\ndef countPS ( i , j ) :\n    if ( i >= n or j < 0 ) :\n        return 0\n    if ( dp [ i ] [ j ] != - 1 ) :\n        return dp [ i ] [ j ]\n    if ( abs ( i - j ) == 1 ) :\n        if ( str [ i ] == str [ j ] ) :\n            dp [ i ] [ j ] = 3\n            return dp [ i ] [ j ]\n        else :\n            dp [ i ] [ j ] = 2\n            return dp [ i ] [ j ]\n    if ( i == j ) :\n        dp [ 1 ] [ j ] = 1\n        return dp [ 1 ] [ j ]\n    elif ( str [ i ] == str [ j ] ) :\n        dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 )\n        return dp [ i ] [ j ]\n    else :\n        dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) )\n        return dp [ i ] [ j ]\nif __name__ == \"__main__\" :\n    dp = [ [ - 1 for x in range ( 1000 ) ] for y in range ( 1000 ) ]\n    n = len ( str )\n    print ( \"Total palindromic subsequence are :\" , countPS ( 0 , n - 1 ) )\n", "python_code_tokenized": "str = \" abcb \" NEW_LINE def countPS ( i , j ) : NEW_LINE INDENT if ( i >= n or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( abs ( i - j ) == 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 3 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 2 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( i == j ) : NEW_LINE INDENT dp [ 1 ] [ j ] = 1 NEW_LINE return dp [ 1 ] [ j ] NEW_LINE DEDENT elif ( str [ i ] == str [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ) NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ) NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT dp = [ [ - 1 for x in range ( 1000 ) ] for y in range ( 1000 ) ] NEW_LINE n = len ( str ) NEW_LINE print ( \" Total \u2581 palindromic \u2581 subsequence \u2581 are \u2581 : \" , countPS ( 0 , n - 1 ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC148_E", "sol": 0, "python_code": "n = int ( input ( ) )\nif n % 2 == 1 :\n    print ( 0 )\nelse :\n    t = 0\n    for i in range ( 1 , 1000 ) :\n        if 5 ** i <= n :\n            t += ( n // ( 5 ** i ) ) // 2\n        else :\n            break\n    print ( t )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE if n % 2 == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT t = 0 NEW_LINE for i in range ( 1 , 1000 ) : NEW_LINE INDENT if 5 ** i <= n : NEW_LINE INDENT t += ( n // ( 5 ** i ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_710_A", "sol": 0, "python_code": "def maxSum ( a , n ) :\n    maxAnd = max ( a )\n    maxOR = 0\n    for i in range ( n ) :\n        maxOR |= a [ i ]\n    print ( maxAnd + maxOR )\nn = 4\na = [ 3 , 5 , 6 , 1 ]\nmaxSum ( a , n )\n", "python_code_tokenized": "def maxSum ( a , n ) : NEW_LINE INDENT maxAnd = max ( a ) NEW_LINE maxOR = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxOR |= a [ i ] NEW_LINE DEDENT print ( maxAnd + maxOR ) NEW_LINE DEDENT n = 4 NEW_LINE a = [ 3 , 5 , 6 , 1 ] NEW_LINE maxSum ( a , n ) NEW_LINE"}
{"id": "aizu_p00313_A", "sol": 0, "python_code": "N = int ( input ( ) )\nA = [ 0 ] * N\nB = [ 0 ] * N\nC = [ 0 ] * N\nlineA = list ( map ( int , input ( ).split ( ) ) )\nlineB = list ( map ( int , input ( ).split ( ) ) )\nlineC = list ( map ( int , input ( ).split ( ) ) )\nfor i in range ( 1 , lineA [ 0 ] + 1 ) : A [ lineA [ i ] - 1 ] = 1\nfor i in range ( 1 , lineB [ 0 ] + 1 ) : B [ lineB [ i ] - 1 ] = 1\nfor i in range ( 1 , lineC [ 0 ] + 1 ) : C [ lineC [ i ] - 1 ] = 1\nans = 0\nfor i in range ( N ) :\n    if ( ( ( not A [ i ] ) and C [ i ] ) or ( B [ i ] and C [ i ] ) ) :\n        ans += 1\nprint ( ans )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE A = [ 0 ] * N NEW_LINE B = [ 0 ] * N NEW_LINE C = [ 0 ] * N NEW_LINE lineA = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lineB = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lineC = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 1 , lineA [ 0 ] + 1 ) : A [ lineA [ i ] - 1 ] = 1 NEW_LINE for i in range ( 1 , lineB [ 0 ] + 1 ) : B [ lineB [ i ] - 1 ] = 1 NEW_LINE for i in range ( 1 , lineC [ 0 ] + 1 ) : C [ lineC [ i ] - 1 ] = 1 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( ( ( not A [ i ] ) and C [ i ] ) or ( B [ i ] and C [ i ] ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_4055_A", "sol": 0, "python_code": "def SUM ( x , n ) :\n    total = 1\n    for i in range ( 1 , n + 1 ) :\n        total = total + ( ( x ** i ) / i )\n    return total\nx = 2\nn = 5\ns = SUM ( x , n )\nprint ( round ( s , 2 ) )\n", "python_code_tokenized": "def SUM ( x , n ) : NEW_LINE INDENT total = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total = total + ( ( x ** i ) / i ) NEW_LINE DEDENT return total NEW_LINE DEDENT x = 2 NEW_LINE n = 5 NEW_LINE s = SUM ( x , n ) NEW_LINE print ( round ( s , 2 ) ) NEW_LINE"}
{"id": "geeksforgeeks_2004_A", "sol": 0, "python_code": "def compute ( S , X ) :\n    A = ( S - X ) // 2\n    a = 0\n    b = 0\n    for i in range ( 64 ) :\n        Xi = ( X & ( 1 << i ) )\n        Ai = ( A & ( 1 << i ) )\n        if ( Xi == 0 and Ai == 0 ) :\n            pass\n        elif ( Xi == 0 and Ai > 0 ) :\n            a = ( ( 1 << i ) | a )\n            b = ( ( 1 << i ) | b )\n        elif ( Xi > 0 and Ai == 0 ) :\n            a = ( ( 1 << i ) | a )\n        else :\n            print ( \"Not Possible\" )\n            return\n    print ( \"a = \" , a )\n    print ( \"b =\" , b )\nS = 17\nX = 13\ncompute ( S , X )\n", "python_code_tokenized": "def compute ( S , X ) : NEW_LINE INDENT A = ( S - X ) // 2 NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT Xi = ( X & ( 1 << i ) ) NEW_LINE Ai = ( A & ( 1 << i ) ) NEW_LINE if ( Xi == 0 and Ai == 0 ) : NEW_LINE INDENT pass NEW_LINE DEDENT elif ( Xi == 0 and Ai > 0 ) : NEW_LINE INDENT a = ( ( 1 << i ) | a ) NEW_LINE b = ( ( 1 << i ) | b ) NEW_LINE DEDENT elif ( Xi > 0 and Ai == 0 ) : NEW_LINE INDENT a = ( ( 1 << i ) | a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Possible \" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" a \u2581 = \u2581 \" , a ) NEW_LINE print ( \" b \u2581 = \" , b ) NEW_LINE DEDENT S = 17 NEW_LINE X = 13 NEW_LINE compute ( S , X ) NEW_LINE"}
{"id": "geeksforgeeks_318_A", "sol": 0, "python_code": "def StrictlyPositiveXor ( A , N ) :\n    allxor = 0 ;\n    checkallzero = True ;\n    for i in range ( N ) :\n        allxor ^= A [ i ] ;\n        if ( A [ i ] > 0 ) :\n            checkallzero = False ;\n    if ( allxor != 0 ) :\n        return N ;\n    if ( checkallzero ) :\n        return - 1 ;\n    l = N ; r = - 1 ;\n    for i in range ( N ) :\n        if ( A [ i ] > 0 ) :\n            l = i + 1 ;\n            break ;\n    for i in range ( N - 1 , - 1 , - 1 ) :\n        if ( A [ i ] > 0 ) :\n            r = i + 1 ;\n            break ;\n    return max ( N - l , r - 1 ) ;\nif __name__ == \"__main__\" :\n    A = [ 1 , 0 , 0 , 1 ] ;\n    N = len ( A ) ;\n    print ( StrictlyPositiveXor ( A , N ) ) ;\n", "python_code_tokenized": "def StrictlyPositiveXor ( A , N ) : NEW_LINE INDENT allxor = 0 ; NEW_LINE checkallzero = True ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT allxor ^= A [ i ] ; NEW_LINE if ( A [ i ] > 0 ) : NEW_LINE INDENT checkallzero = False ; NEW_LINE DEDENT DEDENT if ( allxor != 0 ) : NEW_LINE INDENT return N ; NEW_LINE DEDENT if ( checkallzero ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT l = N ; r = - 1 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] > 0 ) : NEW_LINE INDENT l = i + 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( A [ i ] > 0 ) : NEW_LINE INDENT r = i + 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT return max ( N - l , r - 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 0 , 0 , 1 ] ; NEW_LINE N = len ( A ) ; NEW_LINE print ( StrictlyPositiveXor ( A , N ) ) ; NEW_LINE DEDENT"}
{"id": "atcoder_AGC006_B", "sol": 0, "python_code": "N , x = map ( int , input ( ).split ( ) )\nif x == 1 or x == 2 * N - 1 :\n    print ( \"No\" )\nelse :\n    print ( \"Yes\" )\n    l = [ i for i in range ( 1 , 2 * N ) ]\n    l.remove ( x - 1 )\n    l.remove ( x )\n    l.remove ( x + 1 )\n    for i in range ( N - 2 ) :\n        print ( l [ i ] )\n    print ( x - 1 )\n    print ( x )\n    print ( x + 1 )\n    for i in range ( N - 2 ) :\n        print ( l [ N - 2 + i ] )\n", "python_code_tokenized": "N , x = map ( int , input ( ) . split ( ) ) NEW_LINE if x == 1 or x == 2 * N - 1 : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE l = [ i for i in range ( 1 , 2 * N ) ] NEW_LINE l . remove ( x - 1 ) NEW_LINE l . remove ( x ) NEW_LINE l . remove ( x + 1 ) NEW_LINE for i in range ( N - 2 ) : NEW_LINE INDENT print ( l [ i ] ) NEW_LINE DEDENT print ( x - 1 ) NEW_LINE print ( x ) NEW_LINE print ( x + 1 ) NEW_LINE for i in range ( N - 2 ) : NEW_LINE INDENT print ( l [ N - 2 + i ] ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1467_A", "sol": 0, "python_code": "def Minimum_Operations ( a , n ) :\n    np = [ 0 for i in range ( n + 1 ) ]\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        np [ i ] = np [ i + 1 ]\n        if ( a [ i ] <= 0 ) :\n            np [ i ] += 1\n    pos = 0\n    ans = n\n    for i in range ( n - 1 ) :\n        if ( a [ i ] >= 0 ) :\n            pos += 1\n        ans = min ( ans , pos + np [ i + 1 ] )\n    return ans\na = [ - 1 , 0 , 1 , 2 ]\nn = len ( a )\nprint ( Minimum_Operations ( a , n ) )\n", "python_code_tokenized": "def Minimum_Operations ( a , n ) : NEW_LINE INDENT np = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT np [ i ] = np [ i + 1 ] NEW_LINE if ( a [ i ] <= 0 ) : NEW_LINE INDENT np [ i ] += 1 NEW_LINE DEDENT DEDENT pos = 0 NEW_LINE ans = n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT ans = min ( ans , pos + np [ i + 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ - 1 , 0 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( Minimum_Operations ( a , n ) ) NEW_LINE"}
{"id": "aizu_p00596_A", "sol": 0, "python_code": "class UnionFind ( ) :\n    def __init__ ( self , n ) :\n        self.parent = list ( range ( n ) )\n        self.rank = [ 0 ] * n\n    def find ( self , x ) :\n        if self.parent [ x ] == x :\n            return x\n        else :\n            self.parent [ x ] = self.find ( self.parent [ x ] )\n            return self.parent [ x ]\n    def unite ( self , x , y ) :\n        x , y = self.find ( x ) , self.find ( y )\n        if x == y :\n            return\n        if self.rank [ x ] < self.rank [ y ] :\n            self.parent [ x ] = y\n        else :\n            self.parent [ y ] = x\n            if self.rank [ x ] == self.rank [ y ] :\n                self.rank [ x ] += 1\n    def same ( self , x , y ) :\n        return self.find ( x ) == self.find ( y )\nwhile True :\n    try :\n        n = int ( input ( ) )\n    except EOFError :\n        break\n    tree = UnionFind ( 7 )\n    nums = [ 0 ] * 7\n    for dominoes in input ( ).split ( ) :\n        x , y = divmod ( int ( dominoes ) , 10 )\n        tree.unite ( x , y )\n        nums [ x ] += 1\n        nums [ y ] += 1\n    if all ( tree.same ( x , i ) for i in range ( 1 , 7 ) if nums [ i ] ) and sum ( 1 for x in nums if x % 2 ) <= 2 :\n        print ( 'Yes' )\n    else :\n        print ( 'No' )\n", "python_code_tokenized": "class UnionFind ( ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . parent = list ( range ( n ) ) NEW_LINE self . rank = [ 0 ] * n NEW_LINE DEDENT def find ( self , x ) : NEW_LINE INDENT if self . parent [ x ] == x : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT self . parent [ x ] = self . find ( self . parent [ x ] ) NEW_LINE return self . parent [ x ] NEW_LINE DEDENT DEDENT def unite ( self , x , y ) : NEW_LINE INDENT x , y = self . find ( x ) , self . find ( y ) NEW_LINE if x == y : NEW_LINE INDENT return NEW_LINE DEDENT if self . rank [ x ] < self . rank [ y ] : NEW_LINE INDENT self . parent [ x ] = y NEW_LINE DEDENT else : NEW_LINE INDENT self . parent [ y ] = x NEW_LINE if self . rank [ x ] == self . rank [ y ] : NEW_LINE INDENT self . rank [ x ] += 1 NEW_LINE DEDENT DEDENT DEDENT def same ( self , x , y ) : NEW_LINE INDENT return self . find ( x ) == self . find ( y ) NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT tree = UnionFind ( 7 ) NEW_LINE nums = [ 0 ] * 7 NEW_LINE for dominoes in input ( ) . split ( ) : NEW_LINE INDENT x , y = divmod ( int ( dominoes ) , 10 ) NEW_LINE tree . unite ( x , y ) NEW_LINE nums [ x ] += 1 NEW_LINE nums [ y ] += 1 NEW_LINE DEDENT if all ( tree . same ( x , i ) for i in range ( 1 , 7 ) if nums [ i ] ) and sum ( 1 for x in nums if x % 2 ) <= 2 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT"}
{"id": "codejam_17_31", "sol": 0, "python_code": "import math\nclass pannukakku :\n    radius = 0\n    height = 0\n    size_h = 0\n    size_r = 0\n    def size ( self , current_r ) :\n        if ( self.radius > current_r ) :\n            return self.size_h + self.size_r - math.pi * current_r * current_r ;\n        return self.size_h ;\ndef poista_isoin ( kakut , current_r ) :\n    isoin_index = 0 ;\n    isoin_size = kakut [ 0 ].size ( current_r ) ;\n    for p in range ( 1 , len ( kakut ) ) :\n        if ( kakut [ p ].size ( current_r ) > isoin_size ) :\n            isoin_index = p ;\n            isoin_size = kakut [ p ].size ( current_r ) ;\n    return kakut.pop ( isoin_index ) ;\nt = int ( input ( ) )\nfor i in range ( 1 , t + 1 ) :\n    pannukakkuja , tilauksen_koko = [ int ( s ) for s in input ( ).split ( \" \" ) ] ;\n    radiuses = [ 0 for h in range ( pannukakkuja ) ]\n    heigths = [ 0 for h in range ( pannukakkuja ) ]\n    sizes = [ 0 for h in range ( pannukakkuja ) ]\n    kakut = [ pannukakku ( ) for h in range ( pannukakkuja ) ]\n    for h in range ( 0 , pannukakkuja ) :\n        r , s = [ int ( s ) for s in input ( ).split ( \" \" ) ] ;\n        kakut [ h ].radius = r ;\n        kakut [ h ].heigth = s ;\n        kakut [ h ].size_h = math.pi * 2 * r * s ;\n        kakut [ h ].size_r = math.pi * r * r ;\n    total = 0 ;\n    current_r = 0 ;\n    for p in range ( tilauksen_koko ) :\n        isoin = poista_isoin ( kakut , current_r ) ;\n        total += isoin.size ( current_r ) ;\n        current_r = max ( current_r , isoin.radius ) ;\n    print ( \"Case #{0:.0f}: {1:.6f}\".format ( i , total ) ) ;\n", "python_code_tokenized": "import math NEW_LINE class pannukakku : NEW_LINE INDENT radius = 0 NEW_LINE height = 0 NEW_LINE size_h = 0 NEW_LINE size_r = 0 NEW_LINE def size ( self , current_r ) : NEW_LINE INDENT if ( self . radius > current_r ) : NEW_LINE INDENT return self . size_h + self . size_r - math . pi * current_r * current_r ; NEW_LINE DEDENT return self . size_h ; NEW_LINE DEDENT DEDENT def poista_isoin ( kakut , current_r ) : NEW_LINE INDENT isoin_index = 0 ; NEW_LINE isoin_size = kakut [ 0 ] . size ( current_r ) ; NEW_LINE for p in range ( 1 , len ( kakut ) ) : NEW_LINE INDENT if ( kakut [ p ] . size ( current_r ) > isoin_size ) : NEW_LINE INDENT isoin_index = p ; NEW_LINE isoin_size = kakut [ p ] . size ( current_r ) ; NEW_LINE DEDENT DEDENT return kakut . pop ( isoin_index ) ; NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT pannukakkuja , tilauksen_koko = [ int ( s ) for s in input ( ) . split ( \" \u2581 \" ) ] ; NEW_LINE radiuses = [ 0 for h in range ( pannukakkuja ) ] NEW_LINE heigths = [ 0 for h in range ( pannukakkuja ) ] NEW_LINE sizes = [ 0 for h in range ( pannukakkuja ) ] NEW_LINE kakut = [ pannukakku ( ) for h in range ( pannukakkuja ) ] NEW_LINE for h in range ( 0 , pannukakkuja ) : NEW_LINE INDENT r , s = [ int ( s ) for s in input ( ) . split ( \" \u2581 \" ) ] ; NEW_LINE kakut [ h ] . radius = r ; NEW_LINE kakut [ h ] . heigth = s ; NEW_LINE kakut [ h ] . size_h = math . pi * 2 * r * s ; NEW_LINE kakut [ h ] . size_r = math . pi * r * r ; NEW_LINE DEDENT total = 0 ; NEW_LINE current_r = 0 ; NEW_LINE for p in range ( tilauksen_koko ) : NEW_LINE INDENT isoin = poista_isoin ( kakut , current_r ) ; NEW_LINE total += isoin . size ( current_r ) ; NEW_LINE current_r = max ( current_r , isoin . radius ) ; NEW_LINE DEDENT print ( \" Case \u2581 # { 0 : . 0f } : \u2581 { 1 : . 6f } \" . format ( i , total ) ) ; NEW_LINE DEDENT"}
{"id": "atcoder_ABC052_C", "sol": 0, "python_code": "from collections import defaultdict\ndef primeFactors ( n ) :\n    res = [ ]\n    while n % 2 == 0 :\n        res.append ( 2 )\n        n //= 2\n    x = 3\n    while n > 1 and n >= x * x :\n        while n % x == 0 :\n            res.append ( x )\n            n //= x\n        x += 2\n    if n > 1 :\n        res.append ( n )\n    return res\ndef modpow ( a , n , m ) :\n    res = 1\n    while n > 0 :\n        if n % 2 == 1 :\n            res = ( res * a ) % m\n        a = ( a * a ) % m\n        n = n // 2\n    return res\nMOD = 10 ** 9 + 7\nn = int ( input ( ) )\nd = defaultdict ( int )\nfor i in range ( 1 , n + 1 ) :\n    for r in primeFactors ( i ) :\n        d [ r ] += 1\nres = 1\nfor k in d.keys ( ) :\n    res *= ( d [ k ] + 1 )\n    res %= MOD\nprint ( res )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE def primeFactors ( n ) : NEW_LINE INDENT res = [ ] NEW_LINE while n % 2 == 0 : NEW_LINE INDENT res . append ( 2 ) NEW_LINE n //= 2 NEW_LINE DEDENT x = 3 NEW_LINE while n > 1 and n >= x * x : NEW_LINE INDENT while n % x == 0 : NEW_LINE INDENT res . append ( x ) NEW_LINE n //= x NEW_LINE DEDENT x += 2 NEW_LINE DEDENT if n > 1 : NEW_LINE INDENT res . append ( n ) NEW_LINE DEDENT return res NEW_LINE DEDENT def modpow ( a , n , m ) : NEW_LINE INDENT res = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT res = ( res * a ) % m NEW_LINE DEDENT a = ( a * a ) % m NEW_LINE n = n // 2 NEW_LINE DEDENT return res NEW_LINE DEDENT MOD = 10 ** 9 + 7 NEW_LINE n = int ( input ( ) ) NEW_LINE d = defaultdict ( int ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for r in primeFactors ( i ) : NEW_LINE INDENT d [ r ] += 1 NEW_LINE DEDENT DEDENT res = 1 NEW_LINE for k in d . keys ( ) : NEW_LINE INDENT res *= ( d [ k ] + 1 ) NEW_LINE res %= MOD NEW_LINE DEDENT print ( res ) NEW_LINE"}
{"id": "geeksforgeeks_4904_A", "sol": 0, "python_code": "def maxDiff ( arr , n ) :\n    diff = [ 0 ] * ( n - 1 )\n    for i in range ( 0 , n - 1 ) :\n        diff [ i ] = arr [ i + 1 ] - arr [ i ]\n    max_diff = diff [ 0 ]\n    for i in range ( 1 , n - 1 ) :\n        if ( diff [ i - 1 ] > 0 ) :\n            diff [ i ] += diff [ i - 1 ]\n        if ( max_diff < diff [ i ] ) :\n            max_diff = diff [ i ]\n    return max_diff\narr = [ 80 , 2 , 6 , 3 , 100 ]\nsize = len ( arr )\nprint ( \"Maximum difference is\" , maxDiff ( arr , size ) )\n", "python_code_tokenized": "def maxDiff ( arr , n ) : NEW_LINE INDENT diff = [ 0 ] * ( n - 1 ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT diff [ i ] = arr [ i + 1 ] - arr [ i ] NEW_LINE DEDENT max_diff = diff [ 0 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( diff [ i - 1 ] > 0 ) : NEW_LINE INDENT diff [ i ] += diff [ i - 1 ] NEW_LINE DEDENT if ( max_diff < diff [ i ] ) : NEW_LINE INDENT max_diff = diff [ i ] NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT arr = [ 80 , 2 , 6 , 3 , 100 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Maximum \u2581 difference \u2581 is \" , maxDiff ( arr , size ) ) NEW_LINE"}
{"id": "codeforces_515_A", "sol": 0, "python_code": "a , b , s = map ( int , input ( ).split ( ) )\nx = abs ( b ) + abs ( a )\nif s < x :\n    print ( \"NO\" )\nelif s == x :\n    print ( \"YES\" )\nelse :\n    if ( s - x ) % 2 == 0 :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "a , b , s = map ( int , input ( ) . split ( ) ) NEW_LINE x = abs ( b ) + abs ( a ) NEW_LINE if s < x : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT elif s == x : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( s - x ) % 2 == 0 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_940_A", "sol": 0, "python_code": "try :\n    N , d = map ( int , input ( ).split ( ) )\n    nums = list ( map ( int , input ( ).split ( ) ) )\n    nums.sort ( )\n    ans = 0\n    for i in range ( N ) :\n        for j in range ( N - 1 , i - 1 , - 1 ) :\n            if abs ( nums [ i ] - nums [ j ] ) <= d :\n                ans = max ( ans , j - i + 1 )\n                break\n    print ( N - ans )\nexcept Exception as e :\n    print ( e )\n", "python_code_tokenized": "try : NEW_LINE INDENT N , d = map ( int , input ( ) . split ( ) ) NEW_LINE nums = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE nums . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N - 1 , i - 1 , - 1 ) : NEW_LINE INDENT if abs ( nums [ i ] - nums [ j ] ) <= d : NEW_LINE INDENT ans = max ( ans , j - i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( N - ans ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT"}
{"id": "aizu_p00816_A", "sol": 0, "python_code": "while True :\n    t , n = input ( ).split ( )\n    t = int ( t )\n    if t == 0 :\n        exit ( )\n    L = len ( n )\n    m = 0\n    parts = [ ]\n    f = False\n    for b in range ( 1 << ( L - 1 ) ) :\n        c = int ( n [ 0 ] )\n        s = 0\n        li = [ ]\n        for k in range ( L - 1 ) :\n            if b >> k & 1 == 1 :\n                s += c\n                li.append ( c )\n                c = 0\n            c = 10 * c + int ( n [ k + 1 ] )\n        s += c\n        li.append ( c )\n        c = 0\n        if s > t :\n            continue\n        if s >= m :\n            f = ( s == m )\n            m = s\n            parts = li\n    if f :\n        print ( 'rejected' )\n    elif m == 0 :\n        print ( 'error' )\n    else :\n        print ( m , * parts , sep = ' ' )\n", "python_code_tokenized": "while True : NEW_LINE INDENT t , n = input ( ) . split ( ) NEW_LINE t = int ( t ) NEW_LINE if t == 0 : NEW_LINE INDENT exit ( ) NEW_LINE DEDENT L = len ( n ) NEW_LINE m = 0 NEW_LINE parts = [ ] NEW_LINE f = False NEW_LINE for b in range ( 1 << ( L - 1 ) ) : NEW_LINE INDENT c = int ( n [ 0 ] ) NEW_LINE s = 0 NEW_LINE li = [ ] NEW_LINE for k in range ( L - 1 ) : NEW_LINE INDENT if b >> k & 1 == 1 : NEW_LINE INDENT s += c NEW_LINE li . append ( c ) NEW_LINE c = 0 NEW_LINE DEDENT c = 10 * c + int ( n [ k + 1 ] ) NEW_LINE DEDENT s += c NEW_LINE li . append ( c ) NEW_LINE c = 0 NEW_LINE if s > t : NEW_LINE INDENT continue NEW_LINE DEDENT if s >= m : NEW_LINE INDENT f = ( s == m ) NEW_LINE m = s NEW_LINE parts = li NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT print ( ' rejected ' ) NEW_LINE DEDENT elif m == 0 : NEW_LINE INDENT print ( ' error ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( m , * parts , sep = ' \u2581 ' ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_876_B", "sol": 0, "python_code": "n , k , m = map ( int , input ( ).split ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\ne = { }\nfor item in a :\n    u = item % m\n    if e.get ( u ) :\n        e [ u ].append ( item )\n    else :\n        e [ u ] = [ item ]\nthings = sorted ( list ( e.values ( ) ) , key = lambda x : len ( x ) , reverse = True )\nthe_one = things [ 0 ]\nif len ( the_one ) < k :\n    print ( \"No\" )\nelse :\n    print ( \"Yes\" )\n    print ( * the_one [ : k ] )\n", "python_code_tokenized": "n , k , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE e = { } NEW_LINE for item in a : NEW_LINE INDENT u = item % m NEW_LINE if e . get ( u ) : NEW_LINE INDENT e [ u ] . append ( item ) NEW_LINE DEDENT else : NEW_LINE INDENT e [ u ] = [ item ] NEW_LINE DEDENT DEDENT things = sorted ( list ( e . values ( ) ) , key = lambda x : len ( x ) , reverse = True ) NEW_LINE the_one = things [ 0 ] NEW_LINE if len ( the_one ) < k : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE print ( * the_one [ : k ] ) NEW_LINE DEDENT"}
{"id": "aizu_p01614_A", "sol": 0, "python_code": "from operator import itemgetter\nm_inf = float ( \"-inf\" )\nn = int ( input ( ) )\nphrase = [ 0 ] * ( 394 )\nfor s , l , p in ( map ( int , input ( ).split ( ) ) for _ in [ 0 ] * n ) :\n    for i , _p in enumerate ( phrase [ s : l + 1 ] , start = s ) :\n        phrase [ i ] = _p if _p > p else p\ndp = [ 0 ] + [ m_inf ] * 393\nfor length , p in filter ( itemgetter ( 1 ) , enumerate ( phrase ) ) :\n    for from_p , to_p , to in zip ( dp , dp [ length : ] , range ( length , 395 ) ) :\n        dp [ to ] = to_p if to_p >= from_p + p else from_p + p\nresult = [ dp [ int ( input ( ) ) ] for _ in [ 0 ] * int ( input ( ) ) ]\nprint ( * ( result if m_inf not in result else [ - 1 ] ) , sep = \"\\n\" )\n", "python_code_tokenized": "from operator import itemgetter NEW_LINE m_inf = float ( \" - inf \" ) NEW_LINE n = int ( input ( ) ) NEW_LINE phrase = [ 0 ] * ( 394 ) NEW_LINE for s , l , p in ( map ( int , input ( ) . split ( ) ) for _ in [ 0 ] * n ) : NEW_LINE INDENT for i , _p in enumerate ( phrase [ s : l + 1 ] , start = s ) : NEW_LINE INDENT phrase [ i ] = _p if _p > p else p NEW_LINE DEDENT DEDENT dp = [ 0 ] + [ m_inf ] * 393 NEW_LINE for length , p in filter ( itemgetter ( 1 ) , enumerate ( phrase ) ) : NEW_LINE INDENT for from_p , to_p , to in zip ( dp , dp [ length : ] , range ( length , 395 ) ) : NEW_LINE INDENT dp [ to ] = to_p if to_p >= from_p + p else from_p + p NEW_LINE DEDENT DEDENT result = [ dp [ int ( input ( ) ) ] for _ in [ 0 ] * int ( input ( ) ) ] NEW_LINE print ( * ( result if m_inf not in result else [ - 1 ] ) , sep = \" \\n \" ) NEW_LINE"}
{"id": "geeksforgeeks_2205_A", "sol": 0, "python_code": "def countDivisibleSubseq ( str , n ) :\n    l = len ( str )\n    dp = [ [ 0 for x in range ( l ) ] for y in range ( n ) ]\n    dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1\n    for i in range ( 1 , l ) :\n        dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1\n        for j in range ( n ) :\n            dp [ i ] [ j ] += dp [ i - 1 ] [ j ]\n            dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ]\n    return dp [ l - 1 ] [ 0 ]\nif __name__ == \"__main__\" :\n    str = \"1234\"\n    n = 4\n    print ( countDivisibleSubseq ( str , n ) )\n", "python_code_tokenized": "def countDivisibleSubseq ( str , n ) : NEW_LINE INDENT l = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( l ) ] for y in range ( n ) ] NEW_LINE dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT return dp [ l - 1 ] [ 0 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"1234\" NEW_LINE n = 4 NEW_LINE print ( countDivisibleSubseq ( str , n ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ARC101_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nclass BIT ( ) :\n    def __init__ ( self , size ) :\n        self.table = [ 0 for _ in range ( size + 2 ) ]\n        self.size = size\n    def b_sum ( self , i ) :\n        s = 0\n        while i > 0 :\n            s += self.table [ i ]\n            i -= ( i & - i )\n        return s\n    def b_add ( self , i , x ) :\n        while i <= self.size :\n            self.table [ i ] += x\n            i += ( i & - i )\n        return\nfr , ba = min ( a ) , max ( a ) + 1\nwhile ba - fr > 1 :\n    mi = ( fr + ba ) // 2\n    bit = BIT ( n + 1 )\n    res = 0\n    inv = [ 0 ]\n    min_tmp = 0\n    for j in range ( n ) :\n        if a [ j ] >= mi :\n            inv.append ( inv [ - 1 ] + 1 )\n        else :\n            inv.append ( inv [ - 1 ] - 1 )\n            min_tmp = min ( min_tmp , inv [ - 1 ] )\n    for j in range ( n + 1 ) :\n        res += bit.b_sum ( inv [ j ] - min_tmp + 1 )\n        bit.b_add ( inv [ j ] - min_tmp + 1 , 1 )\n    if res >= ( n * ( n + 1 ) / 4 ) :\n        fr = mi\n    else :\n        ba = mi\nprint ( fr )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE class BIT ( ) : NEW_LINE INDENT def __init__ ( self , size ) : NEW_LINE INDENT self . table = [ 0 for _ in range ( size + 2 ) ] NEW_LINE self . size = size NEW_LINE DEDENT def b_sum ( self , i ) : NEW_LINE INDENT s = 0 NEW_LINE while i > 0 : NEW_LINE INDENT s += self . table [ i ] NEW_LINE i -= ( i & - i ) NEW_LINE DEDENT return s NEW_LINE DEDENT def b_add ( self , i , x ) : NEW_LINE INDENT while i <= self . size : NEW_LINE INDENT self . table [ i ] += x NEW_LINE i += ( i & - i ) NEW_LINE DEDENT return NEW_LINE DEDENT DEDENT fr , ba = min ( a ) , max ( a ) + 1 NEW_LINE while ba - fr > 1 : NEW_LINE INDENT mi = ( fr + ba ) // 2 NEW_LINE bit = BIT ( n + 1 ) NEW_LINE res = 0 NEW_LINE inv = [ 0 ] NEW_LINE min_tmp = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] >= mi : NEW_LINE INDENT inv . append ( inv [ - 1 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT inv . append ( inv [ - 1 ] - 1 ) NEW_LINE min_tmp = min ( min_tmp , inv [ - 1 ] ) NEW_LINE DEDENT DEDENT for j in range ( n + 1 ) : NEW_LINE INDENT res += bit . b_sum ( inv [ j ] - min_tmp + 1 ) NEW_LINE bit . b_add ( inv [ j ] - min_tmp + 1 , 1 ) NEW_LINE DEDENT if res >= ( n * ( n + 1 ) / 4 ) : NEW_LINE INDENT fr = mi NEW_LINE DEDENT else : NEW_LINE INDENT ba = mi NEW_LINE DEDENT DEDENT print ( fr ) NEW_LINE"}
{"id": "geeksforgeeks_4974_A", "sol": 0, "python_code": "def check_elements ( arr , n , A , B ) :\n    rangeV = B - A\n    for i in range ( 0 , n ) :\n        if ( abs ( arr [ i ] ) >= A and abs ( arr [ i ] ) <= B ) :\n            z = abs ( arr [ i ] ) - A\n            if ( arr [ z ] > 0 ) :\n                arr [ z ] = arr [ z ] * - 1\n    count = 0\n    for i in range ( 0 , rangeV + 1 ) :\n        if i >= n :\n            break\n        if ( arr [ i ] > 0 ) :\n            return False\n        else :\n            count = count + 1\n    if ( count != ( rangeV + 1 ) ) :\n        return False\n    return True\narr = [ 1 , 4 , 5 , 2 , 7 , 8 , 3 ]\nn = len ( arr )\nA = 2\nB = 5\nif ( check_elements ( arr , n , A , B ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def check_elements ( arr , n , A , B ) : NEW_LINE INDENT rangeV = B - A NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) >= A and abs ( arr [ i ] ) <= B ) : NEW_LINE INDENT z = abs ( arr [ i ] ) - A NEW_LINE if ( arr [ z ] > 0 ) : NEW_LINE INDENT arr [ z ] = arr [ z ] * - 1 NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 0 , rangeV + 1 ) : NEW_LINE INDENT if i >= n : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if ( count != ( rangeV + 1 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT arr = [ 1 , 4 , 5 , 2 , 7 , 8 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE A = 2 NEW_LINE B = 5 NEW_LINE if ( check_elements ( arr , n , A , B ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1200_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n , m , k = map ( int , input ( ).split ( ) )\n    l = [ int ( x ) for x in input ( ).split ( ) ]\n    i = 0\n    while ( i < n - 1 ) :\n        x = min ( k - l [ i + 1 ] , 0 )\n        m += ( l [ i ] + x )\n        if m < 0 :\n            break\n        i += 1\n    if i == n - 1 :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT x = min ( k - l [ i + 1 ] , 0 ) NEW_LINE m += ( l [ i ] + x ) NEW_LINE if m < 0 : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if i == n - 1 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_490_A", "sol": 0, "python_code": "import heapq\ndef check ( A , B , N ) :\n    pq1 = [ ]\n    pq2 = [ ]\n    for i in range ( N ) :\n        heapq.heappush ( pq1 , - A [ i ] )\n    for i in range ( N ) :\n        heapq.heappush ( pq2 , - B [ i ] )\n    c = 0\n    for i in range ( N ) :\n        if - pq1 [ 0 ] > - pq2 [ 0 ] :\n            c += 1\n            heapq.heappop ( pq1 )\n            heapq.heappop ( pq2 )\n        else :\n            if len ( pq2 ) == 0 :\n                break\n            heapq.heappop ( pq2 )\n    return ( c )\nA = [ 10 , 3 , 7 , 5 , 8 ]\nB = [ 8 , 6 , 2 , 5 , 9 ]\nN = len ( A )\nprint ( check ( A , B , N ) )\n", "python_code_tokenized": "import heapq NEW_LINE def check ( A , B , N ) : NEW_LINE INDENT pq1 = [ ] NEW_LINE pq2 = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT heapq . heappush ( pq1 , - A [ i ] ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT heapq . heappush ( pq2 , - B [ i ] ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if - pq1 [ 0 ] > - pq2 [ 0 ] : NEW_LINE INDENT c += 1 NEW_LINE heapq . heappop ( pq1 ) NEW_LINE heapq . heappop ( pq2 ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( pq2 ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT heapq . heappop ( pq2 ) NEW_LINE DEDENT DEDENT return ( c ) NEW_LINE DEDENT A = [ 10 , 3 , 7 , 5 , 8 ] NEW_LINE B = [ 8 , 6 , 2 , 5 , 9 ] NEW_LINE N = len ( A ) NEW_LINE print ( check ( A , B , N ) ) NEW_LINE"}
{"id": "aizu_p00578_A", "sol": 0, "python_code": "from collections import defaultdict\nN = int ( input ( ) )\nA = list ( map ( int , input ( ).split ( ) ) )\nif all ( a == 0 for a in A ) :\n    print ( 0 )\n    exit ( )\nposition = defaultdict ( list )\nfor i , a in enumerate ( A ) :\n    position [ a ].append ( i )\nans = 0\nuse = 0\nlink = 0\nfor a in sorted ( set ( A ) , reverse = True ) :\n    use += len ( position [ a ] )\n    for i in position [ a ] :\n        if i > 0 and A [ i ] < A [ i - 1 ] :\n            link += 1\n        if i < N - 1 and A [ i ] <= A [ i + 1 ] :\n            link += 1\n    ans = max ( ans , use - link )\nprint ( ans )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if all ( a == 0 for a in A ) : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT position = defaultdict ( list ) NEW_LINE for i , a in enumerate ( A ) : NEW_LINE INDENT position [ a ] . append ( i ) NEW_LINE DEDENT ans = 0 NEW_LINE use = 0 NEW_LINE link = 0 NEW_LINE for a in sorted ( set ( A ) , reverse = True ) : NEW_LINE INDENT use += len ( position [ a ] ) NEW_LINE for i in position [ a ] : NEW_LINE INDENT if i > 0 and A [ i ] < A [ i - 1 ] : NEW_LINE INDENT link += 1 NEW_LINE DEDENT if i < N - 1 and A [ i ] <= A [ i + 1 ] : NEW_LINE INDENT link += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , use - link ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_2183_A", "sol": 0, "python_code": "def sumOfDigits ( n ) :\n    Sum = 0\n    while ( n != 0 ) :\n        Sum = Sum + n % 10\n        n = n // 10\n    return Sum\ndef countTheNumbers ( l , r , y ) :\n    count = 0\n    for i in range ( l , r + 1 ) :\n        if ( sumOfDigits ( i ) == y ) :\n            count += 1\n    return count\nl , r , y = 0 , 10 , 1\nprint ( countTheNumbers ( l , r , y ) )\n", "python_code_tokenized": "def sumOfDigits ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT Sum = Sum + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return Sum NEW_LINE DEDENT def countTheNumbers ( l , r , y ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( sumOfDigits ( i ) == y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT l , r , y = 0 , 10 , 1 NEW_LINE print ( countTheNumbers ( l , r , y ) ) NEW_LINE"}
{"id": "geeksforgeeks_3210_A", "sol": 0, "python_code": "def __gcd ( a , b ) :\n    if ( a == 0 or b == 0 ) :\n        return 0\n    if ( a == b ) :\n        return a\n    if ( a > b ) :\n        return __gcd ( a - b , b )\n    return __gcd ( a , b - a )\ndef findValue ( x , y , z ) :\n    g = __gcd ( y , z )\n    return ( x * g ) / __gcd ( x , g )\nx = 30\ny = 40\nz = 400\nprint ( \"%d\" % findValue ( x , y , z ) )\n", "python_code_tokenized": "def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def findValue ( x , y , z ) : NEW_LINE INDENT g = __gcd ( y , z ) NEW_LINE return ( x * g ) / __gcd ( x , g ) NEW_LINE DEDENT x = 30 NEW_LINE y = 40 NEW_LINE z = 400 NEW_LINE print ( \" % d \" % findValue ( x , y , z ) ) NEW_LINE"}
{"id": "geeksforgeeks_38_A", "sol": 0, "python_code": "limit = 1000000\nposition = [ 0 ] * ( limit + 1 )\ndef sieve ( ) :\n    position [ 0 ] = - 1\n    position [ 1 ] = - 1\n    pos = 0\n    for i in range ( 2 , limit + 1 ) :\n        if ( position [ i ] == 0 ) :\n            pos += 1\n            position [ i ] = pos\n            for j in range ( i * 2 , limit + 1 , i ) :\n                position [ j ] = - 1\nif __name__ == \"__main__\" :\n    sieve ( )\n    n = 11\n    print ( position [ n ] )\n", "python_code_tokenized": "limit = 1000000 NEW_LINE position = [ 0 ] * ( limit + 1 ) NEW_LINE def sieve ( ) : NEW_LINE INDENT position [ 0 ] = - 1 NEW_LINE position [ 1 ] = - 1 NEW_LINE pos = 0 NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if ( position [ i ] == 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE position [ i ] = pos NEW_LINE for j in range ( i * 2 , limit + 1 , i ) : NEW_LINE INDENT position [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sieve ( ) NEW_LINE n = 11 NEW_LINE print ( position [ n ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5071_A", "sol": 0, "python_code": "def ksmallest ( arr , n , k ) :\n    arr.sort ( ) ;\n    if ( k < arr [ 0 ] ) :\n        return k ;\n    if ( k == arr [ 0 ] ) :\n        return arr [ 0 ] + 1 ;\n    if ( k > arr [ n - 1 ] ) :\n        return k + n ;\n    if ( arr [ 0 ] == 1 ) :\n        k -= 1 ;\n    else :\n        k -= ( arr [ 0 ] - 1 ) ;\n    for i in range ( 1 , n ) :\n        c = arr [ i ] - arr [ i - 1 ] - 1 ;\n        if ( k <= c ) :\n            return arr [ i - 1 ] + k ;\n        else :\n            k -= c ;\n    return arr [ n - 1 ] + k ;\nk = 1 ;\narr = [ 1 ] ;\nn = len ( arr ) ;\nprint ( ksmallest ( arr , n , k ) ) ;\n", "python_code_tokenized": "def ksmallest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE if ( k < arr [ 0 ] ) : NEW_LINE INDENT return k ; NEW_LINE DEDENT if ( k == arr [ 0 ] ) : NEW_LINE INDENT return arr [ 0 ] + 1 ; NEW_LINE DEDENT if ( k > arr [ n - 1 ] ) : NEW_LINE INDENT return k + n ; NEW_LINE DEDENT if ( arr [ 0 ] == 1 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT k -= ( arr [ 0 ] - 1 ) ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT c = arr [ i ] - arr [ i - 1 ] - 1 ; NEW_LINE if ( k <= c ) : NEW_LINE INDENT return arr [ i - 1 ] + k ; NEW_LINE DEDENT else : NEW_LINE INDENT k -= c ; NEW_LINE DEDENT DEDENT return arr [ n - 1 ] + k ; NEW_LINE DEDENT k = 1 ; NEW_LINE arr = [ 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ksmallest ( arr , n , k ) ) ; NEW_LINE"}
{"id": "atcoder_AGC017_C", "sol": 0, "python_code": "import sys\nimport numpy as np\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef main ( A , X , Y ) :\n    N = len ( A )\n    count = np.zeros ( N + 1 , np.int64 )\n    covered = np.zeros ( N + 1 , np.int64 )\n    for x in A :\n        count [ x ] += 1\n        y = x - count [ x ] + 1\n        if y > 0 :\n            covered [ y ] += 1\n    spell = np.sum ( covered [ 1 : ] == 0 )\n    for i in range ( len ( X ) ) :\n        x , y = X [ i ] , Y [ i ]\n        before = A [ x - 1 ]\n        after = y\n        A [ x - 1 ] = y\n        rem = before - count [ before ] + 1\n        count [ before ] -= 1\n        add = after - count [ after ]\n        count [ after ] += 1\n        if rem > 0 :\n            covered [ rem ] -= 1\n            if not covered [ rem ] :\n                spell += 1\n        if add > 0 :\n            if not covered [ add ] :\n                spell -= 1\n            covered [ add ] += 1\n        print ( spell )\nif sys.argv [ - 1 ] == 'ONLINE_JUDGE' :\n    import numba\n    from numba.pycc import CC\n    i8 = numba.from_dtype ( np.int64 )\n    signature = ( i8 [ : ] , i8 [ : ] , i8 [ : ] )\n    cc = CC ( 'my_module' )\n    cc.export ( 'main' , signature ) ( main )\n    cc.compile ( )\nfrom my_module import main\nN , M = map ( int , readline ( ).split ( ) )\nA = np.array ( readline ( ).split ( ) , np.int64 )\nXY = np.array ( read ( ).split ( ) , np.int64 )\nX = XY [ : : 2 ]\nY = XY [ 1 : : 2 ]\nmain ( A , X , Y )\n", "python_code_tokenized": "import sys NEW_LINE import numpy as np NEW_LINE read = sys . stdin . buffer . read NEW_LINE readline = sys . stdin . buffer . readline NEW_LINE readlines = sys . stdin . buffer . readlines NEW_LINE def main ( A , X , Y ) : NEW_LINE INDENT N = len ( A ) NEW_LINE count = np . zeros ( N + 1 , np . int64 ) NEW_LINE covered = np . zeros ( N + 1 , np . int64 ) NEW_LINE for x in A : NEW_LINE INDENT count [ x ] += 1 NEW_LINE y = x - count [ x ] + 1 NEW_LINE if y > 0 : NEW_LINE INDENT covered [ y ] += 1 NEW_LINE DEDENT DEDENT spell = np . sum ( covered [ 1 : ] == 0 ) NEW_LINE for i in range ( len ( X ) ) : NEW_LINE INDENT x , y = X [ i ] , Y [ i ] NEW_LINE before = A [ x - 1 ] NEW_LINE after = y NEW_LINE A [ x - 1 ] = y NEW_LINE rem = before - count [ before ] + 1 NEW_LINE count [ before ] -= 1 NEW_LINE add = after - count [ after ] NEW_LINE count [ after ] += 1 NEW_LINE if rem > 0 : NEW_LINE INDENT covered [ rem ] -= 1 NEW_LINE if not covered [ rem ] : NEW_LINE INDENT spell += 1 NEW_LINE DEDENT DEDENT if add > 0 : NEW_LINE INDENT if not covered [ add ] : NEW_LINE INDENT spell -= 1 NEW_LINE DEDENT covered [ add ] += 1 NEW_LINE DEDENT print ( spell ) NEW_LINE DEDENT DEDENT if sys . argv [ - 1 ] == ' ONLINE _ JUDGE ' : NEW_LINE INDENT import numba NEW_LINE from numba . pycc import CC NEW_LINE i8 = numba . from_dtype ( np . int64 ) NEW_LINE signature = ( i8 [ : ] , i8 [ : ] , i8 [ : ] ) NEW_LINE cc = CC ( ' my _ module ' ) NEW_LINE cc . export ( ' main ' , signature ) ( main ) NEW_LINE cc . compile ( ) NEW_LINE DEDENT from my_module import main NEW_LINE N , M = map ( int , readline ( ) . split ( ) ) NEW_LINE A = np . array ( readline ( ) . split ( ) , np . int64 ) NEW_LINE XY = np . array ( read ( ) . split ( ) , np . int64 ) NEW_LINE X = XY [ : : 2 ] NEW_LINE Y = XY [ 1 : : 2 ] NEW_LINE main ( A , X , Y ) NEW_LINE"}
{"id": "geeksforgeeks_4449_A", "sol": 0, "python_code": "def checkIfStartsWithVowels ( string ) :\n    if ( not ( string [ 0 ] == 'A' or string [ 0 ] == 'a' or string [ 0 ] == 'E' or string [ 0 ] == 'e' or string [ 0 ] == 'I' or string [ 0 ] == 'i' or string [ 0 ] == 'O' or string [ 0 ] == 'o' or string [ 0 ] == 'U' or string [ 0 ] == 'u' ) ) :\n        return 1 ;\n    else :\n        return 0 ;\ndef check ( string ) :\n    if ( checkIfStartsWithVowels ( string ) ) :\n        print ( \"Not Accepted\" ) ;\n    else :\n        print ( \"Accepted\" ) ;\nif __name__ == \"__main__\" :\n    string = \"animal\" ;\n    check ( string ) ;\n    string = \"zebra\" ;\n    check ( string ) ;\n", "python_code_tokenized": "def checkIfStartsWithVowels ( string ) : NEW_LINE INDENT if ( not ( string [ 0 ] == ' A ' or string [ 0 ] == ' a ' or string [ 0 ] == ' E ' or string [ 0 ] == ' e ' or string [ 0 ] == ' I ' or string [ 0 ] == ' i ' or string [ 0 ] == ' O ' or string [ 0 ] == ' o ' or string [ 0 ] == ' U ' or string [ 0 ] == ' u ' ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT def check ( string ) : NEW_LINE INDENT if ( checkIfStartsWithVowels ( string ) ) : NEW_LINE INDENT print ( \" Not \u2581 Accepted \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Accepted \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" animal \" ; NEW_LINE check ( string ) ; NEW_LINE string = \" zebra \" ; NEW_LINE check ( string ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2360_A", "sol": 0, "python_code": "def minflip ( arr1 , arr2 , arr3 , p , q , n ) :\n    flip = 0\n    for i in range ( 0 , n ) :\n        if ( arr1 [ i ] ^ arr2 [ i ] != arr3 [ i ] ) :\n            flip += 1\n    return flip if ( flip <= p + q ) else - 1\narr1 = [ 1 , 0 , 1 , 1 , 1 , 1 , 1 ]\narr2 = [ 0 , 1 , 1 , 1 , 1 , 0 , 0 ]\narr3 = [ 1 , 1 , 1 , 1 , 0 , 0 , 1 ]\nn = len ( arr1 )\np = 2\nq = 4\nprint ( minflip ( arr1 , arr2 , arr3 , p , q , n ) )\n", "python_code_tokenized": "def minflip ( arr1 , arr2 , arr3 , p , q , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] ^ arr2 [ i ] != arr3 [ i ] ) : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT return flip if ( flip <= p + q ) else - 1 NEW_LINE DEDENT arr1 = [ 1 , 0 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE arr2 = [ 0 , 1 , 1 , 1 , 1 , 0 , 0 ] NEW_LINE arr3 = [ 1 , 1 , 1 , 1 , 0 , 0 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE p = 2 NEW_LINE q = 4 NEW_LINE print ( minflip ( arr1 , arr2 , arr3 , p , q , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2994_A", "sol": 0, "python_code": "import math\ndef factorial ( n ) :\n    fact = 1\n    for i in range ( 1 , n + 1 ) :\n        fact = fact * i\n    return fact ;\ndef findMiddleTerm ( A , X , n ) :\n    if ( n % 2 == 0 ) :\n        i = int ( n / 2 )\n        aPow = int ( math.pow ( A , n - i ) )\n        xPow = int ( math.pow ( X , i ) )\n        middleTerm1 = ( ( math.factorial ( n ) / ( math.factorial ( n - i ) * math.factorial ( i ) ) ) * aPow * xPow )\n        print ( \"MiddleTerm = {}\".format ( middleTerm1 ) )\n    else :\n        i = int ( ( n - 1 ) / 2 )\n        j = int ( ( n + 1 ) / 2 )\n        aPow = int ( math.pow ( A , n - i ) )\n        xPow = int ( math.pow ( X , i ) )\n        middleTerm1 = ( ( math.factorial ( n ) / ( math.factorial ( n - i ) * math.factorial ( i ) ) ) * aPow * xPow )\n        aPow = int ( math.pow ( A , n - j ) )\n        xPow = int ( math.pow ( X , j ) )\n        middleTerm2 = ( ( math.factorial ( n ) / ( math.factorial ( n - j ) * math.factorial ( j ) ) ) * aPow * xPow )\n        print ( \"MiddleTerm1 = {}\".format ( int ( middleTerm1 ) ) )\n        print ( \"MiddleTerm2 = {}\".format ( int ( middleTerm2 ) ) )\nn = 5\nA = 2\nX = 3\nfindMiddleTerm ( A , X , n )\n", "python_code_tokenized": "import math NEW_LINE def factorial ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact ; NEW_LINE DEDENT def findMiddleTerm ( A , X , n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT i = int ( n / 2 ) NEW_LINE aPow = int ( math . pow ( A , n - i ) ) NEW_LINE xPow = int ( math . pow ( X , i ) ) NEW_LINE middleTerm1 = ( ( math . factorial ( n ) / ( math . factorial ( n - i ) * math . factorial ( i ) ) ) * aPow * xPow ) NEW_LINE print ( \" MiddleTerm \u2581 = \u2581 { } \" . format ( middleTerm1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT i = int ( ( n - 1 ) / 2 ) NEW_LINE j = int ( ( n + 1 ) / 2 ) NEW_LINE aPow = int ( math . pow ( A , n - i ) ) NEW_LINE xPow = int ( math . pow ( X , i ) ) NEW_LINE middleTerm1 = ( ( math . factorial ( n ) / ( math . factorial ( n - i ) * math . factorial ( i ) ) ) * aPow * xPow ) NEW_LINE aPow = int ( math . pow ( A , n - j ) ) NEW_LINE xPow = int ( math . pow ( X , j ) ) NEW_LINE middleTerm2 = ( ( math . factorial ( n ) / ( math . factorial ( n - j ) * math . factorial ( j ) ) ) * aPow * xPow ) NEW_LINE print ( \" MiddleTerm1 \u2581 = \u2581 { } \" . format ( int ( middleTerm1 ) ) ) NEW_LINE print ( \" MiddleTerm2 \u2581 = \u2581 { } \" . format ( int ( middleTerm2 ) ) ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE A = 2 NEW_LINE X = 3 NEW_LINE findMiddleTerm ( A , X , n ) NEW_LINE"}
{"id": "aizu_p00191_A", "sol": 0, "python_code": "while True :\n    N , M = map ( int , raw_input ( ).split ( ) )\n    if ( N , M ) == ( 0 , 0 ) : break\n    fert = [ map ( float , raw_input ( ).split ( ) ) for _ in range ( N ) ]\n    dp = [ [ 0 ] * N for _ in range ( M ) ]\n    for i in range ( N ) : dp [ 0 ] [ i ] = 1.0\n    for i in range ( M - 1 ) :\n        for j in range ( N ) :\n            dp [ i + 1 ] [ j ] = max ( [ dp [ i ] [ k ] * fert [ k ] [ j ] for k in range ( N ) ] )\n    print ( '{:.2f}'.format ( max ( dp [ M - 1 ] ) ) )\n", "python_code_tokenized": "while True : NEW_LINE INDENT N , M = map ( int , raw_input ( ) . split ( ) ) NEW_LINE if ( N , M ) == ( 0 , 0 ) : break NEW_LINE fert = [ map ( float , raw_input ( ) . split ( ) ) for _ in range ( N ) ] NEW_LINE dp = [ [ 0 ] * N for _ in range ( M ) ] NEW_LINE for i in range ( N ) : dp [ 0 ] [ i ] = 1.0 NEW_LINE for i in range ( M - 1 ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = max ( [ dp [ i ] [ k ] * fert [ k ] [ j ] for k in range ( N ) ] ) NEW_LINE DEDENT DEDENT print ( ' { : . 2f } ' . format ( max ( dp [ M - 1 ] ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1630_A", "sol": 0, "python_code": "def printOrder ( arr , n ) :\n    arr.sort ( )\n    for i in range ( n // 2 ) :\n        print ( arr [ i ] , end = \" \" )\n    for j in range ( n - 1 , n // 2 - 1 , - 1 ) :\n        print ( arr [ j ] , end = \" \" )\nif __name__ == \"__main__\" :\n    arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , - 1 ]\n    n = len ( arr )\n    printOrder ( arr , n )\n", "python_code_tokenized": "def printOrder ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT for j in range ( n - 1 , n // 2 - 1 , - 1 ) : NEW_LINE INDENT print ( arr [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE printOrder ( arr , n ) NEW_LINE DEDENT"}
{"id": "codeforces_236_B", "sol": 0, "python_code": "a , b , c = map ( int , input ( ).split ( ) )\nimport math\nsum = 0\nmodulo = 1073741824 * pow ( 2 , 30 )\ndef factors ( number ) :\n    if number == 1 :\n        counter = 1\n        return counter\n    counter = 2\n    for i in range ( 2 , int ( math.sqrt ( ( number ) ) + 1 ) ) :\n        if number % i == 0 :\n            if i * i == number :\n                counter += 1\n            else :\n                counter += 2\n    return counter\nfrom collections import defaultdict\nfactor = defaultdict ( int )\nfor a in range ( 1 , a + 1 ) :\n    for b in range ( 1 , b + 1 ) :\n        for c in range ( 1 , c + 1 ) :\n            multiplication = a * b * c\n            if multiplication not in factor :\n                factor [ multiplication ] = factors ( multiplication )\n            sum += factor [ multiplication ]\n            sum %= modulo\nprint ( sum )\n", "python_code_tokenized": "a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE import math NEW_LINE sum = 0 NEW_LINE modulo = 1073741824 * pow ( 2 , 30 ) NEW_LINE def factors ( number ) : NEW_LINE INDENT if number == 1 : NEW_LINE INDENT counter = 1 NEW_LINE return counter NEW_LINE DEDENT counter = 2 NEW_LINE for i in range ( 2 , int ( math . sqrt ( ( number ) ) + 1 ) ) : NEW_LINE INDENT if number % i == 0 : NEW_LINE INDENT if i * i == number : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT else : NEW_LINE INDENT counter += 2 NEW_LINE DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT from collections import defaultdict NEW_LINE factor = defaultdict ( int ) NEW_LINE for a in range ( 1 , a + 1 ) : NEW_LINE INDENT for b in range ( 1 , b + 1 ) : NEW_LINE INDENT for c in range ( 1 , c + 1 ) : NEW_LINE INDENT multiplication = a * b * c NEW_LINE if multiplication not in factor : NEW_LINE INDENT factor [ multiplication ] = factors ( multiplication ) NEW_LINE DEDENT sum += factor [ multiplication ] NEW_LINE sum %= modulo NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE"}
{"id": "projecteuler_p075_A", "sol": 0, "python_code": "import eulerlib , fractions\ndef compute ( ) :\n    LIMIT = 1500000\n    triples = set ( )\n    for s in range ( 3 , eulerlib.sqrt ( LIMIT ) + 1 , 2 ) :\n        for t in range ( s - 2 , 0 , - 2 ) :\n            if fractions.gcd ( s , t ) == 1 :\n                a = s * t\n                b = ( s * s - t * t ) // 2\n                c = ( s * s + t * t ) // 2\n                if a + b + c <= LIMIT :\n                    triples.add ( ( a , b , c ) )\n    ways = [ 0 ] * ( LIMIT + 1 )\n    for triple in triples :\n        sigma = sum ( triple )\n        for i in range ( sigma , len ( ways ) , sigma ) :\n            ways [ i ] += 1\n    ans = ways.count ( 1 )\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 1500000 NEW_LINE triples = set ( ) NEW_LINE for s in range ( 3 , eulerlib . sqrt ( LIMIT ) + 1 , 2 ) : NEW_LINE INDENT for t in range ( s - 2 , 0 , - 2 ) : NEW_LINE INDENT if fractions . gcd ( s , t ) == 1 : NEW_LINE INDENT a = s * t NEW_LINE b = ( s * s - t * t ) // 2 NEW_LINE c = ( s * s + t * t ) // 2 NEW_LINE if a + b + c <= LIMIT : NEW_LINE INDENT triples . add ( ( a , b , c ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ways = [ 0 ] * ( LIMIT + 1 ) NEW_LINE for triple in triples : NEW_LINE INDENT sigma = sum ( triple ) NEW_LINE for i in range ( sigma , len ( ways ) , sigma ) : NEW_LINE INDENT ways [ i ] += 1 NEW_LINE DEDENT DEDENT ans = ways . count ( 1 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1375_A", "sol": 0, "python_code": "MAX = 1000000\nprime = [ True for i in range ( MAX + 1 ) ]\ndef sieve ( ) :\n    prime [ 0 ] , prime [ 1 ] = False , False\n    for p in range ( 2 , MAX + 1 ) :\n        if p * p > MAX :\n            break\n        if ( prime [ p ] == True ) :\n            for i in range ( 2 * p , MAX + 1 , p ) :\n                prime [ i ] = False\ndef distinctSum ( arr1 , arr2 , m , n ) :\n    sieve ( )\n    sumSet = dict ( )\n    for i in range ( m ) :\n        for j in range ( n ) :\n            if ( prime [ arr1 [ i ] ] and prime [ arr2 [ j ] ] ) :\n                sumSet [ arr1 [ i ] + arr2 [ j ] ] = 1\n    return len ( sumSet )\narr1 = [ 2 , 3 ]\narr2 = [ 2 , 2 , 4 , 7 ]\nm = len ( arr1 )\nn = len ( arr2 )\nprint ( distinctSum ( arr1 , arr2 , m , n ) )\n", "python_code_tokenized": "MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if p * p > MAX : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def distinctSum ( arr1 , arr2 , m , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE sumSet = dict ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( prime [ arr1 [ i ] ] and prime [ arr2 [ j ] ] ) : NEW_LINE INDENT sumSet [ arr1 [ i ] + arr2 [ j ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT return len ( sumSet ) NEW_LINE DEDENT arr1 = [ 2 , 3 ] NEW_LINE arr2 = [ 2 , 2 , 4 , 7 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( distinctSum ( arr1 , arr2 , m , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3904_A", "sol": 0, "python_code": "MAX = 256\ndef countPairs ( s ) :\n    cnt = [ 0 for i in range ( 0 , MAX ) ]\n    for i in range ( len ( s ) ) :\n        cnt [ ord ( s [ i ] ) - 97 ] += 1\n    ans = 0\n    for i in range ( 0 , MAX ) :\n        ans += cnt [ i ] * cnt [ i ]\n    return ans\nif __name__ == \"__main__\" :\n    s = \"geeksforgeeks\"\n    print ( countPairs ( s ) )\n", "python_code_tokenized": "MAX = 256 NEW_LINE def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 for i in range ( 0 , MAX ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( countPairs ( s ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1545_A", "sol": 0, "python_code": "def deleteElement ( arr , n , key ) :\n    pos = binarySearch ( arr , 0 , n - 1 , key )\n    if ( pos == - 1 ) :\n        print ( \"Element not found\" )\n        return n\n    for i in range ( pos , n - 1 ) :\n        arr [ i ] = arr [ i + 1 ]\n    return n - 1\ndef binarySearch ( arr , low , high , key ) :\n    if ( high < low ) :\n        return - 1\n    mid = ( low + high ) // 2\n    if ( key == arr [ mid ] ) :\n        return mid\n    if ( key > arr [ mid ] ) :\n        return binarySearch ( arr , ( mid + 1 ) , high , key )\n    return binarySearch ( arr , low , ( mid - 1 ) , key )\narr = [ 10 , 20 , 30 , 40 , 50 ]\nn = len ( arr )\nkey = 30\nprint ( \"Array before deletion\" )\nfor i in range ( n ) :\n    print ( arr [ i ] , end = \" \" )\nn = deleteElement ( arr , n , key )\nprint ( \"\\n\\nArray after deletion\" )\nfor i in range ( n ) :\n    print ( arr [ i ] , end = \" \" )\n", "python_code_tokenized": "def deleteElement ( arr , n , key ) : NEW_LINE INDENT pos = binarySearch ( arr , 0 , n - 1 , key ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" Element \u2581 not \u2581 found \" ) NEW_LINE return n NEW_LINE DEDENT for i in range ( pos , n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT return n - 1 NEW_LINE DEDENT def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( key == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ mid ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 40 , 50 ] NEW_LINE n = len ( arr ) NEW_LINE key = 30 NEW_LINE print ( \" Array \u2581 before \u2581 deletion \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT n = deleteElement ( arr , n , key ) NEW_LINE print ( \" \\n \\n Array \u2581 after \u2581 deletion \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "codejam_12_31", "sol": 0, "python_code": "import operator\nimport itertools\nimport functools\nimport math\nfrom collections import deque\ndef bfs ( i ) :\n    res = False\n    visited = [ 0 ] * ( N + 1 )\n    q = deque ( [ node [ i ] ] )\n    while len ( q ) :\n        n = q.popleft ( )\n        if visited [ n [ 0 ] ] :\n            res = True\n            return res\n        else :\n            visited [ n [ 0 ] ] = 1\n        for x in n [ 1 : ] :\n            q.append ( node [ x ] )\nfn = open ( '1.in' )\nofn = open ( '1.out' , 'w' )\nTC = int ( fn.readline ( ) )\nfor tc in range ( TC ) :\n    N = int ( fn.readline ( ).strip ( ) )\n    node = [ None ] * ( N + 1 )\n    for i in range ( 1 , N + 1 ) :\n        r = map ( int , fn.readline ( ).strip ( ).split ( ) )\n        node [ i ] = [ i ] + r [ 1 : ]\n    for i in range ( 1 , N + 1 ) :\n        if bfs ( i ) :\n            print >> ofn , 'Case #{}: {}'.format ( tc + 1 , 'Yes' )\n            break\n    else :\n        print >> ofn , 'Case #{}: {}'.format ( tc + 1 , 'No' )\n", "python_code_tokenized": "import operator NEW_LINE import itertools NEW_LINE import functools NEW_LINE import math NEW_LINE from collections import deque NEW_LINE def bfs ( i ) : NEW_LINE INDENT res = False NEW_LINE visited = [ 0 ] * ( N + 1 ) NEW_LINE q = deque ( [ node [ i ] ] ) NEW_LINE while len ( q ) : NEW_LINE INDENT n = q . popleft ( ) NEW_LINE if visited [ n [ 0 ] ] : NEW_LINE INDENT res = True NEW_LINE return res NEW_LINE DEDENT else : NEW_LINE INDENT visited [ n [ 0 ] ] = 1 NEW_LINE DEDENT for x in n [ 1 : ] : NEW_LINE INDENT q . append ( node [ x ] ) NEW_LINE DEDENT DEDENT DEDENT fn = open ( '1 . in ' ) NEW_LINE ofn = open ( '1 . out ' , ' w ' ) NEW_LINE TC = int ( fn . readline ( ) ) NEW_LINE for tc in range ( TC ) : NEW_LINE INDENT N = int ( fn . readline ( ) . strip ( ) ) NEW_LINE node = [ None ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT r = map ( int , fn . readline ( ) . strip ( ) . split ( ) ) NEW_LINE node [ i ] = [ i ] + r [ 1 : ] NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if bfs ( i ) : NEW_LINE INDENT print >> ofn , ' Case \u2581 # { } : \u2581 { } ' . format ( tc + 1 , ' Yes ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print >> ofn , ' Case \u2581 # { } : \u2581 { } ' . format ( tc + 1 , ' No ' ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1796_A", "sol": 0, "python_code": "def squareSum ( N ) :\n    Sum = ( N * ( N + 1 ) * ( 2 * N + 1 ) ) // 6\n    return Sum\ndef findMaxN ( X ) :\n    low , high , N = 1 , 100000 , 0\n    while low <= high :\n        mid = ( high + low ) // 2\n        if squareSum ( mid ) <= X :\n            N = mid\n            low = mid + 1\n        else :\n            high = mid - 1\n    return N\nif __name__ == \"__main__\" :\n    X = 25\n    print ( findMaxN ( X ) )\n", "python_code_tokenized": "def squareSum ( N ) : NEW_LINE INDENT Sum = ( N * ( N + 1 ) * ( 2 * N + 1 ) ) // 6 NEW_LINE return Sum NEW_LINE DEDENT def findMaxN ( X ) : NEW_LINE INDENT low , high , N = 1 , 100000 , 0 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( high + low ) // 2 NEW_LINE if squareSum ( mid ) <= X : NEW_LINE INDENT N = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return N NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 25 NEW_LINE print ( findMaxN ( X ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02301_A", "sol": 0, "python_code": "from sys import stdin\nreadline = stdin.readline\ndef cross ( a , b ) :\n    return a.real * b.imag - a.imag * b.real\ndef dot ( a , b ) :\n    return a.real * b.real + a.imag * b.imag\ndef diff ( p , i ) :\n    return p [ ( i + 1 ) % len ( p ) ] - p [ i ]\ndef convex_diameter ( p ) :\n    js = ks = 0\n    for i in range ( 1 , len ( p ) ) :\n        if p [ i ].imag > p [ js ].imag :\n            js = i\n        if p [ i ].imag < p [ ks ].imag :\n            ks = i\n    maxd = abs ( p [ js ] - p [ ks ] )\n    j , k = js , ks\n    while True :\n        if cross ( diff ( p , j ) , diff ( p , k ) ) >= 0 :\n            k = ( k + 1 ) % len ( p )\n        else :\n            j = ( j + 1 ) % len ( p )\n        if maxd < abs ( p [ j ] - p [ k ] ) :\n            maxd = abs ( p [ j ] - p [ k ] )\n        if j == js and k == ks :\n            break\n    return maxd\nn = int ( readline ( ) )\np = [ map ( float , readline ( ).split ( ) ) for _ in range ( n ) ]\np = [ x + y * 1j for x , y in p ]\nprint ( '{:.6f}'.format ( convex_diameter ( p ) ) )\n", "python_code_tokenized": "from sys import stdin NEW_LINE readline = stdin . readline NEW_LINE def cross ( a , b ) : NEW_LINE INDENT return a . real * b . imag - a . imag * b . real NEW_LINE DEDENT def dot ( a , b ) : NEW_LINE INDENT return a . real * b . real + a . imag * b . imag NEW_LINE DEDENT def diff ( p , i ) : NEW_LINE INDENT return p [ ( i + 1 ) % len ( p ) ] - p [ i ] NEW_LINE DEDENT def convex_diameter ( p ) : NEW_LINE INDENT js = ks = 0 NEW_LINE for i in range ( 1 , len ( p ) ) : NEW_LINE INDENT if p [ i ] . imag > p [ js ] . imag : NEW_LINE INDENT js = i NEW_LINE DEDENT if p [ i ] . imag < p [ ks ] . imag : NEW_LINE INDENT ks = i NEW_LINE DEDENT DEDENT maxd = abs ( p [ js ] - p [ ks ] ) NEW_LINE j , k = js , ks NEW_LINE while True : NEW_LINE INDENT if cross ( diff ( p , j ) , diff ( p , k ) ) >= 0 : NEW_LINE INDENT k = ( k + 1 ) % len ( p ) NEW_LINE DEDENT else : NEW_LINE INDENT j = ( j + 1 ) % len ( p ) NEW_LINE DEDENT if maxd < abs ( p [ j ] - p [ k ] ) : NEW_LINE INDENT maxd = abs ( p [ j ] - p [ k ] ) NEW_LINE DEDENT if j == js and k == ks : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return maxd NEW_LINE DEDENT n = int ( readline ( ) ) NEW_LINE p = [ map ( float , readline ( ) . split ( ) ) for _ in range ( n ) ] NEW_LINE p = [ x + y * 1j for x , y in p ] NEW_LINE print ( ' { : . 6f } ' . format ( convex_diameter ( p ) ) ) NEW_LINE"}
{"id": "atcoder_ABC147_D", "sol": 0, "python_code": "MOD = 10 ** 9 + 7\ndef main ( ) :\n    N = int ( input ( ) )\n    AN = map ( int , input ( ).split ( ) )\n    digits_ct = [ ( 0 , 0 ) for _ in range ( 65 ) ]\n    for A in AN :\n        temp = A\n        length = 0\n        for _ in range ( 65 ) :\n            digit = temp & 0b1\n            zero , one = digits_ct [ length ]\n            if digit == 0 :\n                digits_ct [ length ] = ( zero + 1 , one )\n            else :\n                digits_ct [ length ] = ( zero , one + 1 )\n            temp = temp >> 1\n            length += 1\n    ans = 0\n    radix = 1\n    for digit_ct in digits_ct :\n        zero , one = digit_ct\n        ans += ( ( ( zero * one ) % MOD ) * radix ) % MOD\n        ans = ans % MOD\n        radix *= 2\n    print ( ans )\nmain ( )\n", "python_code_tokenized": "MOD = 10 ** 9 + 7 NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE AN = map ( int , input ( ) . split ( ) ) NEW_LINE digits_ct = [ ( 0 , 0 ) for _ in range ( 65 ) ] NEW_LINE for A in AN : NEW_LINE INDENT temp = A NEW_LINE length = 0 NEW_LINE for _ in range ( 65 ) : NEW_LINE INDENT digit = temp & 0b1 NEW_LINE zero , one = digits_ct [ length ] NEW_LINE if digit == 0 : NEW_LINE INDENT digits_ct [ length ] = ( zero + 1 , one ) NEW_LINE DEDENT else : NEW_LINE INDENT digits_ct [ length ] = ( zero , one + 1 ) NEW_LINE DEDENT temp = temp >> 1 NEW_LINE length += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE radix = 1 NEW_LINE for digit_ct in digits_ct : NEW_LINE INDENT zero , one = digit_ct NEW_LINE ans += ( ( ( zero * one ) % MOD ) * radix ) % MOD NEW_LINE ans = ans % MOD NEW_LINE radix *= 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT main ( ) NEW_LINE"}
{"id": "codeforces_984_A", "sol": 0, "python_code": "import sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\nn = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\na.sort ( reverse = True )\nans = a [ n // 2 ]\nprint ( ans )\n", "python_code_tokenized": "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE ans = a [ n // 2 ] NEW_LINE print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_4920_A", "sol": 0, "python_code": "def find_sub ( s , k ) :\n    Len = len ( s )\n    lp , rp = 0 , 0\n    ans = 0\n    hash_char = [ 0 for i in range ( 256 ) ]\n    for rp in range ( Len ) :\n        hash_char [ ord ( s [ rp ] ) ] += 1\n        while ( hash_char [ ord ( s [ rp ] ) ] > k ) :\n            hash_char [ ord ( s [ lp ] ) ] -= 1\n            lp += 1\n        ans += rp - lp + 1\n    return ans\ns = \"aaabb\"\nk = 2 ;\nprint ( find_sub ( s , k ) )\n", "python_code_tokenized": "def find_sub ( s , k ) : NEW_LINE INDENT Len = len ( s ) NEW_LINE lp , rp = 0 , 0 NEW_LINE ans = 0 NEW_LINE hash_char = [ 0 for i in range ( 256 ) ] NEW_LINE for rp in range ( Len ) : NEW_LINE INDENT hash_char [ ord ( s [ rp ] ) ] += 1 NEW_LINE while ( hash_char [ ord ( s [ rp ] ) ] > k ) : NEW_LINE INDENT hash_char [ ord ( s [ lp ] ) ] -= 1 NEW_LINE lp += 1 NEW_LINE DEDENT ans += rp - lp + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT s = \" aaabb \" NEW_LINE k = 2 ; NEW_LINE print ( find_sub ( s , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_1299_A", "sol": 0, "python_code": "def find_numbers ( N ) :\n    if ( N == 1 ) :\n        print ( - 1 , end = \"\" ) ;\n    else :\n        print ( N , N + 1 , N * ( N + 1 ) ) ;\nif __name__ == \"__main__\" :\n    N = 5 ;\n    find_numbers ( N ) ;\n", "python_code_tokenized": "def find_numbers ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT print ( - 1 , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , N + 1 , N * ( N + 1 ) ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 ; NEW_LINE find_numbers ( N ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4777_A", "sol": 0, "python_code": "import math\ndef geometricMean ( arr , n ) :\n    product = 1\n    for i in range ( 0 , n ) :\n        product = product * arr [ i ]\n    gm = ( float ) ( math.pow ( product , ( 1 / n ) ) )\n    return ( float ) ( gm )\narr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]\nn = len ( arr )\nprint ( '{0:.6f}'.format ( geometricMean ( arr , n ) ) )\n", "python_code_tokenized": "import math NEW_LINE def geometricMean ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE DEDENT gm = ( float ) ( math . pow ( product , ( 1 / n ) ) ) NEW_LINE return ( float ) ( gm ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ' { 0 : . 6f } ' . format ( geometricMean ( arr , n ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_512_A", "sol": 0, "python_code": "import math\ndef summingSeries ( n ) :\n    return math.pow ( n , 2 )\nn = 100\nprint ( \"The sum of n term is: \" , summingSeries ( n ) )\n", "python_code_tokenized": "import math NEW_LINE def summingSeries ( n ) : NEW_LINE INDENT return math . pow ( n , 2 ) NEW_LINE DEDENT n = 100 NEW_LINE print ( \" The \u2581 sum \u2581 of \u2581 n \u2581 term \u2581 is : \u2581 \" , summingSeries ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_511_A", "sol": 0, "python_code": "def summingSeries ( n ) :\n    S = 0\n    for i in range ( 1 , n + 1 ) :\n        S += i * i - ( i - 1 ) * ( i - 1 )\n    return S\nn = 100\nprint ( \"The sum of n term is: \" , summingSeries ( n ) , sep = \"\" )\n", "python_code_tokenized": "def summingSeries ( n ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT S += i * i - ( i - 1 ) * ( i - 1 ) NEW_LINE DEDENT return S NEW_LINE DEDENT n = 100 NEW_LINE print ( \" The \u2581 sum \u2581 of \u2581 n \u2581 term \u2581 is : \u2581 \" , summingSeries ( n ) , sep = \" \" ) NEW_LINE"}
{"id": "atcoder_ARC069_A", "sol": 0, "python_code": "def main ( ) :\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit ( 10 ** 6 )\n    n , m = map ( int , input ( ).split ( ) )\n    if m > n * 2 :\n        print ( n + ( m - n * 2 ) // 4 )\n    else :\n        print ( m // 2 )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m > n * 2 : NEW_LINE INDENT print ( n + ( m - n * 2 ) // 4 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( m // 2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_109_A", "sol": 0, "python_code": "s = int ( input ( ) )\nn , m = 0 , 0\nfor i in range ( 0 , s // 4 + 1 ) :\n    if ( s - 4 * i ) % 7 == 0 :\n        n = i\n        m = ( s - 4 * i ) // 7\n        break\nif n == 0 and m == 0 :\n    print ( - 1 )\nelse :\n    print ( '4' * n + '7' * m )\n", "python_code_tokenized": "s = int ( input ( ) ) NEW_LINE n , m = 0 , 0 NEW_LINE for i in range ( 0 , s // 4 + 1 ) : NEW_LINE INDENT if ( s - 4 * i ) % 7 == 0 : NEW_LINE INDENT n = i NEW_LINE m = ( s - 4 * i ) // 7 NEW_LINE break NEW_LINE DEDENT DEDENT if n == 0 and m == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '4' * n + '7' * m ) NEW_LINE DEDENT"}
{"id": "aizu_p00780_A", "sol": 0, "python_code": "def f ( x ) :\n    if x == 2 :\n        return 1\n    if x < 2 or x % 2 == 0 :\n        return 0\n    i = 3\n    while i <= x ** ( 1 / 2 ) :\n        if x % i == 0 :\n            return 0\n        i += 2\n    return 1\nwhile True :\n    n = int ( input ( ) )\n    if n == 0 :\n        break\n    else :\n        a = 0\n        for i in range ( 2 , n // 2 + 1 ) :\n            m = n - i\n            if f ( m ) == 1 and f ( i ) == 1 :\n                a += 1\n        print ( a )\n", "python_code_tokenized": "def f ( x ) : NEW_LINE INDENT if x == 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if x < 2 or x % 2 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = 3 NEW_LINE while i <= x ** ( 1 / 2 ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT a = 0 NEW_LINE for i in range ( 2 , n // 2 + 1 ) : NEW_LINE INDENT m = n - i NEW_LINE if f ( m ) == 1 and f ( i ) == 1 : NEW_LINE INDENT a += 1 NEW_LINE DEDENT DEDENT print ( a ) NEW_LINE DEDENT DEDENT"}
{"id": "codejam_08_01", "sol": 0, "python_code": "from sys import stdin as input_file\nfrom sys import stdout as output_file\ndef readline ( file ) :\n    return file.readline ( ).rstrip ( '\\n' )\nnum_cases = int ( readline ( input_file ) )\nfor case_num in xrange ( num_cases ) :\n    num_engines = int ( readline ( input_file ) )\n    engines = [ ]\n    for i in xrange ( num_engines ) :\n        engine = readline ( input_file )\n        engines.append ( engine )\n    num_queries = int ( readline ( input_file ) )\n    queries = [ ]\n    for i in xrange ( num_queries ) :\n        query = readline ( input_file )\n        queries.append ( query )\n    num_switches = 0\n    occurrence = set ( )\n    for query in queries :\n        occurrence.add ( query )\n        if len ( occurrence ) == num_engines :\n            occurrence = set ( )\n            occurrence.add ( query )\n            num_switches += 1\n    output_file.write ( 'Case #%d: %d\\n' % ( case_num + 1 , num_switches ) )\n", "python_code_tokenized": "from sys import stdin as input_file NEW_LINE from sys import stdout as output_file NEW_LINE def readline ( file ) : NEW_LINE INDENT return file . readline ( ) . rstrip ( ' \\n ' ) NEW_LINE DEDENT num_cases = int ( readline ( input_file ) ) NEW_LINE for case_num in xrange ( num_cases ) : NEW_LINE INDENT num_engines = int ( readline ( input_file ) ) NEW_LINE engines = [ ] NEW_LINE for i in xrange ( num_engines ) : NEW_LINE INDENT engine = readline ( input_file ) NEW_LINE engines . append ( engine ) NEW_LINE DEDENT num_queries = int ( readline ( input_file ) ) NEW_LINE queries = [ ] NEW_LINE for i in xrange ( num_queries ) : NEW_LINE INDENT query = readline ( input_file ) NEW_LINE queries . append ( query ) NEW_LINE DEDENT num_switches = 0 NEW_LINE occurrence = set ( ) NEW_LINE for query in queries : NEW_LINE INDENT occurrence . add ( query ) NEW_LINE if len ( occurrence ) == num_engines : NEW_LINE INDENT occurrence = set ( ) NEW_LINE occurrence . add ( query ) NEW_LINE num_switches += 1 NEW_LINE DEDENT DEDENT output_file . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( case_num + 1 , num_switches ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1547_A", "sol": 0, "python_code": "def search ( arr , n , x ) :\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] == x ) :\n            return i ;\n    return - 1 ;\narr = [ 2 , 3 , 4 , 10 , 40 ] ;\nx = 10 ;\nn = len ( arr ) ;\nresult = search ( arr , n , x )\nif ( result == - 1 ) :\n    print ( \"Element is not present in array\" )\nelse :\n    print ( \"Element is present at index\" , result ) ;\n", "python_code_tokenized": "def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] ; NEW_LINE x = 10 ; NEW_LINE n = len ( arr ) ; NEW_LINE result = search ( arr , n , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( \" Element \u2581 is \u2581 not \u2581 present \u2581 in \u2581 array \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Element \u2581 is \u2581 present \u2581 at \u2581 index \" , result ) ; NEW_LINE DEDENT"}
{"id": "codeforces_858_B", "sol": 0, "python_code": "import math\ndef main ( ) :\n    n , m = map ( int , input ( ).split ( ) )\n    data = [ ]\n    for _ in range ( m ) :\n        k , f = map ( int , input ( ).split ( ) )\n        data.append ( ( k , f ) )\n    candidates = [ ]\n    for i in range ( 1 , 101 ) :\n        for elem in data :\n            k , f = elem\n            if ( k - 1 ) // i != f - 1 :\n                break\n        else :\n            candidates.append ( i )\n    answers = [ ]\n    for candidate in candidates :\n        answers.append ( math.ceil ( n / candidate ) )\n    flag = False\n    for i in range ( len ( answers ) - 1 ) :\n        if answers [ i ] != answers [ i + 1 ] :\n            flag = True\n    if flag :\n        print ( - 1 )\n    else :\n        print ( answers [ 0 ] )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "import math NEW_LINE def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE data = [ ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT k , f = map ( int , input ( ) . split ( ) ) NEW_LINE data . append ( ( k , f ) ) NEW_LINE DEDENT candidates = [ ] NEW_LINE for i in range ( 1 , 101 ) : NEW_LINE INDENT for elem in data : NEW_LINE INDENT k , f = elem NEW_LINE if ( k - 1 ) // i != f - 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT candidates . append ( i ) NEW_LINE DEDENT DEDENT answers = [ ] NEW_LINE for candidate in candidates : NEW_LINE INDENT answers . append ( math . ceil ( n / candidate ) ) NEW_LINE DEDENT flag = False NEW_LINE for i in range ( len ( answers ) - 1 ) : NEW_LINE INDENT if answers [ i ] != answers [ i + 1 ] : NEW_LINE INDENT flag = True NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( answers [ 0 ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_603_B", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nm = 10 ** 9 + 7\nif k == 0 :\n    print ( pow ( n , n - 1 , m ) )\nelif k == 1 :\n    print ( pow ( n , n , m ) )\nelse :\n    c = 1\n    x = k\n    while x != 1 :\n        x = ( x * k ) % n\n        c += 1\n    print ( pow ( n , ( n - 1 ) // c , m ) )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE m = 10 ** 9 + 7 NEW_LINE if k == 0 : NEW_LINE INDENT print ( pow ( n , n - 1 , m ) ) NEW_LINE DEDENT elif k == 1 : NEW_LINE INDENT print ( pow ( n , n , m ) ) NEW_LINE DEDENT else : NEW_LINE INDENT c = 1 NEW_LINE x = k NEW_LINE while x != 1 : NEW_LINE INDENT x = ( x * k ) % n NEW_LINE c += 1 NEW_LINE DEDENT print ( pow ( n , ( n - 1 ) // c , m ) ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC019_C", "sol": 0, "python_code": "from bisect import bisect_left as bl\nfrom math import pi\nfx = 1\nfy = 1\nx1 , y1 , x2 , y2 = map ( int , input ( ).split ( ) )\nif x1 > x2 : fx = - 1\nif y1 > y2 : fy = - 1\nN = int ( input ( ) )\ninf = 10 ** 9\nf = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( N ) ]\nf = [ [ p [ 0 ] * fx , p [ 1 ] * fy ] for p in f if ( min ( x1 , x2 ) <= p [ 0 ] <= max ( x1 , x2 ) and min ( y1 , y2 ) <= p [ 1 ] <= max ( y1 , y2 ) ) ]\nf.sort ( key = lambda x : ( x [ 0 ] , - x [ 1 ] ) )\nlis = [ inf ] * N\nlislen = 0\nfor i in range ( len ( f ) ) :\n    t = f [ i ] [ 1 ]\n    ind = bl ( lis , t )\n    lis [ ind ] = t\n    lislen = max ( lislen , ind + 1 )\nif lislen == min ( abs ( x2 - x1 ) , abs ( y2 - y1 ) ) + 1 :\n    print ( ( abs ( x2 - x1 ) + abs ( y2 - y1 ) ) * 100 - 20 * lislen + 10 * pi + 5 * pi * max ( lislen - 1 , 0 ) )\nelse :\n    print ( ( abs ( x2 - x1 ) + abs ( y2 - y1 ) ) * 100 - 20 * lislen + 5 * pi * lislen )\n", "python_code_tokenized": "from bisect import bisect_left as bl NEW_LINE from math import pi NEW_LINE fx = 1 NEW_LINE fy = 1 NEW_LINE x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE if x1 > x2 : fx = - 1 NEW_LINE if y1 > y2 : fy = - 1 NEW_LINE N = int ( input ( ) ) NEW_LINE inf = 10 ** 9 NEW_LINE f = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE f = [ [ p [ 0 ] * fx , p [ 1 ] * fy ] for p in f if ( min ( x1 , x2 ) <= p [ 0 ] <= max ( x1 , x2 ) and min ( y1 , y2 ) <= p [ 1 ] <= max ( y1 , y2 ) ) ] NEW_LINE f . sort ( key = lambda x : ( x [ 0 ] , - x [ 1 ] ) ) NEW_LINE lis = [ inf ] * N NEW_LINE lislen = 0 NEW_LINE for i in range ( len ( f ) ) : NEW_LINE INDENT t = f [ i ] [ 1 ] NEW_LINE ind = bl ( lis , t ) NEW_LINE lis [ ind ] = t NEW_LINE lislen = max ( lislen , ind + 1 ) NEW_LINE DEDENT if lislen == min ( abs ( x2 - x1 ) , abs ( y2 - y1 ) ) + 1 : NEW_LINE INDENT print ( ( abs ( x2 - x1 ) + abs ( y2 - y1 ) ) * 100 - 20 * lislen + 10 * pi + 5 * pi * max ( lislen - 1 , 0 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( abs ( x2 - x1 ) + abs ( y2 - y1 ) ) * 100 - 20 * lislen + 5 * pi * lislen ) NEW_LINE DEDENT"}
{"id": "codeforces_914_A", "sol": 0, "python_code": "n = int ( input ( ) )\nnum = list ( map ( int , input ( ).split ( ) ) )\nnum.sort ( reverse = True )\nfor i in range ( n ) :\n    x = num [ i ]\n    if ( x < 0 or x ** 0.5 % 1 != 0 ) :\n        print ( x )\n        break\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE num = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE num . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = num [ i ] NEW_LINE if ( x < 0 or x ** 0.5 % 1 != 0 ) : NEW_LINE INDENT print ( x ) NEW_LINE break NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4617_A", "sol": 0, "python_code": "from math import gcd\ndef FindRatio ( a , b , c ) :\n    up = abs ( b - c )\n    down = abs ( c - a )\n    g = gcd ( up , down )\n    up //= g\n    down //= g\n    print ( up , \":\" , down )\na = 4\nb = 10\nc = 6\nFindRatio ( a , b , c )\n", "python_code_tokenized": "from math import gcd NEW_LINE def FindRatio ( a , b , c ) : NEW_LINE INDENT up = abs ( b - c ) NEW_LINE down = abs ( c - a ) NEW_LINE g = gcd ( up , down ) NEW_LINE up //= g NEW_LINE down //= g NEW_LINE print ( up , \" : \" , down ) NEW_LINE DEDENT a = 4 NEW_LINE b = 10 NEW_LINE c = 6 NEW_LINE FindRatio ( a , b , c ) NEW_LINE"}
{"id": "geeksforgeeks_4960_A", "sol": 0, "python_code": "def distantAdjacentElement ( a , n ) :\n    m = dict ( )\n    for i in range ( n ) :\n        if a [ i ] in m :\n            m [ a [ i ] ] += 1\n        else :\n            m [ a [ i ] ] = 1\n    mx = 0\n    for i in range ( n ) :\n        if mx < m [ a [ i ] ] :\n            mx = m [ a [ i ] ]\n    if mx > ( n + 1 ) // 2 :\n        print ( \"NO\" )\n    else :\n        print ( \"YES\" )\nif __name__ == \"__main__\" :\n    a = [ 7 , 7 , 7 , 7 ]\n    n = len ( a )\n    distantAdjacentElement ( a , n )\n", "python_code_tokenized": "def distantAdjacentElement ( a , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in m : NEW_LINE INDENT m [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mx < m [ a [ i ] ] : NEW_LINE INDENT mx = m [ a [ i ] ] NEW_LINE DEDENT DEDENT if mx > ( n + 1 ) // 2 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 7 , 7 , 7 ] NEW_LINE n = len ( a ) NEW_LINE distantAdjacentElement ( a , n ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC157_A", "sol": 0, "python_code": "N = int ( input ( ) )\nprint ( ( N + 2 - 1 ) // 2 )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE print ( ( N + 2 - 1 ) // 2 ) NEW_LINE"}
{"id": "geeksforgeeks_237_A", "sol": 0, "python_code": "def findElement ( arr , size ) :\n    right_mul = 1 ;\n    left_mul = 1 ;\n    for i in range ( 1 , size ) :\n        right_mul = right_mul * arr [ i ] ;\n    for i , j in zip ( range ( 0 , size ) , range ( 1 , size , 1 ) ) :\n        right_mul = right_mul / arr [ j ] ;\n        left_mul = left_mul * arr [ i ] ;\n        if ( left_mul == right_mul ) :\n            return arr [ i + 1 ] ;\n    return - 1 ;\narr = [ 2 , 3 , 4 , 1 , 4 , 6 , ] ;\nsize = len ( arr ) ;\nprint ( findElement ( arr , size ) ) ;\n", "python_code_tokenized": "def findElement ( arr , size ) : NEW_LINE INDENT right_mul = 1 ; NEW_LINE left_mul = 1 ; NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT right_mul = right_mul * arr [ i ] ; NEW_LINE DEDENT for i , j in zip ( range ( 0 , size ) , range ( 1 , size , 1 ) ) : NEW_LINE INDENT right_mul = right_mul / arr [ j ] ; NEW_LINE left_mul = left_mul * arr [ i ] ; NEW_LINE if ( left_mul == right_mul ) : NEW_LINE INDENT return arr [ i + 1 ] ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 1 , 4 , 6 , ] ; NEW_LINE size = len ( arr ) ; NEW_LINE print ( findElement ( arr , size ) ) ; NEW_LINE"}
{"id": "aizu_p00140_A", "sol": 0, "python_code": "def printAns ( ans ) :\n    for i in range ( len ( ans ) ) :\n        if i == 0 :\n            print ( ans [ i ] , end = \"\" )\n        else :\n            print ( \"\" , end = \"\" )\n            print ( ans [ i ] , end = \"\" )\n    print ( \"\" )\nN = int ( input ( ) )\nfor l in range ( N ) :\n    a , b = [ int ( i ) for i in input ( ).split ( ) ]\n    ans = [ ]\n    if a < b :\n        for i in range ( a , b + 1 ) :\n            ans.append ( i )\n    else :\n        if a <= 5 :\n            for i in range ( a , b - 1 , - 1 ) :\n                ans.append ( i )\n        else :\n            if b <= 5 :\n                for i in range ( a , 10 ) :\n                    ans.append ( i )\n                for i in range ( 5 , b - 1 , - 1 ) :\n                    ans.append ( i )\n            else :\n                for i in range ( a , 10 ) :\n                    ans.append ( i )\n                for i in range ( 5 , 0 , - 1 ) :\n                    ans.append ( i )\n                for i in range ( b + 1 ) :\n                    ans.append ( i )\n    printAns ( ans )\n", "python_code_tokenized": "def printAns ( ans ) : NEW_LINE INDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT print ( ans [ i ] , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \u2581 \" , end = \" \" ) NEW_LINE print ( ans [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT print ( \" \" ) NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE for l in range ( N ) : NEW_LINE INDENT a , b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = [ ] NEW_LINE if a < b : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a <= 5 : NEW_LINE INDENT for i in range ( a , b - 1 , - 1 ) : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if b <= 5 : NEW_LINE INDENT for i in range ( a , 10 ) : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT for i in range ( 5 , b - 1 , - 1 ) : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( a , 10 ) : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT for i in range ( 5 , 0 , - 1 ) : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT for i in range ( b + 1 ) : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT printAns ( ans ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_400_A", "sol": 0, "python_code": "from collections import defaultdict\ndef countPairs ( a , n ) :\n    frequency = defaultdict ( int )\n    for i in range ( n ) :\n        frequency [ a [ i ] ] += 1\n    count = 0\n    for x in frequency.keys ( ) :\n        f = frequency [ x ]\n        count += f * ( f - 1 ) // 2\n    return count\nif __name__ == \"__main__\" :\n    arr = [ 1 , 1 , 1 ]\n    n = len ( arr )\n    print ( countPairs ( arr , n ) )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE def countPairs ( a , n ) : NEW_LINE INDENT frequency = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT frequency [ a [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for x in frequency . keys ( ) : NEW_LINE INDENT f = frequency [ x ] NEW_LINE count += f * ( f - 1 ) // 2 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_835_A", "sol": 0, "python_code": "def anglechordtang ( z ) :\n    print ( \"The angle between tangent\" , \"and the chord is\" , z , \"degrees\" ) ;\nz = 48 ;\nanglechordtang ( z ) ;\n", "python_code_tokenized": "def anglechordtang ( z ) : NEW_LINE INDENT print ( \" The \u2581 angle \u2581 between \u2581 tangent \" , \" and \u2581 the \u2581 chord \u2581 is \" , z , \" degrees \" ) ; NEW_LINE DEDENT z = 48 ; NEW_LINE anglechordtang ( z ) ; NEW_LINE"}
{"id": "geeksforgeeks_2895_A", "sol": 0, "python_code": "def findNumUtil ( res , a , aCount , b , bCount , n ) :\n    if ( res > 1e11 ) :\n        return 1e11\n    if ( aCount == bCount and res >= n ) :\n        return res\n    return min ( findNumUtil ( res * 10 + a , a , aCount + 1 , b , bCount , n ) , findNumUtil ( res * 10 + b , a , aCount , b , bCount + 1 , n ) )\ndef findNum ( n , a , b ) :\n    result = 0\n    aCount = 0\n    bCount = 0\n    return findNumUtil ( result , a , aCount , b , bCount , n )\nif __name__ == '__main__' :\n    N = 4500\n    A = 4\n    B = 7\n    print ( findNum ( N , A , B ) )\n", "python_code_tokenized": "def findNumUtil ( res , a , aCount , b , bCount , n ) : NEW_LINE INDENT if ( res > 1e11 ) : NEW_LINE INDENT return 1e11 NEW_LINE DEDENT if ( aCount == bCount and res >= n ) : NEW_LINE INDENT return res NEW_LINE DEDENT return min ( findNumUtil ( res * 10 + a , a , aCount + 1 , b , bCount , n ) , findNumUtil ( res * 10 + b , a , aCount , b , bCount + 1 , n ) ) NEW_LINE DEDENT def findNum ( n , a , b ) : NEW_LINE INDENT result = 0 NEW_LINE aCount = 0 NEW_LINE bCount = 0 NEW_LINE return findNumUtil ( result , a , aCount , b , bCount , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4500 NEW_LINE A = 4 NEW_LINE B = 7 NEW_LINE print ( findNum ( N , A , B ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2263_A", "sol": 0, "python_code": "def countNums ( n , x , y ) :\n    arr = [ False for i in range ( n + 2 ) ]\n    if ( x <= n ) :\n        arr [ x ] = True\n    if ( y <= n ) :\n        arr [ y ] = True\n    result = 0\n    for i in range ( min ( x , y ) , n + 1 ) :\n        if ( arr [ i ] ) :\n            if ( i + x <= n ) :\n                arr [ i + x ] = True\n            if ( i + y <= n ) :\n                arr [ i + y ] = True\n            result = result + 1\n    return result\nn = 15\nx = 5\ny = 7\nprint ( countNums ( n , x , y ) )\n", "python_code_tokenized": "def countNums ( n , x , y ) : NEW_LINE INDENT arr = [ False for i in range ( n + 2 ) ] NEW_LINE if ( x <= n ) : NEW_LINE INDENT arr [ x ] = True NEW_LINE DEDENT if ( y <= n ) : NEW_LINE INDENT arr [ y ] = True NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( min ( x , y ) , n + 1 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT if ( i + x <= n ) : NEW_LINE INDENT arr [ i + x ] = True NEW_LINE DEDENT if ( i + y <= n ) : NEW_LINE INDENT arr [ i + y ] = True NEW_LINE DEDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT n = 15 NEW_LINE x = 5 NEW_LINE y = 7 NEW_LINE print ( countNums ( n , x , y ) ) NEW_LINE"}
{"id": "codeforces_1708_A", "sol": 0, "python_code": "for sol in [ * open ( 0 ) ] [ 2 : : 2 ] : y , * x = map ( int , sol.split ( ) ) ; print ( 'YNEOS' [ any ( p % y for p in x ) : : 2 ] )\n", "python_code_tokenized": "for sol in [ * open ( 0 ) ] [ 2 : : 2 ] : y , * x = map ( int , sol . split ( ) ) ; print ( ' YNEOS ' [ any ( p % y for p in x ) : : 2 ] ) NEW_LINE"}
{"id": "geeksforgeeks_1305_A", "sol": 0, "python_code": "def calculateAlternateSum ( n ) :\n    if ( n <= 0 ) :\n        return 0\n    fibo = [ 0 ] * ( n + 1 )\n    fibo [ 0 ] = 0\n    fibo [ 1 ] = 1\n    sum = pow ( fibo [ 0 ] , 2 ) + pow ( fibo [ 1 ] , 2 )\n    for i in range ( 2 , n + 1 ) :\n        fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ]\n        if ( i % 2 == 0 ) :\n            sum -= fibo [ i ]\n        else :\n            sum += fibo [ i ]\n    return sum\nif __name__ == \"__main__\" :\n    n = 8\n    print ( \"Alternating Fibonacci Sum upto \" , n , \" terms: \" , calculateAlternateSum ( n ) )\n", "python_code_tokenized": "def calculateAlternateSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 0 ] = 0 NEW_LINE fibo [ 1 ] = 1 NEW_LINE sum = pow ( fibo [ 0 ] , 2 ) + pow ( fibo [ 1 ] , 2 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT sum -= fibo [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += fibo [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 NEW_LINE print ( \" Alternating \u2581 Fibonacci \u2581 Sum \u2581 upto \u2581 \" , n , \" \u2581 terms : \u2581 \" , calculateAlternateSum ( n ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC159_F", "sol": 0, "python_code": "n , s = map ( int , input ( ).split ( ) )\nnow = [ 0 ] * ( s + 1 )\nmod1 , mod2 = 10 ** 9 + 7 , 998244353\nmod = mod2\nans = 0\nfor a in map ( int , input ( ).split ( ) ) :\n    now [ 0 ] += 1\n    for i in range ( s , - 1 , - 1 ) :\n        now [ i ] = ( now [ i ] + ( 0 if i < a else now [ i - a ] ) ) % mod\n    ans = ( ans + now [ - 1 ] ) % mod\nprint ( ans )\n", "python_code_tokenized": "n , s = map ( int , input ( ) . split ( ) ) NEW_LINE now = [ 0 ] * ( s + 1 ) NEW_LINE mod1 , mod2 = 10 ** 9 + 7 , 998244353 NEW_LINE mod = mod2 NEW_LINE ans = 0 NEW_LINE for a in map ( int , input ( ) . split ( ) ) : NEW_LINE INDENT now [ 0 ] += 1 NEW_LINE for i in range ( s , - 1 , - 1 ) : NEW_LINE INDENT now [ i ] = ( now [ i ] + ( 0 if i < a else now [ i - a ] ) ) % mod NEW_LINE DEDENT ans = ( ans + now [ - 1 ] ) % mod NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "aizu_p02182_A", "sol": 0, "python_code": "N , M = map ( int , input ( ).split ( ) )\ntable1 = ''\ntable2 = ''\nfor i in range ( 2 * N ) :\n    if i < N :\n        table1 += input ( )\n    else :\n        table2 += input ( )\ncount = 0\nfor i , j in zip ( table1 , table2 ) :\n    if i != j :\n        count += 1\nprint ( count )\n", "python_code_tokenized": "N , M = map ( int , input ( ) . split ( ) ) NEW_LINE table1 = ' ' NEW_LINE table2 = ' ' NEW_LINE for i in range ( 2 * N ) : NEW_LINE INDENT if i < N : NEW_LINE INDENT table1 += input ( ) NEW_LINE DEDENT else : NEW_LINE INDENT table2 += input ( ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i , j in zip ( table1 , table2 ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"}
{"id": "codeforces_1650_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    st = input ( )\n    ch = input ( )\n    k = True\n    s = 0\n    for x in st :\n        if ( ( x == ch ) and ( s % 2 == 0 ) ) :\n            print ( \"YES\" )\n            k = False\n            break\n        s = s + 1\n    if k :\n        print ( \"NO\" )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT st = input ( ) NEW_LINE ch = input ( ) NEW_LINE k = True NEW_LINE s = 0 NEW_LINE for x in st : NEW_LINE INDENT if ( ( x == ch ) and ( s % 2 == 0 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE k = False NEW_LINE break NEW_LINE DEDENT s = s + 1 NEW_LINE DEDENT if k : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4387_A", "sol": 0, "python_code": "from math import sqrt\ndef triangle ( n ) :\n    k = 2 * n - 2 ;\n    ch = 1 ;\n    for i in range ( n ) :\n        for j in range ( k ) :\n            print ( \"\" , end = \"\" ) ;\n        k = k - 1 ;\n        for j in range ( i + 1 ) :\n            print ( ch , end = \"\" ) ;\n            ch += 1 ;\n        print ( )\ndef maxHeight ( n ) :\n    ans = ( sqrt ( 1 + 8.0 * n ) - 1 ) // 2 ;\n    return int ( ans ) ;\nif __name__ == \"__main__\" :\n    N = 9 ;\n    triangle ( maxHeight ( N ) ) ;\n", "python_code_tokenized": "from math import sqrt NEW_LINE def triangle ( n ) : NEW_LINE INDENT k = 2 * n - 2 ; NEW_LINE ch = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT print ( \" \u2581 \" , end = \" \" ) ; NEW_LINE DEDENT k = k - 1 ; NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT print ( ch , end = \" \u2581 \" ) ; NEW_LINE ch += 1 ; NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def maxHeight ( n ) : NEW_LINE INDENT ans = ( sqrt ( 1 + 8.0 * n ) - 1 ) // 2 ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 ; NEW_LINE triangle ( maxHeight ( N ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4473_A", "sol": 0, "python_code": "from math import *\ndef nextFibonacci ( n ) :\n    a = n * ( 1 + sqrt ( 5 ) ) / 2.0\n    return round ( a )\nn = 5\nprint ( nextFibonacci ( n ) )\n", "python_code_tokenized": "from math import * NEW_LINE def nextFibonacci ( n ) : NEW_LINE INDENT a = n * ( 1 + sqrt ( 5 ) ) / 2.0 NEW_LINE return round ( a ) NEW_LINE DEDENT n = 5 NEW_LINE print ( nextFibonacci ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1659_A", "sol": 0, "python_code": "def getMinimumOps ( ar ) :\n    n = len ( ar )\n    small = min ( ar )\n    large = max ( ar )\n    dp = [ [ 0 for i in range ( large + 1 ) ] for i in range ( n ) ]\n    for j in range ( small , large + 1 ) :\n        dp [ 0 ] [ j ] = abs ( ar [ 0 ] - j )\n    for i in range ( 1 , n ) :\n        minimum = 10 ** 9\n        for j in range ( small , large + 1 ) :\n            minimum = min ( minimum , dp [ i - 1 ] [ j ] )\n            dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j )\n    ans = 10 ** 9\n    for j in range ( small , large + 1 ) :\n        ans = min ( ans , dp [ n - 1 ] [ j ] )\n    return ans\nar = [ 1 , 2 , 1 , 4 , 3 ]\nprint ( getMinimumOps ( ar ) )\n", "python_code_tokenized": "def getMinimumOps ( ar ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE small = min ( ar ) NEW_LINE large = max ( ar ) NEW_LINE dp = [ [ 0 for i in range ( large + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( ar [ 0 ] - j ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT minimum = 10 ** 9 NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j ) NEW_LINE DEDENT DEDENT ans = 10 ** 9 NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT ar = [ 1 , 2 , 1 , 4 , 3 ] NEW_LINE print ( getMinimumOps ( ar ) ) NEW_LINE"}
{"id": "geeksforgeeks_3834_A", "sol": 0, "python_code": "import sys\ndef __gcd ( a , b ) :\n    if ( a == 0 ) :\n        return b ;\n    if ( b == 0 ) :\n        return a ;\n    if ( a == b ) :\n        return a ;\n    if ( a > b ) :\n        return __gcd ( a - b , b ) ;\n    return __gcd ( a , b - a ) ;\ndef lcm ( a , b ) :\n    return ( a / __gcd ( a , b ) * b ) ;\ndef getMinValue ( c ) :\n    ans = sys.maxsize ;\n    for i in range ( 1 , int ( pow ( c , 1 / 2 ) ) + 1 ) :\n        if ( c % i == 0 and lcm ( i , c / i ) == c ) :\n            ans = min ( ans , max ( i , c / i ) ) ;\n    return int ( ans ) ;\nif __name__ == '__main__' :\n    c = 6 ;\n    print ( getMinValue ( c ) ) ;\n", "python_code_tokenized": "import sys NEW_LINE def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) ; NEW_LINE DEDENT return __gcd ( a , b - a ) ; NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a / __gcd ( a , b ) * b ) ; NEW_LINE DEDENT def getMinValue ( c ) : NEW_LINE INDENT ans = sys . maxsize ; NEW_LINE for i in range ( 1 , int ( pow ( c , 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( c % i == 0 and lcm ( i , c / i ) == c ) : NEW_LINE INDENT ans = min ( ans , max ( i , c / i ) ) ; NEW_LINE DEDENT DEDENT return int ( ans ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT c = 6 ; NEW_LINE print ( getMinValue ( c ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5241_A", "sol": 0, "python_code": "import sys\ndef makeEven ( arr , n ) :\n    first_e_i = - 1\n    last_e_i = - 1\n    last_n_i = n - 1\n    for i in range ( n ) :\n        if ( int ( arr [ i ] ) % 2 == 0 and int ( arr [ i ] ) < int ( arr [ last_n_i ] ) ) :\n            first_e_i = i\n            break\n        if int ( arr [ i ] ) % 2 == 0 :\n            last_e_i = i\n    if first_e_i != - 1 :\n        ( arr [ first_e_i ] , arr [ last_n_i ] ) = ( arr [ last_n_i ] , arr [ first_e_i ] )\n        return arr\n    if first_e_i == - 1 and last_e_i != - 1 :\n        ( arr [ last_e_i ] , arr [ last_n_i ] ) = ( arr [ last_n_i ] , arr [ last_e_i ] )\n        return arr\n    return arr\nif __name__ == '__main__' :\n    string = \"1356425\"\n    result = \"\".join ( makeEven ( list ( string ) , len ( list ( string ) ) ) )\n    print ( result )\n", "python_code_tokenized": "import sys NEW_LINE def makeEven ( arr , n ) : NEW_LINE INDENT first_e_i = - 1 NEW_LINE last_e_i = - 1 NEW_LINE last_n_i = n - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( int ( arr [ i ] ) % 2 == 0 and int ( arr [ i ] ) < int ( arr [ last_n_i ] ) ) : NEW_LINE INDENT first_e_i = i NEW_LINE break NEW_LINE DEDENT if int ( arr [ i ] ) % 2 == 0 : NEW_LINE INDENT last_e_i = i NEW_LINE DEDENT DEDENT if first_e_i != - 1 : NEW_LINE INDENT ( arr [ first_e_i ] , arr [ last_n_i ] ) = ( arr [ last_n_i ] , arr [ first_e_i ] ) NEW_LINE return arr NEW_LINE DEDENT if first_e_i == - 1 and last_e_i != - 1 : NEW_LINE INDENT ( arr [ last_e_i ] , arr [ last_n_i ] ) = ( arr [ last_n_i ] , arr [ last_e_i ] ) NEW_LINE return arr NEW_LINE DEDENT return arr NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \"1356425\" NEW_LINE result = \" \" . join ( makeEven ( list ( string ) , len ( list ( string ) ) ) ) NEW_LINE print ( result ) NEW_LINE DEDENT"}
{"id": "codeforces_1223_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    if n == 2 :\n        print ( 2 )\n    else :\n        print ( 1 ) if n % 2 else print ( 0 )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 2 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) if n % 2 else print ( 0 ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00557_A", "sol": 0, "python_code": "def check ( y , x ) :\n    if 0 <= y <= h - 1 and 0 <= x <= w - 1 :\n        return True\n    return False\nh , w = map ( int , raw_input ( ).split ( ) )\ng = [ map ( int , raw_input ( ).split ( ) ) for _ in xrange ( h ) ]\npos = [ - 1 ] * ( h * w )\nfor i in xrange ( h ) :\n    for j in xrange ( w ) :\n        pos [ g [ i ] [ j ] - 1 ] = [ i , j ]\ndy = ( 1 , 0 , - 1 , 0 )\ndx = ( 0 , 1 , 0 , - 1 )\nstop = [ set ( ) for _ in xrange ( h * w ) ]\nans = 0\nfor i in xrange ( h * w ) :\n    y , x = pos [ i ]\n    for j in xrange ( 4 ) :\n        ny = y + dy [ j ] ; nx = x + dx [ j ]\n        if check ( ny , nx ) :\n            if g [ ny ] [ nx ] < g [ y ] [ x ] :\n                for k in list ( stop [ g [ ny ] [ nx ] - 1 ] ) :\n                    stop [ i ].add ( k )\n    cnt = len ( stop [ i ] )\n    if cnt >= 2 :\n        ans += 1\n    elif cnt == 0 :\n        stop [ i ].add ( g [ y ] [ x ] )\nprint ( ans )\n", "python_code_tokenized": "def check ( y , x ) : NEW_LINE INDENT if 0 <= y <= h - 1 and 0 <= x <= w - 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT h , w = map ( int , raw_input ( ) . split ( ) ) NEW_LINE g = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( h ) ] NEW_LINE pos = [ - 1 ] * ( h * w ) NEW_LINE for i in xrange ( h ) : NEW_LINE INDENT for j in xrange ( w ) : NEW_LINE INDENT pos [ g [ i ] [ j ] - 1 ] = [ i , j ] NEW_LINE DEDENT DEDENT dy = ( 1 , 0 , - 1 , 0 ) NEW_LINE dx = ( 0 , 1 , 0 , - 1 ) NEW_LINE stop = [ set ( ) for _ in xrange ( h * w ) ] NEW_LINE ans = 0 NEW_LINE for i in xrange ( h * w ) : NEW_LINE INDENT y , x = pos [ i ] NEW_LINE for j in xrange ( 4 ) : NEW_LINE INDENT ny = y + dy [ j ] ; nx = x + dx [ j ] NEW_LINE if check ( ny , nx ) : NEW_LINE INDENT if g [ ny ] [ nx ] < g [ y ] [ x ] : NEW_LINE INDENT for k in list ( stop [ g [ ny ] [ nx ] - 1 ] ) : NEW_LINE INDENT stop [ i ] . add ( k ) NEW_LINE DEDENT DEDENT DEDENT DEDENT cnt = len ( stop [ i ] ) NEW_LINE if cnt >= 2 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif cnt == 0 : NEW_LINE INDENT stop [ i ] . add ( g [ y ] [ x ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_788_A", "sol": 0, "python_code": "import math\ndef findCount ( d ) :\n    return 9 * ( ( int ) ( math.pow ( 10 , d - 1 ) ) - ( int ) ( math.pow ( 9 , d - 1 ) ) ) ;\nd = 1\nprint ( findCount ( d ) )\nd = 2\nprint ( findCount ( d ) )\nd = 4\nprint ( findCount ( d ) )\n", "python_code_tokenized": "import math NEW_LINE def findCount ( d ) : NEW_LINE INDENT return 9 * ( ( int ) ( math . pow ( 10 , d - 1 ) ) - ( int ) ( math . pow ( 9 , d - 1 ) ) ) ; NEW_LINE DEDENT d = 1 NEW_LINE print ( findCount ( d ) ) NEW_LINE d = 2 NEW_LINE print ( findCount ( d ) ) NEW_LINE d = 4 NEW_LINE print ( findCount ( d ) ) NEW_LINE"}
{"id": "aizu_p01574_A", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nfor _ in range ( m ) :\n    a = int ( input ( ) )\n    while a : n , a = a , n % a\nprint ( [ 'No' , 'Yes' ] [ n == 1 ] )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE while a : n , a = a , n % a NEW_LINE DEDENT print ( [ ' No ' , ' Yes ' ] [ n == 1 ] ) NEW_LINE"}
{"id": "aizu_p00710_A", "sol": 0, "python_code": "while 1 :\n    n , r = map ( int , input ( ).split ( ) )\n    if n == 0 : break\n    a = [ n - i for i in range ( n ) ]\n    for i in range ( r ) :\n        p , c = map ( int , input ( ).split ( ) )\n        a = a [ p - 1 : p - 1 + c ] + a [ : p - 1 ] + a [ p - 1 + c : ]\n    print ( a [ 0 ] )\n", "python_code_tokenized": "while 1 : NEW_LINE INDENT n , r = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = [ n - i for i in range ( n ) ] NEW_LINE for i in range ( r ) : NEW_LINE INDENT p , c = map ( int , input ( ) . split ( ) ) NEW_LINE a = a [ p - 1 : p - 1 + c ] + a [ : p - 1 ] + a [ p - 1 + c : ] NEW_LINE DEDENT print ( a [ 0 ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3597_A", "sol": 0, "python_code": "import sys\nimport math\ndef printChar ( str_ , n ) :\n    freq = [ 0 ] * 26\n    for i in range ( n ) :\n        freq [ ord ( str_ [ i ] ) - ord ( 'a' ) ] += 1\n    for i in range ( n ) :\n        if ( freq [ ord ( str_ [ i ] ) - ord ( 'a' ) ] ) % 2 == 1 :\n            print ( \"{}\".format ( str_ [ i ] ) , end = \"\" )\nif __name__ == '__main__' :\n    str_ = \"geeksforgeeks\"\n    n = len ( str_ )\n    printChar ( str_ , n )\n", "python_code_tokenized": "import sys NEW_LINE import math NEW_LINE def printChar ( str_ , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] ) % 2 == 1 : NEW_LINE INDENT print ( \" { } \" . format ( str_ [ i ] ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str_ = \" geeksforgeeks \" NEW_LINE n = len ( str_ ) NEW_LINE printChar ( str_ , n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4910_A", "sol": 0, "python_code": "SIZE = 26\ndef printChar ( string , n ) :\n    freq = [ 0 ] * SIZE\n    for i in range ( 0 , n ) :\n        freq [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1\n    for i in range ( 0 , n ) :\n        if ( freq [ ord ( string [ i ] ) - ord ( 'a' ) ] % 2 == 0 ) :\n            print ( string [ i ] , end = \"\" )\nif __name__ == '__main__' :\n    string = \"geeksforgeeks\"\n    n = len ( string )\n    printChar ( string , n )\n", "python_code_tokenized": "SIZE = 26 NEW_LINE def printChar ( string , n ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE n = len ( string ) NEW_LINE printChar ( string , n ) NEW_LINE DEDENT"}
{"id": "codeforces_133_B", "sol": 0, "python_code": "import os , sys , io , math\nfrom tokenize import Triple\nfrom array import array\nfrom math import *\nI = lambda : [ * map ( int , sys.stdin.readline ( ).split ( ) ) ]\nIS = lambda : input ( )\nIN = lambda : int ( input ( ) )\nIF = lambda : float ( input ( ) )\na = '1000'\nb = '1001'\nc = '1010'\nd = '1011'\ne = '1100'\nf = '1101'\ng = '1110'\nh = '1111'\ns = IS ( )\nres = ''\nfor i in s :\n    if i == '>' : res += a\n    elif i == '<' : res += b\n    elif i == '+' : res += c\n    elif i == '-' : res += d\n    elif i == '.' : res += e\n    elif i == ',' : res += f\n    elif i == '[' : res += g\n    else : res += h\nprint ( ( int ( res , 2 ) ) % ( 10 ** 6 + 3 ) )\n", "python_code_tokenized": "import os , sys , io , math NEW_LINE from tokenize import Triple NEW_LINE from array import array NEW_LINE from math import * NEW_LINE I = lambda : [ * map ( int , sys . stdin . readline ( ) . split ( ) ) ] NEW_LINE IS = lambda : input ( ) NEW_LINE IN = lambda : int ( input ( ) ) NEW_LINE IF = lambda : float ( input ( ) ) NEW_LINE a = '1000' NEW_LINE b = '1001' NEW_LINE c = '1010' NEW_LINE d = '1011' NEW_LINE e = '1100' NEW_LINE f = '1101' NEW_LINE g = '1110' NEW_LINE h = '1111' NEW_LINE s = IS ( ) NEW_LINE res = ' ' NEW_LINE for i in s : NEW_LINE INDENT if i == ' > ' : res += a NEW_LINE elif i == ' < ' : res += b NEW_LINE elif i == ' + ' : res += c NEW_LINE elif i == ' - ' : res += d NEW_LINE elif i == ' . ' : res += e NEW_LINE elif i == ' , ' : res += f NEW_LINE elif i == ' [ ' : res += g NEW_LINE else : res += h NEW_LINE DEDENT print ( ( int ( res , 2 ) ) % ( 10 ** 6 + 3 ) ) NEW_LINE"}
{"id": "aizu_p00155_A", "sol": 0, "python_code": "from heapq import heappush , heappop\nINF = 10 ** 20\nwhile True :\n    n = int ( input ( ) )\n    if n == 0 : break\n    buil_point = [ None ] * n\n    for _ in range ( n ) :\n        b , x , y = map ( int , input ( ).split ( ) )\n        buil_point [ b - 1 ] = ( x , y )\n    edges = [ [ ] for _ in range ( n ) ]\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            ix , iy = buil_point [ i ]\n            jx , jy = buil_point [ j ]\n            cost = ( ( jx - ix ) ** 2 + ( jy - iy ) ** 2 ) ** ( 1 / 2 )\n            if cost <= 50 :\n                edges [ i ].append ( ( cost , j ) )\n                edges [ j ].append ( ( cost , i ) )\n    m = int ( input ( ) )\n    for _ in range ( m ) :\n        s , g = map ( int , input ( ).split ( ) )\n        costs = [ INF ] * n\n        costs [ s - 1 ] = 0\n        paths = [ [ ] ] * n\n        paths [ s - 1 ] = [ s - 1 ]\n        que = [ ]\n        heappush ( que , ( 0 , [ s - 1 ] ) )\n        while que :\n            dist , path = heappop ( que )\n            last = path [ - 1 ]\n            for cost , to in edges [ last ] :\n                if costs [ to ] > dist + cost :\n                    costs [ to ] = dist + cost\n                    paths [ to ] = path + [ to ]\n                    heappush ( que , ( dist + cost , path + [ to ] ) )\n        if paths [ g - 1 ] :\n            print ( * list ( map ( lambda x : x + 1 , paths [ g - 1 ] ) ) )\n        else :\n            print ( \"NA\" )\n", "python_code_tokenized": "from heapq import heappush , heappop NEW_LINE INF = 10 ** 20 NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE buil_point = [ None ] * n NEW_LINE for _ in range ( n ) : NEW_LINE INDENT b , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE buil_point [ b - 1 ] = ( x , y ) NEW_LINE DEDENT edges = [ [ ] for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ix , iy = buil_point [ i ] NEW_LINE jx , jy = buil_point [ j ] NEW_LINE cost = ( ( jx - ix ) ** 2 + ( jy - iy ) ** 2 ) ** ( 1 / 2 ) NEW_LINE if cost <= 50 : NEW_LINE INDENT edges [ i ] . append ( ( cost , j ) ) NEW_LINE edges [ j ] . append ( ( cost , i ) ) NEW_LINE DEDENT DEDENT DEDENT m = int ( input ( ) ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT s , g = map ( int , input ( ) . split ( ) ) NEW_LINE costs = [ INF ] * n NEW_LINE costs [ s - 1 ] = 0 NEW_LINE paths = [ [ ] ] * n NEW_LINE paths [ s - 1 ] = [ s - 1 ] NEW_LINE que = [ ] NEW_LINE heappush ( que , ( 0 , [ s - 1 ] ) ) NEW_LINE while que : NEW_LINE INDENT dist , path = heappop ( que ) NEW_LINE last = path [ - 1 ] NEW_LINE for cost , to in edges [ last ] : NEW_LINE INDENT if costs [ to ] > dist + cost : NEW_LINE INDENT costs [ to ] = dist + cost NEW_LINE paths [ to ] = path + [ to ] NEW_LINE heappush ( que , ( dist + cost , path + [ to ] ) ) NEW_LINE DEDENT DEDENT DEDENT if paths [ g - 1 ] : NEW_LINE INDENT print ( * list ( map ( lambda x : x + 1 , paths [ g - 1 ] ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NA \" ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "leetcode_560_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def subarraySum ( self , nums , k ) :\n        sum_map = { }\n        sum_map [ 0 ] = 1\n        count = curr_sum = 0\n        for num in nums :\n            curr_sum += num\n            count += sum_map.get ( curr_sum - k , 0 )\n            sum_map [ curr_sum ] = sum_map.get ( curr_sum , 0 ) + 1\n        return count\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def subarraySum ( self , nums , k ) : NEW_LINE INDENT sum_map = { } NEW_LINE sum_map [ 0 ] = 1 NEW_LINE count = curr_sum = 0 NEW_LINE for num in nums : NEW_LINE INDENT curr_sum += num NEW_LINE count += sum_map . get ( curr_sum - k , 0 ) NEW_LINE sum_map [ curr_sum ] = sum_map . get ( curr_sum , 0 ) + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_AGC041_B", "sol": 0, "python_code": "n , m , v , p = map ( int , input ( ).split ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\na.sort ( )\ndef solve ( ind ) :\n    if a [ ind ] + m < a [ - p ] :\n        return False\n    thr = a [ ind ] + m\n    votes = [ ]\n    for i in range ( n ) :\n        if i <= ind or i > n - p :\n            votes.append ( m )\n        else :\n            votes.append ( thr - a [ i ] )\n    sm = sum ( votes )\n    return sm >= m * v\nok = n - 1\nng = - 1\nwhile abs ( ng - ok ) > 1 :\n    mid = ( ng + ok ) // 2\n    if solve ( mid ) :\n        ok = mid\n    else :\n        ng = mid\nprint ( n - ok )\n", "python_code_tokenized": "n , m , v , p = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE def solve ( ind ) : NEW_LINE INDENT if a [ ind ] + m < a [ - p ] : NEW_LINE INDENT return False NEW_LINE DEDENT thr = a [ ind ] + m NEW_LINE votes = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i <= ind or i > n - p : NEW_LINE INDENT votes . append ( m ) NEW_LINE DEDENT else : NEW_LINE INDENT votes . append ( thr - a [ i ] ) NEW_LINE DEDENT DEDENT sm = sum ( votes ) NEW_LINE return sm >= m * v NEW_LINE DEDENT ok = n - 1 NEW_LINE ng = - 1 NEW_LINE while abs ( ng - ok ) > 1 : NEW_LINE INDENT mid = ( ng + ok ) // 2 NEW_LINE if solve ( mid ) : NEW_LINE INDENT ok = mid NEW_LINE DEDENT else : NEW_LINE INDENT ng = mid NEW_LINE DEDENT DEDENT print ( n - ok ) NEW_LINE"}
{"id": "geeksforgeeks_4158_A", "sol": 0, "python_code": "MAX = 256 ;\ndef lastNonRepeating ( string , n ) :\n    freq = [ 0 ] * MAX ;\n    for i in range ( n ) :\n        freq [ ord ( string [ i ] ) ] += 1 ;\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        ch = string [ i ] ;\n        if ( freq [ ord ( ch ) ] == 1 ) :\n            return ( \"\" + ch ) ;\n    return \"-1\" ;\nif __name__ == \"__main__\" :\n    string = \"GeeksForGeeks\" ;\n    n = len ( string ) ;\n    print ( lastNonRepeating ( string , n ) ) ;\n", "python_code_tokenized": "MAX = 256 ; NEW_LINE def lastNonRepeating ( string , n ) : NEW_LINE INDENT freq = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) ] += 1 ; NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT ch = string [ i ] ; NEW_LINE if ( freq [ ord ( ch ) ] == 1 ) : NEW_LINE INDENT return ( \" \" + ch ) ; NEW_LINE DEDENT DEDENT return \" - 1\" ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GeeksForGeeks \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( lastNonRepeating ( string , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4841_A", "sol": 0, "python_code": "adjacency = [ [ ] for i in range ( 100 ) ]\ndef insert ( x , y ) :\n    adjacency [ x ].append ( y )\ndef dfs ( node , leaf , vis ) :\n    leaf [ node ] = 0\n    vis [ node ] = 1\n    for it in adjacency [ node ] :\n        if ( vis [ it ] == False ) :\n            dfs ( it , leaf , vis )\n            leaf [ node ] += leaf [ it ]\n    if ( len ( adjacency [ node ] ) == 0 ) :\n        leaf [ node ] = 1\ndef printLeaf ( n , leaf ) :\n    for i in range ( 1 , n + 1 ) :\n        print ( \"The node\" , i , \"has\" , leaf [ i ] , \"leaf nodes\" )\nN = 6\ninsert ( 1 , 2 )\ninsert ( 1 , 3 )\ninsert ( 3 , 4 )\ninsert ( 3 , 5 )\ninsert ( 3 , 6 )\nleaf = [ 0 for i in range ( N + 1 ) ]\nvis = [ 0 for i in range ( N + 1 ) ]\ndfs ( 1 , leaf , vis )\nprintLeaf ( N , leaf )\n", "python_code_tokenized": "adjacency = [ [ ] for i in range ( 100 ) ] NEW_LINE def insert ( x , y ) : NEW_LINE INDENT adjacency [ x ] . append ( y ) NEW_LINE DEDENT def dfs ( node , leaf , vis ) : NEW_LINE INDENT leaf [ node ] = 0 NEW_LINE vis [ node ] = 1 NEW_LINE for it in adjacency [ node ] : NEW_LINE INDENT if ( vis [ it ] == False ) : NEW_LINE INDENT dfs ( it , leaf , vis ) NEW_LINE leaf [ node ] += leaf [ it ] NEW_LINE DEDENT DEDENT if ( len ( adjacency [ node ] ) == 0 ) : NEW_LINE INDENT leaf [ node ] = 1 NEW_LINE DEDENT DEDENT def printLeaf ( n , leaf ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( \" The \u2581 node \" , i , \" has \" , leaf [ i ] , \" leaf \u2581 nodes \" ) NEW_LINE DEDENT DEDENT N = 6 NEW_LINE insert ( 1 , 2 ) NEW_LINE insert ( 1 , 3 ) NEW_LINE insert ( 3 , 4 ) NEW_LINE insert ( 3 , 5 ) NEW_LINE insert ( 3 , 6 ) NEW_LINE leaf = [ 0 for i in range ( N + 1 ) ] NEW_LINE vis = [ 0 for i in range ( N + 1 ) ] NEW_LINE dfs ( 1 , leaf , vis ) NEW_LINE printLeaf ( N , leaf ) NEW_LINE"}
{"id": "geeksforgeeks_173_A", "sol": 0, "python_code": "def SumOfDigits ( str , n ) :\n    sum = 0\n    for i in range ( 0 , n ) :\n        sum += int ( ord ( str [ i ] ) - ord ( '0' ) )\n    return sum\ndef Divisible ( str , n ) :\n    if ( ( SumOfDigits ( str , n ) % 3 == 0 and str [ n - 1 ] == '0' ) ) :\n        return True\n    return False\nif __name__ == \"__main__\" :\n    str = \"263730746028908374890\"\n    n = len ( str )\n    if ( Divisible ( str , n ) ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "def SumOfDigits ( str , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += int ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def Divisible ( str , n ) : NEW_LINE INDENT if ( ( SumOfDigits ( str , n ) % 3 == 0 and str [ n - 1 ] == '0' ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"263730746028908374890\" NEW_LINE n = len ( str ) NEW_LINE if ( Divisible ( str , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3929_A", "sol": 0, "python_code": "def minFn ( arr ) :\n    minimum = float ( 'inf' )\n    for i in range ( 0 , 4 ) :\n        if minimum > arr [ i ] :\n            minimum = arr [ i ]\n    return minimum\ndef minimizeGraph ( arr ) :\n    for i in range ( 0 , 4 ) :\n        for j in range ( 0 , 4 ) :\n            if arr [ i ] [ j ] == 0 :\n                arr [ i ] [ j ] = float ( 'inf' )\n    for i in range ( 0 , 4 ) :\n        minimum = minFn ( arr [ i ] )\n        for j in range ( 0 , 4 ) :\n            if ( ( not ( arr [ i ] [ j ] == minimum ) ) or ( arr [ i ] [ j ] == float ( 'inf' ) ) ) :\n                arr [ i ] [ j ] = 0\n            else :\n                minimum = 0\n    for i in range ( 0 , 4 ) :\n        for j in range ( 0 , 4 ) :\n            print ( arr [ i ] [ j ] , end = \" \" )\n        print ( )\nif __name__ == \"__main__\" :\n    arr = [ [ 1 , 2 , 4 , 0 ] , [ 0 , 0 , 0 , 5 ] , [ 0 , 2 , 0 , 3 ] , [ 0 , 0 , 0 , 0 ] ]\n    minimizeGraph ( arr )\n", "python_code_tokenized": "def minFn ( arr ) : NEW_LINE INDENT minimum = float ( ' inf ' ) NEW_LINE for i in range ( 0 , 4 ) : NEW_LINE INDENT if minimum > arr [ i ] : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT return minimum NEW_LINE DEDENT def minimizeGraph ( arr ) : NEW_LINE INDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT for j in range ( 0 , 4 ) : NEW_LINE INDENT if arr [ i ] [ j ] == 0 : NEW_LINE INDENT arr [ i ] [ j ] = float ( ' inf ' ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT minimum = minFn ( arr [ i ] ) NEW_LINE for j in range ( 0 , 4 ) : NEW_LINE INDENT if ( ( not ( arr [ i ] [ j ] == minimum ) ) or ( arr [ i ] [ j ] == float ( ' inf ' ) ) ) : NEW_LINE INDENT arr [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT minimum = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT for j in range ( 0 , 4 ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 2 , 4 , 0 ] , [ 0 , 0 , 0 , 5 ] , [ 0 , 2 , 0 , 3 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE minimizeGraph ( arr ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3955_A", "sol": 0, "python_code": "def search ( arr , start , end , value ) :\n    for i in range ( start , end + 1 ) :\n        if arr [ i ] == value :\n            return i\n    return - 1\ndef getHeight ( inOrder , levelOrder , start , end , height , n ) :\n    if start > end :\n        return 0\n    getIndex = search ( inOrder , start , end , levelOrder [ 0 ] )\n    if getIndex == - 1 :\n        return 0\n    leftCount = getIndex - start\n    rightCount = end - getIndex\n    newLeftLevel = [ None for _ in range ( leftCount ) ]\n    newRightLevel = [ None for _ in range ( rightCount ) ]\n    lheight , rheight , k = 0 , 0 , 0\n    for i in range ( n ) :\n        for j in range ( start , getIndex ) :\n            if levelOrder [ i ] == inOrder [ j ] :\n                newLeftLevel [ k ] = levelOrder [ i ]\n                k += 1\n                break\n    k = 0\n    for i in range ( n ) :\n        for j in range ( getIndex + 1 , end + 1 ) :\n            if levelOrder [ i ] == inOrder [ j ] :\n                newRightLevel [ k ] = levelOrder [ i ]\n                k += 1\n                break\n    if leftCount > 0 :\n        lheight = getHeight ( inOrder , newLeftLevel , start , getIndex - 1 , height , leftCount )\n    if rightCount > 0 :\n        rheight = getHeight ( inOrder , newRightLevel , getIndex + 1 , end , height , rightCount )\n    height = max ( lheight + 1 , rheight + 1 )\n    return height\nif __name__ == '__main__' :\n    inOrder = [ 4 , 8 , 10 , 12 , 14 , 20 , 22 ]\n    levelOrder = [ 20 , 8 , 22 , 4 , 12 , 10 , 14 ]\n    n , h = len ( inOrder ) , 0\n    print ( getHeight ( inOrder , levelOrder , 0 , n - 1 , h , n ) )\n", "python_code_tokenized": "def search ( arr , start , end , value ) : NEW_LINE INDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] == value : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def getHeight ( inOrder , levelOrder , start , end , height , n ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return 0 NEW_LINE DEDENT getIndex = search ( inOrder , start , end , levelOrder [ 0 ] ) NEW_LINE if getIndex == - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT leftCount = getIndex - start NEW_LINE rightCount = end - getIndex NEW_LINE newLeftLevel = [ None for _ in range ( leftCount ) ] NEW_LINE newRightLevel = [ None for _ in range ( rightCount ) ] NEW_LINE lheight , rheight , k = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( start , getIndex ) : NEW_LINE INDENT if levelOrder [ i ] == inOrder [ j ] : NEW_LINE INDENT newLeftLevel [ k ] = levelOrder [ i ] NEW_LINE k += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( getIndex + 1 , end + 1 ) : NEW_LINE INDENT if levelOrder [ i ] == inOrder [ j ] : NEW_LINE INDENT newRightLevel [ k ] = levelOrder [ i ] NEW_LINE k += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if leftCount > 0 : NEW_LINE INDENT lheight = getHeight ( inOrder , newLeftLevel , start , getIndex - 1 , height , leftCount ) NEW_LINE DEDENT if rightCount > 0 : NEW_LINE INDENT rheight = getHeight ( inOrder , newRightLevel , getIndex + 1 , end , height , rightCount ) NEW_LINE DEDENT height = max ( lheight + 1 , rheight + 1 ) NEW_LINE return height NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT inOrder = [ 4 , 8 , 10 , 12 , 14 , 20 , 22 ] NEW_LINE levelOrder = [ 20 , 8 , 22 , 4 , 12 , 10 , 14 ] NEW_LINE n , h = len ( inOrder ) , 0 NEW_LINE print ( getHeight ( inOrder , levelOrder , 0 , n - 1 , h , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4326_A", "sol": 0, "python_code": "def print2largest ( arr , arr_size ) :\n    if ( arr_size < 2 ) :\n        print ( \" Invalid Input \" )\n        return\n    first = second = - 2147483648\n    for i in range ( arr_size ) :\n        if ( arr [ i ] > first ) :\n            second = first\n            first = arr [ i ]\n        elif ( arr [ i ] > second and arr [ i ] != first ) :\n            second = arr [ i ]\n    if ( second == - 2147483648 ) :\n        print ( \"There is no second largest element\" )\n    else :\n        print ( \"The second largest element is\" , second )\narr = [ 12 , 35 , 1 , 10 , 34 , 1 ]\nn = len ( arr )\nprint2largest ( arr , n )\n", "python_code_tokenized": "def print2largest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 2 ) : NEW_LINE INDENT print ( \" \u2581 Invalid \u2581 Input \u2581 \" ) NEW_LINE return NEW_LINE DEDENT first = second = - 2147483648 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second and arr [ i ] != first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT if ( second == - 2147483648 ) : NEW_LINE INDENT print ( \" There \u2581 is \u2581 no \u2581 second \u2581 largest \u2581 element \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The \u2581 second \u2581 largest \u2581 element \u2581 is \" , second ) NEW_LINE DEDENT DEDENT arr = [ 12 , 35 , 1 , 10 , 34 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print2largest ( arr , n ) NEW_LINE"}
{"id": "codeforces_525_A", "sol": 0, "python_code": "n = int ( input ( ) )\ns = input ( )\nhistory = dict ( )\ncount = 0\nfor i in range ( 0 , 2 * n - 2 , 2 ) :\n    code = s [ i ]\n    if code in history :\n        history [ code ] += 1\n    else :\n        history [ code ] = 1\n    next_code = s [ i + 1 ].lower ( )\n    if next_code in history and history [ next_code ] > 0 :\n        history [ next_code ] -= 1\n    else :\n        count += 1\nprint ( count )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE history = dict ( ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , 2 * n - 2 , 2 ) : NEW_LINE INDENT code = s [ i ] NEW_LINE if code in history : NEW_LINE INDENT history [ code ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT history [ code ] = 1 NEW_LINE DEDENT next_code = s [ i + 1 ] . lower ( ) NEW_LINE if next_code in history and history [ next_code ] > 0 : NEW_LINE INDENT history [ next_code ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"}
{"id": "geeksforgeeks_3036_A", "sol": 0, "python_code": "def PowerOfTwo ( x , n ) :\n    x.sort ( )\n    res = [ ]\n    for i in range ( n ) :\n        for j in range ( 1 , 31 ) :\n            lx = x [ i ] - ( 1 << j )\n            rx = x [ i ] + ( 1 << j )\n            if lx in x :\n                isl = True\n            else :\n                isl = False\n            if rx in x :\n                isr = True\n            else :\n                isr = False\n            if ( isl and isr and len ( res ) < 3 ) :\n                res = [ lx , x [ i ] , rx ]\n            if ( isl and len ( res ) < 2 ) :\n                res = [ lx , x [ i ] ]\n            if ( isr and len ( res ) < 2 ) :\n                res = [ x [ i ] , rx ]\n    if ( not len ( res ) ) :\n        print ( - 1 )\n        return\n    for it in res :\n        print ( it , end = \" \" )\nif __name__ == \"__main__\" :\n    a = [ 3 , 4 , 5 , 6 , 7 ]\n    n = len ( a )\n    PowerOfTwo ( a , n )\n", "python_code_tokenized": "def PowerOfTwo ( x , n ) : NEW_LINE INDENT x . sort ( ) NEW_LINE res = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , 31 ) : NEW_LINE INDENT lx = x [ i ] - ( 1 << j ) NEW_LINE rx = x [ i ] + ( 1 << j ) NEW_LINE if lx in x : NEW_LINE INDENT isl = True NEW_LINE DEDENT else : NEW_LINE INDENT isl = False NEW_LINE DEDENT if rx in x : NEW_LINE INDENT isr = True NEW_LINE DEDENT else : NEW_LINE INDENT isr = False NEW_LINE DEDENT if ( isl and isr and len ( res ) < 3 ) : NEW_LINE INDENT res = [ lx , x [ i ] , rx ] NEW_LINE DEDENT if ( isl and len ( res ) < 2 ) : NEW_LINE INDENT res = [ lx , x [ i ] ] NEW_LINE DEDENT if ( isr and len ( res ) < 2 ) : NEW_LINE INDENT res = [ x [ i ] , rx ] NEW_LINE DEDENT DEDENT DEDENT if ( not len ( res ) ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for it in res : NEW_LINE INDENT print ( it , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( a ) NEW_LINE PowerOfTwo ( a , n ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC119_B", "sol": 0, "python_code": "N = int ( input ( ) )\nc = 0\nfor i in range ( N ) :\n    a = list ( input ( ).split ( ) )\n    if a [ 1 ] == 'BTC' :\n        c += float ( a [ 0 ] ) * 380000.0\n    else :\n        c += float ( a [ 0 ] )\nprint ( c )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = list ( input ( ) . split ( ) ) NEW_LINE if a [ 1 ] == ' BTC ' : NEW_LINE INDENT c += float ( a [ 0 ] ) * 380000.0 NEW_LINE DEDENT else : NEW_LINE INDENT c += float ( a [ 0 ] ) NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE"}
{"id": "geeksforgeeks_1652_A", "sol": 0, "python_code": "from sys import maxsize\ndef maxSubArraySum ( a , size ) :\n    max_so_far = - maxsize - 1\n    max_ending_here = 0\n    start = 0\n    end = 0\n    s = 0\n    for i in range ( 0 , size ) :\n        max_ending_here += a [ i ]\n        if max_so_far < max_ending_here :\n            max_so_far = max_ending_here\n            start = s\n            end = i\n        if max_ending_here < 0 :\n            max_ending_here = 0\n            s = i + 1\n    print ( \"Maximum contiguous sum is %d\" % ( max_so_far ) )\n    print ( \"Starting Index %d\" % ( start ) )\n    print ( \"Ending Index %d\" % ( end ) )\na = [ - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 ]\nmaxSubArraySum ( a , len ( a ) )\n", "python_code_tokenized": "from sys import maxsize NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - maxsize - 1 NEW_LINE max_ending_here = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here += a [ i ] NEW_LINE if max_so_far < max_ending_here : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE start = s NEW_LINE end = i NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE s = i + 1 NEW_LINE DEDENT DEDENT print ( \" Maximum \u2581 contiguous \u2581 sum \u2581 is \u2581 % d \" % ( max_so_far ) ) NEW_LINE print ( \" Starting \u2581 Index \u2581 % d \" % ( start ) ) NEW_LINE print ( \" Ending \u2581 Index \u2581 % d \" % ( end ) ) NEW_LINE DEDENT a = [ - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 ] NEW_LINE maxSubArraySum ( a , len ( a ) ) NEW_LINE"}
{"id": "geeksforgeeks_1763_A", "sol": 0, "python_code": "def printUnion ( arr1 , arr2 , n1 , n2 ) :\n    hs = set ( )\n    for i in range ( 0 , n1 ) :\n        hs.add ( arr1 [ i ] )\n    for i in range ( 0 , n2 ) :\n        hs.add ( arr2 [ i ] )\n    print ( \"Union:\" )\n    for i in hs :\n        print ( i , end = \" \" )\n    print ( \"\\n\" )\ndef printIntersection ( arr1 , arr2 , n1 , n2 ) :\n    hs = set ( )\n    for i in range ( 0 , n1 ) :\n        hs.add ( arr1 [ i ] )\n    print ( \"Intersection:\" )\n    for i in range ( 0 , n2 ) :\n        if arr2 [ i ] in hs :\n            print ( arr2 [ i ] , end = \" \" )\narr1 = [ 7 , 1 , 5 , 2 , 3 , 6 ]\narr2 = [ 3 , 8 , 6 , 20 , 7 ]\nn1 = len ( arr1 )\nn2 = len ( arr2 )\nprintUnion ( arr1 , arr2 , n1 , n2 )\nprintIntersection ( arr1 , arr2 , n1 , n2 )\n", "python_code_tokenized": "def printUnion ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT hs = set ( ) NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT hs . add ( arr1 [ i ] ) NEW_LINE DEDENT for i in range ( 0 , n2 ) : NEW_LINE INDENT hs . add ( arr2 [ i ] ) NEW_LINE DEDENT print ( \" Union : \" ) NEW_LINE for i in hs : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \\n \" ) NEW_LINE DEDENT def printIntersection ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT hs = set ( ) NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT hs . add ( arr1 [ i ] ) NEW_LINE DEDENT print ( \" Intersection : \" ) NEW_LINE for i in range ( 0 , n2 ) : NEW_LINE INDENT if arr2 [ i ] in hs : NEW_LINE INDENT print ( arr2 [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 7 , 1 , 5 , 2 , 3 , 6 ] NEW_LINE arr2 = [ 3 , 8 , 6 , 20 , 7 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE printUnion ( arr1 , arr2 , n1 , n2 ) NEW_LINE printIntersection ( arr1 , arr2 , n1 , n2 ) NEW_LINE"}
{"id": "geeksforgeeks_3445_A", "sol": 0, "python_code": "def check ( n ) :\n    if n % 2 == 1 and n > 5 :\n        print ( 'YES' )\n    else :\n        print ( 'NO' )\ndef main ( ) :\n    a = 3\n    b = 7\n    check ( a )\n    check ( b )\nmain ( )\n", "python_code_tokenized": "def check ( n ) : NEW_LINE INDENT if n % 2 == 1 and n > 5 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT a = 3 NEW_LINE b = 7 NEW_LINE check ( a ) NEW_LINE check ( b ) NEW_LINE DEDENT main ( ) NEW_LINE"}
{"id": "codeforces_879_B", "sol": 0, "python_code": "inputNum = input ( ).split ( )\nnumPeople = int ( inputNum [ 0 ] )\ngames = int ( inputNum [ 1 ] )\ni = 0\npowers = input ( ).split ( )\nj = 0\nwhile j < numPeople :\n    powers [ j ] = int ( powers [ j ] )\n    j += 1\nqueue = [ ]\nwhile i < numPeople :\n    queue.append ( [ powers [ i ] , 0 ] )\n    i += 1\nif games > numPeople :\n    print ( max ( powers ) )\nelse :\n    while queue [ 0 ] [ 1 ] != games :\n        if queue [ 0 ] [ 0 ] > queue [ 1 ] [ 0 ] :\n            queue.append ( [ queue [ 1 ] [ 0 ] , queue [ 1 ] [ 1 ] ] )\n            queue [ 0 ] [ 1 ] += 1\n            queue.pop ( 1 )\n        else :\n            queue.append ( [ queue [ 0 ] [ 0 ] , queue [ 0 ] [ 1 ] ] )\n            queue [ 1 ] [ 1 ] += 1\n            queue.pop ( 0 )\n    print ( queue [ 0 ] [ 0 ] )\n", "python_code_tokenized": "inputNum = input ( ) . split ( ) NEW_LINE numPeople = int ( inputNum [ 0 ] ) NEW_LINE games = int ( inputNum [ 1 ] ) NEW_LINE i = 0 NEW_LINE powers = input ( ) . split ( ) NEW_LINE j = 0 NEW_LINE while j < numPeople : NEW_LINE INDENT powers [ j ] = int ( powers [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT queue = [ ] NEW_LINE while i < numPeople : NEW_LINE INDENT queue . append ( [ powers [ i ] , 0 ] ) NEW_LINE i += 1 NEW_LINE DEDENT if games > numPeople : NEW_LINE INDENT print ( max ( powers ) ) NEW_LINE DEDENT else : NEW_LINE INDENT while queue [ 0 ] [ 1 ] != games : NEW_LINE INDENT if queue [ 0 ] [ 0 ] > queue [ 1 ] [ 0 ] : NEW_LINE INDENT queue . append ( [ queue [ 1 ] [ 0 ] , queue [ 1 ] [ 1 ] ] ) NEW_LINE queue [ 0 ] [ 1 ] += 1 NEW_LINE queue . pop ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT queue . append ( [ queue [ 0 ] [ 0 ] , queue [ 0 ] [ 1 ] ] ) NEW_LINE queue [ 1 ] [ 1 ] += 1 NEW_LINE queue . pop ( 0 ) NEW_LINE DEDENT DEDENT print ( queue [ 0 ] [ 0 ] ) NEW_LINE DEDENT"}
{"id": "codeforces_192_A", "sol": 0, "python_code": "a = set ( [ i * ( i + 1 ) // 2 for i in range ( 1 , 50000 ) ] )\nn = int ( input ( ) )\nprint ( \"YES\" if any ( n - t in a for t in a ) else \"NO\" )\n", "python_code_tokenized": "a = set ( [ i * ( i + 1 ) // 2 for i in range ( 1 , 50000 ) ] ) NEW_LINE n = int ( input ( ) ) NEW_LINE print ( \" YES \" if any ( n - t in a for t in a ) else \" NO \" ) NEW_LINE"}
{"id": "geeksforgeeks_2007_A", "sol": 0, "python_code": "MAX = 10000\nprime = [ True for i in range ( MAX + 1 ) ]\ndef SieveOfEratosthenes ( ) :\n    prime [ 1 ] = False\n    for p in range ( 2 , MAX + 1 ) :\n        if ( prime [ p ] == True ) :\n            for i in range ( 2 * p , MAX + 1 , p ) :\n                prime [ i ] = False\ndef xorFirstNPrime ( n ) :\n    count = 0\n    num = 1\n    xorVal = 0\n    while ( count < n ) :\n        if ( prime [ num ] ) :\n            xorVal ^= num\n            count += 1\n        num += 1\n    return xorVal\nSieveOfEratosthenes ( )\nn = 4\nprint ( xorFirstNPrime ( n ) )\n", "python_code_tokenized": "MAX = 10000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def xorFirstNPrime ( n ) : NEW_LINE INDENT count = 0 NEW_LINE num = 1 NEW_LINE xorVal = 0 NEW_LINE while ( count < n ) : NEW_LINE INDENT if ( prime [ num ] ) : NEW_LINE INDENT xorVal ^= num NEW_LINE count += 1 NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return xorVal NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE n = 4 NEW_LINE print ( xorFirstNPrime ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3921_A", "sol": 0, "python_code": "class Node :\n    def __init__ ( self ) :\n        self.data = 0\n        self.left = None\n        self.right = None\ndef newNode ( data ) :\n    newNode = Node ( )\n    newNode.data = data\n    newNode.left = newNode.right = None\n    return ( newNode )\nres = 0\ndef countUntil ( root ) :\n    global res\n    if ( root == None ) :\n        return 0\n    l = countUntil ( root.left )\n    r = countUntil ( root.right )\n    maxCount = 0\n    if ( root.data == 1 ) :\n        maxCount = l + r + 1\n    else :\n        maxCount = l + r\n    res = max ( res , maxCount )\n    if ( root.data == 1 ) :\n        return max ( l , r ) + 1\n    else :\n        return max ( l , r )\ndef findMaxCount ( root ) :\n    global res\n    res = - 999999\n    countUntil ( root )\n    return res\nroot = newNode ( 1 )\nroot.left = newNode ( 0 )\nroot.right = newNode ( 1 )\nroot.left.left = newNode ( 1 )\nroot.left.right = newNode ( 1 )\nroot.left.right.left = newNode ( 1 )\nroot.left.right.right = newNode ( 0 )\nprint ( findMaxCount ( root ) )\n", "python_code_tokenized": "class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT newNode = Node ( ) NEW_LINE newNode . data = data NEW_LINE newNode . left = newNode . right = None NEW_LINE return ( newNode ) NEW_LINE DEDENT res = 0 NEW_LINE def countUntil ( root ) : NEW_LINE INDENT global res NEW_LINE if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = countUntil ( root . left ) NEW_LINE r = countUntil ( root . right ) NEW_LINE maxCount = 0 NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT maxCount = l + r + 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxCount = l + r NEW_LINE DEDENT res = max ( res , maxCount ) NEW_LINE if ( root . data == 1 ) : NEW_LINE INDENT return max ( l , r ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return max ( l , r ) NEW_LINE DEDENT DEDENT def findMaxCount ( root ) : NEW_LINE INDENT global res NEW_LINE res = - 999999 NEW_LINE countUntil ( root ) NEW_LINE return res NEW_LINE DEDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 0 ) NEW_LINE root . right = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . left . right . left = newNode ( 1 ) NEW_LINE root . left . right . right = newNode ( 0 ) NEW_LINE print ( findMaxCount ( root ) ) NEW_LINE"}
{"id": "geeksforgeeks_5278_A", "sol": 0, "python_code": "def digitSum ( n ) :\n    digSum = 0\n    while ( n > 0 ) :\n        digSum += n % 10\n        n //= 10\n    return digSum\ndef countInteger ( n , s ) :\n    if ( n < s ) :\n        return 0\n    for i in range ( s , min ( n , s + 163 ) + 1 ) :\n        if ( ( i - digitSum ( i ) ) > s ) :\n            return ( n - i + 1 )\n    return 0\nn = 1000\ns = 100\nprint ( countInteger ( n , s ) )\n", "python_code_tokenized": "def digitSum ( n ) : NEW_LINE INDENT digSum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digSum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return digSum NEW_LINE DEDENT def countInteger ( n , s ) : NEW_LINE INDENT if ( n < s ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( s , min ( n , s + 163 ) + 1 ) : NEW_LINE INDENT if ( ( i - digitSum ( i ) ) > s ) : NEW_LINE INDENT return ( n - i + 1 ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT n = 1000 NEW_LINE s = 100 NEW_LINE print ( countInteger ( n , s ) ) NEW_LINE"}
{"id": "geeksforgeeks_3031_A", "sol": 0, "python_code": "def countPairsWithProdK ( arr , n , k ) :\n    count = 0\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            if ( arr [ i ] * arr [ j ] == k ) :\n                count += 1\n    return count\narr = [ 1 , 5 , 3 , 4 , 2 ]\nN = len ( arr )\nK = 3\nprint ( countPairsWithProdK ( arr , N , K ) )\n", "python_code_tokenized": "def countPairsWithProdK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 5 , 3 , 4 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( countPairsWithProdK ( arr , N , K ) ) NEW_LINE"}
{"id": "geeksforgeeks_2_A", "sol": 0, "python_code": "from math import sqrt\ndef Prime ( n ) :\n    if ( n < 2 ) :\n        return False ;\n    for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) :\n        if ( n % i == 0 ) :\n            return False ;\n    return True ;\ndef primeCountDivisors ( n ) :\n    if ( n < 2 ) :\n        return False ;\n    for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) :\n        if ( n % i == 0 ) :\n            a = n ; c = 0 ;\n            while ( a % i == 0 ) :\n                a //= i ;\n                c += 1 ;\n            if ( a == 1 and Prime ( c + 1 ) ) :\n                return True ;\n            else :\n                return False ;\n    return True ;\nif __name__ == \"__main__\" :\n    n = 13 ;\n    if ( primeCountDivisors ( n ) ) :\n        print ( \"Yes\" ) ;\n    else :\n        print ( \"No\" ) ;\n", "python_code_tokenized": "from math import sqrt NEW_LINE def Prime ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def primeCountDivisors ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT a = n ; c = 0 ; NEW_LINE while ( a % i == 0 ) : NEW_LINE INDENT a //= i ; NEW_LINE c += 1 ; NEW_LINE DEDENT if ( a == 1 and Prime ( c + 1 ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 13 ; NEW_LINE if ( primeCountDivisors ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC140_A", "sol": 0, "python_code": "def main ( ) :\n    n = int ( input ( ) )\n    print ( n ** 3 )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( n ** 3 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2186_A", "sol": 0, "python_code": "def check ( n ) :\n    m = n\n    while ( n != 0 ) :\n        r = n % 10\n        if ( r > 0 ) :\n            if ( ( m % r ) != 0 ) :\n                return False\n        n = n // 10\n    return True\ndef count ( l , r ) :\n    ans = 0\n    for i in range ( l , r + 1 ) :\n        if ( check ( i ) ) :\n            ans = ans + 1\n    return ans\nl = 10\nr = 20\nprint ( count ( l , r ) )\n", "python_code_tokenized": "def check ( n ) : NEW_LINE INDENT m = n NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE if ( r > 0 ) : NEW_LINE INDENT if ( ( m % r ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def count ( l , r ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( check ( i ) ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT l = 10 NEW_LINE r = 20 NEW_LINE print ( count ( l , r ) ) NEW_LINE"}
{"id": "aizu_p02198_A", "sol": 0, "python_code": "N , M = map ( int , input ( ).split ( ) )\nprint ( N * M )\n", "python_code_tokenized": "N , M = map ( int , input ( ) . split ( ) ) NEW_LINE print ( N * M ) NEW_LINE"}
{"id": "codeforces_840_A", "sol": 0, "python_code": "m = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nb = list ( map ( int , input ( ).split ( ) ) )\nd = [ 0 ] * m\nclass struct :\n    def __init__ ( self , value , idx ) :\n        self.value = value\n        self.idx = idx\nfor i in range ( m ) :\n    b [ i ] = struct ( b [ i ] , i )\na.sort ( reverse = True )\nb.sort ( key = lambda x : x.value )\nfor i in range ( m ) :\n    d [ b [ i ].idx ] = a [ i ]\nfor i in range ( m ) :\n    print ( d [ i ] , '' , end = '' )\n", "python_code_tokenized": "m = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = [ 0 ] * m NEW_LINE class struct : NEW_LINE INDENT def __init__ ( self , value , idx ) : NEW_LINE INDENT self . value = value NEW_LINE self . idx = idx NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT b [ i ] = struct ( b [ i ] , i ) NEW_LINE DEDENT a . sort ( reverse = True ) NEW_LINE b . sort ( key = lambda x : x . value ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT d [ b [ i ] . idx ] = a [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT print ( d [ i ] , ' ' , end = ' ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_432_A", "sol": 0, "python_code": "def countKdivPairs ( A , n , K ) :\n    freq = [ 0 ] * K\n    for i in range ( n ) :\n        freq [ A [ i ] % K ] += 1\n    sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 ;\n    i = 1\n    while ( i <= K // 2 and i != ( K - i ) ) :\n        sum += freq [ i ] * freq [ K - i ]\n        i += 1\n    if ( K % 2 == 0 ) :\n        sum += ( freq [ K // 2 ] * ( freq [ K // 2 ] - 1 ) / 2 ) ;\n    return int ( sum )\nA = [ 2 , 2 , 1 , 7 , 5 , 3 ]\nn = len ( A )\nK = 4\nprint ( countKdivPairs ( A , n , K ) )\n", "python_code_tokenized": "def countKdivPairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 ] * K NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ A [ i ] % K ] += 1 NEW_LINE DEDENT sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 ; NEW_LINE i = 1 NEW_LINE while ( i <= K // 2 and i != ( K - i ) ) : NEW_LINE INDENT sum += freq [ i ] * freq [ K - i ] NEW_LINE i += 1 NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT sum += ( freq [ K // 2 ] * ( freq [ K // 2 ] - 1 ) / 2 ) ; NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT A = [ 2 , 2 , 1 , 7 , 5 , 3 ] NEW_LINE n = len ( A ) NEW_LINE K = 4 NEW_LINE print ( countKdivPairs ( A , n , K ) ) NEW_LINE"}
{"id": "geeksforgeeks_953_A", "sol": 0, "python_code": "def countDistinct ( arr , n ) :\n    res = 1\n    for i in range ( 1 , n ) :\n        j = 0\n        for j in range ( i ) :\n            if ( arr [ i ] == arr [ j ] ) :\n                break\n        if ( i == j + 1 ) :\n            res += 1\n    return res\narr = [ 12 , 10 , 9 , 45 , 2 , 10 , 10 , 45 ]\nn = len ( arr )\nprint ( countDistinct ( arr , n ) )\n", "python_code_tokenized": "def countDistinct ( arr , n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == j + 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 12 , 10 , 9 , 45 , 2 , 10 , 10 , 45 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDistinct ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3902_A", "sol": 0, "python_code": "import math\ndef CountAllPairs ( N , K ) :\n    count = 0\n    if ( N > K ) :\n        count = N - K\n        for i in range ( K + 1 , N + 1 ) :\n            count = count + ( ( N - K ) // i )\n    return count\nN = 11\nK = 5\nprint ( CountAllPairs ( N , K ) )\n", "python_code_tokenized": "import math NEW_LINE def CountAllPairs ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE if ( N > K ) : NEW_LINE INDENT count = N - K NEW_LINE for i in range ( K + 1 , N + 1 ) : NEW_LINE INDENT count = count + ( ( N - K ) // i ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT N = 11 NEW_LINE K = 5 NEW_LINE print ( CountAllPairs ( N , K ) ) NEW_LINE"}
{"id": "leetcode_872_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def leafSimilar ( self , root1 , root2 ) :\n        if not root1 and not root2 :\n            return True\n        leaf1 = [ ]\n        leaf2 = [ ]\n        self.dfs ( root1 , leaf1 )\n        self.dfs ( root2 , leaf2 )\n        if leaf1 == leaf2 :\n            return True\n        return False\n    def dfs ( self , node , leavels ) :\n        if not node :\n            return\n        if not node.left and not node.right :\n            leavels.append ( node.val )\n        self.dfs ( node.left , leavels )\n        self.dfs ( node.right , leavels )\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def leafSimilar ( self , root1 , root2 ) : NEW_LINE INDENT if not root1 and not root2 : NEW_LINE INDENT return True NEW_LINE DEDENT leaf1 = [ ] NEW_LINE leaf2 = [ ] NEW_LINE self . dfs ( root1 , leaf1 ) NEW_LINE self . dfs ( root2 , leaf2 ) NEW_LINE if leaf1 == leaf2 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def dfs ( self , node , leavels ) : NEW_LINE INDENT if not node : NEW_LINE INDENT return NEW_LINE DEDENT if not node . left and not node . right : NEW_LINE INDENT leavels . append ( node . val ) NEW_LINE DEDENT self . dfs ( node . left , leavels ) NEW_LINE self . dfs ( node . right , leavels ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00033_A", "sol": 0, "python_code": "import sys\nsys.setrecursionlimit ( 100000 )\ndef load_balls ( ) :\n    LINE_NUM , TOTAL = 0 , 0\n    balls = [ ]\n    i = 0\n    for line in sys.stdin :\n        line = line.strip ( )\n        LINE_NUM += 1\n        if LINE_NUM == 1 :\n            TOTAL = int ( line.strip ( ) )\n            continue\n        balls.append ( [ int ( i ) for i in line.split ( \" \" ) ] )\n        if LINE_NUM == TOTAL + 1 : break\n    return balls\nclass VesselClass :\n    def __init__ ( self ) :\n        self.tmp = [ ]\n        self.left = [ 0 ]\n        self.right = [ 0 ]\n    def fill ( self , balls : list ) :\n        self.tmp = balls\n    def DFS ( self ) :\n        if len ( self.tmp ) == 0 : print ( \"YES\" )\n        elif self.left [ - 1 ] < self.tmp [ 0 ] :\n            self.left.append ( self.tmp [ 0 ] )\n            self.tmp.pop ( 0 )\n            self.DFS ( )\n        elif self.right [ - 1 ] < self.tmp [ 0 ] :\n            self.right.append ( self.tmp [ 0 ] )\n            self.tmp.pop ( 0 )\n            self.DFS ( )\n        else : print ( \"NO\" )\nballs_list = load_balls ( )\nfor balls in balls_list :\n    Vessel = VesselClass ( )\n    Vessel.fill ( balls )\n    Vessel.DFS ( )\n", "python_code_tokenized": "import sys NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE def load_balls ( ) : NEW_LINE INDENT LINE_NUM , TOTAL = 0 , 0 NEW_LINE balls = [ ] NEW_LINE i = 0 NEW_LINE for line in sys . stdin : NEW_LINE INDENT line = line . strip ( ) NEW_LINE LINE_NUM += 1 NEW_LINE if LINE_NUM == 1 : NEW_LINE INDENT TOTAL = int ( line . strip ( ) ) NEW_LINE continue NEW_LINE DEDENT balls . append ( [ int ( i ) for i in line . split ( \" \u2581 \" ) ] ) NEW_LINE if LINE_NUM == TOTAL + 1 : break NEW_LINE DEDENT return balls NEW_LINE DEDENT class VesselClass : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . tmp = [ ] NEW_LINE self . left = [ 0 ] NEW_LINE self . right = [ 0 ] NEW_LINE DEDENT def fill ( self , balls : list ) : NEW_LINE INDENT self . tmp = balls NEW_LINE DEDENT def DFS ( self ) : NEW_LINE INDENT if len ( self . tmp ) == 0 : print ( \" YES \" ) NEW_LINE elif self . left [ - 1 ] < self . tmp [ 0 ] : NEW_LINE INDENT self . left . append ( self . tmp [ 0 ] ) NEW_LINE self . tmp . pop ( 0 ) NEW_LINE self . DFS ( ) NEW_LINE DEDENT elif self . right [ - 1 ] < self . tmp [ 0 ] : NEW_LINE INDENT self . right . append ( self . tmp [ 0 ] ) NEW_LINE self . tmp . pop ( 0 ) NEW_LINE self . DFS ( ) NEW_LINE DEDENT else : print ( \" NO \" ) NEW_LINE DEDENT DEDENT balls_list = load_balls ( ) NEW_LINE for balls in balls_list : NEW_LINE INDENT Vessel = VesselClass ( ) NEW_LINE Vessel . fill ( balls ) NEW_LINE Vessel . DFS ( ) NEW_LINE DEDENT"}
{"id": "codeforces_894_B", "sol": 0, "python_code": "mod = 1e9 + 7\nn , m , k = map ( int , input ( ).split ( ) )\nif ( n + m ) % 2 == 1 and k == - 1 :\n    print ( 0 )\n    exit ( )\na = ( n - 1 ) * ( m - 1 )\nprint ( pow ( 2 , a , int ( mod ) ) )\n", "python_code_tokenized": "mod = 1e9 + 7 NEW_LINE n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE if ( n + m ) % 2 == 1 and k == - 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT a = ( n - 1 ) * ( m - 1 ) NEW_LINE print ( pow ( 2 , a , int ( mod ) ) ) NEW_LINE"}
{"id": "leetcode_002_A", "sol": 0, "python_code": "class ListNode ( object ) :\n    def __init__ ( self , x ) :\n        self.val = x\n        self.next = None\nclass Solution ( object ) :\n    def addTwoNumbers ( self , l1 , l2 ) :\n        carry = 0\n        head = curr = ListNode ( 0 )\n        while l1 or l2 :\n            val = carry\n            if l1 :\n                val += l1.val\n                l1 = l1.next\n            if l2 :\n                val += l2.val\n                l2 = l2.next\n            curr.next = ListNode ( val % 10 )\n            curr = curr.next\n            carry = val / 10\n        if carry > 0 :\n            curr.next = ListNode ( carry )\n        return head.next\n", "python_code_tokenized": "class ListNode ( object ) : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . val = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def addTwoNumbers ( self , l1 , l2 ) : NEW_LINE INDENT carry = 0 NEW_LINE head = curr = ListNode ( 0 ) NEW_LINE while l1 or l2 : NEW_LINE INDENT val = carry NEW_LINE if l1 : NEW_LINE INDENT val += l1 . val NEW_LINE l1 = l1 . next NEW_LINE DEDENT if l2 : NEW_LINE INDENT val += l2 . val NEW_LINE l2 = l2 . next NEW_LINE DEDENT curr . next = ListNode ( val % 10 ) NEW_LINE curr = curr . next NEW_LINE carry = val / 10 NEW_LINE DEDENT if carry > 0 : NEW_LINE INDENT curr . next = ListNode ( carry ) NEW_LINE DEDENT return head . next NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1743_A", "sol": 0, "python_code": "def countNumbersWith4 ( n ) :\n    result = 0\n    for x in range ( 1 , n + 1 ) :\n        if ( has4 ( x ) == True ) :\n            result = result + 1\n    return result\ndef has4 ( x ) :\n    while ( x != 0 ) :\n        if ( x % 10 == 4 ) :\n            return True\n        x = x // 10\n    return False\nn = 328\nprint ( \"Count of numbers from 1 to \" , n , \" that have 4 as a a digit is \" , countNumbersWith4 ( n ) )\n", "python_code_tokenized": "def countNumbersWith4 ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( has4 ( x ) == True ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def has4 ( x ) : NEW_LINE INDENT while ( x != 0 ) : NEW_LINE INDENT if ( x % 10 == 4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT return False NEW_LINE DEDENT n = 328 NEW_LINE print ( \" Count \u2581 of \u2581 numbers \u2581 from \u2581 1 \u2581 to \u2581 \" , n , \" \u2581 that \u2581 have \u2581 4 \u2581 as \u2581 a \u2581 a \u2581 digit \u2581 is \u2581 \" , countNumbersWith4 ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4983_A", "sol": 0, "python_code": "def printUncommon ( arr1 , arr2 , n1 , n2 ) :\n    i = 0\n    j = 0\n    k = 0\n    while ( i < n1 and j < n2 ) :\n        if ( arr1 [ i ] < arr2 [ j ] ) :\n            print ( arr1 [ i ] , end = \" \" )\n            i = i + 1\n            k = k + 1\n        elif ( arr2 [ j ] < arr1 [ i ] ) :\n            print ( arr2 [ j ] , end = \" \" )\n            k = k + 1\n            j = j + 1\n        else :\n            i = i + 1\n            j = j + 1\n    while ( i < n1 ) :\n        print ( arr1 [ i ] , end = \" \" )\n        i = i + 1\n        k = k + 1\n    while ( j < n2 ) :\n        print ( arr2 [ j ] , end = \" \" )\n        j = j + 1\n        k = k + 1\narr1 = [ 10 , 20 , 30 ]\narr2 = [ 20 , 25 , 30 , 40 , 50 ]\nn1 = len ( arr1 )\nn2 = len ( arr2 )\nprintUncommon ( arr1 , arr2 , n1 , n2 )\n", "python_code_tokenized": "def printUncommon ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( i < n1 and j < n2 ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" \u2581 \" ) NEW_LINE i = i + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT elif ( arr2 [ j ] < arr1 [ i ] ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" \u2581 \" ) NEW_LINE k = k + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT while ( i < n1 ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" \u2581 \" ) NEW_LINE i = i + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT while ( j < n2 ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" \u2581 \" ) NEW_LINE j = j + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT DEDENT arr1 = [ 10 , 20 , 30 ] NEW_LINE arr2 = [ 20 , 25 , 30 , 40 , 50 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE printUncommon ( arr1 , arr2 , n1 , n2 ) NEW_LINE"}
{"id": "geeksforgeeks_528_A", "sol": 0, "python_code": "def count9s ( number ) :\n    n = len ( number )\n    d = [ 0 for i in range ( 9 ) ]\n    d [ 0 ] = 1\n    result = 0\n    mod_sum = 0\n    continuous_zero = 0\n    for i in range ( n ) :\n        if ( ord ( number [ i ] ) - ord ( '0' ) == 0 ) :\n            continuous_zero += 1\n        else :\n            continuous_zero = 0\n        mod_sum += ord ( number [ i ] ) - ord ( '0' )\n        mod_sum %= 9\n        result += d [ mod_sum ]\n        d [ mod_sum ] += 1\n        result -= continuous_zero\n    return result\nif __name__ == '__main__' :\n    print ( count9s ( \"01809\" ) )\n    print ( count9s ( \"1809\" ) )\n    print ( count9s ( \"4189\" ) )\n", "python_code_tokenized": "def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE d = [ 0 for i in range ( 9 ) ] NEW_LINE d [ 0 ] = 1 NEW_LINE result = 0 NEW_LINE mod_sum = 0 NEW_LINE continuous_zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ord ( number [ i ] ) - ord ( '0' ) == 0 ) : NEW_LINE INDENT continuous_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continuous_zero = 0 NEW_LINE DEDENT mod_sum += ord ( number [ i ] ) - ord ( '0' ) NEW_LINE mod_sum %= 9 NEW_LINE result += d [ mod_sum ] NEW_LINE d [ mod_sum ] += 1 NEW_LINE result -= continuous_zero NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( count9s ( \"01809\" ) ) NEW_LINE print ( count9s ( \"1809\" ) ) NEW_LINE print ( count9s ( \"4189\" ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00054_A", "sol": 0, "python_code": "import sys\nfor l in sys.stdin :\n    a , b , n = map ( int , l.split ( \" \" ) )\n    print ( sum ( map ( int , list ( str ( ( a % b ) * 10 ** n // b ) ) ) ) )\n", "python_code_tokenized": "import sys NEW_LINE for l in sys . stdin : NEW_LINE INDENT a , b , n = map ( int , l . split ( \" \u2581 \" ) ) NEW_LINE print ( sum ( map ( int , list ( str ( ( a % b ) * 10 ** n // b ) ) ) ) ) NEW_LINE DEDENT"}
{"id": "codeforces_437_A", "sol": 0, "python_code": "a = [ ]\nfor i in range ( 4 ) :\n    c = input ( )\n    a.append ( ( len ( c ) - 2 , c [ 0 ] ) )\na.sort ( )\ngs = a [ 0 ] [ 0 ] * 2 <= a [ 1 ] [ 0 ]\ngl = a [ 3 ] [ 0 ] >= a [ 2 ] [ 0 ] * 2\nif ( gs and gl ) or ( not gs and not gl ) :\n    print ( \"C\" )\nelse :\n    print ( a [ 0 ] [ 1 ] if gs else a [ 3 ] [ 1 ] )\n", "python_code_tokenized": "a = [ ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT c = input ( ) NEW_LINE a . append ( ( len ( c ) - 2 , c [ 0 ] ) ) NEW_LINE DEDENT a . sort ( ) NEW_LINE gs = a [ 0 ] [ 0 ] * 2 <= a [ 1 ] [ 0 ] NEW_LINE gl = a [ 3 ] [ 0 ] >= a [ 2 ] [ 0 ] * 2 NEW_LINE if ( gs and gl ) or ( not gs and not gl ) : NEW_LINE INDENT print ( \" C \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ 0 ] [ 1 ] if gs else a [ 3 ] [ 1 ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1363_A", "sol": 0, "python_code": "import math\ndef findDigits ( n ) :\n    if ( n < 0 ) :\n        return 0 ;\n    if ( n <= 1 ) :\n        return 1 ;\n    x = ( ( n * math.log10 ( n / math.e ) + math.log10 ( 2 * math.pi * n ) / 2.0 ) ) ;\n    return math.floor ( x ) + 1 ;\nprint ( findDigits ( 1 ) ) ;\nprint ( findDigits ( 50000000 ) ) ;\nprint ( findDigits ( 1000000000 ) ) ;\nprint ( findDigits ( 120 ) ) ;\n", "python_code_tokenized": "import math NEW_LINE def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) ; NEW_LINE return math . floor ( x ) + 1 ; NEW_LINE DEDENT print ( findDigits ( 1 ) ) ; NEW_LINE print ( findDigits ( 50000000 ) ) ; NEW_LINE print ( findDigits ( 1000000000 ) ) ; NEW_LINE print ( findDigits ( 120 ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_3944_A", "sol": 0, "python_code": "def countStr ( n , bCount , cCount ) :\n    if ( bCount < 0 or cCount < 0 ) :\n        return 0\n    if ( n == 0 ) :\n        return 1\n    if ( bCount == 0 and cCount == 0 ) :\n        return 1\n    res = countStr ( n - 1 , bCount , cCount )\n    res += countStr ( n - 1 , bCount - 1 , cCount )\n    res += countStr ( n - 1 , bCount , cCount - 1 )\n    return res\nif __name__ == \"__main__\" :\n    n = 3\n    print ( countStr ( n , 1 , 2 ) )\n", "python_code_tokenized": "def countStr ( n , bCount , cCount ) : NEW_LINE INDENT if ( bCount < 0 or cCount < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( bCount == 0 and cCount == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = countStr ( n - 1 , bCount , cCount ) NEW_LINE res += countStr ( n - 1 , bCount - 1 , cCount ) NEW_LINE res += countStr ( n - 1 , bCount , cCount - 1 ) NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( countStr ( n , 1 , 2 ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00266_A", "sol": 0, "python_code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef main ( ) :\n    MOD = 10 ** 9 + 7\n    def query ( k0 ) :\n        s = 0\n        k = k0\n        while k :\n            s += data [ k ]\n            k -= k & - k\n        k = k0\n        while k <= N :\n            data [ k ] += 1\n            k += k & - k\n        return s % MOD\n    L = 100000\n    fact = [ 1 ] * ( L + 1 )\n    rfact = [ 1 ] * ( L + 1 )\n    r = 1\n    for i in range ( 2 , L + 1 ) :\n        fact [ i ] = r = i * r % MOD\n    rfact [ i ] = r = pow ( fact [ i ] , MOD - 2 , MOD )\n    for i in range ( L , 0 , - 1 ) :\n        rfact [ i - 1 ] = r = i * r % MOD\n    while 1 :\n        N = int ( readline ( ) )\n        if N == 0 :\n            break\n        R = int ( readline ( ) )\n        * S , = range ( N )\n        for i in range ( R ) :\n            s , t = map ( int , readline ( ).split ( ) ) ; s -= 1 ; t -= 1\n            S [ s ] , S [ t ] = S [ t ] , S [ s ]\n        data = [ 0 ] * ( N + 1 )\n        write ( \"%d\\n\" % ( sum ( fact [ N - 1 - i ] * ( e - query ( e + 1 ) ) % MOD for i , e in enumerate ( S ) ) % MOD ) )\nmain ( )\n", "python_code_tokenized": "import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def main ( ) : NEW_LINE INDENT MOD = 10 ** 9 + 7 NEW_LINE def query ( k0 ) : NEW_LINE INDENT s = 0 NEW_LINE k = k0 NEW_LINE while k : NEW_LINE INDENT s += data [ k ] NEW_LINE k -= k & - k NEW_LINE DEDENT k = k0 NEW_LINE while k <= N : NEW_LINE INDENT data [ k ] += 1 NEW_LINE k += k & - k NEW_LINE DEDENT return s % MOD NEW_LINE DEDENT L = 100000 NEW_LINE fact = [ 1 ] * ( L + 1 ) NEW_LINE rfact = [ 1 ] * ( L + 1 ) NEW_LINE r = 1 NEW_LINE for i in range ( 2 , L + 1 ) : NEW_LINE INDENT fact [ i ] = r = i * r % MOD NEW_LINE DEDENT rfact [ i ] = r = pow ( fact [ i ] , MOD - 2 , MOD ) NEW_LINE for i in range ( L , 0 , - 1 ) : NEW_LINE INDENT rfact [ i - 1 ] = r = i * r % MOD NEW_LINE DEDENT while 1 : NEW_LINE INDENT N = int ( readline ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT R = int ( readline ( ) ) NEW_LINE * S , = range ( N ) NEW_LINE for i in range ( R ) : NEW_LINE INDENT s , t = map ( int , readline ( ) . split ( ) ) ; s -= 1 ; t -= 1 NEW_LINE S [ s ] , S [ t ] = S [ t ] , S [ s ] NEW_LINE DEDENT data = [ 0 ] * ( N + 1 ) NEW_LINE write ( \" % d \\n \" % ( sum ( fact [ N - 1 - i ] * ( e - query ( e + 1 ) ) % MOD for i , e in enumerate ( S ) ) % MOD ) ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "codeforces_1592_A", "sol": 0, "python_code": "import sys\nR = lambda : map ( int , next ( sys.stdin ).split ( ) )\nt , = R ( )\nwhile t :\n    t -= 1 ;\n    n , h = R ( ) ;\n    * _ , x , y = sorted ( R ( ) ) ;\n    x += y ;\n    print ( h // x * 2 + ( h % x > 0 ) + ( h % x > y ) )\n", "python_code_tokenized": "import sys NEW_LINE R = lambda : map ( int , next ( sys . stdin ) . split ( ) ) NEW_LINE t , = R ( ) NEW_LINE while t : NEW_LINE INDENT t -= 1 ; NEW_LINE n , h = R ( ) ; NEW_LINE * _ , x , y = sorted ( R ( ) ) ; NEW_LINE x += y ; NEW_LINE print ( h // x * 2 + ( h % x > 0 ) + ( h % x > y ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_952_A", "sol": 0, "python_code": "def sameOccurrence ( arr , n , x , y ) :\n    countX = [ 0 for i in range ( n ) ]\n    countY = [ 0 for i in range ( n ) ]\n    m = dict ( )\n    for i in range ( n ) :\n        if ( arr [ i ] == x ) :\n            if ( i != 0 ) :\n                countX [ i ] = countX [ i - 1 ] + 1\n            else :\n                countX [ i ] = 1\n        else :\n            if ( i != 0 ) :\n                countX [ i ] = countX [ i - 1 ]\n            else :\n                countX [ i ] = 0\n        if ( arr [ i ] == y ) :\n            if ( i != 0 ) :\n                countY [ i ] = countY [ i - 1 ] + 1\n            else :\n                countY [ i ] = 1\n        else :\n            if ( i != 0 ) :\n                countY [ i ] = countY [ i - 1 ]\n            else :\n                countY [ i ] = 0\n        m [ countX [ i ] - countY [ i ] ] = m.get ( countX [ i ] - countY [ i ] , 0 ) + 1\n    result = m [ 0 ]\n    for j in m :\n        result += ( m [ j ] * ( m [ j ] - 1 ) ) // 2\n    return result\narr = [ 1 , 2 , 2 , 3 , 4 , 1 ]\nn = len ( arr )\nx , y = 2 , 3\nprint ( sameOccurrence ( arr , n , x , y ) )\n", "python_code_tokenized": "def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT countX = [ 0 for i in range ( n ) ] NEW_LINE countY = [ 0 for i in range ( n ) ] NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countX [ i ] = countX [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT countX [ i ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countX [ i ] = countX [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT countX [ i ] = 0 NEW_LINE DEDENT DEDENT if ( arr [ i ] == y ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT countY [ i ] = countY [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT countY [ i ] = 0 NEW_LINE DEDENT DEDENT m [ countX [ i ] - countY [ i ] ] = m . get ( countX [ i ] - countY [ i ] , 0 ) + 1 NEW_LINE DEDENT result = m [ 0 ] NEW_LINE for j in m : NEW_LINE INDENT result += ( m [ j ] * ( m [ j ] - 1 ) ) // 2 NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE x , y = 2 , 3 NEW_LINE print ( sameOccurrence ( arr , n , x , y ) ) NEW_LINE"}
{"id": "codeforces_489_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nb = [ ]\ncounter = { }\npositions = { }\nfor i , x in enumerate ( a ) :\n    if x not in counter :\n        counter [ x ] = 0\n    counter [ x ] += 1\n    b.append ( ( x , counter [ x ] ) )\n    positions [ ( x , counter [ x ] ) ] = i\na = sorted ( b )\nresult = [ ]\nfor i , x in enumerate ( a ) :\n    pos = positions [ x ]\n    if pos != i :\n        tmp = b [ i ]\n        b [ pos ] , b [ i ] = b [ i ] , b [ pos ]\n        result.append ( ( i , positions [ x ] ) )\n        positions [ x ] , positions [ tmp ] = positions [ tmp ] , positions [ x ]\nprint ( len ( result ) )\nfor i , j in result :\n    print ( i , j )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE counter = { } NEW_LINE positions = { } NEW_LINE for i , x in enumerate ( a ) : NEW_LINE INDENT if x not in counter : NEW_LINE INDENT counter [ x ] = 0 NEW_LINE DEDENT counter [ x ] += 1 NEW_LINE b . append ( ( x , counter [ x ] ) ) NEW_LINE positions [ ( x , counter [ x ] ) ] = i NEW_LINE DEDENT a = sorted ( b ) NEW_LINE result = [ ] NEW_LINE for i , x in enumerate ( a ) : NEW_LINE INDENT pos = positions [ x ] NEW_LINE if pos != i : NEW_LINE INDENT tmp = b [ i ] NEW_LINE b [ pos ] , b [ i ] = b [ i ] , b [ pos ] NEW_LINE result . append ( ( i , positions [ x ] ) ) NEW_LINE positions [ x ] , positions [ tmp ] = positions [ tmp ] , positions [ x ] NEW_LINE DEDENT DEDENT print ( len ( result ) ) NEW_LINE for i , j in result : NEW_LINE INDENT print ( i , j ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC119_C", "sol": 0, "python_code": "N , A , B , C = map ( int , input ( ).split ( ) )\nl = list ( int ( input ( ) ) for i in range ( N ) )\nans = float ( 'inf' )\ndef dfs ( x , a , b , c ) :\n    if x == N :\n        return ( abs ( a - A ) + abs ( b - B ) + abs ( c - C ) - 30 ) if min ( a , b , c ) > 0 else float ( 'inf' )\n    ret0 = dfs ( x + 1 , a , b , c )\n    ret1 = dfs ( x + 1 , a + l [ x ] , b , c ) + 10\n    ret2 = dfs ( x + 1 , a , b + l [ x ] , c ) + 10\n    ret3 = dfs ( x + 1 , a , b , c + l [ x ] ) + 10\n    return min ( ret0 , ret1 , ret2 , ret3 )\nprint ( dfs ( 0 , 0 , 0 , 0 ) )\n", "python_code_tokenized": "N , A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( int ( input ( ) ) for i in range ( N ) ) NEW_LINE ans = float ( ' inf ' ) NEW_LINE def dfs ( x , a , b , c ) : NEW_LINE INDENT if x == N : NEW_LINE INDENT return ( abs ( a - A ) + abs ( b - B ) + abs ( c - C ) - 30 ) if min ( a , b , c ) > 0 else float ( ' inf ' ) NEW_LINE DEDENT ret0 = dfs ( x + 1 , a , b , c ) NEW_LINE ret1 = dfs ( x + 1 , a + l [ x ] , b , c ) + 10 NEW_LINE ret2 = dfs ( x + 1 , a , b + l [ x ] , c ) + 10 NEW_LINE ret3 = dfs ( x + 1 , a , b , c + l [ x ] ) + 10 NEW_LINE return min ( ret0 , ret1 , ret2 , ret3 ) NEW_LINE DEDENT print ( dfs ( 0 , 0 , 0 , 0 ) ) NEW_LINE"}
{"id": "geeksforgeeks_5176_A", "sol": 0, "python_code": "from math import sqrt\nMAX = 100000\nprime = [ True ] * MAX\ndef sieve ( ) :\n    for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) :\n        if prime [ p ] == True :\n            for i in range ( p * 2 , MAX , p ) :\n                prime [ i ] = False\ndef printPrimeQuad ( n ) :\n    for i in range ( n - 7 ) :\n        if ( prime [ i ] and prime [ i + 2 ] and prime [ i + 6 ] and prime [ i + 8 ] ) :\n            print ( i , i + 2 , i + 6 , i + 8 )\nif __name__ == \"__main__\" :\n    sieve ( )\n    n = 20\n    printPrimeQuad ( 20 )\n", "python_code_tokenized": "from math import sqrt NEW_LINE MAX = 100000 NEW_LINE prime = [ True ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printPrimeQuad ( n ) : NEW_LINE INDENT for i in range ( n - 7 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i + 2 ] and prime [ i + 6 ] and prime [ i + 8 ] ) : NEW_LINE INDENT print ( i , i + 2 , i + 6 , i + 8 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sieve ( ) NEW_LINE n = 20 NEW_LINE printPrimeQuad ( 20 ) NEW_LINE DEDENT"}
{"id": "codeforces_1689_A", "sol": 0, "python_code": "t = int ( input ( ) )\nwhile t > 0 :\n    n , m , k = list ( map ( int , input ( ).split ( \"\" ) ) )\n    a = input ( )\n    b = input ( )\n    a = sorted ( a )\n    b = sorted ( b )\n    ak = 0\n    bk = 0\n    c = \"\"\n    i , j = 0 , 0\n    while i < n and j < m :\n        gde = b [ j ] < a [ i ]\n        if gde and bk == k :\n            gde = False\n        if not gde and ak == k :\n            gde = True\n        if gde :\n            c = c + b [ j ]\n            bk += 1\n            ak = 0\n            j += 1\n        else :\n            c = c + a [ i ]\n            ak += 1\n            bk = 0\n            i += 1\n    print ( c )\n    t -= 1\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT n , m , k = list ( map ( int , input ( ) . split ( \" \u2581 \" ) ) ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE a = sorted ( a ) NEW_LINE b = sorted ( b ) NEW_LINE ak = 0 NEW_LINE bk = 0 NEW_LINE c = \" \" NEW_LINE i , j = 0 , 0 NEW_LINE while i < n and j < m : NEW_LINE INDENT gde = b [ j ] < a [ i ] NEW_LINE if gde and bk == k : NEW_LINE INDENT gde = False NEW_LINE DEDENT if not gde and ak == k : NEW_LINE INDENT gde = True NEW_LINE DEDENT if gde : NEW_LINE INDENT c = c + b [ j ] NEW_LINE bk += 1 NEW_LINE ak = 0 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c = c + a [ i ] NEW_LINE ak += 1 NEW_LINE bk = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE t -= 1 NEW_LINE DEDENT"}
{"id": "aizu_p00367_A", "sol": 0, "python_code": "n = int ( input ( ) )\nlst = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( n ) ]\na_start = [ x [ 0 ] * 60 + x [ 1 ] for x in lst ]\na_end = [ x [ 2 ] * 60 + x [ 3 ] for x in lst ]\nh_start = [ x [ 4 ] * 60 + x [ 5 ] for x in lst ]\nh_end = [ x [ 6 ] * 60 + x [ 7 ] for x in lst ]\nb_start = [ x [ 8 ] * 60 + x [ 9 ] for x in lst ]\nb_end = [ x [ 10 ] * 60 + x [ 11 ] for x in lst ]\ndef make_sets ( start , end ) :\n    sets = [ ]\n    member = [ ]\n    for i in range ( 1440 ) :\n        upd = False\n        for j in range ( n ) :\n            if start [ j ] == i :\n                member.append ( j )\n                upd = True\n            if end [ j ] == i - 1 :\n                member.remove ( j )\n                upd = True\n        if upd :\n            sets.append ( set ( member ) )\n    return sets\na_sets = make_sets ( a_start , a_end )\nh_sets = make_sets ( h_start , h_end )\nb_sets = make_sets ( b_start , b_end )\nans = 0\nfor s1 in a_sets :\n    for s2 in h_sets :\n        for s3 in b_sets :\n            ans = max ( ans , len ( s1 & s2 & s3 ) )\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE lst = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE a_start = [ x [ 0 ] * 60 + x [ 1 ] for x in lst ] NEW_LINE a_end = [ x [ 2 ] * 60 + x [ 3 ] for x in lst ] NEW_LINE h_start = [ x [ 4 ] * 60 + x [ 5 ] for x in lst ] NEW_LINE h_end = [ x [ 6 ] * 60 + x [ 7 ] for x in lst ] NEW_LINE b_start = [ x [ 8 ] * 60 + x [ 9 ] for x in lst ] NEW_LINE b_end = [ x [ 10 ] * 60 + x [ 11 ] for x in lst ] NEW_LINE def make_sets ( start , end ) : NEW_LINE INDENT sets = [ ] NEW_LINE member = [ ] NEW_LINE for i in range ( 1440 ) : NEW_LINE INDENT upd = False NEW_LINE for j in range ( n ) : NEW_LINE INDENT if start [ j ] == i : NEW_LINE INDENT member . append ( j ) NEW_LINE upd = True NEW_LINE DEDENT if end [ j ] == i - 1 : NEW_LINE INDENT member . remove ( j ) NEW_LINE upd = True NEW_LINE DEDENT DEDENT if upd : NEW_LINE INDENT sets . append ( set ( member ) ) NEW_LINE DEDENT DEDENT return sets NEW_LINE DEDENT a_sets = make_sets ( a_start , a_end ) NEW_LINE h_sets = make_sets ( h_start , h_end ) NEW_LINE b_sets = make_sets ( b_start , b_end ) NEW_LINE ans = 0 NEW_LINE for s1 in a_sets : NEW_LINE INDENT for s2 in h_sets : NEW_LINE INDENT for s3 in b_sets : NEW_LINE INDENT ans = max ( ans , len ( s1 & s2 & s3 ) ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_4281_A", "sol": 0, "python_code": "from math import gcd\ndef maxProfit ( n , a , b , x , y ) :\n    res = x * ( n // a ) ;\n    res += y * ( n // b ) ;\n    res -= min ( x , y ) * ( n // ( ( a * b ) // gcd ( a , b ) ) ) ;\n    return res ;\nif __name__ == \"__main__\" :\n    n = 6 ; a = 6 ; b = 2 ; x = 8 ; y = 2 ;\n    print ( maxProfit ( n , a , b , x , y ) ) ;\n", "python_code_tokenized": "from math import gcd NEW_LINE def maxProfit ( n , a , b , x , y ) : NEW_LINE INDENT res = x * ( n // a ) ; NEW_LINE res += y * ( n // b ) ; NEW_LINE res -= min ( x , y ) * ( n // ( ( a * b ) // gcd ( a , b ) ) ) ; NEW_LINE return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; a = 6 ; b = 2 ; x = 8 ; y = 2 ; NEW_LINE print ( maxProfit ( n , a , b , x , y ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2421_A", "sol": 0, "python_code": "def nthTerm ( n ) :\n    return ( N * N * N ) + ( N * N ) + N\nif __name__ == \"__main__\" :\n    N = 3\n    print ( nthTerm ( N ) )\n", "python_code_tokenized": "def nthTerm ( n ) : NEW_LINE INDENT return ( N * N * N ) + ( N * N ) + N NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1832_A", "sol": 0, "python_code": "def nthTerm ( N ) :\n    return ( N * ( ( N // 2 ) + ( ( N % 2 ) * 2 ) + N ) )\nif __name__ == '__main__' :\n    N = 5\n    print ( \"Nth term for N = \" , N , \" : \" , nthTerm ( N ) )\n", "python_code_tokenized": "def nthTerm ( N ) : NEW_LINE INDENT return ( N * ( ( N // 2 ) + ( ( N % 2 ) * 2 ) + N ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE print ( \" Nth \u2581 term \u2581 for \u2581 N \u2581 = \u2581 \" , N , \" \u2581 : \u2581 \" , nthTerm ( N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1831_A", "sol": 0, "python_code": "def nthTerm ( N ) :\n    return ( N * ( ( N % 2 ) + ( N % 3 ) ) )\nif __name__ == '__main__' :\n    N = 5\n    print ( \"Nth term for N = \" , N , \" : \" , nthTerm ( N ) )\n", "python_code_tokenized": "def nthTerm ( N ) : NEW_LINE INDENT return ( N * ( ( N % 2 ) + ( N % 3 ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE print ( \" Nth \u2581 term \u2581 for \u2581 N \u2581 = \u2581 \" , N , \" \u2581 : \u2581 \" , nthTerm ( N ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02527_A", "sol": 0, "python_code": "n = int ( input ( ) )\nnumbers = list ( map ( int , input ( ).split ( ) ) )\nnumbers.sort ( )\nprint ( ' '.join ( map ( str , numbers ) ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE numbers = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE numbers . sort ( ) NEW_LINE print ( ' \u2581 ' . join ( map ( str , numbers ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_2058_A", "sol": 0, "python_code": "def calculateLeaps ( n ) :\n    if n == 0 or n == 1 :\n        return 1 ;\n    else :\n        leaps = 0 ;\n        for i in range ( 0 , n ) :\n            leaps = leaps + calculateLeaps ( i ) ;\n        return leaps ;\nprint ( calculateLeaps ( 4 ) ) ;\n", "python_code_tokenized": "def calculateLeaps ( n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT leaps = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT leaps = leaps + calculateLeaps ( i ) ; NEW_LINE DEDENT return leaps ; NEW_LINE DEDENT DEDENT print ( calculateLeaps ( 4 ) ) ; NEW_LINE"}
{"id": "codeforces_320_A", "sol": 0, "python_code": "n = input ( )\nk = len ( n )\ni = 0\nwhile True :\n    if i <= ( k - 3 ) and n [ i ] == \"1\" and n [ i + 1 ] == \"4\" and n [ i + 2 ] == \"4\" :\n        i += 3\n    elif i <= ( k - 2 ) and n [ i ] == \"1\" and n [ i + 1 ] == \"4\" :\n        i += 2\n    elif i <= ( k - 1 ) and n [ i ] == \"1\" :\n        i += 1\n    elif i > ( k - 1 ) :\n        break\n    else :\n        i = 2 * k\n        break\nif i == 2 * k :\n    print ( \"NO\" )\nelse :\n    print ( \"YES\" )\n", "python_code_tokenized": "n = input ( ) NEW_LINE k = len ( n ) NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT if i <= ( k - 3 ) and n [ i ] == \"1\" and n [ i + 1 ] == \"4\" and n [ i + 2 ] == \"4\" : NEW_LINE INDENT i += 3 NEW_LINE DEDENT elif i <= ( k - 2 ) and n [ i ] == \"1\" and n [ i + 1 ] == \"4\" : NEW_LINE INDENT i += 2 NEW_LINE DEDENT elif i <= ( k - 1 ) and n [ i ] == \"1\" : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif i > ( k - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT i = 2 * k NEW_LINE break NEW_LINE DEDENT DEDENT if i == 2 * k : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2965_A", "sol": 0, "python_code": "def greaterK ( n , k ) :\n    index = 0\n    p = [ 0 for i in range ( n + 2 ) ]\n    x = n\n    while ( x > 0 ) :\n        p [ index ] = x % k\n        x //= k\n        index += 1\n    idx = 0\n    for i in range ( 0 , len ( p ) - 1 , 1 ) :\n        if ( p [ i ] >= 2 ) :\n            p [ i ] = 0\n            p [ i + 1 ] += 1\n            for j in range ( idx , i , 1 ) :\n                p [ j ] = 0\n            idx = i + 1\n        if ( p [ i ] == k ) :\n            p [ i ] = 0\n            p [ i + 1 ] += 1\n    j = len ( p ) - 1\n    if ( p [ j ] >= 2 ) :\n        p [ index ] = 1\n        index += 1\n    ans = 0\n    i = len ( p ) - 1\n    while ( i >= 0 ) :\n        ans = ans * k + p [ i ]\n        i -= 1\n    print ( ans )\nif __name__ == '__main__' :\n    n = 29\n    k = 7\n    greaterK ( n , k )\n", "python_code_tokenized": "def greaterK ( n , k ) : NEW_LINE INDENT index = 0 NEW_LINE p = [ 0 for i in range ( n + 2 ) ] NEW_LINE x = n NEW_LINE while ( x > 0 ) : NEW_LINE INDENT p [ index ] = x % k NEW_LINE x //= k NEW_LINE index += 1 NEW_LINE DEDENT idx = 0 NEW_LINE for i in range ( 0 , len ( p ) - 1 , 1 ) : NEW_LINE INDENT if ( p [ i ] >= 2 ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE p [ i + 1 ] += 1 NEW_LINE for j in range ( idx , i , 1 ) : NEW_LINE INDENT p [ j ] = 0 NEW_LINE DEDENT idx = i + 1 NEW_LINE DEDENT if ( p [ i ] == k ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE p [ i + 1 ] += 1 NEW_LINE DEDENT DEDENT j = len ( p ) - 1 NEW_LINE if ( p [ j ] >= 2 ) : NEW_LINE INDENT p [ index ] = 1 NEW_LINE index += 1 NEW_LINE DEDENT ans = 0 NEW_LINE i = len ( p ) - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT ans = ans * k + p [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 29 NEW_LINE k = 7 NEW_LINE greaterK ( n , k ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2000_A", "sol": 0, "python_code": "def reverse ( x ) :\n    rev = 0 ;\n    while ( x > 0 ) :\n        rev = ( rev * 10 ) + x % 10 ;\n        x = int ( x / 10 ) ;\n    return rev ;\ndef printEmirp ( n ) :\n    prime = [ 1 ] * ( n + 1 ) ;\n    p = 2 ;\n    while ( p * p <= n ) :\n        if ( prime [ p ] == 1 ) :\n            for i in range ( p * 2 , n + 1 , p ) :\n                prime [ i ] = 0 ;\n        p += 1 ;\n    for p in range ( 2 , n + 1 ) :\n        if ( prime [ p ] == 1 ) :\n            rev = reverse ( p ) ;\n            if ( p != rev and rev <= n and prime [ rev ] == 1 ) :\n                print ( p , rev , end = \" \" ) ;\n                prime [ rev ] = 0 ;\nn = 100 ;\nprintEmirp ( n ) ;\n", "python_code_tokenized": "def reverse ( x ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + x % 10 ; NEW_LINE x = int ( x / 10 ) ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def printEmirp ( n ) : NEW_LINE INDENT prime = [ 1 ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = 0 ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT rev = reverse ( p ) ; NEW_LINE if ( p != rev and rev <= n and prime [ rev ] == 1 ) : NEW_LINE INDENT print ( p , rev , end = \" \u2581 \" ) ; NEW_LINE prime [ rev ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT n = 100 ; NEW_LINE printEmirp ( n ) ; NEW_LINE"}
{"id": "geeksforgeeks_4971_A", "sol": 0, "python_code": "def checkDuplicatesWithinK ( arr , n , k ) :\n    myset = [ ]\n    for i in range ( n ) :\n        if arr [ i ] in myset :\n            return True\n        myset.append ( arr [ i ] )\n        if ( i >= k ) :\n            myset.remove ( arr [ i - k ] )\n    return False\nif __name__ == \"__main__\" :\n    arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ]\n    n = len ( arr )\n    if ( checkDuplicatesWithinK ( arr , n , 3 ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def checkDuplicatesWithinK ( arr , n , k ) : NEW_LINE INDENT myset = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in myset : NEW_LINE INDENT return True NEW_LINE DEDENT myset . append ( arr [ i ] ) NEW_LINE if ( i >= k ) : NEW_LINE INDENT myset . remove ( arr [ i - k ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkDuplicatesWithinK ( arr , n , 3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_922_A", "sol": 0, "python_code": "import math as mt\ndef primeProduct ( arr , n ) :\n    max_val = max ( arr )\n    prime = [ True for i in range ( max_val + 1 ) ]\n    prime [ 0 ] = False\n    prime [ 1 ] = False\n    for p in range ( mt.ceil ( mt.sqrt ( max_val ) ) ) :\n        if prime [ p ] :\n            for i in range ( p * 2 , max_val + 1 , p ) :\n                prime [ i ] = False\n    prod = 1\n    for i in range ( n ) :\n        if prime [ arr [ i ] ] :\n            prod *= arr [ i ]\n    return prod\narr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ]\nn = len ( arr )\nprint ( primeProduct ( arr , n ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def primeProduct ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( mt . ceil ( mt . sqrt ( max_val ) ) ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( primeProduct ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_474_A", "sol": 0, "python_code": "def printKPFNums ( A , B , K ) :\n    prime = [ True ] * ( B + 1 )\n    p_factors = [ 0 ] * ( B + 1 )\n    for p in range ( 2 , B + 1 ) :\n        if ( p_factors [ p ] == 0 ) :\n            for i in range ( p , B + 1 , p ) :\n                p_factors [ i ] = p_factors [ i ] + 1\n    for i in range ( A , B + 1 ) :\n        if ( p_factors [ i ] == K ) :\n            print ( i , end = \" \" )\nA = 14\nB = 18\nK = 2\nprintKPFNums ( A , B , K )\n", "python_code_tokenized": "def printKPFNums ( A , B , K ) : NEW_LINE INDENT prime = [ True ] * ( B + 1 ) NEW_LINE p_factors = [ 0 ] * ( B + 1 ) NEW_LINE for p in range ( 2 , B + 1 ) : NEW_LINE INDENT if ( p_factors [ p ] == 0 ) : NEW_LINE INDENT for i in range ( p , B + 1 , p ) : NEW_LINE INDENT p_factors [ i ] = p_factors [ i ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( p_factors [ i ] == K ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT A = 14 NEW_LINE B = 18 NEW_LINE K = 2 NEW_LINE printKPFNums ( A , B , K ) NEW_LINE"}
{"id": "geeksforgeeks_1186_A", "sol": 0, "python_code": "def minCost ( n , arr , cost ) :\n    Sum , totalCost = 0 , 0\n    for i in range ( 0 , n - 1 ) :\n        Sum += arr [ i ]\n    totalCost += cost * Sum\n    arr [ n - 1 ] += Sum\n    totalCost += ( 2 * cost * arr [ n - 1 ] )\n    return totalCost\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 4 , 5 ]\n    n = len ( arr )\n    cost = 1\n    print ( minCost ( n , arr , cost ) )\n", "python_code_tokenized": "def minCost ( n , arr , cost ) : NEW_LINE INDENT Sum , totalCost = 0 , 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT totalCost += cost * Sum NEW_LINE arr [ n - 1 ] += Sum NEW_LINE totalCost += ( 2 * cost * arr [ n - 1 ] ) NEW_LINE return totalCost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE cost = 1 NEW_LINE print ( minCost ( n , arr , cost ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC099_C", "sol": 0, "python_code": "N = int ( input ( ) )\ndef f ( n ) :\n    L = [ 1 ]\n    c = 1\n    while 6 ** c <= n :\n        L.append ( 6 ** c )\n        c += 1\n    c = 1\n    while 9 ** c <= n :\n        L.append ( 9 ** c )\n        c += 1\n    return L\ndp = [ 0 for i in range ( N + 1 ) ]\ndp [ 1 ] = 1\nfor i in range ( N ) :\n    L = f ( i + 1 )\n    temp = dp [ i + 1 - L [ 0 ] ]\n    for j in range ( len ( L ) ) :\n        if temp > dp [ i + 1 - L [ j ] ] :\n            temp = dp [ i + 1 - L [ j ] ]\n    dp [ i + 1 ] = temp + 1\nprint ( dp [ N ] )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE def f ( n ) : NEW_LINE INDENT L = [ 1 ] NEW_LINE c = 1 NEW_LINE while 6 ** c <= n : NEW_LINE INDENT L . append ( 6 ** c ) NEW_LINE c += 1 NEW_LINE DEDENT c = 1 NEW_LINE while 9 ** c <= n : NEW_LINE INDENT L . append ( 9 ** c ) NEW_LINE c += 1 NEW_LINE DEDENT return L NEW_LINE DEDENT dp = [ 0 for i in range ( N + 1 ) ] NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT L = f ( i + 1 ) NEW_LINE temp = dp [ i + 1 - L [ 0 ] ] NEW_LINE for j in range ( len ( L ) ) : NEW_LINE INDENT if temp > dp [ i + 1 - L [ j ] ] : NEW_LINE INDENT temp = dp [ i + 1 - L [ j ] ] NEW_LINE DEDENT DEDENT dp [ i + 1 ] = temp + 1 NEW_LINE DEDENT print ( dp [ N ] ) NEW_LINE"}
{"id": "geeksforgeeks_3629_A", "sol": 0, "python_code": "def isprime ( x ) :\n    for i in range ( 2 , math.sqrt ( x ) ) :\n        if ( x % i == 0 ) :\n            return False ;\n    return True ;\ndef isNSqMinusnMSqPrime ( m , n ) :\n    if ( n - m == 1 and isprime ( m + n ) ) :\n        return True ;\n    else :\n        return False ;\nm = 13 ;\nn = 16 ;\nif ( isNSqMinusnMSqPrime ( m , n ) ) :\n    print ( \"YES\" ) ;\nelse :\n    print ( \"NO\" ) ;\n", "python_code_tokenized": "def isprime ( x ) : NEW_LINE INDENT for i in range ( 2 , math . sqrt ( x ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def isNSqMinusnMSqPrime ( m , n ) : NEW_LINE INDENT if ( n - m == 1 and isprime ( m + n ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT m = 13 ; NEW_LINE n = 16 ; NEW_LINE if ( isNSqMinusnMSqPrime ( m , n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"}
{"id": "aizu_p00543_A", "sol": 0, "python_code": "n , m = [ int ( s ) for s in input ( ).split ( \" \" ) ]\nbibs = [ int ( input ( ) ) for i in range ( n ) ]\nfor k in range ( 1 , m + 1 ) :\n    for i in range ( n - 1 ) :\n        if bibs [ i ] % k > bibs [ i + 1 ] % k : ( bibs [ i ] , bibs [ i + 1 ] ) = ( bibs [ i + 1 ] , bibs [ i ] )\nfor bib in bibs : print ( bib )\n", "python_code_tokenized": "n , m = [ int ( s ) for s in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE bibs = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE for k in range ( 1 , m + 1 ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if bibs [ i ] % k > bibs [ i + 1 ] % k : ( bibs [ i ] , bibs [ i + 1 ] ) = ( bibs [ i + 1 ] , bibs [ i ] ) NEW_LINE DEDENT DEDENT for bib in bibs : print ( bib ) NEW_LINE"}
{"id": "geeksforgeeks_4393_A", "sol": 0, "python_code": "def q1 ( s , i ) :\n    if ( i == len ( s ) ) :\n        print ( \"Yes\" ) ;\n        return ;\n    if ( s [ i ] == 'a' ) :\n        q1 ( s , i + 1 ) ;\n    else :\n        q2 ( s , i + 1 ) ;\ndef q2 ( s , i ) :\n    if ( i == len ( s ) ) :\n        print ( \"No\" ) ;\n        return ;\n    if ( s [ i ] == 'a' ) :\n        q1 ( s , i + 1 ) ;\n    else :\n        q2 ( s , i + 1 ) ;\ndef q3 ( s , i ) :\n    if ( i == len ( s ) ) :\n        print ( \"Yes\" ) ;\n        return ;\n    if ( s [ i ] == 'a' ) :\n        q4 ( s , i + 1 ) ;\n    else :\n        q3 ( s , i + 1 ) ;\ndef q4 ( s , i ) :\n    if ( i == s.length ( ) ) :\n        print ( \"No\" ) ;\n        return ;\n    if ( s [ i ] == 'a' ) :\n        q4 ( s , i + 1 ) ;\n    else :\n        q3 ( s , i + 1 ) ;\ndef q0 ( s , i ) :\n    if ( i == len ( s ) ) :\n        print ( \"No\" ) ;\n        return ;\n    if ( s [ i ] == 'a' ) :\n        q1 ( s , i + 1 ) ;\n    else :\n        q3 ( s , i + 1 ) ;\nif __name__ == '__main__' :\n    s = \"abbaabb\" ;\n    q0 ( s , 0 ) ;\n", "python_code_tokenized": "def q1 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q2 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q3 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q4 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q4 ( s , i ) : NEW_LINE INDENT if ( i == s . length ( ) ) : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q4 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q0 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" abbaabb \" ; NEW_LINE q0 ( s , 0 ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_415_A", "sol": 0, "python_code": "def fact ( n ) :\n    res = 1\n    for i in range ( 2 , n + 1 ) :\n        res = res * i\n    return res\ndef nCr ( n , r ) :\n    return fact ( n ) // ( fact ( r ) * fact ( n - r ) )\ndef number_of_subsequences ( arr , k , n ) :\n    s = 0\n    m = dict ( )\n    for i in arr :\n        m [ i ] = m.get ( i , 0 ) + 1\n    for j in m :\n        s = s + nCr ( m [ j ] , k )\n    return s\narr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 ]\nk = 2\nn = len ( arr )\nprint ( number_of_subsequences ( arr , k , n ) )\n", "python_code_tokenized": "def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) // ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT def number_of_subsequences ( arr , k , n ) : NEW_LINE INDENT s = 0 NEW_LINE m = dict ( ) NEW_LINE for i in arr : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT for j in m : NEW_LINE INDENT s = s + nCr ( m [ j ] , k ) NEW_LINE DEDENT return s NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( number_of_subsequences ( arr , k , n ) ) NEW_LINE"}
{"id": "atcoder_ABC080_B", "sol": 0, "python_code": "def main ( ) :\n    N = input ( )\n    total = 0\n    for i in range ( len ( N ) ) :\n        total += int ( N [ i ] )\n    N = int ( N )\n    if N % total == 0 :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\nmain ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT N = input ( ) NEW_LINE total = 0 NEW_LINE for i in range ( len ( N ) ) : NEW_LINE INDENT total += int ( N [ i ] ) NEW_LINE DEDENT N = int ( N ) NEW_LINE if N % total == 0 : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_4021_A", "sol": 0, "python_code": "def isValid ( string , length ) :\n    for i in range ( 1 , length ) :\n        if string [ i ] == string [ i - 1 ] :\n            return False\n    return True\nif __name__ == \"__main__\" :\n    string = \"0110\"\n    length = len ( string )\n    if isValid ( string , length ) :\n        print ( \"Valid\" )\n    else :\n        print ( \"Invalid\" )\n", "python_code_tokenized": "def isValid ( string , length ) : NEW_LINE INDENT for i in range ( 1 , length ) : NEW_LINE INDENT if string [ i ] == string [ i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"0110\" NEW_LINE length = len ( string ) NEW_LINE if isValid ( string , length ) : NEW_LINE INDENT print ( \" Valid \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1205_A", "sol": 0, "python_code": "def solve ( ) :\n    n = int ( input ( ) )\n    sum = 2 * n * ( 2 * n + 1 ) // 2\n    if ( sum % 2 == 0 ) :\n        print ( \"NO\" )\n        return\n    a = [ ]\n    b = [ ]\n    x = 2 * n\n    y = 2 * n - 1\n    cnt = 1\n    while ( cnt <= n ) :\n        if ( cnt % 2 != 0 ) :\n            a.append ( x )\n            b.append ( y )\n        else :\n            a.append ( y )\n            b.append ( x )\n        cnt += 1\n        x -= 2\n        y -= 2\n    print ( \"YES\" )\n    for item in a :\n        print ( item , end = \" \" )\n    for item in b :\n        print ( item , end = \" \" )\n    print ( )\ntest = 1\nfor t in range ( 0 , test ) :\n    solve ( )\n", "python_code_tokenized": "def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE sum = 2 * n * ( 2 * n + 1 ) // 2 NEW_LINE if ( sum % 2 == 0 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return NEW_LINE DEDENT a = [ ] NEW_LINE b = [ ] NEW_LINE x = 2 * n NEW_LINE y = 2 * n - 1 NEW_LINE cnt = 1 NEW_LINE while ( cnt <= n ) : NEW_LINE INDENT if ( cnt % 2 != 0 ) : NEW_LINE INDENT a . append ( x ) NEW_LINE b . append ( y ) NEW_LINE DEDENT else : NEW_LINE INDENT a . append ( y ) NEW_LINE b . append ( x ) NEW_LINE DEDENT cnt += 1 NEW_LINE x -= 2 NEW_LINE y -= 2 NEW_LINE DEDENT print ( \" YES \" ) NEW_LINE for item in a : NEW_LINE INDENT print ( item , end = \" \u2581 \" ) NEW_LINE DEDENT for item in b : NEW_LINE INDENT print ( item , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT test = 1 NEW_LINE for t in range ( 0 , test ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_387_A", "sol": 0, "python_code": "def cmp ( a , b ) :\n    return ( a > b ) - ( a < b )\ndef maxSubarraySize ( arr ) :\n    N = len ( arr )\n    ans = 1\n    anchor = 0\n    for i in range ( 1 , N ) :\n        c = cmp ( arr [ i - 1 ] , arr [ i ] )\n        if c == 0 :\n            anchor = i\n        elif i == N - 1 or c * cmp ( arr [ i ] , arr [ i + 1 ] ) != - 1 :\n            ans = max ( ans , i - anchor + 1 )\n            anchor = i\n    return ans\narr = [ 9 , 4 , 2 , 10 , 7 , 8 , 8 , 1 , 9 ]\nprint ( maxSubarraySize ( arr ) )\n", "python_code_tokenized": "def cmp ( a , b ) : NEW_LINE INDENT return ( a > b ) - ( a < b ) NEW_LINE DEDENT def maxSubarraySize ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE ans = 1 NEW_LINE anchor = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT c = cmp ( arr [ i - 1 ] , arr [ i ] ) NEW_LINE if c == 0 : NEW_LINE INDENT anchor = i NEW_LINE DEDENT elif i == N - 1 or c * cmp ( arr [ i ] , arr [ i + 1 ] ) != - 1 : NEW_LINE INDENT ans = max ( ans , i - anchor + 1 ) NEW_LINE anchor = i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 9 , 4 , 2 , 10 , 7 , 8 , 8 , 1 , 9 ] NEW_LINE print ( maxSubarraySize ( arr ) ) NEW_LINE"}
{"id": "geeksforgeeks_168_A", "sol": 0, "python_code": "def isdivisible7 ( num ) :\n    n = len ( num )\n    if ( n == 0 and num [ 0 ] == '\\n' ) :\n        return 1\n    if ( n % 3 == 1 ) :\n        num = str ( num ) + \"00\"\n        n += 2\n    elif ( n % 3 == 2 ) :\n        num = str ( num ) + \"0\"\n        n += 1\n    GSum = 0\n    p = 1\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        group = 0\n        group += ord ( num [ i ] ) - ord ( '0' )\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10\n        i -= 1\n        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100\n        GSum = GSum + group * p\n        p *= ( - 1 )\n    return ( GSum % 7 == 0 )\nif __name__ == \"__main__\" :\n    num = \"8955795758\"\n    if ( isdivisible7 ( num ) ) :\n        print ( \"Divisible by 7\" )\n    else :\n        print ( \"Not Divisible by 7\" )\n", "python_code_tokenized": "def isdivisible7 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE if ( n == 0 and num [ 0 ] == ' \\n ' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 3 == 1 ) : NEW_LINE INDENT num = str ( num ) + \"00\" NEW_LINE n += 2 NEW_LINE DEDENT elif ( n % 3 == 2 ) : NEW_LINE INDENT num = str ( num ) + \"0\" NEW_LINE n += 1 NEW_LINE DEDENT GSum = 0 NEW_LINE p = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE GSum = GSum + group * p NEW_LINE p *= ( - 1 ) NEW_LINE DEDENT return ( GSum % 7 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = \"8955795758\" NEW_LINE if ( isdivisible7 ( num ) ) : NEW_LINE INDENT print ( \" Divisible \u2581 by \u2581 7\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Divisible \u2581 by \u2581 7\" ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC138_B", "sol": 0, "python_code": "N = int ( input ( ) )\nA = map ( int , input ( ).split ( ) )\nreciprocal_A = [ 1 / x for x in A ]\nans = 1 / sum ( reciprocal_A )\nprint ( ans )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE A = map ( int , input ( ) . split ( ) ) NEW_LINE reciprocal_A = [ 1 / x for x in A ] NEW_LINE ans = 1 / sum ( reciprocal_A ) NEW_LINE print ( ans ) NEW_LINE"}
{"id": "atcoder_ABC045_D", "sol": 0, "python_code": "h , w , n = map ( int , input ( ).split ( ) )\ncoord = [ list ( map ( int , input ( ).split ( ) ) ) for i in range ( n ) ]\nnum = { }\nfor i in range ( n ) :\n    for j , k in [ [ 0 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] , [ - 1 , - 1 ] ] :\n        if not ( 2 <= coord [ i ] [ 0 ] + j <= h - 1 ) or not ( 2 <= coord [ i ] [ 1 ] + k <= w - 1 ) :\n            continue\n        if not coord [ i ] [ 0 ] + j in num :\n            num [ coord [ i ] [ 0 ] + j ] = { }\n        if not coord [ i ] [ 1 ] + k in num [ coord [ i ] [ 0 ] + j ] :\n            num [ coord [ i ] [ 0 ] + j ] [ coord [ i ] [ 1 ] + k ] = 1\n        else :\n            num [ coord [ i ] [ 0 ] + j ] [ coord [ i ] [ 1 ] + k ] += 1\nans = [ 0 ] * 10\nfor i in num :\n    for value in num [ i ].values ( ) :\n        ans [ value ] += 1\nprint ( ( h - 2 ) * ( w - 2 ) - sum ( ans ) )\nfor i in range ( 1 , 10 ) :\n    print ( ans [ i ] )\n", "python_code_tokenized": "h , w , n = map ( int , input ( ) . split ( ) ) NEW_LINE coord = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE num = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j , k in [ [ 0 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] , [ - 1 , - 1 ] ] : NEW_LINE INDENT if not ( 2 <= coord [ i ] [ 0 ] + j <= h - 1 ) or not ( 2 <= coord [ i ] [ 1 ] + k <= w - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if not coord [ i ] [ 0 ] + j in num : NEW_LINE INDENT num [ coord [ i ] [ 0 ] + j ] = { } NEW_LINE DEDENT if not coord [ i ] [ 1 ] + k in num [ coord [ i ] [ 0 ] + j ] : NEW_LINE INDENT num [ coord [ i ] [ 0 ] + j ] [ coord [ i ] [ 1 ] + k ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT num [ coord [ i ] [ 0 ] + j ] [ coord [ i ] [ 1 ] + k ] += 1 NEW_LINE DEDENT DEDENT DEDENT ans = [ 0 ] * 10 NEW_LINE for i in num : NEW_LINE INDENT for value in num [ i ] . values ( ) : NEW_LINE INDENT ans [ value ] += 1 NEW_LINE DEDENT DEDENT print ( ( h - 2 ) * ( w - 2 ) - sum ( ans ) ) NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT print ( ans [ i ] ) NEW_LINE DEDENT"}
{"id": "codeforces_1037_B", "sol": 0, "python_code": "import math\na , b = map ( int , input ( ).split ( ) )\nc = list ( map ( int , input ( ).split ( ) ) )\nc.sort ( )\nval = c [ len ( c ) // 2 ]\nans = 0\nif b > val :\n    for i in range ( len ( c ) // 2 , len ( c ) ) :\n        if b <= c [ i ] :\n            break\n        ans += b - c [ i ]\nelif b < val :\n    for i in range ( len ( c ) // 2 , - 1 , - 1 ) :\n        if b >= c [ i ] :\n            break\n        ans += c [ i ] - b\nprint ( ans )\n", "python_code_tokenized": "import math NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c . sort ( ) NEW_LINE val = c [ len ( c ) // 2 ] NEW_LINE ans = 0 NEW_LINE if b > val : NEW_LINE INDENT for i in range ( len ( c ) // 2 , len ( c ) ) : NEW_LINE INDENT if b <= c [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT ans += b - c [ i ] NEW_LINE DEDENT DEDENT elif b < val : NEW_LINE INDENT for i in range ( len ( c ) // 2 , - 1 , - 1 ) : NEW_LINE INDENT if b >= c [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT ans += c [ i ] - b NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_2624_A", "sol": 0, "python_code": "def findNthTerm ( x , y , n ) :\n    f = [ 0 ] * 6\n    f [ 0 ] = x\n    f [ 1 ] = y\n    for i in range ( 2 , 6 ) :\n        f [ i ] = f [ i - 1 ] - f [ i - 2 ]\n    return f [ n % 6 ]\nif __name__ == \"__main__\" :\n    x , y , n = 2 , 3 , 3\n    print ( findNthTerm ( x , y , n ) )\n", "python_code_tokenized": "def findNthTerm ( x , y , n ) : NEW_LINE INDENT f = [ 0 ] * 6 NEW_LINE f [ 0 ] = x NEW_LINE f [ 1 ] = y NEW_LINE for i in range ( 2 , 6 ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] - f [ i - 2 ] NEW_LINE DEDENT return f [ n % 6 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x , y , n = 2 , 3 , 3 NEW_LINE print ( findNthTerm ( x , y , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4036_A", "sol": 0, "python_code": "def check ( s , l ) :\n    pos = [ ]\n    for i in range ( l ) :\n        if ( s [ i ] == '1' ) :\n            pos.append ( i )\n    t = len ( pos )\n    for i in range ( 1 , t ) :\n        if ( ( pos [ i ] - pos [ i - 1 ] ) != ( pos [ 1 ] - pos [ 0 ] ) ) :\n            return False\n    return True\ns = \"100010001000\"\nl = len ( s )\nif ( check ( s , l ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def check ( s , l ) : NEW_LINE INDENT pos = [ ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT pos . append ( i ) NEW_LINE DEDENT DEDENT t = len ( pos ) NEW_LINE for i in range ( 1 , t ) : NEW_LINE INDENT if ( ( pos [ i ] - pos [ i - 1 ] ) != ( pos [ 1 ] - pos [ 0 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \"100010001000\" NEW_LINE l = len ( s ) NEW_LINE if ( check ( s , l ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2925_A", "sol": 0, "python_code": "def printGroups ( n , a ) :\n    ct = [ 0 for i in range ( 7 ) ]\n    grps = n // 3\n    i = 0\n    for i in range ( n ) :\n        ct [ a [ i ] ] += 1\n    if ( ct [ 1 ] != grps or ( ct [ 4 ] + ct [ 6 ] ) != grps or ( ct [ 2 ] + ct [ 3 ] ) != grps or ct [ 4 ] > ct [ 2 ] ) :\n        print ( - 1 )\n        return\n    for i in range ( ct [ 4 ] ) :\n        print ( \"1 2 4\" )\n    for i in range ( ct [ 2 ] - ct [ 4 ] ) :\n        print ( \"1 2 6\" )\n    for i in range ( ct [ 3 ] ) :\n        print ( \"1 3 6\" )\nn = 6\na = [ 2 , 2 , 1 , 1 , 4 , 6 ]\nprintGroups ( n , a )\n", "python_code_tokenized": "def printGroups ( n , a ) : NEW_LINE INDENT ct = [ 0 for i in range ( 7 ) ] NEW_LINE grps = n // 3 NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ct [ a [ i ] ] += 1 NEW_LINE DEDENT if ( ct [ 1 ] != grps or ( ct [ 4 ] + ct [ 6 ] ) != grps or ( ct [ 2 ] + ct [ 3 ] ) != grps or ct [ 4 ] > ct [ 2 ] ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( ct [ 4 ] ) : NEW_LINE INDENT print ( \"1 \u2581 2 \u2581 4\" ) NEW_LINE DEDENT for i in range ( ct [ 2 ] - ct [ 4 ] ) : NEW_LINE INDENT print ( \"1 \u2581 2 \u2581 6\" ) NEW_LINE DEDENT for i in range ( ct [ 3 ] ) : NEW_LINE INDENT print ( \"1 \u2581 3 \u2581 6\" ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE a = [ 2 , 2 , 1 , 1 , 4 , 6 ] NEW_LINE printGroups ( n , a ) NEW_LINE"}
{"id": "codeforces_6_A", "sol": 0, "python_code": "a = list ( map ( int , input ( ).split ( ) ) )\nans = 0\nfor i in range ( 4 ) :\n    if ans != 2 :\n        for j in range ( i + 1 , 4 ) :\n            if ans != 2 :\n                for k in range ( j + 1 , 4 ) :\n                    l = [ a [ i ] , a [ j ] , a [ k ] ]\n                    l.sort ( )\n                    if l [ - 1 ] < l [ - 2 ] + l [ - 3 ] :\n                        ans = 2\n                        break\n                    elif l [ - 1 ] == l [ - 2 ] + l [ - 3 ] :\n                        ans = 1\nif ans == 2 :\n    print ( \"TRIANGLE\" )\nelif ans == 1 :\n    print ( \"SEGMENT\" )\nelse :\n    print ( \"IMPOSSIBLE\" )\n", "python_code_tokenized": "a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT if ans != 2 : NEW_LINE INDENT for j in range ( i + 1 , 4 ) : NEW_LINE INDENT if ans != 2 : NEW_LINE INDENT for k in range ( j + 1 , 4 ) : NEW_LINE INDENT l = [ a [ i ] , a [ j ] , a [ k ] ] NEW_LINE l . sort ( ) NEW_LINE if l [ - 1 ] < l [ - 2 ] + l [ - 3 ] : NEW_LINE INDENT ans = 2 NEW_LINE break NEW_LINE DEDENT elif l [ - 1 ] == l [ - 2 ] + l [ - 3 ] : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT if ans == 2 : NEW_LINE INDENT print ( \" TRIANGLE \" ) NEW_LINE DEDENT elif ans == 1 : NEW_LINE INDENT print ( \" SEGMENT \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" IMPOSSIBLE \" ) NEW_LINE DEDENT"}
{"id": "aizu_p00195_A", "sol": 0, "python_code": "dic = { 0 : \"A\" , 1 : \"B\" , 2 : \"C\" , 3 : \"D\" , 4 : \"E\" }\nwhile True :\n    sa = list ( map ( int , input ( ).split ( ) ) )\n    if sa == [ 0 , 0 ] :\n        break\n    lst = [ sum ( sa ) ]\n    for _ in range ( 4 ) :\n        lst.append ( sum ( map ( int , input ( ).split ( ) ) ) )\n    print ( dic [ lst.index ( max ( lst ) ) ] , max ( lst ) )\n", "python_code_tokenized": "dic = { 0 : \" A \" , 1 : \" B \" , 2 : \" C \" , 3 : \" D \" , 4 : \" E \" } NEW_LINE while True : NEW_LINE INDENT sa = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if sa == [ 0 , 0 ] : NEW_LINE INDENT break NEW_LINE DEDENT lst = [ sum ( sa ) ] NEW_LINE for _ in range ( 4 ) : NEW_LINE INDENT lst . append ( sum ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT print ( dic [ lst . index ( max ( lst ) ) ] , max ( lst ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00062_A", "sol": 0, "python_code": "import sys\nfor e in sys.stdin : print ( sum ( int ( a ) * k for a , k in zip ( e [ : 5 ] + e [ 9 : 4 : - 1 ] , [ 1 , 9 , 36 , 84 , 126 ] * 2 ) ) % 10 )\n", "python_code_tokenized": "import sys NEW_LINE for e in sys . stdin : print ( sum ( int ( a ) * k for a , k in zip ( e [ : 5 ] + e [ 9 : 4 : - 1 ] , [ 1 , 9 , 36 , 84 , 126 ] * 2 ) ) % 10 ) NEW_LINE"}
{"id": "geeksforgeeks_640_A", "sol": 0, "python_code": "import math\ndef isPerfectSquare ( num ) :\n    n = int ( math.sqrt ( num ) )\n    return ( n * n == num )\ndef checkFib ( array , n ) :\n    count = 0\n    for i in range ( n ) :\n        if ( isPerfectSquare ( 5 * array [ i ] * array [ i ] + 4 ) or isPerfectSquare ( 5 * array [ i ] * array [ i ] - 4 ) ) :\n            print ( array [ i ] , \"\" , end = \"\" ) ;\n            count = count + 1\n    if ( count == 0 ) :\n        print ( \"None present\" ) ;\narray = [ 4 , 2 , 8 , 5 , 20 , 1 , 40 , 13 , 23 ]\nn = len ( array )\ncheckFib ( array , n )\n", "python_code_tokenized": "import math NEW_LINE def isPerfectSquare ( num ) : NEW_LINE INDENT n = int ( math . sqrt ( num ) ) NEW_LINE return ( n * n == num ) NEW_LINE DEDENT def checkFib ( array , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( 5 * array [ i ] * array [ i ] + 4 ) or isPerfectSquare ( 5 * array [ i ] * array [ i ] - 4 ) ) : NEW_LINE INDENT print ( array [ i ] , \" \u2581 \" , end = \" \" ) ; NEW_LINE count = count + 1 NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( \" None \u2581 present \" ) ; NEW_LINE DEDENT DEDENT array = [ 4 , 2 , 8 , 5 , 20 , 1 , 40 , 13 , 23 ] NEW_LINE n = len ( array ) NEW_LINE checkFib ( array , n ) NEW_LINE"}
{"id": "geeksforgeeks_4752_A", "sol": 0, "python_code": "def findEvenPair ( A , N ) :\n    count = 0\n    for i in range ( N ) :\n        if ( not ( A [ i ] & 1 ) ) :\n            count += 1\n    return count * ( count - 1 ) // 2\nif __name__ == \"__main__\" :\n    A = [ 5 , 6 , 2 , 8 ]\n    N = len ( A )\n    print ( findEvenPair ( A , N ) )\n", "python_code_tokenized": "def findEvenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( not ( A [ i ] & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( count - 1 ) // 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 5 , 6 , 2 , 8 ] NEW_LINE N = len ( A ) NEW_LINE print ( findEvenPair ( A , N ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00136_A", "sol": 0, "python_code": "n = int ( input ( ) )\nH = [ ]\nfor i in range ( n ) :\n    H.append ( float ( input ( ) ) )\nc1 = 0\nc2 = 0\nc3 = 0\nc4 = 0\nc5 = 0\nc6 = 0\nfor j in range ( n ) :\n    if H [ j ] < 165.0 :\n        c1 += 1\n    elif 165.0 <= H [ j ] < 170.0 :\n        c2 += 1\n    elif 170.0 <= H [ j ] < 175.0 :\n        c3 += 1\n    elif 175.0 <= H [ j ] < 180.0 :\n        c4 += 1\n    elif 180.0 <= H [ j ] < 185.0 :\n        c5 += 1\n    else :\n        c6 += 1\nprint ( \"1:\" + c1 * \"*\" , sep = \"\" )\nprint ( \"2:\" + c2 * \"*\" , sep = \"\" )\nprint ( \"3:\" + c3 * \"*\" , sep = \"\" )\nprint ( \"4:\" + c4 * \"*\" , sep = \"\" )\nprint ( \"5:\" + c5 * \"*\" , sep = \"\" )\nprint ( \"6:\" + c6 * \"*\" , sep = \"\" )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE H = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT H . append ( float ( input ( ) ) ) NEW_LINE DEDENT c1 = 0 NEW_LINE c2 = 0 NEW_LINE c3 = 0 NEW_LINE c4 = 0 NEW_LINE c5 = 0 NEW_LINE c6 = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if H [ j ] < 165.0 : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT elif 165.0 <= H [ j ] < 170.0 : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT elif 170.0 <= H [ j ] < 175.0 : NEW_LINE INDENT c3 += 1 NEW_LINE DEDENT elif 175.0 <= H [ j ] < 180.0 : NEW_LINE INDENT c4 += 1 NEW_LINE DEDENT elif 180.0 <= H [ j ] < 185.0 : NEW_LINE INDENT c5 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c6 += 1 NEW_LINE DEDENT DEDENT print ( \"1 : \" + c1 * \" * \" , sep = \" \" ) NEW_LINE print ( \"2 : \" + c2 * \" * \" , sep = \" \" ) NEW_LINE print ( \"3 : \" + c3 * \" * \" , sep = \" \" ) NEW_LINE print ( \"4 : \" + c4 * \" * \" , sep = \" \" ) NEW_LINE print ( \"5 : \" + c5 * \" * \" , sep = \" \" ) NEW_LINE print ( \"6 : \" + c6 * \" * \" , sep = \" \" ) NEW_LINE"}
{"id": "geeksforgeeks_2605_A", "sol": 0, "python_code": "def printArr ( arr , k ) :\n    for i in range ( k ) :\n        print ( arr [ i ] , end = \" \" ) ;\n    print ( ) ;\ndef printSeqUtil ( n , k , len1 , arr ) :\n    if ( len1 == k ) :\n        printArr ( arr , k ) ;\n        return ;\n    i = 1 if ( len1 == 0 ) else ( arr [ len1 - 1 ] + 1 ) ;\n    len1 += 1 ;\n    while ( i <= n ) :\n        arr [ len1 - 1 ] = i ;\n        printSeqUtil ( n , k , len1 , arr ) ;\n        i += 1 ;\n    len1 -= 1 ;\ndef printSeq ( n , k ) :\n    arr = [ 0 ] * k ;\n    len1 = 0 ;\n    printSeqUtil ( n , k , len1 , arr ) ;\nk = 3 ;\nn = 7 ;\nprintSeq ( n , k ) ;\n", "python_code_tokenized": "def printArr ( arr , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def printSeqUtil ( n , k , len1 , arr ) : NEW_LINE INDENT if ( len1 == k ) : NEW_LINE INDENT printArr ( arr , k ) ; NEW_LINE return ; NEW_LINE DEDENT i = 1 if ( len1 == 0 ) else ( arr [ len1 - 1 ] + 1 ) ; NEW_LINE len1 += 1 ; NEW_LINE while ( i <= n ) : NEW_LINE INDENT arr [ len1 - 1 ] = i ; NEW_LINE printSeqUtil ( n , k , len1 , arr ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT len1 -= 1 ; NEW_LINE DEDENT def printSeq ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * k ; NEW_LINE len1 = 0 ; NEW_LINE printSeqUtil ( n , k , len1 , arr ) ; NEW_LINE DEDENT k = 3 ; NEW_LINE n = 7 ; NEW_LINE printSeq ( n , k ) ; NEW_LINE"}
{"id": "geeksforgeeks_1696_A", "sol": 0, "python_code": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if ( arr [ i ] == 0 ) :\n            jumps [ i ] = float ( 'inf' )\n        elif ( arr [ i ] >= n - i - 1 ) :\n            jumps [ i ] = 1\n        else :\n            min = float ( 'inf' )\n            for j in range ( i + 1 , n ) :\n                if ( j <= arr [ i ] + i ) :\n                    if ( min > jumps [ j ] ) :\n                        min = jumps [ j ]\n            if ( min != float ( 'inf' ) ) :\n                jumps [ i ] = min + 1\n            else :\n                jumps [ i ] = min\n    return jumps [ 0 ]\narr = [ 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 ]\nn = len ( arr )\nprint ( 'Minimum number of jumps to reach' , 'end is' , minJumps ( arr , n - 1 ) )\n", "python_code_tokenized": "def minJumps ( arr , n ) : NEW_LINE INDENT jumps = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT jumps [ i ] = float ( ' inf ' ) NEW_LINE DEDENT elif ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT jumps [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT min = float ( ' inf ' ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j <= arr [ i ] + i ) : NEW_LINE INDENT if ( min > jumps [ j ] ) : NEW_LINE INDENT min = jumps [ j ] NEW_LINE DEDENT DEDENT DEDENT if ( min != float ( ' inf ' ) ) : NEW_LINE INDENT jumps [ i ] = min + 1 NEW_LINE DEDENT else : NEW_LINE INDENT jumps [ i ] = min NEW_LINE DEDENT DEDENT DEDENT return jumps [ 0 ] NEW_LINE DEDENT arr = [ 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ' Minimum \u2581 number \u2581 of \u2581 jumps \u2581 to \u2581 reach ' , ' end \u2581 is ' , minJumps ( arr , n - 1 ) ) NEW_LINE"}
{"id": "geeksforgeeks_1695_A", "sol": 0, "python_code": "def minJumps ( arr , n ) :\n    jumps = [ 0 for i in range ( n ) ]\n    if ( n == 0 ) or ( arr [ 0 ] == 0 ) :\n        return float ( 'inf' )\n    jumps [ 0 ] = 0\n    for i in range ( 1 , n ) :\n        jumps [ i ] = float ( 'inf' )\n        for j in range ( i ) :\n            if ( i <= j + arr [ j ] ) and ( jumps [ j ] != float ( 'inf' ) ) :\n                jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 )\n                break\n    return jumps [ n - 1 ]\narr = [ 1 , 3 , 6 , 1 , 0 , 9 ]\nsize = len ( arr )\nprint ( 'Minimum number of jumps to reach' , 'end is' , minJumps ( arr , size ) )\n", "python_code_tokenized": "def minJumps ( arr , n ) : NEW_LINE INDENT jumps = [ 0 for i in range ( n ) ] NEW_LINE if ( n == 0 ) or ( arr [ 0 ] == 0 ) : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT jumps [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT jumps [ i ] = float ( ' inf ' ) NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( i <= j + arr [ j ] ) and ( jumps [ j ] != float ( ' inf ' ) ) : NEW_LINE INDENT jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return jumps [ n - 1 ] NEW_LINE DEDENT arr = [ 1 , 3 , 6 , 1 , 0 , 9 ] NEW_LINE size = len ( arr ) NEW_LINE print ( ' Minimum \u2581 number \u2581 of \u2581 jumps \u2581 to \u2581 reach ' , ' end \u2581 is ' , minJumps ( arr , size ) ) NEW_LINE"}
{"id": "geeksforgeeks_283_A", "sol": 0, "python_code": "def maxUniqueNum ( a , N , M ) :\n    maxUnique = 0\n    for i in range ( N - M ) :\n        s = set ( )\n        for j in range ( M ) :\n            s.add ( a [ i + j ] )\n        if ( len ( s ) > maxUnique ) :\n            maxUnique = len ( s )\n    return maxUnique\nif __name__ == '__main__' :\n    arr = [ 5 , 3 , 5 , 2 , 3 , 2 ]\n    M = 3\n    N = len ( arr )\n    print ( maxUniqueNum ( arr , N , M ) )\n", "python_code_tokenized": "def maxUniqueNum ( a , N , M ) : NEW_LINE INDENT maxUnique = 0 NEW_LINE for i in range ( N - M ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( M ) : NEW_LINE INDENT s . add ( a [ i + j ] ) NEW_LINE DEDENT if ( len ( s ) > maxUnique ) : NEW_LINE INDENT maxUnique = len ( s ) NEW_LINE DEDENT DEDENT return maxUnique NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 5 , 2 , 3 , 2 ] NEW_LINE M = 3 NEW_LINE N = len ( arr ) NEW_LINE print ( maxUniqueNum ( arr , N , M ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4698_A", "sol": 0, "python_code": "def MinOperation ( a , b , n ) :\n    a.sort ( reverse = False )\n    b.sort ( reverse = False )\n    result = 0\n    for i in range ( 0 , n , 1 ) :\n        if ( a [ i ] > b [ i ] ) :\n            result = result + abs ( a [ i ] - b [ i ] )\n        elif ( a [ i ] < b [ i ] ) :\n            result = result + abs ( a [ i ] - b [ i ] )\n    return result\nif __name__ == '__main__' :\n    a = [ 3 , 1 , 1 ]\n    b = [ 1 , 2 , 2 ]\n    n = len ( a )\n    print ( MinOperation ( a , b , n ) )\n", "python_code_tokenized": "def MinOperation ( a , b , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] > b [ i ] ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT elif ( a [ i ] < b [ i ] ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 3 , 1 , 1 ] NEW_LINE b = [ 1 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( MinOperation ( a , b , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_777_B", "sol": 0, "python_code": "n = int ( input ( ) )\nSherlock = list ( input ( ) )\nMoriarty = sorted ( list ( input ( ) ) )\ncopySherlock = [ digit for digit in Sherlock ]\ncopyMoriarty = [ digit for digit in Moriarty ]\nminHits = 0\nmaxHits = 0\nfor i in range ( n ) :\n    for j in range ( n ) :\n        if Moriarty [ j ] == - 1 :\n            continue\n        if Moriarty [ j ] >= Sherlock [ i ] :\n            Moriarty [ j ] = - 1\n            Sherlock [ i ] = - 1\n            break\nfor i in range ( n ) :\n    if Moriarty [ i ] != - 1 :\n        minHits += 1\nfor i in range ( n ) :\n    for j in range ( n ) :\n        if copyMoriarty [ j ] == - 1 :\n            continue\n        if copyMoriarty [ j ] > copySherlock [ i ] :\n            maxHits += 1\n            copyMoriarty [ j ] = - 1\n            break\nprint ( minHits )\nprint ( maxHits )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE Sherlock = list ( input ( ) ) NEW_LINE Moriarty = sorted ( list ( input ( ) ) ) NEW_LINE copySherlock = [ digit for digit in Sherlock ] NEW_LINE copyMoriarty = [ digit for digit in Moriarty ] NEW_LINE minHits = 0 NEW_LINE maxHits = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if Moriarty [ j ] == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if Moriarty [ j ] >= Sherlock [ i ] : NEW_LINE INDENT Moriarty [ j ] = - 1 NEW_LINE Sherlock [ i ] = - 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if Moriarty [ i ] != - 1 : NEW_LINE INDENT minHits += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if copyMoriarty [ j ] == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if copyMoriarty [ j ] > copySherlock [ i ] : NEW_LINE INDENT maxHits += 1 NEW_LINE copyMoriarty [ j ] = - 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( minHits ) NEW_LINE print ( maxHits ) NEW_LINE"}
{"id": "atcoder_ABC176_E", "sol": 0, "python_code": "from itertools import product\nh , w , m = map ( int , input ( ).split ( ) )\nrow = [ set ( ) for _ in range ( h ) ]\ncol = [ set ( ) for _ in range ( w ) ]\nfor _ in range ( m ) :\n    x , y = map ( lambda x : int ( x ) - 1 , input ( ).split ( ) )\n    row [ x ].add ( y )\n    col [ y ].add ( x )\ncrow = 0\nic = [ ]\nfor i , x in enumerate ( row ) :\n    if crow < len ( x ) :\n        crow = len ( x )\n        ic = [ i ]\n    elif crow == len ( x ) :\n        ic.append ( i )\nccol = 0\njc = [ ]\nfor j , x in enumerate ( col ) :\n    if ccol < len ( x ) :\n        ccol = len ( x )\n        jc = [ j ]\n    elif ccol == len ( x ) :\n        jc.append ( j )\nans = crow + ccol\nfor i , j in product ( ic , jc ) :\n    if j not in row [ i ] :\n        print ( ans )\n        break\nelse :\n    print ( ans - 1 )\n", "python_code_tokenized": "from itertools import product NEW_LINE h , w , m = map ( int , input ( ) . split ( ) ) NEW_LINE row = [ set ( ) for _ in range ( h ) ] NEW_LINE col = [ set ( ) for _ in range ( w ) ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT x , y = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) NEW_LINE row [ x ] . add ( y ) NEW_LINE col [ y ] . add ( x ) NEW_LINE DEDENT crow = 0 NEW_LINE ic = [ ] NEW_LINE for i , x in enumerate ( row ) : NEW_LINE INDENT if crow < len ( x ) : NEW_LINE INDENT crow = len ( x ) NEW_LINE ic = [ i ] NEW_LINE DEDENT elif crow == len ( x ) : NEW_LINE INDENT ic . append ( i ) NEW_LINE DEDENT DEDENT ccol = 0 NEW_LINE jc = [ ] NEW_LINE for j , x in enumerate ( col ) : NEW_LINE INDENT if ccol < len ( x ) : NEW_LINE INDENT ccol = len ( x ) NEW_LINE jc = [ j ] NEW_LINE DEDENT elif ccol == len ( x ) : NEW_LINE INDENT jc . append ( j ) NEW_LINE DEDENT DEDENT ans = crow + ccol NEW_LINE for i , j in product ( ic , jc ) : NEW_LINE INDENT if j not in row [ i ] : NEW_LINE INDENT print ( ans ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ans - 1 ) NEW_LINE DEDENT"}
{"id": "codeforces_1504_B", "sol": 0, "python_code": "for p in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    a = input ( )\n    b = input ( )\n    a += \"0\"\n    b += \"0\"\n    f , p = 0 , 0\n    for i in range ( n ) :\n        if a [ i ] == \"1\" : x = 1\n        else : x = 0\n        if a [ i ] == \"0\" : y = 1\n        else : y = 0\n        f += ( x - y )\n        if a [ i ] == b [ i ] : w = 1\n        else : w = 0\n        if a [ i + 1 ] == b [ i + 1 ] : z = 1\n        else : z = 0\n        if w != z and f != 0 :\n            p = 1\n            print ( \"NO\" )\n            break\n    if not p :\n        print ( \"YES\" )\n", "python_code_tokenized": "for p in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE a += \"0\" NEW_LINE b += \"0\" NEW_LINE f , p = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == \"1\" : x = 1 NEW_LINE else : x = 0 NEW_LINE if a [ i ] == \"0\" : y = 1 NEW_LINE else : y = 0 NEW_LINE f += ( x - y ) NEW_LINE if a [ i ] == b [ i ] : w = 1 NEW_LINE else : w = 0 NEW_LINE if a [ i + 1 ] == b [ i + 1 ] : z = 1 NEW_LINE else : z = 0 NEW_LINE if w != z and f != 0 : NEW_LINE INDENT p = 1 NEW_LINE print ( \" NO \" ) NEW_LINE break NEW_LINE DEDENT DEDENT if not p : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_189_A", "sol": 0, "python_code": "def cutRibbon ( ) :\n    arr = [ int ( i ) for i in input ( ).split ( ) ]\n    length = arr [ 0 ]\n    arr = sorted ( arr [ 1 : 4 ] , reverse = False )\n    if ( length % arr [ 0 ] == 0 ) :\n        print ( int ( length / arr [ 0 ] ) )\n        return\n    ans = 0\n    if ( arr [ 0 ] == arr [ 1 ] ) :\n        k = 0\n        for i in range ( int ( length / arr [ 2 ] ) + 1 ) :\n            check = length - i * arr [ 2 ]\n            if ( check >= 0 and check % arr [ 0 ] == 0 ) :\n                k = int ( check / arr [ 0 ] )\n                ans = max ( ans , k + i )\n    else :\n        k = 0\n        for i in range ( int ( length / arr [ 2 ] ) + 1 ) :\n            for j in range ( int ( length / arr [ 1 ] ) + 1 ) :\n                check = length - i * arr [ 2 ] - j * arr [ 1 ]\n                if ( check >= 0 and check % arr [ 0 ] == 0 ) :\n                    k = int ( check / arr [ 0 ] )\n                    ans = max ( ans , k + i + j )\n    print ( ans )\n    return\ncutRibbon ( )\n", "python_code_tokenized": "def cutRibbon ( ) : NEW_LINE INDENT arr = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE length = arr [ 0 ] NEW_LINE arr = sorted ( arr [ 1 : 4 ] , reverse = False ) NEW_LINE if ( length % arr [ 0 ] == 0 ) : NEW_LINE INDENT print ( int ( length / arr [ 0 ] ) ) NEW_LINE return NEW_LINE DEDENT ans = 0 NEW_LINE if ( arr [ 0 ] == arr [ 1 ] ) : NEW_LINE INDENT k = 0 NEW_LINE for i in range ( int ( length / arr [ 2 ] ) + 1 ) : NEW_LINE INDENT check = length - i * arr [ 2 ] NEW_LINE if ( check >= 0 and check % arr [ 0 ] == 0 ) : NEW_LINE INDENT k = int ( check / arr [ 0 ] ) NEW_LINE ans = max ( ans , k + i ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT k = 0 NEW_LINE for i in range ( int ( length / arr [ 2 ] ) + 1 ) : NEW_LINE INDENT for j in range ( int ( length / arr [ 1 ] ) + 1 ) : NEW_LINE INDENT check = length - i * arr [ 2 ] - j * arr [ 1 ] NEW_LINE if ( check >= 0 and check % arr [ 0 ] == 0 ) : NEW_LINE INDENT k = int ( check / arr [ 0 ] ) NEW_LINE ans = max ( ans , k + i + j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE return NEW_LINE DEDENT cutRibbon ( ) NEW_LINE"}
{"id": "geeksforgeeks_418_A", "sol": 0, "python_code": "def maxSum ( arr , n , k ) :\n    if ( n < k ) :\n        return - 1 ;\n    res = 0 ;\n    for i in range ( k ) :\n        res += arr [ i ] ;\n    curr_sum = res ;\n    for i in range ( k , n ) :\n        curr_sum += arr [ i ] - arr [ i - k ] ;\n        res = max ( res , curr_sum ) ;\n    return res ;\ndef solve ( arr , n , k ) :\n    max_len = 0 ; l = 0 ; r = n ;\n    while ( l <= r ) :\n        m = ( l + r ) // 2 ;\n        if ( maxSum ( arr , n , m ) > k ) :\n            r = m - 1 ;\n        else :\n            l = m + 1 ;\n            max_len = m ;\n    return max_len ;\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 3 , 4 , 5 ] ;\n    n = len ( arr ) ;\n    k = 10 ;\n    print ( solve ( arr , n , k ) ) ;\n", "python_code_tokenized": "def maxSum ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT res = 0 ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT res += arr [ i ] ; NEW_LINE DEDENT curr_sum = res ; NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum += arr [ i ] - arr [ i - k ] ; NEW_LINE res = max ( res , curr_sum ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def solve ( arr , n , k ) : NEW_LINE INDENT max_len = 0 ; l = 0 ; r = n ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) // 2 ; NEW_LINE if ( maxSum ( arr , n , m ) > k ) : NEW_LINE INDENT r = m - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 ; NEW_LINE max_len = m ; NEW_LINE DEDENT DEDENT return max_len ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 10 ; NEW_LINE print ( solve ( arr , n , k ) ) ; NEW_LINE DEDENT"}
{"id": "atcoder_ABC134_A", "sol": 0, "python_code": "r = int ( input ( ) )\nprint ( 3 * r ** 2 )\n", "python_code_tokenized": "r = int ( input ( ) ) NEW_LINE print ( 3 * r ** 2 ) NEW_LINE"}
{"id": "geeksforgeeks_2176_A", "sol": 0, "python_code": "MAX = 10001\ndef sieveOfEratosthenes ( s ) :\n    prime = [ False for i in range ( MAX + 1 ) ]\n    for i in range ( 2 , MAX + 1 , 2 ) :\n        s [ i ] = 2 ;\n    for i in range ( 3 , MAX , 2 ) :\n        if ( prime [ i ] == False ) :\n            s [ i ] = i\n            for j in range ( i , MAX + 1 , 2 ) :\n                if j * j > MAX :\n                    break\n                if ( prime [ i * j ] == False ) :\n                    prime [ i * j ] = True\n                    s [ i * j ] = i\ndef kPrimeFactor ( n , k , s ) :\n    while ( n > 1 ) :\n        if ( k == 1 ) :\n            return s [ n ]\n        k -= 1\n        n //= s [ n ]\n    return - 1\ns = [ - 1 for i in range ( MAX + 1 ) ]\nsieveOfEratosthenes ( s )\nn = 12\nk = 3\nprint ( kPrimeFactor ( n , k , s ) )\nn = 14\nk = 3\nprint ( kPrimeFactor ( n , k , s ) )\n", "python_code_tokenized": "MAX = 10001 NEW_LINE def sieveOfEratosthenes ( s ) : NEW_LINE INDENT prime = [ False for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( 2 , MAX + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 ; NEW_LINE DEDENT for i in range ( 3 , MAX , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , MAX + 1 , 2 ) : NEW_LINE INDENT if j * j > MAX : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def kPrimeFactor ( n , k , s ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return s [ n ] NEW_LINE DEDENT k -= 1 NEW_LINE n //= s [ n ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT s = [ - 1 for i in range ( MAX + 1 ) ] NEW_LINE sieveOfEratosthenes ( s ) NEW_LINE n = 12 NEW_LINE k = 3 NEW_LINE print ( kPrimeFactor ( n , k , s ) ) NEW_LINE n = 14 NEW_LINE k = 3 NEW_LINE print ( kPrimeFactor ( n , k , s ) ) NEW_LINE"}
{"id": "atcoder_ABC075_C", "sol": 0, "python_code": "def root ( nodes , x ) :\n    if nodes [ x ] < 0 :\n        return x\n    else :\n        nodes [ x ] = root ( nodes , nodes [ x ] )\n        return nodes [ x ]\ndef unite ( nodes , x , y ) :\n    root_x , root_y = root ( nodes , x ) , root ( nodes , y )\n    if root_x != root_y :\n        nodes [ root_x ] = root_y\ndef is_same ( nodes , x , y ) :\n    return root ( nodes , x ) == root ( nodes , y )\nN , M = list ( map ( int , input ( ).split ( ) ) )\ndata = [ [ 0 for s in range ( 2 ) ] for k in range ( M ) ]\nfor i in range ( M ) :\n    temp = input ( ).split ( )\n    data [ i ] [ 0 ] = int ( temp [ 0 ] ) - 1\n    data [ i ] [ 1 ] = int ( temp [ 1 ] ) - 1\nsum = 0\nfor i in range ( M ) :\n    nodes = [ - 1 ] * ( N )\n    for j in range ( M ) :\n        if j != i :\n            unite ( nodes , data [ j ] [ 0 ] , data [ j ] [ 1 ] )\n    for k in range ( 1 , N ) :\n        if is_same ( nodes , k - 1 , k ) :\n            continue\n        else :\n            sum += 1\n            break\nprint ( sum )\n", "python_code_tokenized": "def root ( nodes , x ) : NEW_LINE INDENT if nodes [ x ] < 0 : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT nodes [ x ] = root ( nodes , nodes [ x ] ) NEW_LINE return nodes [ x ] NEW_LINE DEDENT DEDENT def unite ( nodes , x , y ) : NEW_LINE INDENT root_x , root_y = root ( nodes , x ) , root ( nodes , y ) NEW_LINE if root_x != root_y : NEW_LINE INDENT nodes [ root_x ] = root_y NEW_LINE DEDENT DEDENT def is_same ( nodes , x , y ) : NEW_LINE INDENT return root ( nodes , x ) == root ( nodes , y ) NEW_LINE DEDENT N , M = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE data = [ [ 0 for s in range ( 2 ) ] for k in range ( M ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT temp = input ( ) . split ( ) NEW_LINE data [ i ] [ 0 ] = int ( temp [ 0 ] ) - 1 NEW_LINE data [ i ] [ 1 ] = int ( temp [ 1 ] ) - 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT nodes = [ - 1 ] * ( N ) NEW_LINE for j in range ( M ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT unite ( nodes , data [ j ] [ 0 ] , data [ j ] [ 1 ] ) NEW_LINE DEDENT DEDENT for k in range ( 1 , N ) : NEW_LINE INDENT if is_same ( nodes , k - 1 , k ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE"}
{"id": "geeksforgeeks_1866_A", "sol": 0, "python_code": "A = [ 11 , 15 , 7 , 19 ]\nN = len ( A )\nSet = set ( )\nfor i in range ( 0 , N ) :\n    res = 2147483647\n    for j in range ( i , N ) :\n        res &= A [ j ]\n        Set.add ( res )\nprint ( Set )\n", "python_code_tokenized": "A = [ 11 , 15 , 7 , 19 ] NEW_LINE N = len ( A ) NEW_LINE Set = set ( ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT res = 2147483647 NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT res &= A [ j ] NEW_LINE Set . add ( res ) NEW_LINE DEDENT DEDENT print ( Set ) NEW_LINE"}
{"id": "geeksforgeeks_2575_A", "sol": 0, "python_code": "def integer_to_string ( n , base ) :\n    str = \"\" ;\n    while ( n > 0 ) :\n        digit = n % base ;\n        n = int ( n / base ) ;\n        str = chr ( digit + ord ( '0' ) ) + str ;\n    return str ;\ndef isPalindrome ( i , k ) :\n    temp = i ;\n    m = 0 ;\n    while ( temp > 0 ) :\n        m = ( temp % 10 ) + ( m * 10 ) ;\n        temp = int ( temp / 10 ) ;\n    if ( m == i ) :\n        str = integer_to_string ( m , k ) ;\n        str1 = str ;\n        if ( str [ : : - 1 ] == str1 ) :\n            return i ;\n    return 0 ;\ndef sumPalindrome ( n , k ) :\n    sum = 0 ;\n    for i in range ( n ) :\n        sum += isPalindrome ( i , k ) ;\n    print ( \"Total sum is\" , sum ) ;\nn = 100 ;\nk = 2 ;\nsumPalindrome ( n , k ) ;\n", "python_code_tokenized": "def integer_to_string ( n , base ) : NEW_LINE INDENT str = \" \" ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % base ; NEW_LINE n = int ( n / base ) ; NEW_LINE str = chr ( digit + ord ( '0' ) ) + str ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT def isPalindrome ( i , k ) : NEW_LINE INDENT temp = i ; NEW_LINE m = 0 ; NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT m = ( temp % 10 ) + ( m * 10 ) ; NEW_LINE temp = int ( temp / 10 ) ; NEW_LINE DEDENT if ( m == i ) : NEW_LINE INDENT str = integer_to_string ( m , k ) ; NEW_LINE str1 = str ; NEW_LINE if ( str [ : : - 1 ] == str1 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT def sumPalindrome ( n , k ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += isPalindrome ( i , k ) ; NEW_LINE DEDENT print ( \" Total \u2581 sum \u2581 is \" , sum ) ; NEW_LINE DEDENT n = 100 ; NEW_LINE k = 2 ; NEW_LINE sumPalindrome ( n , k ) ; NEW_LINE"}
{"id": "codeforces_219_A", "sol": 0, "python_code": "k = int ( input ( ).strip ( ) )\nS = input ( )\nd = { }\nfor s in S :\n    try :\n        d [ s ] += 1\n    except :\n        d [ s ] = 1\ndone = False\nfor x , y in d.items ( ) :\n    if y % k != 0 :\n        print ( - 1 )\n        done = True\n        break\no = ''\nif not done :\n    for x , y in d.items ( ) :\n        o += str ( x ) * ( y // k )\n    print ( o * k )\n", "python_code_tokenized": "k = int ( input ( ) . strip ( ) ) NEW_LINE S = input ( ) NEW_LINE d = { } NEW_LINE for s in S : NEW_LINE INDENT try : NEW_LINE INDENT d [ s ] += 1 NEW_LINE DEDENT except : NEW_LINE INDENT d [ s ] = 1 NEW_LINE DEDENT DEDENT done = False NEW_LINE for x , y in d . items ( ) : NEW_LINE INDENT if y % k != 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE done = True NEW_LINE break NEW_LINE DEDENT DEDENT o = ' ' NEW_LINE if not done : NEW_LINE INDENT for x , y in d . items ( ) : NEW_LINE INDENT o += str ( x ) * ( y // k ) NEW_LINE DEDENT print ( o * k ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5113_A", "sol": 0, "python_code": "def maxPerimeter ( arr ) :\n    maxi = 0\n    n = len ( arr )\n    for i in range ( n - 2 ) :\n        for j in range ( i + 1 , n - 1 ) :\n            for k in range ( j + 1 , n ) :\n                a = arr [ i ]\n                b = arr [ j ]\n                c = arr [ k ]\n                if ( a < b + c and b < a + c and c < a + b ) :\n                    maxi = max ( maxi , a + b + c )\n    if ( maxi == 0 ) :\n        return \"Triangle formation is not possible\"\n    else :\n        return \"Maximum Perimeter is: \" + str ( maxi )\ndef main ( ) :\n    arr1 = [ 6 , 1 , 6 , 5 , 8 , 4 ]\n    a = maxPerimeter ( arr1 )\n    print ( a )\n    arr2 = [ 2 , 20 , 7 , 55 , 1 , 33 , 12 , 4 ]\n    a = maxPerimeter ( arr2 )\n    print ( a )\n    arr3 = [ 33 , 6 , 20 , 1 , 8 , 12 , 5 , 55 , 4 , 9 ]\n    a = maxPerimeter ( arr3 )\n    print ( a )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "def maxPerimeter ( arr ) : NEW_LINE INDENT maxi = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT a = arr [ i ] NEW_LINE b = arr [ j ] NEW_LINE c = arr [ k ] NEW_LINE if ( a < b + c and b < a + c and c < a + b ) : NEW_LINE INDENT maxi = max ( maxi , a + b + c ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( maxi == 0 ) : NEW_LINE INDENT return \" Triangle \u2581 formation \u2581 is \u2581 not \u2581 possible \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" Maximum \u2581 Perimeter \u2581 is : \u2581 \" + str ( maxi ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr1 = [ 6 , 1 , 6 , 5 , 8 , 4 ] NEW_LINE a = maxPerimeter ( arr1 ) NEW_LINE print ( a ) NEW_LINE arr2 = [ 2 , 20 , 7 , 55 , 1 , 33 , 12 , 4 ] NEW_LINE a = maxPerimeter ( arr2 ) NEW_LINE print ( a ) NEW_LINE arr3 = [ 33 , 6 , 20 , 1 , 8 , 12 , 5 , 55 , 4 , 9 ] NEW_LINE a = maxPerimeter ( arr3 ) NEW_LINE print ( a ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "aizu_p01636_A", "sol": 0, "python_code": "a = input ( )\nans = 0\nfor i in range ( 1 , len ( a ) ) :\n    df = a [ : i ]\n    sm = a [ i : ]\n    if sm [ 0 ] == \"0\" : continue\n    df = int ( df )\n    sm = int ( sm )\n    if ( df + sm ) % 2 == 0 and sm >= df and ( sm - df ) % 2 == 0 :\n        ans += 1\nif int ( a ) % 2 == 0 : ans += 1\nprint ( ans )\n", "python_code_tokenized": "a = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT df = a [ : i ] NEW_LINE sm = a [ i : ] NEW_LINE if sm [ 0 ] == \"0\" : continue NEW_LINE df = int ( df ) NEW_LINE sm = int ( sm ) NEW_LINE if ( df + sm ) % 2 == 0 and sm >= df and ( sm - df ) % 2 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if int ( a ) % 2 == 0 : ans += 1 NEW_LINE print ( ans ) NEW_LINE"}
{"id": "aizu_p02293_A", "sol": 0, "python_code": "import sys\nimport os\nimport pprint\ndef judge ( lst ) :\n    x0 , y0 , x1 , y1 , x2 , y2 , x3 , y3 = lst\n    v0 = ( x1 - x0 , y1 - y0 )\n    v1 = ( x3 - x2 , y3 - y2 )\n    dot = v0 [ 0 ] * v1 [ 0 ] + v0 [ 1 ] * v1 [ 1 ]\n    cross = v0 [ 0 ] * v1 [ 1 ] - v0 [ 1 ] * v1 [ 0 ]\n    if dot == 0 :\n        print ( 1 )\n    elif cross == 0 :\n        print ( 2 )\n    else :\n        print ( 0 )\nN = int ( input ( ) )\nfor i in range ( N ) :\n    lst = list ( map ( int , input ( ).split ( ) ) )\n    judge ( lst )\n", "python_code_tokenized": "import sys NEW_LINE import os NEW_LINE import pprint NEW_LINE def judge ( lst ) : NEW_LINE INDENT x0 , y0 , x1 , y1 , x2 , y2 , x3 , y3 = lst NEW_LINE v0 = ( x1 - x0 , y1 - y0 ) NEW_LINE v1 = ( x3 - x2 , y3 - y2 ) NEW_LINE dot = v0 [ 0 ] * v1 [ 0 ] + v0 [ 1 ] * v1 [ 1 ] NEW_LINE cross = v0 [ 0 ] * v1 [ 1 ] - v0 [ 1 ] * v1 [ 0 ] NEW_LINE if dot == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif cross == 0 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT N = int ( input ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE judge ( lst ) NEW_LINE DEDENT"}
{"id": "codeforces_1603_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor e in range ( t ) :\n    n = int ( input ( ) )\n    c = 0\n    l1 = list ( map ( int , input ( ).split ( ) ) )\n    for i in range ( min ( len ( l1 ) , 21 ) ) :\n        q = l1 [ i ]\n        chk = 0\n        for i in range ( 2 , i + 3 ) :\n            if ( q % i != 0 ) :\n                chk = 1\n                break\n        if ( chk == 1 ) :\n            continue\n        else :\n            c = 1\n            break\n    if ( c == 0 ) :\n        print ( 'YES' )\n    else :\n        print ( 'NO' )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for e in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE c = 0 NEW_LINE l1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( min ( len ( l1 ) , 21 ) ) : NEW_LINE INDENT q = l1 [ i ] NEW_LINE chk = 0 NEW_LINE for i in range ( 2 , i + 3 ) : NEW_LINE INDENT if ( q % i != 0 ) : NEW_LINE INDENT chk = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( chk == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT c = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( c == 0 ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4670_A", "sol": 0, "python_code": "def __gcd ( a , b ) :\n    if ( b == 0 ) :\n        return a\n    else :\n        return __gcd ( b , a % b )\ndef power ( x , y , m ) :\n    if ( y == 0 ) :\n        return 1\n    p = power ( x , y // 2 , m ) % m\n    p = ( p * p ) % m\n    return p if ( y % 2 == 0 ) else ( x * p ) % m\ndef modInverse ( a , m ) :\n    if ( __gcd ( a , m ) != 1 ) :\n        print ( \"Inverse doesn't exist\" )\n    else :\n        print ( \"Modular multiplicative inverse is \" , power ( a , m - 2 , m ) )\na = 3\nm = 11\nmodInverse ( a , m )\n", "python_code_tokenized": "def __gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return __gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def power ( x , y , m ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( x , y // 2 , m ) % m NEW_LINE p = ( p * p ) % m NEW_LINE return p if ( y % 2 == 0 ) else ( x * p ) % m NEW_LINE DEDENT def modInverse ( a , m ) : NEW_LINE INDENT if ( __gcd ( a , m ) != 1 ) : NEW_LINE INDENT print ( \" Inverse \u2581 doesn ' t \u2581 exist \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Modular \u2581 multiplicative \u2581 inverse \u2581 is \u2581 \" , power ( a , m - 2 , m ) ) NEW_LINE DEDENT DEDENT a = 3 NEW_LINE m = 11 NEW_LINE modInverse ( a , m ) NEW_LINE"}
{"id": "atcoder_ABC052_B", "sol": 0, "python_code": "N = int ( input ( ) )\nS = input ( )\nx = 0\nmax_num = 0\nfor i in range ( N ) :\n    if S [ i ] == \"I\" :\n        x += 1\n    else :\n        x -= 1\n    if x > max_num :\n        max_num = x\nprint ( max_num )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE S = input ( ) NEW_LINE x = 0 NEW_LINE max_num = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if S [ i ] == \" I \" : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT if x > max_num : NEW_LINE INDENT max_num = x NEW_LINE DEDENT DEDENT print ( max_num ) NEW_LINE"}
{"id": "geeksforgeeks_4821_A", "sol": 0, "python_code": "def sumOfSeries ( n ) :\n    x = 0\n    if n % 2 == 0 :\n        x = ( n / 2 ) * ( n + 1 )\n    else :\n        x = ( ( n + 1 ) / 2 ) * n\n    return ( int ) ( x * x )\nn = 5\nprint ( sumOfSeries ( n ) )\n", "python_code_tokenized": "def sumOfSeries ( n ) : NEW_LINE INDENT x = 0 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT x = ( n / 2 ) * ( n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT x = ( ( n + 1 ) / 2 ) * n NEW_LINE DEDENT return ( int ) ( x * x ) NEW_LINE DEDENT n = 5 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4819_A", "sol": 0, "python_code": "def sumOfSeries ( n ) :\n    sum = 0\n    for i in range ( 1 , n + 1 ) :\n        sum += i * i * i\n    return sum\nn = 5\nprint ( sumOfSeries ( n ) )\n", "python_code_tokenized": "def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 5 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4820_A", "sol": 0, "python_code": "def sumOfSeries ( n ) :\n    x = ( n * ( n + 1 ) / 2 )\n    return ( int ) ( x * x )\nn = 5\nprint ( sumOfSeries ( n ) )\n", "python_code_tokenized": "def sumOfSeries ( n ) : NEW_LINE INDENT x = ( n * ( n + 1 ) / 2 ) NEW_LINE return ( int ) ( x * x ) NEW_LINE DEDENT n = 5 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3539_A", "sol": 0, "python_code": "def editDistanceWith2Ops ( X , Y ) :\n    m = len ( X )\n    n = len ( Y )\n    L = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ]\n    for i in range ( m + 1 ) :\n        for j in range ( n + 1 ) :\n            if ( i == 0 or j == 0 ) :\n                L [ i ] [ j ] = 0\n            elif ( X [ i - 1 ] == Y [ j - 1 ] ) :\n                L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1\n            else :\n                L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] )\n    lcs = L [ m ] [ n ]\n    return ( m - lcs ) + ( n - lcs )\nif __name__ == \"__main__\" :\n    X = \"abc\"\n    Y = \"acd\"\n    print ( editDistanceWith2Ops ( X , Y ) )\n", "python_code_tokenized": "def editDistanceWith2Ops ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE L = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT lcs = L [ m ] [ n ] NEW_LINE return ( m - lcs ) + ( n - lcs ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = \" abc \" NEW_LINE Y = \" acd \" NEW_LINE print ( editDistanceWith2Ops ( X , Y ) ) NEW_LINE DEDENT"}
{"id": "aizu_p01996_A", "sol": 0, "python_code": "n , m = [ int ( i ) for i in input ( ).split ( ) ]\na = [ int ( i ) for i in input ( ).split ( ) ]\nprint ( sum ( x > m for x in a ) )\n", "python_code_tokenized": "n , m = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE print ( sum ( x > m for x in a ) ) NEW_LINE"}
{"id": "projecteuler_p078_A", "sol": 0, "python_code": "import itertools\nMODULUS = 10 ** 6\ndef compute ( ) :\n    partitions = [ 1 ]\n    for i in itertools.count ( len ( partitions ) ) :\n        item = 0\n        for j in itertools.count ( 1 ) :\n            sign = - 1 if j % 2 == 0 else + 1\n            index = ( j * j * 3 - j ) // 2\n            if index > i :\n                break\n            item += partitions [ i - index ] * sign\n            index += j\n            if index > i :\n                break\n            item += partitions [ i - index ] * sign\n            item %= MODULUS\n        if item == 0 :\n            return str ( i )\n        partitions.append ( item )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import itertools NEW_LINE MODULUS = 10 ** 6 NEW_LINE def compute ( ) : NEW_LINE INDENT partitions = [ 1 ] NEW_LINE for i in itertools . count ( len ( partitions ) ) : NEW_LINE INDENT item = 0 NEW_LINE for j in itertools . count ( 1 ) : NEW_LINE INDENT sign = - 1 if j % 2 == 0 else + 1 NEW_LINE index = ( j * j * 3 - j ) // 2 NEW_LINE if index > i : NEW_LINE INDENT break NEW_LINE DEDENT item += partitions [ i - index ] * sign NEW_LINE index += j NEW_LINE if index > i : NEW_LINE INDENT break NEW_LINE DEDENT item += partitions [ i - index ] * sign NEW_LINE item %= MODULUS NEW_LINE DEDENT if item == 0 : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT partitions . append ( item ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4564_A", "sol": 0, "python_code": "def findNth ( N ) :\n    b = 14\n    for i in range ( 2 , N + 1 ) :\n        if ( i % 2 == 0 ) :\n            b = b * 2\n        else :\n            b = b - 8\n    return b\nN = 6\nprint ( findNth ( N ) )\n", "python_code_tokenized": "def findNth ( N ) : NEW_LINE INDENT b = 14 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT b = b * 2 NEW_LINE DEDENT else : NEW_LINE INDENT b = b - 8 NEW_LINE DEDENT DEDENT return b NEW_LINE DEDENT N = 6 NEW_LINE print ( findNth ( N ) ) NEW_LINE"}
{"id": "geeksforgeeks_433_A", "sol": 0, "python_code": "def CountPair ( arr , n ) :\n    result = 0 ;\n    for i in range ( 0 , n ) :\n        j = i + 1\n        while ( j < n ) :\n            if ( i * arr [ i ] > j * arr [ j ] ) :\n                result = result + 1\n            j = j + 1\n    return result ;\narr = [ 5 , 0 , 10 , 2 , 4 , 1 , 6 ]\nn = len ( arr )\nprint ( \"Count of Pairs : \" , CountPair ( arr , n ) )\n", "python_code_tokenized": "def CountPair ( arr , n ) : NEW_LINE INDENT result = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( i * arr [ i ] > j * arr [ j ] ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT arr = [ 5 , 0 , 10 , 2 , 4 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Count \u2581 of \u2581 Pairs \u2581 : \u2581 \" , CountPair ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4350_A", "sol": 0, "python_code": "def emi_calculator ( p , r , t ) :\n    r = r / ( 12 * 100 )\n    t = t * 12\n    emi = ( p * r * pow ( 1 + r , t ) ) / ( pow ( 1 + r , t ) - 1 )\n    return emi\nprincipal = 10000 ;\nrate = 10 ;\ntime = 2 ;\nemi = emi_calculator ( principal , rate , time ) ;\nprint ( \"Monthly EMI is= \" , emi )\n", "python_code_tokenized": "def emi_calculator ( p , r , t ) : NEW_LINE INDENT r = r / ( 12 * 100 ) NEW_LINE t = t * 12 NEW_LINE emi = ( p * r * pow ( 1 + r , t ) ) / ( pow ( 1 + r , t ) - 1 ) NEW_LINE return emi NEW_LINE DEDENT principal = 10000 ; NEW_LINE rate = 10 ; NEW_LINE time = 2 ; NEW_LINE emi = emi_calculator ( principal , rate , time ) ; NEW_LINE print ( \" Monthly \u2581 EMI \u2581 is = \u2581 \" , emi ) NEW_LINE"}
{"id": "codeforces_340_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = [ ]\narea = 0\nfor i in range ( n ) :\n    a.append ( [ int ( i ) for i in input ( ).split ( ' ' ) ] )\ndef get_s ( p1 , p2 , p3 ) :\n    return ( ( p2 [ 0 ] - p1 [ 0 ] ) * ( p3 [ 1 ] - p1 [ 1 ] ) - ( p2 [ 1 ] - p1 [ 1 ] ) * ( p3 [ 0 ] - p1 [ 0 ] ) ) / 2.0\nfor i in range ( len ( a ) - 1 ) :\n    for j in range ( i + 1 , len ( a ) ) :\n        positive = 0\n        negative = 0\n        for k in range ( len ( a ) ) :\n            if k == i or k == j :\n                continue\n            s = get_s ( a [ i ] , a [ j ] , a [ k ] )\n            if s > 0 :\n                positive = max ( positive , s )\n            if s == 0 :\n                pass\n            else :\n                negative = min ( negative , s )\n        if positive != 0 and negative != 0 :\n            area = max ( area , positive - negative )\nprint ( area )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE area = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( [ int ( i ) for i in input ( ) . split ( ' \u2581 ' ) ] ) NEW_LINE DEDENT def get_s ( p1 , p2 , p3 ) : NEW_LINE INDENT return ( ( p2 [ 0 ] - p1 [ 0 ] ) * ( p3 [ 1 ] - p1 [ 1 ] ) - ( p2 [ 1 ] - p1 [ 1 ] ) * ( p3 [ 0 ] - p1 [ 0 ] ) ) / 2.0 NEW_LINE DEDENT for i in range ( len ( a ) - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , len ( a ) ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 0 NEW_LINE for k in range ( len ( a ) ) : NEW_LINE INDENT if k == i or k == j : NEW_LINE INDENT continue NEW_LINE DEDENT s = get_s ( a [ i ] , a [ j ] , a [ k ] ) NEW_LINE if s > 0 : NEW_LINE INDENT positive = max ( positive , s ) NEW_LINE DEDENT if s == 0 : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT negative = min ( negative , s ) NEW_LINE DEDENT DEDENT if positive != 0 and negative != 0 : NEW_LINE INDENT area = max ( area , positive - negative ) NEW_LINE DEDENT DEDENT DEDENT print ( area ) NEW_LINE"}
{"id": "geeksforgeeks_3437_A", "sol": 0, "python_code": "def getPerfectSquares ( n ) :\n    perfectSquares = [ ] ;\n    current = 1 ;\n    i = 1 ;\n    while ( current <= n ) :\n        perfectSquares.append ( current ) ;\n        i += 1 ;\n        current = int ( pow ( i , 2 ) ) ;\n    return perfectSquares ;\ndef maxPairSum ( arr ) :\n    n = len ( arr ) ;\n    max = 0 ;\n    secondMax = 0 ;\n    if ( arr [ 0 ] > arr [ 1 ] ) :\n        max = arr [ 0 ] ;\n        secondMax = arr [ 1 ] ;\n    else :\n        max = arr [ 1 ] ;\n        secondMax = arr [ 0 ] ;\n    for i in range ( 2 , n ) :\n        if ( arr [ i ] > max ) :\n            secondMax = max ;\n            max = arr [ i ] ;\n        elif ( arr [ i ] > secondMax ) :\n            secondMax = arr [ i ] ;\n    return ( max + secondMax ) ;\ndef countPairsWith ( n , perfectSquares , nums ) :\n    count = 0 ;\n    for i in range ( len ( perfectSquares ) ) :\n        temp = perfectSquares [ i ] - n ;\n        if ( temp > n and ( temp in nums ) ) :\n            count += 1 ;\n    return count ;\ndef countPairs ( arr ) :\n    n = len ( arr ) ;\n    max = maxPairSum ( arr ) ;\n    perfectSquares = getPerfectSquares ( max ) ;\n    nums = [ ] ;\n    for i in range ( n ) :\n        nums.append ( arr [ i ] ) ;\n    count = 0 ;\n    for i in range ( n ) :\n        count += countPairsWith ( arr [ i ] , perfectSquares , nums ) ;\n    return count ;\narr = [ 2 , 3 , 6 , 9 , 10 , 20 ] ;\nprint ( countPairs ( arr ) ) ;\n", "python_code_tokenized": "def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] ; NEW_LINE current = 1 ; NEW_LINE i = 1 ; NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) ; NEW_LINE i += 1 ; NEW_LINE current = int ( pow ( i , 2 ) ) ; NEW_LINE DEDENT return perfectSquares ; NEW_LINE DEDENT def maxPairSum ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE max = 0 ; NEW_LINE secondMax = 0 ; NEW_LINE if ( arr [ 0 ] > arr [ 1 ] ) : NEW_LINE INDENT max = arr [ 0 ] ; NEW_LINE secondMax = arr [ 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT max = arr [ 1 ] ; NEW_LINE secondMax = arr [ 0 ] ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT secondMax = max ; NEW_LINE max = arr [ i ] ; NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] ; NEW_LINE DEDENT DEDENT return ( max + secondMax ) ; NEW_LINE DEDENT def countPairsWith ( n , perfectSquares , nums ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT temp = perfectSquares [ i ] - n ; NEW_LINE if ( temp > n and ( temp in nums ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT def countPairs ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE max = maxPairSum ( arr ) ; NEW_LINE perfectSquares = getPerfectSquares ( max ) ; NEW_LINE nums = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT nums . append ( arr [ i ] ) ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count += countPairsWith ( arr [ i ] , perfectSquares , nums ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT arr = [ 2 , 3 , 6 , 9 , 10 , 20 ] ; NEW_LINE print ( countPairs ( arr ) ) ; NEW_LINE"}
{"id": "atcoder_ABC174_B", "sol": 0, "python_code": "N , D = map ( int , input ( ).split ( ) )\ncounter = 0\nfor _ in range ( N ) :\n    x , y = map ( int , input ( ).split ( ) )\n    d = ( x ** 2 + y ** 2 ) ** ( 1 / 2 )\n    if d <= D :\n        counter += 1\nprint ( counter )\n", "python_code_tokenized": "N , D = map ( int , input ( ) . split ( ) ) NEW_LINE counter = 0 NEW_LINE for _ in range ( N ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE d = ( x ** 2 + y ** 2 ) ** ( 1 / 2 ) NEW_LINE if d <= D : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT print ( counter ) NEW_LINE"}
{"id": "geeksforgeeks_2766_A", "sol": 0, "python_code": "from collections import defaultdict\ndef commonWords ( S ) :\n    has = defaultdict ( lambda : False )\n    ans = [ ]\n    m = len ( S )\n    i = 0\n    while i < len ( S [ 0 ] ) :\n        string = \"\"\n        while i < len ( S [ 0 ] ) and S [ 0 ] [ i ] != ' ' :\n            string += S [ 0 ] [ i ]\n            i += 1\n        i += 1\n        if string != \"\" :\n            ans.append ( [ string , True ] )\n    for j in range ( 1 , m ) :\n        has.clear ( )\n        i = 0\n        while i < len ( S [ j ] ) :\n            string = \"\"\n            while i < len ( S [ j ] ) and S [ j ] [ i ] != ' ' :\n                string += S [ j ] [ i ]\n                i += 1\n            i += 1\n            if string != \"\" :\n                has [ string ] = True\n        for k in range ( 0 , len ( ans ) ) :\n            if ( ans [ k ] [ 1 ] != False and has [ ans [ k ] [ 0 ] ] == False ) :\n                ans [ k ] [ 1 ] = False\n            elif ( ans [ k ] [ 1 ] != False and has [ ans [ k ] [ 0 ] ] == True ) :\n                has [ ans [ k ] [ 0 ] ] = False\n    cnt = 0\n    for k in range ( 0 , len ( ans ) ) :\n        if ans [ k ] [ 1 ] == True :\n            cnt += 1\n    return cnt\nif __name__ == \"__main__\" :\n    S = [ ]\n    S.append ( \"there is a cow\" )\n    S.append ( \"cow is our mother\" )\n    S.append ( \"cow gives us milk and milk is sweet\" )\n    S.append ( \"there is a boy who loves cow\" )\n    print ( commonWords ( S ) )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE def commonWords ( S ) : NEW_LINE INDENT has = defaultdict ( lambda : False ) NEW_LINE ans = [ ] NEW_LINE m = len ( S ) NEW_LINE i = 0 NEW_LINE while i < len ( S [ 0 ] ) : NEW_LINE INDENT string = \" \" NEW_LINE while i < len ( S [ 0 ] ) and S [ 0 ] [ i ] != ' \u2581 ' : NEW_LINE INDENT string += S [ 0 ] [ i ] NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE if string != \" \" : NEW_LINE INDENT ans . append ( [ string , True ] ) NEW_LINE DEDENT DEDENT for j in range ( 1 , m ) : NEW_LINE INDENT has . clear ( ) NEW_LINE i = 0 NEW_LINE while i < len ( S [ j ] ) : NEW_LINE INDENT string = \" \" NEW_LINE while i < len ( S [ j ] ) and S [ j ] [ i ] != ' \u2581 ' : NEW_LINE INDENT string += S [ j ] [ i ] NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE if string != \" \" : NEW_LINE INDENT has [ string ] = True NEW_LINE DEDENT DEDENT for k in range ( 0 , len ( ans ) ) : NEW_LINE INDENT if ( ans [ k ] [ 1 ] != False and has [ ans [ k ] [ 0 ] ] == False ) : NEW_LINE INDENT ans [ k ] [ 1 ] = False NEW_LINE DEDENT elif ( ans [ k ] [ 1 ] != False and has [ ans [ k ] [ 0 ] ] == True ) : NEW_LINE INDENT has [ ans [ k ] [ 0 ] ] = False NEW_LINE DEDENT DEDENT DEDENT cnt = 0 NEW_LINE for k in range ( 0 , len ( ans ) ) : NEW_LINE INDENT if ans [ k ] [ 1 ] == True : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = [ ] NEW_LINE S . append ( \" there \u2581 is \u2581 a \u2581 cow \" ) NEW_LINE S . append ( \" cow \u2581 is \u2581 our \u2581 mother \" ) NEW_LINE S . append ( \" cow \u2581 gives \u2581 us \u2581 milk \u2581 and \u2581 milk \u2581 is \u2581 sweet \" ) NEW_LINE S . append ( \" there \u2581 is \u2581 a \u2581 boy \u2581 who \u2581 loves \u2581 cow \" ) NEW_LINE print ( commonWords ( S ) ) NEW_LINE DEDENT"}
{"id": "codeforces_988_B", "sol": 0, "python_code": "a = [ ]\nn = int ( input ( ) )\nfor i in range ( n ) :\n    x = input ( )\n    a.append ( x )\ndef cmp ( x ) :\n    return len ( x )\na.sort ( key = cmp )\ntemp = True\nfor i in range ( len ( a ) - 1 ) :\n    if not a [ i ] in a [ i + 1 ] :\n        temp = False\n        break\nif temp :\n    print ( \"YES\" )\n    for i in range ( len ( a ) ) :\n        print ( a [ i ] )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "a = [ ] NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = input ( ) NEW_LINE a . append ( x ) NEW_LINE DEDENT def cmp ( x ) : NEW_LINE INDENT return len ( x ) NEW_LINE DEDENT a . sort ( key = cmp ) NEW_LINE temp = True NEW_LINE for i in range ( len ( a ) - 1 ) : NEW_LINE INDENT if not a [ i ] in a [ i + 1 ] : NEW_LINE INDENT temp = False NEW_LINE break NEW_LINE DEDENT DEDENT if temp : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT print ( a [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_182_A", "sol": 0, "python_code": "def isVowel ( x ) :\n    return ( x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' )\ndef longestVowelSubsequence ( str ) :\n    answer = \"\"\n    n = len ( str )\n    for i in range ( n ) :\n        if ( isVowel ( str [ i ] ) ) :\n            answer += str [ i ]\n    return answer\nstr = \"geeksforgeeks\"\nprint ( longestVowelSubsequence ( str ) )\n", "python_code_tokenized": "def isVowel ( x ) : NEW_LINE INDENT return ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' ) NEW_LINE DEDENT def longestVowelSubsequence ( str ) : NEW_LINE INDENT answer = \" \" NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) ) : NEW_LINE INDENT answer += str [ i ] NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE print ( longestVowelSubsequence ( str ) ) NEW_LINE"}
{"id": "geeksforgeeks_2322_A", "sol": 0, "python_code": "def convertToBinary ( num , a , n ) :\n    pointer = n - 1\n    while ( num > 0 ) :\n        a [ pointer ] = num % 2\n        num = num // 2\n        pointer -= 1\ndef checkforsum ( a , n ) :\n    sum1 = 0\n    sum2 = 0\n    mid = n // 2\n    for i in range ( mid ) :\n        sum1 = sum1 + a [ i ]\n    for j in range ( mid , n ) :\n        sum2 = sum2 + a [ j ]\n    if ( sum1 == sum2 ) :\n        for i in range ( n ) :\n            print ( a [ i ] , end = \"\" )\n        print ( )\ndef print_seq ( m ) :\n    n = ( 2 * m )\n    a = [ 0 for i in range ( n ) ]\n    for i in range ( pow ( 2 , n ) ) :\n        convertToBinary ( i , a , n )\n        checkforsum ( a , n )\nm = 2\nprint_seq ( m )\n", "python_code_tokenized": "def convertToBinary ( num , a , n ) : NEW_LINE INDENT pointer = n - 1 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT a [ pointer ] = num % 2 NEW_LINE num = num // 2 NEW_LINE pointer -= 1 NEW_LINE DEDENT DEDENT def checkforsum ( a , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE mid = n // 2 NEW_LINE for i in range ( mid ) : NEW_LINE INDENT sum1 = sum1 + a [ i ] NEW_LINE DEDENT for j in range ( mid , n ) : NEW_LINE INDENT sum2 = sum2 + a [ j ] NEW_LINE DEDENT if ( sum1 == sum2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def print_seq ( m ) : NEW_LINE INDENT n = ( 2 * m ) NEW_LINE a = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( pow ( 2 , n ) ) : NEW_LINE INDENT convertToBinary ( i , a , n ) NEW_LINE checkforsum ( a , n ) NEW_LINE DEDENT DEDENT m = 2 NEW_LINE print_seq ( m ) NEW_LINE"}
{"id": "geeksforgeeks_2836_A", "sol": 0, "python_code": "def maxLength ( s , n ) :\n    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    for i in range ( n - 1 ) :\n        if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) :\n            dp [ i ] [ i + 1 ] = 2\n    for l in range ( 2 , n ) :\n        i = - 1\n        for j in range ( l , n ) :\n            i += 1\n            if ( s [ i ] == '(' and s [ j ] == ')' ) :\n                dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ]\n            for k in range ( i , j ) :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] )\n    return dp [ 0 ] [ n - 1 ]\ns = \"()(((((()\"\nn = len ( s )\nprint ( maxLength ( s , n ) )\n", "python_code_tokenized": "def maxLength ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' and s [ i + 1 ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ i + 1 ] = 2 NEW_LINE DEDENT DEDENT for l in range ( 2 , n ) : NEW_LINE INDENT i = - 1 NEW_LINE for j in range ( l , n ) : NEW_LINE INDENT i += 1 NEW_LINE if ( s [ i ] == ' ( ' and s [ j ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT s = \" ( ) ( ( ( ( ( ( ) \" NEW_LINE n = len ( s ) NEW_LINE print ( maxLength ( s , n ) ) NEW_LINE"}
{"id": "atcoder_ABC106_C", "sol": 0, "python_code": "import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools\nsys.setrecursionlimit ( 10 ** 7 )\ninf = 10 ** 20\neps = 1.0 / 10 ** 10\nmod = 10 ** 9 + 7\ndd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ]\nddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ]\ndef LI ( ) : return [ int ( x ) for x in sys.stdin.readline ( ).split ( ) ]\ndef LI_ ( ) : return [ int ( x ) - 1 for x in sys.stdin.readline ( ).split ( ) ]\ndef LF ( ) : return [ float ( x ) for x in sys.stdin.readline ( ).split ( ) ]\ndef LS ( ) : return sys.stdin.readline ( ).split ( )\ndef I ( ) : return int ( sys.stdin.readline ( ) )\ndef F ( ) : return float ( sys.stdin.readline ( ) )\ndef S ( ) : return input ( )\ndef pf ( s ) : return print ( s , flush = True )\ndef main ( ) :\n    s = S ( )\n    k = I ( )\n    l = 0\n    for c in s :\n        if c != '1' :\n            break\n        l += 1\n    if l >= k :\n        return 1\n    return s [ l ]\nprint ( main ( ) )\n", "python_code_tokenized": "import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 / 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] NEW_LINE ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT s = S ( ) NEW_LINE k = I ( ) NEW_LINE l = 0 NEW_LINE for c in s : NEW_LINE INDENT if c != '1' : NEW_LINE INDENT break NEW_LINE DEDENT l += 1 NEW_LINE DEDENT if l >= k : NEW_LINE INDENT return 1 NEW_LINE DEDENT return s [ l ] NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"}
{"id": "aizu_p00075_A", "sol": 0, "python_code": "try :\n    while True :\n        s , w , h = map ( float , input ( ).split ( \",\" ) )\n        bmi = w / ( h * h )\n        if bmi >= 25.0 :\n            print ( int ( s ) )\nexcept :\n    pass\n", "python_code_tokenized": "try : NEW_LINE INDENT while True : NEW_LINE INDENT s , w , h = map ( float , input ( ) . split ( \" , \" ) ) NEW_LINE bmi = w / ( h * h ) NEW_LINE if bmi >= 25.0 : NEW_LINE INDENT print ( int ( s ) ) NEW_LINE DEDENT DEDENT DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1256_A", "sol": 0, "python_code": "def isPerfectCube ( x ) :\n    cr = int ( x ** ( 1 / 3 ) ) ;\n    return ( cr * cr * cr == x ) ;\ndef canBePerfectCube ( N , K ) :\n    if ( isPerfectCube ( N + K ) or isPerfectCube ( N - K ) ) :\n        print ( \"Yes\" ) ;\n    else :\n        print ( \"No\" ) ;\nif __name__ == \"__main__\" :\n    N = 7 ; K = 1 ;\n    canBePerfectCube ( N , K ) ;\n    N = 5 ; K = 4 ;\n    canBePerfectCube ( N , K ) ;\n    N = 7 ; K = 2 ;\n    canBePerfectCube ( N , K ) ;\n", "python_code_tokenized": "def isPerfectCube ( x ) : NEW_LINE INDENT cr = int ( x ** ( 1 / 3 ) ) ; NEW_LINE return ( cr * cr * cr == x ) ; NEW_LINE DEDENT def canBePerfectCube ( N , K ) : NEW_LINE INDENT if ( isPerfectCube ( N + K ) or isPerfectCube ( N - K ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 7 ; K = 1 ; NEW_LINE canBePerfectCube ( N , K ) ; NEW_LINE N = 5 ; K = 4 ; NEW_LINE canBePerfectCube ( N , K ) ; NEW_LINE N = 7 ; K = 2 ; NEW_LINE canBePerfectCube ( N , K ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_61_A", "sol": 0, "python_code": "import sys\nINT_MAX = sys.maxsize ;\nINT_MIN = - ( sys.maxsize - 1 ) ;\ndef minimumAdjacentDifference ( a , n , k ) :\n    minDiff = INT_MAX ;\n    for i in range ( k + 1 ) :\n        maxDiff = INT_MIN ;\n        for j in range ( n - k - 1 ) :\n            for p in range ( i , i + j + 1 ) :\n                maxDiff = max ( maxDiff , a [ p + 1 ] - a [ p ] ) ;\n        minDiff = min ( minDiff , maxDiff ) ;\n    return minDiff ;\nif __name__ == \"__main__\" :\n    n = 5 ;\n    k = 2 ;\n    a = [ 3 , 7 , 8 , 10 , 14 ] ;\n    print ( minimumAdjacentDifference ( a , n , k ) ) ;\n", "python_code_tokenized": "import sys NEW_LINE INT_MAX = sys . maxsize ; NEW_LINE INT_MIN = - ( sys . maxsize - 1 ) ; NEW_LINE def minimumAdjacentDifference ( a , n , k ) : NEW_LINE INDENT minDiff = INT_MAX ; NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT maxDiff = INT_MIN ; NEW_LINE for j in range ( n - k - 1 ) : NEW_LINE INDENT for p in range ( i , i + j + 1 ) : NEW_LINE INDENT maxDiff = max ( maxDiff , a [ p + 1 ] - a [ p ] ) ; NEW_LINE DEDENT DEDENT minDiff = min ( minDiff , maxDiff ) ; NEW_LINE DEDENT return minDiff ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE k = 2 ; NEW_LINE a = [ 3 , 7 , 8 , 10 , 14 ] ; NEW_LINE print ( minimumAdjacentDifference ( a , n , k ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1546_A", "sol": 0, "python_code": "class newNode :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.left = None\n        self.right = None\ndef inorder ( root ) :\n    if ( root == None ) :\n        return\n    inorder ( root.left )\n    print ( root.data , end = \" \" )\n    inorder ( root.right )\ndef isIdentical ( root1 , root2 ) :\n    if ( root1 == None and root2 == None ) :\n        return 1\n    elif ( root1 != None and root2 == None ) :\n        return 0\n    elif ( root1 == None and root2 != None ) :\n        return 0\n    else :\n        if ( root1.data == root2.data and isIdentical ( root1.left , root2.left ) and isIdentical ( root1.right , root2.right ) ) :\n            return 1\n        else :\n            return 0\nif __name__ == '__main__' :\n    root1 = newNode ( 5 )\n    root2 = newNode ( 5 )\n    root1.left = newNode ( 3 )\n    root1.right = newNode ( 8 )\n    root1.left.left = newNode ( 2 )\n    root1.left.right = newNode ( 4 )\n    root2.left = newNode ( 3 )\n    root2.right = newNode ( 8 )\n    root2.left.left = newNode ( 2 )\n    root2.left.right = newNode ( 4 )\n    if ( isIdentical ( root1 , root2 ) ) :\n        print ( \"Both BSTs are identical\" )\n    else :\n        print ( \"BSTs are not identical\" )\n", "python_code_tokenized": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def inorder ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT inorder ( root . left ) NEW_LINE print ( root . data , end = \" \u2581 \" ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT def isIdentical ( root1 , root2 ) : NEW_LINE INDENT if ( root1 == None and root2 == None ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( root1 != None and root2 == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( root1 == None and root2 != None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT if ( root1 . data == root2 . data and isIdentical ( root1 . left , root2 . left ) and isIdentical ( root1 . right , root2 . right ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root1 = newNode ( 5 ) NEW_LINE root2 = newNode ( 5 ) NEW_LINE root1 . left = newNode ( 3 ) NEW_LINE root1 . right = newNode ( 8 ) NEW_LINE root1 . left . left = newNode ( 2 ) NEW_LINE root1 . left . right = newNode ( 4 ) NEW_LINE root2 . left = newNode ( 3 ) NEW_LINE root2 . right = newNode ( 8 ) NEW_LINE root2 . left . left = newNode ( 2 ) NEW_LINE root2 . left . right = newNode ( 4 ) NEW_LINE if ( isIdentical ( root1 , root2 ) ) : NEW_LINE INDENT print ( \" Both \u2581 BSTs \u2581 are \u2581 identical \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" BSTs \u2581 are \u2581 not \u2581 identical \" ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_AGC019_B", "sol": 0, "python_code": "from collections import Counter\nA = input ( )\nN = len ( A )\nc = Counter ( A )\nans = 1 + N * ( N - 1 ) // 2 - sum ( ( v * ( v - 1 ) ) // 2 for v in c.values ( ) )\nprint ( ans )\n", "python_code_tokenized": "from collections import Counter NEW_LINE A = input ( ) NEW_LINE N = len ( A ) NEW_LINE c = Counter ( A ) NEW_LINE ans = 1 + N * ( N - 1 ) // 2 - sum ( ( v * ( v - 1 ) ) // 2 for v in c . values ( ) ) NEW_LINE print ( ans ) NEW_LINE"}
{"id": "codeforces_1637_A", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\ninf = float ( 'inf' )\ndef getInt ( ) :\n    return int ( input ( ) )\ndef getStr ( ) :\n    return input ( ).strip ( )\ndef getList ( split = True ) :\n    s = getStr ( )\n    if split :\n        s = s.split ( )\n    return map ( int , s )\nt = getInt ( )\ndef solve ( ) :\n    n = getInt ( )\n    a = list ( getList ( ) )\n    print ( a == sorted ( a ) and \"NO\" or \"YES\" )\nfor _ in range ( t ) :\n    solve ( )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE inf = float ( ' inf ' ) NEW_LINE def getInt ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def getStr ( ) : NEW_LINE INDENT return input ( ) . strip ( ) NEW_LINE DEDENT def getList ( split = True ) : NEW_LINE INDENT s = getStr ( ) NEW_LINE if split : NEW_LINE INDENT s = s . split ( ) NEW_LINE DEDENT return map ( int , s ) NEW_LINE DEDENT t = getInt ( ) NEW_LINE def solve ( ) : NEW_LINE INDENT n = getInt ( ) NEW_LINE a = list ( getList ( ) ) NEW_LINE print ( a == sorted ( a ) and \" NO \" or \" YES \" ) NEW_LINE DEDENT for _ in range ( t ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1432_A", "sol": 0, "python_code": "def sieve_modified ( ) :\n    for i in range ( 2 , MAX , 2 ) :\n        for j in range ( i , MAX , i ) :\n            prefix [ j ] += i\n    for i in range ( 1 , MAX ) :\n        prefix [ i ] += prefix [ i - 1 ]\ndef sumEvenFactors ( L , R ) :\n    return ( prefix [ R ] - prefix [ L - 1 ] )\nif __name__ == \"__main__\" :\n    MAX = 100000\n    prefix = [ 0 ] * MAX\n    sieve_modified ( )\n    l , r = 6 , 10\n    print ( sumEvenFactors ( l , r ) )\n", "python_code_tokenized": "def sieve_modified ( ) : NEW_LINE INDENT for i in range ( 2 , MAX , 2 ) : NEW_LINE INDENT for j in range ( i , MAX , i ) : NEW_LINE INDENT prefix [ j ] += i NEW_LINE DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT prefix [ i ] += prefix [ i - 1 ] NEW_LINE DEDENT DEDENT def sumEvenFactors ( L , R ) : NEW_LINE INDENT return ( prefix [ R ] - prefix [ L - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT MAX = 100000 NEW_LINE prefix = [ 0 ] * MAX NEW_LINE sieve_modified ( ) NEW_LINE l , r = 6 , 10 NEW_LINE print ( sumEvenFactors ( l , r ) ) NEW_LINE DEDENT"}
{"id": "leetcode_654_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def constructMaximumBinaryTree ( self , nums ) :\n        if nums is None or len ( nums ) == 0 :\n            return None\n        max_index , max_value = 0 , 0\n        for i , value in enumerate ( nums ) :\n            if value >= max_value :\n                max_value = value\n                max_index = i\n        root = TreeNode ( max_value )\n        root.left = self.constructMaximumBinaryTree ( nums [ : max_index ] )\n        root.right = self.constructMaximumBinaryTree ( nums [ max_index + 1 : ] )\n        return root\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def constructMaximumBinaryTree ( self , nums ) : NEW_LINE INDENT if nums is None or len ( nums ) == 0 : NEW_LINE INDENT return None NEW_LINE DEDENT max_index , max_value = 0 , 0 NEW_LINE for i , value in enumerate ( nums ) : NEW_LINE INDENT if value >= max_value : NEW_LINE INDENT max_value = value NEW_LINE max_index = i NEW_LINE DEDENT DEDENT root = TreeNode ( max_value ) NEW_LINE root . left = self . constructMaximumBinaryTree ( nums [ : max_index ] ) NEW_LINE root . right = self . constructMaximumBinaryTree ( nums [ max_index + 1 : ] ) NEW_LINE return root NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3548_A", "sol": 0, "python_code": "import math as mt\nR = 3\nC = 3\ndef minInitialPoints ( points ) :\n    dp = [ [ 0 for x in range ( C + 1 ) ] for y in range ( R + 1 ) ]\n    m , n = R , C\n    if points [ m - 1 ] [ n - 1 ] > 0 :\n        dp [ m - 1 ] [ n - 1 ] = 1\n    else :\n        dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 1 ] ) + 1\n    for i in range ( m - 2 , - 1 , - 1 ) :\n        dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 )\n    for i in range ( 2 , - 1 , - 1 ) :\n        dp [ m - 1 ] [ i ] = max ( dp [ m - 1 ] [ i + 1 ] - points [ m - 1 ] [ i ] , 1 )\n    for i in range ( m - 2 , - 1 , - 1 ) :\n        for j in range ( n - 2 , - 1 , - 1 ) :\n            min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] )\n            dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 )\n    return dp [ 0 ] [ 0 ]\npoints = [ [ - 2 , - 3 , 3 ] , [ - 5 , - 10 , 1 ] , [ 10 , 30 , - 5 ] ]\nprint ( \"Minimum Initial Points Required:\" , minInitialPoints ( points ) )\n", "python_code_tokenized": "import math as mt NEW_LINE R = 3 NEW_LINE C = 3 NEW_LINE def minInitialPoints ( points ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( C + 1 ) ] for y in range ( R + 1 ) ] NEW_LINE m , n = R , C NEW_LINE if points [ m - 1 ] [ n - 1 ] > 0 : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 1 ] ) + 1 NEW_LINE DEDENT for i in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) NEW_LINE DEDENT for i in range ( 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ m - 1 ] [ i ] = max ( dp [ m - 1 ] [ i + 1 ] - points [ m - 1 ] [ i ] , 1 ) NEW_LINE DEDENT for i in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) NEW_LINE dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 ) NEW_LINE DEDENT DEDENT return dp [ 0 ] [ 0 ] NEW_LINE DEDENT points = [ [ - 2 , - 3 , 3 ] , [ - 5 , - 10 , 1 ] , [ 10 , 30 , - 5 ] ] NEW_LINE print ( \" Minimum \u2581 Initial \u2581 Points \u2581 Required : \" , minInitialPoints ( points ) ) NEW_LINE"}
{"id": "atcoder_ABC153_A", "sol": 0, "python_code": "import math\nh , a = map ( int , input ( ).split ( ) )\nprint ( math.ceil ( h / a ) )\n", "python_code_tokenized": "import math NEW_LINE h , a = map ( int , input ( ) . split ( ) ) NEW_LINE print ( math . ceil ( h / a ) ) NEW_LINE"}
{"id": "geeksforgeeks_1735_A", "sol": 0, "python_code": "def y ( x ) :\n    return ( 1 / ( 1 + x * x ) )\ndef trapezoidal ( a , b , n ) :\n    h = ( b - a ) / n\n    s = ( y ( a ) + y ( b ) )\n    i = 1\n    while i < n :\n        s += 2 * y ( a + i * h )\n        i += 1\n    return ( ( h / 2 ) * s )\nx0 = 0\nxn = 1\nn = 6\nprint ( \"Value of integral is \" , \"%.4f\" % trapezoidal ( x0 , xn , n ) )\n", "python_code_tokenized": "def y ( x ) : NEW_LINE INDENT return ( 1 / ( 1 + x * x ) ) NEW_LINE DEDENT def trapezoidal ( a , b , n ) : NEW_LINE INDENT h = ( b - a ) / n NEW_LINE s = ( y ( a ) + y ( b ) ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT s += 2 * y ( a + i * h ) NEW_LINE i += 1 NEW_LINE DEDENT return ( ( h / 2 ) * s ) NEW_LINE DEDENT x0 = 0 NEW_LINE xn = 1 NEW_LINE n = 6 NEW_LINE print ( \" Value \u2581 of \u2581 integral \u2581 is \u2581 \" , \" % .4f \" % trapezoidal ( x0 , xn , n ) ) NEW_LINE"}
{"id": "codeforces_526_A", "sol": 0, "python_code": "from math import ceil\nn , level = int ( input ( ) ) , input ( )\nprint ( ( 'no' , 'yes' ) [ any ( '*****' in level [ start : : jump ] for jump in range ( 1 , ceil ( n / 4 ) ) for start in [ i for i in range ( n ) if level [ i ] == '*' ] ) ] )\n", "python_code_tokenized": "from math import ceil NEW_LINE n , level = int ( input ( ) ) , input ( ) NEW_LINE print ( ( ' no ' , ' yes ' ) [ any ( ' * * * * * ' in level [ start : : jump ] for jump in range ( 1 , ceil ( n / 4 ) ) for start in [ i for i in range ( n ) if level [ i ] == ' * ' ] ) ] ) NEW_LINE"}
{"id": "aizu_p00007_A", "sol": 0, "python_code": "from math import ceil\nn = int ( input ( ) )\ndebt = 100000\nfor i in range ( 0 , n ) :\n    debt = debt * 1.05\n    debt = int ( ceil ( debt / 1000.0 ) * 1000.0 )\nprint ( debt )\n", "python_code_tokenized": "from math import ceil NEW_LINE n = int ( input ( ) ) NEW_LINE debt = 100000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT debt = debt * 1.05 NEW_LINE debt = int ( ceil ( debt / 1000.0 ) * 1000.0 ) NEW_LINE DEDENT print ( debt ) NEW_LINE"}
{"id": "geeksforgeeks_1907_A", "sol": 0, "python_code": "mod = 1000000007\ndef power ( x , y , p ) :\n    res = 1\n    x = x % p\n    while ( y > 0 ) :\n        if ( y & 1 ) :\n            res = ( res * x ) % p\n        y = y >> 1\n        x = ( x * x ) % p\n    return res\ndef findCount ( N ) :\n    count = power ( 2 , N , mod )\n    return count\nif __name__ == '__main__' :\n    N = 25\n    print ( findCount ( N ) )\n", "python_code_tokenized": "mod = 1000000007 NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def findCount ( N ) : NEW_LINE INDENT count = power ( 2 , N , mod ) NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 25 NEW_LINE print ( findCount ( N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5040_A", "sol": 0, "python_code": "def reachTarget ( target ) :\n    target = abs ( target )\n    sum = 0\n    step = 0\n    while ( sum < target or ( sum - target ) % 2 != 0 ) :\n        step = step + 1\n        sum = sum + step\n    return step\ntarget = 5\nprint ( reachTarget ( target ) )\n", "python_code_tokenized": "def reachTarget ( target ) : NEW_LINE INDENT target = abs ( target ) NEW_LINE sum = 0 NEW_LINE step = 0 NEW_LINE while ( sum < target or ( sum - target ) % 2 != 0 ) : NEW_LINE INDENT step = step + 1 NEW_LINE sum = sum + step NEW_LINE DEDENT return step NEW_LINE DEDENT target = 5 NEW_LINE print ( reachTarget ( target ) ) NEW_LINE"}
{"id": "geeksforgeeks_3190_A", "sol": 0, "python_code": "def largestSubset ( a , n ) :\n    a.sort ( )\n    dp = [ 0 for i in range ( n ) ]\n    dp [ n - 1 ] = 1 ;\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        mxm = 0 ;\n        for j in range ( i + 1 , n ) :\n            if a [ j ] % a [ i ] == 0 :\n                mxm = max ( mxm , dp [ j ] )\n        dp [ i ] = 1 + mxm\n    return max ( dp )\na = [ 1 , 3 , 6 , 13 , 17 , 18 ]\nn = len ( a )\nprint ( largestSubset ( a , n ) )\n", "python_code_tokenized": "def largestSubset ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE dp = [ 0 for i in range ( n ) ] NEW_LINE dp [ n - 1 ] = 1 ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ j ] % a [ i ] == 0 : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT a = [ 1 , 3 , 6 , 13 , 17 , 18 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestSubset ( a , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4324_A", "sol": 0, "python_code": "def isValidISBN ( isbn ) :\n    if len ( isbn ) != 10 :\n        return False\n    _sum = 0\n    for i in range ( 9 ) :\n        if 0 <= int ( isbn [ i ] ) <= 9 :\n            _sum += int ( isbn [ i ] ) * ( 10 - i )\n        else :\n            return False\n    if ( isbn [ 9 ] != 'X' and 0 <= int ( isbn [ 9 ] ) <= 9 ) :\n        return False\n    _sum += 10 if isbn [ 9 ] == 'X' else int ( isbn [ 9 ] )\n    return ( _sum % 11 == 0 )\nisbn = \"007462542X\"\nif isValidISBN ( isbn ) :\n    print ( 'Valid' )\nelse :\n    print ( \"Invalid\" )\n", "python_code_tokenized": "def isValidISBN ( isbn ) : NEW_LINE INDENT if len ( isbn ) != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT _sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if 0 <= int ( isbn [ i ] ) <= 9 : NEW_LINE INDENT _sum += int ( isbn [ i ] ) * ( 10 - i ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( isbn [ 9 ] != ' X ' and 0 <= int ( isbn [ 9 ] ) <= 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT _sum += 10 if isbn [ 9 ] == ' X ' else int ( isbn [ 9 ] ) NEW_LINE return ( _sum % 11 == 0 ) NEW_LINE DEDENT isbn = \"007462542X \" NEW_LINE if isValidISBN ( isbn ) : NEW_LINE INDENT print ( ' Valid ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1031_A", "sol": 0, "python_code": "from math import sqrt ;\ndef isPalindrome ( n ) :\n    string = str ( n ) ;\n    s = 0 ; e = len ( string ) - 1 ;\n    while ( s < e ) :\n        if ( string [ s ] != string [ e ] ) :\n            return False ;\n        s += 1 ;\n        e -= 1 ;\n    return True ;\ndef palindromicDivisors ( n ) :\n    PalindromDivisors = [ ] ;\n    for i in range ( 1 , int ( sqrt ( n ) ) ) :\n        if ( n % i == 0 ) :\n            if ( n // i == i ) :\n                if ( isPalindrome ( i ) ) :\n                    PalindromDivisors.append ( i ) ;\n            else :\n                if ( isPalindrome ( i ) ) :\n                    PalindromDivisors.append ( i ) ;\n                if ( isPalindrome ( n // i ) ) :\n                    PalindromDivisors.append ( n // i ) ;\n    PalindromDivisors.sort ( ) ;\n    for i in range ( len ( PalindromDivisors ) ) :\n        print ( PalindromDivisors [ i ] , end = \" \" ) ;\nif __name__ == \"__main__\" :\n    n = 66 ;\n    palindromicDivisors ( n ) ;\n", "python_code_tokenized": "from math import sqrt ; NEW_LINE def isPalindrome ( n ) : NEW_LINE INDENT string = str ( n ) ; NEW_LINE s = 0 ; e = len ( string ) - 1 ; NEW_LINE while ( s < e ) : NEW_LINE INDENT if ( string [ s ] != string [ e ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT s += 1 ; NEW_LINE e -= 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def palindromicDivisors ( n ) : NEW_LINE INDENT PalindromDivisors = [ ] ; NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT if ( isPalindrome ( i ) ) : NEW_LINE INDENT PalindromDivisors . append ( i ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( isPalindrome ( i ) ) : NEW_LINE INDENT PalindromDivisors . append ( i ) ; NEW_LINE DEDENT if ( isPalindrome ( n // i ) ) : NEW_LINE INDENT PalindromDivisors . append ( n // i ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT PalindromDivisors . sort ( ) ; NEW_LINE for i in range ( len ( PalindromDivisors ) ) : NEW_LINE INDENT print ( PalindromDivisors [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 66 ; NEW_LINE palindromicDivisors ( n ) ; NEW_LINE DEDENT"}
{"id": "codeforces_982_B", "sol": 0, "python_code": "import sys\nfrom collections import deque\nif __name__ == \"__main__\" :\n    r = int ( sys.stdin.readline ( ) )\n    s = [ 0 ] * r\n    sw = list ( map ( int , sys.stdin.readline ( ).split ( ) ) )\n    ps = sys.stdin.readline ( ).strip ( )\n    ll = len ( ps )\n    d = { }\n    for z in range ( r ) :\n        d [ sw [ z ] ] = z\n    sw.sort ( )\n    it = sw\n    et = deque ( )\n    swc = 0\n    for p in range ( ll ) :\n        if ps [ p ] == '0' :\n            seat = it [ swc ]\n            ri = d [ it [ swc ] ]\n            print ( ri + 1 , end = ' ' )\n            et.append ( seat )\n            swc += 1\n        else :\n            print ( d [ et [ - 1 ] ] + 1 , end = ' ' )\n            et.pop ( )\n", "python_code_tokenized": "import sys NEW_LINE from collections import deque NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT r = int ( sys . stdin . readline ( ) ) NEW_LINE s = [ 0 ] * r NEW_LINE sw = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE ps = sys . stdin . readline ( ) . strip ( ) NEW_LINE ll = len ( ps ) NEW_LINE d = { } NEW_LINE for z in range ( r ) : NEW_LINE INDENT d [ sw [ z ] ] = z NEW_LINE DEDENT sw . sort ( ) NEW_LINE it = sw NEW_LINE et = deque ( ) NEW_LINE swc = 0 NEW_LINE for p in range ( ll ) : NEW_LINE INDENT if ps [ p ] == '0' : NEW_LINE INDENT seat = it [ swc ] NEW_LINE ri = d [ it [ swc ] ] NEW_LINE print ( ri + 1 , end = ' \u2581 ' ) NEW_LINE et . append ( seat ) NEW_LINE swc += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( d [ et [ - 1 ] ] + 1 , end = ' \u2581 ' ) NEW_LINE et . pop ( ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "codejam_15_32", "sol": 0, "python_code": "import sys\niFile = open ( sys.argv [ 1 ] , \"r\" )\nT = int ( iFile.readline ( ).strip ( ) )\nfor t in range ( T ) :\n    line = iFile.readline ( ).strip ( ).split ( )\n    K = int ( line [ 0 ] )\n    L = int ( line [ 1 ] )\n    S = int ( line [ 2 ] )\n    keyboard = iFile.readline ( ).strip ( )\n    target = iFile.readline ( ).strip ( )\n    effectiveLength = len ( target )\n    for strPos in range ( 1 , len ( target ) ) :\n        if target [ strPos : ] == target [ : - strPos ] :\n            effectiveLength = strPos\n            break\n    max_bananas = 1 + int ( ( S - len ( target ) ) / effectiveLength )\n    single_prob = 1.0\n    for letter in target :\n        if letter in keyboard :\n            single_prob *= keyboard.count ( letter ) / len ( keyboard )\n        else :\n            single_prob = 0.0\n            max_bananas = 0\n            break\n    total_prob = single_prob * ( S - len ( target ) + 1 )\n    answer = max_bananas - total_prob\n    output = str ( answer )\n    print ( \"Case #\" + str ( t + 1 ) + \": \" + output )\n", "python_code_tokenized": "import sys NEW_LINE iFile = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE T = int ( iFile . readline ( ) . strip ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT line = iFile . readline ( ) . strip ( ) . split ( ) NEW_LINE K = int ( line [ 0 ] ) NEW_LINE L = int ( line [ 1 ] ) NEW_LINE S = int ( line [ 2 ] ) NEW_LINE keyboard = iFile . readline ( ) . strip ( ) NEW_LINE target = iFile . readline ( ) . strip ( ) NEW_LINE effectiveLength = len ( target ) NEW_LINE for strPos in range ( 1 , len ( target ) ) : NEW_LINE INDENT if target [ strPos : ] == target [ : - strPos ] : NEW_LINE INDENT effectiveLength = strPos NEW_LINE break NEW_LINE DEDENT DEDENT max_bananas = 1 + int ( ( S - len ( target ) ) / effectiveLength ) NEW_LINE single_prob = 1.0 NEW_LINE for letter in target : NEW_LINE INDENT if letter in keyboard : NEW_LINE INDENT single_prob *= keyboard . count ( letter ) / len ( keyboard ) NEW_LINE DEDENT else : NEW_LINE INDENT single_prob = 0.0 NEW_LINE max_bananas = 0 NEW_LINE break NEW_LINE DEDENT DEDENT total_prob = single_prob * ( S - len ( target ) + 1 ) NEW_LINE answer = max_bananas - total_prob NEW_LINE output = str ( answer ) NEW_LINE print ( \" Case \u2581 # \" + str ( t + 1 ) + \" : \u2581 \" + output ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3282_A", "sol": 0, "python_code": "def LucasSum ( N ) :\n    Sum = 0\n    a = 2\n    b = 1\n    c = 0\n    Sum += a\n    while ( b <= N ) :\n        Sum += b\n        c = a + b\n        a = b\n        b = c\n    return Sum\nN = 20\nprint ( LucasSum ( N ) )\n", "python_code_tokenized": "def LucasSum ( N ) : NEW_LINE INDENT Sum = 0 NEW_LINE a = 2 NEW_LINE b = 1 NEW_LINE c = 0 NEW_LINE Sum += a NEW_LINE while ( b <= N ) : NEW_LINE INDENT Sum += b NEW_LINE c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return Sum NEW_LINE DEDENT N = 20 NEW_LINE print ( LucasSum ( N ) ) NEW_LINE"}
{"id": "geeksforgeeks_3967_A", "sol": 0, "python_code": "import numpy as np\ndef solve ( dp , wt , K , M , used ) :\n    if ( wt < 0 ) :\n        return 0\n    if ( wt == 0 ) :\n        if ( used ) :\n            return 1\n        return 0\n    if ( dp [ wt ] [ used ] != - 1 ) :\n        return dp [ wt ] [ used ]\n    ans = 0\n    for i in range ( 1 , K + 1 ) :\n        if ( i >= M ) :\n            ans += solve ( dp , wt - i , K , M , used | 1 )\n        else :\n            ans += solve ( dp , wt - i , K , M , used )\n    dp [ wt ] [ used ] = ans\n    return ans\nif __name__ == \"__main__\" :\n    W = 3\n    K = 3\n    M = 2\n    dp = np.ones ( ( W + 1 , 2 ) ) ;\n    dp = - 1 * dp\n    print ( solve ( dp , W , K , M , 0 ) )\n", "python_code_tokenized": "import numpy as np NEW_LINE def solve ( dp , wt , K , M , used ) : NEW_LINE INDENT if ( wt < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt == 0 ) : NEW_LINE INDENT if ( used ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ wt ] [ used ] != - 1 ) : NEW_LINE INDENT return dp [ wt ] [ used ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( i >= M ) : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used | 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used ) NEW_LINE DEDENT DEDENT dp [ wt ] [ used ] = ans NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT W = 3 NEW_LINE K = 3 NEW_LINE M = 2 NEW_LINE dp = np . ones ( ( W + 1 , 2 ) ) ; NEW_LINE dp = - 1 * dp NEW_LINE print ( solve ( dp , W , K , M , 0 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2484_A", "sol": 0, "python_code": "import math\nclass Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.next = None\ndef getNode ( data ) :\n    newNode = Node ( data )\n    newNode.data = data\n    return newNode\ndef insertEnd ( head , new_node ) :\n    if ( head == None ) :\n        new_node.next = new_node\n        new_node.prev = new_node\n        head = new_node\n        return head\n    last = head.prev\n    new_node.next = head\n    head.prev = new_node\n    new_node.prev = last\n    last.next = new_node\n    return head\ndef reverse ( head ) :\n    if ( head == None ) :\n        return None\n    new_head = None\n    last = head.prev\n    curr = last\n    while ( curr.prev != last ) :\n        prev = curr.prev\n        new_head = insertEnd ( new_head , curr )\n        curr = prev\n    new_head = insertEnd ( new_head , curr )\n    return new_head\ndef display ( head ) :\n    if ( head == None ) :\n        return\n    temp = head\n    print ( \"Forward direction: \" , end = \"\" )\n    while ( temp.next != head ) :\n        print ( temp.data , end = \"\" )\n        temp = temp.next\n    print ( temp.data )\n    last = head.prev\n    temp = last\n    print ( \"Backward direction: \" , end = \"\" )\n    while ( temp.prev != last ) :\n        print ( temp.data , end = \"\" )\n        temp = temp.prev\n    print ( temp.data )\nif __name__ == '__main__' :\n    head = None\n    head = insertEnd ( head , getNode ( 1 ) )\n    head = insertEnd ( head , getNode ( 2 ) )\n    head = insertEnd ( head , getNode ( 3 ) )\n    head = insertEnd ( head , getNode ( 4 ) )\n    head = insertEnd ( head , getNode ( 5 ) )\n    print ( \"Current list:\" )\n    display ( head )\n    head = reverse ( head )\n    print ( \"\\nReversed list:\" )\n    display ( head )\n", "python_code_tokenized": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def getNode ( data ) : NEW_LINE INDENT newNode = Node ( data ) NEW_LINE newNode . data = data NEW_LINE return newNode NEW_LINE DEDENT def insertEnd ( head , new_node ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT new_node . next = new_node NEW_LINE new_node . prev = new_node NEW_LINE head = new_node NEW_LINE return head NEW_LINE DEDENT last = head . prev NEW_LINE new_node . next = head NEW_LINE head . prev = new_node NEW_LINE new_node . prev = last NEW_LINE last . next = new_node NEW_LINE return head NEW_LINE DEDENT def reverse ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT new_head = None NEW_LINE last = head . prev NEW_LINE curr = last NEW_LINE while ( curr . prev != last ) : NEW_LINE INDENT prev = curr . prev NEW_LINE new_head = insertEnd ( new_head , curr ) NEW_LINE curr = prev NEW_LINE DEDENT new_head = insertEnd ( new_head , curr ) NEW_LINE return new_head NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE print ( \" Forward \u2581 direction : \u2581 \" , end = \" \" ) NEW_LINE while ( temp . next != head ) : NEW_LINE INDENT print ( temp . data , end = \" \u2581 \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data ) NEW_LINE last = head . prev NEW_LINE temp = last NEW_LINE print ( \" Backward \u2581 direction : \u2581 \" , end = \" \" ) NEW_LINE while ( temp . prev != last ) : NEW_LINE INDENT print ( temp . data , end = \" \u2581 \" ) NEW_LINE temp = temp . prev NEW_LINE DEDENT print ( temp . data ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = insertEnd ( head , getNode ( 1 ) ) NEW_LINE head = insertEnd ( head , getNode ( 2 ) ) NEW_LINE head = insertEnd ( head , getNode ( 3 ) ) NEW_LINE head = insertEnd ( head , getNode ( 4 ) ) NEW_LINE head = insertEnd ( head , getNode ( 5 ) ) NEW_LINE print ( \" Current \u2581 list : \" ) NEW_LINE display ( head ) NEW_LINE head = reverse ( head ) NEW_LINE print ( \" \\n Reversed \u2581 list : \" ) NEW_LINE display ( head ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3189_A", "sol": 0, "python_code": "def avgRec ( a , i , n ) :\n    if i == n - 1 :\n        return a [ i ]\n    if i == 0 :\n        return ( ( a [ i ] + avgRec ( a , i + 1 , n ) ) / n )\n    return ( a [ i ] + avgRec ( a , i + 1 , n ) )\ndef average ( a , n ) :\n    return avgRec ( a , 0 , n )\narr = [ 10 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]\nn = len ( arr )\nprint ( average ( arr , n ) )\n", "python_code_tokenized": "def avgRec ( a , i , n ) : NEW_LINE INDENT if i == n - 1 : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT return ( ( a [ i ] + avgRec ( a , i + 1 , n ) ) / n ) NEW_LINE DEDENT return ( a [ i ] + avgRec ( a , i + 1 , n ) ) NEW_LINE DEDENT def average ( a , n ) : NEW_LINE INDENT return avgRec ( a , 0 , n ) NEW_LINE DEDENT arr = [ 10 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( average ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2561_A", "sol": 0, "python_code": "import math\ndef substringConversions ( s , k , b ) :\n    l = len ( s ) ;\n    for i in range ( l ) :\n        if ( ( i + k ) < l + 1 ) :\n            sub = s [ i : i + k ] ;\n            sum , counter = 0 , 0 ;\n            for i in range ( len ( sub ) - 1 , - 1 , - 1 ) :\n                sum = sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ;\n                counter += 1 ;\n            print ( sum , end = \" \" ) ;\ns = \"12212\" ;\nb , k = 3 , 3 ;\nsubstringConversions ( s , b , k ) ;\n", "python_code_tokenized": "import math NEW_LINE def substringConversions ( s , k , b ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ( i + k ) < l + 1 ) : NEW_LINE INDENT sub = s [ i : i + k ] ; NEW_LINE sum , counter = 0 , 0 ; NEW_LINE for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ; NEW_LINE counter += 1 ; NEW_LINE DEDENT print ( sum , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT DEDENT s = \"12212\" ; NEW_LINE b , k = 3 , 3 ; NEW_LINE substringConversions ( s , b , k ) ; NEW_LINE"}
{"id": "atcoder_ARC078_C", "sol": 0, "python_code": "def binsearch ( l , r , pred ) :\n    assert l < r\n    l -= 1\n    while r - l > 1 :\n        m = ( l + r ) // 2\n        if pred ( m ) :\n            r = m\n        else :\n            l = m\n    return r\nimport sys\ndef pred ( n ) :\n    assert 1 <= n and n <= 10 ** 18\n    print ( '?' , n )\n    sys.stdout.flush ( )\n    return input ( ) == 'Y'\ndef solve ( ) :\n    s = ''\n    s += str ( binsearch ( 1 , 9 + 1 , lambda c : not pred ( int ( s + str ( c ) ) ) ) - 1 )\n    if s == '9' :\n        f = lambda k : pred ( int ( '1' + '0' * k ) )\n    else :\n        f = lambda k : not pred ( int ( '9' * k ) )\n    k = 1\n    while f ( k ) :\n        k += 1\n        if k >= 13 :\n            return 1\n    if k == 1 :\n        return binsearch ( 1 , 9 + 1 , lambda c : pred ( int ( str ( c ) + '0' ) ) )\n    else :\n        for _ in range ( k - 2 ) :\n            s += str ( binsearch ( 0 , 9 + 1 , lambda c : not pred ( int ( s + str ( c ) ) ) ) - 1 )\n        s += str ( binsearch ( 0 , 9 + 1 , lambda c : pred ( int ( s + str ( c ) + '0' ) ) ) )\n    return int ( s )\nprint ( '!' , solve ( ) )\n", "python_code_tokenized": "def binsearch ( l , r , pred ) : NEW_LINE INDENT assert l < r NEW_LINE l -= 1 NEW_LINE while r - l > 1 : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if pred ( m ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT import sys NEW_LINE def pred ( n ) : NEW_LINE INDENT assert 1 <= n and n <= 10 ** 18 NEW_LINE print ( ' ? ' , n ) NEW_LINE sys . stdout . flush ( ) NEW_LINE return input ( ) == ' Y ' NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT s = ' ' NEW_LINE s += str ( binsearch ( 1 , 9 + 1 , lambda c : not pred ( int ( s + str ( c ) ) ) ) - 1 ) NEW_LINE if s == '9' : NEW_LINE INDENT f = lambda k : pred ( int ( '1' + '0' * k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f = lambda k : not pred ( int ( '9' * k ) ) NEW_LINE DEDENT k = 1 NEW_LINE while f ( k ) : NEW_LINE INDENT k += 1 NEW_LINE if k >= 13 : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if k == 1 : NEW_LINE INDENT return binsearch ( 1 , 9 + 1 , lambda c : pred ( int ( str ( c ) + '0' ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT for _ in range ( k - 2 ) : NEW_LINE INDENT s += str ( binsearch ( 0 , 9 + 1 , lambda c : not pred ( int ( s + str ( c ) ) ) ) - 1 ) NEW_LINE DEDENT s += str ( binsearch ( 0 , 9 + 1 , lambda c : pred ( int ( s + str ( c ) + '0' ) ) ) ) NEW_LINE DEDENT return int ( s ) NEW_LINE DEDENT print ( ' ! ' , solve ( ) ) NEW_LINE"}
{"id": "geeksforgeeks_4790_A", "sol": 0, "python_code": "from math import sqrt\ndef maxPeople ( p ) :\n    tmp = 0 ; count = 0 ;\n    for i in range ( 1 , int ( sqrt ( p ) ) + 1 ) :\n        tmp = tmp + ( i * i ) ;\n        if ( tmp <= p ) :\n            count += 1 ;\n        else :\n            break ;\n    return count ;\nif __name__ == \"__main__\" :\n    p = 14 ;\n    print ( maxPeople ( p ) ) ;\n", "python_code_tokenized": "from math import sqrt NEW_LINE def maxPeople ( p ) : NEW_LINE INDENT tmp = 0 ; count = 0 ; NEW_LINE for i in range ( 1 , int ( sqrt ( p ) ) + 1 ) : NEW_LINE INDENT tmp = tmp + ( i * i ) ; NEW_LINE if ( tmp <= p ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p = 14 ; NEW_LINE print ( maxPeople ( p ) ) ; NEW_LINE DEDENT"}
{"id": "atcoder_AGC011_A", "sol": 0, "python_code": "N , C , K = map ( int , input ( ).split ( ) )\nT = [ ]\nfor i in range ( N ) :\n    T.append ( int ( input ( ) ) )\nT.sort ( )\nidx = 0\nbus = 0\nwhile ( True ) :\n    if idx == N :\n        break\n    bus += 1\n    limit = T [ idx ] + K\n    for c in range ( idx , idx + C ) :\n        if idx == N :\n            break\n        dep = T [ c ]\n        if dep <= limit :\n            idx += 1\n            continue\n        else :\n            break\nprint ( bus )\n", "python_code_tokenized": "N , C , K = map ( int , input ( ) . split ( ) ) NEW_LINE T = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT T . append ( int ( input ( ) ) ) NEW_LINE DEDENT T . sort ( ) NEW_LINE idx = 0 NEW_LINE bus = 0 NEW_LINE while ( True ) : NEW_LINE INDENT if idx == N : NEW_LINE INDENT break NEW_LINE DEDENT bus += 1 NEW_LINE limit = T [ idx ] + K NEW_LINE for c in range ( idx , idx + C ) : NEW_LINE INDENT if idx == N : NEW_LINE INDENT break NEW_LINE DEDENT dep = T [ c ] NEW_LINE if dep <= limit : NEW_LINE INDENT idx += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( bus ) NEW_LINE"}
{"id": "codeforces_711_A", "sol": 0, "python_code": "kolvomest = int ( input ( ) )\nk = 0\nspisok = [ ]\nfor stroka in range ( kolvomest ) :\n    ryad = input ( )\n    if 'OO' in ryad and k == 0 :\n        k = 1\n        ryad = ryad.replace ( 'OO' , '++' , 1 )\n    spisok.append ( ryad )\nif k == 1 :\n    print ( 'YES' )\n    for stroka in range ( kolvomest ) :\n        print ( spisok [ stroka ] )\nelse :\n    print ( 'NO' )\n", "python_code_tokenized": "kolvomest = int ( input ( ) ) NEW_LINE k = 0 NEW_LINE spisok = [ ] NEW_LINE for stroka in range ( kolvomest ) : NEW_LINE INDENT ryad = input ( ) NEW_LINE if ' OO ' in ryad and k == 0 : NEW_LINE INDENT k = 1 NEW_LINE ryad = ryad . replace ( ' OO ' , ' + + ' , 1 ) NEW_LINE DEDENT spisok . append ( ryad ) NEW_LINE DEDENT if k == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE for stroka in range ( kolvomest ) : NEW_LINE INDENT print ( spisok [ stroka ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"}
{"id": "codeforces_729_A", "sol": 0, "python_code": "a = int ( input ( ) )\nb = input ( )\nfor x in range ( a // 2 + 1 , 0 , - 1 ) :\n    if 'og' * x + 'o' in b :\n        b = b.replace ( 'o' + 'go' * x , '***' )\nprint ( b )\n", "python_code_tokenized": "a = int ( input ( ) ) NEW_LINE b = input ( ) NEW_LINE for x in range ( a // 2 + 1 , 0 , - 1 ) : NEW_LINE INDENT if ' og ' * x + ' o ' in b : NEW_LINE INDENT b = b . replace ( ' o ' + ' go ' * x , ' * * * ' ) NEW_LINE DEDENT DEDENT print ( b ) NEW_LINE"}
{"id": "codeforces_354_A", "sol": 0, "python_code": "n , L , R , QL , QR = map ( int , input ( ).split ( ) )\nW = list ( map ( int , input ( ).split ( ) ) )\nsum_el = [ 0 ]\nfor i in range ( 1 , n + 1 ) :\n    sum_el.append ( W [ i - 1 ] + sum_el [ i - 1 ] )\nanswer = QR * ( n - 1 ) + sum_el [ n ] * R\nfor i in range ( 1 , n + 1 ) :\n    energy = L * sum_el [ i ] + R * ( sum_el [ n ] - sum_el [ i ] )\n    if i > ( n - i ) :\n        energy = energy + ( i - ( n - i ) - 1 ) * QL\n    elif ( n - i ) > i :\n        energy = energy + ( ( n - i ) - i - 1 ) * QR\n    if energy < answer :\n        answer = energy\nprint ( answer )\n", "python_code_tokenized": "n , L , R , QL , QR = map ( int , input ( ) . split ( ) ) NEW_LINE W = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum_el = [ 0 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum_el . append ( W [ i - 1 ] + sum_el [ i - 1 ] ) NEW_LINE DEDENT answer = QR * ( n - 1 ) + sum_el [ n ] * R NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT energy = L * sum_el [ i ] + R * ( sum_el [ n ] - sum_el [ i ] ) NEW_LINE if i > ( n - i ) : NEW_LINE INDENT energy = energy + ( i - ( n - i ) - 1 ) * QL NEW_LINE DEDENT elif ( n - i ) > i : NEW_LINE INDENT energy = energy + ( ( n - i ) - i - 1 ) * QR NEW_LINE DEDENT if energy < answer : NEW_LINE INDENT answer = energy NEW_LINE DEDENT DEDENT print ( answer ) NEW_LINE"}
{"id": "geeksforgeeks_674_A", "sol": 0, "python_code": "import math\ndef CheckArray ( arr , n ) :\n    prod = 1\n    freq = [ ]\n    for i in range ( n ) :\n        freq.append ( arr [ i ] )\n        prod *= arr [ i ]\n    root = math.sqrt ( prod )\n    if ( root * root == prod ) :\n        if root in freq :\n            return True\n    return False\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 12 , 3 , 2 ]\n    n = len ( arr )\n    if ( CheckArray ( arr , n ) ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "import math NEW_LINE def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE freq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq . append ( arr [ i ] ) NEW_LINE prod *= arr [ i ] NEW_LINE DEDENT root = math . sqrt ( prod ) NEW_LINE if ( root * root == prod ) : NEW_LINE INDENT if root in freq : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 12 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2792_A", "sol": 0, "python_code": "def stringToInt ( str ) :\n    if ( len ( str ) == 1 ) :\n        return ord ( str [ 0 ] ) - ord ( '0' ) ;\n    y = stringToInt ( str [ 1 : ] ) ;\n    x = ord ( str [ 0 ] ) - ord ( '0' ) ;\n    x = x * ( 10 ** ( len ( str ) - 1 ) ) + y ;\n    return int ( x ) ;\nif __name__ == '__main__' :\n    str = \"1235\" ;\n    print ( stringToInt ( str ) ) ;\n", "python_code_tokenized": "def stringToInt ( str ) : NEW_LINE INDENT if ( len ( str ) == 1 ) : NEW_LINE INDENT return ord ( str [ 0 ] ) - ord ( '0' ) ; NEW_LINE DEDENT y = stringToInt ( str [ 1 : ] ) ; NEW_LINE x = ord ( str [ 0 ] ) - ord ( '0' ) ; NEW_LINE x = x * ( 10 ** ( len ( str ) - 1 ) ) + y ; NEW_LINE return int ( x ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"1235\" ; NEW_LINE print ( stringToInt ( str ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_520_B", "sol": 0, "python_code": "from math import log2\nn , m = [ int ( i ) for i in input ( ).split ( ) ]\nqueue = [ [ n , 0 ] ]\nmaxn = 10e4\nred = lambda x : x * 2\nblue = lambda x : x - 1\nmemoized_values = set ( )\nwhile queue :\n    current_n , buttons_pressed = queue.pop ( 0 )\n    if current_n == m :\n        print ( buttons_pressed )\n        break\n    if blue ( current_n ) not in memoized_values and blue ( current_n ) > 0 :\n        memoized_values.add ( blue ( current_n ) )\n        queue.append ( [ blue ( current_n ) , buttons_pressed + 1 ] )\n    if red ( current_n ) not in memoized_values and red ( current_n ) <= maxn :\n        memoized_values.add ( red ( current_n ) )\n        queue.append ( [ red ( current_n ) , buttons_pressed + 1 ] )\n", "python_code_tokenized": "from math import log2 NEW_LINE n , m = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE queue = [ [ n , 0 ] ] NEW_LINE maxn = 10e4 NEW_LINE red = lambda x : x * 2 NEW_LINE blue = lambda x : x - 1 NEW_LINE memoized_values = set ( ) NEW_LINE while queue : NEW_LINE INDENT current_n , buttons_pressed = queue . pop ( 0 ) NEW_LINE if current_n == m : NEW_LINE INDENT print ( buttons_pressed ) NEW_LINE break NEW_LINE DEDENT if blue ( current_n ) not in memoized_values and blue ( current_n ) > 0 : NEW_LINE INDENT memoized_values . add ( blue ( current_n ) ) NEW_LINE queue . append ( [ blue ( current_n ) , buttons_pressed + 1 ] ) NEW_LINE DEDENT if red ( current_n ) not in memoized_values and red ( current_n ) <= maxn : NEW_LINE INDENT memoized_values . add ( red ( current_n ) ) NEW_LINE queue . append ( [ red ( current_n ) , buttons_pressed + 1 ] ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3807_A", "sol": 0, "python_code": "import sys\nimport math\nclass Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.next = None\ndef push ( head , data ) :\n    if not head :\n        return Node ( data )\n    temp = Node ( data )\n    temp.next = head\n    head = temp\n    return head\ndef countMinimun ( head ) :\n    freq = { }\n    temp = head\n    while ( temp ) :\n        d = temp.data\n        if d in freq :\n            freq [ d ] = freq.get ( d ) + 1\n        else :\n            freq [ d ] = 1\n        temp = temp.next\n    minimum_freq = sys.maxsize\n    for i in freq :\n        minimum_freq = min ( minimum_freq , freq.get ( i ) )\n    countMin = 0\n    for i in freq :\n        if freq.get ( i ) == minimum_freq :\n            countMin += 1\n    return countMin\nif __name__ == '__main__' :\n    head = None\n    head = push ( head , 10 )\n    head = push ( head , 30 )\n    head = push ( head , 11 )\n    head = push ( head , 10 )\n    head = push ( head , 10 )\n    print ( countMinimun ( head ) )\n", "python_code_tokenized": "import sys NEW_LINE import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head , data ) : NEW_LINE INDENT if not head : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT temp = Node ( data ) NEW_LINE temp . next = head NEW_LINE head = temp NEW_LINE return head NEW_LINE DEDENT def countMinimun ( head ) : NEW_LINE INDENT freq = { } NEW_LINE temp = head NEW_LINE while ( temp ) : NEW_LINE INDENT d = temp . data NEW_LINE if d in freq : NEW_LINE INDENT freq [ d ] = freq . get ( d ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ d ] = 1 NEW_LINE DEDENT temp = temp . next NEW_LINE DEDENT minimum_freq = sys . maxsize NEW_LINE for i in freq : NEW_LINE INDENT minimum_freq = min ( minimum_freq , freq . get ( i ) ) NEW_LINE DEDENT countMin = 0 NEW_LINE for i in freq : NEW_LINE INDENT if freq . get ( i ) == minimum_freq : NEW_LINE INDENT countMin += 1 NEW_LINE DEDENT DEDENT return countMin NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 10 ) NEW_LINE head = push ( head , 30 ) NEW_LINE head = push ( head , 11 ) NEW_LINE head = push ( head , 10 ) NEW_LINE head = push ( head , 10 ) NEW_LINE print ( countMinimun ( head ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3272_A", "sol": 0, "python_code": "def power ( a , n ) :\n    if n == 0 :\n        return 1\n    p = power ( a , n // 2 )\n    p = p * p\n    if n & 1 :\n        p = p * a\n    return p\ndef countIntegers ( l , r ) :\n    ans , i = 0 , 1\n    v = power ( 2 , i )\n    while v <= r :\n        while v <= r :\n            if v >= l :\n                ans += 1\n            v = v * 3\n        i += 1\n        v = power ( 2 , i )\n    if l == 1 :\n        ans += 1\n    return ans\nif __name__ == \"__main__\" :\n    l , r = 12 , 21\n    print ( countIntegers ( l , r ) )\n", "python_code_tokenized": "def power ( a , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , n // 2 ) NEW_LINE p = p * p NEW_LINE if n & 1 : NEW_LINE INDENT p = p * a NEW_LINE DEDENT return p NEW_LINE DEDENT def countIntegers ( l , r ) : NEW_LINE INDENT ans , i = 0 , 1 NEW_LINE v = power ( 2 , i ) NEW_LINE while v <= r : NEW_LINE INDENT while v <= r : NEW_LINE INDENT if v >= l : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT v = v * 3 NEW_LINE DEDENT i += 1 NEW_LINE v = power ( 2 , i ) NEW_LINE DEDENT if l == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l , r = 12 , 21 NEW_LINE print ( countIntegers ( l , r ) ) NEW_LINE DEDENT"}
{"id": "codeforces_740_B", "sol": 0, "python_code": "n , m = [ int ( i ) for i in input ( ).split ( ) ]\nl = [ int ( i ) for i in input ( ).split ( ) ]\ncumSum = [ 0 ]\nfor i in range ( 1 , n + 1 ) :\n    v = cumSum [ i - 1 ] + l [ i - 1 ]\n    cumSum.append ( v )\ntotalSum = 0\nfor k in range ( m ) :\n    i , j = [ int ( i ) for i in input ( ).split ( ) ]\n    resSum = cumSum [ j ] - cumSum [ i - 1 ]\n    if ( resSum > 0 ) :\n        totalSum += resSum\nprint ( totalSum )\n", "python_code_tokenized": "n , m = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE l = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE cumSum = [ 0 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT v = cumSum [ i - 1 ] + l [ i - 1 ] NEW_LINE cumSum . append ( v ) NEW_LINE DEDENT totalSum = 0 NEW_LINE for k in range ( m ) : NEW_LINE INDENT i , j = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE resSum = cumSum [ j ] - cumSum [ i - 1 ] NEW_LINE if ( resSum > 0 ) : NEW_LINE INDENT totalSum += resSum NEW_LINE DEDENT DEDENT print ( totalSum ) NEW_LINE"}
{"id": "geeksforgeeks_1002_A", "sol": 0, "python_code": "MAX = 10\ndef isDigit ( ch ) :\n    ch = ord ( ch )\n    if ( ch >= ord ( '0' ) and ch <= ord ( '9' ) ) :\n        return True\n    return False\ndef allDigits ( st , le ) :\n    present = [ False for i in range ( MAX ) ]\n    for i in range ( le ) :\n        if ( isDigit ( st [ i ] ) ) :\n            digit = ord ( st [ i ] ) - ord ( '0' )\n            present [ digit ] = True\n    for i in range ( MAX ) :\n        if ( present [ i ] == False ) :\n            return False\n    return True\nst = \"Geeks12345for69708\"\nle = len ( st )\nif ( allDigits ( st , le ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "MAX = 10 NEW_LINE def isDigit ( ch ) : NEW_LINE INDENT ch = ord ( ch ) NEW_LINE if ( ch >= ord ( '0' ) and ch <= ord ( '9' ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def allDigits ( st , le ) : NEW_LINE INDENT present = [ False for i in range ( MAX ) ] NEW_LINE for i in range ( le ) : NEW_LINE INDENT if ( isDigit ( st [ i ] ) ) : NEW_LINE INDENT digit = ord ( st [ i ] ) - ord ( '0' ) NEW_LINE present [ digit ] = True NEW_LINE DEDENT DEDENT for i in range ( MAX ) : NEW_LINE INDENT if ( present [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT st = \" Geeks12345for69708\" NEW_LINE le = len ( st ) NEW_LINE if ( allDigits ( st , le ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "codeforces_146_A", "sol": 0, "python_code": "num = int ( input ( ) )\nnum = input ( )\nlist_is = [ ]\nfor i in num :\n    list_is.append ( int ( i ) )\nlist_is1 = list_is [ : len ( list_is ) // 2 ]\nlist_is2 = list_is [ len ( list_is ) // 2 : ]\nsum1 = sum ( list_is1 )\nsum2 = sum ( list_is2 )\ncondition = False\nfor i in list_is :\n    if i == 4 or i == 7 :\n        condition = True\n        continue\n    else :\n        condition = False\n        break\nif condition == True :\n    if sum1 == sum2 :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "num = int ( input ( ) ) NEW_LINE num = input ( ) NEW_LINE list_is = [ ] NEW_LINE for i in num : NEW_LINE INDENT list_is . append ( int ( i ) ) NEW_LINE DEDENT list_is1 = list_is [ : len ( list_is ) // 2 ] NEW_LINE list_is2 = list_is [ len ( list_is ) // 2 : ] NEW_LINE sum1 = sum ( list_is1 ) NEW_LINE sum2 = sum ( list_is2 ) NEW_LINE condition = False NEW_LINE for i in list_is : NEW_LINE INDENT if i == 4 or i == 7 : NEW_LINE INDENT condition = True NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT condition = False NEW_LINE break NEW_LINE DEDENT DEDENT if condition == True : NEW_LINE INDENT if sum1 == sum2 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3540_A", "sol": 0, "python_code": "SIZE = 100\nMAX = 10000000\ndef minCells ( mat , m , n ) :\n    dp = [ [ MAX for i in range ( n ) ] for i in range ( m ) ]\n    dp [ 0 ] [ 0 ] = 1\n    for i in range ( m ) :\n        for j in range ( n ) :\n            if ( dp [ i ] [ j ] != MAX and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) :\n                dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1\n            if ( dp [ i ] [ j ] != MAX and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) :\n                dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1\n    if ( dp [ m - 1 ] [ n - 1 ] != MAX ) :\n        return dp [ m - 1 ] [ n - 1 ]\n    return - 1\nmat = [ [ 2 , 3 , 2 , 1 , 4 ] , [ 3 , 2 , 5 , 8 , 2 ] , [ 1 , 1 , 2 , 2 , 1 ] ]\nm = 3\nn = 5\nprint ( \"Minimum number of cells = \" , minCells ( mat , m , n ) )\n", "python_code_tokenized": "SIZE = 100 NEW_LINE MAX = 10000000 NEW_LINE def minCells ( mat , m , n ) : NEW_LINE INDENT dp = [ [ MAX for i in range ( n ) ] for i in range ( m ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( dp [ i ] [ j ] != MAX and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) : NEW_LINE INDENT dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT if ( dp [ i ] [ j ] != MAX and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) : NEW_LINE INDENT dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT if ( dp [ m - 1 ] [ n - 1 ] != MAX ) : NEW_LINE INDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT mat = [ [ 2 , 3 , 2 , 1 , 4 ] , [ 3 , 2 , 5 , 8 , 2 ] , [ 1 , 1 , 2 , 2 , 1 ] ] NEW_LINE m = 3 NEW_LINE n = 5 NEW_LINE print ( \" Minimum \u2581 number \u2581 of \u2581 cells \u2581 = \u2581 \" , minCells ( mat , m , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_545_A", "sol": 0, "python_code": "def maxnumber ( n , k ) :\n    for i in range ( 0 , k ) :\n        ans = 0\n        i = 1\n        while n // i > 0 :\n            temp = ( n // ( i * 10 ) ) * i + ( n % i )\n            i *= 10\n            if temp > ans :\n                ans = temp\n        n = ans\n    return ans ;\nn = 6358\nk = 1\nprint ( maxnumber ( n , k ) )\n", "python_code_tokenized": "def maxnumber ( n , k ) : NEW_LINE INDENT for i in range ( 0 , k ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 1 NEW_LINE while n // i > 0 : NEW_LINE INDENT temp = ( n // ( i * 10 ) ) * i + ( n % i ) NEW_LINE i *= 10 NEW_LINE if temp > ans : NEW_LINE INDENT ans = temp NEW_LINE DEDENT DEDENT n = ans NEW_LINE DEDENT return ans ; NEW_LINE DEDENT n = 6358 NEW_LINE k = 1 NEW_LINE print ( maxnumber ( n , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_2642_A", "sol": 0, "python_code": "def calculateSum ( n ) :\n    if ( n <= 0 ) :\n        return 0\n    fibo = [ 0 ] * ( n + 1 )\n    fibo [ 1 ] = 1\n    sm = fibo [ 0 ] + fibo [ 1 ]\n    for i in range ( 2 , n + 1 ) :\n        fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ]\n        sm = sm + fibo [ i ]\n    return sm\nn = 4\nprint ( \"Sum of Fibonacci numbers is : \" , calculateSum ( n ) )\n", "python_code_tokenized": "def calculateSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 1 ] = 1 NEW_LINE sm = fibo [ 0 ] + fibo [ 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE sm = sm + fibo [ i ] NEW_LINE DEDENT return sm NEW_LINE DEDENT n = 4 NEW_LINE print ( \" Sum \u2581 of \u2581 Fibonacci \u2581 numbers \u2581 is \u2581 : \u2581 \" , calculateSum ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4614_A", "sol": 0, "python_code": "import collections\ndef minimumBox ( arr , n ) :\n    q = collections.deque ( [ ] )\n    arr.sort ( )\n    q.append ( arr [ 0 ] )\n    for i in range ( 1 , n ) :\n        now = q [ 0 ]\n        if ( arr [ i ] >= 2 * now ) :\n            q.popleft ( )\n        q.append ( arr [ i ] )\n    return len ( q )\nif __name__ == '__main__' :\n    arr = [ 4 , 1 , 2 , 8 ]\n    n = len ( arr )\n    print ( minimumBox ( arr , n ) )\n", "python_code_tokenized": "import collections NEW_LINE def minimumBox ( arr , n ) : NEW_LINE INDENT q = collections . deque ( [ ] ) NEW_LINE arr . sort ( ) NEW_LINE q . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT now = q [ 0 ] NEW_LINE if ( arr [ i ] >= 2 * now ) : NEW_LINE INDENT q . popleft ( ) NEW_LINE DEDENT q . append ( arr [ i ] ) NEW_LINE DEDENT return len ( q ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 1 , 2 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumBox ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1492_A", "sol": 0, "python_code": "num = int ( input ( ) )\nnlist = [ ]\nmlist = [ ]\nt = True\nfor i in range ( num ) :\n    list1 = list ( map ( int , input ( ).split ( ) ) )\n    k = list1 [ 0 ]\n    n = 0\n    while t == True :\n        n = n + 1\n        if ( k % list1 [ n ] ) == 0 :\n            o = 0\n            mlist.append ( o )\n        elif ( k - list1 [ n ] ) > 0 :\n            i = 1\n            r = k // list1 [ n ]\n            i = list1 [ n ] * ( r + 1 )\n            h = k - i\n            o = h\n            o = int ( o )\n            o = abs ( o )\n            mlist.append ( o )\n        if ( k - list1 [ n ] ) < 0 :\n            o = k - list1 [ n ]\n            o = abs ( o )\n            mlist.append ( o )\n        if n == 3 :\n            break\n    m = min ( mlist )\n    nlist.append ( m )\n    mlist = [ ]\nprint ( * nlist , sep = '\\n' )\n", "python_code_tokenized": "num = int ( input ( ) ) NEW_LINE nlist = [ ] NEW_LINE mlist = [ ] NEW_LINE t = True NEW_LINE for i in range ( num ) : NEW_LINE INDENT list1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = list1 [ 0 ] NEW_LINE n = 0 NEW_LINE while t == True : NEW_LINE INDENT n = n + 1 NEW_LINE if ( k % list1 [ n ] ) == 0 : NEW_LINE INDENT o = 0 NEW_LINE mlist . append ( o ) NEW_LINE DEDENT elif ( k - list1 [ n ] ) > 0 : NEW_LINE INDENT i = 1 NEW_LINE r = k // list1 [ n ] NEW_LINE i = list1 [ n ] * ( r + 1 ) NEW_LINE h = k - i NEW_LINE o = h NEW_LINE o = int ( o ) NEW_LINE o = abs ( o ) NEW_LINE mlist . append ( o ) NEW_LINE DEDENT if ( k - list1 [ n ] ) < 0 : NEW_LINE INDENT o = k - list1 [ n ] NEW_LINE o = abs ( o ) NEW_LINE mlist . append ( o ) NEW_LINE DEDENT if n == 3 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT m = min ( mlist ) NEW_LINE nlist . append ( m ) NEW_LINE mlist = [ ] NEW_LINE DEDENT print ( * nlist , sep = ' \\n ' ) NEW_LINE"}
{"id": "geeksforgeeks_2571_A", "sol": 0, "python_code": "fact = [ 0 ] * 21\ndef preCompute ( ) :\n    fact [ 0 ] = 1\n    for i in range ( 1 , 18 ) :\n        fact [ i ] = ( fact [ i - 1 ] * i )\ndef nextFactorial ( N ) :\n    for i in range ( 21 ) :\n        if N < fact [ i ] :\n            print ( fact [ i ] )\n            break\npreCompute ( )\nN = 120\nnextFactorial ( N )\n", "python_code_tokenized": "fact = [ 0 ] * 21 NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , 18 ) : NEW_LINE INDENT fact [ i ] = ( fact [ i - 1 ] * i ) NEW_LINE DEDENT DEDENT def nextFactorial ( N ) : NEW_LINE INDENT for i in range ( 21 ) : NEW_LINE INDENT if N < fact [ i ] : NEW_LINE INDENT print ( fact [ i ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT preCompute ( ) NEW_LINE N = 120 NEW_LINE nextFactorial ( N ) NEW_LINE"}
{"id": "geeksforgeeks_3779_A", "sol": 0, "python_code": "seg = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ]\ndef computeSegment ( x ) :\n    if ( x == 0 ) :\n        return seg [ 0 ]\n    count = 0\n    while ( x ) :\n        count += seg [ x % 10 ]\n        x = x // 10\n    return count\ndef elementMinSegment ( arr , n ) :\n    minseg = computeSegment ( arr [ 0 ] )\n    minindex = 0\n    for i in range ( 1 , n ) :\n        temp = computeSegment ( arr [ i ] )\n        if ( temp < minseg ) :\n            minseg = temp\n            minindex = i\n    return arr [ minindex ]\narr = [ 489 , 206 , 745 , 123 , 756 ]\nn = len ( arr )\nprint ( elementMinSegment ( arr , n ) )\n", "python_code_tokenized": "seg = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] NEW_LINE def computeSegment ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return seg [ 0 ] NEW_LINE DEDENT count = 0 NEW_LINE while ( x ) : NEW_LINE INDENT count += seg [ x % 10 ] NEW_LINE x = x // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def elementMinSegment ( arr , n ) : NEW_LINE INDENT minseg = computeSegment ( arr [ 0 ] ) NEW_LINE minindex = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT temp = computeSegment ( arr [ i ] ) NEW_LINE if ( temp < minseg ) : NEW_LINE INDENT minseg = temp NEW_LINE minindex = i NEW_LINE DEDENT DEDENT return arr [ minindex ] NEW_LINE DEDENT arr = [ 489 , 206 , 745 , 123 , 756 ] NEW_LINE n = len ( arr ) NEW_LINE print ( elementMinSegment ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_724_A", "sol": 0, "python_code": "import sys , io , math\nfrom tokenize import Triple\nfrom math import *\nI = lambda : [ * map ( int , sys.stdin.readline ( ).split ( ) ) ]\nIS = lambda : input ( )\nIN = lambda : int ( input ( ) )\nIF = lambda : float ( input ( ) )\ndays = [ 28 , 30 , 31 ]\nweek = [ 'monday' , 'tuesday' , 'wednesday' , 'thursday' , 'friday' , 'saturday' , 'sunday' ]\na = IS ( )\nb = IS ( )\nfor index , name in enumerate ( week ) :\n    if name == a :\n        ind = index\nflag = False\nfor mo in days :\n    if week [ ( ind + mo ) % 7 ] == b :\n        flag = True\nif flag :\n    print ( 'YES' )\nelse :\n    print ( 'NO' )\n", "python_code_tokenized": "import sys , io , math NEW_LINE from tokenize import Triple NEW_LINE from math import * NEW_LINE I = lambda : [ * map ( int , sys . stdin . readline ( ) . split ( ) ) ] NEW_LINE IS = lambda : input ( ) NEW_LINE IN = lambda : int ( input ( ) ) NEW_LINE IF = lambda : float ( input ( ) ) NEW_LINE days = [ 28 , 30 , 31 ] NEW_LINE week = [ ' monday ' , ' tuesday ' , ' wednesday ' , ' thursday ' , ' friday ' , ' saturday ' , ' sunday ' ] NEW_LINE a = IS ( ) NEW_LINE b = IS ( ) NEW_LINE for index , name in enumerate ( week ) : NEW_LINE INDENT if name == a : NEW_LINE INDENT ind = index NEW_LINE DEDENT DEDENT flag = False NEW_LINE for mo in days : NEW_LINE INDENT if week [ ( ind + mo ) % 7 ] == b : NEW_LINE INDENT flag = True NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1280_A", "sol": 0, "python_code": "class Node :\n    def __init__ ( self , val ) :\n        self.data = val\n        self.left = None\n        self.right = None\nprev = None\ndef isbst ( root ) :\n    global prev\n    prev = None\n    return isbst_rec ( root )\ndef isbst_rec ( root ) :\n    global prev\n    if root is None :\n        return True\n    if isbst_rec ( root.left ) is False :\n        return False\n    if prev is not None and prev.data > root.data :\n        return False\n    prev = root\n    return isbst_rec ( root.right )\nroot = Node ( 4 )\nroot.left = Node ( 2 )\nroot.right = Node ( 5 )\nroot.left.left = Node ( 1 )\nroot.left.right = Node ( 3 )\nif isbst ( root ) :\n    print ( \"is BST\" )\nelse :\n    print ( \"not a BST\" )\n", "python_code_tokenized": "class Node : NEW_LINE INDENT def __init__ ( self , val ) : NEW_LINE INDENT self . data = val NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT prev = None NEW_LINE def isbst ( root ) : NEW_LINE INDENT global prev NEW_LINE prev = None NEW_LINE return isbst_rec ( root ) NEW_LINE DEDENT def isbst_rec ( root ) : NEW_LINE INDENT global prev NEW_LINE if root is None : NEW_LINE INDENT return True NEW_LINE DEDENT if isbst_rec ( root . left ) is False : NEW_LINE INDENT return False NEW_LINE DEDENT if prev is not None and prev . data > root . data : NEW_LINE INDENT return False NEW_LINE DEDENT prev = root NEW_LINE return isbst_rec ( root . right ) NEW_LINE DEDENT root = Node ( 4 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 5 ) NEW_LINE root . left . left = Node ( 1 ) NEW_LINE root . left . right = Node ( 3 ) NEW_LINE if isbst ( root ) : NEW_LINE INDENT print ( \" is \u2581 BST \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" not \u2581 a \u2581 BST \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2239_A", "sol": 0, "python_code": "def convert_To_Len_th_base ( n , arr , Len , L ) :\n    for i in range ( L ) :\n        print ( arr [ n % Len ] , end = \"\" )\n        n //= Len\n    print ( )\ndef printf ( arr , Len , L ) :\n    for i in range ( pow ( Len , L ) ) :\n        convert_To_Len_th_base ( i , arr , Len , L )\narr = [ 1 , 2 , 3 ]\nLen = len ( arr )\nL = 2\nprintf ( arr , Len , L )\n", "python_code_tokenized": "def convert_To_Len_th_base ( n , arr , Len , L ) : NEW_LINE INDENT for i in range ( L ) : NEW_LINE INDENT print ( arr [ n % Len ] , end = \" \" ) NEW_LINE n //= Len NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printf ( arr , Len , L ) : NEW_LINE INDENT for i in range ( pow ( Len , L ) ) : NEW_LINE INDENT convert_To_Len_th_base ( i , arr , Len , L ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE Len = len ( arr ) NEW_LINE L = 2 NEW_LINE printf ( arr , Len , L ) NEW_LINE"}
{"id": "codeforces_1650_B", "sol": 0, "python_code": "import math\nt = int ( input ( ) )\nfor i in range ( t ) :\n    l , r , a = [ int ( x ) for x in input ( ).split ( ) ]\n    d = r // a\n    m = r % a\n    res = d + m\n    prev = ( d - 1 ) * a + ( a - 1 )\n    if ( prev >= l ) :\n        tmp = ( d - 1 ) + ( a - 1 )\n        if ( res > tmp ) :\n            res = res\n        else :\n            res = tmp\n    print ( res )\n", "python_code_tokenized": "import math NEW_LINE t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT l , r , a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE d = r // a NEW_LINE m = r % a NEW_LINE res = d + m NEW_LINE prev = ( d - 1 ) * a + ( a - 1 ) NEW_LINE if ( prev >= l ) : NEW_LINE INDENT tmp = ( d - 1 ) + ( a - 1 ) NEW_LINE if ( res > tmp ) : NEW_LINE INDENT res = res NEW_LINE DEDENT else : NEW_LINE INDENT res = tmp NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2187_A", "sol": 0, "python_code": "from math import gcd\ndef minGCD ( arr , n ) :\n    minGCD = 0 ;\n    for i in range ( n ) :\n        minGCD = gcd ( minGCD , arr [ i ] ) ;\n    return minGCD ;\ndef minLCM ( arr , n ) :\n    minLCM = arr [ 0 ] ;\n    for i in range ( 1 , n ) :\n        minLCM = min ( minLCM , arr [ i ] ) ;\n    return minLCM ;\nif __name__ == \"__main__\" :\n    arr = [ 2 , 66 , 14 , 521 ] ;\n    n = len ( arr ) ;\n    print ( \"LCM = \" , minLCM ( arr , n ) , \", GCD =\" , minGCD ( arr , n ) ) ;\n", "python_code_tokenized": "from math import gcd NEW_LINE def minGCD ( arr , n ) : NEW_LINE INDENT minGCD = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT minGCD = gcd ( minGCD , arr [ i ] ) ; NEW_LINE DEDENT return minGCD ; NEW_LINE DEDENT def minLCM ( arr , n ) : NEW_LINE INDENT minLCM = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minLCM = min ( minLCM , arr [ i ] ) ; NEW_LINE DEDENT return minLCM ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 66 , 14 , 521 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( \" LCM \u2581 = \u2581 \" , minLCM ( arr , n ) , \" , \u2581 GCD \u2581 = \" , minGCD ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1613_A", "sol": 0, "python_code": "h = int ( input ( ) )\nfor x in range ( h ) :\n    a , b = map ( int , input ( ).split ( ) )\n    n , m = map ( int , input ( ).split ( ) )\n    s = min ( m , b )\n    m -= s\n    b -= s\n    while a % 10 == 0 :\n        b += 1\n        a = a // 10\n    while n % 10 == 0 :\n        m += 1\n        n = n // 10\n    h = str ( a )\n    k = str ( n )\n    if len ( h ) + b > len ( k ) + m :\n        print ( '>' )\n    elif len ( h ) + b < len ( k ) + m :\n        print ( '<' )\n    else :\n        if h > k :\n            print ( '>' )\n        elif h < k :\n            print ( '<' )\n        else :\n            print ( '=' )\n", "python_code_tokenized": "h = int ( input ( ) ) NEW_LINE for x in range ( h ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = min ( m , b ) NEW_LINE m -= s NEW_LINE b -= s NEW_LINE while a % 10 == 0 : NEW_LINE INDENT b += 1 NEW_LINE a = a // 10 NEW_LINE DEDENT while n % 10 == 0 : NEW_LINE INDENT m += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT h = str ( a ) NEW_LINE k = str ( n ) NEW_LINE if len ( h ) + b > len ( k ) + m : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT elif len ( h ) + b < len ( k ) + m : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if h > k : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT elif h < k : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "codeforces_242_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = [ ]\nminx = 1000000000\nmaxy = 0\nfor i in range ( n ) :\n    x , y = map ( int , input ( ).split ( ) )\n    minx = min ( minx , x )\n    maxy = max ( maxy , y )\n    a.append ( [ x , y ] )\nfor i in range ( n ) :\n    if a [ i ] [ 0 ] == minx and a [ i ] [ 1 ] == maxy :\n        print ( i + 1 )\n        break\nelse :\n    print ( - 1 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE minx = 1000000000 NEW_LINE maxy = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE minx = min ( minx , x ) NEW_LINE maxy = max ( maxy , y ) NEW_LINE a . append ( [ x , y ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] [ 0 ] == minx and a [ i ] [ 1 ] == maxy : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3245_A", "sol": 0, "python_code": "from math import ceil\ndef Min_glass ( n , k , a ) :\n    a.sort ( )\n    return ceil ( sum ( a [ : k ] ) / 100 )\nif __name__ == \"__main__\" :\n    n , k = 4 , 3\n    a = [ 200 , 150 , 140 , 300 ]\n    print ( Min_glass ( n , k , a ) )\n", "python_code_tokenized": "from math import ceil NEW_LINE def Min_glass ( n , k , a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return ceil ( sum ( a [ : k ] ) / 100 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 4 , 3 NEW_LINE a = [ 200 , 150 , 140 , 300 ] NEW_LINE print ( Min_glass ( n , k , a ) ) NEW_LINE DEDENT"}
{"id": "codeforces_351_A", "sol": 0, "python_code": "n = int ( input ( ) )\narr = list ( map ( float , input ( ).split ( ) ) )\narr = sorted ( [ x - int ( x ) for x in arr if x - int ( x ) != 0 ] )\no = 2 * n - len ( arr )\narr_sum = sum ( arr )\nres = int ( 2e9 )\nfor i in range ( n + 1 ) :\n    if i + o >= n :\n        res = min ( res , abs ( i - arr_sum ) )\nprint ( \"%.3f\" % res )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE arr = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE arr = sorted ( [ x - int ( x ) for x in arr if x - int ( x ) != 0 ] ) NEW_LINE o = 2 * n - len ( arr ) NEW_LINE arr_sum = sum ( arr ) NEW_LINE res = int ( 2e9 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if i + o >= n : NEW_LINE INDENT res = min ( res , abs ( i - arr_sum ) ) NEW_LINE DEDENT DEDENT print ( \" % .3f \" % res ) NEW_LINE"}
{"id": "geeksforgeeks_1419_A", "sol": 0, "python_code": "def check ( n , marks ) :\n    x = max ( marks )\n    bonus = 100 - x\n    c = 0\n    for i in range ( n ) :\n        if ( marks [ i ] + bonus >= 50 ) :\n            c += 1\n    return c\nn = 5\nmarks = [ 0 , 21 , 83 , 45 , 64 ]\nprint ( check ( n , marks ) )\n", "python_code_tokenized": "def check ( n , marks ) : NEW_LINE INDENT x = max ( marks ) NEW_LINE bonus = 100 - x NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( marks [ i ] + bonus >= 50 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT n = 5 NEW_LINE marks = [ 0 , 21 , 83 , 45 , 64 ] NEW_LINE print ( check ( n , marks ) ) NEW_LINE"}
{"id": "codeforces_83_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = [ int ( t ) for t in input ( ).split ( ) ]\nres = 0\ni = 0\nwhile i < n :\n    j = i\n    while j < n and a [ i ] == a [ j ] :\n        j += 1\n    res += ( j - i ) * ( j - i + 1 ) // 2\n    i = j\nprint ( res )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = [ int ( t ) for t in input ( ) . split ( ) ] NEW_LINE res = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT j = i NEW_LINE while j < n and a [ i ] == a [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT res += ( j - i ) * ( j - i + 1 ) // 2 NEW_LINE i = j NEW_LINE DEDENT print ( res ) NEW_LINE"}
{"id": "codeforces_133_A", "sol": 0, "python_code": "n = str ( input ( ) )\nk = 0\nfor i in n :\n    if ( i == \"H\" or i == \"Q\" or i == \"9\" ) :\n        k = 1\nif ( k > 0 ) :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "n = str ( input ( ) ) NEW_LINE k = 0 NEW_LINE for i in n : NEW_LINE INDENT if ( i == \" H \" or i == \" Q \" or i == \"9\" ) : NEW_LINE INDENT k = 1 NEW_LINE DEDENT DEDENT if ( k > 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "aizu_p00740_A", "sol": 0, "python_code": "def get_two_int ( ) :\n    two_int = input ( ).split ( )\n    for i in range ( 2 ) :\n        two_int [ i ] = int ( two_int [ i ] )\n    return two_int\ndef distribute_stone ( candidate_num , stone_num ) :\n    bowl_stone = stone_num\n    candidate_list = [ 0 ] * candidate_num\n    i = 0\n    while True :\n        order = i % candidate_num\n        if bowl_stone != 0 :\n            candidate_list [ order ] += 1\n            bowl_stone -= 1\n        elif bowl_stone == 0 and candidate_list [ order ] == stone_num :\n            return order\n        else :\n            bowl_stone = candidate_list [ order ]\n            candidate_list [ order ] = 0\n        i += 1\nif __name__ == \"__main__\" :\n    while True :\n        candidate_num , stone_num = get_two_int ( )\n        if candidate_num == 0 :\n            break\n        order = distribute_stone ( candidate_num , stone_num )\n        print ( order )\n", "python_code_tokenized": "def get_two_int ( ) : NEW_LINE INDENT two_int = input ( ) . split ( ) NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT two_int [ i ] = int ( two_int [ i ] ) NEW_LINE DEDENT return two_int NEW_LINE DEDENT def distribute_stone ( candidate_num , stone_num ) : NEW_LINE INDENT bowl_stone = stone_num NEW_LINE candidate_list = [ 0 ] * candidate_num NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT order = i % candidate_num NEW_LINE if bowl_stone != 0 : NEW_LINE INDENT candidate_list [ order ] += 1 NEW_LINE bowl_stone -= 1 NEW_LINE DEDENT elif bowl_stone == 0 and candidate_list [ order ] == stone_num : NEW_LINE INDENT return order NEW_LINE DEDENT else : NEW_LINE INDENT bowl_stone = candidate_list [ order ] NEW_LINE candidate_list [ order ] = 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT while True : NEW_LINE INDENT candidate_num , stone_num = get_two_int ( ) NEW_LINE if candidate_num == 0 : NEW_LINE INDENT break NEW_LINE DEDENT order = distribute_stone ( candidate_num , stone_num ) NEW_LINE print ( order ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1330_A", "sol": 0, "python_code": "def isPowerOfTwo ( x ) :\n    return ( x and ( not ( x & ( x - 1 ) ) ) )\nif ( isPowerOfTwo ( 31 ) ) :\n    print ( 'Yes' )\nelse :\n    print ( 'No' )\nif ( isPowerOfTwo ( 64 ) ) :\n    print ( 'Yes' )\nelse :\n    print ( 'No' )\n", "python_code_tokenized": "def isPowerOfTwo ( x ) : NEW_LINE INDENT return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT"}
{"id": "codejam_08_32", "sol": 0, "python_code": "FNAME = \"B-small-attempt0.in\"\nPRIMDIV = 2 , 3 , 5 , 7\nclass Case ( object ) :\n    def __init__ ( self , num ) :\n        self.num = num\ndef isugly ( n ) :\n    for i in PRIMDIV :\n        if n % i == 0 :\n            return True\n    return False\ndef getvals ( s ) :\n    vals = [ ]\n    for i in xrange ( len ( s ) ) :\n        v = int ( s [ : i + 1 ] )\n        if not s [ i + 1 : ] :\n            prevvals = [ 0 ]\n            vals.append ( v )\n        else :\n            prevvals = getvals ( s [ i + 1 : ] )\n            vals.extend ( [ v + val for val in prevvals ] )\n            vals.extend ( [ v - val for val in prevvals ] )\n    return vals\ndef getnugly ( s ) :\n    return len ( [ val for val in getvals ( s ) if isugly ( val ) ] )\ndef parse ( lines ) :\n    cases = [ ]\n    i = 1\n    while i < len ( lines ) :\n        cases.append ( Case ( lines [ i ] ) )\n        i += 1\n    return cases\nif __name__ == \"__main__\" :\n    lines = file ( FNAME ).read ( ).splitlines ( )\n    answers = [ getnugly ( case.num ) for case in parse ( lines ) ]\n    outlines = [ \"Case #%d: %d\\n\" % ( i + 1 , answer ) for i , answer in enumerate ( answers ) ]\n    file ( FNAME + \".out\" , \"w\" ).writelines ( outlines )\n", "python_code_tokenized": "FNAME = \" B - small - attempt0 . in \" NEW_LINE PRIMDIV = 2 , 3 , 5 , 7 NEW_LINE class Case ( object ) : NEW_LINE INDENT def __init__ ( self , num ) : NEW_LINE INDENT self . num = num NEW_LINE DEDENT DEDENT def isugly ( n ) : NEW_LINE INDENT for i in PRIMDIV : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def getvals ( s ) : NEW_LINE INDENT vals = [ ] NEW_LINE for i in xrange ( len ( s ) ) : NEW_LINE INDENT v = int ( s [ : i + 1 ] ) NEW_LINE if not s [ i + 1 : ] : NEW_LINE INDENT prevvals = [ 0 ] NEW_LINE vals . append ( v ) NEW_LINE DEDENT else : NEW_LINE INDENT prevvals = getvals ( s [ i + 1 : ] ) NEW_LINE vals . extend ( [ v + val for val in prevvals ] ) NEW_LINE vals . extend ( [ v - val for val in prevvals ] ) NEW_LINE DEDENT DEDENT return vals NEW_LINE DEDENT def getnugly ( s ) : NEW_LINE INDENT return len ( [ val for val in getvals ( s ) if isugly ( val ) ] ) NEW_LINE DEDENT def parse ( lines ) : NEW_LINE INDENT cases = [ ] NEW_LINE i = 1 NEW_LINE while i < len ( lines ) : NEW_LINE INDENT cases . append ( Case ( lines [ i ] ) ) NEW_LINE i += 1 NEW_LINE DEDENT return cases NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT lines = file ( FNAME ) . read ( ) . splitlines ( ) NEW_LINE answers = [ getnugly ( case . num ) for case in parse ( lines ) ] NEW_LINE outlines = [ \" Case \u2581 # % d : \u2581 % d \\n \" % ( i + 1 , answer ) for i , answer in enumerate ( answers ) ] NEW_LINE file ( FNAME + \" . out \" , \" w \" ) . writelines ( outlines ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC112_B", "sol": 0, "python_code": "n , t = map ( int , input ( ).split ( ) )\nkeepcost = 10 ** 10\nfor i in range ( 0 , n ) :\n    c , tt = map ( int , input ( ).split ( ) )\n    if tt <= t :\n        if c < keepcost :\n            keepcost = c\nprint ( [ keepcost , \"TLE\" ] [ keepcost == 10 ** 10 ] )\n", "python_code_tokenized": "n , t = map ( int , input ( ) . split ( ) ) NEW_LINE keepcost = 10 ** 10 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT c , tt = map ( int , input ( ) . split ( ) ) NEW_LINE if tt <= t : NEW_LINE INDENT if c < keepcost : NEW_LINE INDENT keepcost = c NEW_LINE DEDENT DEDENT DEDENT print ( [ keepcost , \" TLE \" ] [ keepcost == 10 ** 10 ] ) NEW_LINE"}
{"id": "geeksforgeeks_4902_A", "sol": 0, "python_code": "def maxDiff ( arr , arr_size ) :\n    max_diff = arr [ 1 ] - arr [ 0 ]\n    min_element = arr [ 0 ]\n    for i in range ( 1 , arr_size ) :\n        if ( arr [ i ] - min_element > max_diff ) :\n            max_diff = arr [ i ] - min_element\n        if ( arr [ i ] < min_element ) :\n            min_element = arr [ i ]\n    return max_diff\narr = [ 1 , 2 , 6 , 80 , 100 ]\nsize = len ( arr )\nprint ( \"Maximum difference is\" , maxDiff ( arr , size ) )\n", "python_code_tokenized": "def maxDiff ( arr , arr_size ) : NEW_LINE INDENT max_diff = arr [ 1 ] - arr [ 0 ] NEW_LINE min_element = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] - min_element > max_diff ) : NEW_LINE INDENT max_diff = arr [ i ] - min_element NEW_LINE DEDENT if ( arr [ i ] < min_element ) : NEW_LINE INDENT min_element = arr [ i ] NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 80 , 100 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Maximum \u2581 difference \u2581 is \" , maxDiff ( arr , size ) ) NEW_LINE"}
{"id": "geeksforgeeks_553_A", "sol": 0, "python_code": "def maxPrimefactorNum ( N ) :\n    arr = [ 0 ] * ( N + 1 ) ;\n    i = 2 ;\n    while ( i * i <= N ) :\n        if ( arr [ i ] > 0 ) :\n            for j in range ( 2 * i , N + 1 , i ) :\n                arr [ j ] += 1 ;\n        i += 1 ;\n        arr [ i ] = 1 ;\n    return max ( arr ) ;\nN = 40 ;\nprint ( maxPrimefactorNum ( N ) ) ;\n", "python_code_tokenized": "def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ 0 ] * ( N + 1 ) ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT for j in range ( 2 * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] += 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE arr [ i ] = 1 ; NEW_LINE DEDENT return max ( arr ) ; NEW_LINE DEDENT N = 40 ; NEW_LINE print ( maxPrimefactorNum ( N ) ) ; NEW_LINE"}
{"id": "codeforces_677_A", "sol": 0, "python_code": "n , h = map ( int , input ( ).split ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\ncount = 0\nfor i in range ( n ) :\n    if a [ i ] <= h :\n        count += 1\n    else :\n        count += 2\nprint ( count )\n", "python_code_tokenized": "n , h = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= h : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 2 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"}
{"id": "geeksforgeeks_3594_A", "sol": 0, "python_code": "def EqualNumbers ( a , n ) :\n    for i in range ( 0 , n ) :\n        while a [ i ] % 2 == 0 :\n            a [ i ] //= 2\n        while a [ i ] % 3 == 0 :\n            a [ i ] //= 3\n        if a [ i ] != a [ 0 ] :\n            return False\n    return True\nif __name__ == \"__main__\" :\n    a = [ 50 , 75 , 150 ]\n    n = len ( a )\n    if EqualNumbers ( a , n ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def EqualNumbers ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT while a [ i ] % 2 == 0 : NEW_LINE INDENT a [ i ] //= 2 NEW_LINE DEDENT while a [ i ] % 3 == 0 : NEW_LINE INDENT a [ i ] //= 3 NEW_LINE DEDENT if a [ i ] != a [ 0 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 50 , 75 , 150 ] NEW_LINE n = len ( a ) NEW_LINE if EqualNumbers ( a , n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_AGC009_A", "sol": 0, "python_code": "def main ( ) :\n    n = int ( input ( ) )\n    a = [ 0 for _ in range ( n ) ]\n    b = [ 0 for _ in range ( n ) ]\n    for i in range ( n ) :\n        _a , _b = map ( int , input ( ).split ( ) )\n        a [ i ] = _a\n        b [ i ] = _b\n    counter = 0\n    for i in range ( n ) :\n        a [ - ( i + 1 ) ] += counter\n        if a [ - ( i + 1 ) ] % b [ - ( i + 1 ) ] == 0 :\n            pass\n        else :\n            counter += ( b [ - ( i + 1 ) ] - ( a [ - ( i + 1 ) ] % b [ - ( i + 1 ) ] ) )\n    print ( counter )\nif __name__ == \"__main__\" :\n    main ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ 0 for _ in range ( n ) ] NEW_LINE b = [ 0 for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT _a , _b = map ( int , input ( ) . split ( ) ) NEW_LINE a [ i ] = _a NEW_LINE b [ i ] = _b NEW_LINE DEDENT counter = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ - ( i + 1 ) ] += counter NEW_LINE if a [ - ( i + 1 ) ] % b [ - ( i + 1 ) ] == 0 : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT counter += ( b [ - ( i + 1 ) ] - ( a [ - ( i + 1 ) ] % b [ - ( i + 1 ) ] ) ) NEW_LINE DEDENT DEDENT print ( counter ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_799_A", "sol": 0, "python_code": "def findRemainder ( n ) :\n    l = n % 10\n    while ( n >= 10 ) :\n        n //= 10\n    f = n\n    remainder = f % l\n    print ( remainder )\nn = 5223\nfindRemainder ( n )\n", "python_code_tokenized": "def findRemainder ( n ) : NEW_LINE INDENT l = n % 10 NEW_LINE while ( n >= 10 ) : NEW_LINE INDENT n //= 10 NEW_LINE DEDENT f = n NEW_LINE remainder = f % l NEW_LINE print ( remainder ) NEW_LINE DEDENT n = 5223 NEW_LINE findRemainder ( n ) NEW_LINE"}
{"id": "geeksforgeeks_4786_A", "sol": 0, "python_code": "def minItems ( k , r ) :\n    for i in range ( 1 , 10 ) :\n        if ( ( i * k - r ) % 10 == 0 or ( i * k ) % 10 == 0 ) :\n            return i\n    return 10 ;\nif __name__ == \"__main__\" :\n    k , r = 15 , 2 ;\n    print ( minItems ( k , r ) )\n", "python_code_tokenized": "def minItems ( k , r ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( ( i * k - r ) % 10 == 0 or ( i * k ) % 10 == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 10 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k , r = 15 , 2 ; NEW_LINE print ( minItems ( k , r ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2106_A", "sol": 0, "python_code": "def countSolutions ( n ) :\n    res = 0\n    x = 0\n    while ( x * x < n ) :\n        y = 0\n        while ( x * x + y * y < n ) :\n            res = res + 1\n            y = y + 1\n        x = x + 1\n    return res\nif __name__ == '__main__' :\n    print ( \"Total Number of distinct Non-Negative pairs is \" , countSolutions ( 6 ) )\n", "python_code_tokenized": "def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE x = 0 NEW_LINE while ( x * x < n ) : NEW_LINE INDENT y = 0 NEW_LINE while ( x * x + y * y < n ) : NEW_LINE INDENT res = res + 1 NEW_LINE y = y + 1 NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( \" Total \u2581 Number \u2581 of \u2581 distinct \u2581 Non - Negative \u2581 pairs \u2581 is \u2581 \" , countSolutions ( 6 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4999_A", "sol": 0, "python_code": "def printQueries ( n , a , q , qry ) :\n    occ = dict ( )\n    suffixCount = [ 0 for i in range ( n + 1 ) ]\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        occ [ a [ i ] ] = 1\n        suffixCount [ i + 1 ] = len ( occ )\n    for i in range ( q ) :\n        print ( suffixCount [ qry [ i ] ] )\nn = 5\nq = 3\na = [ 2 , 4 , 6 , 10 , 2 ]\nqry = [ 1 , 3 , 2 ]\nprintQueries ( n , a , q , qry )\n", "python_code_tokenized": "def printQueries ( n , a , q , qry ) : NEW_LINE INDENT occ = dict ( ) NEW_LINE suffixCount = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT occ [ a [ i ] ] = 1 NEW_LINE suffixCount [ i + 1 ] = len ( occ ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( suffixCount [ qry [ i ] ] ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE q = 3 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE qry = [ 1 , 3 , 2 ] NEW_LINE printQueries ( n , a , q , qry ) NEW_LINE"}
{"id": "geeksforgeeks_819_A", "sol": 0, "python_code": "from math import sqrt\ndef findModulo ( s ) :\n    l = len ( s )\n    modulus = 0\n    if ( '+' in s ) :\n        i = s.index ( '+' )\n    else :\n        i = s.index ( '-' )\n    real = s [ 0 : i ]\n    imaginary = s [ i + 1 : l - 1 ]\n    x = int ( real )\n    y = int ( imaginary )\n    print ( int ( sqrt ( x * x + y * y ) ) )\nif __name__ == '__main__' :\n    s = \"3+4i\"\n    findModulo ( s )\n", "python_code_tokenized": "from math import sqrt NEW_LINE def findModulo ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE modulus = 0 NEW_LINE if ( ' + ' in s ) : NEW_LINE INDENT i = s . index ( ' + ' ) NEW_LINE DEDENT else : NEW_LINE INDENT i = s . index ( ' - ' ) NEW_LINE DEDENT real = s [ 0 : i ] NEW_LINE imaginary = s [ i + 1 : l - 1 ] NEW_LINE x = int ( real ) NEW_LINE y = int ( imaginary ) NEW_LINE print ( int ( sqrt ( x * x + y * y ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"3 + 4i \" NEW_LINE findModulo ( s ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1254_A", "sol": 0, "python_code": "def isEven ( n ) :\n    return ( not ( n & 1 ) )\nn = 101 ;\nprint ( \"Even\" if isEven ( n ) else \"Odd\" )\n", "python_code_tokenized": "def isEven ( n ) : NEW_LINE INDENT return ( not ( n & 1 ) ) NEW_LINE DEDENT n = 101 ; NEW_LINE print ( \" Even \" if isEven ( n ) else \" Odd \" ) NEW_LINE"}
{"id": "geeksforgeeks_98_A", "sol": 0, "python_code": "def isEven ( n ) :\n    return ( not ( n & 1 ) ) ;\nif __name__ == \"__main__\" :\n    n = 101 ;\n    if isEven ( n ) :\n        print ( \"Even\" )\n    else :\n        print ( \"Odd\" ) ;\n", "python_code_tokenized": "def isEven ( n ) : NEW_LINE INDENT return ( not ( n & 1 ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 101 ; NEW_LINE if isEven ( n ) : NEW_LINE INDENT print ( \" Even \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Odd \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_97_A", "sol": 0, "python_code": "def isEven ( n ) :\n    if ( n ^ 1 == n + 1 ) :\n        return True ;\n    else :\n        return False ;\nif __name__ == \"__main__\" :\n    n = 100 ;\n    print ( \"Even\" ) if isEven ( n ) else print ( \"Odd\" ) ;\n", "python_code_tokenized": "def isEven ( n ) : NEW_LINE INDENT if ( n ^ 1 == n + 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 100 ; NEW_LINE print ( \" Even \" ) if isEven ( n ) else print ( \" Odd \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1253_A", "sol": 0, "python_code": "def isEven ( n ) :\n    return ( n % 2 == 0 )\nn = 101\nprint ( \"Even\" if isEven ( n ) else \"Odd\" )\n", "python_code_tokenized": "def isEven ( n ) : NEW_LINE INDENT return ( n % 2 == 0 ) NEW_LINE DEDENT n = 101 NEW_LINE print ( \" Even \" if isEven ( n ) else \" Odd \" ) NEW_LINE"}
{"id": "geeksforgeeks_849_A", "sol": 0, "python_code": "def orgazineInOrder ( vec , op , n ) :\n    result = [ 0 ] * n ;\n    vec.sort ( ) ;\n    i = 0 ;\n    j = n - 1 ;\n    k = 0 ;\n    while ( i <= j and k <= n - 2 ) :\n        if ( op [ k ] == '<' ) :\n            result [ k ] = vec [ i ] ;\n            i += 1 ;\n        else :\n            result [ k ] = vec [ j ] ;\n            j -= 1 ;\n        k += 1 ;\n    result [ n - 1 ] = vec [ i ] ;\n    return result ;\nif __name__ == \"__main__\" :\n    vec = [ 8 , 2 , 7 , 1 , 5 , 9 ] ;\n    op = [ '>' , '>' , '<' , '>' , '<' ] ;\n    result = orgazineInOrder ( vec , op , len ( vec ) ) ;\n    for i in range ( len ( result ) ) :\n        print ( result [ i ] , end = \" \" ) ;\n", "python_code_tokenized": "def orgazineInOrder ( vec , op , n ) : NEW_LINE INDENT result = [ 0 ] * n ; NEW_LINE vec . sort ( ) ; NEW_LINE i = 0 ; NEW_LINE j = n - 1 ; NEW_LINE k = 0 ; NEW_LINE while ( i <= j and k <= n - 2 ) : NEW_LINE INDENT if ( op [ k ] == ' < ' ) : NEW_LINE INDENT result [ k ] = vec [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT result [ k ] = vec [ j ] ; NEW_LINE j -= 1 ; NEW_LINE DEDENT k += 1 ; NEW_LINE DEDENT result [ n - 1 ] = vec [ i ] ; NEW_LINE return result ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT vec = [ 8 , 2 , 7 , 1 , 5 , 9 ] ; NEW_LINE op = [ ' > ' , ' > ' , ' < ' , ' > ' , ' < ' ] ; NEW_LINE result = orgazineInOrder ( vec , op , len ( vec ) ) ; NEW_LINE for i in range ( len ( result ) ) : NEW_LINE INDENT print ( result [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3134_A", "sol": 0, "python_code": "def palindrome ( arr , n ) :\n    flag = 0 ;\n    i = 0 ;\n    while ( i <= n // 2 and n != 0 ) :\n        if ( arr [ i ] != arr [ n - i - 1 ] ) :\n            flag = 1 ;\n            break ;\n        i += 1 ;\n    if ( flag == 1 ) :\n        print ( \"Not Palindrome\" ) ;\n    else :\n        print ( \"Palindrome\" ) ;\narr = [ 1 , 2 , 3 , 2 , 1 ] ;\nn = len ( arr ) ;\npalindrome ( arr , n ) ;\n", "python_code_tokenized": "def palindrome ( arr , n ) : NEW_LINE INDENT flag = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i <= n // 2 and n != 0 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ n - i - 1 ] ) : NEW_LINE INDENT flag = 1 ; NEW_LINE break ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( \" Not \u2581 Palindrome \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Palindrome \" ) ; NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 2 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE palindrome ( arr , n ) ; NEW_LINE"}
{"id": "atcoder_ARC076_C", "sol": 0, "python_code": "R , C , N = map ( int , input ( ).split ( ) )\nedge = [ ]\ndef F ( x , y ) :\n    if x == 0 :\n        return y\n    if y == C :\n        return C + x\n    if x == R :\n        return R + C * 2 - y\n    if y == 0 :\n        return 2 * R + 2 * C - x\n    return - 1\nfor i in range ( 1 , N + 1 ) :\n    x1 , y1 , x2 , y2 = map ( int , input ( ).split ( ) )\n    d1 = F ( x1 , y1 )\n    d2 = F ( x2 , y2 )\n    if d1 < 0 :\n        continue\n    if d2 < 0 :\n        continue\n    edge.append ( ( d1 , i ) )\n    edge.append ( ( d2 , i ) )\nedge.sort ( )\nstack = [ ]\nused = [ False ] * ( N + 1 )\nans = \"YES\"\nfor _ , x in edge :\n    if not used [ x ] :\n        used [ x ] = True\n        stack.append ( x )\n    else :\n        y = stack.pop ( )\n        if x != y :\n            ans = \"NO\"\n            break\nprint ( ans )\n", "python_code_tokenized": "R , C , N = map ( int , input ( ) . split ( ) ) NEW_LINE edge = [ ] NEW_LINE def F ( x , y ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return y NEW_LINE DEDENT if y == C : NEW_LINE INDENT return C + x NEW_LINE DEDENT if x == R : NEW_LINE INDENT return R + C * 2 - y NEW_LINE DEDENT if y == 0 : NEW_LINE INDENT return 2 * R + 2 * C - x NEW_LINE DEDENT return - 1 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE d1 = F ( x1 , y1 ) NEW_LINE d2 = F ( x2 , y2 ) NEW_LINE if d1 < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if d2 < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT edge . append ( ( d1 , i ) ) NEW_LINE edge . append ( ( d2 , i ) ) NEW_LINE DEDENT edge . sort ( ) NEW_LINE stack = [ ] NEW_LINE used = [ False ] * ( N + 1 ) NEW_LINE ans = \" YES \" NEW_LINE for _ , x in edge : NEW_LINE INDENT if not used [ x ] : NEW_LINE INDENT used [ x ] = True NEW_LINE stack . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT y = stack . pop ( ) NEW_LINE if x != y : NEW_LINE INDENT ans = \" NO \" NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "atcoder_ARC097_B", "sol": 0, "python_code": "N , M = map ( int , input ( ).split ( ) )\nP = list ( map ( int , input ( ).split ( ) ) )\nL = [ ]\nfor i in range ( M ) :\n    L.append ( list ( map ( int , input ( ).split ( ) ) ) )\npar = [ ]\nrank = [ ]\nfor i in range ( N ) :\n    par.append ( i )\n    rank.append ( 0 )\ndef find ( x , par ) :\n    if par [ x ] == x :\n        return x\n    else :\n        return find ( par [ x ] , par )\ndef unite ( x , y , par , rank ) :\n    x = find ( x , par )\n    y = find ( y , par )\n    if x != y :\n        if rank [ x ] < rank [ y ] :\n            par [ x ] = y\n        else :\n            par [ y ] = x\n            if rank [ x ] == rank [ y ] :\n                rank [ x ] += 1\nfor i in range ( M ) :\n    unite ( L [ i ] [ 0 ] - 1 , L [ i ] [ 1 ] - 1 , par , rank )\nans = 0\nfor i in range ( N ) :\n    if find ( P [ i ] - 1 , par ) == find ( i , par ) :\n        ans += 1\nprint ( ans )\n", "python_code_tokenized": "N , M = map ( int , input ( ) . split ( ) ) NEW_LINE P = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE L = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT L . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT par = [ ] NEW_LINE rank = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT par . append ( i ) NEW_LINE rank . append ( 0 ) NEW_LINE DEDENT def find ( x , par ) : NEW_LINE INDENT if par [ x ] == x : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return find ( par [ x ] , par ) NEW_LINE DEDENT DEDENT def unite ( x , y , par , rank ) : NEW_LINE INDENT x = find ( x , par ) NEW_LINE y = find ( y , par ) NEW_LINE if x != y : NEW_LINE INDENT if rank [ x ] < rank [ y ] : NEW_LINE INDENT par [ x ] = y NEW_LINE DEDENT else : NEW_LINE INDENT par [ y ] = x NEW_LINE if rank [ x ] == rank [ y ] : NEW_LINE INDENT rank [ x ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT unite ( L [ i ] [ 0 ] - 1 , L [ i ] [ 1 ] - 1 , par , rank ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if find ( P [ i ] - 1 , par ) == find ( i , par ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "codejam_16_13", "sol": 0, "python_code": "def find_longest ( node ) :\n    global visited\n    visited [ node ] = True\n    if node not in graph :\n        return 1\n    max_child = 0\n    for i in graph [ node ] :\n        if visited [ i ] :\n            continue\n        max_child = max ( max_child , find_longest ( i ) )\n    return max_child + 1\ndef dfs ( node ) :\n    vis = [ 0 for i in range ( len ( FF ) ) ]\n    vis [ node ] = 1\n    size = 1\n    tmp = node\n    while True :\n        tmp = FF [ tmp ]\n        if tmp == node :\n            return size\n        if vis [ tmp ] == 1 :\n            return 0\n        vis [ tmp ] = 1\n        size += 1\n    return 0\nvisited = [ ]\ngraph = { }\nQ = int ( input ( ) )\nfor q in range ( Q ) :\n    N = int ( input ( ) )\n    FF = list ( map ( int , input ( ).split ( ) ) )\n    FF.insert ( 0 , - 1 )\n    graph = { }\n    visited = [ False for i in range ( N + 1 ) ]\n    for i in range ( 1 , len ( FF ) ) :\n        if FF [ i ] not in graph :\n            graph [ FF [ i ] ] = [ ]\n        graph [ FF [ i ] ].append ( i )\n    double = 0\n    for i in range ( 1 , N + 1 ) :\n        if i == FF [ FF [ i ] ] and not visited [ i ] :\n            visited [ i ] = True\n            visited [ FF [ i ] ] = True\n            dou = find_longest ( i ) + find_longest ( FF [ i ] )\n            double += dou\n    for i in range ( 1 , N + 1 ) :\n        if not visited [ i ] :\n            double = max ( double , dfs ( i ) )\n    print ( \"Case #{}: {}\".format ( q + 1 , double ) )\n", "python_code_tokenized": "def find_longest ( node ) : NEW_LINE INDENT global visited NEW_LINE visited [ node ] = True NEW_LINE if node not in graph : NEW_LINE INDENT return 1 NEW_LINE DEDENT max_child = 0 NEW_LINE for i in graph [ node ] : NEW_LINE INDENT if visited [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT max_child = max ( max_child , find_longest ( i ) ) NEW_LINE DEDENT return max_child + 1 NEW_LINE DEDENT def dfs ( node ) : NEW_LINE INDENT vis = [ 0 for i in range ( len ( FF ) ) ] NEW_LINE vis [ node ] = 1 NEW_LINE size = 1 NEW_LINE tmp = node NEW_LINE while True : NEW_LINE INDENT tmp = FF [ tmp ] NEW_LINE if tmp == node : NEW_LINE INDENT return size NEW_LINE DEDENT if vis [ tmp ] == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT vis [ tmp ] = 1 NEW_LINE size += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT visited = [ ] NEW_LINE graph = { } NEW_LINE Q = int ( input ( ) ) NEW_LINE for q in range ( Q ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE FF = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE FF . insert ( 0 , - 1 ) NEW_LINE graph = { } NEW_LINE visited = [ False for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , len ( FF ) ) : NEW_LINE INDENT if FF [ i ] not in graph : NEW_LINE INDENT graph [ FF [ i ] ] = [ ] NEW_LINE DEDENT graph [ FF [ i ] ] . append ( i ) NEW_LINE DEDENT double = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if i == FF [ FF [ i ] ] and not visited [ i ] : NEW_LINE INDENT visited [ i ] = True NEW_LINE visited [ FF [ i ] ] = True NEW_LINE dou = find_longest ( i ) + find_longest ( FF [ i ] ) NEW_LINE double += dou NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if not visited [ i ] : NEW_LINE INDENT double = max ( double , dfs ( i ) ) NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # { } : \u2581 { } \" . format ( q + 1 , double ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00702_A", "sol": 0, "python_code": "def count_characters ( word , dic , kcs , kcs2 , kcs2_1 ) :\n    prev1 = None\n    i = 0\n    l = len ( word )\n    while i < l :\n        c = word [ i ]\n        if c in kcs2_1 and i < l - 1 :\n            c2 = word [ i + 1 ]\n            if ( c + c2 ) in kcs2 :\n                if prev1 != None :\n                    dic [ prev1 ] [ c + c2 ] += 1\n                prev1 = c + c2\n                i += 2\n                continue\n        if prev1 != None :\n            dic [ prev1 ] [ c ] += 1\n        prev1 = c\n        i += 1\nkcs = [ \"a\" , \"b\" , \"c\" , \"d\" , \"e\" , \"f\" , \"g\" , \"h\" , \"i\" , \"j\" , \"k\" , \"l\" , \"m\" , \"n\" , \"o\" , \"p\" , \"q\" , \"r\" , \"s\" , \"t\" , \"u\" , \"v\" , \"w\" , \"x\" , \"y\" , \"z\" ]\nkcs2 = [ \"ld\" , \"mb\" , \"mp\" , \"nc\" , \"nd\" , \"ng\" , \"nt\" , \"nw\" , \"ps\" , \"qu\" , \"cw\" , \"ts\" ]\nkcs2_1 = [ \"l\" , \"m\" , \"n\" , \"p\" , \"q\" , \"c\" , \"t\" ]\nn = int ( input ( ) )\ndic = { }\nfor c in ( kcs + kcs2 ) :\n    table = { }\n    for c1 in ( kcs + kcs2 ) :\n        table [ c1 ] = 0\n    dic [ c ] = table\nfor i in range ( n ) :\n    words = input ( ).split ( )\n    for word in words :\n        count_characters ( word , dic , kcs , kcs2 , kcs2_1 )\nfor c in ( kcs + kcs2 ) :\n    occurence_table = dic [ c ]\n    max_c = \"a\"\n    max_n = 0\n    for k , v in occurence_table.items ( ) :\n        if v > max_n :\n            max_n = v\n            max_c = k\n    print ( c , max_c , max_n )\n", "python_code_tokenized": "def count_characters ( word , dic , kcs , kcs2 , kcs2_1 ) : NEW_LINE INDENT prev1 = None NEW_LINE i = 0 NEW_LINE l = len ( word ) NEW_LINE while i < l : NEW_LINE INDENT c = word [ i ] NEW_LINE if c in kcs2_1 and i < l - 1 : NEW_LINE INDENT c2 = word [ i + 1 ] NEW_LINE if ( c + c2 ) in kcs2 : NEW_LINE INDENT if prev1 != None : NEW_LINE INDENT dic [ prev1 ] [ c + c2 ] += 1 NEW_LINE DEDENT prev1 = c + c2 NEW_LINE i += 2 NEW_LINE continue NEW_LINE DEDENT DEDENT if prev1 != None : NEW_LINE INDENT dic [ prev1 ] [ c ] += 1 NEW_LINE DEDENT prev1 = c NEW_LINE i += 1 NEW_LINE DEDENT DEDENT kcs = [ \" a \" , \" b \" , \" c \" , \" d \" , \" e \" , \" f \" , \" g \" , \" h \" , \" i \" , \" j \" , \" k \" , \" l \" , \" m \" , \" n \" , \" o \" , \" p \" , \" q \" , \" r \" , \" s \" , \" t \" , \" u \" , \" v \" , \" w \" , \" x \" , \" y \" , \" z \" ] NEW_LINE kcs2 = [ \" ld \" , \" mb \" , \" mp \" , \" nc \" , \" nd \" , \" ng \" , \" nt \" , \" nw \" , \" ps \" , \" qu \" , \" cw \" , \" ts \" ] NEW_LINE kcs2_1 = [ \" l \" , \" m \" , \" n \" , \" p \" , \" q \" , \" c \" , \" t \" ] NEW_LINE n = int ( input ( ) ) NEW_LINE dic = { } NEW_LINE for c in ( kcs + kcs2 ) : NEW_LINE INDENT table = { } NEW_LINE for c1 in ( kcs + kcs2 ) : NEW_LINE INDENT table [ c1 ] = 0 NEW_LINE DEDENT dic [ c ] = table NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT words = input ( ) . split ( ) NEW_LINE for word in words : NEW_LINE INDENT count_characters ( word , dic , kcs , kcs2 , kcs2_1 ) NEW_LINE DEDENT DEDENT for c in ( kcs + kcs2 ) : NEW_LINE INDENT occurence_table = dic [ c ] NEW_LINE max_c = \" a \" NEW_LINE max_n = 0 NEW_LINE for k , v in occurence_table . items ( ) : NEW_LINE INDENT if v > max_n : NEW_LINE INDENT max_n = v NEW_LINE max_c = k NEW_LINE DEDENT DEDENT print ( c , max_c , max_n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1802_A", "sol": 0, "python_code": "def productSumDivisible ( n , size ) :\n    sum = 0\n    product = 1\n    while ( n > 0 ) :\n        if ( size % 2 == 0 ) :\n            product *= n % 10\n        else :\n            sum += n % 10\n        n = n // 10\n        size -= 1\n    if ( product % sum == 0 ) :\n        return True\n    return False\nif __name__ == \"__main__\" :\n    n = 1234\n    len = 4\n    if ( productSumDivisible ( n , len ) ) :\n        print ( \"TRUE\" )\n    else :\n        print ( \"FALSE\" )\n", "python_code_tokenized": "def productSumDivisible ( n , size ) : NEW_LINE INDENT sum = 0 NEW_LINE product = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( size % 2 == 0 ) : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT else : NEW_LINE INDENT sum += n % 10 NEW_LINE DEDENT n = n // 10 NEW_LINE size -= 1 NEW_LINE DEDENT if ( product % sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1234 NEW_LINE len = 4 NEW_LINE if ( productSumDivisible ( n , len ) ) : NEW_LINE INDENT print ( \" TRUE \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" FALSE \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_811_A", "sol": 0, "python_code": "def findArea ( a , b , c ) :\n    if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) ) :\n        print ( 'Not a valid trianglen' )\n        return\n    s = ( a + b + c ) / 2\n    area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5\n    print ( 'Area of a traingle is %f' % area )\na = 3.0\nb = 4.0\nc = 5.0\nfindArea ( a , b , c )\n", "python_code_tokenized": "def findArea ( a , b , c ) : NEW_LINE INDENT if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) ) : NEW_LINE INDENT print ( ' Not \u2581 a \u2581 valid \u2581 trianglen ' ) NEW_LINE return NEW_LINE DEDENT s = ( a + b + c ) / 2 NEW_LINE area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 NEW_LINE print ( ' Area \u2581 of \u2581 a \u2581 traingle \u2581 is \u2581 % f ' % area ) NEW_LINE DEDENT a = 3.0 NEW_LINE b = 4.0 NEW_LINE c = 5.0 NEW_LINE findArea ( a , b , c ) NEW_LINE"}
{"id": "codeforces_1719_A", "sol": 0, "python_code": "for t in range ( int ( input ( ) ) ) :\n    n , m = map ( int , input ( ).split ( ) )\n    print ( \"Burenka\" if ( n + m & 1 ) else \"Tonya\" )\n", "python_code_tokenized": "for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( \" Burenka \" if ( n + m & 1 ) else \" Tonya \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_678_A", "sol": 0, "python_code": "def findElement ( arr , n ) :\n    prefixSum = [ 0 ] * n\n    prefixSum [ 0 ] = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ]\n    suffixSum = [ 0 ] * n\n    suffixSum [ n - 1 ] = arr [ n - 1 ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        suffixSum [ i ] = suffixSum [ i + 1 ] + arr [ i ]\n    for i in range ( 1 , n - 1 , 1 ) :\n        if prefixSum [ i ] == suffixSum [ i ] :\n            return arr [ i ]\n    return - 1\nif __name__ == \"__main__\" :\n    arr = [ 1 , 4 , 2 , 5 ]\n    n = len ( arr )\n    print ( findElement ( arr , n ) )\n", "python_code_tokenized": "def findElement ( arr , n ) : NEW_LINE INDENT prefixSum = [ 0 ] * n NEW_LINE prefixSum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT suffixSum = [ 0 ] * n NEW_LINE suffixSum [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffixSum [ i ] = suffixSum [ i + 1 ] + arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n - 1 , 1 ) : NEW_LINE INDENT if prefixSum [ i ] == suffixSum [ i ] : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findElement ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4093_A", "sol": 0, "python_code": "def partOdd ( s ) :\n    odd = [ ]\n    for i in range ( len ( s ) ) :\n        if i % 2 != 0 :\n            odd.append ( s [ i ] )\n    return odd\ndef partEven ( s ) :\n    even = [ ]\n    for i in range ( len ( s ) ) :\n        if i % 2 == 0 :\n            even.append ( s [ i ] )\n    return even\ndef canBeMadeEqual ( s1 , s2 ) :\n    even_s1 = partEven ( s1 )\n    even_s2 = partEven ( s2 )\n    odd_s1 = partOdd ( s1 )\n    odd_s2 = partOdd ( s2 )\n    even_s1.sort ( )\n    even_s2.sort ( )\n    odd_s1.sort ( )\n    odd_s2.sort ( )\n    if even_s1 == even_s2 and odd_s1 == odd_s2 :\n        return True\n    return False\ns1 = \"cdab\"\ns2 = \"abcd\"\nif canBeMadeEqual ( s1 , s2 ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def partOdd ( s ) : NEW_LINE INDENT odd = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i % 2 != 0 : NEW_LINE INDENT odd . append ( s [ i ] ) NEW_LINE DEDENT DEDENT return odd NEW_LINE DEDENT def partEven ( s ) : NEW_LINE INDENT even = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT even . append ( s [ i ] ) NEW_LINE DEDENT DEDENT return even NEW_LINE DEDENT def canBeMadeEqual ( s1 , s2 ) : NEW_LINE INDENT even_s1 = partEven ( s1 ) NEW_LINE even_s2 = partEven ( s2 ) NEW_LINE odd_s1 = partOdd ( s1 ) NEW_LINE odd_s2 = partOdd ( s2 ) NEW_LINE even_s1 . sort ( ) NEW_LINE even_s2 . sort ( ) NEW_LINE odd_s1 . sort ( ) NEW_LINE odd_s2 . sort ( ) NEW_LINE if even_s1 == even_s2 and odd_s1 == odd_s2 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT s1 = \" cdab \" NEW_LINE s2 = \" abcd \" NEW_LINE if canBeMadeEqual ( s1 , s2 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "codeforces_181_A", "sol": 0, "python_code": "x = y = 0\nn , _ = map ( int , input ( ).split ( ) )\nfor i in range ( n ) :\n    for j , ch in enumerate ( input ( ) ) :\n        if ch == '*' :\n            x , y = x ^ i , y ^ j\nprint ( x + 1 , y + 1 )\n", "python_code_tokenized": "x = y = 0 NEW_LINE n , _ = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j , ch in enumerate ( input ( ) ) : NEW_LINE INDENT if ch == ' * ' : NEW_LINE INDENT x , y = x ^ i , y ^ j NEW_LINE DEDENT DEDENT DEDENT print ( x + 1 , y + 1 ) NEW_LINE"}
{"id": "codeforces_1602_A", "sol": 0, "python_code": "n = int ( input ( ) )\nfor i in range ( n ) :\n    s = input ( )\n    v = [ ord ( i ) for i in s ]\n    m = min ( v )\n    a = chr ( m )\n    v.remove ( m )\n    b = [ chr ( i ) for i in v ]\n    b = ''.join ( b )\n    print ( a , b )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE v = [ ord ( i ) for i in s ] NEW_LINE m = min ( v ) NEW_LINE a = chr ( m ) NEW_LINE v . remove ( m ) NEW_LINE b = [ chr ( i ) for i in v ] NEW_LINE b = ' ' . join ( b ) NEW_LINE print ( a , b ) NEW_LINE DEDENT"}
{"id": "codeforces_1189_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\na.sort ( )\nif a [ n - 1 ] >= a [ n - 2 ] + a [ n - 3 ] :\n    print ( \"NO\" )\nelse :\n    print ( \"YES\" )\n    for i in range ( n - 1 , - 1 , - 2 ) :\n        print ( a [ i ] , end = \" \" )\n    for i in range ( n % 2 , n , 2 ) :\n        print ( a [ i ] , end = \" \" )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if a [ n - 1 ] >= a [ n - 2 ] + a [ n - 3 ] : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE for i in range ( n - 1 , - 1 , - 2 ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT for i in range ( n % 2 , n , 2 ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_454_A", "sol": 0, "python_code": "n = int ( input ( ) )\nres = [ ]\nfor p in range ( n // 2 , - n // 2 , - 1 ) :\n    p = abs ( p )\n    res.append ( \"*\" * p + \"D\" * ( n - 2 * p ) + \"*\" * p )\nres = \"\\n\".join ( res )\nprint ( res )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE res = [ ] NEW_LINE for p in range ( n // 2 , - n // 2 , - 1 ) : NEW_LINE INDENT p = abs ( p ) NEW_LINE res . append ( \" * \" * p + \" D \" * ( n - 2 * p ) + \" * \" * p ) NEW_LINE DEDENT res = \" \\n \" . join ( res ) NEW_LINE print ( res ) NEW_LINE"}
{"id": "geeksforgeeks_4072_A", "sol": 0, "python_code": "def midpoint ( x1 , x2 , y1 , y2 ) :\n    print ( ( x1 + x2 ) // 2 , \" , \" , ( y1 + y2 ) // 2 )\nx1 , y1 , x2 , y2 = - 1 , 2 , 3 , - 6\nmidpoint ( x1 , x2 , y1 , y2 )\n", "python_code_tokenized": "def midpoint ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( ( x1 + x2 ) // 2 , \" \u2581 , \u2581 \" , ( y1 + y2 ) // 2 ) NEW_LINE DEDENT x1 , y1 , x2 , y2 = - 1 , 2 , 3 , - 6 NEW_LINE midpoint ( x1 , x2 , y1 , y2 ) NEW_LINE"}
{"id": "geeksforgeeks_1606_A", "sol": 0, "python_code": "MAX = 100\ndef smallestInRow ( mat , n , m ) :\n    print ( \"{\" , end = \"\" )\n    for i in range ( n ) :\n        minm = mat [ i ] [ 0 ]\n        for j in range ( 1 , m , 1 ) :\n            if ( mat [ i ] [ j ] < minm ) :\n                minm = mat [ i ] [ j ]\n        print ( minm , end = \",\" )\n    print ( \"}\" )\ndef smallestInCol ( mat , n , m ) :\n    print ( \"{\" , end = \"\" )\n    for i in range ( m ) :\n        minm = mat [ 0 ] [ i ]\n        for j in range ( 1 , n , 1 ) :\n            if ( mat [ j ] [ i ] < minm ) :\n                minm = mat [ j ] [ i ]\n        print ( minm , end = \",\" )\n    print ( \"}\" )\nif __name__ == '__main__' :\n    n = 3\n    m = 3\n    mat = [ [ 2 , 1 , 7 ] , [ 3 , 7 , 2 ] , [ 5 , 4 , 9 ] ] ;\n    print ( \"Minimum element of each row is\" , end = \" \" )\n    smallestInRow ( mat , n , m )\n    print ( \"Minimum element of each column is\" , end = \" \" )\n    smallestInCol ( mat , n , m )\n", "python_code_tokenized": "MAX = 100 NEW_LINE def smallestInRow ( mat , n , m ) : NEW_LINE INDENT print ( \" { \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT minm = mat [ i ] [ 0 ] NEW_LINE for j in range ( 1 , m , 1 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] < minm ) : NEW_LINE INDENT minm = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( minm , end = \" , \" ) NEW_LINE DEDENT print ( \" } \" ) NEW_LINE DEDENT def smallestInCol ( mat , n , m ) : NEW_LINE INDENT print ( \" { \" , end = \" \" ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT minm = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( mat [ j ] [ i ] < minm ) : NEW_LINE INDENT minm = mat [ j ] [ i ] NEW_LINE DEDENT DEDENT print ( minm , end = \" , \" ) NEW_LINE DEDENT print ( \" } \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = 3 NEW_LINE mat = [ [ 2 , 1 , 7 ] , [ 3 , 7 , 2 ] , [ 5 , 4 , 9 ] ] ; NEW_LINE print ( \" Minimum \u2581 element \u2581 of \u2581 each \u2581 row \u2581 is \" , end = \" \u2581 \" ) NEW_LINE smallestInRow ( mat , n , m ) NEW_LINE print ( \" Minimum \u2581 element \u2581 of \u2581 each \u2581 column \u2581 is \" , end = \" \u2581 \" ) NEW_LINE smallestInCol ( mat , n , m ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC049_A", "sol": 0, "python_code": "print ( \"vowel\" if input ( ) in \"aiueo\" else \"consonant\" )\n", "python_code_tokenized": "print ( \" vowel \" if input ( ) in \" aiueo \" else \" consonant \" ) NEW_LINE"}
{"id": "aizu_p00499_A", "sol": 0, "python_code": "l = int ( input ( ) )\na = [ ]\nfor i in range ( 4 ) :\n    x = int ( input ( ) )\n    a.append ( x )\nr1 = 0\nr2 = 0\nif a [ 0 ] % a [ 2 ] == 0 :\n    r1 = a [ 0 ] // a [ 2 ]\nelse :\n    r1 = a [ 0 ] // a [ 2 ] + 1\nif a [ 1 ] % a [ 3 ] == 0 :\n    r2 = a [ 1 ] // a [ 3 ]\nelse :\n    r2 = a [ 1 ] // a [ 3 ] + 1\nprint ( l - max ( r1 , r2 ) )\n", "python_code_tokenized": "l = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE a . append ( x ) NEW_LINE DEDENT r1 = 0 NEW_LINE r2 = 0 NEW_LINE if a [ 0 ] % a [ 2 ] == 0 : NEW_LINE INDENT r1 = a [ 0 ] // a [ 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT r1 = a [ 0 ] // a [ 2 ] + 1 NEW_LINE DEDENT if a [ 1 ] % a [ 3 ] == 0 : NEW_LINE INDENT r2 = a [ 1 ] // a [ 3 ] NEW_LINE DEDENT else : NEW_LINE INDENT r2 = a [ 1 ] // a [ 3 ] + 1 NEW_LINE DEDENT print ( l - max ( r1 , r2 ) ) NEW_LINE"}
{"id": "geeksforgeeks_4366_A", "sol": 0, "python_code": "def ReverseCharBridge ( n ) :\n    for i in range ( n ) :\n        for j in range ( ord ( 'A' ) , ord ( 'A' ) + ( 2 * n ) - 1 ) :\n            if j >= ( ord ( 'A' ) + n - 1 ) + i :\n                print ( chr ( ( ord ( 'A' ) + n - 1 ) - ( j % ( ord ( 'A' ) + n - 1 ) ) ) , end = '' )\n            elif j <= ( ord ( 'A' ) + n - 1 ) - i :\n                print ( chr ( j ) , end = '' )\n            else :\n                print ( end = \" \" )\n        print ( \"\\n\" , end = '' )\nn = 6\nReverseCharBridge ( n )\n", "python_code_tokenized": "def ReverseCharBridge ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( ord ( ' A ' ) , ord ( ' A ' ) + ( 2 * n ) - 1 ) : NEW_LINE INDENT if j >= ( ord ( ' A ' ) + n - 1 ) + i : NEW_LINE INDENT print ( chr ( ( ord ( ' A ' ) + n - 1 ) - ( j % ( ord ( ' A ' ) + n - 1 ) ) ) , end = ' ' ) NEW_LINE DEDENT elif j <= ( ord ( ' A ' ) + n - 1 ) - i : NEW_LINE INDENT print ( chr ( j ) , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT print ( \" \\n \" , end = ' ' ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE ReverseCharBridge ( n ) NEW_LINE"}
{"id": "geeksforgeeks_1335_A", "sol": 0, "python_code": "import math\ndef gcd ( a , b ) :\n    if ( a == 0 ) :\n        return b\n    return math.gcd ( b % a , a )\ndef countPairs ( G , L ) :\n    count = 0\n    p = G * L\n    for a in range ( 1 , L + 1 ) :\n        if ( not ( p % a ) and math.gcd ( a , p // a ) == G ) :\n            count += 1\n    return count\nif __name__ == \"__main__\" :\n    G = 2\n    L = 12\n    print ( \"Total possible pair with GCD \" , G , end = \"\" )\n    print ( \" & LCM \" , L , end = \"\" )\n    print ( \" = \" , countPairs ( G , L ) )\n", "python_code_tokenized": "import math NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return math . gcd ( b % a , a ) NEW_LINE DEDENT def countPairs ( G , L ) : NEW_LINE INDENT count = 0 NEW_LINE p = G * L NEW_LINE for a in range ( 1 , L + 1 ) : NEW_LINE INDENT if ( not ( p % a ) and math . gcd ( a , p // a ) == G ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT G = 2 NEW_LINE L = 12 NEW_LINE print ( \" Total \u2581 possible \u2581 pair \u2581 with \u2581 GCD \u2581 \" , G , end = \" \" ) NEW_LINE print ( \" \u2581 & \u2581 LCM \u2581 \" , L , end = \" \" ) NEW_LINE print ( \" \u2581 = \u2581 \" , countPairs ( G , L ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1861_A", "sol": 0, "python_code": "def maxOR ( arr , n , k , x ) :\n    preSum = [ 0 ] * ( n + 1 )\n    suffSum = [ 0 ] * ( n + 1 )\n    pow = 1\n    for i in range ( 0 , k ) :\n        pow *= x\n    preSum [ 0 ] = 0\n    for i in range ( 0 , n ) :\n        preSum [ i + 1 ] = preSum [ i ] | arr [ i ]\n    suffSum [ n ] = 0\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ]\n    res = 0\n    for i in range ( 0 , n ) :\n        res = max ( res , preSum [ i ] | ( arr [ i ] * pow ) | suffSum [ i + 1 ] )\n    return res\narr = [ 1 , 2 , 4 , 8 ]\nn = len ( arr )\nk = 2\nx = 3\nprint ( maxOR ( arr , n , k , x ) )\n", "python_code_tokenized": "def maxOR ( arr , n , k , x ) : NEW_LINE INDENT preSum = [ 0 ] * ( n + 1 ) NEW_LINE suffSum = [ 0 ] * ( n + 1 ) NEW_LINE pow = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT pow *= x NEW_LINE DEDENT preSum [ 0 ] = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT preSum [ i + 1 ] = preSum [ i ] | arr [ i ] NEW_LINE DEDENT suffSum [ n ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res = max ( res , preSum [ i ] | ( arr [ i ] * pow ) | suffSum [ i + 1 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE x = 3 NEW_LINE print ( maxOR ( arr , n , k , x ) ) NEW_LINE"}
{"id": "atcoder_ABC115_A", "sol": 0, "python_code": "d = int ( input ( ) )\nif d == 22 : print ( 'Christmas Eve Eve Eve' )\nif d == 23 : print ( 'Christmas Eve Eve' )\nif d == 24 : print ( 'Christmas Eve' )\nif d == 25 : print ( 'Christmas' )\n", "python_code_tokenized": "d = int ( input ( ) ) NEW_LINE if d == 22 : print ( ' Christmas \u2581 Eve \u2581 Eve \u2581 Eve ' ) NEW_LINE if d == 23 : print ( ' Christmas \u2581 Eve \u2581 Eve ' ) NEW_LINE if d == 24 : print ( ' Christmas \u2581 Eve ' ) NEW_LINE if d == 25 : print ( ' Christmas ' ) NEW_LINE"}
{"id": "geeksforgeeks_4586_A", "sol": 0, "python_code": "def hexDiagonal ( a ) :\n    if ( a < 0 ) :\n        return - 1 ;\n    d = 1.73 * a ;\n    return d ;\na = 9 ;\nprint ( hexDiagonal ( a ) ) ;\n", "python_code_tokenized": "def hexDiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT d = 1.73 * a ; NEW_LINE return d ; NEW_LINE DEDENT a = 9 ; NEW_LINE print ( hexDiagonal ( a ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_4585_A", "sol": 0, "python_code": "def pentdiagonal ( a ) :\n    if ( a < 0 ) :\n        return - 1\n    d = 1.22 * a\n    return d\nif __name__ == \"__main__\" :\n    a = 6\n    print ( pentdiagonal ( a ) )\n", "python_code_tokenized": "def pentdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 6 NEW_LINE print ( pentdiagonal ( a ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1632_B", "sol": 0, "python_code": "import math\nfor i in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    k = 2 ** ( int ( math.log2 ( n - 1 ) ) )\n    for i in reversed ( range ( k ) ) :\n        print ( i , end = ' ' )\n    for i in range ( k , n ) :\n        print ( i , end = ' ' )\n    print ( )\n", "python_code_tokenized": "import math NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE k = 2 ** ( int ( math . log2 ( n - 1 ) ) ) NEW_LINE for i in reversed ( range ( k ) ) : NEW_LINE INDENT print ( i , end = ' \u2581 ' ) NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT print ( i , end = ' \u2581 ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"id": "codeforces_75_A", "sol": 0, "python_code": "a = int ( input ( ) )\nb = int ( input ( ) )\nc = a + b\na = str ( a )\nb = str ( b )\nc = str ( c )\nfa = int ( a [ 0 ] )\nfb = int ( b [ 0 ] )\nfc = int ( c [ 0 ] )\nfor i in a [ 1 : ] :\n    if i != '0' :\n        fa *= 10\n        fa += int ( i )\nfor y in b [ 1 : ] :\n    if y != '0' :\n        fb *= 10\n        fb += int ( y )\nfor u in c [ 1 : ] :\n    if u != '0' :\n        fc *= 10\n        fc += int ( u )\nif fa + fb == fc :\n    print ( 'YES' )\nelse :\n    print ( 'NO' )\n", "python_code_tokenized": "a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE c = a + b NEW_LINE a = str ( a ) NEW_LINE b = str ( b ) NEW_LINE c = str ( c ) NEW_LINE fa = int ( a [ 0 ] ) NEW_LINE fb = int ( b [ 0 ] ) NEW_LINE fc = int ( c [ 0 ] ) NEW_LINE for i in a [ 1 : ] : NEW_LINE INDENT if i != '0' : NEW_LINE INDENT fa *= 10 NEW_LINE fa += int ( i ) NEW_LINE DEDENT DEDENT for y in b [ 1 : ] : NEW_LINE INDENT if y != '0' : NEW_LINE INDENT fb *= 10 NEW_LINE fb += int ( y ) NEW_LINE DEDENT DEDENT for u in c [ 1 : ] : NEW_LINE INDENT if u != '0' : NEW_LINE INDENT fc *= 10 NEW_LINE fc += int ( u ) NEW_LINE DEDENT DEDENT if fa + fb == fc : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_381_A", "sol": 0, "python_code": "import math as mt\ndef sizeSubSet ( a , k , n ) :\n    a.sort ( )\n    s = set ( )\n    for i in range ( n ) :\n        if ( a [ i ] % k != 0 or a [ i ] // k not in s ) :\n            s.add ( a [ i ] )\n    return len ( s )\na = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]\nn = len ( a )\nk = 2\nprint ( sizeSubSet ( a , k , n ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def sizeSubSet ( a , k , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % k != 0 or a [ i ] // k not in s ) : NEW_LINE INDENT s . add ( a [ i ] ) NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( a ) NEW_LINE k = 2 NEW_LINE print ( sizeSubSet ( a , k , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3059_A", "sol": 0, "python_code": "def maxValue ( a , b ) :\n    b = sorted ( b )\n    bi = [ i for i in b ]\n    ai = [ i for i in a ]\n    n = len ( a )\n    m = len ( b )\n    j = m - 1\n    for i in range ( n ) :\n        if ( j < 0 ) :\n            break\n        if ( bi [ j ] > ai [ i ] ) :\n            ai [ i ] = bi [ j ]\n            j -= 1\n    x = \"\".join ( ai )\n    return x\na = \"1234\"\nb = \"4321\"\nprint ( maxValue ( a , b ) )\n", "python_code_tokenized": "def maxValue ( a , b ) : NEW_LINE INDENT b = sorted ( b ) NEW_LINE bi = [ i for i in b ] NEW_LINE ai = [ i for i in a ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE j = m - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( j < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( bi [ j ] > ai [ i ] ) : NEW_LINE INDENT ai [ i ] = bi [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT x = \" \" . join ( ai ) NEW_LINE return x NEW_LINE DEDENT a = \"1234\" NEW_LINE b = \"4321\" NEW_LINE print ( maxValue ( a , b ) ) NEW_LINE"}
{"id": "aizu_p02265_A", "sol": 0, "python_code": "from collections import deque\nn = int ( input ( ) )\nque = deque ( )\nfor i in range ( n ) :\n    command = input ( )\n    if command == \"deleteFirst\" : que.popleft ( )\n    elif command == \"deleteLast\" : que.pop ( )\n    else :\n        x , y = command.split ( )\n        if x == \"insert\" : que.appendleft ( y )\n        else :\n            if y in que : que.remove ( y )\nprint ( * que )\n", "python_code_tokenized": "from collections import deque NEW_LINE n = int ( input ( ) ) NEW_LINE que = deque ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT command = input ( ) NEW_LINE if command == \" deleteFirst \" : que . popleft ( ) NEW_LINE elif command == \" deleteLast \" : que . pop ( ) NEW_LINE else : NEW_LINE INDENT x , y = command . split ( ) NEW_LINE if x == \" insert \" : que . appendleft ( y ) NEW_LINE else : NEW_LINE INDENT if y in que : que . remove ( y ) NEW_LINE DEDENT DEDENT DEDENT print ( * que ) NEW_LINE"}
{"id": "codeforces_1251_A", "sol": 0, "python_code": "S = int ( input ( ) )\nfor i in range ( S ) :\n    A = input ( )\n    N = \"\"\n    B = sorted ( set ( A ) )\n    for j in B :\n        if A.count ( j ) > 2 * A.count ( j + j ) :\n            N += j\n    print ( N )\n", "python_code_tokenized": "S = int ( input ( ) ) NEW_LINE for i in range ( S ) : NEW_LINE INDENT A = input ( ) NEW_LINE N = \" \" NEW_LINE B = sorted ( set ( A ) ) NEW_LINE for j in B : NEW_LINE INDENT if A . count ( j ) > 2 * A . count ( j + j ) : NEW_LINE INDENT N += j NEW_LINE DEDENT DEDENT print ( N ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC094_C", "sol": 0, "python_code": "n = int ( input ( ) )\nlst1 = list ( map ( int , input ( ).split ( ) ) )\nlst2 = sorted ( lst1 )\nleft = lst2 [ int ( n / 2 ) - 1 ]\nright = lst2 [ int ( n / 2 ) ]\nfor num in lst1 :\n    if num <= left :\n        print ( right )\n    else :\n        print ( left )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE lst1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lst2 = sorted ( lst1 ) NEW_LINE left = lst2 [ int ( n / 2 ) - 1 ] NEW_LINE right = lst2 [ int ( n / 2 ) ] NEW_LINE for num in lst1 : NEW_LINE INDENT if num <= left : NEW_LINE INDENT print ( right ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( left ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ARC081_B", "sol": 0, "python_code": "N = int ( input ( ) )\nS1 , S2 = input ( ) , input ( )\nA = [ ]\ncur = 0\nwhile cur < N :\n    if S1 [ cur ] == S2 [ cur ] :\n        A.append ( \"X\" )\n        cur += 1\n    else :\n        A.append ( \"Y\" )\n        cur += 2\nans = 3 if A [ 0 ] == \"X\" else 6\nfor i in range ( 1 , len ( A ) ) :\n    if A [ i - 1 ] == \"X\" :\n        ans *= 2\n    elif A [ i ] == \"Y\" :\n        ans *= 3\n    ans %= 1000000007\nprint ( ans )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE S1 , S2 = input ( ) , input ( ) NEW_LINE A = [ ] NEW_LINE cur = 0 NEW_LINE while cur < N : NEW_LINE INDENT if S1 [ cur ] == S2 [ cur ] : NEW_LINE INDENT A . append ( \" X \" ) NEW_LINE cur += 1 NEW_LINE DEDENT else : NEW_LINE INDENT A . append ( \" Y \" ) NEW_LINE cur += 2 NEW_LINE DEDENT DEDENT ans = 3 if A [ 0 ] == \" X \" else 6 NEW_LINE for i in range ( 1 , len ( A ) ) : NEW_LINE INDENT if A [ i - 1 ] == \" X \" : NEW_LINE INDENT ans *= 2 NEW_LINE DEDENT elif A [ i ] == \" Y \" : NEW_LINE INDENT ans *= 3 NEW_LINE DEDENT ans %= 1000000007 NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "aizu_p01113_A", "sol": 0, "python_code": "import math\nimport sys\nma = 1 << 53\nwhile 1 :\n    n = int ( sys.stdin.readline ( ) )\n    if n == 0 :\n        break\n    s = list ( sys.stdin.readline ( ) [ : - 1 ] )\n    a = 1\n    for i in range ( 52 ) :\n        a <<= 1\n        a += int ( s [ i ] )\n    ans = a\n    e = 0\n    while n :\n        if a == 0 :\n            break\n        k = math.ceil ( ( ma - ans ) / a )\n        if n < k :\n            ans += a * n\n            break\n        ans += a * k\n        ans >>= 1\n        e += 1\n        a >>= 1\n        n -= k\n    e = list ( bin ( e ) [ 2 : ] )\n    for i in range ( 12 - len ( e ) ) :\n        e.insert ( 0 , 0 )\n    ans = list ( bin ( ans ) [ 3 : ] )\n    for i in range ( 52 - len ( ans ) ) :\n        ans.insert ( 0 , 0 )\n    for i in e + ans :\n        print ( i , end = \"\" )\n    print ( )\n", "python_code_tokenized": "import math NEW_LINE import sys NEW_LINE ma = 1 << 53 NEW_LINE while 1 : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = list ( sys . stdin . readline ( ) [ : - 1 ] ) NEW_LINE a = 1 NEW_LINE for i in range ( 52 ) : NEW_LINE INDENT a <<= 1 NEW_LINE a += int ( s [ i ] ) NEW_LINE DEDENT ans = a NEW_LINE e = 0 NEW_LINE while n : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT break NEW_LINE DEDENT k = math . ceil ( ( ma - ans ) / a ) NEW_LINE if n < k : NEW_LINE INDENT ans += a * n NEW_LINE break NEW_LINE DEDENT ans += a * k NEW_LINE ans >>= 1 NEW_LINE e += 1 NEW_LINE a >>= 1 NEW_LINE n -= k NEW_LINE DEDENT e = list ( bin ( e ) [ 2 : ] ) NEW_LINE for i in range ( 12 - len ( e ) ) : NEW_LINE INDENT e . insert ( 0 , 0 ) NEW_LINE DEDENT ans = list ( bin ( ans ) [ 3 : ] ) NEW_LINE for i in range ( 52 - len ( ans ) ) : NEW_LINE INDENT ans . insert ( 0 , 0 ) NEW_LINE DEDENT for i in e + ans : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3984_A", "sol": 0, "python_code": "def checkconv ( a , b , n ) :\n    c = [ 0 ] * n ; flag = 0 ;\n    for i in range ( n ) :\n        c [ i ] = b [ i ] - a [ i ] ;\n    idxs = [ ] ;\n    for i in range ( n ) :\n        if ( c [ i ] != 0 ) :\n            idxs.append ( ( i , c [ i ] ) ) ;\n    for i in range ( len ( idxs ) - 1 ) :\n        if ( idxs [ i + 1 ] [ 0 ] - idxs [ i ] [ 0 ] != 1 or idxs [ i + 1 ] [ 1 ] != idxs [ i ] [ 1 ] ) :\n            flag = 1 ;\n            break ;\n    return not flag ;\ndef diffofarrays ( a , b , n ) :\n    c = [ 0 ] * n ;\n    ans = 0 ;\n    for i in range ( n ) :\n        c [ i ] = b [ i ] - a [ i ] ;\n    for i in range ( n ) :\n        if ( c [ i ] != 0 ) :\n            ans = c [ i ] ;\n            break ;\n    return ans ;\nif __name__ == \"__main__\" :\n    A = [ 3 , 7 , 1 , 4 , 0 , 2 , 2 ] ;\n    B = [ 3 , 7 , 3 , 6 , 2 , 2 , 2 ] ;\n    arr_size = len ( A ) ;\n    if ( checkconv ( A , B , arr_size ) ) :\n        print ( diffofarrays ( A , B , arr_size ) ) ;\n    else :\n        print ( \"NA\" ) ;\n", "python_code_tokenized": "def checkconv ( a , b , n ) : NEW_LINE INDENT c = [ 0 ] * n ; flag = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = b [ i ] - a [ i ] ; NEW_LINE DEDENT idxs = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != 0 ) : NEW_LINE INDENT idxs . append ( ( i , c [ i ] ) ) ; NEW_LINE DEDENT DEDENT for i in range ( len ( idxs ) - 1 ) : NEW_LINE INDENT if ( idxs [ i + 1 ] [ 0 ] - idxs [ i ] [ 0 ] != 1 or idxs [ i + 1 ] [ 1 ] != idxs [ i ] [ 1 ] ) : NEW_LINE INDENT flag = 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT return not flag ; NEW_LINE DEDENT def diffofarrays ( a , b , n ) : NEW_LINE INDENT c = [ 0 ] * n ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = b [ i ] - a [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != 0 ) : NEW_LINE INDENT ans = c [ i ] ; NEW_LINE break ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 3 , 7 , 1 , 4 , 0 , 2 , 2 ] ; NEW_LINE B = [ 3 , 7 , 3 , 6 , 2 , 2 , 2 ] ; NEW_LINE arr_size = len ( A ) ; NEW_LINE if ( checkconv ( A , B , arr_size ) ) : NEW_LINE INDENT print ( diffofarrays ( A , B , arr_size ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NA \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1784_A", "sol": 0, "python_code": "def printDistinct ( arr , n ) :\n    for i in range ( 0 , n ) :\n        d = 0\n        for j in range ( 0 , i ) :\n            if ( arr [ i ] == arr [ j ] ) :\n                d = 1\n                break\n        if ( d == 0 ) :\n            print ( arr [ i ] )\narr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ]\nn = len ( arr )\nprintDistinct ( arr , n )\n", "python_code_tokenized": "def printDistinct ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT d = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT d = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( d == 0 ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE printDistinct ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_4813_A", "sol": 0, "python_code": "def printKMissing ( arr , n , k ) :\n    arr.sort ( )\n    i = 0\n    while ( i < n and arr [ i ] <= 0 ) :\n        i = i + 1\n    count = 0\n    curr = 1\n    while ( count < k and i < n ) :\n        if ( arr [ i ] != curr ) :\n            print ( str ( curr ) + \" \" , end = '' )\n            count = count + 1\n        else :\n            i = i + 1\n        curr = curr + 1\n    while ( count < k ) :\n        print ( str ( curr ) + \" \" , end = '' )\n        curr = curr + 1\n        count = count + 1\narr = [ 2 , 3 , 4 ]\nn = len ( arr )\nk = 3\nprintKMissing ( arr , n , k ) ;\n", "python_code_tokenized": "def printKMissing ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE while ( i < n and arr [ i ] <= 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT count = 0 NEW_LINE curr = 1 NEW_LINE while ( count < k and i < n ) : NEW_LINE INDENT if ( arr [ i ] != curr ) : NEW_LINE INDENT print ( str ( curr ) + \" \u2581 \" , end = ' ' ) NEW_LINE count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT curr = curr + 1 NEW_LINE DEDENT while ( count < k ) : NEW_LINE INDENT print ( str ( curr ) + \" \u2581 \" , end = ' ' ) NEW_LINE curr = curr + 1 NEW_LINE count = count + 1 NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printKMissing ( arr , n , k ) ; NEW_LINE"}
{"id": "aizu_p02472_A", "sol": 0, "python_code": "A , B = map ( int , input ( ).split ( ) )\nprint ( A + B )\n", "python_code_tokenized": "A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( A + B ) NEW_LINE"}
{"id": "codeforces_139_A", "sol": 0, "python_code": "n = int ( input ( ) )\npages = [ int ( i ) for i in input ( ).split ( ) ]\nsum = sum ( pages )\nrest = n % sum\nif ( rest == 0 ) :\n    counter = 0\n    for i in range ( 0 , len ( pages ) ) :\n        if ( counter + pages [ i ] == sum ) :\n            print ( i + 1 )\n            break\n        else :\n            counter += pages [ i ]\nelse :\n    for i in range ( 0 , len ( pages ) ) :\n        if rest - pages [ i ] <= 0 :\n            print ( i + 1 )\n            break\n        else : rest -= pages [ i ]\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE pages = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE sum = sum ( pages ) NEW_LINE rest = n % sum NEW_LINE if ( rest == 0 ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , len ( pages ) ) : NEW_LINE INDENT if ( counter + pages [ i ] == sum ) : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT counter += pages [ i ] NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 0 , len ( pages ) ) : NEW_LINE INDENT if rest - pages [ i ] <= 0 : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT else : rest -= pages [ i ] NEW_LINE DEDENT DEDENT"}
{"id": "projecteuler_p113_A", "sol": 0, "python_code": "import eulerlib\ndef compute ( ) :\n    DIGITS = 100\n    increasing = eulerlib.binomial ( DIGITS + 9 , 9 ) - 1\n    decreasing = eulerlib.binomial ( DIGITS + 10 , 10 ) - ( DIGITS + 1 )\n    flat = DIGITS * 9\n    ans = increasing + decreasing - flat\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT DIGITS = 100 NEW_LINE increasing = eulerlib . binomial ( DIGITS + 9 , 9 ) - 1 NEW_LINE decreasing = eulerlib . binomial ( DIGITS + 10 , 10 ) - ( DIGITS + 1 ) NEW_LINE flat = DIGITS * 9 NEW_LINE ans = increasing + decreasing - flat NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1025_A", "sol": 0, "python_code": "def minCost ( arr , n ) :\n    count_even = 0\n    count_odd = 0\n    for i in range ( n ) :\n        if ( arr [ i ] % 2 == 0 ) :\n            count_even += 1\n        else :\n            count_odd += 1\n    return min ( count_even , count_odd )\narr = [ 2 , 4 , 3 , 1 , 5 ]\nn = len ( arr )\nprint ( minCost ( arr , n ) )\n", "python_code_tokenized": "def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE"}
{"id": "atcoder_ABC135_E", "sol": 0, "python_code": "def solve ( k , x , y ) :\n    if k % 2 == 0 and ( x + y ) % 2 == 1 :\n        print ( - 1 )\n        return\n    x_sign = 1 ; y_sign = 1\n    xy_inv = False\n    if x < 0 :\n        x *= - 1\n        x_sign = - 1\n    if y < 0 :\n        y *= - 1\n        y_sign = - 1\n    if x < y :\n        xy_inv = True\n        x , y = y , x\n    def print_xy ( x , y ) :\n        if xy_inv :\n            print ( y * x_sign , x * y_sign )\n        else :\n            print ( x * x_sign , y * y_sign )\n        return\n    if x + y < k and ( x + y ) % 2 == 1 :\n        print ( 3 )\n        now_y = x - k\n        print_xy ( x , now_y )\n        now_x = x + ( k + x - y ) // 2\n        now_y += k - ( k + x - y ) // 2\n        print_xy ( now_x , now_y )\n        print_xy ( x , y )\n        return\n    c = ( k - ( ( x + y ) % k ) ) % k\n    if x + y < k :\n        n = 2\n    else :\n        n = ( ( x + y + k - 1 ) // k ) + ( c % 2 )\n    print ( n )\n    ans = 0\n    now_y = - k\n    l = - ( k * n - x - y ) // 2\n    while now_y >= l :\n        print_xy ( 0 , now_y )\n        now_y -= k\n    now_x = l - now_y\n    while now_x <= x :\n        print_xy ( now_x , l )\n        now_x += k\n    now_y = l + now_x - x\n    while now_y <= y :\n        print_xy ( x , now_y )\n        now_y += k\n    return\nk = int ( input ( ) )\nx , y = map ( int , input ( ).split ( ) )\nsolve ( k , x , y )\n", "python_code_tokenized": "def solve ( k , x , y ) : NEW_LINE INDENT if k % 2 == 0 and ( x + y ) % 2 == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT x_sign = 1 ; y_sign = 1 NEW_LINE xy_inv = False NEW_LINE if x < 0 : NEW_LINE INDENT x *= - 1 NEW_LINE x_sign = - 1 NEW_LINE DEDENT if y < 0 : NEW_LINE INDENT y *= - 1 NEW_LINE y_sign = - 1 NEW_LINE DEDENT if x < y : NEW_LINE INDENT xy_inv = True NEW_LINE x , y = y , x NEW_LINE DEDENT def print_xy ( x , y ) : NEW_LINE INDENT if xy_inv : NEW_LINE INDENT print ( y * x_sign , x * y_sign ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x * x_sign , y * y_sign ) NEW_LINE DEDENT return NEW_LINE DEDENT if x + y < k and ( x + y ) % 2 == 1 : NEW_LINE INDENT print ( 3 ) NEW_LINE now_y = x - k NEW_LINE print_xy ( x , now_y ) NEW_LINE now_x = x + ( k + x - y ) // 2 NEW_LINE now_y += k - ( k + x - y ) // 2 NEW_LINE print_xy ( now_x , now_y ) NEW_LINE print_xy ( x , y ) NEW_LINE return NEW_LINE DEDENT c = ( k - ( ( x + y ) % k ) ) % k NEW_LINE if x + y < k : NEW_LINE INDENT n = 2 NEW_LINE DEDENT else : NEW_LINE INDENT n = ( ( x + y + k - 1 ) // k ) + ( c % 2 ) NEW_LINE DEDENT print ( n ) NEW_LINE ans = 0 NEW_LINE now_y = - k NEW_LINE l = - ( k * n - x - y ) // 2 NEW_LINE while now_y >= l : NEW_LINE INDENT print_xy ( 0 , now_y ) NEW_LINE now_y -= k NEW_LINE DEDENT now_x = l - now_y NEW_LINE while now_x <= x : NEW_LINE INDENT print_xy ( now_x , l ) NEW_LINE now_x += k NEW_LINE DEDENT now_y = l + now_x - x NEW_LINE while now_y <= y : NEW_LINE INDENT print_xy ( x , now_y ) NEW_LINE now_y += k NEW_LINE DEDENT return NEW_LINE DEDENT k = int ( input ( ) ) NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE solve ( k , x , y ) NEW_LINE"}
{"id": "atcoder_ABC061_A", "sol": 0, "python_code": "A , B , C = map ( int , input ( ).split ( ) )\nif A <= C and B >= C :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE if A <= C and B >= C : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "codejam_08_22", "sol": 0, "python_code": "inp_file = file ( \"B-small.in\" )\nout_file = file ( \"B-small.out\" , \"w\" )\ndef solve ( line ) :\n    A , B , P = [ int ( c1 ) for c1 in line.split ( \" \" ) ]\n    numbers = range ( A , B + 1 )\n    sets = range ( B - A + 1 )\n    for c1 in primes :\n        if c1 < P : continue\n        if c1 > B / 2 + 1 : break\n        same = [ ]\n        for c2 in numbers :\n            if not c2 % c1 : same.append ( c2 - A )\n        sets = merge_sets ( sets , same )\n    counted = [ ]\n    c2 = 0\n    for c1 in sets :\n        if not c1 in counted :\n            counted.append ( c1 )\n            c2 += 1\n    return str ( c2 )\ndef merge_sets ( sets , same ) :\n    to_change = [ sets [ c1 ] for c1 in same ]\n    for c1 in range ( len ( sets ) ) :\n        if sets [ c1 ] in to_change :\n            sets [ c1 ] = to_change [ 0 ]\n    return sets\np_file = file ( \"primes1000.txt\" )\nprimes = [ int ( c1 ) for c1 in p_file.read ( ).split ( \"\\n\" ) ]\np_file.close ( )\nnum = int ( inp_file.readline ( ) )\nfor case in range ( num ) :\n    line = inp_file.readline ( ) [ : - 1 ]\n    out_file.write ( \"Case #%s: \" % ( case + 1 ) + solve ( line ) + \"\\n\" )\ninp_file.close ( )\nout_file.close ( )\n", "python_code_tokenized": "inp_file = file ( \" B - small . in \" ) NEW_LINE out_file = file ( \" B - small . out \" , \" w \" ) NEW_LINE def solve ( line ) : NEW_LINE INDENT A , B , P = [ int ( c1 ) for c1 in line . split ( \" \u2581 \" ) ] NEW_LINE numbers = range ( A , B + 1 ) NEW_LINE sets = range ( B - A + 1 ) NEW_LINE for c1 in primes : NEW_LINE INDENT if c1 < P : continue NEW_LINE if c1 > B / 2 + 1 : break NEW_LINE same = [ ] NEW_LINE for c2 in numbers : NEW_LINE INDENT if not c2 % c1 : same . append ( c2 - A ) NEW_LINE DEDENT sets = merge_sets ( sets , same ) NEW_LINE DEDENT counted = [ ] NEW_LINE c2 = 0 NEW_LINE for c1 in sets : NEW_LINE INDENT if not c1 in counted : NEW_LINE INDENT counted . append ( c1 ) NEW_LINE c2 += 1 NEW_LINE DEDENT DEDENT return str ( c2 ) NEW_LINE DEDENT def merge_sets ( sets , same ) : NEW_LINE INDENT to_change = [ sets [ c1 ] for c1 in same ] NEW_LINE for c1 in range ( len ( sets ) ) : NEW_LINE INDENT if sets [ c1 ] in to_change : NEW_LINE INDENT sets [ c1 ] = to_change [ 0 ] NEW_LINE DEDENT DEDENT return sets NEW_LINE DEDENT p_file = file ( \" primes1000 . txt \" ) NEW_LINE primes = [ int ( c1 ) for c1 in p_file . read ( ) . split ( \" \\n \" ) ] NEW_LINE p_file . close ( ) NEW_LINE num = int ( inp_file . readline ( ) ) NEW_LINE for case in range ( num ) : NEW_LINE INDENT line = inp_file . readline ( ) [ : - 1 ] NEW_LINE out_file . write ( \" Case \u2581 # % s : \u2581 \" % ( case + 1 ) + solve ( line ) + \" \\n \" ) NEW_LINE DEDENT inp_file . close ( ) NEW_LINE out_file . close ( ) NEW_LINE"}
{"id": "codeforces_1526_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    a = list ( map ( int , input ( ).split ( ) ) )\n    a.sort ( )\n    for i in range ( n ) :\n        print ( a [ i ] , a [ n + i ] , end = \" \" )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , a [ n + i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_330_A", "sol": 0, "python_code": "r , c = ( int ( i ) for i in input ( ).split ( ) )\na = [ [ v for v in input ( ) ] for _ in range ( r ) ]\nrs = [ any ( a [ i ] [ j ] == \"S\" for j in range ( c ) ) for i in range ( r ) ]\ncs = [ any ( a [ i ] [ j ] == \"S\" for i in range ( r ) ) for j in range ( c ) ]\nres = 0\nfor i in range ( r ) :\n    for j in range ( c ) :\n        if not rs [ i ] or not cs [ j ] :\n            res += 1\nprint ( res )\n", "python_code_tokenized": "r , c = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE a = [ [ v for v in input ( ) ] for _ in range ( r ) ] NEW_LINE rs = [ any ( a [ i ] [ j ] == \" S \" for j in range ( c ) ) for i in range ( r ) ] NEW_LINE cs = [ any ( a [ i ] [ j ] == \" S \" for i in range ( r ) ) for j in range ( c ) ] NEW_LINE res = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if not rs [ i ] or not cs [ j ] : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE"}
{"id": "aizu_p02060_A", "sol": 0, "python_code": "N = int ( input ( ) )\nP = [ int ( x ) for x in input ( ).split ( ) ]\nt = [ int ( x ) for x in input ( ).split ( ) ]\ndp = [ 1 << 29 ] * 10001\ndp [ 0 ] = 0\nfor i in range ( 4 ) :\n    for j in range ( 1 , t [ i ] ) :\n        if dp [ j ] > P [ i ] :\n            dp [ j ] = P [ i ]\n    for j in range ( t [ i ] , 10001 ) :\n        dp [ j ] = min ( dp [ j ] , dp [ j - t [ i ] ] + P [ i ] )\nprint ( min ( dp [ N : ] ) )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE P = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE t = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE dp = [ 1 << 29 ] * 10001 NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT for j in range ( 1 , t [ i ] ) : NEW_LINE INDENT if dp [ j ] > P [ i ] : NEW_LINE INDENT dp [ j ] = P [ i ] NEW_LINE DEDENT DEDENT for j in range ( t [ i ] , 10001 ) : NEW_LINE INDENT dp [ j ] = min ( dp [ j ] , dp [ j - t [ i ] ] + P [ i ] ) NEW_LINE DEDENT DEDENT print ( min ( dp [ N : ] ) ) NEW_LINE"}
{"id": "geeksforgeeks_5108_A", "sol": 0, "python_code": "MAX_VAL = 1000000000\ndef printClosest ( arr , n , x ) :\n    res_l , res_r = 0 , 0\n    l , r , diff = 0 , n - 1 , MAX_VAL\n    while r > l :\n        if abs ( arr [ l ] + arr [ r ] - x ) < diff :\n            res_l = l\n            res_r = r\n            diff = abs ( arr [ l ] + arr [ r ] - x )\n        if arr [ l ] + arr [ r ] > x :\n            r -= 1\n        else :\n            l += 1\n    print ( 'The closest pair is {} and {}'.format ( arr [ res_l ] , arr [ res_r ] ) )\nif __name__ == \"__main__\" :\n    arr = [ 10 , 22 , 28 , 29 , 30 , 40 ]\n    n = len ( arr )\n    x = 54\n    printClosest ( arr , n , x )\n", "python_code_tokenized": "MAX_VAL = 1000000000 NEW_LINE def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l , res_r = 0 , 0 NEW_LINE l , r , diff = 0 , n - 1 , MAX_VAL NEW_LINE while r > l : NEW_LINE INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if arr [ l ] + arr [ r ] > x : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( ' The \u2581 closest \u2581 pair \u2581 is \u2581 { } \u2581 and \u2581 { } ' . format ( arr [ res_l ] , arr [ res_r ] ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 22 , 28 , 29 , 30 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE x = 54 NEW_LINE printClosest ( arr , n , x ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4965_A", "sol": 0, "python_code": "def binarySearch ( arr , low , high , x ) :\n    while ( low <= high ) :\n        mid = int ( ( low + high ) / 2 )\n        if ( arr [ mid ] == x ) :\n            return mid\n        elif ( arr [ mid ] > x ) :\n            high = mid - 1\n        else :\n            low = mid + 1\ndef isKSortedArray ( arr , n , k ) :\n    aux = [ 0 for i in range ( n ) ]\n    for i in range ( 0 , n , 1 ) :\n        aux [ i ] = arr [ i ]\n    aux.sort ( reverse = False )\n    for i in range ( 0 , n , 1 ) :\n        j = binarySearch ( aux , 0 , n - 1 , arr [ i ] )\n        if ( abs ( i - j ) > k ) :\n            return \"No\"\n    return \"Yes\"\nif __name__ == '__main__' :\n    arr = [ 3 , 2 , 1 , 5 , 6 , 4 ]\n    n = len ( arr )\n    k = 2\n    print ( \"Is it a k sorted array?:\" , isKSortedArray ( arr , n , k ) )\n", "python_code_tokenized": "def binarySearch ( arr , low , high , x ) : NEW_LINE INDENT while ( low <= high ) : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( arr [ mid ] > x ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT DEDENT def isKSortedArray ( arr , n , k ) : NEW_LINE INDENT aux = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT aux [ i ] = arr [ i ] NEW_LINE DEDENT aux . sort ( reverse = False ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT j = binarySearch ( aux , 0 , n - 1 , arr [ i ] ) NEW_LINE if ( abs ( i - j ) > k ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT DEDENT return \" Yes \" NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 5 , 6 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( \" Is \u2581 it \u2581 a \u2581 k \u2581 sorted \u2581 array ? : \" , isKSortedArray ( arr , n , k ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00028_A", "sol": 0, "python_code": "ans = [ 0 ] * 101\nwhile True :\n    try :\n        ans [ int ( input ( ) ) ] += 1\n    except EOFError :\n        break\nprintqueue = [ ]\nmaxi = max ( ans )\nfor i in range ( 1 , 101 ) :\n    if ans [ i ] == maxi : printqueue.append ( i )\nfor i in printqueue :\n    print ( i )\n", "python_code_tokenized": "ans = [ 0 ] * 101 NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT ans [ int ( input ( ) ) ] += 1 NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT printqueue = [ ] NEW_LINE maxi = max ( ans ) NEW_LINE for i in range ( 1 , 101 ) : NEW_LINE INDENT if ans [ i ] == maxi : printqueue . append ( i ) NEW_LINE DEDENT for i in printqueue : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3315_A", "sol": 0, "python_code": "def minSwaps ( s1 , s2 ) :\n    c0 = 0 ; c1 = 0 ;\n    for i in range ( len ( s1 ) ) :\n        if ( s1 [ i ] == '0' and s2 [ i ] == '1' ) :\n            c0 += 1 ;\n        elif ( s1 [ i ] == '1' and s2 [ i ] == '0' ) :\n            c1 += 1 ;\n    ans = c0 // 2 + c1 // 2 ;\n    if ( c0 % 2 == 0 and c1 % 2 == 0 ) :\n        return ans ;\n    elif ( ( c0 + c1 ) % 2 == 0 ) :\n        return ans + 2 ;\n    else :\n        return - 1 ;\nif __name__ == \"__main__\" :\n    s1 = \"0011\" ; s2 = \"1111\" ;\n    ans = minSwaps ( s1 , s2 ) ;\n    print ( ans ) ;\n", "python_code_tokenized": "def minSwaps ( s1 , s2 ) : NEW_LINE INDENT c0 = 0 ; c1 = 0 ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] == '0' and s2 [ i ] == '1' ) : NEW_LINE INDENT c0 += 1 ; NEW_LINE DEDENT elif ( s1 [ i ] == '1' and s2 [ i ] == '0' ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT DEDENT ans = c0 // 2 + c1 // 2 ; NEW_LINE if ( c0 % 2 == 0 and c1 % 2 == 0 ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT elif ( ( c0 + c1 ) % 2 == 0 ) : NEW_LINE INDENT return ans + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \"0011\" ; s2 = \"1111\" ; NEW_LINE ans = minSwaps ( s1 , s2 ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT"}
{"id": "codeforces_846_A", "sol": 0, "python_code": "n = int ( input ( ) )\ns = input ( ).split ( ) + [ '1' ]\nzeroes_before = [ ]\nzeroes = 0\nones = 0\nfor c in s :\n    if c == '0' :\n        zeroes += 1\n    elif c == '1' :\n        zeroes_before.append ( zeroes )\n        ones += 1\nres = 0\nfor z in range ( ones ) :\n    res = max ( res , zeroes_before [ z ] + ( ones - 1 - z ) )\nprint ( res )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = input ( ) . split ( ) + [ '1' ] NEW_LINE zeroes_before = [ ] NEW_LINE zeroes = 0 NEW_LINE ones = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == '0' : NEW_LINE INDENT zeroes += 1 NEW_LINE DEDENT elif c == '1' : NEW_LINE INDENT zeroes_before . append ( zeroes ) NEW_LINE ones += 1 NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for z in range ( ones ) : NEW_LINE INDENT res = max ( res , zeroes_before [ z ] + ( ones - 1 - z ) ) NEW_LINE DEDENT print ( res ) NEW_LINE"}
{"id": "geeksforgeeks_245_A", "sol": 0, "python_code": "def findSplit ( arr , n ) :\n    preSum = 0\n    ind1 = - 1\n    ind2 = - 1\n    S = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        S += arr [ i ]\n    if ( S % 3 != 0 ) :\n        return 0\n    S1 = S / 3\n    S2 = 2 * S1\n    for i in range ( 0 , n ) :\n        preSum += arr [ i ]\n        if ( preSum % S1 == 0 and ind1 == - 1 ) :\n            ind1 = i\n        elif ( preSum % S2 == 0 ) :\n            ind2 = i\n            break\n    if ( ind1 != - 1 and ind2 != - 1 ) :\n        print ( \"({}, {})\".format ( ind1 , ind2 ) )\n        return 1\n    return 0\narr = [ 1 , 3 , 4 , 0 , 4 ]\nn = len ( arr )\nif ( findSplit ( arr , n ) == 0 ) :\n    print ( \"-1\" )\n", "python_code_tokenized": "def findSplit ( arr , n ) : NEW_LINE INDENT preSum = 0 NEW_LINE ind1 = - 1 NEW_LINE ind2 = - 1 NEW_LINE S = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE DEDENT if ( S % 3 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT S1 = S / 3 NEW_LINE S2 = 2 * S1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT preSum += arr [ i ] NEW_LINE if ( preSum % S1 == 0 and ind1 == - 1 ) : NEW_LINE INDENT ind1 = i NEW_LINE DEDENT elif ( preSum % S2 == 0 ) : NEW_LINE INDENT ind2 = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ind1 != - 1 and ind2 != - 1 ) : NEW_LINE INDENT print ( \" ( { } , \u2581 { } ) \" . format ( ind1 , ind2 ) ) NEW_LINE return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 0 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE if ( findSplit ( arr , n ) == 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT"}
{"id": "codeforces_1032_B", "sol": 0, "python_code": "import math\nn = input ( )\nr = math.ceil ( len ( n ) / 20 )\nif r == 1 :\n    print ( r , len ( n ) )\n    print ( n )\nelse :\n    c = math.ceil ( len ( n ) / r )\n    a = r * c - len ( n )\n    print ( r , c )\n    i = 0\n    for _ in range ( r ) :\n        if a > 0 :\n            print ( '*' + n [ i : i + c - 1 ] )\n            i += c - 1\n            a -= 1\n            continue\n        print ( n [ i : i + c ] )\n        i += c\n", "python_code_tokenized": "import math NEW_LINE n = input ( ) NEW_LINE r = math . ceil ( len ( n ) / 20 ) NEW_LINE if r == 1 : NEW_LINE INDENT print ( r , len ( n ) ) NEW_LINE print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT c = math . ceil ( len ( n ) / r ) NEW_LINE a = r * c - len ( n ) NEW_LINE print ( r , c ) NEW_LINE i = 0 NEW_LINE for _ in range ( r ) : NEW_LINE INDENT if a > 0 : NEW_LINE INDENT print ( ' * ' + n [ i : i + c - 1 ] ) NEW_LINE i += c - 1 NEW_LINE a -= 1 NEW_LINE continue NEW_LINE DEDENT print ( n [ i : i + c ] ) NEW_LINE i += c NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_492_A", "sol": 0, "python_code": "def countFreq ( arr , n ) :\n    visited = [ False for i in range ( n ) ]\n    for i in range ( n ) :\n        if ( visited [ i ] == True ) :\n            continue\n        count = 1\n        for j in range ( i + 1 , n , 1 ) :\n            if ( arr [ i ] == arr [ j ] ) :\n                visited [ j ] = True\n                count += 1\n        print ( arr [ i ] , count )\nif __name__ == '__main__' :\n    arr = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ]\n    n = len ( arr )\n    countFreq ( arr , n )\n", "python_code_tokenized": "def countFreq ( arr , n ) : NEW_LINE INDENT visited = [ False for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( visited [ i ] == True ) : NEW_LINE INDENT continue NEW_LINE DEDENT count = 1 NEW_LINE for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT visited [ j ] = True NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( arr [ i ] , count ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE countFreq ( arr , n ) NEW_LINE DEDENT"}
{"id": "projecteuler_p121_A", "sol": 0, "python_code": "import math\ndef compute ( ) :\n    TURNS = 15\n    ways = [ [ 1 ] ]\n    for i in range ( 1 , TURNS + 1 ) :\n        row = [ ]\n        for j in range ( i + 1 ) :\n            temp = 0\n            if j < i :\n                temp = ways [ i - 1 ] [ j ] * i\n            if j > 0 :\n                temp += ways [ i - 1 ] [ j - 1 ]\n            row.append ( temp )\n        ways.append ( row )\n    numer = sum ( ways [ TURNS ] [ i ] for i in range ( TURNS // 2 + 1 , TURNS + 1 ) )\n    denom = math.factorial ( TURNS + 1 )\n    return str ( denom // numer )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import math NEW_LINE def compute ( ) : NEW_LINE INDENT TURNS = 15 NEW_LINE ways = [ [ 1 ] ] NEW_LINE for i in range ( 1 , TURNS + 1 ) : NEW_LINE INDENT row = [ ] NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT temp = 0 NEW_LINE if j < i : NEW_LINE INDENT temp = ways [ i - 1 ] [ j ] * i NEW_LINE DEDENT if j > 0 : NEW_LINE INDENT temp += ways [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT row . append ( temp ) NEW_LINE DEDENT ways . append ( row ) NEW_LINE DEDENT numer = sum ( ways [ TURNS ] [ i ] for i in range ( TURNS // 2 + 1 , TURNS + 1 ) ) NEW_LINE denom = math . factorial ( TURNS + 1 ) NEW_LINE return str ( denom // numer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_774_A", "sol": 0, "python_code": "from math import sqrt , gcd\ndef printArr ( arr , n ) :\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" )\ndef findNumbers ( arr , n ) :\n    arr.sort ( reverse = True )\n    freq = [ 0 for i in range ( arr [ 0 ] + 1 ) ]\n    for i in range ( n ) :\n        freq [ arr [ i ] ] += 1\n    size = int ( sqrt ( n ) )\n    brr = [ 0 for i in range ( len ( arr ) ) ]\n    l = 0\n    for i in range ( n ) :\n        if ( freq [ arr [ i ] ] > 0 ) :\n            brr [ l ] = arr [ i ]\n            freq [ brr [ l ] ] -= 1\n            l += 1\n            for j in range ( l ) :\n                if ( i != j ) :\n                    x = gcd ( arr [ i ] , brr [ j ] )\n                    freq [ x ] -= 2\n    printArr ( brr , size )\nif __name__ == '__main__' :\n    arr = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 5 , 5 , 5 , 7 , 10 , 12 , 2 , 2 ]\n    n = len ( arr )\n    findNumbers ( arr , n )\n", "python_code_tokenized": "from math import sqrt , gcd NEW_LINE def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT def findNumbers ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE freq = [ 0 for i in range ( arr [ 0 ] + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT size = int ( sqrt ( n ) ) NEW_LINE brr = [ 0 for i in range ( len ( arr ) ) ] NEW_LINE l = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( freq [ arr [ i ] ] > 0 ) : NEW_LINE INDENT brr [ l ] = arr [ i ] NEW_LINE freq [ brr [ l ] ] -= 1 NEW_LINE l += 1 NEW_LINE for j in range ( l ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT x = gcd ( arr [ i ] , brr [ j ] ) NEW_LINE freq [ x ] -= 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT printArr ( brr , size ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 5 , 5 , 5 , 7 , 10 , 12 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE findNumbers ( arr , n ) NEW_LINE DEDENT"}
{"id": "projecteuler_p045_A", "sol": 0, "python_code": "def compute ( ) :\n    i = 286\n    j = 166\n    k = 144\n    while True :\n        triangle = i * ( i + 1 ) // 2\n        pentagon = j * ( j * 3 - 1 ) // 2\n        hexagon = k * ( k * 2 - 1 )\n        minimum = min ( triangle , pentagon , hexagon )\n        if minimum == max ( triangle , pentagon , hexagon ) :\n            return str ( triangle )\n        if minimum == triangle : i += 1\n        if minimum == pentagon : j += 1\n        if minimum == hexagon : k += 1\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT i = 286 NEW_LINE j = 166 NEW_LINE k = 144 NEW_LINE while True : NEW_LINE INDENT triangle = i * ( i + 1 ) // 2 NEW_LINE pentagon = j * ( j * 3 - 1 ) // 2 NEW_LINE hexagon = k * ( k * 2 - 1 ) NEW_LINE minimum = min ( triangle , pentagon , hexagon ) NEW_LINE if minimum == max ( triangle , pentagon , hexagon ) : NEW_LINE INDENT return str ( triangle ) NEW_LINE DEDENT if minimum == triangle : i += 1 NEW_LINE if minimum == pentagon : j += 1 NEW_LINE if minimum == hexagon : k += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3648_A", "sol": 0, "python_code": "def checkValidity ( a , b , c ) :\n    if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) :\n        return False\n    else :\n        return True\na = 7\nb = 10\nc = 5\nif checkValidity ( a , b , c ) :\n    print ( \"Valid\" )\nelse :\n    print ( \"Invalid\" )\n", "python_code_tokenized": "def checkValidity ( a , b , c ) : NEW_LINE INDENT if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT a = 7 NEW_LINE b = 10 NEW_LINE c = 5 NEW_LINE if checkValidity ( a , b , c ) : NEW_LINE INDENT print ( \" Valid \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4283_A", "sol": 0, "python_code": "def Valid ( a , b , c ) :\n    if ( ( a + b + c == 180 ) and a != 0 and b != 0 and c != 0 ) :\n        return True\n    else :\n        return False\nif __name__ == \"__main__\" :\n    a = 60\n    b = 40\n    c = 80\n    if ( Valid ( a , b , c ) ) :\n        print ( \"Valid\" )\n    else :\n        print ( \"Invalid\" )\n", "python_code_tokenized": "def Valid ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c == 180 ) and a != 0 and b != 0 and c != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 60 NEW_LINE b = 40 NEW_LINE c = 80 NEW_LINE if ( Valid ( a , b , c ) ) : NEW_LINE INDENT print ( \" Valid \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC156_C", "sol": 0, "python_code": "n = int ( input ( ) )\nx = list ( map ( int , input ( ).split ( ) ) )\nans = float ( \"inf\" )\nfor i in range ( 1 , 101 ) :\n    cost = 0\n    for j in range ( n ) :\n        cost += ( x [ j ] - i ) ** 2\n    ans = min ( ans , cost )\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = float ( \" inf \" ) NEW_LINE for i in range ( 1 , 101 ) : NEW_LINE INDENT cost = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT cost += ( x [ j ] - i ) ** 2 NEW_LINE DEDENT ans = min ( ans , cost ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_4953_A", "sol": 0, "python_code": "def maxlenAP ( a , n , d ) :\n    m = dict ( )\n    maxt = 1\n    for i in range ( n ) :\n        if ( a [ i ] - i * d ) in m :\n            m [ a [ i ] - i * d ] += 1\n        else :\n            m [ a [ i ] - i * d ] = 1\n    for it in m :\n        if m [ it ] > maxt :\n            maxt = m [ it ]\n    return maxt\nif __name__ == \"__main__\" :\n    n , d = 10 , 3\n    a = [ 1 , 4 , 2 , 5 , 20 , 11 , 56 , 100 , 20 , 23 ]\n    print ( maxlenAP ( a , n , d ) )\n", "python_code_tokenized": "def maxlenAP ( a , n , d ) : NEW_LINE INDENT m = dict ( ) NEW_LINE maxt = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] - i * d ) in m : NEW_LINE INDENT m [ a [ i ] - i * d ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ a [ i ] - i * d ] = 1 NEW_LINE DEDENT DEDENT for it in m : NEW_LINE INDENT if m [ it ] > maxt : NEW_LINE INDENT maxt = m [ it ] NEW_LINE DEDENT DEDENT return maxt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , d = 10 , 3 NEW_LINE a = [ 1 , 4 , 2 , 5 , 20 , 11 , 56 , 100 , 20 , 23 ] NEW_LINE print ( maxlenAP ( a , n , d ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1085_A", "sol": 0, "python_code": "s = input ( )\ns1 = ''\nif len ( s ) % 2 == 0 :\n    x = s [ ( len ( s ) // 2 ) - 1 ]\n    s1 += x\n    a = list ( s [ : ( len ( s ) // 2 ) - 1 ] )\n    b = list ( s [ len ( s ) // 2 : ] )\n    while len ( s1 ) != len ( s ) :\n        if len ( b ) > 0 :\n            s1 += b.pop ( 0 )\n        if len ( a ) > 0 :\n            s1 += a.pop ( - 1 )\n    print ( s1 )\nelse :\n    x = s [ ( len ( s ) // 2 ) ]\n    s1 += x\n    a = list ( s [ : ( len ( s ) // 2 ) ] )\n    b = list ( s [ ( len ( s ) // 2 ) + 1 : ] )\n    while len ( s1 ) != len ( s ) :\n        if len ( b ) > 0 :\n            s1 += b.pop ( 0 )\n        if len ( a ) > 0 :\n            s1 += a.pop ( - 1 )\n    print ( s1 )\n", "python_code_tokenized": "s = input ( ) NEW_LINE s1 = ' ' NEW_LINE if len ( s ) % 2 == 0 : NEW_LINE INDENT x = s [ ( len ( s ) // 2 ) - 1 ] NEW_LINE s1 += x NEW_LINE a = list ( s [ : ( len ( s ) // 2 ) - 1 ] ) NEW_LINE b = list ( s [ len ( s ) // 2 : ] ) NEW_LINE while len ( s1 ) != len ( s ) : NEW_LINE INDENT if len ( b ) > 0 : NEW_LINE INDENT s1 += b . pop ( 0 ) NEW_LINE DEDENT if len ( a ) > 0 : NEW_LINE INDENT s1 += a . pop ( - 1 ) NEW_LINE DEDENT DEDENT print ( s1 ) NEW_LINE DEDENT else : NEW_LINE INDENT x = s [ ( len ( s ) // 2 ) ] NEW_LINE s1 += x NEW_LINE a = list ( s [ : ( len ( s ) // 2 ) ] ) NEW_LINE b = list ( s [ ( len ( s ) // 2 ) + 1 : ] ) NEW_LINE while len ( s1 ) != len ( s ) : NEW_LINE INDENT if len ( b ) > 0 : NEW_LINE INDENT s1 += b . pop ( 0 ) NEW_LINE DEDENT if len ( a ) > 0 : NEW_LINE INDENT s1 += a . pop ( - 1 ) NEW_LINE DEDENT DEDENT print ( s1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_616_A", "sol": 0, "python_code": "def SubArraySum ( arr , n ) :\n    temp , result = 0 , 0\n    for i in range ( 0 , n ) :\n        temp = 0 ;\n        for j in range ( i , n ) :\n            temp += arr [ j ]\n            result += temp\n    return result\narr = [ 1 , 2 , 3 ]\nn = len ( arr )\nprint ( \"Sum of SubArray :\" , SubArraySum ( arr , n ) )\n", "python_code_tokenized": "def SubArraySum ( arr , n ) : NEW_LINE INDENT temp , result = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += arr [ j ] NEW_LINE result += temp NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Sum \u2581 of \u2581 SubArray \u2581 : \" , SubArraySum ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_617_A", "sol": 0, "python_code": "def SubArraySum ( arr , n ) :\n    result = 0\n    for i in range ( 0 , n ) :\n        result += ( arr [ i ] * ( i + 1 ) * ( n - i ) )\n    return result\narr = [ 1 , 2 , 3 ]\nn = len ( arr )\nprint ( \"Sum of SubArray : \" , SubArraySum ( arr , n ) )\n", "python_code_tokenized": "def SubArraySum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Sum \u2581 of \u2581 SubArray \u2581 : \u2581 \" , SubArraySum ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_757_B", "sol": 0, "python_code": "import math\ndef primes ( a ) :\n    s1 = set ( )\n    f = 0\n    for i in range ( 2 , math.ceil ( math.sqrt ( a + 1 ) ) ) :\n        while a % i == 0 :\n            a //= i\n            s1.add ( i )\n            if a < i :\n                f = 1\n                break\n        if f :\n            break\n    if a != 1 :\n        s1.add ( a )\n    return list ( s1 )\nn = int ( input ( ) )\nl1 = [ int ( a ) for a in input ( ).split ( ) ]\nl1.sort ( )\ndt = dict ( )\nfor i in range ( n ) :\n    if l1 [ i ] > 1 :\n        l2 = primes ( l1 [ i ] )\n        for a in l2 :\n            if a in dt :\n                dt [ a ] += 1\n            else :\n                dt [ a ] = 1\ntry :\n    print ( max ( dt.values ( ) ) )\nexcept :\n    print ( 1 )\n", "python_code_tokenized": "import math NEW_LINE def primes ( a ) : NEW_LINE INDENT s1 = set ( ) NEW_LINE f = 0 NEW_LINE for i in range ( 2 , math . ceil ( math . sqrt ( a + 1 ) ) ) : NEW_LINE INDENT while a % i == 0 : NEW_LINE INDENT a //= i NEW_LINE s1 . add ( i ) NEW_LINE if a < i : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if a != 1 : NEW_LINE INDENT s1 . add ( a ) NEW_LINE DEDENT return list ( s1 ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE l1 = [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE l1 . sort ( ) NEW_LINE dt = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l1 [ i ] > 1 : NEW_LINE INDENT l2 = primes ( l1 [ i ] ) NEW_LINE for a in l2 : NEW_LINE INDENT if a in dt : NEW_LINE INDENT dt [ a ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dt [ a ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT try : NEW_LINE INDENT print ( max ( dt . values ( ) ) ) NEW_LINE DEDENT except : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT"}
{"id": "aizu_p00952_A", "sol": 0, "python_code": "c = p = 0 ; b = [ 0 ] * 1000000\nfor _ in range ( int ( input ( ) ) ) :\n    x = int ( input ( ) )\n    if ( c == x and p != x ) or b [ 0 ] == 1 or c > x : print ( 'No' ) ; continue\n    print ( 'Yes' )\n    if x >= 1000000 : continue\n    p += 1 ; b [ x ] += 1\n    while b [ x ] > 1 : p -= 1 ; b [ x ] -= 2 ; b [ x - 1 ] += 1 ; x -= 1\n    while b [ c + 1 ] == 1 and c < 999999 : c += 1\n", "python_code_tokenized": "c = p = 0 ; b = [ 0 ] * 1000000 NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE if ( c == x and p != x ) or b [ 0 ] == 1 or c > x : print ( ' No ' ) ; continue NEW_LINE print ( ' Yes ' ) NEW_LINE if x >= 1000000 : continue NEW_LINE p += 1 ; b [ x ] += 1 NEW_LINE while b [ x ] > 1 : p -= 1 ; b [ x ] -= 2 ; b [ x - 1 ] += 1 ; x -= 1 NEW_LINE while b [ c + 1 ] == 1 and c < 999999 : c += 1 NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1017_A", "sol": 0, "python_code": "def minNumber ( a , n , x ) :\n    a.sort ( reverse = False )\n    k = 0\n    while ( a [ int ( ( n - 1 ) / 2 ) ] != x ) :\n        a [ n - 1 ] = x\n        n += 1\n        a.sort ( reverse = False )\n        k += 1\n    return k\nif __name__ == '__main__' :\n    x = 10\n    a = [ 10 , 20 , 30 ]\n    n = 3\n    print ( minNumber ( a , n , x ) )\n", "python_code_tokenized": "def minNumber ( a , n , x ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE k = 0 NEW_LINE while ( a [ int ( ( n - 1 ) / 2 ) ] != x ) : NEW_LINE INDENT a [ n - 1 ] = x NEW_LINE n += 1 NEW_LINE a . sort ( reverse = False ) NEW_LINE k += 1 NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 10 NEW_LINE a = [ 10 , 20 , 30 ] NEW_LINE n = 3 NEW_LINE print ( minNumber ( a , n , x ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4152_A", "sol": 0, "python_code": "import numpy as np\nMAX = 26 ;\ndef performQueries ( string , q , type_arr , ch , freq ) :\n    n = len ( string ) ;\n    L = np.zeros ( ( MAX , n ) ) ;\n    F = np.zeros ( ( MAX , n ) ) ;\n    cnt = [ 0 ] * MAX ;\n    for i in range ( n ) :\n        k = ord ( string [ i ] ) - ord ( 'a' ) ;\n        cnt [ k ] += 1 ;\n        for j in range ( MAX ) :\n            if ( k == j ) :\n                L [ j ] [ cnt [ j ] ] = i ;\n                F [ j ] [ cnt [ j ] ] = i ;\n            else :\n                L [ j ] [ cnt [ j ] ] = L [ j ] [ cnt [ j ] ] + 1 ;\n    for i in range ( q ) :\n        if ( type_arr [ i ] == 1 ) :\n            print ( L [ ord ( ch [ i ] ) - ord ( 'a' ) ] [ freq [ i ] ] , end = \"\" ) ;\n        else :\n            print ( F [ ord ( ch [ i ] ) - ord ( 'a' ) ] [ freq [ i ] ] , end = \"\" ) ;\n        print ( )\nif __name__ == \"__main__\" :\n    string = \"geeksforgeeks\" ;\n    type_arr = [ 1 , 2 ] ;\n    ch = [ 'e' , 'k' ] ;\n    freq = [ 2 , 2 ] ;\n    q = len ( type_arr ) ;\n    performQueries ( string , q , type_arr , ch , freq ) ;\n", "python_code_tokenized": "import numpy as np NEW_LINE MAX = 26 ; NEW_LINE def performQueries ( string , q , type_arr , ch , freq ) : NEW_LINE INDENT n = len ( string ) ; NEW_LINE L = np . zeros ( ( MAX , n ) ) ; NEW_LINE F = np . zeros ( ( MAX , n ) ) ; NEW_LINE cnt = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = ord ( string [ i ] ) - ord ( ' a ' ) ; NEW_LINE cnt [ k ] += 1 ; NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT if ( k == j ) : NEW_LINE INDENT L [ j ] [ cnt [ j ] ] = i ; NEW_LINE F [ j ] [ cnt [ j ] ] = i ; NEW_LINE DEDENT else : NEW_LINE INDENT L [ j ] [ cnt [ j ] ] = L [ j ] [ cnt [ j ] ] + 1 ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( q ) : NEW_LINE INDENT if ( type_arr [ i ] == 1 ) : NEW_LINE INDENT print ( L [ ord ( ch [ i ] ) - ord ( ' a ' ) ] [ freq [ i ] ] , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( F [ ord ( ch [ i ] ) - ord ( ' a ' ) ] [ freq [ i ] ] , end = \" \" ) ; NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE type_arr = [ 1 , 2 ] ; NEW_LINE ch = [ ' e ' , ' k ' ] ; NEW_LINE freq = [ 2 , 2 ] ; NEW_LINE q = len ( type_arr ) ; NEW_LINE performQueries ( string , q , type_arr , ch , freq ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_885_A", "sol": 0, "python_code": "def maxConsecutiveOnes ( x ) :\n    count = 0 ;\n    while ( x != 0 ) :\n        x = ( x & ( x << 1 ) ) ;\n        count += 1 ;\n    return count ;\ndef maxOnes ( arr , n ) :\n    ans = 0 ;\n    for i in range ( n ) :\n        currMax = maxConsecutiveOnes ( arr [ i ] ) ;\n        ans = max ( ans , currMax ) ;\n    return ans ;\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 3 , 4 ] ;\n    n = len ( arr ) ;\n    print ( maxOnes ( arr , n ) ) ;\n", "python_code_tokenized": "def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) ; NEW_LINE count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def maxOnes ( arr , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT currMax = maxConsecutiveOnes ( arr [ i ] ) ; NEW_LINE ans = max ( ans , currMax ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxOnes ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_453_A", "sol": 0, "python_code": "def count ( n , x ) :\n    cnt = 0\n    for i in range ( 1 , n + 1 ) :\n        if i <= x :\n            if x // i <= n and x % i == 0 :\n                cnt += 1\n    return cnt\nn = 8\nx = 24\nprint ( count ( n , x ) )\n", "python_code_tokenized": "def count ( n , x ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i <= x : NEW_LINE INDENT if x // i <= n and x % i == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT n = 8 NEW_LINE x = 24 NEW_LINE print ( count ( n , x ) ) NEW_LINE"}
{"id": "geeksforgeeks_1916_A", "sol": 0, "python_code": "def decToBinary ( n ) :\n    binaryNum = [ 0 ] * n ;\n    i = 0 ;\n    while ( n > 0 ) :\n        binaryNum [ i ] = n % 2 ;\n        n = int ( n / 2 ) ;\n        i += 1 ;\n    for j in range ( i - 1 , - 1 , - 1 ) :\n        print ( binaryNum [ j ] , end = \"\" ) ;\nn = 17 ;\ndecToBinary ( n ) ;\n", "python_code_tokenized": "def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * n ; NEW_LINE i = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 ; NEW_LINE n = int ( n / 2 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT n = 17 ; NEW_LINE decToBinary ( n ) ; NEW_LINE"}
{"id": "geeksforgeeks_3178_A", "sol": 0, "python_code": "def reverse ( n ) :\n    d = 0 ; s = 0 ;\n    while ( n > 0 ) :\n        d = n % 10 ;\n        s = s * 10 + d ;\n        n = n // 10 ;\n    return s ;\ndef isPalin ( n ) :\n    return n == reverse ( n ) ;\ndef sumOfArray ( arr , n ) :\n    s = 0 ;\n    for i in range ( n ) :\n        if ( ( arr [ i ] > 10 ) and isPalin ( arr [ i ] ) ) :\n            s += arr [ i ] ;\n    return s ;\nif __name__ == \"__main__\" :\n    n = 6 ;\n    arr = [ 12 , 313 , 11 , 44 , 9 , 1 ] ;\n    print ( sumOfArray ( arr , n ) ) ;\n", "python_code_tokenized": "def reverse ( n ) : NEW_LINE INDENT d = 0 ; s = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 ; NEW_LINE s = s * 10 + d ; NEW_LINE n = n // 10 ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT def isPalin ( n ) : NEW_LINE INDENT return n == reverse ( n ) ; NEW_LINE DEDENT def sumOfArray ( arr , n ) : NEW_LINE INDENT s = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] > 10 ) and isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += arr [ i ] ; NEW_LINE DEDENT DEDENT return s ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINE arr = [ 12 , 313 , 11 , 44 , 9 , 1 ] ; NEW_LINE print ( sumOfArray ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_310_A", "sol": 0, "python_code": "def lenOfLongIncSubArr ( arr , n ) :\n    m = 1\n    l = 1\n    for i in range ( 1 , n ) :\n        if ( arr [ i ] > arr [ i - 1 ] ) :\n            l = l + 1\n        else :\n            if ( m < l ) :\n                m = l\n            l = 1\n    if ( m < l ) :\n        m = l\n    return m\narr = [ 5 , 6 , 3 , 5 , 7 , 8 , 9 , 1 , 2 ]\nn = len ( arr )\nprint ( \"Length = \" , lenOfLongIncSubArr ( arr , n ) )\n", "python_code_tokenized": "def lenOfLongIncSubArr ( arr , n ) : NEW_LINE INDENT m = 1 NEW_LINE l = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT l = l + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( m < l ) : NEW_LINE INDENT m = l NEW_LINE DEDENT l = 1 NEW_LINE DEDENT DEDENT if ( m < l ) : NEW_LINE INDENT m = l NEW_LINE DEDENT return m NEW_LINE DEDENT arr = [ 5 , 6 , 3 , 5 , 7 , 8 , 9 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length \u2581 = \u2581 \" , lenOfLongIncSubArr ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_1372_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    if n % 2 == 0 :\n        a = b = n // 2\n        print ( a , b )\n    else :\n        a = 1\n        for i in range ( 3 , int ( n ** ( 1 / 2 ) ) + 1 , 2 ) :\n            if n % i == 0 :\n                a = ( n // i )\n                break\n        print ( a , n - a )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT a = b = n // 2 NEW_LINE print ( a , b ) NEW_LINE DEDENT else : NEW_LINE INDENT a = 1 NEW_LINE for i in range ( 3 , int ( n ** ( 1 / 2 ) ) + 1 , 2 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT a = ( n // i ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( a , n - a ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_397_B", "sol": 0, "python_code": "t = int ( input ( ) )\nwhile t > 0 :\n    t -= 1\n    n , l , r = map ( int , input ( ).split ( ) )\n    k = n // l\n    if r * k >= n :\n        print ( 'Yes' )\n    else :\n        print ( 'No' )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE n , l , r = map ( int , input ( ) . split ( ) ) NEW_LINE k = n // l NEW_LINE if r * k >= n : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_801_A", "sol": 0, "python_code": "def NumberofTimes ( s ) :\n    temporary_sum = 0\n    count = 0\n    while ( len ( s ) > 1 ) :\n        temporary_sum = 0\n        for i in range ( len ( s ) ) :\n            temporary_sum += ( ord ( s [ i ] ) - ord ( '0' ) )\n        s = str ( temporary_sum )\n        count += 1\n    return count\nif __name__ == \"__main__\" :\n    s = \"991\"\n    print ( NumberofTimes ( s ) )\n", "python_code_tokenized": "def NumberofTimes ( s ) : NEW_LINE INDENT temporary_sum = 0 NEW_LINE count = 0 NEW_LINE while ( len ( s ) > 1 ) : NEW_LINE INDENT temporary_sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT temporary_sum += ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT s = str ( temporary_sum ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"991\" NEW_LINE print ( NumberofTimes ( s ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00241_A", "sol": 0, "python_code": "while 1 :\n    n = int ( input ( ) )\n    if n == 0 : break\n    mark = ( 1 , 1 , 1 , 1 , 1 , - 1 , 1 , - 1 , 1 , - 1 , - 1 , 1 , 1 , 1 , - 1 , - 1 )\n    k = ( 0 , 1 , 2 , 3 , 1 , 0 , 3 , 2 , 2 , 3 , 0 , 1 , 3 , 2 , 1 , 0 )\n    for i in range ( n ) :\n        result = [ 0 for i in range ( 4 ) ]\n        inp = list ( map ( int , input ( ).split ( ) ) )\n        for x_i , x in enumerate ( inp [ : 4 ] ) :\n            for y_i , y in enumerate ( inp [ 4 : ] ) :\n                idx = x_i * 4 + y_i\n                result [ k [ idx ] ] += ( mark [ idx ] * ( x * y ) )\n        print ( ' '.join ( map ( str , result ) ) )\n", "python_code_tokenized": "while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE mark = ( 1 , 1 , 1 , 1 , 1 , - 1 , 1 , - 1 , 1 , - 1 , - 1 , 1 , 1 , 1 , - 1 , - 1 ) NEW_LINE k = ( 0 , 1 , 2 , 3 , 1 , 0 , 3 , 2 , 2 , 3 , 0 , 1 , 3 , 2 , 1 , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = [ 0 for i in range ( 4 ) ] NEW_LINE inp = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for x_i , x in enumerate ( inp [ : 4 ] ) : NEW_LINE INDENT for y_i , y in enumerate ( inp [ 4 : ] ) : NEW_LINE INDENT idx = x_i * 4 + y_i NEW_LINE result [ k [ idx ] ] += ( mark [ idx ] * ( x * y ) ) NEW_LINE DEDENT DEDENT print ( ' \u2581 ' . join ( map ( str , result ) ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1812_A", "sol": 0, "python_code": "def nthDigit ( a , n , b ) :\n    for i in range ( 1 , n ) :\n        a = a // b\n    return a % b\na = 100\nn = 3\nb = 4\nprint ( nthDigit ( a , n , b ) )\n", "python_code_tokenized": "def nthDigit ( a , n , b ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT a = a // b NEW_LINE DEDENT return a % b NEW_LINE DEDENT a = 100 NEW_LINE n = 3 NEW_LINE b = 4 NEW_LINE print ( nthDigit ( a , n , b ) ) NEW_LINE"}
{"id": "geeksforgeeks_4994_A", "sol": 0, "python_code": "def maximumPoints ( arr , n , k , i ) :\n    start = 0\n    if ( k > i ) :\n        start = 0\n    else :\n        start = i - k\n    res = 0\n    j = start\n    while ( j <= start + k and j < n ) :\n        res += arr [ j ]\n        j += 1\n    curr_sum = res\n    j = start + k + 1\n    while ( j < n and j <= i + k ) :\n        curr_sum += arr [ j ] - arr [ j - k - 1 ]\n        res = max ( res , curr_sum )\n        j += 1\n    return res\narr = [ 5 , 6 , 4 , 2 , 8 , 3 , 1 ]\nk , i = 3 , 3\nn = len ( arr )\nprint ( \"Maximum points :\" , maximumPoints ( arr , n , k - 1 , i ) )\n", "python_code_tokenized": "def maximumPoints ( arr , n , k , i ) : NEW_LINE INDENT start = 0 NEW_LINE if ( k > i ) : NEW_LINE INDENT start = 0 NEW_LINE DEDENT else : NEW_LINE INDENT start = i - k NEW_LINE DEDENT res = 0 NEW_LINE j = start NEW_LINE while ( j <= start + k and j < n ) : NEW_LINE INDENT res += arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT curr_sum = res NEW_LINE j = start + k + 1 NEW_LINE while ( j < n and j <= i + k ) : NEW_LINE INDENT curr_sum += arr [ j ] - arr [ j - k - 1 ] NEW_LINE res = max ( res , curr_sum ) NEW_LINE j += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 5 , 6 , 4 , 2 , 8 , 3 , 1 ] NEW_LINE k , i = 3 , 3 NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum \u2581 points \u2581 : \" , maximumPoints ( arr , n , k - 1 , i ) ) NEW_LINE"}
{"id": "codeforces_1155_B", "sol": 0, "python_code": "n = int ( input ( ) )\nlst = list ( map ( int , input ( ) ) )\nif lst [ : n - 10 ].count ( 8 ) > ( n - 11 ) / 2 :\n    print ( 'YES' )\nelse :\n    print ( 'NO' )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE lst = list ( map ( int , input ( ) ) ) NEW_LINE if lst [ : n - 10 ] . count ( 8 ) > ( n - 11 ) / 2 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3242_A", "sol": 0, "python_code": "def MinimumCost ( a , n , x ) :\n    for i in range ( 1 , n , 1 ) :\n        a [ i ] = min ( a [ i ] , 2 * a [ i - 1 ] )\n    ind = 0\n    sum = 0\n    while ( x ) :\n        if ( x & 1 ) :\n            sum += a [ ind ]\n        ind += 1\n        x = x >> 1\n    return sum\nif __name__ == '__main__' :\n    a = [ 20 , 50 , 60 , 90 ]\n    x = 7\n    n = len ( a )\n    print ( MinimumCost ( a , n , x ) )\n", "python_code_tokenized": "def MinimumCost ( a , n , x ) : NEW_LINE INDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT a [ i ] = min ( a [ i ] , 2 * a [ i - 1 ] ) NEW_LINE DEDENT ind = 0 NEW_LINE sum = 0 NEW_LINE while ( x ) : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT sum += a [ ind ] NEW_LINE DEDENT ind += 1 NEW_LINE x = x >> 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 20 , 50 , 60 , 90 ] NEW_LINE x = 7 NEW_LINE n = len ( a ) NEW_LINE print ( MinimumCost ( a , n , x ) ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC044_A", "sol": 0, "python_code": "from math import inf\ndef main ( N , A , B , C , D ) :\n    if N == 1 :\n        return D\n    if N in dp :\n        return dp [ N ]\n    r = inf\n    if N % 2 != 0 :\n        r = min ( A + main ( N // 2 + 1 , A , B , C , D ) + D , A + main ( N // 2 , A , B , C , D ) + D , r )\n    else :\n        r = min ( A + main ( N // 2 , A , B , C , D ) , r )\n    if N % 3 != 0 :\n        r = min ( B + main ( N // 3 + 1 , A , B , C , D ) + ( 3 - N % 3 ) * D , B + main ( N // 3 , A , B , C , D ) + ( N % 3 * D ) , r )\n    else :\n        r = min ( B + main ( N // 3 , A , B , C , D ) , r )\n    if N % 5 != 0 :\n        r = min ( C + main ( N // 5 + 1 , A , B , C , D ) + ( 5 - N % 5 ) * D , C + main ( N // 5 , A , B , C , D ) + ( N % 5 * D ) , r )\n    else :\n        r = min ( C + main ( N // 5 , A , B , C , D ) , r )\n    r = min ( N * D , r )\n    dp [ N ] = r\n    return r\nT = int ( input ( ) )\nq_list = [ [ int ( s ) for s in input ( ).split ( ) ] for _ in range ( T ) ]\nfor q in q_list :\n    dp = { 0 : 0 }\n    print ( main ( * q ) )\n", "python_code_tokenized": "from math import inf NEW_LINE def main ( N , A , B , C , D ) : NEW_LINE INDENT if N == 1 : NEW_LINE INDENT return D NEW_LINE DEDENT if N in dp : NEW_LINE INDENT return dp [ N ] NEW_LINE DEDENT r = inf NEW_LINE if N % 2 != 0 : NEW_LINE INDENT r = min ( A + main ( N // 2 + 1 , A , B , C , D ) + D , A + main ( N // 2 , A , B , C , D ) + D , r ) NEW_LINE DEDENT else : NEW_LINE INDENT r = min ( A + main ( N // 2 , A , B , C , D ) , r ) NEW_LINE DEDENT if N % 3 != 0 : NEW_LINE INDENT r = min ( B + main ( N // 3 + 1 , A , B , C , D ) + ( 3 - N % 3 ) * D , B + main ( N // 3 , A , B , C , D ) + ( N % 3 * D ) , r ) NEW_LINE DEDENT else : NEW_LINE INDENT r = min ( B + main ( N // 3 , A , B , C , D ) , r ) NEW_LINE DEDENT if N % 5 != 0 : NEW_LINE INDENT r = min ( C + main ( N // 5 + 1 , A , B , C , D ) + ( 5 - N % 5 ) * D , C + main ( N // 5 , A , B , C , D ) + ( N % 5 * D ) , r ) NEW_LINE DEDENT else : NEW_LINE INDENT r = min ( C + main ( N // 5 , A , B , C , D ) , r ) NEW_LINE DEDENT r = min ( N * D , r ) NEW_LINE dp [ N ] = r NEW_LINE return r NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE q_list = [ [ int ( s ) for s in input ( ) . split ( ) ] for _ in range ( T ) ] NEW_LINE for q in q_list : NEW_LINE INDENT dp = { 0 : 0 } NEW_LINE print ( main ( * q ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1451_A", "sol": 0, "python_code": "def solve ( n ) :\n    if n <= 1 :\n        return 0\n    elif n == 2 :\n        return 1\n    elif n == 3 :\n        return 2\n    elif n % 2 == 0 :\n        return 2\n    else :\n        return 3\nif __name__ == \"__main__\" :\n    t = int ( input ( ) )\n    for i in range ( 0 , t ) :\n        n = int ( input ( ) )\n        print ( solve ( n ) )\n", "python_code_tokenized": "def solve ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n == 3 : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for i in range ( 0 , t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( solve ( n ) ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1658_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    def fact ( n ) :\n        if n == 1 or n == 0 :\n            return 1\n        else :\n            return n * fact ( n - 1 )\n    if n % 2 == 1 :\n        print ( 0 )\n        continue\n    else :\n        res = fact ( n // 2 )\n        res = ( res ** 2 ) % 998244353\n        print ( res )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE def fact ( n ) : NEW_LINE INDENT if n == 1 or n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n * fact ( n - 1 ) NEW_LINE DEDENT DEDENT if n % 2 == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT res = fact ( n // 2 ) NEW_LINE res = ( res ** 2 ) % 998244353 NEW_LINE print ( res ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3177_A", "sol": 0, "python_code": "def reverse ( num ) :\n    rev = 0 ;\n    while ( num > 0 ) :\n        rev = rev * 10 + num % 10 ;\n        num = num // 10 ;\n    return rev ;\ndef isPalindrome ( num ) :\n    if ( num == reverse ( num ) ) :\n        return True ;\n    return False ;\ndef printPalindromes ( d ) :\n    if ( d <= 0 ) :\n        return ;\n    smallest = pow ( 10 , d - 1 ) ;\n    largest = pow ( 10 , d ) - 1 ;\n    for i in range ( smallest , largest + 1 ) :\n        if ( isPalindrome ( i ) ) :\n            print ( i , end = \" \" ) ;\nd = 2 ;\nprintPalindromes ( d ) ;\n", "python_code_tokenized": "def reverse ( num ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev = rev * 10 + num % 10 ; NEW_LINE num = num // 10 ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def isPalindrome ( num ) : NEW_LINE INDENT if ( num == reverse ( num ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def printPalindromes ( d ) : NEW_LINE INDENT if ( d <= 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT smallest = pow ( 10 , d - 1 ) ; NEW_LINE largest = pow ( 10 , d ) - 1 ; NEW_LINE for i in range ( smallest , largest + 1 ) : NEW_LINE INDENT if ( isPalindrome ( i ) ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT DEDENT d = 2 ; NEW_LINE printPalindromes ( d ) ; NEW_LINE"}
{"id": "geeksforgeeks_1614_A", "sol": 0, "python_code": "def findSum ( n ) :\n    n -= 1\n    sum = 0\n    sum += ( n * ( n + 1 ) ) / 2\n    sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6\n    return int ( sum )\nn = 3\nprint ( findSum ( n ) )\n", "python_code_tokenized": "def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) / 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE return int ( sum ) NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3145_A", "sol": 0, "python_code": "def getSum ( n ) :\n    sum = 0\n    while ( n != 0 ) :\n        sum = sum + int ( n % 10 )\n        n = int ( n / 10 )\n    return sum\nn = 687\nprint ( getSum ( n ) )\n", "python_code_tokenized": "def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3146_A", "sol": 0, "python_code": "def getSum ( n ) :\n    sum = 0\n    while ( n > 0 ) :\n        sum += int ( n % 10 )\n        n = int ( n / 10 )\n    return sum\nn = 687\nprint ( getSum ( n ) )\n", "python_code_tokenized": "def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE"}
{"id": "aizu_p00040_A", "sol": 0, "python_code": "z = 'abcdefghijklmnopqrstuvwxyz'\ndef f ( x ) :\n    for i in range ( 1 , 26 , 2 ) :\n        for j in range ( 26 ) :\n            a = ''.join ( z [ ( z.index ( c ) * i + j ) % 26 ] if c in z else c for c in x )\n            if 'that' in a or 'this' in a : return a\nfor _ in [ 0 ] * int ( input ( ) ) : print ( f ( input ( ) ) )\n", "python_code_tokenized": "z = ' abcdefghijklmnopqrstuvwxyz ' NEW_LINE def f ( x ) : NEW_LINE INDENT for i in range ( 1 , 26 , 2 ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT a = ' ' . join ( z [ ( z . index ( c ) * i + j ) % 26 ] if c in z else c for c in x ) NEW_LINE if ' that ' in a or ' this ' in a : return a NEW_LINE DEDENT DEDENT DEDENT for _ in [ 0 ] * int ( input ( ) ) : print ( f ( input ( ) ) ) NEW_LINE"}
{"id": "codeforces_1038_A", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\ns = input ( )\nprint ( k * min ( [ s.count ( chr ( ord ( 'A' ) + i ) ) for i in range ( k ) ] ) )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE print ( k * min ( [ s . count ( chr ( ord ( ' A ' ) + i ) ) for i in range ( k ) ] ) ) NEW_LINE"}
{"id": "aizu_p00026_A", "sol": 0, "python_code": "import sys\nf = sys.stdin\ndef drop ( paper , x , y ) :\n    if 0 <= x < len ( paper [ 0 ] ) and 0 <= y < len ( paper ) :\n        paper [ y ] [ x ] += 1\ndrop_range = { }\ndrop_range [ 1 ] = ( ( 0 , 0 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) )\ndrop_range [ 2 ] = drop_range [ 1 ] + ( ( - 1 , - 1 ) , ( 1 , - 1 ) , ( 1 , 1 ) , ( - 1 , 1 ) )\ndrop_range [ 3 ] = drop_range [ 2 ] + ( ( 0 , - 2 ) , ( 2 , 0 ) , ( 0 , 2 ) , ( - 2 , 0 ) )\npaper = [ [ 0 for j in range ( 10 ) ] for i in range ( 10 ) ]\nfor line in f :\n    x , y , size = map ( int , line.split ( ',' ) )\n    for dx , dy in drop_range [ size ] :\n        drop ( paper , x + dx , y + dy )\npaper = [ x for y in paper for x in y ]\nprint ( sum ( 1 for thick in paper if thick == 0 ) )\nprint ( max ( paper ) )\n", "python_code_tokenized": "import sys NEW_LINE f = sys . stdin NEW_LINE def drop ( paper , x , y ) : NEW_LINE INDENT if 0 <= x < len ( paper [ 0 ] ) and 0 <= y < len ( paper ) : NEW_LINE INDENT paper [ y ] [ x ] += 1 NEW_LINE DEDENT DEDENT drop_range = { } NEW_LINE drop_range [ 1 ] = ( ( 0 , 0 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ) NEW_LINE drop_range [ 2 ] = drop_range [ 1 ] + ( ( - 1 , - 1 ) , ( 1 , - 1 ) , ( 1 , 1 ) , ( - 1 , 1 ) ) NEW_LINE drop_range [ 3 ] = drop_range [ 2 ] + ( ( 0 , - 2 ) , ( 2 , 0 ) , ( 0 , 2 ) , ( - 2 , 0 ) ) NEW_LINE paper = [ [ 0 for j in range ( 10 ) ] for i in range ( 10 ) ] NEW_LINE for line in f : NEW_LINE INDENT x , y , size = map ( int , line . split ( ' , ' ) ) NEW_LINE for dx , dy in drop_range [ size ] : NEW_LINE INDENT drop ( paper , x + dx , y + dy ) NEW_LINE DEDENT DEDENT paper = [ x for y in paper for x in y ] NEW_LINE print ( sum ( 1 for thick in paper if thick == 0 ) ) NEW_LINE print ( max ( paper ) ) NEW_LINE"}
{"id": "geeksforgeeks_1504_A", "sol": 0, "python_code": "def find_digit ( s , n ) :\n    first_digit = - 1\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        if s [ i ] < '0' or s [ i ] > '9' :\n            first_digit = i\n            break\n    first_digit += 1\n    s_len = first_digit\n    num = 0\n    pw = 1\n    i = n - 1\n    while i >= 0 :\n        if s [ i ] >= '0' and s [ i ] <= '9' :\n            digit = ord ( s [ i ] ) - ord ( '0' )\n            num = num + ( pw * digit )\n            if num >= s_len :\n                return - 1\n            pw = pw * 10\n        i -= 1\n    num = num * 10\n    req = s_len - num\n    if req > 9 or req < 0 :\n        return - 1\n    return req\nif __name__ == \"__main__\" :\n    s = \"abcd0\"\n    n = len ( s )\n    print ( find_digit ( s , n ) )\n", "python_code_tokenized": "def find_digit ( s , n ) : NEW_LINE INDENT first_digit = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] < '0' or s [ i ] > '9' : NEW_LINE INDENT first_digit = i NEW_LINE break NEW_LINE DEDENT DEDENT first_digit += 1 NEW_LINE s_len = first_digit NEW_LINE num = 0 NEW_LINE pw = 1 NEW_LINE i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if s [ i ] >= '0' and s [ i ] <= '9' : NEW_LINE INDENT digit = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE num = num + ( pw * digit ) NEW_LINE if num >= s_len : NEW_LINE INDENT return - 1 NEW_LINE DEDENT pw = pw * 10 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT num = num * 10 NEW_LINE req = s_len - num NEW_LINE if req > 9 or req < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return req NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abcd0\" NEW_LINE n = len ( s ) NEW_LINE print ( find_digit ( s , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3759_A", "sol": 0, "python_code": "def segregate0and1 ( arr , size ) :\n    type0 = 0\n    type1 = size - 1\n    while ( type0 < type1 ) :\n        if ( arr [ type0 ] == 1 ) :\n            ( arr [ type0 ] , arr [ type1 ] ) = ( arr [ type1 ] , arr [ type0 ] )\n            type1 -= 1\n        else :\n            type0 += 1\narr = [ 0 , 1 , 0 , 1 , 1 , 1 ]\narr_size = len ( arr )\nsegregate0and1 ( arr , arr_size )\nprint ( \"Array after segregation is\" , end = \" \" )\nfor i in range ( 0 , arr_size ) :\n    print ( arr [ i ] , end = \" \" )\n", "python_code_tokenized": "def segregate0and1 ( arr , size ) : NEW_LINE INDENT type0 = 0 NEW_LINE type1 = size - 1 NEW_LINE while ( type0 < type1 ) : NEW_LINE INDENT if ( arr [ type0 ] == 1 ) : NEW_LINE INDENT ( arr [ type0 ] , arr [ type1 ] ) = ( arr [ type1 ] , arr [ type0 ] ) NEW_LINE type1 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT type0 += 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE segregate0and1 ( arr , arr_size ) NEW_LINE print ( \" Array \u2581 after \u2581 segregation \u2581 is \" , end = \" \u2581 \" ) NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5215_A", "sol": 0, "python_code": "def pythagoreanTriplet ( n ) :\n    for i in range ( 1 , int ( n / 3 ) + 1 ) :\n        for j in range ( i + 1 , int ( n / 2 ) + 1 ) :\n            k = n - i - j\n            if ( i * i + j * j == k * k ) :\n                print ( i , \", \" , j , \", \" , k , sep = \"\" )\n                return\n    print ( \"No Triplet\" )\nn = 12\npythagoreanTriplet ( n )\n", "python_code_tokenized": "def pythagoreanTriplet ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( n / 3 ) + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if ( i * i + j * j == k * k ) : NEW_LINE INDENT print ( i , \" , \u2581 \" , j , \" , \u2581 \" , k , sep = \" \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( \" No \u2581 Triplet \" ) NEW_LINE DEDENT n = 12 NEW_LINE pythagoreanTriplet ( n ) NEW_LINE"}
{"id": "geeksforgeeks_3230_A", "sol": 0, "python_code": "def maxSumBitonicSubArr ( arr , n ) :\n    msis = [ None ] * n\n    msds = [ None ] * n\n    max_sum = 0\n    msis [ 0 ] = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        if ( arr [ i ] > arr [ i - 1 ] ) :\n            msis [ i ] = msis [ i - 1 ] + arr [ i ]\n        else :\n            msis [ i ] = arr [ i ]\n    msds [ n - 1 ] = arr [ n - 1 ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if ( arr [ i ] > arr [ i + 1 ] ) :\n            msds [ i ] = msds [ i + 1 ] + arr [ i ]\n        else :\n            msds [ i ] = arr [ i ]\n    for i in range ( n ) :\n        if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) :\n            max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] )\n    return max_sum\narr = [ 5 , 3 , 9 , 2 , 7 , 6 , 4 ] ;\nn = len ( arr )\nprint ( \"Maximum Sum = \" + str ( maxSumBitonicSubArr ( arr , n ) ) )\n", "python_code_tokenized": "def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT msis = [ None ] * n NEW_LINE msds = [ None ] * n NEW_LINE max_sum = 0 NEW_LINE msis [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT msis [ i ] = msis [ i - 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT msds [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT msds [ i ] = msds [ i + 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msds [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : NEW_LINE INDENT max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT arr = [ 5 , 3 , 9 , 2 , 7 , 6 , 4 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum \u2581 Sum \u2581 = \u2581 \" + str ( maxSumBitonicSubArr ( arr , n ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_3867_A", "sol": 0, "python_code": "def findCnt ( arr , n , k ) :\n    ret = 0 ;\n    i = 0 ;\n    while ( i < n ) :\n        j = i + 1 ;\n        while ( j < n and arr [ j ] >= arr [ j - 1 ] ) :\n            j += 1 ;\n        x = max ( 0 , j - i - k ) ;\n        ret += ( x * ( x + 1 ) ) / 2 ;\n        i = j ;\n    return ret ;\nif __name__ == \"__main__\" :\n    arr = [ 5 , 4 , 3 , 2 , 1 ] ;\n    n = len ( arr ) ;\n    k = 2 ;\n    print ( findCnt ( arr , n , k ) ) ;\n", "python_code_tokenized": "def findCnt ( arr , n , k ) : NEW_LINE INDENT ret = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 ; NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT x = max ( 0 , j - i - k ) ; NEW_LINE ret += ( x * ( x + 1 ) ) / 2 ; NEW_LINE i = j ; NEW_LINE DEDENT return ret ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 3 , 2 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE print ( findCnt ( arr , n , k ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2884_A", "sol": 0, "python_code": "def spellsCount ( num ) :\n    n = len ( num ) ;\n    result = 1 ;\n    i = 0 ;\n    while ( i < n ) :\n        count = 1 ;\n        while ( i < n - 1 and num [ i + 1 ] == num [ i ] ) :\n            count += 1 ;\n            i += 1 ;\n        result = result * int ( pow ( 2 , count - 1 ) ) ;\n        i += 1 ;\n    return result ;\nnum = \"11112\" ;\nprint ( spellsCount ( num ) ) ;\n", "python_code_tokenized": "def spellsCount ( num ) : NEW_LINE INDENT n = len ( num ) ; NEW_LINE result = 1 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT count = 1 ; NEW_LINE while ( i < n - 1 and num [ i + 1 ] == num [ i ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT result = result * int ( pow ( 2 , count - 1 ) ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT num = \"11112\" ; NEW_LINE print ( spellsCount ( num ) ) ; NEW_LINE"}
{"id": "codeforces_1474_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    li = list ( map ( int , input ( ) ) )\n    res = [ ]\n    ans = [ ]\n    if li [ 0 ] == 0 :\n        res.append ( 1 )\n        ans.append ( 1 )\n    else :\n        res.append ( 2 )\n        ans.append ( 1 )\n    for i in range ( 1 , n ) :\n        if li [ i ] == 1 and res [ i - 1 ] == 1 :\n            res.append ( 2 )\n            ans.append ( 1 )\n        elif li [ i ] == 0 and res [ i - 1 ] == 1 :\n            res.append ( 0 )\n            ans.append ( 0 )\n        elif li [ i ] == 1 and res [ i - 1 ] == 2 :\n            res.append ( 1 )\n            ans.append ( 0 )\n        elif li [ i ] == 0 and res [ i - 1 ] == 2 :\n            res.append ( 1 )\n            ans.append ( 1 )\n        elif li [ i ] == 0 and res [ i - 1 ] == 0 :\n            res.append ( 1 )\n            ans.append ( 1 )\n        elif li [ i ] == 1 and res [ i - 1 ] == 0 :\n            res.append ( 2 )\n            ans.append ( 1 )\n    print ( * ans , sep = '' )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE li = list ( map ( int , input ( ) ) ) NEW_LINE res = [ ] NEW_LINE ans = [ ] NEW_LINE if li [ 0 ] == 0 : NEW_LINE INDENT res . append ( 1 ) NEW_LINE ans . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( 2 ) NEW_LINE ans . append ( 1 ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if li [ i ] == 1 and res [ i - 1 ] == 1 : NEW_LINE INDENT res . append ( 2 ) NEW_LINE ans . append ( 1 ) NEW_LINE DEDENT elif li [ i ] == 0 and res [ i - 1 ] == 1 : NEW_LINE INDENT res . append ( 0 ) NEW_LINE ans . append ( 0 ) NEW_LINE DEDENT elif li [ i ] == 1 and res [ i - 1 ] == 2 : NEW_LINE INDENT res . append ( 1 ) NEW_LINE ans . append ( 0 ) NEW_LINE DEDENT elif li [ i ] == 0 and res [ i - 1 ] == 2 : NEW_LINE INDENT res . append ( 1 ) NEW_LINE ans . append ( 1 ) NEW_LINE DEDENT elif li [ i ] == 0 and res [ i - 1 ] == 0 : NEW_LINE INDENT res . append ( 1 ) NEW_LINE ans . append ( 1 ) NEW_LINE DEDENT elif li [ i ] == 1 and res [ i - 1 ] == 0 : NEW_LINE INDENT res . append ( 2 ) NEW_LINE ans . append ( 1 ) NEW_LINE DEDENT DEDENT print ( * ans , sep = ' ' ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC040_C", "sol": 0, "python_code": "n = int ( input ( ) ) ; l = [ 0 , 1 ] ; a = 0 ; b = c = 1 ; p = 998244353\nfor i in range ( 2 , n ) :\n    l += [ l [ p % i ] * ( p - int ( p / i ) ) % p ]\nfor i in range ( n , n // 2 , - 1 ) :\n    a += b * c % p ; b = 2 * b % p ; c = c * i * l [ n + 1 - i ] % p\nprint ( ( pow ( 3 , n , p ) - 2 * a ) % p )\n", "python_code_tokenized": "n = int ( input ( ) ) ; l = [ 0 , 1 ] ; a = 0 ; b = c = 1 ; p = 998244353 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT l += [ l [ p % i ] * ( p - int ( p / i ) ) % p ] NEW_LINE DEDENT for i in range ( n , n // 2 , - 1 ) : NEW_LINE INDENT a += b * c % p ; b = 2 * b % p ; c = c * i * l [ n + 1 - i ] % p NEW_LINE DEDENT print ( ( pow ( 3 , n , p ) - 2 * a ) % p ) NEW_LINE"}
{"id": "geeksforgeeks_4019_A", "sol": 0, "python_code": "def findNumber ( N , S ) :\n    i = ( ( ( N ) * ( N + 1 ) ) / 4 ) - ( ( S + 1 ) / 2 ) ;\n    return i ;\ndef check ( N , S ) :\n    i = findNumber ( N , S ) ;\n    integerI = int ( i ) ;\n    if ( i - integerI == 0 ) :\n        print ( \"Yes:\" , integerI , \",\" , integerI + 1 ) ;\n    else :\n        print ( \"No\" ) ;\nif __name__ == \"__main__\" :\n    N = 4 ;\n    S = 3 ;\n    check ( N , S ) ;\n    N = 5 ;\n    S = 3 ;\n    check ( N , S ) ;\n", "python_code_tokenized": "def findNumber ( N , S ) : NEW_LINE INDENT i = ( ( ( N ) * ( N + 1 ) ) / 4 ) - ( ( S + 1 ) / 2 ) ; NEW_LINE return i ; NEW_LINE DEDENT def check ( N , S ) : NEW_LINE INDENT i = findNumber ( N , S ) ; NEW_LINE integerI = int ( i ) ; NEW_LINE if ( i - integerI == 0 ) : NEW_LINE INDENT print ( \" Yes : \" , integerI , \" , \" , integerI + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE N = 5 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE DEDENT"}
{"id": "codejam_10_22", "sol": 0, "python_code": "import sys\nif ( len ( sys.argv ) < 2 ) :\n    print ( \"No file specified\" )\n    sys.exit ( 1 )\ninfile = open ( sys.argv [ 1 ] )\noutfile = open ( sys.argv [ 1 ] + \".out\" , \"w\" )\nnum_cases = int ( infile.readline ( ).strip ( ) )\nfor case in range ( 1 , num_cases + 1 ) :\n    n , k , b , t = map ( int , infile.readline ( ).split ( ) )\n    positions = map ( int , infile.readline ( ).split ( ) )\n    speeds = map ( int , infile.readline ( ).split ( ) )\n    positions.reverse ( )\n    speeds.reverse ( )\n    swaps = 0\n    chick_idx = 0\n    found_completers = 0\n    while chick_idx < n and found_completers < k :\n        if speeds [ chick_idx ] * t >= ( b - positions [ chick_idx ] ) :\n            swaps += chick_idx - found_completers\n            found_completers += 1\n        chick_idx += 1\n    if found_completers < k :\n        result = \"IMPOSSIBLE\"\n    else :\n        result = \"%d\" % swaps\n    outfile.write ( \"Case #%d: %s\\n\" % ( case , result ) )\n    if case % 100 == 0 :\n        print ( \"Completed case %d\" % case )\noutfile.close ( )\ninfile.close ( )\n", "python_code_tokenized": "import sys NEW_LINE if ( len ( sys . argv ) < 2 ) : NEW_LINE INDENT print ( \" No \u2581 file \u2581 specified \" ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT infile = open ( sys . argv [ 1 ] ) NEW_LINE outfile = open ( sys . argv [ 1 ] + \" . out \" , \" w \" ) NEW_LINE num_cases = int ( infile . readline ( ) . strip ( ) ) NEW_LINE for case in range ( 1 , num_cases + 1 ) : NEW_LINE INDENT n , k , b , t = map ( int , infile . readline ( ) . split ( ) ) NEW_LINE positions = map ( int , infile . readline ( ) . split ( ) ) NEW_LINE speeds = map ( int , infile . readline ( ) . split ( ) ) NEW_LINE positions . reverse ( ) NEW_LINE speeds . reverse ( ) NEW_LINE swaps = 0 NEW_LINE chick_idx = 0 NEW_LINE found_completers = 0 NEW_LINE while chick_idx < n and found_completers < k : NEW_LINE INDENT if speeds [ chick_idx ] * t >= ( b - positions [ chick_idx ] ) : NEW_LINE INDENT swaps += chick_idx - found_completers NEW_LINE found_completers += 1 NEW_LINE DEDENT chick_idx += 1 NEW_LINE DEDENT if found_completers < k : NEW_LINE INDENT result = \" IMPOSSIBLE \" NEW_LINE DEDENT else : NEW_LINE INDENT result = \" % d \" % swaps NEW_LINE DEDENT outfile . write ( \" Case \u2581 # % d : \u2581 % s \\n \" % ( case , result ) ) NEW_LINE if case % 100 == 0 : NEW_LINE INDENT print ( \" Completed \u2581 case \u2581 % d \" % case ) NEW_LINE DEDENT DEDENT outfile . close ( ) NEW_LINE infile . close ( ) NEW_LINE"}
{"id": "geeksforgeeks_3525_A", "sol": 0, "python_code": "INT_BITS = 32\ndef maxSubarrayXOR ( set , n ) :\n    index = 0\n    for i in range ( INT_BITS - 1 , - 1 , - 1 ) :\n        maxInd = index\n        maxEle = - 2147483648\n        for j in range ( index , n ) :\n            if ( ( set [ j ] & ( 1 << i ) ) != 0 and set [ j ] > maxEle ) :\n                maxEle = set [ j ]\n                maxInd = j\n        if ( maxEle == - 2147483648 ) :\n            continue\n        temp = set [ index ]\n        set [ index ] = set [ maxInd ]\n        set [ maxInd ] = temp\n        maxInd = index\n        for j in range ( n ) :\n            if ( j != maxInd and ( set [ j ] & ( 1 << i ) ) != 0 ) :\n                set [ j ] = set [ j ] ^ set [ maxInd ]\n        index = index + 1\n    res = 0\n    for i in range ( n ) :\n        res = res ^ set [ i ]\n    return res\nset = [ 9 , 8 , 5 ]\nn = len ( set )\nprint ( \"Max subset XOR is \" , end = \"\" )\nprint ( maxSubarrayXOR ( set , n ) )\n", "python_code_tokenized": "INT_BITS = 32 NEW_LINE def maxSubarrayXOR ( set , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( INT_BITS - 1 , - 1 , - 1 ) : NEW_LINE INDENT maxInd = index NEW_LINE maxEle = - 2147483648 NEW_LINE for j in range ( index , n ) : NEW_LINE INDENT if ( ( set [ j ] & ( 1 << i ) ) != 0 and set [ j ] > maxEle ) : NEW_LINE INDENT maxEle = set [ j ] NEW_LINE maxInd = j NEW_LINE DEDENT DEDENT if ( maxEle == - 2147483648 ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = set [ index ] NEW_LINE set [ index ] = set [ maxInd ] NEW_LINE set [ maxInd ] = temp NEW_LINE maxInd = index NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( j != maxInd and ( set [ j ] & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT set [ j ] = set [ j ] ^ set [ maxInd ] NEW_LINE DEDENT DEDENT index = index + 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = res ^ set [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT set = [ 9 , 8 , 5 ] NEW_LINE n = len ( set ) NEW_LINE print ( \" Max \u2581 subset \u2581 XOR \u2581 is \u2581 \" , end = \" \" ) NEW_LINE print ( maxSubarrayXOR ( set , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2207_A", "sol": 0, "python_code": "def findSurpasser ( arr , n ) :\n    for i in range ( 0 , n ) :\n        count = 0 ;\n        for j in range ( i + 1 , n ) :\n            if ( arr [ j ] > arr [ i ] ) :\n                count += 1\n        print ( count , end = \" \" )\ndef printArray ( arr , n ) :\n    for i in range ( 0 , n ) :\n        print ( arr [ i ] , end = \" \" )\narr = [ 2 , 7 , 5 , 3 , 0 , 8 , 1 ]\nn = len ( arr )\nprint ( \"Given array is\" )\nprintArray ( arr , n )\nprint ( \"\\nSurpasser Count of array is\" ) ;\nfindSurpasser ( arr , n )\n", "python_code_tokenized": "def findSurpasser ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT arr = [ 2 , 7 , 5 , 3 , 0 , 8 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Given \u2581 array \u2581 is \" ) NEW_LINE printArray ( arr , n ) NEW_LINE print ( \" \\n Surpasser \u2581 Count \u2581 of \u2581 array \u2581 is \" ) ; NEW_LINE findSurpasser ( arr , n ) NEW_LINE"}
{"id": "codeforces_1421_A", "sol": 0, "python_code": "n = int ( input ( ) )\nwhile n :\n    a , b = map ( int , input ( ).split ( ) )\n    print ( a ^ b )\n    n -= 1\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE while n : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a ^ b ) NEW_LINE n -= 1 NEW_LINE DEDENT"}
{"id": "atcoder_ABC089_B", "sol": 0, "python_code": "def actual ( N , S ) :\n    number_of_hina_arare_types = len ( set ( S ) )\n    color_map = { 3 : 'Three' , 4 : 'Four' }\n    return color_map [ number_of_hina_arare_types ]\nN = int ( input ( ) )\nS = input ( ).split ( )\nprint ( actual ( N , S ) )\n", "python_code_tokenized": "def actual ( N , S ) : NEW_LINE INDENT number_of_hina_arare_types = len ( set ( S ) ) NEW_LINE color_map = { 3 : ' Three ' , 4 : ' Four ' } NEW_LINE return color_map [ number_of_hina_arare_types ] NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE S = input ( ) . split ( ) NEW_LINE print ( actual ( N , S ) ) NEW_LINE"}
{"id": "geeksforgeeks_3898_A", "sol": 0, "python_code": "class Graph :\n    def __init__ ( self , V ) :\n        self.V = V\n        self.adj = [ [ ] for i in range ( V ) ]\n    def addEdge ( self , u , v ) :\n        self.adj [ u ].append ( v )\n        self.adj [ v ].append ( u )\n    def countEdges ( self ) :\n        Sum = 0\n        for i in range ( self.V ) :\n            Sum += len ( self.adj [ i ] )\n        return Sum // 2\nif __name__ == '__main__' :\n    V = 9\n    g = Graph ( V )\n    g.addEdge ( 0 , 1 )\n    g.addEdge ( 0 , 7 )\n    g.addEdge ( 1 , 2 )\n    g.addEdge ( 1 , 7 )\n    g.addEdge ( 2 , 3 )\n    g.addEdge ( 2 , 8 )\n    g.addEdge ( 2 , 5 )\n    g.addEdge ( 3 , 4 )\n    g.addEdge ( 3 , 5 )\n    g.addEdge ( 4 , 5 )\n    g.addEdge ( 5 , 6 )\n    g.addEdge ( 6 , 7 )\n    g.addEdge ( 6 , 8 )\n    g.addEdge ( 7 , 8 )\n    print ( g.countEdges ( ) )\n", "python_code_tokenized": "class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . adj [ u ] . append ( v ) NEW_LINE self . adj [ v ] . append ( u ) NEW_LINE DEDENT def countEdges ( self ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( self . V ) : NEW_LINE INDENT Sum += len ( self . adj [ i ] ) NEW_LINE DEDENT return Sum // 2 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT V = 9 NEW_LINE g = Graph ( V ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 7 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 1 , 7 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 2 , 8 ) NEW_LINE g . addEdge ( 2 , 5 ) NEW_LINE g . addEdge ( 3 , 4 ) NEW_LINE g . addEdge ( 3 , 5 ) NEW_LINE g . addEdge ( 4 , 5 ) NEW_LINE g . addEdge ( 5 , 6 ) NEW_LINE g . addEdge ( 6 , 7 ) NEW_LINE g . addEdge ( 6 , 8 ) NEW_LINE g . addEdge ( 7 , 8 ) NEW_LINE print ( g . countEdges ( ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00005_A", "sol": 0, "python_code": "import math\nwhile True :\n    try :\n        a , b = map ( int , input ( ).split ( ) )\n        print ( math.gcd ( a , b ) , a * b // math.gcd ( a , b ) )\n    except :\n        break\n", "python_code_tokenized": "import math NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( math . gcd ( a , b ) , a * b // math . gcd ( a , b ) ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_577_A", "sol": 0, "python_code": "n , x = input ( ).split ( \" \" )\nn = int ( n )\nx = int ( x )\ncount = 0\nfor i in range ( 1 , n + 1 ) :\n    if x % i == 0 and x // i <= n :\n        if i == 1 and x <= n :\n            count += 1\n        elif i > 1 :\n            count += 1\nprint ( count )\n", "python_code_tokenized": "n , x = input ( ) . split ( \" \u2581 \" ) NEW_LINE n = int ( n ) NEW_LINE x = int ( x ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if x % i == 0 and x // i <= n : NEW_LINE INDENT if i == 1 and x <= n : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif i > 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE"}
{"id": "geeksforgeeks_1308_A", "sol": 0, "python_code": "def topsyTurvy ( string ) :\n    for i in range ( len ( string ) ) :\n        if ( string [ i ] == '2' or string [ i ] == '4' or string [ i ] == '5' or string [ i ] == '6' or string [ i ] == '7' or string [ i ] == '9' ) :\n            return False ;\n    return True ;\nif __name__ == \"__main__\" :\n    string = \"1234\" ;\n    if ( topsyTurvy ( string ) ) :\n        print ( \"Yes\" ) ;\n    else :\n        print ( \"No\" ) ;\n", "python_code_tokenized": "def topsyTurvy ( string ) : NEW_LINE INDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == '2' or string [ i ] == '4' or string [ i ] == '5' or string [ i ] == '6' or string [ i ] == '7' or string [ i ] == '9' ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"1234\" ; NEW_LINE if ( topsyTurvy ( string ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC089_A", "sol": 0, "python_code": "import math\nn = int ( input ( ) )\nprint ( '{:.0f}'.format ( math.floor ( n / 3 ) ) )\n", "python_code_tokenized": "import math NEW_LINE n = int ( input ( ) ) NEW_LINE print ( ' { : . 0f } ' . format ( math . floor ( n / 3 ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_2710_A", "sol": 0, "python_code": "MAX_CHAR = 26\ndef removeChars ( str , k ) :\n    hash = [ 0 ] * ( MAX_CHAR )\n    n = len ( str )\n    for i in range ( n ) :\n        hash [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1\n    res = \"\"\n    for i in range ( n ) :\n        if ( hash [ ord ( str [ i ] ) - ord ( 'a' ) ] >= k ) :\n            res += str [ i ]\n    return res\nif __name__ == \"__main__\" :\n    str = \"geeksforgeeks\"\n    k = 2\n    print ( removeChars ( str , k ) )\n", "python_code_tokenized": "MAX_CHAR = 26 NEW_LINE def removeChars ( str , k ) : NEW_LINE INDENT hash = [ 0 ] * ( MAX_CHAR ) NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT res = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] >= k ) : NEW_LINE INDENT res += str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_677_A", "sol": 0, "python_code": "def removeAlternate ( n ) :\n    if ( n == 1 ) :\n        return 1\n    if ( n % 2 == 0 ) :\n        return 2 * removeAlternate ( n / 2 ) - 1\n    else :\n        return 2 * removeAlternate ( ( ( n - 1 ) / 2 ) ) + 1\nn = 5\nprint ( removeAlternate ( n ) )\nn = 10\nprint ( removeAlternate ( n ) )\n", "python_code_tokenized": "def removeAlternate ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 * removeAlternate ( n / 2 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * removeAlternate ( ( ( n - 1 ) / 2 ) ) + 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE n = 10 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE"}
{"id": "codeforces_235_B", "sol": 0, "python_code": "n = int ( input ( ) )\np = list ( map ( float , input ( ).split ( ) ) )\nif n == 1 :\n    print ( p [ 0 ] )\n    quit ( )\nM = [ 0.0 ] * n\nf = [ 0.0 ] * n\nf [ 0 ] = 1.0\nfor i in range ( 1 , n ) :\n    f [ i ] = p [ i ] * f [ i - 1 ] + 1 - p [ i ]\nres = p [ 0 ] * p [ 1 ]\nans = res\nfor i in range ( 2 , n ) :\n    temp = ( 1 - p [ i - 1 ] ) + p [ i - 1 ] * ( 1 - p [ i - 2 ] )\n    res = p [ i ] * p [ i - 1 ] * ( 1 - p [ i - 2 ] ) + p [ i ] * ( res + 1 - temp )\n    ans += res\nprint ( sum ( p ) + 2 * ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE p = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( p [ 0 ] ) NEW_LINE quit ( ) NEW_LINE DEDENT M = [ 0.0 ] * n NEW_LINE f = [ 0.0 ] * n NEW_LINE f [ 0 ] = 1.0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT f [ i ] = p [ i ] * f [ i - 1 ] + 1 - p [ i ] NEW_LINE DEDENT res = p [ 0 ] * p [ 1 ] NEW_LINE ans = res NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT temp = ( 1 - p [ i - 1 ] ) + p [ i - 1 ] * ( 1 - p [ i - 2 ] ) NEW_LINE res = p [ i ] * p [ i - 1 ] * ( 1 - p [ i - 2 ] ) + p [ i ] * ( res + 1 - temp ) NEW_LINE ans += res NEW_LINE DEDENT print ( sum ( p ) + 2 * ans ) NEW_LINE"}
{"id": "geeksforgeeks_2661_A", "sol": 0, "python_code": "def flip ( ch ) :\n    return '1' if ( ch == '0' ) else '0'\ndef getFlipWithStartingCharcter ( str , expected ) :\n    flipCount = 0\n    for i in range ( len ( str ) ) :\n        if ( str [ i ] != expected ) :\n            flipCount += 1\n        expected = flip ( expected )\n    return flipCount\ndef minFlipToMakeStringAlternate ( str ) :\n    return min ( getFlipWithStartingCharcter ( str , '0' ) , getFlipWithStartingCharcter ( str , '1' ) )\nif __name__ == \"__main__\" :\n    str = \"0001010111\"\n    print ( minFlipToMakeStringAlternate ( str ) )\n", "python_code_tokenized": "def flip ( ch ) : NEW_LINE INDENT return '1' if ( ch == '0' ) else '0' NEW_LINE DEDENT def getFlipWithStartingCharcter ( str , expected ) : NEW_LINE INDENT flipCount = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] != expected ) : NEW_LINE INDENT flipCount += 1 NEW_LINE DEDENT expected = flip ( expected ) NEW_LINE DEDENT return flipCount NEW_LINE DEDENT def minFlipToMakeStringAlternate ( str ) : NEW_LINE INDENT return min ( getFlipWithStartingCharcter ( str , '0' ) , getFlipWithStartingCharcter ( str , '1' ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"0001010111\" NEW_LINE print ( minFlipToMakeStringAlternate ( str ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC044_C", "sol": 0, "python_code": "import sys\nimport numpy as np\nn , a , * x = map ( int , sys.stdin.read ( ).split ( ) )\ndef main ( ) :\n    m = 2500\n    dp = np.zeros ( ( n + 1 , m + 1 ) , dtype = np.int64 )\n    dp [ 0 , 0 ] = 1\n    for i in range ( n ) :\n        dp [ 1 : , x [ i ] : ] += dp [ : - 1 , : - x [ i ] ].copy ( )\n    i = np.arange ( 1 , n + 1 )\n    print ( dp [ i , i * a ].sum ( ) )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "import sys NEW_LINE import numpy as np NEW_LINE n , a , * x = map ( int , sys . stdin . read ( ) . split ( ) ) NEW_LINE def main ( ) : NEW_LINE INDENT m = 2500 NEW_LINE dp = np . zeros ( ( n + 1 , m + 1 ) , dtype = np . int64 ) NEW_LINE dp [ 0 , 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 1 : , x [ i ] : ] += dp [ : - 1 , : - x [ i ] ] . copy ( ) NEW_LINE DEDENT i = np . arange ( 1 , n + 1 ) NEW_LINE print ( dp [ i , i * a ] . sum ( ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "aizu_p02364_A", "sol": 0, "python_code": "num_v , num_e = input ( ).split ( )\nedges = [ ]\nverticies = [ ]\nfor i in range ( int ( num_e ) ) :\n    v , u , w = input ( ).split ( )\n    e = ( v , u , int ( w ) )\n    edges.append ( e )\nfor v in range ( int ( num_v ) ) :\n    v = str ( v )\n    verticies.append ( v )\ngraph = { 'verticies' : verticies , 'edges' : edges }\nparent = { }\ng_len = { }\ndef group ( v ) :\n    parent [ v ] = v\n    g_len [ v ] = 0\ndef my_parent ( v ) :\n    if parent [ v ] != v :\n        parent [ v ] = my_parent ( parent [ v ] )\n    return parent [ v ]\ndef union ( v , u ) :\n    g_v = my_parent ( v )\n    g_u = my_parent ( u )\n    if g_v != g_u :\n        if g_len [ g_v ] >= g_len [ g_u ] :\n            parent [ g_u ] = parent [ g_v ]\n            g_len [ g_v ] += 1\n        else :\n            parent [ g_v ] = parent [ g_u ]\n            g_len [ g_u ] += 1\ndef kruskal ( graph ) :\n    g_list = [ ]\n    sum_w = 0\n    for v in graph [ 'verticies' ] :\n        group ( v )\n    edges = graph [ 'edges' ]\n    edges.sort ( key = lambda edges : edges [ 2 ] )\n    for edge in edges :\n        v , u , weight = edge\n        if my_parent ( v ) != my_parent ( u ) :\n            union ( v , u )\n            g_list.append ( edge )\n            sum_w = sum_w + weight\n    return sum_w\nprint ( kruskal ( graph ) )\n", "python_code_tokenized": "num_v , num_e = input ( ) . split ( ) NEW_LINE edges = [ ] NEW_LINE verticies = [ ] NEW_LINE for i in range ( int ( num_e ) ) : NEW_LINE INDENT v , u , w = input ( ) . split ( ) NEW_LINE e = ( v , u , int ( w ) ) NEW_LINE edges . append ( e ) NEW_LINE DEDENT for v in range ( int ( num_v ) ) : NEW_LINE INDENT v = str ( v ) NEW_LINE verticies . append ( v ) NEW_LINE DEDENT graph = { ' verticies ' : verticies , ' edges ' : edges } NEW_LINE parent = { } NEW_LINE g_len = { } NEW_LINE def group ( v ) : NEW_LINE INDENT parent [ v ] = v NEW_LINE g_len [ v ] = 0 NEW_LINE DEDENT def my_parent ( v ) : NEW_LINE INDENT if parent [ v ] != v : NEW_LINE INDENT parent [ v ] = my_parent ( parent [ v ] ) NEW_LINE DEDENT return parent [ v ] NEW_LINE DEDENT def union ( v , u ) : NEW_LINE INDENT g_v = my_parent ( v ) NEW_LINE g_u = my_parent ( u ) NEW_LINE if g_v != g_u : NEW_LINE INDENT if g_len [ g_v ] >= g_len [ g_u ] : NEW_LINE INDENT parent [ g_u ] = parent [ g_v ] NEW_LINE g_len [ g_v ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT parent [ g_v ] = parent [ g_u ] NEW_LINE g_len [ g_u ] += 1 NEW_LINE DEDENT DEDENT DEDENT def kruskal ( graph ) : NEW_LINE INDENT g_list = [ ] NEW_LINE sum_w = 0 NEW_LINE for v in graph [ ' verticies ' ] : NEW_LINE INDENT group ( v ) NEW_LINE DEDENT edges = graph [ ' edges ' ] NEW_LINE edges . sort ( key = lambda edges : edges [ 2 ] ) NEW_LINE for edge in edges : NEW_LINE INDENT v , u , weight = edge NEW_LINE if my_parent ( v ) != my_parent ( u ) : NEW_LINE INDENT union ( v , u ) NEW_LINE g_list . append ( edge ) NEW_LINE sum_w = sum_w + weight NEW_LINE DEDENT DEDENT return sum_w NEW_LINE DEDENT print ( kruskal ( graph ) ) NEW_LINE"}
{"id": "codeforces_1059_A", "sol": 0, "python_code": "import math\nn , L , a = input ( ).split ( )\nn = int ( n )\nL = int ( L )\na = int ( a )\nh = [ ]\nif ( n <= 0 ) :\n    print ( math.floor ( L / a ) )\nelse :\n    for i in range ( n ) :\n        t , l = input ( ).split ( )\n        h.append ( ( int ( t ) , int ( l ) ) )\n    first = math.floor ( h [ 0 ] [ 0 ] / a )\n    middle = 0\n    for i in range ( n - 1 ) :\n        mid = h [ i + 1 ] [ 0 ] - ( h [ i ] [ 0 ] + h [ i ] [ 1 ] )\n        middle += math.floor ( mid / a )\n    last = math.floor ( ( L - ( h [ len ( h ) - 1 ] [ 0 ] + h [ len ( h ) - 1 ] [ 1 ] ) ) / a )\n    print ( first + middle + last )\n", "python_code_tokenized": "import math NEW_LINE n , L , a = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE L = int ( L ) NEW_LINE a = int ( a ) NEW_LINE h = [ ] NEW_LINE if ( n <= 0 ) : NEW_LINE INDENT print ( math . floor ( L / a ) ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT t , l = input ( ) . split ( ) NEW_LINE h . append ( ( int ( t ) , int ( l ) ) ) NEW_LINE DEDENT first = math . floor ( h [ 0 ] [ 0 ] / a ) NEW_LINE middle = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT mid = h [ i + 1 ] [ 0 ] - ( h [ i ] [ 0 ] + h [ i ] [ 1 ] ) NEW_LINE middle += math . floor ( mid / a ) NEW_LINE DEDENT last = math . floor ( ( L - ( h [ len ( h ) - 1 ] [ 0 ] + h [ len ( h ) - 1 ] [ 1 ] ) ) / a ) NEW_LINE print ( first + middle + last ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4126_A", "sol": 0, "python_code": "def lexNext ( s , n ) :\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        if s [ i ] != 'z' :\n            k = ord ( s [ i ] )\n            s [ i ] = chr ( k + 1 )\n            return ''.join ( s )\n        s [ i ] = 'a'\nif __name__ == \"__main__\" :\n    S = \"abcdeg\"\n    T = \"abcfgh\"\n    n = len ( S )\n    S = list ( S )\n    res = lexNext ( S , n )\n    if res != T :\n        print ( res )\n    else :\n        print ( - 1 )\n", "python_code_tokenized": "def lexNext ( s , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] != ' z ' : NEW_LINE INDENT k = ord ( s [ i ] ) NEW_LINE s [ i ] = chr ( k + 1 ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT s [ i ] = ' a ' NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" abcdeg \" NEW_LINE T = \" abcfgh \" NEW_LINE n = len ( S ) NEW_LINE S = list ( S ) NEW_LINE res = lexNext ( S , n ) NEW_LINE if res != T : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4103_A", "sol": 0, "python_code": "def isVowel ( c ) :\n    return ( c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' ) ;\ndef countSubstringsUtil ( s ) :\n    count = 0 ;\n    mp = dict.fromkeys ( s , 0 ) ;\n    n = len ( s ) ;\n    start = 0 ;\n    for i in range ( n ) :\n        mp [ s [ i ] ] += 1 ;\n        while ( mp [ 'a' ] > 0 and mp [ 'e' ] > 0 and mp [ 'i' ] > 0 and mp [ 'o' ] > 0 and mp [ 'u' ] > 0 ) :\n            count += n - i ;\n            mp [ s [ start ] ] -= 1 ;\n            start += 1 ;\n    return count ;\ndef countSubstrings ( s ) :\n    count = 0 ;\n    temp = \"\" ;\n    for i in range ( len ( s ) ) :\n        if ( isVowel ( s [ i ] ) ) :\n            temp += s [ i ] ;\n        else :\n            if ( len ( temp ) > 0 ) :\n                count += countSubstringsUtil ( temp ) ;\n            temp = \"\" ;\n    if ( len ( temp ) > 0 ) :\n        count += countSubstringsUtil ( temp ) ;\n    return count ;\nif __name__ == \"__main__\" :\n    s = \"aeouisddaaeeiouua\" ;\n    print ( countSubstrings ( s ) ) ;\n", "python_code_tokenized": "def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) ; NEW_LINE DEDENT def countSubstringsUtil ( s ) : NEW_LINE INDENT count = 0 ; NEW_LINE mp = dict . fromkeys ( s , 0 ) ; NEW_LINE n = len ( s ) ; NEW_LINE start = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ s [ i ] ] += 1 ; NEW_LINE while ( mp [ ' a ' ] > 0 and mp [ ' e ' ] > 0 and mp [ ' i ' ] > 0 and mp [ ' o ' ] > 0 and mp [ ' u ' ] > 0 ) : NEW_LINE INDENT count += n - i ; NEW_LINE mp [ s [ start ] ] -= 1 ; NEW_LINE start += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT def countSubstrings ( s ) : NEW_LINE INDENT count = 0 ; NEW_LINE temp = \" \" ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) ) : NEW_LINE INDENT temp += s [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( temp ) > 0 ) : NEW_LINE INDENT count += countSubstringsUtil ( temp ) ; NEW_LINE DEDENT temp = \" \" ; NEW_LINE DEDENT DEDENT if ( len ( temp ) > 0 ) : NEW_LINE INDENT count += countSubstringsUtil ( temp ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aeouisddaaeeiouua \" ; NEW_LINE print ( countSubstrings ( s ) ) ; NEW_LINE DEDENT"}
{"id": "codejam_16_42", "sol": 0, "python_code": "__author__ = 'Tianren Liu'\nimport sys\nimport numpy as np\ndef solve ( Choose , Target , p , dis ) :\n    if len ( dis ) - 1 + Choose < Target :\n        return 0.\n    if Choose == 0 :\n        return dis [ Target ]\n    if Choose > len ( p ) :\n        return 0\n    ndis = np.zeros ( len ( dis ) + 1 )\n    ndis [ : len ( dis ) ] += dis * ( 1 - p [ 0 ] )\n    ndis [ 1 : ] += dis * p [ 0 ]\n    res = max ( solve ( Choose - 1 , Target , p [ 1 : ] , ndis ) , solve ( Choose , Target , p [ 1 : ] , dis ) )\n    return res\nif __name__ == \"__main__\" :\n    T = int ( sys.stdin.readline ( ) )\n    for t in range ( T ) :\n        N , K = map ( int , sys.stdin.readline ( ).split ( ) )\n        p = [ float ( f ) for f in sys.stdin.readline ( ).split ( ) ]\n        print ( \"Case #{}: {}\".format ( t + 1 , solve ( K , K // 2 , p , np.array ( [ 1.] ) ) ) )\n", "python_code_tokenized": "__author__ = ' Tianren \u2581 Liu ' NEW_LINE import sys NEW_LINE import numpy as np NEW_LINE def solve ( Choose , Target , p , dis ) : NEW_LINE INDENT if len ( dis ) - 1 + Choose < Target : NEW_LINE INDENT return 0. NEW_LINE DEDENT if Choose == 0 : NEW_LINE INDENT return dis [ Target ] NEW_LINE DEDENT if Choose > len ( p ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ndis = np . zeros ( len ( dis ) + 1 ) NEW_LINE ndis [ : len ( dis ) ] += dis * ( 1 - p [ 0 ] ) NEW_LINE ndis [ 1 : ] += dis * p [ 0 ] NEW_LINE res = max ( solve ( Choose - 1 , Target , p [ 1 : ] , ndis ) , solve ( Choose , Target , p [ 1 : ] , dis ) ) NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT N , K = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE p = [ float ( f ) for f in sys . stdin . readline ( ) . split ( ) ] NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( t + 1 , solve ( K , K // 2 , p , np . array ( [ 1. ] ) ) ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1389_A", "sol": 0, "python_code": "def GCD ( a , b ) :\n    if ( b == 0 ) :\n        return a\n    return GCD ( b , a % b )\ndef FillPrefixSuffix ( prefix , arr , suffix , n ) :\n    prefix [ 0 ] = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        prefix [ i ] = GCD ( prefix [ i - 1 ] , arr [ i ] )\n    suffix [ n - 1 ] = arr [ n - 1 ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        suffix [ i ] = GCD ( suffix [ i + 1 ] , arr [ i ] )\ndef GCDoutsideRange ( l , r , prefix , suffix , n ) :\n    if ( l == 0 ) :\n        return suffix [ r + 1 ]\n    if ( r == n - 1 ) :\n        return prefix [ l - 1 ]\n    return GCD ( prefix [ l - 1 ] , suffix [ r + 1 ] )\narr = [ 2 , 6 , 9 ]\nn = len ( arr )\nprefix = [ ]\nsuffix = [ ]\nfor i in range ( n + 1 ) :\n    prefix.append ( 0 )\n    suffix.append ( 0 )\nFillPrefixSuffix ( prefix , arr , suffix , n )\nl = 0\nr = 0\nprint ( GCDoutsideRange ( l , r , prefix , suffix , n ) )\nl = 1\nr = 1\nprint ( GCDoutsideRange ( l , r , prefix , suffix , n ) )\nl = 1\nr = 2\nprint ( GCDoutsideRange ( l , r , prefix , suffix , n ) )\n", "python_code_tokenized": "def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT def FillPrefixSuffix ( prefix , arr , suffix , n ) : NEW_LINE INDENT prefix [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = GCD ( prefix [ i - 1 ] , arr [ i ] ) NEW_LINE DEDENT suffix [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffix [ i ] = GCD ( suffix [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT DEDENT def GCDoutsideRange ( l , r , prefix , suffix , n ) : NEW_LINE INDENT if ( l == 0 ) : NEW_LINE INDENT return suffix [ r + 1 ] NEW_LINE DEDENT if ( r == n - 1 ) : NEW_LINE INDENT return prefix [ l - 1 ] NEW_LINE DEDENT return GCD ( prefix [ l - 1 ] , suffix [ r + 1 ] ) NEW_LINE DEDENT arr = [ 2 , 6 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE prefix = [ ] NEW_LINE suffix = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT prefix . append ( 0 ) NEW_LINE suffix . append ( 0 ) NEW_LINE DEDENT FillPrefixSuffix ( prefix , arr , suffix , n ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE print ( GCDoutsideRange ( l , r , prefix , suffix , n ) ) NEW_LINE l = 1 NEW_LINE r = 1 NEW_LINE print ( GCDoutsideRange ( l , r , prefix , suffix , n ) ) NEW_LINE l = 1 NEW_LINE r = 2 NEW_LINE print ( GCDoutsideRange ( l , r , prefix , suffix , n ) ) NEW_LINE"}
{"id": "atcoder_ABC140_F", "sol": 0, "python_code": "N = int ( input ( ) )\nN2 = 2 ** N\nS = list ( map ( int , input ( ).split ( ) ) )\nS.sort ( reverse = True )\nslimes = [ S [ 0 ] ]\nINF = S [ 0 ] + 1\nS [ 0 ] = INF\nnum = 1\nmin_idx = 1\nfor i in range ( N ) :\n    slimes.sort ( )\n    n = num\n    idx = min_idx\n    is_continuous = True\n    while n and idx <= N2 - 1 :\n        if S [ idx ] < slimes [ n - 1 ] :\n            slimes.append ( S [ idx ] )\n            S [ idx ] = INF\n            idx += 1\n            n -= 1\n            min_idx += is_continuous\n        else :\n            if S [ idx ] < INF :\n                is_continuous = False\n            idx += 1\n            min_idx += is_continuous\n    if n :\n        print ( 'No' )\n        quit ( )\n    num *= 2\nprint ( 'Yes' )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE N2 = 2 ** N NEW_LINE S = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE S . sort ( reverse = True ) NEW_LINE slimes = [ S [ 0 ] ] NEW_LINE INF = S [ 0 ] + 1 NEW_LINE S [ 0 ] = INF NEW_LINE num = 1 NEW_LINE min_idx = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT slimes . sort ( ) NEW_LINE n = num NEW_LINE idx = min_idx NEW_LINE is_continuous = True NEW_LINE while n and idx <= N2 - 1 : NEW_LINE INDENT if S [ idx ] < slimes [ n - 1 ] : NEW_LINE INDENT slimes . append ( S [ idx ] ) NEW_LINE S [ idx ] = INF NEW_LINE idx += 1 NEW_LINE n -= 1 NEW_LINE min_idx += is_continuous NEW_LINE DEDENT else : NEW_LINE INDENT if S [ idx ] < INF : NEW_LINE INDENT is_continuous = False NEW_LINE DEDENT idx += 1 NEW_LINE min_idx += is_continuous NEW_LINE DEDENT DEDENT if n : NEW_LINE INDENT print ( ' No ' ) NEW_LINE quit ( ) NEW_LINE DEDENT num *= 2 NEW_LINE DEDENT print ( ' Yes ' ) NEW_LINE"}
{"id": "codeforces_1607_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor test in range ( t ) :\n    keyboard = input ( )\n    s = input ( )\n    last = 0\n    time = - keyboard.index ( s [ 0 ] )\n    for x in s :\n        i = keyboard.index ( x )\n        time += abs ( i - last )\n        last = i\n    print ( time )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for test in range ( t ) : NEW_LINE INDENT keyboard = input ( ) NEW_LINE s = input ( ) NEW_LINE last = 0 NEW_LINE time = - keyboard . index ( s [ 0 ] ) NEW_LINE for x in s : NEW_LINE INDENT i = keyboard . index ( x ) NEW_LINE time += abs ( i - last ) NEW_LINE last = i NEW_LINE DEDENT print ( time ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4086_A", "sol": 0, "python_code": "def sumOfAP ( a , d , n ) :\n    sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d )\n    return sum\nn = 20\na = 2.5\nd = 1.5\nprint ( sumOfAP ( a , d , n ) )\n", "python_code_tokenized": "def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print ( sumOfAP ( a , d , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_541_A", "sol": 0, "python_code": "def countPairs ( arr , k ) :\n    arr.sort ( )\n    pair = 0\n    index = 0\n    while ( index < len ( arr ) - 1 ) :\n        if arr [ index + 1 ] - arr [ index ] <= k :\n            pair += 1\n            index += 2\n        else :\n            index += 1\n    return pair\nif __name__ == \"__main__\" :\n    arr = [ 1 , 4 , 3 , 7 , 5 ]\n    k = 2\n    count = countPairs ( arr , k )\n    print ( count )\n", "python_code_tokenized": "def countPairs ( arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE pair = 0 NEW_LINE index = 0 NEW_LINE while ( index < len ( arr ) - 1 ) : NEW_LINE INDENT if arr [ index + 1 ] - arr [ index ] <= k : NEW_LINE INDENT pair += 1 NEW_LINE index += 2 NEW_LINE DEDENT else : NEW_LINE INDENT index += 1 NEW_LINE DEDENT DEDENT return pair NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 4 , 3 , 7 , 5 ] NEW_LINE k = 2 NEW_LINE count = countPairs ( arr , k ) NEW_LINE print ( count ) NEW_LINE DEDENT"}
{"id": "aizu_p00003_A", "sol": 0, "python_code": "n = int ( input ( ) )\nfor i in range ( n ) :\n    t = list ( map ( int , input ( ).split ( ) ) )\n    t.sort ( )\n    a , b = t [ 0 ] ** 2 + t [ 1 ] ** 2 , t [ 2 ] ** 2\n    if a == b :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t . sort ( ) NEW_LINE a , b = t [ 0 ] ** 2 + t [ 1 ] ** 2 , t [ 2 ] ** 2 NEW_LINE if a == b : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2400_A", "sol": 0, "python_code": "from math import sqrt\ndef circleradius ( l , b ) :\n    if ( l < 0 or b < 0 ) :\n        return - 1\n    r = ( l * b ) / ( 2 * sqrt ( ( pow ( l , 2 ) + pow ( b , 2 ) ) ) ) ;\n    return r\nif __name__ == '__main__' :\n    l = 5\n    b = 3\n    print ( \"{0:.5}\".format ( circleradius ( l , b ) ) )\n", "python_code_tokenized": "from math import sqrt NEW_LINE def circleradius ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = ( l * b ) / ( 2 * sqrt ( ( pow ( l , 2 ) + pow ( b , 2 ) ) ) ) ; NEW_LINE return r NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 5 NEW_LINE b = 3 NEW_LINE print ( \" { 0 : . 5 } \" . format ( circleradius ( l , b ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2422_A", "sol": 0, "python_code": "def countPermutations ( N , B ) :\n    x = B ** N\n    y = B ** ( N - 1 )\n    print ( x - y )\nif __name__ == \"__main__\" :\n    N , B = 6 , 4\n    countPermutations ( N , B )\n", "python_code_tokenized": "def countPermutations ( N , B ) : NEW_LINE INDENT x = B ** N NEW_LINE y = B ** ( N - 1 ) NEW_LINE print ( x - y ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , B = 6 , 4 NEW_LINE countPermutations ( N , B ) NEW_LINE DEDENT"}
{"id": "atcoder_ARC079_A", "sol": 0, "python_code": "def ri ( ) : return int ( input ( ) )\ndef rli ( ) : return list ( map ( int , input ( ).split ( ) ) )\ndef ris ( ) : return list ( input ( ) )\ndef pli ( a ) : return \"\".join ( list ( map ( str , a ) ) )\nN , M = rli ( )\nkeiro = [ [ False for i in range ( 2 ) ] for j in range ( N + 1 ) ]\nfor i in range ( M ) :\n    a , b = rli ( )\n    if ( b == 1 or b == N ) :\n        keiro [ a ] [ 1 if b == 1 else 0 ] = True\n    elif ( a == 1 or a == N ) :\n        keiro [ b ] [ 1 if a == 1 else 0 ] = True\nflag = False\nfor i in range ( 2 , N ) :\n    if ( keiro [ i ] [ 1 ] and keiro [ i ] [ 0 ] ) :\n        flag = True\nif ( flag ) :\n    print ( \"POSSIBLE\" )\nelse :\n    print ( \"IMPOSSIBLE\" )\n", "python_code_tokenized": "def ri ( ) : return int ( input ( ) ) NEW_LINE def rli ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def ris ( ) : return list ( input ( ) ) NEW_LINE def pli ( a ) : return \" \" . join ( list ( map ( str , a ) ) ) NEW_LINE N , M = rli ( ) NEW_LINE keiro = [ [ False for i in range ( 2 ) ] for j in range ( N + 1 ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT a , b = rli ( ) NEW_LINE if ( b == 1 or b == N ) : NEW_LINE INDENT keiro [ a ] [ 1 if b == 1 else 0 ] = True NEW_LINE DEDENT elif ( a == 1 or a == N ) : NEW_LINE INDENT keiro [ b ] [ 1 if a == 1 else 0 ] = True NEW_LINE DEDENT DEDENT flag = False NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( keiro [ i ] [ 1 ] and keiro [ i ] [ 0 ] ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( \" POSSIBLE \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" IMPOSSIBLE \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_783_A", "sol": 0, "python_code": "def isValid ( n , d ) :\n    digit = n % 10 ;\n    sum = digit ;\n    if ( digit == d ) :\n        return False ;\n    n = int ( n / 10 ) ;\n    while ( n > 0 ) :\n        digit = n % 10 ;\n        if ( digit == d or digit <= sum ) :\n            return False ;\n        else :\n            sum += digit ;\n            n = int ( n / 10 ) ;\n    return True ;\ndef printGoodNumber ( L , R , d ) :\n    for i in range ( L , R + 1 ) :\n        if ( isValid ( i , d ) ) :\n            print ( i , end = \" \" ) ;\nL = 410 ;\nR = 520 ;\nd = 3 ;\nprintGoodNumber ( L , R , d ) ;\n", "python_code_tokenized": "def isValid ( n , d ) : NEW_LINE INDENT digit = n % 10 ; NEW_LINE sum = digit ; NEW_LINE if ( digit == d ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n = int ( n / 10 ) ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 ; NEW_LINE if ( digit == d or digit <= sum ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT sum += digit ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def printGoodNumber ( L , R , d ) : NEW_LINE INDENT for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( isValid ( i , d ) ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT DEDENT L = 410 ; NEW_LINE R = 520 ; NEW_LINE d = 3 ; NEW_LINE printGoodNumber ( L , R , d ) ; NEW_LINE"}
{"id": "geeksforgeeks_373_A", "sol": 0, "python_code": "def printCoins ( arr , n ) :\n    oddSum = 0\n    for i in range ( 0 , n , 2 ) :\n        oddSum += arr [ i ]\n    evenSum = 0\n    for i in range ( 1 , n , 2 ) :\n        evenSum += arr [ i ]\n    if oddSum > evenSum :\n        start = 0\n    else :\n        start = 1\n    for i in range ( start , n , 2 ) :\n        print ( arr [ i ] , end = \" \" )\nif __name__ == \"__main__\" :\n    arr1 = [ 8 , 15 , 3 , 7 ]\n    n = len ( arr1 )\n    printCoins ( arr1 , n )\n    print ( )\n    arr2 = [ 2 , 2 , 2 , 2 ]\n    n = len ( arr2 )\n    printCoins ( arr2 , n )\n    print ( )\n    arr3 = [ 20 , 30 , 2 , 2 , 2 , 10 ]\n    n = len ( arr3 )\n    printCoins ( arr3 , n )\n", "python_code_tokenized": "def printCoins ( arr , n ) : NEW_LINE INDENT oddSum = 0 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT oddSum += arr [ i ] NEW_LINE DEDENT evenSum = 0 NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT evenSum += arr [ i ] NEW_LINE DEDENT if oddSum > evenSum : NEW_LINE INDENT start = 0 NEW_LINE DEDENT else : NEW_LINE INDENT start = 1 NEW_LINE DEDENT for i in range ( start , n , 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 8 , 15 , 3 , 7 ] NEW_LINE n = len ( arr1 ) NEW_LINE printCoins ( arr1 , n ) NEW_LINE print ( ) NEW_LINE arr2 = [ 2 , 2 , 2 , 2 ] NEW_LINE n = len ( arr2 ) NEW_LINE printCoins ( arr2 , n ) NEW_LINE print ( ) NEW_LINE arr3 = [ 20 , 30 , 2 , 2 , 2 , 10 ] NEW_LINE n = len ( arr3 ) NEW_LINE printCoins ( arr3 , n ) NEW_LINE DEDENT"}
{"id": "aizu_p00059_A", "sol": 0, "python_code": "while True :\n    try :\n        xa1 , ya1 , xa2 , ya2 , xb1 , yb1 , xb2 , yb2 = map ( float , input ( ).split ( ) )\n    except EOFError :\n        break\n    if xb2 < xa1 or xb1 > xa2 or yb2 < ya1 or yb1 > ya2 :\n        print ( \"NO\" )\n    else :\n        print ( \"YES\" )\n", "python_code_tokenized": "while True : NEW_LINE INDENT try : NEW_LINE INDENT xa1 , ya1 , xa2 , ya2 , xb1 , yb1 , xb2 , yb2 = map ( float , input ( ) . split ( ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT if xb2 < xa1 or xb1 > xa2 or yb2 < ya1 or yb1 > ya2 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1236_A", "sol": 0, "python_code": "t = int ( input ( ) )\nd = 0\nfor i in range ( 0 , t ) :\n    arr1 = [ int ( x ) for x in input ( ).split ( ) ]\n    a , b , c = arr1 [ 0 ] , arr1 [ 1 ] , arr1 [ 2 ]\n    while b > 0 and c >= 2 :\n        d += 1\n        b -= 1\n        c -= 2\n    while a > 0 and b >= 2 :\n        d += 1\n        a -= 1\n        b -= 2\n    print ( d * 3 )\n    d = 0\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE d = 0 NEW_LINE for i in range ( 0 , t ) : NEW_LINE INDENT arr1 = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE a , b , c = arr1 [ 0 ] , arr1 [ 1 ] , arr1 [ 2 ] NEW_LINE while b > 0 and c >= 2 : NEW_LINE INDENT d += 1 NEW_LINE b -= 1 NEW_LINE c -= 2 NEW_LINE DEDENT while a > 0 and b >= 2 : NEW_LINE INDENT d += 1 NEW_LINE a -= 1 NEW_LINE b -= 2 NEW_LINE DEDENT print ( d * 3 ) NEW_LINE d = 0 NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2937_A", "sol": 0, "python_code": "from math import gcd\ndef minValidNumber ( p , q ) :\n    if ( q % p == 0 ) :\n        return gcd ( p , q )\n    else :\n        return - 1\nif __name__ == \"__main__\" :\n    p , q = 2 , 6 ;\n    print ( minValidNumber ( p , q ) )\n", "python_code_tokenized": "from math import gcd NEW_LINE def minValidNumber ( p , q ) : NEW_LINE INDENT if ( q % p == 0 ) : NEW_LINE INDENT return gcd ( p , q ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p , q = 2 , 6 ; NEW_LINE print ( minValidNumber ( p , q ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1153_B", "sol": 0, "python_code": "import sys\nreadline = sys.stdin.readline\nif __name__ == '__main__' :\n    N , M , H = map ( int , readline ( ).split ( ) )\n    A = list ( map ( int , readline ( ).split ( ) ) )\n    B = list ( map ( int , readline ( ).split ( ) ) )\n    C = [ list ( map ( int , readline ( ).split ( ) ) ) for _ in range ( N ) ]\n    ans = [ [ 0 ] * M for _ in range ( N ) ]\n    for i in range ( N ) :\n        for j in range ( M ) :\n            if C [ i ] [ j ] :\n                ans [ i ] [ j ] = min ( A [ j ] , B [ i ] )\n    for tmp in ans :\n        print ( * tmp )\n", "python_code_tokenized": "import sys NEW_LINE readline = sys . stdin . readline NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , M , H = map ( int , readline ( ) . split ( ) ) NEW_LINE A = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE B = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE C = [ list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE ans = [ [ 0 ] * M for _ in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if C [ i ] [ j ] : NEW_LINE INDENT ans [ i ] [ j ] = min ( A [ j ] , B [ i ] ) NEW_LINE DEDENT DEDENT DEDENT for tmp in ans : NEW_LINE INDENT print ( * tmp ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1245_A", "sol": 0, "python_code": "def countHexadecimal ( L , R ) :\n    count = 0 ;\n    for i in range ( L , R + 1 ) :\n        if ( i >= 10 and i <= 15 ) :\n            count += 1 ;\n        elif ( i > 15 ) :\n            k = i ;\n            while ( k != 0 ) :\n                if ( k % 16 >= 10 ) :\n                    count += 1 ;\n                k = k // 16 ;\n    return count ;\nif __name__ == \"__main__\" :\n    L = 5 ; R = 100 ;\n    print ( countHexadecimal ( L , R ) ) ;\n", "python_code_tokenized": "def countHexadecimal ( L , R ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( i >= 10 and i <= 15 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT elif ( i > 15 ) : NEW_LINE INDENT k = i ; NEW_LINE while ( k != 0 ) : NEW_LINE INDENT if ( k % 16 >= 10 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT k = k // 16 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 5 ; R = 100 ; NEW_LINE print ( countHexadecimal ( L , R ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_187_A", "sol": 0, "python_code": "def countDigit ( n ) :\n    prime = [ False ] * 10\n    prime [ 2 ] = True\n    prime [ 3 ] = True ;\n    prime [ 5 ] = True\n    prime [ 7 ] = True ;\n    temp = n\n    count = 0 ;\n    while ( temp != 0 ) :\n        d = temp % 10 ;\n        temp //= 10 ;\n        if ( d > 0 and n % d == 0 and prime [ d ] ) :\n            count += 1\n    return count\nn = 1032\nprint ( countDigit ( n ) )\n", "python_code_tokenized": "def countDigit ( n ) : NEW_LINE INDENT prime = [ False ] * 10 NEW_LINE prime [ 2 ] = True NEW_LINE prime [ 3 ] = True ; NEW_LINE prime [ 5 ] = True NEW_LINE prime [ 7 ] = True ; NEW_LINE temp = n NEW_LINE count = 0 ; NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 ; NEW_LINE temp //= 10 ; NEW_LINE if ( d > 0 and n % d == 0 and prime [ d ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 1032 NEW_LINE print ( countDigit ( n ) ) NEW_LINE"}
{"id": "codeforces_991_A", "sol": 0, "python_code": "import sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\na , b , c , n = map ( int , input ( ).split ( ) )\nif min ( a , b ) < c :\n    ans = - 1\nelse :\n    x = n - ( a + b - c )\n    ans = x if x > 0 else - 1\nprint ( ans )\n", "python_code_tokenized": "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE a , b , c , n = map ( int , input ( ) . split ( ) ) NEW_LINE if min ( a , b ) < c : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = n - ( a + b - c ) NEW_LINE ans = x if x > 0 else - 1 NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_1088_A", "sol": 0, "python_code": "def ReplaceElements ( arr , n ) :\n    max_ele = arr [ 0 ]\n    arr [ 0 ] = - 1\n    for i in range ( 1 , n ) :\n        if ( max_ele > arr [ i ] ) :\n            arr [ i ] = max_ele\n        elif ( max_ele <= arr [ i ] ) :\n            temp = arr [ i ]\n            arr [ i ] = max_ele\n            max_ele = temp\nif __name__ == \"__main__\" :\n    arr = [ 4 , 5 , 2 , 1 , 7 , 6 ]\n    n = len ( arr )\n    ReplaceElements ( arr , n )\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" )\n", "python_code_tokenized": "def ReplaceElements ( arr , n ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE arr [ 0 ] = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( max_ele > arr [ i ] ) : NEW_LINE INDENT arr [ i ] = max_ele NEW_LINE DEDENT elif ( max_ele <= arr [ i ] ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = max_ele NEW_LINE max_ele = temp NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 5 , 2 , 1 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2212_A", "sol": 0, "python_code": "import math\nMAX = 10000 ;\nprimes = [ ] ;\ndef sieveSundaram ( ) :\n    marked = [ False ] * int ( MAX / 2 + 1 ) ;\n    for i in range ( 1 , int ( ( math.sqrt ( MAX ) - 1 ) / 2 ) + 1 ) :\n        for j in range ( ( i * ( i + 1 ) ) << 1 , int ( MAX / 2 ) + 1 , 2 * i + 1 ) :\n            marked [ j ] = True ;\n    primes.append ( 2 ) ;\n    for i in range ( 1 , int ( MAX / 2 ) + 1 ) :\n        if ( marked [ i ] == False ) :\n            primes.append ( 2 * i + 1 ) ;\ndef isEquidigital ( n ) :\n    if ( n == 1 ) :\n        return True ;\n    original_no = n ;\n    sumDigits = 0 ;\n    while ( original_no > 0 ) :\n        sumDigits += 1 ;\n        original_no = int ( original_no / 10 ) ;\n    pDigit = 0 ;\n    count_exp = 0 ;\n    p = 0 ;\n    i = 0 ;\n    while ( primes [ i ] <= int ( n / 2 ) ) :\n        while ( n % primes [ i ] == 0 ) :\n            p = primes [ i ] ;\n            n = int ( n / p ) ;\n            count_exp += 1 ;\n        while ( p > 0 ) :\n            pDigit += 1 ;\n            p = int ( p / 10 ) ;\n        while ( count_exp > 1 ) :\n            pDigit += 1 ;\n            count_exp = int ( count_exp / 10 ) ;\n        i += 1 ;\n    if ( n != 1 ) :\n        while ( n > 0 ) :\n            pDigit += 1 ;\n            n = int ( n / 10 ) ;\n    return ( pDigit == sumDigits ) ;\nsieveSundaram ( ) ;\nprint ( \"Printing first few Equidigital\" , \"Numbers using isEquidigital()\" ) ;\nfor i in range ( 1 , 20 ) :\n    if ( isEquidigital ( i ) ) :\n        print ( i , end = \" \" ) ;\n", "python_code_tokenized": "import math NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieveSundaram ( ) : NEW_LINE INDENT marked = [ False ] * int ( MAX / 2 + 1 ) ; NEW_LINE for i in range ( 1 , int ( ( math . sqrt ( MAX ) - 1 ) / 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , int ( MAX / 2 ) + 1 , 2 * i + 1 ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , int ( MAX / 2 ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def isEquidigital ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT original_no = n ; NEW_LINE sumDigits = 0 ; NEW_LINE while ( original_no > 0 ) : NEW_LINE INDENT sumDigits += 1 ; NEW_LINE original_no = int ( original_no / 10 ) ; NEW_LINE DEDENT pDigit = 0 ; NEW_LINE count_exp = 0 ; NEW_LINE p = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( primes [ i ] <= int ( n / 2 ) ) : NEW_LINE INDENT while ( n % primes [ i ] == 0 ) : NEW_LINE INDENT p = primes [ i ] ; NEW_LINE n = int ( n / p ) ; NEW_LINE count_exp += 1 ; NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT pDigit += 1 ; NEW_LINE p = int ( p / 10 ) ; NEW_LINE DEDENT while ( count_exp > 1 ) : NEW_LINE INDENT pDigit += 1 ; NEW_LINE count_exp = int ( count_exp / 10 ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( n != 1 ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT pDigit += 1 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT DEDENT return ( pDigit == sumDigits ) ; NEW_LINE DEDENT sieveSundaram ( ) ; NEW_LINE print ( \" Printing \u2581 first \u2581 few \u2581 Equidigital \" , \" Numbers \u2581 using \u2581 isEquidigital ( ) \" ) ; NEW_LINE for i in range ( 1 , 20 ) : NEW_LINE INDENT if ( isEquidigital ( i ) ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2258_A", "sol": 0, "python_code": "dp = [ [ - 1 for i in range ( 8101 ) ] for i in range ( 901 ) ]\ndef minimumNumberOfDigits ( a , b ) :\n    if ( a > b or a < 0 or b < 0 or a > 900 or b > 8100 ) :\n        return - 1\n    if ( a == 0 and b == 0 ) :\n        return 0\n    if ( dp [ a ] [ b ] != - 1 ) :\n        return dp [ a ] [ b ]\n    ans = 101\n    for i in range ( 9 , 0 , - 1 ) :\n        k = minimumNumberOfDigits ( a - i , b - ( i * i ) )\n        if ( k != - 1 ) :\n            ans = min ( ans , k + 1 )\n    dp [ a ] [ b ] = ans\n    return ans\ndef printSmallestNumber ( a , b ) :\n    for i in range ( 901 ) :\n        for j in range ( 8101 ) :\n            dp [ i ] [ j ] = - 1\n    dp [ 0 ] [ 0 ] = 0\n    k = minimumNumberOfDigits ( a , b )\n    if ( k == - 1 or k > 100 ) :\n        print ( - 1 , end = '' )\n    else :\n        while ( a > 0 and b > 0 ) :\n            for i in range ( 1 , 10 ) :\n                if ( a >= i and b >= i * i and 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] ) :\n                    print ( i , end = '' )\n                    a -= i\n                    b -= i * i\n                    break\nif __name__ == '__main__' :\n    a = 18\n    b = 162\n    printSmallestNumber ( a , b )\n", "python_code_tokenized": "dp = [ [ - 1 for i in range ( 8101 ) ] for i in range ( 901 ) ] NEW_LINE def minimumNumberOfDigits ( a , b ) : NEW_LINE INDENT if ( a > b or a < 0 or b < 0 or a > 900 or b > 8100 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ a ] [ b ] != - 1 ) : NEW_LINE INDENT return dp [ a ] [ b ] NEW_LINE DEDENT ans = 101 NEW_LINE for i in range ( 9 , 0 , - 1 ) : NEW_LINE INDENT k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) NEW_LINE if ( k != - 1 ) : NEW_LINE INDENT ans = min ( ans , k + 1 ) NEW_LINE DEDENT DEDENT dp [ a ] [ b ] = ans NEW_LINE return ans NEW_LINE DEDENT def printSmallestNumber ( a , b ) : NEW_LINE INDENT for i in range ( 901 ) : NEW_LINE INDENT for j in range ( 8101 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE k = minimumNumberOfDigits ( a , b ) NEW_LINE if ( k == - 1 or k > 100 ) : NEW_LINE INDENT print ( - 1 , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( a > 0 and b > 0 ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( a >= i and b >= i * i and 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] ) : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE a -= i NEW_LINE b -= i * i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 18 NEW_LINE b = 162 NEW_LINE printSmallestNumber ( a , b ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4384_A", "sol": 0, "python_code": "def findSum ( arr , n , left , right ) :\n    k = right - left ;\n    d = arr [ 1 ] - arr [ 0 ] ;\n    ans = arr [ left - 1 ] * ( k + 1 ) ;\n    ans = ans + ( d * ( k * ( k + 1 ) ) ) // 2 ;\n    return ans ;\nif __name__ == '__main__' :\n    arr = [ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 ] ;\n    queries = 3 ;\n    q = [ [ 2 , 4 ] , [ 2 , 6 ] , [ 5 , 6 ] ] ;\n    n = len ( arr ) ;\n    for i in range ( queries ) :\n        print ( findSum ( arr , n , q [ i ] [ 0 ] , q [ i ] [ 1 ] ) ) ;\n", "python_code_tokenized": "def findSum ( arr , n , left , right ) : NEW_LINE INDENT k = right - left ; NEW_LINE d = arr [ 1 ] - arr [ 0 ] ; NEW_LINE ans = arr [ left - 1 ] * ( k + 1 ) ; NEW_LINE ans = ans + ( d * ( k * ( k + 1 ) ) ) // 2 ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 ] ; NEW_LINE queries = 3 ; NEW_LINE q = [ [ 2 , 4 ] , [ 2 , 6 ] , [ 5 , 6 ] ] ; NEW_LINE n = len ( arr ) ; NEW_LINE for i in range ( queries ) : NEW_LINE INDENT print ( findSum ( arr , n , q [ i ] [ 0 ] , q [ i ] [ 1 ] ) ) ; NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2601_A", "sol": 0, "python_code": "def nCr ( n , r ) :\n    ans = 1 ;\n    for i in range ( 1 , r + 1 ) :\n        ans *= ( n - r + i ) ;\n        ans //= i ;\n    return ans ;\ndef total_ways ( N , X ) :\n    return ( nCr ( N - 1 , X - 1 ) + nCr ( N - 1 , X ) ) ;\nif __name__ == \"__main__\" :\n    N = 5 ; X = 3 ;\n    print ( total_ways ( N , X ) ) ;\n", "python_code_tokenized": "def nCr ( n , r ) : NEW_LINE INDENT ans = 1 ; NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans *= ( n - r + i ) ; NEW_LINE ans //= i ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def total_ways ( N , X ) : NEW_LINE INDENT return ( nCr ( N - 1 , X - 1 ) + nCr ( N - 1 , X ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 ; X = 3 ; NEW_LINE print ( total_ways ( N , X ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1780_A", "sol": 0, "python_code": "from __future__ import division\ndef sumOfSeries ( a , num ) :\n    res = 0\n    prev = 1\n    for i in range ( 1 , n + 1 ) :\n        prev *= ( a / i )\n        res = res + prev\n    return res\nn = 5\na = 2\nprint ( round ( sumOfSeries ( a , n ) , 4 ) )\n", "python_code_tokenized": "from __future__ import division NEW_LINE def sumOfSeries ( a , num ) : NEW_LINE INDENT res = 0 NEW_LINE prev = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prev *= ( a / i ) NEW_LINE res = res + prev NEW_LINE DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE a = 2 NEW_LINE print ( round ( sumOfSeries ( a , n ) , 4 ) ) NEW_LINE"}
{"id": "geeksforgeeks_3018_A", "sol": 0, "python_code": "def factorial ( n ) :\n    if n == 1 or n == 0 :\n        return 1\n    else :\n        return factorial ( n - 1 ) * n\ndef gcdOfFactorial ( arr , n ) :\n    minm = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        if minm > arr [ i ] :\n            minm = arr [ i ]\n        else :\n            arr [ i ] = minm\n    return factorial ( minm )\narr = [ 9 , 12 , 122 , 34 , 15 ]\nn = len ( arr )\nprint ( gcdOfFactorial ( arr , n ) )\n", "python_code_tokenized": "def factorial ( n ) : NEW_LINE INDENT if n == 1 or n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return factorial ( n - 1 ) * n NEW_LINE DEDENT DEDENT def gcdOfFactorial ( arr , n ) : NEW_LINE INDENT minm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if minm > arr [ i ] : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = minm NEW_LINE DEDENT DEDENT return factorial ( minm ) NEW_LINE DEDENT arr = [ 9 , 12 , 122 , 34 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( gcdOfFactorial ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_286_A", "sol": 0, "python_code": "def solve ( arr , n ) :\n    b = [ 0 for i in range ( n ) ]\n    p = 0\n    i = n - 1\n    while i >= 0 :\n        b [ p ] = arr [ i ]\n        i -= 1\n        if ( i >= 0 ) :\n            b [ n - 1 - p ] = arr [ i ]\n        p += 1\n        i -= 1\n    return b\narr = [ 1 , 2 , 3 , 4 ]\nn = len ( arr )\nb = solve ( arr , n )\nprint ( b )\n", "python_code_tokenized": "def solve ( arr , n ) : NEW_LINE INDENT b = [ 0 for i in range ( n ) ] NEW_LINE p = 0 NEW_LINE i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT b [ p ] = arr [ i ] NEW_LINE i -= 1 NEW_LINE if ( i >= 0 ) : NEW_LINE INDENT b [ n - 1 - p ] = arr [ i ] NEW_LINE DEDENT p += 1 NEW_LINE i -= 1 NEW_LINE DEDENT return b NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE b = solve ( arr , n ) NEW_LINE print ( b ) NEW_LINE"}
{"id": "atcoder_AGC025_B", "sol": 0, "python_code": "N , A , B , K = map ( int , input ( ).split ( ) )\nif A < B : A , B = B , A\nMOD = 998244353\ndef mul ( a , b ) :\n    return ( a * b ) % MOD\ndef pow ( a , n ) :\n    ret = 1\n    mag = a\n    while n > 0 :\n        if n & 1 :\n            ret = mul ( ret , mag )\n        mag = mul ( mag , mag )\n        n >>= 1\n    return ret\ndef inv ( a ) :\n    return pow ( a , MOD - 2 )\nfac = [ 1 ]\nfac_inv = [ 1 ]\nfor n in range ( 1 , N + 10 ) :\n    f = mul ( fac [ n - 1 ] , n )\n    fac.append ( f )\n    fac_inv.append ( inv ( f ) )\nmem = [ 0 ] * ( N + 1 )\ndef ncr ( n , r ) :\n    if mem [ r ] > 0 :\n        return mem [ r ]\n    else :\n        ret = mul ( mul ( fac [ n ] , fac_inv [ n - r ] ) , fac_inv [ r ] )\n        mem [ r ] = ret\n        return ret\nans = 0\nfor a in range ( N + 1 ) :\n    if a * A > K : break\n    rem = K - a * A\n    if rem % B : continue\n    b = rem // B\n    if b > N : continue\n    ans += mul ( ncr ( N , a ) , ncr ( N , b ) )\nprint ( ans % MOD )\n", "python_code_tokenized": "N , A , B , K = map ( int , input ( ) . split ( ) ) NEW_LINE if A < B : A , B = B , A NEW_LINE MOD = 998244353 NEW_LINE def mul ( a , b ) : NEW_LINE INDENT return ( a * b ) % MOD NEW_LINE DEDENT def pow ( a , n ) : NEW_LINE INDENT ret = 1 NEW_LINE mag = a NEW_LINE while n > 0 : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT ret = mul ( ret , mag ) NEW_LINE DEDENT mag = mul ( mag , mag ) NEW_LINE n >>= 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT def inv ( a ) : NEW_LINE INDENT return pow ( a , MOD - 2 ) NEW_LINE DEDENT fac = [ 1 ] NEW_LINE fac_inv = [ 1 ] NEW_LINE for n in range ( 1 , N + 10 ) : NEW_LINE INDENT f = mul ( fac [ n - 1 ] , n ) NEW_LINE fac . append ( f ) NEW_LINE fac_inv . append ( inv ( f ) ) NEW_LINE DEDENT mem = [ 0 ] * ( N + 1 ) NEW_LINE def ncr ( n , r ) : NEW_LINE INDENT if mem [ r ] > 0 : NEW_LINE INDENT return mem [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT ret = mul ( mul ( fac [ n ] , fac_inv [ n - r ] ) , fac_inv [ r ] ) NEW_LINE mem [ r ] = ret NEW_LINE return ret NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for a in range ( N + 1 ) : NEW_LINE INDENT if a * A > K : break NEW_LINE rem = K - a * A NEW_LINE if rem % B : continue NEW_LINE b = rem // B NEW_LINE if b > N : continue NEW_LINE ans += mul ( ncr ( N , a ) , ncr ( N , b ) ) NEW_LINE DEDENT print ( ans % MOD ) NEW_LINE"}
{"id": "geeksforgeeks_1750_A", "sol": 0, "python_code": "def SieveOfAtkin ( limit ) :\n    if ( limit > 2 ) :\n        print ( 2 , end = \" \" )\n    if ( limit > 3 ) :\n        print ( 3 , end = \" \" )\n    sieve = [ False ] * limit\n    for i in range ( 0 , limit ) :\n        sieve [ i ] = False\n    x = 1\n    while ( x * x < limit ) :\n        y = 1\n        while ( y * y < limit ) :\n            n = ( 4 * x * x ) + ( y * y )\n            if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) :\n                sieve [ n ] ^= True\n            n = ( 3 * x * x ) + ( y * y )\n            if ( n <= limit and n % 12 == 7 ) :\n                sieve [ n ] ^= True\n            n = ( 3 * x * x ) - ( y * y )\n            if ( x > y and n <= limit and n % 12 == 11 ) :\n                sieve [ n ] ^= True\n            y += 1\n        x += 1\n    r = 5\n    while ( r * r < limit ) :\n        if ( sieve [ r ] ) :\n            for i in range ( r * r , limit , r * r ) :\n                sieve [ i ] = False\n    for a in range ( 5 , limit ) :\n        if ( sieve [ a ] ) :\n            print ( a , end = \" \" )\nlimit = 20\nSieveOfAtkin ( limit )\n", "python_code_tokenized": "def SieveOfAtkin ( limit ) : NEW_LINE INDENT if ( limit > 2 ) : NEW_LINE INDENT print ( 2 , end = \" \u2581 \" ) NEW_LINE DEDENT if ( limit > 3 ) : NEW_LINE INDENT print ( 3 , end = \" \u2581 \" ) NEW_LINE DEDENT sieve = [ False ] * limit NEW_LINE for i in range ( 0 , limit ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT x = 1 NEW_LINE while ( x * x < limit ) : NEW_LINE INDENT y = 1 NEW_LINE while ( y * y < limit ) : NEW_LINE INDENT n = ( 4 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and n % 12 == 7 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) - ( y * y ) NEW_LINE if ( x > y and n <= limit and n % 12 == 11 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT r = 5 NEW_LINE while ( r * r < limit ) : NEW_LINE INDENT if ( sieve [ r ] ) : NEW_LINE INDENT for i in range ( r * r , limit , r * r ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for a in range ( 5 , limit ) : NEW_LINE INDENT if ( sieve [ a ] ) : NEW_LINE INDENT print ( a , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT limit = 20 NEW_LINE SieveOfAtkin ( limit ) NEW_LINE"}
{"id": "geeksforgeeks_1731_A", "sol": 0, "python_code": "def findNthDigit ( p , q , N ) :\n    while ( N > 0 ) :\n        N -= 1 ;\n        p *= 10 ;\n        res = p // q ;\n        p %= q ;\n    return res ;\nif __name__ == \"__main__\" :\n    p = 1 ; q = 2 ; N = 1 ;\n    print ( findNthDigit ( p , q , N ) ) ;\n", "python_code_tokenized": "def findNthDigit ( p , q , N ) : NEW_LINE INDENT while ( N > 0 ) : NEW_LINE INDENT N -= 1 ; NEW_LINE p *= 10 ; NEW_LINE res = p // q ; NEW_LINE p %= q ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p = 1 ; q = 2 ; N = 1 ; NEW_LINE print ( findNthDigit ( p , q , N ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3129_A", "sol": 0, "python_code": "def check ( num ) :\n    digitSum = 0\n    while ( num != 0 ) :\n        digitSum = digitSum + num % 10\n        num = num // 10\n    temp = ( int ) ( digitSum )\n    reverseDigitSum = 0\n    while ( temp != 0 ) :\n        rem = temp % 10\n        reverseDigitSum = reverseDigitSum * 10 + rem\n        temp = temp / 10\n    number = digitSum * reverseDigitSum\n    return number\nnum = 1729\nx = ( check ( num ) )\nif ( num == x ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def check ( num ) : NEW_LINE INDENT digitSum = 0 NEW_LINE while ( num != 0 ) : NEW_LINE INDENT digitSum = digitSum + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT temp = ( int ) ( digitSum ) NEW_LINE reverseDigitSum = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE reverseDigitSum = reverseDigitSum * 10 + rem NEW_LINE temp = temp / 10 NEW_LINE DEDENT number = digitSum * reverseDigitSum NEW_LINE return number NEW_LINE DEDENT num = 1729 NEW_LINE x = ( check ( num ) ) NEW_LINE if ( num == x ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_288_A", "sol": 0, "python_code": "def getMin ( arr , n ) :\n    minVal = min ( arr ) ;\n    return minVal ;\nif __name__ == \"__main__\" :\n    arr = [ 5 , 3 , 1 , 6 , 9 ] ;\n    n = len ( arr ) ;\n    print ( getMin ( arr , n ) ) ;\n", "python_code_tokenized": "def getMin ( arr , n ) : NEW_LINE INDENT minVal = min ( arr ) ; NEW_LINE return minVal ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 3 , 1 , 6 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getMin ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2037_A", "sol": 0, "python_code": "from math import *\ndef cal ( n ) :\n    res = pow ( ceil ( ( pow ( pow ( 10 , ( n - 1 ) ) , 1 / 4 ) ) ) , 4 )\n    return int ( res )\nn = 1\nprint ( cal ( n ) )\n", "python_code_tokenized": "from math import * NEW_LINE def cal ( n ) : NEW_LINE INDENT res = pow ( ceil ( ( pow ( pow ( 10 , ( n - 1 ) ) , 1 / 4 ) ) ) , 4 ) NEW_LINE return int ( res ) NEW_LINE DEDENT n = 1 NEW_LINE print ( cal ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_5105_A", "sol": 0, "python_code": "import math\ndef getMaximumSumWithLCMN ( N ) :\n    sum = 0\n    LIM = int ( math.sqrt ( N ) )\n    for i in range ( 1 , LIM + 1 ) :\n        if ( N % i == 0 ) :\n            if ( i == ( N // i ) ) :\n                sum = sum + i\n            else :\n                sum = sum + ( i + N // i )\n    return sum\nN = 12\nprint ( getMaximumSumWithLCMN ( N ) )\n", "python_code_tokenized": "import math NEW_LINE def getMaximumSumWithLCMN ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE LIM = int ( math . sqrt ( N ) ) NEW_LINE for i in range ( 1 , LIM + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i == ( N // i ) ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + ( i + N // i ) NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT N = 12 NEW_LINE print ( getMaximumSumWithLCMN ( N ) ) NEW_LINE"}
{"id": "codeforces_758_A", "sol": 0, "python_code": "a = int ( input ( ) )\nb = list ( map ( int , input ( ).split ( ) ) )\nc = b [ 0 ]\nfor j in b :\n    if j > c :\n        c = j\nm = 0\nfor k in b :\n    m += ( c - k )\nprint ( m )\n", "python_code_tokenized": "a = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = b [ 0 ] NEW_LINE for j in b : NEW_LINE INDENT if j > c : NEW_LINE INDENT c = j NEW_LINE DEDENT DEDENT m = 0 NEW_LINE for k in b : NEW_LINE INDENT m += ( c - k ) NEW_LINE DEDENT print ( m ) NEW_LINE"}
{"id": "geeksforgeeks_1082_A", "sol": 0, "python_code": "import math\ndef findLCM ( arr , n ) :\n    lcm = arr [ 0 ] ;\n    for i in range ( 1 , n - 1 ) :\n        lcm = ( lcm * arr [ i ] ) / math.gcd ( arr [ i ] , lcm ) ;\n    return lcm ;\ndef countNumbers ( arr , n , l , r ) :\n    lcm = int ( findLCM ( arr , n ) ) ;\n    count = ( r / lcm ) - ( ( l - 1 ) / lcm ) ;\n    print ( int ( count ) ) ;\narr = [ 1 , 4 , 2 ] ;\nn = len ( arr ) ;\nl = 1 ;\nr = 10 ;\ncountNumbers ( arr , n , l , r ) ;\n", "python_code_tokenized": "import math NEW_LINE def findLCM ( arr , n ) : NEW_LINE INDENT lcm = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) / math . gcd ( arr [ i ] , lcm ) ; NEW_LINE DEDENT return lcm ; NEW_LINE DEDENT def countNumbers ( arr , n , l , r ) : NEW_LINE INDENT lcm = int ( findLCM ( arr , n ) ) ; NEW_LINE count = ( r / lcm ) - ( ( l - 1 ) / lcm ) ; NEW_LINE print ( int ( count ) ) ; NEW_LINE DEDENT arr = [ 1 , 4 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE l = 1 ; NEW_LINE r = 10 ; NEW_LINE countNumbers ( arr , n , l , r ) ; NEW_LINE"}
{"id": "geeksforgeeks_1037_A", "sol": 0, "python_code": "def findFactors ( a , b ) :\n    c = a + b - 1\n    print ( c )\nif __name__ == '__main__' :\n    a = 13\n    b = 36\n    findFactors ( a , b )\n", "python_code_tokenized": "def findFactors ( a , b ) : NEW_LINE INDENT c = a + b - 1 NEW_LINE print ( c ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 13 NEW_LINE b = 36 NEW_LINE findFactors ( a , b ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_86_A", "sol": 0, "python_code": "def longest_subseq ( n , k , s ) :\n    dp = [ 0 ] * n\n    max_length = [ 0 ] * 26\n    for i in range ( n ) :\n        curr = ord ( s [ i ] ) - ord ( 'a' )\n        lower = max ( 0 , curr - k )\n        upper = min ( 25 , curr + k )\n        for j in range ( lower , upper + 1 ) :\n            dp [ i ] = max ( dp [ i ] , max_length [ j ] + 1 )\n        max_length [ curr ] = max ( dp [ i ] , max_length [ curr ] )\n    return max ( dp )\ndef main ( ) :\n    s = \"geeksforgeeks\"\n    n = len ( s )\n    k = 3\n    print ( longest_subseq ( n , k , s ) )\nmain ( )\n", "python_code_tokenized": "def longest_subseq ( n , k , s ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE max_length = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE lower = max ( 0 , curr - k ) NEW_LINE upper = min ( 25 , curr + k ) NEW_LINE for j in range ( lower , upper + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , max_length [ j ] + 1 ) NEW_LINE DEDENT max_length [ curr ] = max ( dp [ i ] , max_length [ curr ] ) NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE n = len ( s ) NEW_LINE k = 3 NEW_LINE print ( longest_subseq ( n , k , s ) ) NEW_LINE DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_73_A", "sol": 0, "python_code": "from math import *\ndef isPower ( a ) :\n    if a == 1 :\n        return True\n    for i in range ( 2 , int ( sqrt ( a ) ) + 1 ) :\n        val = log ( a ) / log ( i )\n        if ( round ( ( val - int ( val ) ) , 8 ) < 0.00000001 ) :\n            return True\n    return False\nif __name__ == \"__main__\" :\n    n = 16\n    if isPower ( n ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "from math import * NEW_LINE def isPower ( a ) : NEW_LINE INDENT if a == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( a ) ) + 1 ) : NEW_LINE INDENT val = log ( a ) / log ( i ) NEW_LINE if ( round ( ( val - int ( val ) ) , 8 ) < 0.00000001 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 16 NEW_LINE if isPower ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00761_A", "sol": 0, "python_code": "while True :\n    a0 , L = map ( int , input ( ).split ( ) )\n    if a0 == 0 and L == 0 :\n        break\n    s = ( \"{:0\" + str ( L ) + \"d}\" ).format ( a0 )\n    hist = [ a0 ]\n    for i in range ( 1 , 21 ) :\n        large = \"\".join ( sorted ( s , reverse = True ) )\n        small = \"\".join ( sorted ( s ) )\n        ai = int ( large ) - int ( small )\n        if ai in hist :\n            j = hist.index ( ai )\n            print ( j , int ( ai ) , i - j )\n            break\n        else :\n            hist.append ( ai )\n            s = ( \"{:0\" + str ( L ) + \"d}\" ).format ( ai )\n    else :\n        raise AttributeError\n", "python_code_tokenized": "while True : NEW_LINE INDENT a0 , L = map ( int , input ( ) . split ( ) ) NEW_LINE if a0 == 0 and L == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = ( \" { :0\" + str ( L ) + \" d } \" ) . format ( a0 ) NEW_LINE hist = [ a0 ] NEW_LINE for i in range ( 1 , 21 ) : NEW_LINE INDENT large = \" \" . join ( sorted ( s , reverse = True ) ) NEW_LINE small = \" \" . join ( sorted ( s ) ) NEW_LINE ai = int ( large ) - int ( small ) NEW_LINE if ai in hist : NEW_LINE INDENT j = hist . index ( ai ) NEW_LINE print ( j , int ( ai ) , i - j ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT hist . append ( ai ) NEW_LINE s = ( \" { :0\" + str ( L ) + \" d } \" ) . format ( ai ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT raise AttributeError NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3601_A", "sol": 0, "python_code": "def countPieces ( N ) :\n    return 2 * N\nN = 100\nprint ( countPieces ( N ) )\n", "python_code_tokenized": "def countPieces ( N ) : NEW_LINE INDENT return 2 * N NEW_LINE DEDENT N = 100 NEW_LINE print ( countPieces ( N ) ) NEW_LINE"}
{"id": "geeksforgeeks_987_A", "sol": 0, "python_code": "def longestAr ( n , arr ) :\n    count = dict ( )\n    for i in arr :\n        count [ i ] = count.get ( i , 0 ) + 1\n    kset = count.keys ( )\n    maxm = 0\n    for it in list ( kset ) :\n        a = it\n        cur = 0\n        cur1 = 0\n        cur2 = 0\n        if ( ( a + 1 ) in count ) :\n            cur1 = count [ a + 1 ]\n        if ( ( a - 1 ) in count ) :\n            cur2 = count [ a - 1 ]\n        cur = count [ a ] + max ( cur1 , cur2 )\n        if ( cur > maxm ) :\n            maxm = cur\n    return maxm\nif __name__ == '__main__' :\n    n = 8\n    arr = [ 2 , 2 , 3 , 5 , 5 , 6 , 6 , 6 ]\n    maxLen = longestAr ( n , arr )\n    print ( maxLen )\n", "python_code_tokenized": "def longestAr ( n , arr ) : NEW_LINE INDENT count = dict ( ) NEW_LINE for i in arr : NEW_LINE INDENT count [ i ] = count . get ( i , 0 ) + 1 NEW_LINE DEDENT kset = count . keys ( ) NEW_LINE maxm = 0 NEW_LINE for it in list ( kset ) : NEW_LINE INDENT a = it NEW_LINE cur = 0 NEW_LINE cur1 = 0 NEW_LINE cur2 = 0 NEW_LINE if ( ( a + 1 ) in count ) : NEW_LINE INDENT cur1 = count [ a + 1 ] NEW_LINE DEDENT if ( ( a - 1 ) in count ) : NEW_LINE INDENT cur2 = count [ a - 1 ] NEW_LINE DEDENT cur = count [ a ] + max ( cur1 , cur2 ) NEW_LINE if ( cur > maxm ) : NEW_LINE INDENT maxm = cur NEW_LINE DEDENT DEDENT return maxm NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE arr = [ 2 , 2 , 3 , 5 , 5 , 6 , 6 , 6 ] NEW_LINE maxLen = longestAr ( n , arr ) NEW_LINE print ( maxLen ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_699_A", "sol": 0, "python_code": "def minMoves ( arr , n ) :\n    expectedItem = n\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        if ( arr [ i ] == expectedItem ) :\n            expectedItem -= 1\n    return expectedItem\narr = [ 4 , 3 , 2 , 1 ]\nn = len ( arr )\nprint ( minMoves ( arr , n ) )\n", "python_code_tokenized": "def minMoves ( arr , n ) : NEW_LINE INDENT expectedItem = n NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == expectedItem ) : NEW_LINE INDENT expectedItem -= 1 NEW_LINE DEDENT DEDENT return expectedItem NEW_LINE DEDENT arr = [ 4 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minMoves ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2975_A", "sol": 0, "python_code": "def colourVisible ( height , colour , K ) :\n    arr = [ 0 for i in range ( K + 1 ) ]\n    visible = 0\n    max = height [ K - 1 ]\n    arr [ colour [ K - 1 ] ] = 1\n    i = K - 2\n    while ( i >= 0 ) :\n        if ( height [ i ] > max ) :\n            max = height [ i ]\n            arr [ colour [ i ] ] = 1\n        i -= 1\n    for i in range ( 1 , K + 1 , 1 ) :\n        if ( arr [ i ] == 1 ) :\n            visible += 1\n    return visible\nif __name__ == '__main__' :\n    height = [ 3 , 5 , 1 , 2 , 3 ]\n    colour = [ 1 , 2 , 3 , 4 , 3 ]\n    K = len ( colour )\n    print ( colourVisible ( height , colour , K ) )\n", "python_code_tokenized": "def colourVisible ( height , colour , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( K + 1 ) ] NEW_LINE visible = 0 NEW_LINE max = height [ K - 1 ] NEW_LINE arr [ colour [ K - 1 ] ] = 1 NEW_LINE i = K - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( height [ i ] > max ) : NEW_LINE INDENT max = height [ i ] NEW_LINE arr [ colour [ i ] ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( 1 , K + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT visible += 1 NEW_LINE DEDENT DEDENT return visible NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT height = [ 3 , 5 , 1 , 2 , 3 ] NEW_LINE colour = [ 1 , 2 , 3 , 4 , 3 ] NEW_LINE K = len ( colour ) NEW_LINE print ( colourVisible ( height , colour , K ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1075_B", "sol": 0, "python_code": "import bisect\nimport sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\nn , m = map ( int , input ( ).split ( ) )\nx = list ( map ( int , input ( ).split ( ) ) )\nt = list ( map ( int , input ( ).split ( ) ) )\nu , v = [ ] , [ ]\nfor i , j in zip ( x , t ) :\n    if j :\n        u.append ( i )\n    else :\n        v.append ( i )\nans = [ 0 ] * m\nfor i in v :\n    j = bisect.bisect_left ( u , i )\n    if not j :\n        ans [ 0 ] += 1\n    elif not j ^ m :\n        ans [ - 1 ] += 1\n    else :\n        k = j - 1\n        if i - u [ k ] <= u [ j ] - i :\n            ans [ k ] += 1\n        else :\n            ans [ j ] += 1\nsys.stdout.write ( \" \".join ( map ( str , ans ) ) )\n", "python_code_tokenized": "import bisect NEW_LINE import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE u , v = [ ] , [ ] NEW_LINE for i , j in zip ( x , t ) : NEW_LINE INDENT if j : NEW_LINE INDENT u . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT ans = [ 0 ] * m NEW_LINE for i in v : NEW_LINE INDENT j = bisect . bisect_left ( u , i ) NEW_LINE if not j : NEW_LINE INDENT ans [ 0 ] += 1 NEW_LINE DEDENT elif not j ^ m : NEW_LINE INDENT ans [ - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = j - 1 NEW_LINE if i - u [ k ] <= u [ j ] - i : NEW_LINE INDENT ans [ k ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT sys . stdout . write ( \" \u2581 \" . join ( map ( str , ans ) ) ) NEW_LINE"}
{"id": "atcoder_ABC171_F", "sol": 0, "python_code": "import math\nfrom collections import deque\nfrom collections import Counter\nMod = 10 ** 9 + 7\nM = 10 ** 6 * 2\nfac = [ 0 ] * M\nfinv = [ 0 ] * M\ninv = [ 0 ] * M\ndef COMinit ( ) :\n    fac [ 0 ] = fac [ 1 ] = 1\n    finv [ 0 ] = finv [ 1 ] = 1\n    inv [ 1 ] = 1\n    for i in range ( 2 , M ) :\n        fac [ i ] = ( fac [ i - 1 ] * i % Mod ) % Mod\n        inv [ i ] = Mod - inv [ Mod % i ] * ( Mod // i ) % Mod\n        finv [ i ] = ( finv [ i - 1 ] * inv [ i ] % Mod ) % Mod\ndef COM ( n , k ) :\n    if n < k :\n        return 0\n    if n < 0 or k < 0 :\n        return 0\n    return ( fac [ n ] * ( finv [ k ] * finv [ n - k ] % Mod ) % Mod ) % Mod\nCOMinit ( )\nk = int ( input ( ) )\ns = input ( )\nn = len ( s )\nans = 0\nfor i in range ( k + 1 ) :\n    ans += COM ( n + k - i - 1 , n - 1 ) * pow ( 26 , i , Mod ) * pow ( 25 , k - i , Mod )\n    ans = ans % Mod\nprint ( ans )\n", "python_code_tokenized": "import math NEW_LINE from collections import deque NEW_LINE from collections import Counter NEW_LINE Mod = 10 ** 9 + 7 NEW_LINE M = 10 ** 6 * 2 NEW_LINE fac = [ 0 ] * M NEW_LINE finv = [ 0 ] * M NEW_LINE inv = [ 0 ] * M NEW_LINE def COMinit ( ) : NEW_LINE INDENT fac [ 0 ] = fac [ 1 ] = 1 NEW_LINE finv [ 0 ] = finv [ 1 ] = 1 NEW_LINE inv [ 1 ] = 1 NEW_LINE for i in range ( 2 , M ) : NEW_LINE INDENT fac [ i ] = ( fac [ i - 1 ] * i % Mod ) % Mod NEW_LINE inv [ i ] = Mod - inv [ Mod % i ] * ( Mod // i ) % Mod NEW_LINE finv [ i ] = ( finv [ i - 1 ] * inv [ i ] % Mod ) % Mod NEW_LINE DEDENT DEDENT def COM ( n , k ) : NEW_LINE INDENT if n < k : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n < 0 or k < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( fac [ n ] * ( finv [ k ] * finv [ n - k ] % Mod ) % Mod ) % Mod NEW_LINE DEDENT COMinit ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE n = len ( s ) NEW_LINE ans = 0 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT ans += COM ( n + k - i - 1 , n - 1 ) * pow ( 26 , i , Mod ) * pow ( 25 , k - i , Mod ) NEW_LINE ans = ans % Mod NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "aizu_p00434_A", "sol": 0, "python_code": "s = [ i + 1 for i in range ( 30 ) ]\nfor i in range ( 28 ) :\n    t = int ( input ( ) )\n    s.remove ( t )\nprint ( s [ 0 ] , s [ 1 ] , sep = '\\n' )\n", "python_code_tokenized": "s = [ i + 1 for i in range ( 30 ) ] NEW_LINE for i in range ( 28 ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE s . remove ( t ) NEW_LINE DEDENT print ( s [ 0 ] , s [ 1 ] , sep = ' \\n ' ) NEW_LINE"}
{"id": "geeksforgeeks_4935_A", "sol": 0, "python_code": "def countOfAnagramSubstring ( s ) :\n    n = len ( s )\n    mp = dict ( )\n    for i in range ( n ) :\n        sb = ''\n        for j in range ( i , n ) :\n            sb = ''.join ( sorted ( sb + s [ j ] ) )\n            mp [ sb ] = mp.get ( sb , 0 )\n            mp [ sb ] += 1\n    anas = 0\n    for k , v in mp.items ( ) :\n        anas += ( v * ( v - 1 ) ) // 2\n    return anas\ns = \"xyyx\"\nprint ( countOfAnagramSubstring ( s ) )\n", "python_code_tokenized": "def countOfAnagramSubstring ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sb = ' ' NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sb = ' ' . join ( sorted ( sb + s [ j ] ) ) NEW_LINE mp [ sb ] = mp . get ( sb , 0 ) NEW_LINE mp [ sb ] += 1 NEW_LINE DEDENT DEDENT anas = 0 NEW_LINE for k , v in mp . items ( ) : NEW_LINE INDENT anas += ( v * ( v - 1 ) ) // 2 NEW_LINE DEDENT return anas NEW_LINE DEDENT s = \" xyyx \" NEW_LINE print ( countOfAnagramSubstring ( s ) ) NEW_LINE"}
{"id": "aizu_p00366_A", "sol": 0, "python_code": "from bisect import bisect_left as bl\nn = int ( input ( ) )\ntlst = sorted ( [ int ( input ( ) ) for _ in range ( n ) ] )\nmax_t = tlst [ - 1 ]\ndivisors = [ i for i in range ( 1 , max_t + 1 ) if max_t % i == 0 ]\nans = 0\nfor t in tlst :\n    ind = bl ( divisors , t )\n    ans += divisors [ ind ] - t\nprint ( ans )\n", "python_code_tokenized": "from bisect import bisect_left as bl NEW_LINE n = int ( input ( ) ) NEW_LINE tlst = sorted ( [ int ( input ( ) ) for _ in range ( n ) ] ) NEW_LINE max_t = tlst [ - 1 ] NEW_LINE divisors = [ i for i in range ( 1 , max_t + 1 ) if max_t % i == 0 ] NEW_LINE ans = 0 NEW_LINE for t in tlst : NEW_LINE INDENT ind = bl ( divisors , t ) NEW_LINE ans += divisors [ ind ] - t NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_2611_A", "sol": 0, "python_code": "def answer ( n ) :\n    dp = [ 0 ] * 10\n    prev = [ 0 ] * 10\n    if ( n == 1 ) :\n        return 10\n    for j in range ( 0 , 10 ) :\n        dp [ j ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( 0 , 10 ) :\n            prev [ j ] = dp [ j ]\n        for j in range ( 0 , 10 ) :\n            if ( j == 0 ) :\n                dp [ j ] = prev [ j + 1 ]\n            elif ( j == 9 ) :\n                dp [ j ] = prev [ j - 1 ]\n            else :\n                dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ]\n    sum = 0\n    for j in range ( 1 , 10 ) :\n        sum = sum + dp [ j ]\n    return sum\nn = 2\nprint ( answer ( n ) )\n", "python_code_tokenized": "def answer ( n ) : NEW_LINE INDENT dp = [ 0 ] * 10 NEW_LINE prev = [ 0 ] * 10 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT dp [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT prev [ j ] = dp [ j ] NEW_LINE DEDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ j ] = prev [ j + 1 ] NEW_LINE DEDENT elif ( j == 9 ) : NEW_LINE INDENT dp [ j ] = prev [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT sum = sum + dp [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 2 NEW_LINE print ( answer ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4469_A", "sol": 0, "python_code": "MAX = 1000005\nprime = [ True for i in range ( MAX ) ]\ndef seive ( N ) :\n    prime [ 0 ] , prime [ 1 ] = False , False\n    for i in range ( 2 , N + 1 ) :\n        if ( prime [ i ] ) :\n            for j in range ( 2 , N + 1 ) :\n                if ( i * j > N ) :\n                    break\n                prime [ i * j ] = False\ndef countLogNeeded ( N ) :\n    count = 0\n    seive ( N )\n    for i in range ( 1 , N + 1 ) :\n        if ( prime [ i ] ) :\n            count = count + 1\n    return count\nif __name__ == '__main__' :\n    N = 6\n    print ( countLogNeeded ( N ) )\n", "python_code_tokenized": "MAX = 1000005 NEW_LINE prime = [ True for i in range ( MAX ) ] NEW_LINE def seive ( N ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( i * j > N ) : NEW_LINE INDENT break NEW_LINE DEDENT prime [ i * j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def countLogNeeded ( N ) : NEW_LINE INDENT count = 0 NEW_LINE seive ( N ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE print ( countLogNeeded ( N ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1634_B", "sol": 0, "python_code": "def main ( ) :\n    t = int ( input ( ) )\n    for _ in range ( t ) :\n        n , x , y = map ( int , input ( ).split ( ) )\n        odd_cnt = 0\n        for num in input ( ).split ( ) :\n            if int ( num ) % 2 :\n                odd_cnt += 1\n        if odd_cnt % 2 == 0 and ( ( x % 2 ) == ( y % 2 ) ) :\n            print ( \"Alice\" )\n        elif odd_cnt % 2 and ( ( x % 2 ) != ( y % 2 ) ) :\n            print ( \"Alice\" )\n        else :\n            print ( \"Bob\" )\nmain ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE odd_cnt = 0 NEW_LINE for num in input ( ) . split ( ) : NEW_LINE INDENT if int ( num ) % 2 : NEW_LINE INDENT odd_cnt += 1 NEW_LINE DEDENT DEDENT if odd_cnt % 2 == 0 and ( ( x % 2 ) == ( y % 2 ) ) : NEW_LINE INDENT print ( \" Alice \" ) NEW_LINE DEDENT elif odd_cnt % 2 and ( ( x % 2 ) != ( y % 2 ) ) : NEW_LINE INDENT print ( \" Alice \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Bob \" ) NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "codeforces_161_A", "sol": 0, "python_code": "first = list ( map ( int , input ( ).split ( ) ) )\na = list ( map ( int , input ( ).split ( ) ) )\nb = list ( map ( int , input ( ).split ( ) ) )\nnSoldiers = first [ 0 ]\nnVest = first [ 1 ]\nx = first [ 2 ]\ny = first [ 3 ]\npair = 0\nresult = [ ]\ncurVest = 0\ncurSoldier = 0\nwhile curSoldier < nSoldiers and curVest < nVest :\n    if a [ curSoldier ] - x <= b [ curVest ] <= a [ curSoldier ] + y :\n        result.append ( str ( curSoldier + 1 ) + \" \" + str ( curVest + 1 ) )\n        pair += 1\n        curSoldier += 1\n        curVest += 1\n    else :\n        if a [ curSoldier ] < b [ curVest ] :\n            curSoldier += 1\n        else :\n            curVest += 1\nprint ( pair )\nprint ( \"\\n\".join ( result ) )\n", "python_code_tokenized": "first = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE nSoldiers = first [ 0 ] NEW_LINE nVest = first [ 1 ] NEW_LINE x = first [ 2 ] NEW_LINE y = first [ 3 ] NEW_LINE pair = 0 NEW_LINE result = [ ] NEW_LINE curVest = 0 NEW_LINE curSoldier = 0 NEW_LINE while curSoldier < nSoldiers and curVest < nVest : NEW_LINE INDENT if a [ curSoldier ] - x <= b [ curVest ] <= a [ curSoldier ] + y : NEW_LINE INDENT result . append ( str ( curSoldier + 1 ) + \" \u2581 \" + str ( curVest + 1 ) ) NEW_LINE pair += 1 NEW_LINE curSoldier += 1 NEW_LINE curVest += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if a [ curSoldier ] < b [ curVest ] : NEW_LINE INDENT curSoldier += 1 NEW_LINE DEDENT else : NEW_LINE INDENT curVest += 1 NEW_LINE DEDENT DEDENT DEDENT print ( pair ) NEW_LINE print ( \" \\n \" . join ( result ) ) NEW_LINE"}
{"id": "atcoder_ABC157_E", "sol": 0, "python_code": "import bisect\nn = int ( input ( ) )\ns = list ( input ( ) )\nalp = 'abcdefghijklmnopqrstuvwxyz'\ncnt = { c : [ ] for c in alp }\nfor i , c in enumerate ( s ) :\n    cnt [ c ].append ( i )\nq = int ( input ( ) )\nfor _ in range ( q ) :\n    t , x , y = input ( ).split ( )\n    ans = 0\n    if t == '1' :\n        i , c = int ( x ) - 1 , y\n        if s [ i ] == c :\n            continue\n        a = bisect.bisect_left ( cnt [ s [ i ] ] , i )\n        cnt [ s [ i ] ].pop ( a )\n        s [ i ] = c\n        b = bisect.bisect_left ( cnt [ c ] , i )\n        cnt [ c ].insert ( b , i )\n    else :\n        l , r = int ( x ) - 1 , int ( y ) - 1\n        for c in alp :\n            a = bisect.bisect_left ( cnt [ c ] , l )\n            if a < len ( cnt [ c ] ) and cnt [ c ] [ a ] <= r :\n                ans += 1\n        print ( ans )\n", "python_code_tokenized": "import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE s = list ( input ( ) ) NEW_LINE alp = ' abcdefghijklmnopqrstuvwxyz ' NEW_LINE cnt = { c : [ ] for c in alp } NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT cnt [ c ] . append ( i ) NEW_LINE DEDENT q = int ( input ( ) ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT t , x , y = input ( ) . split ( ) NEW_LINE ans = 0 NEW_LINE if t == '1' : NEW_LINE INDENT i , c = int ( x ) - 1 , y NEW_LINE if s [ i ] == c : NEW_LINE INDENT continue NEW_LINE DEDENT a = bisect . bisect_left ( cnt [ s [ i ] ] , i ) NEW_LINE cnt [ s [ i ] ] . pop ( a ) NEW_LINE s [ i ] = c NEW_LINE b = bisect . bisect_left ( cnt [ c ] , i ) NEW_LINE cnt [ c ] . insert ( b , i ) NEW_LINE DEDENT else : NEW_LINE INDENT l , r = int ( x ) - 1 , int ( y ) - 1 NEW_LINE for c in alp : NEW_LINE INDENT a = bisect . bisect_left ( cnt [ c ] , l ) NEW_LINE if a < len ( cnt [ c ] ) and cnt [ c ] [ a ] <= r : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC173_E", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\na = [ 0 ] * n\na = list ( map ( int , input ( ).split ( ) ) )\na = sorted ( a )\nmod = 10 ** 9 + 7\nans = 1\nif ( k % 2 == 0 or a [ - 1 ] >= 0 ) :\n    mlt1 = a [ 0 ] * a [ 1 ]\n    mlt2 = a [ - 2 ] * a [ - 1 ]\n    l = 0\n    r = - 1\n    for i in range ( k // 2 ) :\n        if ( mlt1 >= mlt2 ) :\n            ans *= mlt1 % mod\n            l += 2\n            if ( l <= n - 2 ) :\n                mlt1 = a [ l + 1 ] * a [ l ]\n        else :\n            ans *= mlt2 % mod\n            r -= 2\n            if ( r >= - n + 1 ) :\n                mlt2 = a [ r - 1 ] * a [ r ]\n        ans %= mod\n    if ( k % 2 == 1 ) :\n        ans *= a [ r ]\n        ans %= mod\nelse :\n    for i in range ( k ) :\n        ans *= a [ n - 1 - i ]\n        ans %= mod\nprint ( ans )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ 0 ] * n NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = sorted ( a ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE ans = 1 NEW_LINE if ( k % 2 == 0 or a [ - 1 ] >= 0 ) : NEW_LINE INDENT mlt1 = a [ 0 ] * a [ 1 ] NEW_LINE mlt2 = a [ - 2 ] * a [ - 1 ] NEW_LINE l = 0 NEW_LINE r = - 1 NEW_LINE for i in range ( k // 2 ) : NEW_LINE INDENT if ( mlt1 >= mlt2 ) : NEW_LINE INDENT ans *= mlt1 % mod NEW_LINE l += 2 NEW_LINE if ( l <= n - 2 ) : NEW_LINE INDENT mlt1 = a [ l + 1 ] * a [ l ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans *= mlt2 % mod NEW_LINE r -= 2 NEW_LINE if ( r >= - n + 1 ) : NEW_LINE INDENT mlt2 = a [ r - 1 ] * a [ r ] NEW_LINE DEDENT DEDENT ans %= mod NEW_LINE DEDENT if ( k % 2 == 1 ) : NEW_LINE INDENT ans *= a [ r ] NEW_LINE ans %= mod NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT ans *= a [ n - 1 - i ] NEW_LINE ans %= mod NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_108_B", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nn = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nans = \"NO\"\na.sort ( reverse = True )\nwhile a and not a [ - 1 ] ^ 1 :\n    a.pop ( )\na.reverse ( )\nfor i in range ( len ( a ) - 1 ) :\n    if 2 * a [ i ] > a [ i + 1 ] and a [ i ] ^ a [ i + 1 ] :\n        ans = \"YES\"\n        break\nprint ( ans )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = \" NO \" NEW_LINE a . sort ( reverse = True ) NEW_LINE while a and not a [ - 1 ] ^ 1 : NEW_LINE INDENT a . pop ( ) NEW_LINE DEDENT a . reverse ( ) NEW_LINE for i in range ( len ( a ) - 1 ) : NEW_LINE INDENT if 2 * a [ i ] > a [ i + 1 ] and a [ i ] ^ a [ i + 1 ] : NEW_LINE INDENT ans = \" YES \" NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_3202_A", "sol": 0, "python_code": "def printNonDivisible ( A , B , n , m ) :\n    maxB = 0\n    for i in range ( 0 , m , 1 ) :\n        if ( B [ i ] > maxB ) :\n            maxB = B [ i ]\n    mark = [ 0 for i in range ( maxB ) ]\n    for i in range ( 0 , n , 1 ) :\n        for x in range ( A [ i ] , maxB , A [ i ] ) :\n            mark [ x ] += 1\n    for i in range ( 0 , m - 1 , 1 ) :\n        if ( mark [ B [ i ] ] == 0 ) :\n            print ( B [ i ] )\nif __name__ == '__main__' :\n    A = [ 100 , 200 , 400 , 100 ]\n    n = len ( A )\n    B = [ 190 , 200 , 87 , 600 , 800 ]\n    m = len ( B )\n    printNonDivisible ( A , B , n , m )\n", "python_code_tokenized": "def printNonDivisible ( A , B , n , m ) : NEW_LINE INDENT maxB = 0 NEW_LINE for i in range ( 0 , m , 1 ) : NEW_LINE INDENT if ( B [ i ] > maxB ) : NEW_LINE INDENT maxB = B [ i ] NEW_LINE DEDENT DEDENT mark = [ 0 for i in range ( maxB ) ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT for x in range ( A [ i ] , maxB , A [ i ] ) : NEW_LINE INDENT mark [ x ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , m - 1 , 1 ) : NEW_LINE INDENT if ( mark [ B [ i ] ] == 0 ) : NEW_LINE INDENT print ( B [ i ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 100 , 200 , 400 , 100 ] NEW_LINE n = len ( A ) NEW_LINE B = [ 190 , 200 , 87 , 600 , 800 ] NEW_LINE m = len ( B ) NEW_LINE printNonDivisible ( A , B , n , m ) NEW_LINE DEDENT"}
{"id": "codeforces_1133_B", "sol": 0, "python_code": "from math import floor\nn , k = list ( map ( int , input ( ).split ( ) ) )\nlst = list ( map ( int , input ( ).split ( ) ) )\ncounts = [ 0 ] * k\npairs = 0\nfor l in lst :\n    counts [ l % k ] += 1\npairs += floor ( counts [ 0 ] / 2 )\nif k % 2 == 0 :\n    pairs += floor ( counts [ k // 2 ] / 2 )\nfor i in range ( 1 , ( k + 1 ) // 2 ) :\n    pairs += min ( counts [ i ] , counts [ k - i ] )\nprint ( pairs * 2 )\n", "python_code_tokenized": "from math import floor NEW_LINE n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE counts = [ 0 ] * k NEW_LINE pairs = 0 NEW_LINE for l in lst : NEW_LINE INDENT counts [ l % k ] += 1 NEW_LINE DEDENT pairs += floor ( counts [ 0 ] / 2 ) NEW_LINE if k % 2 == 0 : NEW_LINE INDENT pairs += floor ( counts [ k // 2 ] / 2 ) NEW_LINE DEDENT for i in range ( 1 , ( k + 1 ) // 2 ) : NEW_LINE INDENT pairs += min ( counts [ i ] , counts [ k - i ] ) NEW_LINE DEDENT print ( pairs * 2 ) NEW_LINE"}
{"id": "geeksforgeeks_1418_A", "sol": 0, "python_code": "import numpy as np ;\nmatrix = np.zeros ( ( 100 , 100 ) ) ;\ndef printRequiredMatrix ( n ) :\n    if ( n == 1 ) :\n        print ( \"1\" ) ;\n    elif ( n % 2 != 0 ) :\n        print ( \"-1\" ) ;\n    else :\n        for i in range ( n ) :\n            matrix [ i ] [ i ] = n ;\n        u = n - 1 ;\n        for i in range ( n - 1 ) :\n            matrix [ i ] [ u ] = i + 1 ;\n            for j in range ( 1 , n // 2 ) :\n                a = ( i + j ) % ( n - 1 ) ;\n                b = ( i - j + n - 1 ) % ( n - 1 ) ;\n                if ( a < b ) :\n                    a , b = b , a\n                matrix [ b ] [ a ] = i + 1 ;\n        for i in range ( n ) :\n            for j in range ( i ) :\n                matrix [ i ] [ j ] = matrix [ j ] [ i ] + n ;\n        for i in range ( n ) :\n            for j in range ( n ) :\n                print ( matrix [ i ] [ j ] , end = \" \" ) ;\n            print ( ) ;\n    print ( )\nif __name__ == \"__main__\" :\n    n = 1 ;\n    printRequiredMatrix ( n ) ;\n    n = 3 ;\n    printRequiredMatrix ( n ) ;\n    n = 6 ;\n    printRequiredMatrix ( n ) ;\n", "python_code_tokenized": "import numpy as np ; NEW_LINE matrix = np . zeros ( ( 100 , 100 ) ) ; NEW_LINE def printRequiredMatrix ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( \"1\" ) ; NEW_LINE DEDENT elif ( n % 2 != 0 ) : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT matrix [ i ] [ i ] = n ; NEW_LINE DEDENT u = n - 1 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT matrix [ i ] [ u ] = i + 1 ; NEW_LINE for j in range ( 1 , n // 2 ) : NEW_LINE INDENT a = ( i + j ) % ( n - 1 ) ; NEW_LINE b = ( i - j + n - 1 ) % ( n - 1 ) ; NEW_LINE if ( a < b ) : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT matrix [ b ] [ a ] = i + 1 ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT matrix [ i ] [ j ] = matrix [ j ] [ i ] + n ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( matrix [ i ] [ j ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1 ; NEW_LINE printRequiredMatrix ( n ) ; NEW_LINE n = 3 ; NEW_LINE printRequiredMatrix ( n ) ; NEW_LINE n = 6 ; NEW_LINE printRequiredMatrix ( n ) ; NEW_LINE DEDENT"}
{"id": "atcoder_ABC086_B", "sol": 0, "python_code": "a , b = ( i for i in input ( ).split ( ) )\nz = int ( a + b )\nimport math\nif z ** ( 1 / 2 ) == math.floor ( z ** ( 1 / 2 ) ) :\n    print ( 'Yes' )\nelse :\n    print ( 'No' )\n", "python_code_tokenized": "a , b = ( i for i in input ( ) . split ( ) ) NEW_LINE z = int ( a + b ) NEW_LINE import math NEW_LINE if z ** ( 1 / 2 ) == math . floor ( z ** ( 1 / 2 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT"}
{"id": "codeforces_1110_A", "sol": 0, "python_code": "a , _ = [ int ( c ) for c in input ( ).split ( ) ]\narr = [ int ( c ) for c in input ( ).split ( ) ]\nif a % 2 == 0 :\n    print ( \"even\" if arr [ - 1 ] % 2 == 0 else \"odd\" )\nelse :\n    print ( \"even\" if sum ( arr ) % 2 == 0 else \"odd\" )\n", "python_code_tokenized": "a , _ = [ int ( c ) for c in input ( ) . split ( ) ] NEW_LINE arr = [ int ( c ) for c in input ( ) . split ( ) ] NEW_LINE if a % 2 == 0 : NEW_LINE INDENT print ( \" even \" if arr [ - 1 ] % 2 == 0 else \" odd \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" even \" if sum ( arr ) % 2 == 0 else \" odd \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3490_A", "sol": 0, "python_code": "def minSum ( arr , n ) :\n    evenArr = [ ]\n    oddArr = [ ]\n    arr.sort ( )\n    for i in range ( n ) :\n        if ( i < n // 2 ) :\n            oddArr.append ( arr [ i ] )\n        else :\n            evenArr.append ( arr [ i ] )\n    evenArr.sort ( reverse = True )\n    i = 0\n    sum = 0\n    for j in range ( len ( evenArr ) ) :\n        arr [ i ] = evenArr [ j ]\n        i += 1\n        arr [ i ] = oddArr [ j ]\n        i += 1\n        sum += evenArr [ j ] * oddArr [ j ]\n    return sum\nif __name__ == \"__main__\" :\n    arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ]\n    n = len ( arr )\n    print ( \"Minimum required sum =\" , minSum ( arr , n ) )\n    print ( \"Sorted array in required format : \" , end = \"\" )\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" )\n", "python_code_tokenized": "def minSum ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr . sort ( reverse = True ) NEW_LINE i = 0 NEW_LINE sum = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE sum += evenArr [ j ] * oddArr [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum \u2581 required \u2581 sum \u2581 = \" , minSum ( arr , n ) ) NEW_LINE print ( \" Sorted \u2581 array \u2581 in \u2581 required \u2581 format \u2581 : \u2581 \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2992_A", "sol": 0, "python_code": "def maxcoefficientvalue ( n ) :\n    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] ;\n    for i in range ( n + 1 ) :\n        for j in range ( min ( i , n ) + 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1 ;\n            else :\n                C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ;\n    maxvalue = 0 ;\n    for i in range ( n + 1 ) :\n        maxvalue = max ( maxvalue , C [ n ] [ i ] ) ;\n    return maxvalue ;\nn = 4 ;\nprint ( maxcoefficientvalue ( n ) ) ;\n", "python_code_tokenized": "def maxcoefficientvalue ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT maxvalue = 0 ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT maxvalue = max ( maxvalue , C [ n ] [ i ] ) ; NEW_LINE DEDENT return maxvalue ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( maxcoefficientvalue ( n ) ) ; NEW_LINE"}
{"id": "codeforces_686_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = [ int ( i ) for i in input ( ).split ( ) ]\nA = sorted ( a )\nfor i in range ( n - 1 , - 1 , - 1 ) :\n    for j in range ( i ) :\n        if a [ j ] > a [ j + 1 ] :\n            a [ j ] , a [ j + 1 ] = a [ j + 1 ] , a [ j ]\n            print ( j + 1 , j + 2 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE A = sorted ( a ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if a [ j ] > a [ j + 1 ] : NEW_LINE INDENT a [ j ] , a [ j + 1 ] = a [ j + 1 ] , a [ j ] NEW_LINE print ( j + 1 , j + 2 ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_166_A", "sol": 0, "python_code": "def isOperand ( x ) :\n    return ( ( x >= 'a' and x <= 'z' ) or ( x >= 'A' and x <= 'Z' ) )\ndef getInfix ( exp ) :\n    s = [ ]\n    for i in exp :\n        if ( isOperand ( i ) ) :\n            s.insert ( 0 , i )\n        else :\n            op1 = s [ 0 ]\n            s.pop ( 0 )\n            op2 = s [ 0 ]\n            s.pop ( 0 )\n            s.insert ( 0 , \"(\" + op2 + i + op1 + \")\" )\n    return s [ 0 ]\nif __name__ == '__main__' :\n    exp = \"ab*c+\"\n    print ( getInfix ( exp.strip ( ) ) )\n", "python_code_tokenized": "def isOperand ( x ) : NEW_LINE INDENT return ( ( x >= ' a ' and x <= ' z ' ) or ( x >= ' A ' and x <= ' Z ' ) ) NEW_LINE DEDENT def getInfix ( exp ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in exp : NEW_LINE INDENT if ( isOperand ( i ) ) : NEW_LINE INDENT s . insert ( 0 , i ) NEW_LINE DEDENT else : NEW_LINE INDENT op1 = s [ 0 ] NEW_LINE s . pop ( 0 ) NEW_LINE op2 = s [ 0 ] NEW_LINE s . pop ( 0 ) NEW_LINE s . insert ( 0 , \" ( \" + op2 + i + op1 + \" ) \" ) NEW_LINE DEDENT DEDENT return s [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT exp = \" ab * c + \" NEW_LINE print ( getInfix ( exp . strip ( ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_823_A", "sol": 0, "python_code": "def disp ( row_no , block ) :\n    print ( row_no * block )\ndef row ( ht , h ) :\n    return ht // h\ndef calculate ( l , w , h , a , ht ) :\n    no_block = ( 4 * a ) // l\n    if ( h < w ) :\n        row_no = row ( ht , w )\n    else :\n        row_no = row ( ht , h )\n    disp ( row_no , no_block )\nif __name__ == '__main__' :\n    l = 50\n    w = 20\n    h = 35\n    a = 700\n    ht = 140\n    calculate ( l , w , h , a , ht )\n", "python_code_tokenized": "def disp ( row_no , block ) : NEW_LINE INDENT print ( row_no * block ) NEW_LINE DEDENT def row ( ht , h ) : NEW_LINE INDENT return ht // h NEW_LINE DEDENT def calculate ( l , w , h , a , ht ) : NEW_LINE INDENT no_block = ( 4 * a ) // l NEW_LINE if ( h < w ) : NEW_LINE INDENT row_no = row ( ht , w ) NEW_LINE DEDENT else : NEW_LINE INDENT row_no = row ( ht , h ) NEW_LINE DEDENT disp ( row_no , no_block ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 50 NEW_LINE w = 20 NEW_LINE h = 35 NEW_LINE a = 700 NEW_LINE ht = 140 NEW_LINE calculate ( l , w , h , a , ht ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4727_A", "sol": 0, "python_code": "def xorCalc ( k ) :\n    if ( k == 1 ) :\n        return 2\n    if ( ( ( k + 1 ) & k ) == 0 ) :\n        return k / 2\n    return 1 ;\nk = 31\nprint ( int ( xorCalc ( k ) ) )\n", "python_code_tokenized": "def xorCalc ( k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( ( ( k + 1 ) & k ) == 0 ) : NEW_LINE INDENT return k / 2 NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT k = 31 NEW_LINE print ( int ( xorCalc ( k ) ) ) NEW_LINE"}
{"id": "codeforces_304_B", "sol": 0, "python_code": "y1 , m1 , d1 = input ( ).split ( \":\" )\ny2 , m2 , d2 = input ( ).split ( \":\" )\nfrom datetime import *\ndate1 = datetime ( year = int ( y1 ) , month = int ( m1 ) , day = int ( d1 ) )\ndate2 = datetime ( year = int ( y2 ) , month = int ( m2 ) , day = int ( d2 ) )\nres = date2 - date1\nprint ( abs ( res.days ) )\n", "python_code_tokenized": "y1 , m1 , d1 = input ( ) . split ( \" : \" ) NEW_LINE y2 , m2 , d2 = input ( ) . split ( \" : \" ) NEW_LINE from datetime import * NEW_LINE date1 = datetime ( year = int ( y1 ) , month = int ( m1 ) , day = int ( d1 ) ) NEW_LINE date2 = datetime ( year = int ( y2 ) , month = int ( m2 ) , day = int ( d2 ) ) NEW_LINE res = date2 - date1 NEW_LINE print ( abs ( res . days ) ) NEW_LINE"}
{"id": "geeksforgeeks_4798_A", "sol": 0, "python_code": "def isPalindrome ( n ) :\n    divisor = 1\n    while ( int ( n / divisor ) >= 10 ) :\n        divisor *= 10\n    while ( n != 0 ) :\n        leading = int ( n / divisor )\n        trailing = n % 10\n        if ( leading != trailing ) :\n            return False\n        n = int ( ( n % divisor ) / 10 )\n        divisor = int ( divisor / 100 )\n    return True\ndef largestPalindrome ( A , n ) :\n    currentMax = - 1\n    for i in range ( 0 , n , 1 ) :\n        if ( A [ i ] > currentMax and isPalindrome ( A [ i ] ) ) :\n            currentMax = A [ i ]\n    return currentMax\nif __name__ == '__main__' :\n    A = [ 1 , 232 , 54545 , 999991 ]\n    n = len ( A )\n    print ( largestPalindrome ( A , n ) )\n", "python_code_tokenized": "def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( int ( n / divisor ) >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = int ( n / divisor ) NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = int ( ( n % divisor ) / 10 ) NEW_LINE divisor = int ( divisor / 100 ) NEW_LINE DEDENT return True NEW_LINE DEDENT def largestPalindrome ( A , n ) : NEW_LINE INDENT currentMax = - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( A [ i ] > currentMax and isPalindrome ( A [ i ] ) ) : NEW_LINE INDENT currentMax = A [ i ] NEW_LINE DEDENT DEDENT return currentMax NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 232 , 54545 , 999991 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestPalindrome ( A , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4797_A", "sol": 0, "python_code": "def isPalindrome ( n ) :\n    divisor = 1\n    while ( n / divisor >= 10 ) :\n        divisor *= 10\n    while ( n != 0 ) :\n        leading = n // divisor\n        trailing = n % 10\n        if ( leading != trailing ) :\n            return False\n        n = ( n % divisor ) // 10\n        divisor = divisor // 100\n    return True\ndef largestPalindrome ( A , n ) :\n    A.sort ( )\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        if ( isPalindrome ( A [ i ] ) ) :\n            return A [ i ]\n    return - 1\nif __name__ == \"__main__\" :\n    A = [ 1 , 232 , 54545 , 999991 ]\n    n = len ( A )\n    print ( largestPalindrome ( A , n ) )\n", "python_code_tokenized": "def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( n / divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n // divisor NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = ( n % divisor ) // 10 NEW_LINE divisor = divisor // 100 NEW_LINE DEDENT return True NEW_LINE DEDENT def largestPalindrome ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( isPalindrome ( A [ i ] ) ) : NEW_LINE INDENT return A [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 232 , 54545 , 999991 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestPalindrome ( A , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3061_A", "sol": 0, "python_code": "def squareDigitSum ( num ) :\n    lengthN = len ( num )\n    result = ( lengthN // 9 ) * 81 + ( lengthN % 9 ) ** 2\n    return result\nif __name__ == \"__main__\" :\n    N = \"1111\"\n    print ( squareDigitSum ( N ) )\n", "python_code_tokenized": "def squareDigitSum ( num ) : NEW_LINE INDENT lengthN = len ( num ) NEW_LINE result = ( lengthN // 9 ) * 81 + ( lengthN % 9 ) ** 2 NEW_LINE return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = \"1111\" NEW_LINE print ( squareDigitSum ( N ) ) NEW_LINE DEDENT"}
{"id": "codeforces_388_A", "sol": 0, "python_code": "from typing import List , Tuple , Union\nfrom math import ceil\nfrom typing import List\ndef munimum_number_of_piles ( n : int , n_values : List [ int ] ) -> int :\n    n_values.sort ( )\n    pile = - 1\n    for idx , s in enumerate ( n_values ) :\n        k = int ( ceil ( ( idx + 1 ) / ( s + 1 ) ) )\n        pile = max ( pile , k )\n    return pile\nn = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nprint ( munimum_number_of_piles ( n , a ) )\n", "python_code_tokenized": "from typing import List , Tuple , Union NEW_LINE from math import ceil NEW_LINE from typing import List NEW_LINE def munimum_number_of_piles ( n : int , n_values : List [ int ] ) -> int : NEW_LINE INDENT n_values . sort ( ) NEW_LINE pile = - 1 NEW_LINE for idx , s in enumerate ( n_values ) : NEW_LINE INDENT k = int ( ceil ( ( idx + 1 ) / ( s + 1 ) ) ) NEW_LINE pile = max ( pile , k ) NEW_LINE DEDENT return pile NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( munimum_number_of_piles ( n , a ) ) NEW_LINE"}
{"id": "aizu_p00185_A", "sol": 0, "python_code": "import bisect\nprimes = [ 0 , 0 ] + [ 1 ] * 999999\nfor i in range ( 2 , 1001 ) :\n    if primes [ i ] :\n        for j in range ( i * i , 1000001 , i ) :\n            primes [ j ] = 0\nprime_value = [ i for i in range ( len ( primes ) ) if primes [ i ] ]\nwhile True :\n    n = int ( input ( ) )\n    if n == 0 :\n        break\n    x = bisect.bisect_right ( prime_value , n // 2 )\n    print ( sum ( 1 for p in prime_value [ : x ] if primes [ n - p ] ) )\n", "python_code_tokenized": "import bisect NEW_LINE primes = [ 0 , 0 ] + [ 1 ] * 999999 NEW_LINE for i in range ( 2 , 1001 ) : NEW_LINE INDENT if primes [ i ] : NEW_LINE INDENT for j in range ( i * i , 1000001 , i ) : NEW_LINE INDENT primes [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT prime_value = [ i for i in range ( len ( primes ) ) if primes [ i ] ] NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT x = bisect . bisect_right ( prime_value , n // 2 ) NEW_LINE print ( sum ( 1 for p in prime_value [ : x ] if primes [ n - p ] ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1829_A", "sol": 0, "python_code": "def getNthTerm ( N ) :\n    return ( pow ( N , 2 ) + N + 1 )\nif __name__ == '__main__' :\n    N = 11\n    print ( getNthTerm ( N ) )\n", "python_code_tokenized": "def getNthTerm ( N ) : NEW_LINE INDENT return ( pow ( N , 2 ) + N + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 11 NEW_LINE print ( getNthTerm ( N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1825_A", "sol": 0, "python_code": "def getNthTerm ( N ) :\n    return ( 7 * pow ( N , 2 ) - 19 * N + 15 )\nif __name__ == '__main__' :\n    N = 4\n    print ( getNthTerm ( N ) )\n", "python_code_tokenized": "def getNthTerm ( N ) : NEW_LINE INDENT return ( 7 * pow ( N , 2 ) - 19 * N + 15 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( getNthTerm ( N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1826_A", "sol": 0, "python_code": "def getNthTerm ( N ) :\n    return 4 * pow ( N , 2 ) - 3 * N + 2\nif __name__ == '__main__' :\n    N = 10\n    print ( getNthTerm ( N ) )\n", "python_code_tokenized": "def getNthTerm ( N ) : NEW_LINE INDENT return 4 * pow ( N , 2 ) - 3 * N + 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( getNthTerm ( N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2641_A", "sol": 0, "python_code": "def MinimizeleftOverSum ( a , n ) :\n    v1 , v2 = [ ] , [ ] ;\n    for i in range ( n ) :\n        if ( a [ i ] % 2 ) :\n            v1.append ( a [ i ] ) ;\n        else :\n            v2.append ( a [ i ] ) ;\n    if ( len ( v1 ) > len ( v2 ) ) :\n        v1.sort ( ) ;\n        v2.sort ( ) ;\n        x = len ( v1 ) - len ( v2 ) - 1 ;\n        sum = 0 ;\n        i = 0 ;\n        while ( i < x ) :\n            sum += v1 [ i ] ;\n            i += 1\n        return sum ;\n    elif ( len ( v2 ) > len ( v1 ) ) :\n        v1.sort ( ) ;\n        v2.sort ( ) ;\n        x = len ( v2 ) - len ( v1 ) - 1 ;\n        sum = 0 ;\n        i = 0 ;\n        while ( i < x ) :\n            sum += v2 [ i ] ;\n            i += 1\n        return sum ;\n    else :\n        return 0 ;\nif __name__ == \"__main__\" :\n    a = [ 2 , 2 , 2 , 2 ] ;\n    n = len ( a ) ;\n    print ( MinimizeleftOverSum ( a , n ) ) ;\n", "python_code_tokenized": "def MinimizeleftOverSum ( a , n ) : NEW_LINE INDENT v1 , v2 = [ ] , [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 ) : NEW_LINE INDENT v1 . append ( a [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( a [ i ] ) ; NEW_LINE DEDENT DEDENT if ( len ( v1 ) > len ( v2 ) ) : NEW_LINE INDENT v1 . sort ( ) ; NEW_LINE v2 . sort ( ) ; NEW_LINE x = len ( v1 ) - len ( v2 ) - 1 ; NEW_LINE sum = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < x ) : NEW_LINE INDENT sum += v1 [ i ] ; NEW_LINE i += 1 NEW_LINE DEDENT return sum ; NEW_LINE DEDENT elif ( len ( v2 ) > len ( v1 ) ) : NEW_LINE INDENT v1 . sort ( ) ; NEW_LINE v2 . sort ( ) ; NEW_LINE x = len ( v2 ) - len ( v1 ) - 1 ; NEW_LINE sum = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < x ) : NEW_LINE INDENT sum += v2 [ i ] ; NEW_LINE i += 1 NEW_LINE DEDENT return sum ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 2 , 2 , 2 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( MinimizeleftOverSum ( a , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_986_A", "sol": 0, "python_code": "sz = 10 ** 5\nisPrime = [ True for i in range ( sz + 1 ) ]\ndef sieve ( ) :\n    isPrime [ 0 ] = isPrime [ 1 ] = False\n    i = 2\n    while i * i < sz :\n        if ( isPrime [ i ] ) :\n            for j in range ( i * i , sz , i ) :\n                isPrime [ j ] = False\n        i += 1\ndef prArray ( arr , lenn ) :\n    for i in range ( lenn ) :\n        print ( arr [ i ] , end = \" \" )\ndef removePrimes ( arr , lenn ) :\n    sieve ( )\n    i = 0\n    while i < lenn :\n        if ( isPrime [ arr [ i ] ] ) :\n            for j in range ( i , lenn - 1 ) :\n                arr [ j ] = arr [ j + 1 ]\n            i -= 1\n            lenn -= 1\n        i += 1\n    prArray ( arr , lenn )\nif __name__ == '__main__' :\n    arr = [ 4 , 6 , 5 , 3 , 8 , 7 , 10 , 11 , 14 , 15 ]\n    lenn = len ( arr )\n    removePrimes ( arr , lenn )\n", "python_code_tokenized": "sz = 10 ** 5 NEW_LINE isPrime = [ True for i in range ( sz + 1 ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i < sz : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , sz , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def prArray ( arr , lenn ) : NEW_LINE INDENT for i in range ( lenn ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT def removePrimes ( arr , lenn ) : NEW_LINE INDENT sieve ( ) NEW_LINE i = 0 NEW_LINE while i < lenn : NEW_LINE INDENT if ( isPrime [ arr [ i ] ] ) : NEW_LINE INDENT for j in range ( i , lenn - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT i -= 1 NEW_LINE lenn -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT prArray ( arr , lenn ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 6 , 5 , 3 , 8 , 7 , 10 , 11 , 14 , 15 ] NEW_LINE lenn = len ( arr ) NEW_LINE removePrimes ( arr , lenn ) NEW_LINE DEDENT"}
{"id": "codeforces_1099_A", "sol": 0, "python_code": "w , h = map ( int , input ( ).split ( ) )\nu1 , d1 = map ( int , input ( ).split ( ) )\nu2 , d2 = map ( int , input ( ).split ( ) )\nwhile h :\n    w += h\n    if h == d1 :\n        w = max ( 0 , w - u1 )\n    if h == d2 :\n        w = max ( 0 , w - u2 )\n    h -= 1\nprint ( w )\n", "python_code_tokenized": "w , h = map ( int , input ( ) . split ( ) ) NEW_LINE u1 , d1 = map ( int , input ( ) . split ( ) ) NEW_LINE u2 , d2 = map ( int , input ( ) . split ( ) ) NEW_LINE while h : NEW_LINE INDENT w += h NEW_LINE if h == d1 : NEW_LINE INDENT w = max ( 0 , w - u1 ) NEW_LINE DEDENT if h == d2 : NEW_LINE INDENT w = max ( 0 , w - u2 ) NEW_LINE DEDENT h -= 1 NEW_LINE DEDENT print ( w ) NEW_LINE"}
{"id": "leetcode_743_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def networkDelayTime ( self , times , N , K ) :\n        graph = collections.defaultdict ( list )\n        for u , v , w in times :\n            graph [ u ].append ( ( v , w ) )\n        dist = { node : float ( 'inf' ) for node in xrange ( 1 , N + 1 ) }\n        seen = [ False ] * ( N + 1 )\n        dist [ K ] = 0\n        while True :\n            cand_node = - 1\n            cand_dist = float ( 'inf' )\n            for i in xrange ( 1 , N + 1 ) :\n                if not seen [ i ] and dist [ i ] < cand_dist :\n                    cand_dist = dist [ i ]\n                    cand_node = i\n            if cand_node < 0 : break\n            seen [ cand_node ] = True\n            for nei , d in graph [ cand_node ] :\n                dist [ nei ] = min ( dist [ nei ] , dist [ cand_node ] + d )\n        ans = max ( dist.values ( ) )\n        return ans if ans < float ( 'inf' ) else - 1\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def networkDelayTime ( self , times , N , K ) : NEW_LINE INDENT graph = collections . defaultdict ( list ) NEW_LINE for u , v , w in times : NEW_LINE INDENT graph [ u ] . append ( ( v , w ) ) NEW_LINE DEDENT dist = { node : float ( ' inf ' ) for node in xrange ( 1 , N + 1 ) } NEW_LINE seen = [ False ] * ( N + 1 ) NEW_LINE dist [ K ] = 0 NEW_LINE while True : NEW_LINE INDENT cand_node = - 1 NEW_LINE cand_dist = float ( ' inf ' ) NEW_LINE for i in xrange ( 1 , N + 1 ) : NEW_LINE INDENT if not seen [ i ] and dist [ i ] < cand_dist : NEW_LINE INDENT cand_dist = dist [ i ] NEW_LINE cand_node = i NEW_LINE DEDENT DEDENT if cand_node < 0 : break NEW_LINE seen [ cand_node ] = True NEW_LINE for nei , d in graph [ cand_node ] : NEW_LINE INDENT dist [ nei ] = min ( dist [ nei ] , dist [ cand_node ] + d ) NEW_LINE DEDENT DEDENT ans = max ( dist . values ( ) ) NEW_LINE return ans if ans < float ( ' inf ' ) else - 1 NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3865_A", "sol": 0, "python_code": "def Check_is_possible ( l , r , k ) :\n    count = 0 ;\n    for i in range ( l , r + 1 ) :\n        if ( i % k == 0 ) :\n            count += 1 ;\n    return ( count > 1 ) ;\nl = 4 ;\nr = 12 ;\nk = 5 ;\nif ( Check_is_possible ( l , r , k ) ) :\n    print ( \"YES\" ) ;\nelse :\n    print ( \"NO\" ) ;\n", "python_code_tokenized": "def Check_is_possible ( l , r , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return ( count > 1 ) ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 12 ; NEW_LINE k = 5 ; NEW_LINE if ( Check_is_possible ( l , r , k ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3443_A", "sol": 0, "python_code": "class Data :\n    def __init__ ( self , x , y ) :\n        self.x = x\n        self.y = y\ndef inv_interpolate ( d : list , n : int , y : float ) -> float :\n    x = 0\n    for i in range ( n ) :\n        xi = d [ i ].x\n        for j in range ( n ) :\n            if j != i :\n                xi = ( xi * ( y - d [ j ].y ) / ( d [ i ].y - d [ j ].y ) )\n        x += xi\n    return x\nif __name__ == \"__main__\" :\n    d = [ Data ( 1.27 , 2.3 ) , Data ( 2.25 , 2.95 ) , Data ( 2.5 , 3.5 ) , Data ( 3.6 , 5.1 ) ]\n    n = 4\n    y = 4.5\n    print ( \"Value of x at y = 4.5 :\" , round ( inv_interpolate ( d , n , y ) , 5 ) )\n", "python_code_tokenized": "class Data : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def inv_interpolate ( d : list , n : int , y : float ) -> float : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xi = d [ i ] . x NEW_LINE for j in range ( n ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT xi = ( xi * ( y - d [ j ] . y ) / ( d [ i ] . y - d [ j ] . y ) ) NEW_LINE DEDENT DEDENT x += xi NEW_LINE DEDENT return x NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT d = [ Data ( 1.27 , 2.3 ) , Data ( 2.25 , 2.95 ) , Data ( 2.5 , 3.5 ) , Data ( 3.6 , 5.1 ) ] NEW_LINE n = 4 NEW_LINE y = 4.5 NEW_LINE print ( \" Value \u2581 of \u2581 x \u2581 at \u2581 y \u2581 = \u2581 4.5 \u2581 : \" , round ( inv_interpolate ( d , n , y ) , 5 ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1287_A", "sol": 0, "python_code": "I = input\nexec ( int ( I ( ) ) * \"I();print(max(0,0,*map(len,I().split('A')[1:])));\" )\n", "python_code_tokenized": "I = input NEW_LINE exec ( int ( I ( ) ) * \" I ( ) ; print ( max ( 0,0 , * map ( len , I ( ) . split ( ' A ' ) [ 1 : ] ) ) ) ; \" ) NEW_LINE"}
{"id": "geeksforgeeks_5168_A", "sol": 0, "python_code": "def myCopy ( s1 , s2 ) :\n    for i in range ( len ( s1 ) ) :\n        s2 [ i ] = s1 [ i ] ;\ns1 = \"GEEKSFORGEEKS\" ;\ns2 = [ '' ] * ( len ( s1 ) ) ;\nmyCopy ( s1 , s2 ) ;\nprint ( ( \"\".join ( s2 ) ) ) ;\n", "python_code_tokenized": "def myCopy ( s1 , s2 ) : NEW_LINE INDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT s2 [ i ] = s1 [ i ] ; NEW_LINE DEDENT DEDENT s1 = \" GEEKSFORGEEKS \" ; NEW_LINE s2 = [ ' ' ] * ( len ( s1 ) ) ; NEW_LINE myCopy ( s1 , s2 ) ; NEW_LINE print ( ( \" \" . join ( s2 ) ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_944_A", "sol": 0, "python_code": "from math import gcd as __gcd\nmaxLen = 30\nseg = [ 0 for i in range ( 3 * maxLen ) ]\ndef build ( l , r , inn , arr ) :\n    if ( l == r ) :\n        seg [ inn ] = arr [ l ]\n        return seg [ inn ]\n    mid = ( l + r ) // 2\n    seg [ inn ] = __gcd ( build ( l , mid , 2 * inn + 1 , arr ) , build ( mid + 1 , r , 2 * inn + 2 , arr ) )\n    return seg [ inn ]\ndef query ( l , r , l1 , r1 , inn ) :\n    if ( l1 <= l and r <= r1 ) :\n        return seg [ inn ]\n    if ( l > r1 or r < l1 ) :\n        return 0\n    mid = ( l + r ) // 2\n    x = __gcd ( query ( l , mid , l1 , r1 , 2 * inn + 1 ) , query ( mid + 1 , r , l1 , r1 , 2 * inn + 2 ) )\n    return x\ndef findLen ( arr , n ) :\n    build ( 0 , n - 1 , 0 , arr )\n    i = 0\n    j = 0\n    ans = 10 ** 9\n    while ( i < n ) :\n        while ( j < n and query ( 0 , n - 1 , i , j , 0 ) != 1 ) :\n            j += 1\n        if ( j == n ) :\n            break ;\n        ans = minn ( ( j - i + 1 ) , ans )\n        i += 1\n        j = max ( j , i )\n    if ( ans == 10 ** 9 ) :\n        return - 1\n    else :\n        return ans\narr = [ 2 , 2 , 2 ]\nn = len ( arr )\nprint ( findLen ( arr , n ) )\n", "python_code_tokenized": "from math import gcd as __gcd NEW_LINE maxLen = 30 NEW_LINE seg = [ 0 for i in range ( 3 * maxLen ) ] NEW_LINE def build ( l , r , inn , arr ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT seg [ inn ] = arr [ l ] NEW_LINE return seg [ inn ] NEW_LINE DEDENT mid = ( l + r ) // 2 NEW_LINE seg [ inn ] = __gcd ( build ( l , mid , 2 * inn + 1 , arr ) , build ( mid + 1 , r , 2 * inn + 2 , arr ) ) NEW_LINE return seg [ inn ] NEW_LINE DEDENT def query ( l , r , l1 , r1 , inn ) : NEW_LINE INDENT if ( l1 <= l and r <= r1 ) : NEW_LINE INDENT return seg [ inn ] NEW_LINE DEDENT if ( l > r1 or r < l1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT mid = ( l + r ) // 2 NEW_LINE x = __gcd ( query ( l , mid , l1 , r1 , 2 * inn + 1 ) , query ( mid + 1 , r , l1 , r1 , 2 * inn + 2 ) ) NEW_LINE return x NEW_LINE DEDENT def findLen ( arr , n ) : NEW_LINE INDENT build ( 0 , n - 1 , 0 , arr ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE ans = 10 ** 9 NEW_LINE while ( i < n ) : NEW_LINE INDENT while ( j < n and query ( 0 , n - 1 , i , j , 0 ) != 1 ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT ans = minn ( ( j - i + 1 ) , ans ) NEW_LINE i += 1 NEW_LINE j = max ( j , i ) NEW_LINE DEDENT if ( ans == 10 ** 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT arr = [ 2 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findLen ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_954_A", "sol": 0, "python_code": "l = int ( input ( ) )\nch = input ( )\na = ch.count ( \"UR\" )\nif ( a > 1 ) :\n    ch = ch.replace ( \"UR\" , \"\" )\nelse :\n    ch = ch.replace ( \"UR\" , \"\" )\nb = ch.count ( \"RU\" )\nprint ( l - a - b )\n", "python_code_tokenized": "l = int ( input ( ) ) NEW_LINE ch = input ( ) NEW_LINE a = ch . count ( \" UR \" ) NEW_LINE if ( a > 1 ) : NEW_LINE INDENT ch = ch . replace ( \" UR \" , \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT ch = ch . replace ( \" UR \" , \" \" ) NEW_LINE DEDENT b = ch . count ( \" RU \" ) NEW_LINE print ( l - a - b ) NEW_LINE"}
{"id": "aizu_p02390_A", "sol": 0, "python_code": "s = int ( input ( ) )\nh = int ( s / 3600 )\ns = s - 3600 * h\nm = int ( s / 60 )\ns = s - 60 * m\nprint ( str ( h ) + \":\" + str ( m ) + \":\" + str ( s ) )\n", "python_code_tokenized": "s = int ( input ( ) ) NEW_LINE h = int ( s / 3600 ) NEW_LINE s = s - 3600 * h NEW_LINE m = int ( s / 60 ) NEW_LINE s = s - 60 * m NEW_LINE print ( str ( h ) + \" : \" + str ( m ) + \" : \" + str ( s ) ) NEW_LINE"}
{"id": "geeksforgeeks_2789_A", "sol": 0, "python_code": "def printNumberWithDR ( k , d ) :\n    if d == 0 and k != 1 :\n        print ( - 1 , end = \"\" )\n    else :\n        print ( d , end = \"\" )\n        k -= 1\n        while k :\n            print ( 0 , end = \"\" )\n            k -= 1\nif __name__ == \"__main__\" :\n    k , d = 4 , 4\n    printNumberWithDR ( k , d )\n", "python_code_tokenized": "def printNumberWithDR ( k , d ) : NEW_LINE INDENT if d == 0 and k != 1 : NEW_LINE INDENT print ( - 1 , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d , end = \" \" ) NEW_LINE k -= 1 NEW_LINE while k : NEW_LINE INDENT print ( 0 , end = \" \" ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k , d = 4 , 4 NEW_LINE printNumberWithDR ( k , d ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC165_E", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nif ( m & 1 ) :\n    if n & 1 :\n        left_1 = 1\n        right_1 = n // 2\n        for _ in range ( m // 2 ) :\n            print ( left_1 , right_1 )\n            left_1 += 1\n            right_1 -= 1\n        left_2 = ( n // 2 ) + 1\n        right_2 = n\n        for _ in range ( m // 2 , m ) :\n            print ( left_2 , right_2 )\n            left_2 += 1\n            right_2 -= 1\n    else :\n        left_1 = 1\n        right_1 = n // 2 - 1\n        for _ in range ( m // 2 ) :\n            print ( left_1 , right_1 )\n            left_1 += 1\n            right_1 -= 1\n        left_2 = ( n // 2 ) + 1\n        right_2 = n\n        for _ in range ( m // 2 , m ) :\n            print ( left_2 , right_2 )\n            left_2 += 1\n            right_2 -= 1\nelse :\n    if n & 1 :\n        left_1 = 1\n        right_1 = n // 2\n        for _ in range ( m // 2 ) :\n            print ( left_1 , right_1 )\n            left_1 += 1\n            right_1 -= 1\n        left_2 = ( n // 2 ) + 1\n        right_2 = n\n        for _ in range ( m // 2 , m ) :\n            print ( left_2 , right_2 )\n            left_2 += 1\n            right_2 -= 1\n    else :\n        left_1 = 1\n        right_1 = n // 2 - 1\n        for _ in range ( m // 2 ) :\n            print ( left_1 , right_1 )\n            left_1 += 1\n            right_1 -= 1\n        left_2 = ( n // 2 ) + 1\n        right_2 = n\n        for _ in range ( m // 2 , m ) :\n            print ( left_2 , right_2 )\n            left_2 += 1\n            right_2 -= 1\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if ( m & 1 ) : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT left_1 = 1 NEW_LINE right_1 = n // 2 NEW_LINE for _ in range ( m // 2 ) : NEW_LINE INDENT print ( left_1 , right_1 ) NEW_LINE left_1 += 1 NEW_LINE right_1 -= 1 NEW_LINE DEDENT left_2 = ( n // 2 ) + 1 NEW_LINE right_2 = n NEW_LINE for _ in range ( m // 2 , m ) : NEW_LINE INDENT print ( left_2 , right_2 ) NEW_LINE left_2 += 1 NEW_LINE right_2 -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT left_1 = 1 NEW_LINE right_1 = n // 2 - 1 NEW_LINE for _ in range ( m // 2 ) : NEW_LINE INDENT print ( left_1 , right_1 ) NEW_LINE left_1 += 1 NEW_LINE right_1 -= 1 NEW_LINE DEDENT left_2 = ( n // 2 ) + 1 NEW_LINE right_2 = n NEW_LINE for _ in range ( m // 2 , m ) : NEW_LINE INDENT print ( left_2 , right_2 ) NEW_LINE left_2 += 1 NEW_LINE right_2 -= 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT left_1 = 1 NEW_LINE right_1 = n // 2 NEW_LINE for _ in range ( m // 2 ) : NEW_LINE INDENT print ( left_1 , right_1 ) NEW_LINE left_1 += 1 NEW_LINE right_1 -= 1 NEW_LINE DEDENT left_2 = ( n // 2 ) + 1 NEW_LINE right_2 = n NEW_LINE for _ in range ( m // 2 , m ) : NEW_LINE INDENT print ( left_2 , right_2 ) NEW_LINE left_2 += 1 NEW_LINE right_2 -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT left_1 = 1 NEW_LINE right_1 = n // 2 - 1 NEW_LINE for _ in range ( m // 2 ) : NEW_LINE INDENT print ( left_1 , right_1 ) NEW_LINE left_1 += 1 NEW_LINE right_1 -= 1 NEW_LINE DEDENT left_2 = ( n // 2 ) + 1 NEW_LINE right_2 = n NEW_LINE for _ in range ( m // 2 , m ) : NEW_LINE INDENT print ( left_2 , right_2 ) NEW_LINE left_2 += 1 NEW_LINE right_2 -= 1 NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_3300_A", "sol": 0, "python_code": "import sys\ndef maxSubArraySum ( a , size ) :\n    max_so_far = - ( sys.maxsize - 1 ) ;\n    max_ending_here = 0 ;\n    for i in range ( size ) :\n        max_ending_here = max_ending_here + a [ i ] ;\n        if ( max_so_far < max_ending_here ) :\n            max_so_far = max_ending_here ;\n        if ( max_ending_here < 0 ) :\n            max_ending_here = 0 ;\n    return max_so_far ;\ndef minimizedSum ( a , n , K ) :\n    sum = maxSubArraySum ( a , n ) ;\n    totalSum = 0 ;\n    for i in range ( n ) :\n        totalSum += a [ i ] ;\n    if ( sum < 0 ) :\n        return totalSum ;\n    totalSum = totalSum - sum + sum / K ;\n    return totalSum ;\nif __name__ == \"__main__\" :\n    a = [ 1 , - 2 , 3 ] ;\n    n = len ( a ) ;\n    K = 2 ;\n    print ( minimizedSum ( a , n , K ) ) ;\n", "python_code_tokenized": "import sys NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - ( sys . maxsize - 1 ) ; NEW_LINE max_ending_here = 0 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] ; NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here ; NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 ; NEW_LINE DEDENT DEDENT return max_so_far ; NEW_LINE DEDENT def minimizedSum ( a , n , K ) : NEW_LINE INDENT sum = maxSubArraySum ( a , n ) ; NEW_LINE totalSum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT totalSum += a [ i ] ; NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT return totalSum ; NEW_LINE DEDENT totalSum = totalSum - sum + sum / K ; NEW_LINE return totalSum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , - 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE K = 2 ; NEW_LINE print ( minimizedSum ( a , n , K ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_377_A", "sol": 0, "python_code": "def findSumPairs ( a , n ) :\n    mpp = { i : 0 for i in range ( 21 ) }\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n , 1 ) :\n            mpp [ a [ i ] + a [ j ] ] += 1\n    occur = 0\n    for key , value in mpp.items ( ) :\n        if ( value > occur ) :\n            occur = value\n    for key , value in mpp.items ( ) :\n        if ( value == occur ) :\n            print ( key )\nif __name__ == '__main__' :\n    a = [ 1 , 8 , 3 , 11 , 4 , 9 , 2 , 7 ]\n    n = len ( a )\n    findSumPairs ( a , n )\n", "python_code_tokenized": "def findSumPairs ( a , n ) : NEW_LINE INDENT mpp = { i : 0 for i in range ( 21 ) } NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT mpp [ a [ i ] + a [ j ] ] += 1 NEW_LINE DEDENT DEDENT occur = 0 NEW_LINE for key , value in mpp . items ( ) : NEW_LINE INDENT if ( value > occur ) : NEW_LINE INDENT occur = value NEW_LINE DEDENT DEDENT for key , value in mpp . items ( ) : NEW_LINE INDENT if ( value == occur ) : NEW_LINE INDENT print ( key ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 8 , 3 , 11 , 4 , 9 , 2 , 7 ] NEW_LINE n = len ( a ) NEW_LINE findSumPairs ( a , n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2305_A", "sol": 0, "python_code": "def distinctDigitSum ( n ) :\n    used = [ False ] * 10\n    sum = 0\n    while ( n > 0 ) :\n        digit = n % 10\n        if ( not used [ digit ] ) :\n            used [ digit ] = True\n            sum += digit\n        n = n // 10\n    return sum\ndef checkSum ( m , n ) :\n    sumM = distinctDigitSum ( m )\n    sumN = distinctDigitSum ( n )\n    if ( sumM == sumN ) :\n        return \"YES\"\n    return \"NO\"\nif __name__ == \"__main__\" :\n    m = 2452\n    n = 9222\n    print ( checkSum ( m , n ) )\n", "python_code_tokenized": "def distinctDigitSum ( n ) : NEW_LINE INDENT used = [ False ] * 10 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( not used [ digit ] ) : NEW_LINE INDENT used [ digit ] = True NEW_LINE sum += digit NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def checkSum ( m , n ) : NEW_LINE INDENT sumM = distinctDigitSum ( m ) NEW_LINE sumN = distinctDigitSum ( n ) NEW_LINE if ( sumM == sumN ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT return \" NO \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 2452 NEW_LINE n = 9222 NEW_LINE print ( checkSum ( m , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1213_A", "sol": 0, "python_code": "def circlearea ( a , b ) :\n    if ( a < 0 or b < 0 ) :\n        return - 1\n    A = ( ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) )\n    return A\nif __name__ == \"__main__\" :\n    a = 8\n    b = 10\n    print ( circlearea ( a , b ) )\n", "python_code_tokenized": "def circlearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ) NEW_LINE return A NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 8 NEW_LINE b = 10 NEW_LINE print ( circlearea ( a , b ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC064_A", "sol": 0, "python_code": "r , g , b = map ( int , input ( ).split ( ) )\nif ( 2 * g + b ) % 4 == 0 :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "r , g , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( 2 * g + b ) % 4 == 0 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3844_A", "sol": 0, "python_code": "def primeCount ( arr , n ) :\n    max_val = max ( arr )\n    prime = [ True ] * ( max_val + 1 )\n    prime [ 0 ] = prime [ 1 ] = False\n    p = 2\n    while p * p <= max_val :\n        if prime [ p ] == True :\n            for i in range ( p * 2 , max_val + 1 , p ) :\n                prime [ i ] = False\n        p += 1\n    count = 0\n    for i in range ( 0 , n ) :\n        if prime [ arr [ i ] ] :\n            count += 1\n    return count\ndef getPrefixArray ( arr , n , pre ) :\n    pre [ 0 ] = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        pre [ i ] = pre [ i - 1 ] + arr [ i ]\nif __name__ == \"__main__\" :\n    arr = [ 1 , 4 , 8 , 4 ]\n    n = len ( arr )\n    pre = [ None ] * n\n    getPrefixArray ( arr , n , pre )\n    print ( primeCount ( pre , n ) )\n", "python_code_tokenized": "def primeCount ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def getPrefixArray ( arr , n , pre ) : NEW_LINE INDENT pre [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 4 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE pre = [ None ] * n NEW_LINE getPrefixArray ( arr , n , pre ) NEW_LINE print ( primeCount ( pre , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2514_A", "sol": 0, "python_code": "def sumofseries ( n ) :\n    res = 0\n    for i in range ( 1 , n + 1 ) :\n        res += ( i ) * ( i + 1 ) * ( i + 2 )\n    return res\nprint ( sumofseries ( 3 ) )\n", "python_code_tokenized": "def sumofseries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += ( i ) * ( i + 1 ) * ( i + 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( sumofseries ( 3 ) ) NEW_LINE"}
{"id": "geeksforgeeks_3521_A", "sol": 0, "python_code": "def SumF ( S , n ) :\n    sum = 0\n    for i in range ( n ) :\n        sum = sum + ( S [ i ] * pow ( 2 , n - i - 1 ) )\n    return sum\ndef SumL ( S , n ) :\n    sum = 0\n    for i in range ( n ) :\n        sum = sum + ( S [ i ] * pow ( 2 , i ) )\n    return sum\ndef sumSetDiff ( S , n ) :\n    return SumL ( S , n ) - SumF ( S , n )\nn = 4\nS = [ 5 , 2 , 9 , 6 ]\nprint ( sumSetDiff ( S , n ) )\n", "python_code_tokenized": "def SumF ( S , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( S [ i ] * pow ( 2 , n - i - 1 ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def SumL ( S , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( S [ i ] * pow ( 2 , i ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def sumSetDiff ( S , n ) : NEW_LINE INDENT return SumL ( S , n ) - SumF ( S , n ) NEW_LINE DEDENT n = 4 NEW_LINE S = [ 5 , 2 , 9 , 6 ] NEW_LINE print ( sumSetDiff ( S , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1898_A", "sol": 0, "python_code": "def firstEven ( arr , n ) :\n    map1 = { }\n    for i in range ( 0 , n ) :\n        if arr [ i ] not in map1 :\n            map1 [ arr [ i ] ] = False\n        else :\n            map1 [ arr [ i ] ] = not map1 [ arr [ i ] ]\n    for j in range ( 0 , n ) :\n        if map1 [ arr [ j ] ] == True :\n            break\n    return arr [ j ]\nif __name__ == \"__main__\" :\n    arr = [ 2 , 4 , 6 , 8 , 1 , 6 ]\n    print ( firstEven ( arr , 6 ) )\n", "python_code_tokenized": "def firstEven ( arr , n ) : NEW_LINE INDENT map1 = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] not in map1 : NEW_LINE INDENT map1 [ arr [ i ] ] = False NEW_LINE DEDENT else : NEW_LINE INDENT map1 [ arr [ i ] ] = not map1 [ arr [ i ] ] NEW_LINE DEDENT DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT if map1 [ arr [ j ] ] == True : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return arr [ j ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 1 , 6 ] NEW_LINE print ( firstEven ( arr , 6 ) ) NEW_LINE DEDENT"}
{"id": "codeforces_215_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nm = int ( input ( ) )\nb = list ( map ( int , input ( ).split ( ) ) )\nd = { }\nfor i in range ( m ) :\n    for j in range ( n ) :\n        if b [ i ] % a [ j ] == 0 :\n            div = b [ i ] // a [ j ]\n            if div in d : d [ div ] += 1\n            else : d [ div ] = 1\nres = max ( d )\nprint ( d [ res ] )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if b [ i ] % a [ j ] == 0 : NEW_LINE INDENT div = b [ i ] // a [ j ] NEW_LINE if div in d : d [ div ] += 1 NEW_LINE else : d [ div ] = 1 NEW_LINE DEDENT DEDENT DEDENT res = max ( d ) NEW_LINE print ( d [ res ] ) NEW_LINE"}
{"id": "codeforces_633_A", "sol": 0, "python_code": "a , b , c = input ( ).split ( )\na = int ( a )\nb = int ( b )\nc = int ( c )\nf = 0\nfor i in range ( 10000 ) :\n    ai = a * i\n    if ai > c :\n        break\n    remaining = c - a * i\n    if remaining % b == 0 :\n        print ( \"YES\" )\n        f = 1\n        break\nif f == 0 :\n    print ( \"NO\" )\n", "python_code_tokenized": "a , b , c = input ( ) . split ( ) NEW_LINE a = int ( a ) NEW_LINE b = int ( b ) NEW_LINE c = int ( c ) NEW_LINE f = 0 NEW_LINE for i in range ( 10000 ) : NEW_LINE INDENT ai = a * i NEW_LINE if ai > c : NEW_LINE INDENT break NEW_LINE DEDENT remaining = c - a * i NEW_LINE if remaining % b == 0 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if f == 0 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4382_A", "sol": 0, "python_code": "def PossibleValues ( b , x , n ) :\n    leastdivisible = int ( b / x + 1 ) * x\n    flag = 1\n    while ( leastdivisible <= n ) :\n        if ( leastdivisible - b >= 1 ) :\n            print ( leastdivisible - b , end = \" \" )\n            leastdivisible += x\n            flag = 0\n        else :\n            break\n    if ( flag != 0 ) :\n        print ( - 1 )\nif __name__ == '__main__' :\n    b = 10\n    x = 6\n    n = 40\n    PossibleValues ( b , x , n )\n", "python_code_tokenized": "def PossibleValues ( b , x , n ) : NEW_LINE INDENT leastdivisible = int ( b / x + 1 ) * x NEW_LINE flag = 1 NEW_LINE while ( leastdivisible <= n ) : NEW_LINE INDENT if ( leastdivisible - b >= 1 ) : NEW_LINE INDENT print ( leastdivisible - b , end = \" \u2581 \" ) NEW_LINE leastdivisible += x NEW_LINE flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( flag != 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT b = 10 NEW_LINE x = 6 NEW_LINE n = 40 NEW_LINE PossibleValues ( b , x , n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4849_A", "sol": 0, "python_code": "MAX = 3000 ;\ndef smartNumber ( n ) :\n    primes = [ 0 ] * MAX ;\n    result = [ ] ;\n    for i in range ( 2 , MAX ) :\n        if ( primes [ i ] == 0 ) :\n            primes [ i ] = 1 ;\n            j = i * 2 ;\n            while ( j < MAX ) :\n                primes [ j ] -= 1 ;\n                if ( ( primes [ j ] + 3 ) == 0 ) :\n                    result.append ( j ) ;\n                j = j + i ;\n    result.sort ( ) ;\n    return result [ n - 1 ] ;\nn = 50 ;\nprint ( smartNumber ( n ) ) ;\n", "python_code_tokenized": "MAX = 3000 ; NEW_LINE def smartNumber ( n ) : NEW_LINE INDENT primes = [ 0 ] * MAX ; NEW_LINE result = [ ] ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( primes [ i ] == 0 ) : NEW_LINE INDENT primes [ i ] = 1 ; NEW_LINE j = i * 2 ; NEW_LINE while ( j < MAX ) : NEW_LINE INDENT primes [ j ] -= 1 ; NEW_LINE if ( ( primes [ j ] + 3 ) == 0 ) : NEW_LINE INDENT result . append ( j ) ; NEW_LINE DEDENT j = j + i ; NEW_LINE DEDENT DEDENT DEDENT result . sort ( ) ; NEW_LINE return result [ n - 1 ] ; NEW_LINE DEDENT n = 50 ; NEW_LINE print ( smartNumber ( n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_234_A", "sol": 0, "python_code": "def maxProdSum ( arr , n ) :\n    leftArraySum = 0 ;\n    maxProduct = 0 ;\n    for i in range ( n ) :\n        leftArraySum += arr [ i ] ;\n        rightArraySum = 0 ;\n        for j in range ( i + 1 , n ) :\n            rightArraySum += arr [ j ] ;\n        k = leftArraySum * rightArraySum ;\n        if ( k > maxProduct ) :\n            maxProduct = k ;\n    return maxProduct ;\nif __name__ == '__main__' :\n    arr = [ 4 , 10 , 1 , 7 , 2 , 9 ] ;\n    n = len ( arr ) ;\n    print ( maxProdSum ( arr , n ) ) ;\n", "python_code_tokenized": "def maxProdSum ( arr , n ) : NEW_LINE INDENT leftArraySum = 0 ; NEW_LINE maxProduct = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT leftArraySum += arr [ i ] ; NEW_LINE rightArraySum = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT rightArraySum += arr [ j ] ; NEW_LINE DEDENT k = leftArraySum * rightArraySum ; NEW_LINE if ( k > maxProduct ) : NEW_LINE INDENT maxProduct = k ; NEW_LINE DEDENT DEDENT return maxProduct ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 10 , 1 , 7 , 2 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxProdSum ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "atcoder_ARC083_B", "sol": 0, "python_code": "N = int ( input ( ) )\nimport sys\ninput = sys.stdin.readline\nA = [ [ int ( j ) for j in input ( ).split ( ) ] for _ in range ( N ) ]\nans = 0\nbridge = [ [ False ] * ( N ) for i in range ( N ) ]\nfor k in range ( N ) :\n    for i in range ( N ) :\n        for j in range ( N ) :\n            if i >= j : continue\n            if A [ i ] [ j ] > A [ i ] [ k ] + A [ k ] [ j ] :\n                print ( - 1 )\n                exit ( 0 )\nfor i in range ( N ) :\n    for j in range ( N ) :\n        if i >= j : continue\n        if all ( A [ i ] [ j ] < A [ i ] [ k ] + A [ k ] [ j ] for k in range ( N ) if k != i and k != j ) :\n            if not bridge [ i ] [ j ] :\n                ans += A [ i ] [ j ]\n                bridge [ i ] [ j ] = True\nprint ( ans )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE import sys NEW_LINE input = sys . stdin . readline NEW_LINE A = [ [ int ( j ) for j in input ( ) . split ( ) ] for _ in range ( N ) ] NEW_LINE ans = 0 NEW_LINE bridge = [ [ False ] * ( N ) for i in range ( N ) ] NEW_LINE for k in range ( N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if i >= j : continue NEW_LINE if A [ i ] [ j ] > A [ i ] [ k ] + A [ k ] [ j ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if i >= j : continue NEW_LINE if all ( A [ i ] [ j ] < A [ i ] [ k ] + A [ k ] [ j ] for k in range ( N ) if k != i and k != j ) : NEW_LINE INDENT if not bridge [ i ] [ j ] : NEW_LINE INDENT ans += A [ i ] [ j ] NEW_LINE bridge [ i ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_4532_A", "sol": 0, "python_code": "def canMake ( s ) :\n    o = 0 ; z = 0 ;\n    for i in range ( len ( s ) ) :\n        if ( ord ( s [ i ] ) - ord ( '0' ) == 1 ) :\n            o += 1 ;\n        else :\n            z += 1 ;\n    if ( o % 2 == 1 and z % 2 == 1 ) :\n        return \"NO\" ;\n    else :\n        return \"YES\" ;\nif __name__ == \"__main__\" :\n    s = \"01011\" ;\n    print ( canMake ( s ) ) ;\n", "python_code_tokenized": "def canMake ( s ) : NEW_LINE INDENT o = 0 ; z = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) == 1 ) : NEW_LINE INDENT o += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT z += 1 ; NEW_LINE DEDENT DEDENT if ( o % 2 == 1 and z % 2 == 1 ) : NEW_LINE INDENT return \" NO \" ; NEW_LINE DEDENT else : NEW_LINE INDENT return \" YES \" ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"01011\" ; NEW_LINE print ( canMake ( s ) ) ; NEW_LINE DEDENT"}
{"id": "atcoder_ABC127_F", "sol": 0, "python_code": "def f_absolute_minima ( Q , Queries , INF = float ( 'inf' ) ) :\n    import heapq\n    left , right = [ ] , [ ]\n    current_ans , current_median = 0 , 0\n    bias_total = 0\n    heapq.heappush ( left , INF )\n    heapq.heappush ( right , INF )\n    ans = [ ]\n    for query in Queries :\n        if query [ 0 ] == 1 :\n            _ , a , b = query\n            bias_total += b\n            last_left , last_right = - left [ 0 ] , right [ 0 ]\n            heapq.heappush ( left , - a )\n            heapq.heappush ( right , a )\n            heapq.heappush ( left , - heapq.heappop ( right ) )\n            heapq.heappush ( right , - heapq.heappop ( left ) )\n            current_median = - left [ 0 ]\n            if a < last_left or last_right < a :\n                current_ans += min ( abs ( last_right - a ) , abs ( last_left - a ) )\n        else :\n            ans.append ( ( current_median , current_ans + bias_total ) )\n    return '\\n'.join ( ' '.join ( map ( str , row ) ) for row in ans )\nQ = int ( input ( ) )\nQueries = [ [ int ( i ) for i in input ( ).split ( ) ] for j in range ( Q ) ]\nprint ( f_absolute_minima ( Q , Queries ) )\n", "python_code_tokenized": "def f_absolute_minima ( Q , Queries , INF = float ( ' inf ' ) ) : NEW_LINE INDENT import heapq NEW_LINE left , right = [ ] , [ ] NEW_LINE current_ans , current_median = 0 , 0 NEW_LINE bias_total = 0 NEW_LINE heapq . heappush ( left , INF ) NEW_LINE heapq . heappush ( right , INF ) NEW_LINE ans = [ ] NEW_LINE for query in Queries : NEW_LINE INDENT if query [ 0 ] == 1 : NEW_LINE INDENT _ , a , b = query NEW_LINE bias_total += b NEW_LINE last_left , last_right = - left [ 0 ] , right [ 0 ] NEW_LINE heapq . heappush ( left , - a ) NEW_LINE heapq . heappush ( right , a ) NEW_LINE heapq . heappush ( left , - heapq . heappop ( right ) ) NEW_LINE heapq . heappush ( right , - heapq . heappop ( left ) ) NEW_LINE current_median = - left [ 0 ] NEW_LINE if a < last_left or last_right < a : NEW_LINE INDENT current_ans += min ( abs ( last_right - a ) , abs ( last_left - a ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans . append ( ( current_median , current_ans + bias_total ) ) NEW_LINE DEDENT DEDENT return ' \\n ' . join ( ' \u2581 ' . join ( map ( str , row ) ) for row in ans ) NEW_LINE DEDENT Q = int ( input ( ) ) NEW_LINE Queries = [ [ int ( i ) for i in input ( ) . split ( ) ] for j in range ( Q ) ] NEW_LINE print ( f_absolute_minima ( Q , Queries ) ) NEW_LINE"}
{"id": "codeforces_263_A", "sol": 0, "python_code": "matrix = [ input ( ).split ( ) for _ in range ( 5 ) ]\nrow = 0\ncolumn = 0\nfor i in range ( 5 ) :\n    for j in range ( 5 ) :\n        if matrix [ i ] [ j ] == '1' :\n            row = i + 1\n            column = j + 1\nrow_ = 3\ncolumn_ = 3\nsteps = 0\nwhile row_ != row :\n    if row_ > row :\n        row += 1\n    else :\n        row -= 1\n    steps += 1\nwhile column_ != column :\n    if column_ > column :\n        column += 1\n    else :\n        column -= 1\n    steps += 1\nprint ( steps )\n", "python_code_tokenized": "matrix = [ input ( ) . split ( ) for _ in range ( 5 ) ] NEW_LINE row = 0 NEW_LINE column = 0 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT for j in range ( 5 ) : NEW_LINE INDENT if matrix [ i ] [ j ] == '1' : NEW_LINE INDENT row = i + 1 NEW_LINE column = j + 1 NEW_LINE DEDENT DEDENT DEDENT row_ = 3 NEW_LINE column_ = 3 NEW_LINE steps = 0 NEW_LINE while row_ != row : NEW_LINE INDENT if row_ > row : NEW_LINE INDENT row += 1 NEW_LINE DEDENT else : NEW_LINE INDENT row -= 1 NEW_LINE DEDENT steps += 1 NEW_LINE DEDENT while column_ != column : NEW_LINE INDENT if column_ > column : NEW_LINE INDENT column += 1 NEW_LINE DEDENT else : NEW_LINE INDENT column -= 1 NEW_LINE DEDENT steps += 1 NEW_LINE DEDENT print ( steps ) NEW_LINE"}
{"id": "geeksforgeeks_803_A", "sol": 0, "python_code": "a = [ 1 , 2 , 3 , 4 , 5 ] ;\nfor i in range ( 5 ) :\n    print ( a [ i ] , end = \" \" ) ;\n", "python_code_tokenized": "a = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT"}
{"id": "codeforces_4_A", "sol": 0, "python_code": "w = int ( input ( ) )\nif w % 2 == 0 and w > 2 :\n    print ( \"YES\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "w = int ( input ( ) ) NEW_LINE if w % 2 == 0 and w > 2 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2191_A", "sol": 0, "python_code": "def digitSum ( n ) :\n    Sum = 0\n    while n > 0 :\n        Sum += n % 10\n        n = n // 10\n    return Sum\ndef totalPairs ( arr1 , arr2 , n , m ) :\n    s = set ( )\n    for i in range ( 0 , n ) :\n        for j in range ( 0 , m ) :\n            if digitSum ( arr1 [ i ] ) == digitSum ( arr2 [ j ] ) :\n                if arr1 [ i ] < arr2 [ j ] :\n                    s.add ( ( arr1 [ i ] , arr2 [ j ] ) )\n                else :\n                    s.add ( ( arr2 [ j ] , arr1 [ i ] ) )\n    return len ( s )\nif __name__ == \"__main__\" :\n    arr1 = [ 100 , 3 , 7 , 50 ]\n    arr2 = [ 5 , 1 , 10 , 4 ]\n    n = len ( arr1 )\n    m = len ( arr2 )\n    print ( totalPairs ( arr1 , arr2 , n , m ) )\n", "python_code_tokenized": "def digitSum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT Sum += n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return Sum NEW_LINE DEDENT def totalPairs ( arr1 , arr2 , n , m ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if digitSum ( arr1 [ i ] ) == digitSum ( arr2 [ j ] ) : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT s . add ( ( arr1 [ i ] , arr2 [ j ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( ( arr2 [ j ] , arr1 [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( s ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 100 , 3 , 7 , 50 ] NEW_LINE arr2 = [ 5 , 1 , 10 , 4 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( totalPairs ( arr1 , arr2 , n , m ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4748_A", "sol": 0, "python_code": "def totalPairs ( arr1 , arr2 , K , n , m ) :\n    s = { }\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if ( arr1 [ i ] > arr2 [ j ] ) :\n                if ( arr1 [ i ] % arr2 [ j ] == K ) :\n                    s [ ( arr1 [ i ] , arr2 [ j ] ) ] = 1\n            else :\n                if ( arr2 [ j ] % arr1 [ i ] == K ) :\n                    s [ ( arr2 [ j ] , arr1 [ i ] ) ] = 1\n    return len ( s )\narr1 = [ 8 , 3 , 7 , 50 ]\narr2 = [ 5 , 1 , 10 , 4 ]\nK = 3\nn = len ( arr1 )\nm = len ( arr2 )\nprint ( totalPairs ( arr1 , arr2 , K , n , m ) )\n", "python_code_tokenized": "def totalPairs ( arr1 , arr2 , K , n , m ) : NEW_LINE INDENT s = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT if ( arr1 [ i ] % arr2 [ j ] == K ) : NEW_LINE INDENT s [ ( arr1 [ i ] , arr2 [ j ] ) ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr2 [ j ] % arr1 [ i ] == K ) : NEW_LINE INDENT s [ ( arr2 [ j ] , arr1 [ i ] ) ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( s ) NEW_LINE DEDENT arr1 = [ 8 , 3 , 7 , 50 ] NEW_LINE arr2 = [ 5 , 1 , 10 , 4 ] NEW_LINE K = 3 NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( totalPairs ( arr1 , arr2 , K , n , m ) ) NEW_LINE"}
{"id": "geeksforgeeks_4908_A", "sol": 0, "python_code": "SIZE = 26\nfrom math import sqrt\ndef SieveOfEratosthenes ( prime , p_size ) :\n    prime [ 0 ] = False\n    prime [ 1 ] = False\n    for p in range ( 2 , int ( sqrt ( p_size ) ) , 1 ) :\n        if ( prime [ p ] ) :\n            for i in range ( p * 2 , p_size , p ) :\n                prime [ i ] = False\ndef printChar ( str , n ) :\n    prime = [ True for i in range ( n + 1 ) ]\n    SieveOfEratosthenes ( prime , len ( str ) + 1 )\n    freq = [ 0 for i in range ( SIZE ) ]\n    for i in range ( n ) :\n        freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1\n    for i in range ( n ) :\n        if ( prime [ freq [ ord ( str [ i ] ) - ord ( 'a' ) ] ] ) :\n            print ( str [ i ] , end = \"\" )\nif __name__ == '__main__' :\n    str = \"geeksforgeeks\"\n    n = len ( str )\n    printChar ( str , n )\n", "python_code_tokenized": "SIZE = 26 NEW_LINE from math import sqrt NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printChar ( str , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , len ( str ) + 1 ) NEW_LINE freq = [ 0 for i in range ( SIZE ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prime [ freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] ] ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE DEDENT"}
{"id": "codeforces_446_A", "sol": 0, "python_code": "n , b , i , ma = int ( input ( ) ) , [ ] , 0 , 0\na = list ( map ( int , input ( ).split ( ) ) )\nwhile i < n :\n    j = i\n    while j < n - 1 and a [ j ] < a [ j + 1 ] :\n        j += 1\n    b.append ( [ i , j ] )\n    ma , i = max ( j - i + 1 + ( i != 0 or j != n - 1 ) , ma ) , j + 1\nfor i in range ( len ( b ) - 1 ) :\n    if b [ i + 1 ] [ 0 ] - b [ i ] [ 1 ] == 2 and a [ b [ i + 1 ] [ 0 ] ] > a [ b [ i ] [ 1 ] ] + 1 :\n        ma = max ( ma , b [ i + 1 ] [ 1 ] - b [ i ] [ 0 ] + 1 )\n    elif b [ i + 1 ] [ 0 ] - b [ i ] [ 1 ] == 1 and ( b [ i + 1 ] [ 0 ] + 1 < n and a [ b [ i + 1 ] [ 0 ] + 1 ] > a [ b [ i ] [ 1 ] ] + 1 or b [ i ] [ 1 ] - 1 >= 0 and a [ b [ i ] [ 1 ] - 1 ] + 1 < a [ b [ i + 1 ] [ 0 ] ] ) :\n        ma = max ( ma , b [ i + 1 ] [ 1 ] - b [ i ] [ 0 ] + 1 )\nprint ( ma )\n", "python_code_tokenized": "n , b , i , ma = int ( input ( ) ) , [ ] , 0 , 0 NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE while i < n : NEW_LINE INDENT j = i NEW_LINE while j < n - 1 and a [ j ] < a [ j + 1 ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT b . append ( [ i , j ] ) NEW_LINE ma , i = max ( j - i + 1 + ( i != 0 or j != n - 1 ) , ma ) , j + 1 NEW_LINE DEDENT for i in range ( len ( b ) - 1 ) : NEW_LINE INDENT if b [ i + 1 ] [ 0 ] - b [ i ] [ 1 ] == 2 and a [ b [ i + 1 ] [ 0 ] ] > a [ b [ i ] [ 1 ] ] + 1 : NEW_LINE INDENT ma = max ( ma , b [ i + 1 ] [ 1 ] - b [ i ] [ 0 ] + 1 ) NEW_LINE DEDENT elif b [ i + 1 ] [ 0 ] - b [ i ] [ 1 ] == 1 and ( b [ i + 1 ] [ 0 ] + 1 < n and a [ b [ i + 1 ] [ 0 ] + 1 ] > a [ b [ i ] [ 1 ] ] + 1 or b [ i ] [ 1 ] - 1 >= 0 and a [ b [ i ] [ 1 ] - 1 ] + 1 < a [ b [ i + 1 ] [ 0 ] ] ) : NEW_LINE INDENT ma = max ( ma , b [ i + 1 ] [ 1 ] - b [ i ] [ 0 ] + 1 ) NEW_LINE DEDENT DEDENT print ( ma ) NEW_LINE"}
{"id": "codeforces_116_B", "sol": 0, "python_code": "from collections import defaultdict , deque\nfrom functools import lru_cache\nfrom heapq import heappush , heappop\nfrom typing import Counter\nfrom bisect import bisect_right , bisect_left\nimport math\nhpop = heappop\nhpush = heappush\ndef solution ( ) :\n    n , m = map ( int , input ( ).split ( ) )\n    grid = [ ]\n    res = 0\n    for _ in range ( n ) :\n        grid.append ( input ( ) )\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if grid [ i ] [ j ] == \"W\" :\n                for di , dj in [ ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , 0 ) ] :\n                    ni = i + di\n                    nj = j + dj\n                    if not ( 0 <= ni < len ( grid ) and 0 <= nj < len ( grid [ 0 ] ) ) :\n                        continue\n                    if grid [ ni ] [ nj ] == \"P\" :\n                        res += 1\n                        break ;\n    print ( res )\ndef main ( ) :\n    t = 1\n    for _ in range ( t ) :\n        solution ( )\nmain ( )\n", "python_code_tokenized": "from collections import defaultdict , deque NEW_LINE from functools import lru_cache NEW_LINE from heapq import heappush , heappop NEW_LINE from typing import Counter NEW_LINE from bisect import bisect_right , bisect_left NEW_LINE import math NEW_LINE hpop = heappop NEW_LINE hpush = heappush NEW_LINE def solution ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE grid = [ ] NEW_LINE res = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT grid . append ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if grid [ i ] [ j ] == \" W \" : NEW_LINE INDENT for di , dj in [ ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , 0 ) ] : NEW_LINE INDENT ni = i + di NEW_LINE nj = j + dj NEW_LINE if not ( 0 <= ni < len ( grid ) and 0 <= nj < len ( grid [ 0 ] ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT if grid [ ni ] [ nj ] == \" P \" : NEW_LINE INDENT res += 1 NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = 1 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT solution ( ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "codejam_17_03", "sol": 0, "python_code": "infilecode = \"CLI\"\nimport sys\nmapping = { \"A\" : \"A\" , \"B\" : \"B\" , \"C\" : \"C\" , \"D\" : \"D\" , \"E\" : \"E\" , \"X\" : \"example\" , \"S\" : \"-small\" , \"L\" : \"-large\" , \"P\" : \"-practice\" , \"0\" : \"-attempt0\" , \"1\" : \"-attempt1\" , \"2\" : \"-attempt2\" , \"z\" : \"-1\" , \"Z\" : \"-2\" , \"I\" : \".in\" , \"T\" : \".txt\" }\ninfile = \"\".join ( mapping [ c ] for c in infilecode )\noutfile = infile.replace ( \".in\" , \"\" ) + \".out.txt\"\nsys.stdin = open ( infile , 'r' )\noutput = open ( outfile , 'w' )\nT = int ( input ( ) )\nfor case in range ( 1 , T + 1 ) :\n    N , K = map ( int , input ( ).split ( ) )\n    print ( N , K )\n    sizes = [ N , N + 1 ]\n    num = [ 1 , 0 ]\n    while K > sum ( num ) :\n        a , b = sizes\n        K -= sum ( num )\n        sizes = [ ( a - 1 ) // 2 , b // 2 ]\n        if a % 2 == 0 :\n            num = [ num [ 0 ] , num [ 0 ] + num [ 1 ] * 2 ]\n        else :\n            num = [ num [ 0 ] * 2 + num [ 1 ] , num [ 1 ] ]\n        print ( sizes , num , K )\n    if K <= num [ 1 ] :\n        size = sizes [ 1 ]\n    else :\n        size = sizes [ 0 ]\n    R = size // 2\n    L = ( size - 1 ) // 2\n    answer = str ( R ) + \" \" + str ( L )\n    print ( \"Case #%d:\" % case , answer )\n    print ( \"Case #%d:\" % case , answer , file = output )\n", "python_code_tokenized": "infilecode = \" CLI \" NEW_LINE import sys NEW_LINE mapping = { \" A \" : \" A \" , \" B \" : \" B \" , \" C \" : \" C \" , \" D \" : \" D \" , \" E \" : \" E \" , \" X \" : \" example \" , \" S \" : \" - small \" , \" L \" : \" - large \" , \" P \" : \" - practice \" , \"0\" : \" - attempt0\" , \"1\" : \" - attempt1\" , \"2\" : \" - attempt2\" , \" z \" : \" - 1\" , \" Z \" : \" - 2\" , \" I \" : \" . in \" , \" T \" : \" . txt \" } NEW_LINE infile = \" \" . join ( mapping [ c ] for c in infilecode ) NEW_LINE outfile = infile . replace ( \" . in \" , \" \" ) + \" . out . txt \" NEW_LINE sys . stdin = open ( infile , ' r ' ) NEW_LINE output = open ( outfile , ' w ' ) NEW_LINE T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE print ( N , K ) NEW_LINE sizes = [ N , N + 1 ] NEW_LINE num = [ 1 , 0 ] NEW_LINE while K > sum ( num ) : NEW_LINE INDENT a , b = sizes NEW_LINE K -= sum ( num ) NEW_LINE sizes = [ ( a - 1 ) // 2 , b // 2 ] NEW_LINE if a % 2 == 0 : NEW_LINE INDENT num = [ num [ 0 ] , num [ 0 ] + num [ 1 ] * 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT num = [ num [ 0 ] * 2 + num [ 1 ] , num [ 1 ] ] NEW_LINE DEDENT print ( sizes , num , K ) NEW_LINE DEDENT if K <= num [ 1 ] : NEW_LINE INDENT size = sizes [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT size = sizes [ 0 ] NEW_LINE DEDENT R = size // 2 NEW_LINE L = ( size - 1 ) // 2 NEW_LINE answer = str ( R ) + \" \u2581 \" + str ( L ) NEW_LINE print ( \" Case \u2581 # % d : \" % case , answer ) NEW_LINE print ( \" Case \u2581 # % d : \" % case , answer , file = output ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2042_A", "sol": 0, "python_code": "def getSum ( arr , p ) :\n    return len ( arr )\nif __name__ == \"__main__\" :\n    arr = [ 5 , 6 , 8 ]\n    p = 7\n    print ( getSum ( arr , p ) )\n", "python_code_tokenized": "def getSum ( arr , p ) : NEW_LINE INDENT return len ( arr ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 6 , 8 ] NEW_LINE p = 7 NEW_LINE print ( getSum ( arr , p ) ) NEW_LINE DEDENT"}
{"id": "projecteuler_p387_A", "sol": 0, "python_code": "import eulerlib\ndef compute ( ) :\n    LIMIT = 10 ** 14\n    ans = [ 0 ]\n    def find_harshad_primes ( n , digitsum , isstrong ) :\n        m = n * 10\n        s = digitsum\n        for i in range ( 10 ) :\n            if m >= LIMIT :\n                break\n            if isstrong and eulerlib.is_prime ( m ) :\n                ans [ 0 ] += m\n            if m % s == 0 :\n                find_harshad_primes ( m , s , eulerlib.is_prime ( m // s ) )\n            m += 1\n            s += 1\n    for i in range ( 1 , 10 ) :\n        find_harshad_primes ( i , i , False )\n    return str ( ans [ 0 ] )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 14 NEW_LINE ans = [ 0 ] NEW_LINE def find_harshad_primes ( n , digitsum , isstrong ) : NEW_LINE INDENT m = n * 10 NEW_LINE s = digitsum NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if m >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if isstrong and eulerlib . is_prime ( m ) : NEW_LINE INDENT ans [ 0 ] += m NEW_LINE DEDENT if m % s == 0 : NEW_LINE INDENT find_harshad_primes ( m , s , eulerlib . is_prime ( m // s ) ) NEW_LINE DEDENT m += 1 NEW_LINE s += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT find_harshad_primes ( i , i , False ) NEW_LINE DEDENT return str ( ans [ 0 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1430_A", "sol": 0, "python_code": "def sumOdd ( n ) :\n    terms = ( n + 1 ) // 2\n    sum1 = terms * terms\n    return sum1\ndef suminRange ( l , r ) :\n    return sumOdd ( r ) - sumOdd ( l - 1 )\nl = 2 ; r = 5\nprint ( \"Sum of odd natural number\" , \"from L to R is\" , suminRange ( l , r ) )\n", "python_code_tokenized": "def sumOdd ( n ) : NEW_LINE INDENT terms = ( n + 1 ) // 2 NEW_LINE sum1 = terms * terms NEW_LINE return sum1 NEW_LINE DEDENT def suminRange ( l , r ) : NEW_LINE INDENT return sumOdd ( r ) - sumOdd ( l - 1 ) NEW_LINE DEDENT l = 2 ; r = 5 NEW_LINE print ( \" Sum \u2581 of \u2581 odd \u2581 natural \u2581 number \" , \" from \u2581 L \u2581 to \u2581 R \u2581 is \" , suminRange ( l , r ) ) NEW_LINE"}
{"id": "atcoder_ARC072_A", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\ndef main ( ) :\n    N = int ( input ( ) )\n    A = list ( map ( int , input ( ).split ( ) ) )\n    tmp_o = [ 0 for i in range ( N + 1 ) ]\n    tmp_e = [ 0 for i in range ( N + 1 ) ]\n    count_o = 0\n    count_e = 0\n    for i in range ( N ) :\n        tmp_o [ i + 1 ] = tmp_o [ i ] + A [ i ]\n        if i % 2 == 1 and tmp_o [ i + 1 ] <= 0 :\n            count_o += 1 - tmp_o [ i + 1 ]\n            tmp_o [ i + 1 ] = 1\n        elif i % 2 == 0 and tmp_o [ i + 1 ] >= 0 :\n            count_o += tmp_o [ i + 1 ] + 1\n            tmp_o [ i + 1 ] = - 1\n        else :\n            continue\n    for i in range ( N ) :\n        tmp_e [ i + 1 ] = tmp_e [ i ] + A [ i ]\n        if i % 2 == 0 and tmp_e [ i + 1 ] <= 0 :\n            count_e += 1 - tmp_e [ i + 1 ]\n            tmp_e [ i + 1 ] = 1\n        elif i % 2 == 1 and tmp_e [ i + 1 ] >= 0 :\n            count_e += tmp_e [ i + 1 ] + 1\n            tmp_e [ i + 1 ] = - 1\n        else :\n            continue\n    print ( min ( count_o , count_e ) )\nif __name__ == \"__main__\" :\n    main ( )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE tmp_o = [ 0 for i in range ( N + 1 ) ] NEW_LINE tmp_e = [ 0 for i in range ( N + 1 ) ] NEW_LINE count_o = 0 NEW_LINE count_e = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT tmp_o [ i + 1 ] = tmp_o [ i ] + A [ i ] NEW_LINE if i % 2 == 1 and tmp_o [ i + 1 ] <= 0 : NEW_LINE INDENT count_o += 1 - tmp_o [ i + 1 ] NEW_LINE tmp_o [ i + 1 ] = 1 NEW_LINE DEDENT elif i % 2 == 0 and tmp_o [ i + 1 ] >= 0 : NEW_LINE INDENT count_o += tmp_o [ i + 1 ] + 1 NEW_LINE tmp_o [ i + 1 ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT tmp_e [ i + 1 ] = tmp_e [ i ] + A [ i ] NEW_LINE if i % 2 == 0 and tmp_e [ i + 1 ] <= 0 : NEW_LINE INDENT count_e += 1 - tmp_e [ i + 1 ] NEW_LINE tmp_e [ i + 1 ] = 1 NEW_LINE DEDENT elif i % 2 == 1 and tmp_e [ i + 1 ] >= 0 : NEW_LINE INDENT count_e += tmp_e [ i + 1 ] + 1 NEW_LINE tmp_e [ i + 1 ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( min ( count_o , count_e ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "projecteuler_p063_A", "sol": 0, "python_code": "def compute ( ) :\n    ans = sum ( 1 for i in range ( 1 , 10 ) for j in range ( 1 , 22 ) if len ( str ( i ** j ) ) == j )\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 , 10 ) for j in range ( 1 , 22 ) if len ( str ( i ** j ) ) == j ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1154_A", "sol": 0, "python_code": "def cast_list ( test_list , data_type ) :\n    return list ( map ( data_type , test_list ) )\ninputString = input ( )\nsplitStringList = inputString.split ( )\nsplitIntList = cast_list ( splitStringList , int )\nsplitIntList.sort ( )\n( a_plus_b , a_plus_c , b_plus_c , a_plus_b_plus_c ) = ( splitIntList [ 0 ] , splitIntList [ 1 ] , splitIntList [ 2 ] , splitIntList [ 3 ] )\nc = a_plus_b_plus_c - a_plus_b\na = a_plus_c - c\nb = b_plus_c - c\nprint ( a , b , c )\n", "python_code_tokenized": "def cast_list ( test_list , data_type ) : NEW_LINE INDENT return list ( map ( data_type , test_list ) ) NEW_LINE DEDENT inputString = input ( ) NEW_LINE splitStringList = inputString . split ( ) NEW_LINE splitIntList = cast_list ( splitStringList , int ) NEW_LINE splitIntList . sort ( ) NEW_LINE ( a_plus_b , a_plus_c , b_plus_c , a_plus_b_plus_c ) = ( splitIntList [ 0 ] , splitIntList [ 1 ] , splitIntList [ 2 ] , splitIntList [ 3 ] ) NEW_LINE c = a_plus_b_plus_c - a_plus_b NEW_LINE a = a_plus_c - c NEW_LINE b = b_plus_c - c NEW_LINE print ( a , b , c ) NEW_LINE"}
{"id": "codejam_13_21", "sol": 0, "python_code": "FILE_NAME_BASE = 'A-large'\nNUM_PROCESSES = 0\nMEM_LIMIT_GB = 1.5\nRECURSION_LIMIT = 1000\ndef parse ( inp ) :\n    start , num = ( int ( x ) for x in inp.readline ( ).split ( ) )\n    motes = tuple ( int ( x ) for x in inp.readline ( ).split ( ) )\n    assert len ( motes ) == num\n    return start , motes\ndef solve ( start , motes ) :\n    motes = sorted ( motes )\n    num = len ( motes )\n    best = num\n    size = start\n    added = 0\n    i = 0\n    while i < num :\n        if motes [ i ] < size :\n            size += motes [ i ]\n            i += 1\n        else :\n            best = min ( best , added + num - i )\n            if size <= 1 :\n                break\n            else :\n                while motes [ i ] - size >= 0 :\n                    size += size - 1\n                    added += 1\n    else :\n        best = min ( best , added )\n    return best\ndef main ( ) :\n    import sys\n    sys.setrecursionlimit ( RECURSION_LIMIT )\n    import resource\n    soft , hard = resource.getrlimit ( resource.RLIMIT_AS )\n    resource.setrlimit ( resource.RLIMIT_AS , ( MEM_LIMIT_GB * 1024 ** 3 , hard ) )\n    inp = open ( FILE_NAME_BASE + '.in' , 'r' )\n    numCases = int ( inp.readline ( ) )\n    if NUM_PROCESSES == 0 :\n        results = [ solve ( * parse ( inp ) ) for _ in range ( numCases ) ]\n    else :\n        from multiprocessing import Pool\n        pool = Pool ( NUM_PROCESSES )\n        results = [ pool.apply_async ( solve , parse ( inp ) ) for _ in range ( numCases ) ]\n    inp.close ( )\n    out = open ( FILE_NAME_BASE + '.out' , 'w' )\n    for case , result in enumerate ( results ) :\n        value = result if NUM_PROCESSES == 0 else result.get ( )\n        out.write ( 'Case #%d: %s\\n' % ( case + 1 , value ) )\n        out.flush ( )\n    out.close ( )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "FILE_NAME_BASE = ' A - large ' NEW_LINE NUM_PROCESSES = 0 NEW_LINE MEM_LIMIT_GB = 1.5 NEW_LINE RECURSION_LIMIT = 1000 NEW_LINE def parse ( inp ) : NEW_LINE INDENT start , num = ( int ( x ) for x in inp . readline ( ) . split ( ) ) NEW_LINE motes = tuple ( int ( x ) for x in inp . readline ( ) . split ( ) ) NEW_LINE assert len ( motes ) == num NEW_LINE return start , motes NEW_LINE DEDENT def solve ( start , motes ) : NEW_LINE INDENT motes = sorted ( motes ) NEW_LINE num = len ( motes ) NEW_LINE best = num NEW_LINE size = start NEW_LINE added = 0 NEW_LINE i = 0 NEW_LINE while i < num : NEW_LINE INDENT if motes [ i ] < size : NEW_LINE INDENT size += motes [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT best = min ( best , added + num - i ) NEW_LINE if size <= 1 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT while motes [ i ] - size >= 0 : NEW_LINE INDENT size += size - 1 NEW_LINE added += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT best = min ( best , added ) NEW_LINE DEDENT return best NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT import sys NEW_LINE sys . setrecursionlimit ( RECURSION_LIMIT ) NEW_LINE import resource NEW_LINE soft , hard = resource . getrlimit ( resource . RLIMIT_AS ) NEW_LINE resource . setrlimit ( resource . RLIMIT_AS , ( MEM_LIMIT_GB * 1024 ** 3 , hard ) ) NEW_LINE inp = open ( FILE_NAME_BASE + ' . in ' , ' r ' ) NEW_LINE numCases = int ( inp . readline ( ) ) NEW_LINE if NUM_PROCESSES == 0 : NEW_LINE INDENT results = [ solve ( * parse ( inp ) ) for _ in range ( numCases ) ] NEW_LINE DEDENT else : NEW_LINE INDENT from multiprocessing import Pool NEW_LINE pool = Pool ( NUM_PROCESSES ) NEW_LINE results = [ pool . apply_async ( solve , parse ( inp ) ) for _ in range ( numCases ) ] NEW_LINE DEDENT inp . close ( ) NEW_LINE out = open ( FILE_NAME_BASE + ' . out ' , ' w ' ) NEW_LINE for case , result in enumerate ( results ) : NEW_LINE INDENT value = result if NUM_PROCESSES == 0 else result . get ( ) NEW_LINE out . write ( ' Case \u2581 # % d : \u2581 % s \\n ' % ( case + 1 , value ) ) NEW_LINE out . flush ( ) NEW_LINE DEDENT out . close ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_718_A", "sol": 0, "python_code": "def countSetBits ( n ) :\n    count = 0\n    while ( n ) :\n        count += n & 1\n        n >>= 1\n    return count\ni = 3\nprint ( countSetBits ( i ) )\n", "python_code_tokenized": "def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT i = 3 NEW_LINE print ( countSetBits ( i ) ) NEW_LINE"}
{"id": "codeforces_723_B", "sol": 0, "python_code": "_len = int ( input ( ) )\n_str = input ( ).replace ( '(' , ')!' ).split ( ')' )\n_str = list ( filter ( None , _str ) )\nmxLen , wordsNum = 0 , 0\nfor word in _str :\n    if word [ 0 ] == '!' :\n        words = word [ 1 : ].split ( '_' )\n        words = list ( filter ( None , words ) )\n        wordsNum += len ( words )\n    else :\n        words = word.split ( '_' )\n        mxLen = max ( mxLen , len ( max ( words , key = len ) ) )\nprint ( mxLen , wordsNum )\n", "python_code_tokenized": "_len = int ( input ( ) ) NEW_LINE _str = input ( ) . replace ( ' ( ' , ' ) ! ' ) . split ( ' ) ' ) NEW_LINE _str = list ( filter ( None , _str ) ) NEW_LINE mxLen , wordsNum = 0 , 0 NEW_LINE for word in _str : NEW_LINE INDENT if word [ 0 ] == ' ! ' : NEW_LINE INDENT words = word [ 1 : ] . split ( ' _ ' ) NEW_LINE words = list ( filter ( None , words ) ) NEW_LINE wordsNum += len ( words ) NEW_LINE DEDENT else : NEW_LINE INDENT words = word . split ( ' _ ' ) NEW_LINE mxLen = max ( mxLen , len ( max ( words , key = len ) ) ) NEW_LINE DEDENT DEDENT print ( mxLen , wordsNum ) NEW_LINE"}
{"id": "geeksforgeeks_4864_A", "sol": 0, "python_code": "N = 1000005\nprime = [ True for i in range ( N ) ]\ndef sieve ( ) :\n    prime [ 1 ] = False\n    prime [ 0 ] = False\n    for i in range ( 2 , N ) :\n        if ( prime [ i ] == True ) :\n            for j in range ( i * 2 , N , i ) :\n                prime [ j ] = False\ndef sumTruncatablePrimes ( n ) :\n    sum = 0\n    for i in range ( 2 , n ) :\n        num = i\n        flag = True\n        while ( num ) :\n            if ( prime [ num ] == False ) :\n                flag = False\n                break\n            num //= 10\n        num = i\n        power = 10\n        while ( num // power ) :\n            if ( prime [ num % power ] == False ) :\n                flag = False\n                break\n            power *= 10\n        if ( flag == True ) :\n            sum += i\n    return sum\nn = 25\nsieve ( )\nprint ( sumTruncatablePrimes ( n ) )\n", "python_code_tokenized": "N = 1000005 NEW_LINE prime = [ True for i in range ( N ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT for j in range ( i * 2 , N , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumTruncatablePrimes ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT num = i NEW_LINE flag = True NEW_LINE while ( num ) : NEW_LINE INDENT if ( prime [ num ] == False ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT num //= 10 NEW_LINE DEDENT num = i NEW_LINE power = 10 NEW_LINE while ( num // power ) : NEW_LINE INDENT if ( prime [ num % power ] == False ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT power *= 10 NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 25 NEW_LINE sieve ( ) NEW_LINE print ( sumTruncatablePrimes ( n ) ) NEW_LINE"}
{"id": "leetcode_804_A", "sol": 0, "python_code": "Morse_tab = [ \".-\" , \"-...\" , \"-.-.\" , \"-..\" , \".\" , \"..-.\" , \"--.\" , \"....\" , \"..\" , \".---\" , \"-.-\" , \".-..\" , \"--\" , \"-.\" , \"---\" , \".--.\" , \"--.-\" , \".-.\" , \"...\" , \"-\" , \"..-\" , \"...-\" , \".--\" , \"-..-\" , \"-.--\" , \"--..\" ]\nclass Solution ( object ) :\n    def uniqueMorseRepresentations ( self , words ) :\n        if len ( words ) == 0 :\n            return 0\n        ans_set = set ( )\n        for word in words :\n            morsed = \"\"\n            for c in word :\n                morsed += Morse_tab [ ord ( c ) - ord ( 'a' ) ]\n            ans_set.add ( morsed )\n        return len ( ans_set )\n", "python_code_tokenized": "Morse_tab = [ \" . - \" , \" - . . . \" , \" - . - . \" , \" - . . \" , \" . \" , \" . . - . \" , \" - - . \" , \" . . . . \" , \" . . \" , \" . - - - \" , \" - . - \" , \" . - . . \" , \" - - \" , \" - . \" , \" - - - \" , \" . - - . \" , \" - - . - \" , \" . - . \" , \" . . . \" , \" - \" , \" . . - \" , \" . . . - \" , \" . - - \" , \" - . . - \" , \" - . - - \" , \" - - . . \" ] NEW_LINE class Solution ( object ) : NEW_LINE INDENT def uniqueMorseRepresentations ( self , words ) : NEW_LINE INDENT if len ( words ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans_set = set ( ) NEW_LINE for word in words : NEW_LINE INDENT morsed = \" \" NEW_LINE for c in word : NEW_LINE INDENT morsed += Morse_tab [ ord ( c ) - ord ( ' a ' ) ] NEW_LINE DEDENT ans_set . add ( morsed ) NEW_LINE DEDENT return len ( ans_set ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4323_A", "sol": 0, "python_code": "def findseason ( M ) :\n    list1 = [ [ 12 , 1 , 2 ] , [ 3 , 4 , 5 ] , [ 6 , 7 , 8 ] , [ 9 , 10 , 11 ] ]\n    if M in list1 [ 0 ] :\n        print ( \"WINTER\" )\n    elif M in list1 [ 1 ] :\n        print ( \"SPRING\" )\n    elif M in list1 [ 2 ] :\n        print ( \"SUMMER\" )\n    elif M in list1 [ 3 ] :\n        print ( \"AUTUMN\" )\n    else :\n        print ( \"Invalid Month Number\" )\nM = 5\nprint ( \"For Month number:\" , M ) ;\nfindseason ( M )\nM = 10\nprint ( \"For Month number:\" , M ) ;\nfindseason ( M )\n", "python_code_tokenized": "def findseason ( M ) : NEW_LINE INDENT list1 = [ [ 12 , 1 , 2 ] , [ 3 , 4 , 5 ] , [ 6 , 7 , 8 ] , [ 9 , 10 , 11 ] ] NEW_LINE if M in list1 [ 0 ] : NEW_LINE INDENT print ( \" WINTER \" ) NEW_LINE DEDENT elif M in list1 [ 1 ] : NEW_LINE INDENT print ( \" SPRING \" ) NEW_LINE DEDENT elif M in list1 [ 2 ] : NEW_LINE INDENT print ( \" SUMMER \" ) NEW_LINE DEDENT elif M in list1 [ 3 ] : NEW_LINE INDENT print ( \" AUTUMN \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Invalid \u2581 Month \u2581 Number \" ) NEW_LINE DEDENT DEDENT M = 5 NEW_LINE print ( \" For \u2581 Month \u2581 number : \" , M ) ; NEW_LINE findseason ( M ) NEW_LINE M = 10 NEW_LINE print ( \" For \u2581 Month \u2581 number : \" , M ) ; NEW_LINE findseason ( M ) NEW_LINE"}
{"id": "atcoder_ABC058_D", "sol": 0, "python_code": "n , m = ( int ( i ) for i in input ( ).split ( ) )\nx = [ int ( i ) for i in input ( ).split ( ) ]\ny = [ int ( i ) for i in input ( ).split ( ) ]\ndifx , dify , num , num2 , mod = [ ] , [ ] , 0 , 0 , 10 ** 9 + 7\nfor i in range ( 1 , n ) : difx.append ( x [ i ] - x [ i - 1 ] )\nfor i in range ( 1 , m ) : dify.append ( y [ i ] - y [ i - 1 ] )\nfor i in range ( n - 1 ) : num = ( num + ( i + 1 ) * ( n - i - 1 ) * difx [ i ] ) % mod\nfor i in range ( m - 1 ) : num2 = ( num2 + ( i + 1 ) * ( m - i - 1 ) * dify [ i ] ) % mod\nprint ( num * num2 % mod )\n", "python_code_tokenized": "n , m = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE x = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE y = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE difx , dify , num , num2 , mod = [ ] , [ ] , 0 , 0 , 10 ** 9 + 7 NEW_LINE for i in range ( 1 , n ) : difx . append ( x [ i ] - x [ i - 1 ] ) NEW_LINE for i in range ( 1 , m ) : dify . append ( y [ i ] - y [ i - 1 ] ) NEW_LINE for i in range ( n - 1 ) : num = ( num + ( i + 1 ) * ( n - i - 1 ) * difx [ i ] ) % mod NEW_LINE for i in range ( m - 1 ) : num2 = ( num2 + ( i + 1 ) * ( m - i - 1 ) * dify [ i ] ) % mod NEW_LINE print ( num * num2 % mod ) NEW_LINE"}
{"id": "geeksforgeeks_4577_A", "sol": 0, "python_code": "def xorLessK ( arr , n , k ) :\n    count = 0\n    for i in range ( n ) :\n        tempXor = 0\n        for j in range ( i , n ) :\n            tempXor ^= arr [ j ]\n            if ( tempXor < k ) :\n                count += 1\n    return count\nif __name__ == '__main__' :\n    k = 3\n    arr = [ 8 , 9 , 10 , 11 , 12 ]\n    n = len ( arr )\n    print ( xorLessK ( arr , n , k ) )\n", "python_code_tokenized": "def xorLessK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tempXor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT tempXor ^= arr [ j ] NEW_LINE if ( tempXor < k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 3 NEW_LINE arr = [ 8 , 9 , 10 , 11 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( xorLessK ( arr , n , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1837_A", "sol": 0, "python_code": "from math import log2\ndef findX ( arr , n ) :\n    itr = arr [ 0 ]\n    for i in range ( len ( arr ) ) :\n        if ( arr [ i ] > itr ) :\n            itr = arr [ i ]\n    p = int ( log2 ( itr ) ) + 1\n    X = 0\n    for i in range ( p ) :\n        count = 0\n        for j in range ( n ) :\n            if ( arr [ j ] & ( 1 << i ) ) :\n                count += 1\n        if ( count > int ( n / 2 ) ) :\n            X += 1 << i\n    sum = 0\n    for i in range ( n ) :\n        sum += ( X ^ arr [ i ] )\n    print ( \"X =\" , X , \", Sum =\" , sum )\nif __name__ == '__main__' :\n    arr = [ 2 , 3 , 4 , 5 , 6 ]\n    n = len ( arr )\n    findX ( arr , n )\n", "python_code_tokenized": "from math import log2 NEW_LINE def findX ( arr , n ) : NEW_LINE INDENT itr = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > itr ) : NEW_LINE INDENT itr = arr [ i ] NEW_LINE DEDENT DEDENT p = int ( log2 ( itr ) ) + 1 NEW_LINE X = 0 NEW_LINE for i in range ( p ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > int ( n / 2 ) ) : NEW_LINE INDENT X += 1 << i NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ( X ^ arr [ i ] ) NEW_LINE DEDENT print ( \" X \u2581 = \" , X , \" , \u2581 Sum \u2581 = \" , sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE findX ( arr , n ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC107_D", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\ndef check ( x ) :\n    b = n\n    r = 0\n    y = 0\n    D = [ 0 ] * ( 2 * n + 1 )\n    for i in range ( n ) :\n        D [ b ] += 1\n        if a [ i ] < x :\n            r += D [ b ]\n            b += 1\n        else :\n            b -= 1\n            r -= D [ b ]\n        y += r\n    return y\nalpha = sorted ( a )\nl , r = 0 , n\nm , c = n // 2 , n * ( n + 1 ) // 2\nwhile True :\n    if check ( alpha [ m ] ) <= c // 2 :\n        if m == n - 1 :\n            break\n        elif check ( alpha [ m + 1 ] ) > c // 2 :\n            break\n        else :\n            l , m = m , ( m + r ) // 2\n    else :\n        m , r = ( m + l ) // 2 , m + 1\nprint ( alpha [ m ] )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def check ( x ) : NEW_LINE INDENT b = n NEW_LINE r = 0 NEW_LINE y = 0 NEW_LINE D = [ 0 ] * ( 2 * n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT D [ b ] += 1 NEW_LINE if a [ i ] < x : NEW_LINE INDENT r += D [ b ] NEW_LINE b += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b -= 1 NEW_LINE r -= D [ b ] NEW_LINE DEDENT y += r NEW_LINE DEDENT return y NEW_LINE DEDENT alpha = sorted ( a ) NEW_LINE l , r = 0 , n NEW_LINE m , c = n // 2 , n * ( n + 1 ) // 2 NEW_LINE while True : NEW_LINE INDENT if check ( alpha [ m ] ) <= c // 2 : NEW_LINE INDENT if m == n - 1 : NEW_LINE INDENT break NEW_LINE DEDENT elif check ( alpha [ m + 1 ] ) > c // 2 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT l , m = m , ( m + r ) // 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT m , r = ( m + l ) // 2 , m + 1 NEW_LINE DEDENT DEDENT print ( alpha [ m ] ) NEW_LINE"}
{"id": "aizu_p02400_A", "sol": 0, "python_code": "import math\ndef test_case ( ) :\n    r = float ( input ( ) )\n    area = float ( r ** 2 * math.pi )\n    circum = float ( 2 * r * math.pi )\n    print ( \"{0:.8f} {1:.8f}\".format ( area , circum ) )\nif __name__ == \"__main__\" :\n    test_case ( )\n", "python_code_tokenized": "import math NEW_LINE def test_case ( ) : NEW_LINE INDENT r = float ( input ( ) ) NEW_LINE area = float ( r ** 2 * math . pi ) NEW_LINE circum = float ( 2 * r * math . pi ) NEW_LINE print ( \" { 0 : . 8f } \u2581 { 1 : . 8f } \" . format ( area , circum ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT test_case ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1247_A", "sol": 0, "python_code": "def decToHexa ( n ) :\n    hexaDeciNum = [ '0' ] * 100 ;\n    i = 0 ;\n    while ( n != 0 ) :\n        temp = 0 ;\n        temp = n % 16 ;\n        if ( temp < 10 ) :\n            hexaDeciNum [ i ] = chr ( temp + 48 ) ;\n            i = i + 1 ;\n        else :\n            hexaDeciNum [ i ] = chr ( temp + 55 ) ;\n            i = i + 1 ;\n        n = int ( n / 16 ) ;\n    j = i - 1 ;\n    while ( j >= 0 ) :\n        print ( ( hexaDeciNum [ j ] ) , end = \"\" ) ;\n        j = j - 1 ;\nn = 2545 ;\ndecToHexa ( n ) ;\n", "python_code_tokenized": "def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ '0' ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 ; NEW_LINE temp = n % 16 ; NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 48 ) ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 55 ) ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT n = int ( n / 16 ) ; NEW_LINE DEDENT j = i - 1 ; NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT print ( ( hexaDeciNum [ j ] ) , end = \" \" ) ; NEW_LINE j = j - 1 ; NEW_LINE DEDENT DEDENT n = 2545 ; NEW_LINE decToHexa ( n ) ; NEW_LINE"}
{"id": "atcoder_AGC008_B", "sol": 0, "python_code": "from sys import exit , setrecursionlimit , stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import *\nfrom bisect import bisect\ndef read ( ) :\n    return int ( input ( ) )\ndef reads ( ) :\n    return [ int ( x ) for x in input ( ).split ( ) ]\nN , K = reads ( )\na = reads ( )\nppsum = [ 0 ] * ( N + 1 )\npsum = [ 0 ] * ( N + 1 )\nfor i in range ( N ) :\n    ppsum [ i + 1 ] = ppsum [ i ] + max ( 0 , a [ i ] )\n    psum [ i + 1 ] = psum [ i ] + a [ i ]\nansb = max ( ppsum [ i ] + psum [ i + K ] - psum [ i ] + ppsum [ N ] - ppsum [ i + K ] for i in range ( N - K + 1 ) )\nansw = max ( ppsum [ i ] + ppsum [ N ] - ppsum [ i + K ] for i in range ( N - K + 1 ) )\nprint ( max ( ansb , answ ) )\n", "python_code_tokenized": "from sys import exit , setrecursionlimit , stderr NEW_LINE from functools import reduce NEW_LINE from itertools import * NEW_LINE from collections import * NEW_LINE from bisect import bisect NEW_LINE def read ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def reads ( ) : NEW_LINE INDENT return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE DEDENT N , K = reads ( ) NEW_LINE a = reads ( ) NEW_LINE ppsum = [ 0 ] * ( N + 1 ) NEW_LINE psum = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT ppsum [ i + 1 ] = ppsum [ i ] + max ( 0 , a [ i ] ) NEW_LINE psum [ i + 1 ] = psum [ i ] + a [ i ] NEW_LINE DEDENT ansb = max ( ppsum [ i ] + psum [ i + K ] - psum [ i ] + ppsum [ N ] - ppsum [ i + K ] for i in range ( N - K + 1 ) ) NEW_LINE answ = max ( ppsum [ i ] + ppsum [ N ] - ppsum [ i + K ] for i in range ( N - K + 1 ) ) NEW_LINE print ( max ( ansb , answ ) ) NEW_LINE"}
{"id": "geeksforgeeks_3602_A", "sol": 0, "python_code": "def isSpiltPossible ( n , a ) :\n    Sum = 0\n    c1 = 0\n    for i in range ( n ) :\n        Sum += a [ i ]\n        if ( a [ i ] == 1 ) :\n            c1 += 1\n    if ( Sum % 2 ) :\n        return False\n    if ( ( Sum // 2 ) % 2 == 0 ) :\n        return True\n    if ( c1 > 0 ) :\n        return True\n    else :\n        return False\nn = 3\na = [ 1 , 1 , 2 ]\nif ( isSpiltPossible ( n , a ) ) :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "def isSpiltPossible ( n , a ) : NEW_LINE INDENT Sum = 0 NEW_LINE c1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += a [ i ] NEW_LINE if ( a [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT if ( Sum % 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( Sum // 2 ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( c1 > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 3 NEW_LINE a = [ 1 , 1 , 2 ] NEW_LINE if ( isSpiltPossible ( n , a ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "codeforces_442_B", "sol": 0, "python_code": "n = int ( input ( ) )\nl = list ( map ( float , input ( ).split ( ) ) )\nl = sorted ( l )\nl = l [ : : - 1 ]\nans = 0\nd = 1\nvze = 0\nfor x in l :\n    vze = vze + x * ( d - vze )\n    d *= ( 1 - x )\n    ans = max ( ans , vze )\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE l = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE l = sorted ( l ) NEW_LINE l = l [ : : - 1 ] NEW_LINE ans = 0 NEW_LINE d = 1 NEW_LINE vze = 0 NEW_LINE for x in l : NEW_LINE INDENT vze = vze + x * ( d - vze ) NEW_LINE d *= ( 1 - x ) NEW_LINE ans = max ( ans , vze ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_1192_A", "sol": 0, "python_code": "def countWays ( A , B , C ) :\n    minAddA = max ( 0 , ( C + B - A + 2 ) // 2 )\n    count_ways = max ( C - minAddA + 1 , 0 )\n    return count_ways\nA = 3\nB = 5\nC = 5\nprint ( countWays ( A , B , C ) )\n", "python_code_tokenized": "def countWays ( A , B , C ) : NEW_LINE INDENT minAddA = max ( 0 , ( C + B - A + 2 ) // 2 ) NEW_LINE count_ways = max ( C - minAddA + 1 , 0 ) NEW_LINE return count_ways NEW_LINE DEDENT A = 3 NEW_LINE B = 5 NEW_LINE C = 5 NEW_LINE print ( countWays ( A , B , C ) ) NEW_LINE"}
{"id": "leetcode_414_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def thirdMax ( self , nums ) :\n        import Queue\n        pq = Queue.PriorityQueue ( 4 )\n        check = set ( )\n        for n in nums :\n            if n in check :\n                continue\n            pq.put ( n )\n            check.add ( n )\n            if len ( check ) > 3 :\n                check.remove ( pq.get ( ) )\n        total = len ( check )\n        while total < 3 and total > 1 :\n            total -= 1\n        return pq.get ( )\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def thirdMax ( self , nums ) : NEW_LINE INDENT import Queue NEW_LINE pq = Queue . PriorityQueue ( 4 ) NEW_LINE check = set ( ) NEW_LINE for n in nums : NEW_LINE INDENT if n in check : NEW_LINE INDENT continue NEW_LINE DEDENT pq . put ( n ) NEW_LINE check . add ( n ) NEW_LINE if len ( check ) > 3 : NEW_LINE INDENT check . remove ( pq . get ( ) ) NEW_LINE DEDENT DEDENT total = len ( check ) NEW_LINE while total < 3 and total > 1 : NEW_LINE INDENT total -= 1 NEW_LINE DEDENT return pq . get ( ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_617_B", "sol": 0, "python_code": "number = int ( input ( ) )\narr = list ( map ( int , input ( ).split ( ) ) )\ncounter = 0\ndata = { \"found\" : \"NO\" , 'first' : 0 }\nfor i in range ( 0 , number ) :\n    x = int ( arr [ i ] )\n    if x == 1 :\n        if counter == 0 :\n            counter = 1\n        if data [ 'found' ] == \"yes\" :\n            y = i - data [ 'first' ]\n            counter = counter * y\n            data [ 'first' ] = i\n        else :\n            data [ 'found' ] = \"yes\"\n            data [ 'first' ] = i\nprint ( counter )\n", "python_code_tokenized": "number = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE counter = 0 NEW_LINE data = { \" found \" : \" NO \" , ' first ' : 0 } NEW_LINE for i in range ( 0 , number ) : NEW_LINE INDENT x = int ( arr [ i ] ) NEW_LINE if x == 1 : NEW_LINE INDENT if counter == 0 : NEW_LINE INDENT counter = 1 NEW_LINE DEDENT if data [ ' found ' ] == \" yes \" : NEW_LINE INDENT y = i - data [ ' first ' ] NEW_LINE counter = counter * y NEW_LINE data [ ' first ' ] = i NEW_LINE DEDENT else : NEW_LINE INDENT data [ ' found ' ] = \" yes \" NEW_LINE data [ ' first ' ] = i NEW_LINE DEDENT DEDENT DEDENT print ( counter ) NEW_LINE"}
{"id": "geeksforgeeks_1997_A", "sol": 0, "python_code": "def count_odd_pair ( n , a ) :\n    odd = 0\n    even = 0\n    for i in range ( 0 , n ) :\n        if a [ i ] % 2 == 0 :\n            even = even + 1\n        else :\n            odd = odd + 1\n    ans = odd * ( odd - 1 )\n    return ans\ndef count_even_pair ( odd_product_pairs , n ) :\n    total_pairs = ( n * ( n - 1 ) )\n    ans = total_pairs - odd_product_pairs\n    return ans\nif __name__ == '__main__' :\n    n = 6\n    a = [ 2 , 4 , 5 , 9 , 1 , 8 ]\n    odd_product_pairs = count_odd_pair ( n , a )\n    even_product_pairs = ( count_even_pair ( odd_product_pairs , n ) )\n    print ( \"Even Product Pairs = \" , even_product_pairs )\n    print ( \"Odd Product Pairs= \" , odd_product_pairs )\n", "python_code_tokenized": "def count_odd_pair ( n , a ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT even = even + 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT DEDENT ans = odd * ( odd - 1 ) NEW_LINE return ans NEW_LINE DEDENT def count_even_pair ( odd_product_pairs , n ) : NEW_LINE INDENT total_pairs = ( n * ( n - 1 ) ) NEW_LINE ans = total_pairs - odd_product_pairs NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE a = [ 2 , 4 , 5 , 9 , 1 , 8 ] NEW_LINE odd_product_pairs = count_odd_pair ( n , a ) NEW_LINE even_product_pairs = ( count_even_pair ( odd_product_pairs , n ) ) NEW_LINE print ( \" Even \u2581 Product \u2581 Pairs \u2581 = \u2581 \" , even_product_pairs ) NEW_LINE print ( \" Odd \u2581 Product \u2581 Pairs = \u2581 \" , odd_product_pairs ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3723_A", "sol": 0, "python_code": "from collections import defaultdict\ndef get_unordered_pairs ( a , n ) :\n    vs = [ ]\n    m = defaultdict ( lambda : 0 )\n    for i in range ( 0 , n ) :\n        m [ a [ i ] ] += 1\n        if m [ a [ i ] ] == 1 :\n            vs.append ( a [ i ] )\n    number_of_pairs = 0\n    for i in range ( 0 , len ( vs ) ) :\n        if m [ vs [ i ] ] < vs [ i ] :\n            continue\n        elif m [ vs [ i ] ] == vs [ i ] :\n            number_of_pairs += 1\n        else :\n            number_of_pairs += 1\n            for j in range ( vs [ i ] + 1 , m [ vs [ i ] ] + 1 ) :\n                if m [ j ] >= vs [ i ] :\n                    number_of_pairs += 1\n    return number_of_pairs\nif __name__ == \"__main__\" :\n    arr = [ 3 , 3 , 2 , 2 , 2 ]\n    n = len ( arr )\n    print ( get_unordered_pairs ( arr , n ) )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE def get_unordered_pairs ( a , n ) : NEW_LINE INDENT vs = [ ] NEW_LINE m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT m [ a [ i ] ] += 1 NEW_LINE if m [ a [ i ] ] == 1 : NEW_LINE INDENT vs . append ( a [ i ] ) NEW_LINE DEDENT DEDENT number_of_pairs = 0 NEW_LINE for i in range ( 0 , len ( vs ) ) : NEW_LINE INDENT if m [ vs [ i ] ] < vs [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT elif m [ vs [ i ] ] == vs [ i ] : NEW_LINE INDENT number_of_pairs += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number_of_pairs += 1 NEW_LINE for j in range ( vs [ i ] + 1 , m [ vs [ i ] ] + 1 ) : NEW_LINE INDENT if m [ j ] >= vs [ i ] : NEW_LINE INDENT number_of_pairs += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return number_of_pairs NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 2 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( get_unordered_pairs ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3201_A", "sol": 0, "python_code": "import math as mt\ndef printNonDivisible ( A , B , n , m ) :\n    for i in range ( m ) :\n        j = 0\n        for j in range ( n ) :\n            if ( B [ i ] % A [ j ] == 0 ) :\n                break\n        if ( j == n - 1 ) :\n            print ( B [ i ] )\nA = [ 100 , 200 , 400 , 100 ]\nn = len ( A )\nB = [ 190 , 200 , 87 , 600 , 800 ]\nm = len ( B )\nprintNonDivisible ( A , B , n , m )\n", "python_code_tokenized": "import math as mt NEW_LINE def printNonDivisible ( A , B , n , m ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( B [ i ] % A [ j ] == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == n - 1 ) : NEW_LINE INDENT print ( B [ i ] ) NEW_LINE DEDENT DEDENT DEDENT A = [ 100 , 200 , 400 , 100 ] NEW_LINE n = len ( A ) NEW_LINE B = [ 190 , 200 , 87 , 600 , 800 ] NEW_LINE m = len ( B ) NEW_LINE printNonDivisible ( A , B , n , m ) NEW_LINE"}
{"id": "geeksforgeeks_3113_A", "sol": 0, "python_code": "def checkForSorting ( arr , n ) :\n    for i in range ( 0 , n - 1 ) :\n        if ( arr [ i ] > arr [ i + 1 ] ) :\n            if ( arr [ i ] - arr [ i + 1 ] == 1 ) :\n                arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ]\n            else :\n                return False\n    return True\narr = [ 1 , 0 , 3 , 2 ]\nn = len ( arr )\nif ( checkForSorting ( arr , n ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def checkForSorting ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i + 1 ] == 1 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 0 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkForSorting ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1163_A", "sol": 0, "python_code": "def isVowel ( ch ) :\n    if ch in [ 'a' , 'e' , 'i' , 'o' , 'u' ] :\n        return True\n    else :\n        return False\ndef vowelPairs ( s , n ) :\n    cnt = 0\n    for i in range ( n - 1 ) :\n        if ( isVowel ( s [ i ] ) and isVowel ( s [ i + 1 ] ) ) :\n            cnt += 1\n    return cnt\ns = \"abaebio\"\nn = len ( s )\nprint ( vowelPairs ( s , n ) )\n", "python_code_tokenized": "def isVowel ( ch ) : NEW_LINE INDENT if ch in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def vowelPairs ( s , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) and isVowel ( s [ i + 1 ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT s = \" abaebio \" NEW_LINE n = len ( s ) NEW_LINE print ( vowelPairs ( s , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4290_A", "sol": 0, "python_code": "def display ( n ) :\n    sp = n // 2\n    st = 1\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , sp + 1 ) :\n            print ( \" \" , end = ' ' )\n        count = st // 2 + 1\n        for k in range ( 1 , st + 1 ) :\n            print ( count , end = ' ' )\n            if ( k <= ( st // 2 ) ) :\n                count -= 1\n            else :\n                count += 1\n        print ( )\n        if ( i <= n // 2 ) :\n            sp -= 1\n            st += 2\n        else :\n            sp += 1\n            st -= 2\nn = 7\ndisplay ( n )\n", "python_code_tokenized": "def display ( n ) : NEW_LINE INDENT sp = n // 2 NEW_LINE st = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sp + 1 ) : NEW_LINE INDENT print ( \" \u2581 \" , end = ' \u2581 ' ) NEW_LINE DEDENT count = st // 2 + 1 NEW_LINE for k in range ( 1 , st + 1 ) : NEW_LINE INDENT print ( count , end = ' \u2581 ' ) NEW_LINE if ( k <= ( st // 2 ) ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( ) NEW_LINE if ( i <= n // 2 ) : NEW_LINE INDENT sp -= 1 NEW_LINE st += 2 NEW_LINE DEDENT else : NEW_LINE INDENT sp += 1 NEW_LINE st -= 2 NEW_LINE DEDENT DEDENT DEDENT n = 7 NEW_LINE display ( n ) NEW_LINE"}
{"id": "geeksforgeeks_4545_A", "sol": 0, "python_code": "def display ( n ) :\n    sp = n // 2\n    st = 1\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , sp + 1 ) :\n            print ( end = \"\" )\n        count = 1\n        for k in range ( 1 , st + 1 ) :\n            if ( k % 2 == 0 ) :\n                print ( \"*\" , end = \"\" )\n            else :\n                print ( count , end = \"\" )\n                count += 1\n        print ( )\n        if ( i <= n // 2 ) :\n            sp = sp - 1\n            st = st + 2\n        else :\n            sp = sp + 1\n            st = st - 2\nn = 5\ndisplay ( n )\n", "python_code_tokenized": "def display ( n ) : NEW_LINE INDENT sp = n // 2 NEW_LINE st = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sp + 1 ) : NEW_LINE INDENT print ( end = \" \u2581 \" ) NEW_LINE DEDENT count = 1 NEW_LINE for k in range ( 1 , st + 1 ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count , end = \" \" ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( ) NEW_LINE if ( i <= n // 2 ) : NEW_LINE INDENT sp = sp - 1 NEW_LINE st = st + 2 NEW_LINE DEDENT else : NEW_LINE INDENT sp = sp + 1 NEW_LINE st = st - 2 NEW_LINE DEDENT DEDENT DEDENT n = 5 NEW_LINE display ( n ) NEW_LINE"}
{"id": "codeforces_297_A", "sol": 0, "python_code": "a = input ( )\nb = input ( )\nif a.count ( '1' ) + a.count ( '1' ) % 2 >= b.count ( '1' ) :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "a = input ( ) NEW_LINE b = input ( ) NEW_LINE if a . count ( '1' ) + a . count ( '1' ) % 2 >= b . count ( '1' ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4847_A", "sol": 0, "python_code": "def Circumference ( a ) :\n    return ( 4 * a )\na = 5\nc = Circumference ( a )\nprint ( \"Circumference of a \" + \"square is % d\" % ( c ) )\n", "python_code_tokenized": "def Circumference ( a ) : NEW_LINE INDENT return ( 4 * a ) NEW_LINE DEDENT a = 5 NEW_LINE c = Circumference ( a ) NEW_LINE print ( \" Circumference \u2581 of \u2581 a \u2581 \" + \" square \u2581 is \u2581 % \u2581 d \" % ( c ) ) NEW_LINE"}
{"id": "geeksforgeeks_1681_A", "sol": 0, "python_code": "def findEvenPair ( A , N ) :\n    count = 0\n    for i in range ( 0 , N ) :\n        if ( A [ i ] % 2 != 0 ) :\n            count += 1\n    totalPairs = ( N * ( N - 1 ) / 2 )\n    oddEvenPairs = count * ( N - count )\n    return ( int ) ( totalPairs - oddEvenPairs )\ndef main ( ) :\n    a = [ 5 , 4 , 7 , 2 , 1 ]\n    n = len ( a )\n    print ( findEvenPair ( a , n ) )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "def findEvenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT totalPairs = ( N * ( N - 1 ) / 2 ) NEW_LINE oddEvenPairs = count * ( N - count ) NEW_LINE return ( int ) ( totalPairs - oddEvenPairs ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findEvenPair ( a , n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_697_A", "sol": 0, "python_code": "def printArr ( arr , n ) :\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" )\ndef pushBinaryToBorder ( arr , n ) :\n    count1 = 0\n    for i in range ( n ) :\n        if ( arr [ i ] != 1 ) :\n            arr [ count1 ] = arr [ i ]\n            count1 += 1\n    while ( count1 < n ) :\n        arr [ count1 ] = 1\n        count1 += 1\n    lastNonOne = 0\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        if ( arr [ i ] == 1 ) :\n            continue\n        if ( not lastNonOne ) :\n            lastNonOne = i\n        if ( arr [ i ] != 0 ) :\n            arr [ lastNonOne ] = arr [ i ]\n            lastNonOne -= 1\n    while ( lastNonOne >= 0 ) :\n        arr [ lastNonOne ] = 0\n        lastNonOne -= 1\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 0 , 0 , 0 , 3 , 6 ] ;\n    n = len ( arr ) ;\n    pushBinaryToBorder ( arr , n )\n    printArr ( arr , n )\n", "python_code_tokenized": "def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT def pushBinaryToBorder ( arr , n ) : NEW_LINE INDENT count1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 1 ) : NEW_LINE INDENT arr [ count1 ] = arr [ i ] NEW_LINE count1 += 1 NEW_LINE DEDENT DEDENT while ( count1 < n ) : NEW_LINE INDENT arr [ count1 ] = 1 NEW_LINE count1 += 1 NEW_LINE DEDENT lastNonOne = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( not lastNonOne ) : NEW_LINE INDENT lastNonOne = i NEW_LINE DEDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ lastNonOne ] = arr [ i ] NEW_LINE lastNonOne -= 1 NEW_LINE DEDENT DEDENT while ( lastNonOne >= 0 ) : NEW_LINE INDENT arr [ lastNonOne ] = 0 NEW_LINE lastNonOne -= 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 0 , 0 , 0 , 3 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE pushBinaryToBorder ( arr , n ) NEW_LINE printArr ( arr , n ) NEW_LINE DEDENT"}
{"id": "codeforces_1228_B", "sol": 0, "python_code": "import sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\nh , w = map ( int , input ( ).split ( ) )\nr = list ( map ( int , input ( ).split ( ) ) )\nc = list ( map ( int , input ( ).split ( ) ) )\nmod = pow ( 10 , 9 ) + 7\nx = [ [ ] for _ in range ( w ) ]\nfor i in r :\n    for j in range ( i ) :\n        x [ j ].append ( 1 )\n    if i < w :\n        x [ i ].append ( 0 )\n    for j in range ( i + 1 , w ) :\n        x [ j ].append ( - 1 )\nans = 1\nfor i , y in zip ( c , x ) :\n    for j in range ( i ) :\n        if y [ j ] == 0 :\n            ans = 0\n    if i < h and y [ i ] == 1 :\n        ans = 0\n    for j in range ( i + 1 , h ) :\n        if y [ j ] == - 1 :\n            ans *= 2\n            ans %= mod\n    if not ans :\n        break\nprint ( ans )\n", "python_code_tokenized": "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE h , w = map ( int , input ( ) . split ( ) ) NEW_LINE r = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mod = pow ( 10 , 9 ) + 7 NEW_LINE x = [ [ ] for _ in range ( w ) ] NEW_LINE for i in r : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT x [ j ] . append ( 1 ) NEW_LINE DEDENT if i < w : NEW_LINE INDENT x [ i ] . append ( 0 ) NEW_LINE DEDENT for j in range ( i + 1 , w ) : NEW_LINE INDENT x [ j ] . append ( - 1 ) NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE for i , y in zip ( c , x ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if y [ j ] == 0 : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT DEDENT if i < h and y [ i ] == 1 : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT for j in range ( i + 1 , h ) : NEW_LINE INDENT if y [ j ] == - 1 : NEW_LINE INDENT ans *= 2 NEW_LINE ans %= mod NEW_LINE DEDENT DEDENT if not ans : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_937_B", "sol": 0, "python_code": "n , h = map ( int , input ( ).split ( ) )\nfor i in range ( h , n , - 1 ) :\n    if all ( i % j for j in range ( 2 , min ( int ( i **.5 ) , n ) + 1 ) ) : print ( i ) ; exit ( )\nprint ( - 1 )\n", "python_code_tokenized": "n , h = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( h , n , - 1 ) : NEW_LINE INDENT if all ( i % j for j in range ( 2 , min ( int ( i ** .5 ) , n ) + 1 ) ) : print ( i ) ; exit ( ) NEW_LINE DEDENT print ( - 1 ) NEW_LINE"}
{"id": "geeksforgeeks_2856_A", "sol": 0, "python_code": "MAX_CHAR = 26\ndef countPalindrome ( str ) :\n    n = len ( str )\n    sum = 0\n    hashTable = [ 0 ] * MAX_CHAR\n    for i in range ( n ) :\n        hashTable [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1\n    for i in range ( 26 ) :\n        if ( hashTable [ i ] ) :\n            sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) // 2 )\n    return sum\nif __name__ == \"__main__\" :\n    str = \"ananananddd\"\n    print ( countPalindrome ( str ) )\n", "python_code_tokenized": "MAX_CHAR = 26 NEW_LINE def countPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE sum = 0 NEW_LINE hashTable = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( hashTable [ i ] ) : NEW_LINE INDENT sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) // 2 ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" ananananddd \" NEW_LINE print ( countPalindrome ( str ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2274_A", "sol": 0, "python_code": "def printPattern ( n ) :\n    line_no = 1\n    curr_star = 0\n    line_no = 1\n    while ( line_no <= n ) :\n        if ( curr_star < line_no ) :\n            print ( \"* \" , end = \"\" )\n            curr_star += 1\n            continue\n        if ( curr_star == line_no ) :\n            print ( \"\" )\n            line_no += 1\n            curr_star = 0\nprintPattern ( 7 )\n", "python_code_tokenized": "def printPattern ( n ) : NEW_LINE INDENT line_no = 1 NEW_LINE curr_star = 0 NEW_LINE line_no = 1 NEW_LINE while ( line_no <= n ) : NEW_LINE INDENT if ( curr_star < line_no ) : NEW_LINE INDENT print ( \" * \u2581 \" , end = \" \" ) NEW_LINE curr_star += 1 NEW_LINE continue NEW_LINE DEDENT if ( curr_star == line_no ) : NEW_LINE INDENT print ( \" \" ) NEW_LINE line_no += 1 NEW_LINE curr_star = 0 NEW_LINE DEDENT DEDENT DEDENT printPattern ( 7 ) NEW_LINE"}
{"id": "geeksforgeeks_2645_A", "sol": 0, "python_code": "def calculateSquareSum ( n ) :\n    fibo = [ 0 ] * ( n + 1 ) ;\n    if ( n <= 0 ) :\n        return 0 ;\n    fibo [ 0 ] = 0 ;\n    fibo [ 1 ] = 1 ;\n    sum = ( ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ) ;\n    for i in range ( 2 , n + 1 ) :\n        fibo [ i ] = ( fibo [ i - 1 ] + fibo [ i - 2 ] ) ;\n        sum += ( fibo [ i ] * fibo [ i ] ) ;\n    return sum ;\nn = 6 ;\nprint ( \"Sum of squares of Fibonacci numbers is :\" , calculateSquareSum ( n ) ) ;\n", "python_code_tokenized": "def calculateSquareSum ( n ) : NEW_LINE INDENT fibo = [ 0 ] * ( n + 1 ) ; NEW_LINE if ( n <= 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT fibo [ 0 ] = 0 ; NEW_LINE fibo [ 1 ] = 1 ; NEW_LINE sum = ( ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = ( fibo [ i - 1 ] + fibo [ i - 2 ] ) ; NEW_LINE sum += ( fibo [ i ] * fibo [ i ] ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( \" Sum \u2581 of \u2581 squares \u2581 of \u2581 Fibonacci \u2581 numbers \u2581 is \u2581 : \" , calculateSquareSum ( n ) ) ; NEW_LINE"}
{"id": "codeforces_1463_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    a = list ( map ( int , input ( ).split ( ) ) )\n    sodd = 0\n    seven = 0\n    for i in range ( n ) :\n        if i % 2 == 0 :\n            sodd += a [ i ]\n        else :\n            seven += a [ i ]\n    res = [ ]\n    if sodd <= seven :\n        for i in range ( n ) :\n            if i % 2 == 0 :\n                res.append ( 1 )\n            else :\n                res.append ( a [ i ] )\n    else :\n        for i in range ( n ) :\n            if i % 2 == 0 :\n                res.append ( a [ i ] )\n            else :\n                res.append ( 1 )\n    print ( * res )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sodd = 0 NEW_LINE seven = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT sodd += a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT seven += a [ i ] NEW_LINE DEDENT DEDENT res = [ ] NEW_LINE if sodd <= seven : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT res . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( a [ i ] ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT res . append ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( * res ) NEW_LINE DEDENT"}
{"id": "codeforces_1312_B", "sol": 0, "python_code": "exec ( int ( input ( ) ) * 'input();print(*sorted(input().split(),key=int)[::-1]);' )\n", "python_code_tokenized": "exec ( int ( input ( ) ) * ' input ( ) ; print ( * sorted ( input ( ) . split ( ) , key = int ) [ : : - 1 ] ) ; ' ) NEW_LINE"}
{"id": "codeforces_990_B", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nl = sorted ( map ( int , input ( ).split ( ) ) )\nj = 0\nfor i in l :\n    while l [ j ] < i :\n        if i <= k + l [ j ] : n -= 1\n        j += 1\nprint ( n )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE j = 0 NEW_LINE for i in l : NEW_LINE INDENT while l [ j ] < i : NEW_LINE INDENT if i <= k + l [ j ] : n -= 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE"}
{"id": "codeforces_69_A", "sol": 0, "python_code": "def main ( ) :\n    n = int ( input ( ) )\n    X , Y , Z = 0 , 0 , 0\n    for _ in range ( n ) :\n        x , y , z = list ( map ( int , input ( ).split ( ) ) )\n        X += x\n        Y += y\n        Z += z\n    if X == Y == Z == 0 :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\nif __name__ == \"__main__\" :\n    main ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE X , Y , Z = 0 , 0 , 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , y , z = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE X += x NEW_LINE Y += y NEW_LINE Z += z NEW_LINE DEDENT if X == Y == Z == 0 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1727_A", "sol": 0, "python_code": "def centered_square_num ( n ) :\n    return n * n + ( ( n - 1 ) * ( n - 1 ) )\nn = 7\nprint ( \"%sth Centered square number: \" % n , centered_square_num ( n ) )\n", "python_code_tokenized": "def centered_square_num ( n ) : NEW_LINE INDENT return n * n + ( ( n - 1 ) * ( n - 1 ) ) NEW_LINE DEDENT n = 7 NEW_LINE print ( \" % sth \u2581 Centered \u2581 square \u2581 number : \u2581 \" % n , centered_square_num ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1354_A", "sol": 0, "python_code": "def findMaximumDiff ( a , n ) :\n    ind1 = 0\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        if ( a [ 0 ] != a [ i ] ) :\n            ind1 = i\n            break\n    ind2 = 0\n    for i in range ( n - 1 ) :\n        if ( a [ n - 1 ] != a [ i ] ) :\n            ind2 = ( n - 1 - i )\n            break\n    return max ( ind1 , ind2 )\na = [ 1 , 2 , 3 , 2 , 3 ]\nn = len ( a )\nprint ( findMaximumDiff ( a , n ) )\n", "python_code_tokenized": "def findMaximumDiff ( a , n ) : NEW_LINE INDENT ind1 = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ 0 ] != a [ i ] ) : NEW_LINE INDENT ind1 = i NEW_LINE break NEW_LINE DEDENT DEDENT ind2 = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ n - 1 ] != a [ i ] ) : NEW_LINE INDENT ind2 = ( n - 1 - i ) NEW_LINE break NEW_LINE DEDENT DEDENT return max ( ind1 , ind2 ) NEW_LINE DEDENT a = [ 1 , 2 , 3 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMaximumDiff ( a , n ) ) NEW_LINE"}
{"id": "aizu_p00162_A", "sol": 0, "python_code": "import sys\nfrom sys import stdin\nfrom bisect import bisect_right , bisect_left\ninput = stdin.readline\ndef main ( args ) :\n    hammings = [ ]\n    temp = set ( )\n    for i in range ( 21 ) :\n        for j in range ( 14 ) :\n            for k in range ( 9 ) :\n                ans = 2 ** i * 3 ** j * 5 ** k\n                temp.add ( ans )\n    hammings = list ( temp )\n    hammings.sort ( )\n    while True :\n        try :\n            m , n = map ( int , input ( ).split ( ' ' ) )\n        except ValueError :\n            break\n        s = bisect_left ( hammings , m )\n        t = bisect_right ( hammings , n )\n        print ( t - s )\nif __name__ == '__main__' :\n    main ( sys.argv [ 1 : ] )\n", "python_code_tokenized": "import sys NEW_LINE from sys import stdin NEW_LINE from bisect import bisect_right , bisect_left NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT hammings = [ ] NEW_LINE temp = set ( ) NEW_LINE for i in range ( 21 ) : NEW_LINE INDENT for j in range ( 14 ) : NEW_LINE INDENT for k in range ( 9 ) : NEW_LINE INDENT ans = 2 ** i * 3 ** j * 5 ** k NEW_LINE temp . add ( ans ) NEW_LINE DEDENT DEDENT DEDENT hammings = list ( temp ) NEW_LINE hammings . sort ( ) NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ' \u2581 ' ) ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT break NEW_LINE DEDENT s = bisect_left ( hammings , m ) NEW_LINE t = bisect_right ( hammings , n ) NEW_LINE print ( t - s ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT"}
{"id": "aizu_p01754_A", "sol": 0, "python_code": "n , p , q = map ( int , input ( ).split ( ) )\nb = [ 0 ] * n\nfor i in range ( n ) : b [ i ] = p * i + int ( input ( ) )\nb.sort ( )\na = q * p * n + p * n * ~ - n // 2 ; s = 0\nfor i in range ( 1 , - ~ n ) :\n    s += b [ n - i ]\n    a = max ( a , p * q * ( n - i ) + p * ( n - i ) * ( ~ - n - i ) // 2 - p * i * ( i - 1 ) // 2 - p * i * ( n - i ) + s )\nprint ( a )\n", "python_code_tokenized": "n , p , q = map ( int , input ( ) . split ( ) ) NEW_LINE b = [ 0 ] * n NEW_LINE for i in range ( n ) : b [ i ] = p * i + int ( input ( ) ) NEW_LINE b . sort ( ) NEW_LINE a = q * p * n + p * n * ~ - n // 2 ; s = 0 NEW_LINE for i in range ( 1 , - ~ n ) : NEW_LINE INDENT s += b [ n - i ] NEW_LINE a = max ( a , p * q * ( n - i ) + p * ( n - i ) * ( ~ - n - i ) // 2 - p * i * ( i - 1 ) // 2 - p * i * ( n - i ) + s ) NEW_LINE DEDENT print ( a ) NEW_LINE"}
{"id": "geeksforgeeks_5219_A", "sol": 0, "python_code": "import sys\ndef getMinimumSum ( arr , n ) :\n    ans = sys.maxsize ;\n    for i in range ( n - 2 ) :\n        for j in range ( i + 1 , n - 1 ) :\n            for k in range ( j + 1 , n ) :\n                ans = min ( ans , arr [ i ] + arr [ j ] + arr [ k ] ) ;\n    return ans ;\nif __name__ == '__main__' :\n    arr = [ 1 , 2 , 3 , 4 , 5 , - 1 , 5 , - 2 ] ;\n    n = len ( arr ) ;\n    print ( getMinimumSum ( arr , n ) ) ;\n", "python_code_tokenized": "import sys NEW_LINE def getMinimumSum ( arr , n ) : NEW_LINE INDENT ans = sys . maxsize ; NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT ans = min ( ans , arr [ i ] + arr [ j ] + arr [ k ] ) ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , - 1 , 5 , - 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getMinimumSum ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "aizu_p01300_A", "sol": 0, "python_code": "import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools\nsys.setrecursionlimit ( 10 ** 7 )\ninf = 10 ** 20\neps = 1.0 / 10 ** 10\nmod = 10 ** 9 + 7\ndd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ]\nddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ]\ndef LI ( ) : return [ int ( x ) for x in sys.stdin.readline ( ).split ( ) ]\ndef LI_ ( ) : return [ int ( x ) - 1 for x in sys.stdin.readline ( ).split ( ) ]\ndef LF ( ) : return [ float ( x ) for x in sys.stdin.readline ( ).split ( ) ]\ndef LS ( ) : return sys.stdin.readline ( ).split ( )\ndef I ( ) : return int ( sys.stdin.readline ( ) )\ndef F ( ) : return float ( sys.stdin.readline ( ) )\ndef S ( ) : return input ( )\ndef pf ( s ) : return print ( s , flush = True )\ndef main ( ) :\n    rr = [ ]\n    while True :\n        s = S ( )\n        if s == '0' :\n            break\n        d = collections.defaultdict ( int )\n        r = 0\n        for c in s :\n            c = int ( c )\n            nd = collections.defaultdict ( int )\n            for k , v in d.items ( ) :\n                nd [ ( k * 10 + c ) % 11 ] = v\n            if c > 0 :\n                nd [ c ] += 1\n            r += nd [ 0 ]\n            d = nd\n        rr.append ( r )\n    return '\\n'.join ( map ( str , rr ) )\nprint ( main ( ) )\n", "python_code_tokenized": "import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 / 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] NEW_LINE ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT rr = [ ] NEW_LINE while True : NEW_LINE INDENT s = S ( ) NEW_LINE if s == '0' : NEW_LINE INDENT break NEW_LINE DEDENT d = collections . defaultdict ( int ) NEW_LINE r = 0 NEW_LINE for c in s : NEW_LINE INDENT c = int ( c ) NEW_LINE nd = collections . defaultdict ( int ) NEW_LINE for k , v in d . items ( ) : NEW_LINE INDENT nd [ ( k * 10 + c ) % 11 ] = v NEW_LINE DEDENT if c > 0 : NEW_LINE INDENT nd [ c ] += 1 NEW_LINE DEDENT r += nd [ 0 ] NEW_LINE d = nd NEW_LINE DEDENT rr . append ( r ) NEW_LINE DEDENT return ' \\n ' . join ( map ( str , rr ) ) NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"}
{"id": "geeksforgeeks_4377_A", "sol": 0, "python_code": "def NumberOfSolutions ( x , y , z , n ) :\n    ans = 0\n    for i in range ( x + 1 ) :\n        for j in range ( y + 1 ) :\n            temp = n - i - j\n            if temp >= 0 :\n                temp = min ( temp , z )\n                ans += temp + 1\n    return ans\nif __name__ == \"__main__\" :\n    x , y , z , n = 1 , 2 , 3 , 4\n    print ( NumberOfSolutions ( x , y , z , n ) )\n", "python_code_tokenized": "def NumberOfSolutions ( x , y , z , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT temp = n - i - j NEW_LINE if temp >= 0 : NEW_LINE INDENT temp = min ( temp , z ) NEW_LINE ans += temp + 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x , y , z , n = 1 , 2 , 3 , 4 NEW_LINE print ( NumberOfSolutions ( x , y , z , n ) ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC041_D", "sol": 0, "python_code": "N , M = map ( int , input ( ).split ( ) )\nDP = [ [ - 1 ] * 6000 for i in range ( 6000 ) ]\ndef P ( n , k ) :\n    if n < 0 or k < 1 :\n        return 0\n    if DP [ n ] [ k ] != - 1 :\n        return DP [ n ] [ k ]\n    if k == 1 :\n        DP [ n ] [ k ] = 1\n        return 1\n    DP [ n ] [ k ] = ( P ( n , k - 1 ) + P ( n - k , k ) ) % M\n    return DP [ n ] [ k ]\nfor i in range ( 5500 ) :\n    for j in range ( i + 1 ) :\n        P ( i + 1 , j + 1 )\nX = [ 0 ]\nDP [ 0 ] [ 0 ] = 1\nfor i in range ( 5500 ) :\n    X.append ( 0 )\n    for j in range ( i + 1 ) :\n        X [ - 1 ] = ( X [ - 1 ] + DP [ j ] [ j ] * DP [ i - j ] [ i - j ] ) % M\nY = [ 0 ]\nfor i in range ( 10800 ) :\n    Y.append ( Y [ i ] + X [ i >> 1 ] )\nP = 0\nfor i in range ( 1 , N + 1 ) :\n    P = ( P + X [ i ] ) % M\n    if 2 * i > N :\n        P = ( P - Y [ 2 * i - N ] ) % M\nprint ( P )\n", "python_code_tokenized": "N , M = map ( int , input ( ) . split ( ) ) NEW_LINE DP = [ [ - 1 ] * 6000 for i in range ( 6000 ) ] NEW_LINE def P ( n , k ) : NEW_LINE INDENT if n < 0 or k < 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if DP [ n ] [ k ] != - 1 : NEW_LINE INDENT return DP [ n ] [ k ] NEW_LINE DEDENT if k == 1 : NEW_LINE INDENT DP [ n ] [ k ] = 1 NEW_LINE return 1 NEW_LINE DEDENT DP [ n ] [ k ] = ( P ( n , k - 1 ) + P ( n - k , k ) ) % M NEW_LINE return DP [ n ] [ k ] NEW_LINE DEDENT for i in range ( 5500 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT P ( i + 1 , j + 1 ) NEW_LINE DEDENT DEDENT X = [ 0 ] NEW_LINE DP [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 5500 ) : NEW_LINE INDENT X . append ( 0 ) NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT X [ - 1 ] = ( X [ - 1 ] + DP [ j ] [ j ] * DP [ i - j ] [ i - j ] ) % M NEW_LINE DEDENT DEDENT Y = [ 0 ] NEW_LINE for i in range ( 10800 ) : NEW_LINE INDENT Y . append ( Y [ i ] + X [ i >> 1 ] ) NEW_LINE DEDENT P = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT P = ( P + X [ i ] ) % M NEW_LINE if 2 * i > N : NEW_LINE INDENT P = ( P - Y [ 2 * i - N ] ) % M NEW_LINE DEDENT DEDENT print ( P ) NEW_LINE"}
{"id": "codeforces_254_A", "sol": 0, "python_code": "from collections import defaultdict\nimport sys\nsys.stdin = open ( \"input.txt\" , \"r\" )\nsys.stdout = open ( \"output.txt\" , \"w\" )\nn = int ( input ( ) ) * 2\na = [ int ( i ) for i in input ( ).split ( ) ]\nc = defaultdict ( list )\nfor i in range ( n ) :\n    c [ a [ i ] ].append ( i + 1 )\nans = [ ]\nfor [ k , v ] in c.items ( ) :\n    l = len ( v )\n    if l % 2 :\n        print ( '-1' )\n        exit ( )\n    else :\n        for i in range ( 0 , l - 1 , 2 ) :\n            ans.append ( f'{v[i]} {v[i+1]}' )\nprint ( '\\n'.join ( ans ) )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE import sys NEW_LINE sys . stdin = open ( \" input . txt \" , \" r \" ) NEW_LINE sys . stdout = open ( \" output . txt \" , \" w \" ) NEW_LINE n = int ( input ( ) ) * 2 NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE c = defaultdict ( list ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ a [ i ] ] . append ( i + 1 ) NEW_LINE DEDENT ans = [ ] NEW_LINE for [ k , v ] in c . items ( ) : NEW_LINE INDENT l = len ( v ) NEW_LINE if l % 2 : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , l - 1 , 2 ) : NEW_LINE INDENT ans . append ( f ' { v [ i ] } \u2581 { v [ i + 1 ] } ' ) NEW_LINE DEDENT DEDENT DEDENT print ( ' \\n ' . join ( ans ) ) NEW_LINE"}
{"id": "atcoder_ABC066_D", "sol": 0, "python_code": "N = int ( input ( ) )\nA = [ int ( x ) for x in input ( ).split ( ) ]\nse = [ ]\nc = sum ( A ) - N * ( N + 1 ) / 2\nfor i in range ( len ( A ) ) :\n    if A [ i ] == c :\n        se.append ( i )\nl = se [ 0 ]\nr = se [ 1 ]\nmod = 10 ** 9 + 7\nfactorial = [ 1 ]\ninverse = [ 1 ]\nfor i in range ( 1 , N + 2 ) :\n    factorial.append ( factorial [ - 1 ] * i % mod )\n    inverse.append ( ( pow ( factorial [ i ] , mod - 2 , mod ) ) )\ndef nCr ( n , r ) :\n    if n < r or n == 0 or r == 0 :\n        return 0\n    return factorial [ n ] * inverse [ r ] * inverse [ n - r ] % mod\nprint ( N )\nfor i in range ( 2 , N + 2 ) :\n    print ( int ( nCr ( N + 1 , i ) - nCr ( l + N - r , i - 1 ) ) % mod )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE A = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE se = [ ] NEW_LINE c = sum ( A ) - N * ( N + 1 ) / 2 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if A [ i ] == c : NEW_LINE INDENT se . append ( i ) NEW_LINE DEDENT DEDENT l = se [ 0 ] NEW_LINE r = se [ 1 ] NEW_LINE mod = 10 ** 9 + 7 NEW_LINE factorial = [ 1 ] NEW_LINE inverse = [ 1 ] NEW_LINE for i in range ( 1 , N + 2 ) : NEW_LINE INDENT factorial . append ( factorial [ - 1 ] * i % mod ) NEW_LINE inverse . append ( ( pow ( factorial [ i ] , mod - 2 , mod ) ) ) NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT if n < r or n == 0 or r == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return factorial [ n ] * inverse [ r ] * inverse [ n - r ] % mod NEW_LINE DEDENT print ( N ) NEW_LINE for i in range ( 2 , N + 2 ) : NEW_LINE INDENT print ( int ( nCr ( N + 1 , i ) - nCr ( l + N - r , i - 1 ) ) % mod ) NEW_LINE DEDENT"}
{"id": "aizu_p00613_A", "sol": 0, "python_code": "while True :\n    K = int ( input ( ) )\n    if K == 0 : break\n    print ( sum ( list ( map ( int , input ( ).split ( ) ) ) ) // ( K - 1 ) )\n", "python_code_tokenized": "while True : NEW_LINE INDENT K = int ( input ( ) ) NEW_LINE if K == 0 : break NEW_LINE print ( sum ( list ( map ( int , input ( ) . split ( ) ) ) ) // ( K - 1 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1646_A", "sol": 0, "python_code": "def maxSubArraySumRepeated ( a , n , k ) :\n    max_so_far = - 2147483648\n    max_ending_here = 0\n    for i in range ( n * k ) :\n        max_ending_here = max_ending_here + a [ i % n ]\n        if ( max_so_far < max_ending_here ) :\n            max_so_far = max_ending_here\n        if ( max_ending_here < 0 ) :\n            max_ending_here = 0\n    return max_so_far\na = [ 10 , 20 , - 30 , - 1 ]\nn = len ( a )\nk = 3\nprint ( \"Maximum contiguous sum is \" , maxSubArraySumRepeated ( a , n , k ) )\n", "python_code_tokenized": "def maxSubArraySumRepeated ( a , n , k ) : NEW_LINE INDENT max_so_far = - 2147483648 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( n * k ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i % n ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT a = [ 10 , 20 , - 30 , - 1 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print ( \" Maximum \u2581 contiguous \u2581 sum \u2581 is \u2581 \" , maxSubArraySumRepeated ( a , n , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_4274_A", "sol": 0, "python_code": "def checkYear ( year ) :\n    return ( ( ( year % 4 == 0 ) and ( year % 100 != 0 ) ) or ( year % 400 == 0 ) ) ;\nyear = 2000\nif ( checkYear ( year ) ) :\n    print ( \"Leap Year\" )\nelse :\n    print ( \"Not a Leap Year\" )\n", "python_code_tokenized": "def checkYear ( year ) : NEW_LINE INDENT return ( ( ( year % 4 == 0 ) and ( year % 100 != 0 ) ) or ( year % 400 == 0 ) ) ; NEW_LINE DEDENT year = 2000 NEW_LINE if ( checkYear ( year ) ) : NEW_LINE INDENT print ( \" Leap \u2581 Year \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 a \u2581 Leap \u2581 Year \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4273_A", "sol": 0, "python_code": "def checkYear ( year ) :\n    if ( year % 4 ) == 0 :\n        if ( year % 100 ) == 0 :\n            if ( year % 400 ) == 0 :\n                return True\n            else :\n                return False\n        else :\n            return True\n    else :\n        return False\nyear = 2000\nif ( checkYear ( year ) ) :\n    print ( \"Leap Year\" )\nelse :\n    print ( \"Not a Leap Year\" )\n", "python_code_tokenized": "def checkYear ( year ) : NEW_LINE INDENT if ( year % 4 ) == 0 : NEW_LINE INDENT if ( year % 100 ) == 0 : NEW_LINE INDENT if ( year % 400 ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT year = 2000 NEW_LINE if ( checkYear ( year ) ) : NEW_LINE INDENT print ( \" Leap \u2581 Year \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 a \u2581 Leap \u2581 Year \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1499_A", "sol": 0, "python_code": "for i in range ( int ( input ( ) ) ) :\n    n , k1 , k2 = map ( int , input ( ).split ( ) )\n    w , b = map ( int , input ( ).split ( ) )\n    p = k1 + k2\n    m = 2 * n\n    q = m - p\n    if p >= 2 * w and q >= 2 * b :\n        print ( 'YES' )\n    else :\n        print ( 'NO' )\n", "python_code_tokenized": "for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k1 , k2 = map ( int , input ( ) . split ( ) ) NEW_LINE w , b = map ( int , input ( ) . split ( ) ) NEW_LINE p = k1 + k2 NEW_LINE m = 2 * n NEW_LINE q = m - p NEW_LINE if p >= 2 * w and q >= 2 * b : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00850_A", "sol": 0, "python_code": "from collections import deque\nnumber_list = [ float ( \"inf\" ) for i in range ( 1000 + 1 ) ]\nnumber_list [ 1 ] = 0\nque = deque ( [ [ 1 , [ 1 ] , 0 ] ] )\nwhile len ( que ) > 0 :\n    n , array , depth = que.popleft ( )\n    if depth > 16 :\n        continue\n    for i in array :\n        if n + i <= 1000 and number_list [ n + i ] >= depth + 1 :\n            number_list [ n + i ] = depth + 1\n            que.append ( [ n + i , array + [ n + i ] , depth + 1 ] )\n        if n - i > 0 and number_list [ n - i ] >= depth + 1 :\n            number_list [ n - i ] = depth + 1\n            que.append ( [ n - i , array + [ n - i ] , depth + 1 ] )\nwhile True :\n    N = int ( input ( ) )\n    if N == 0 :\n        break\n    print ( number_list [ N ] )\n", "python_code_tokenized": "from collections import deque NEW_LINE number_list = [ float ( \" inf \" ) for i in range ( 1000 + 1 ) ] NEW_LINE number_list [ 1 ] = 0 NEW_LINE que = deque ( [ [ 1 , [ 1 ] , 0 ] ] ) NEW_LINE while len ( que ) > 0 : NEW_LINE INDENT n , array , depth = que . popleft ( ) NEW_LINE if depth > 16 : NEW_LINE INDENT continue NEW_LINE DEDENT for i in array : NEW_LINE INDENT if n + i <= 1000 and number_list [ n + i ] >= depth + 1 : NEW_LINE INDENT number_list [ n + i ] = depth + 1 NEW_LINE que . append ( [ n + i , array + [ n + i ] , depth + 1 ] ) NEW_LINE DEDENT if n - i > 0 and number_list [ n - i ] >= depth + 1 : NEW_LINE INDENT number_list [ n - i ] = depth + 1 NEW_LINE que . append ( [ n - i , array + [ n - i ] , depth + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( number_list [ N ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4226_A", "sol": 0, "python_code": "from math import log10\ndef rightRotationDivisor ( N ) :\n    lastDigit = N % 10\n    rightRotation = ( lastDigit * 10 ** int ( log10 ( N ) ) + N // 10 )\n    return rightRotation % N == 0\ndef generateNumbers ( m ) :\n    for i in range ( 10 ** ( m - 1 ) , 10 ** m ) :\n        if rightRotationDivisor ( i ) :\n            print ( i )\nm = 3\ngenerateNumbers ( m )\n", "python_code_tokenized": "from math import log10 NEW_LINE def rightRotationDivisor ( N ) : NEW_LINE INDENT lastDigit = N % 10 NEW_LINE rightRotation = ( lastDigit * 10 ** int ( log10 ( N ) ) + N // 10 ) NEW_LINE return rightRotation % N == 0 NEW_LINE DEDENT def generateNumbers ( m ) : NEW_LINE INDENT for i in range ( 10 ** ( m - 1 ) , 10 ** m ) : NEW_LINE INDENT if rightRotationDivisor ( i ) : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT DEDENT m = 3 NEW_LINE generateNumbers ( m ) NEW_LINE"}
{"id": "geeksforgeeks_3484_A", "sol": 0, "python_code": "class Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.left = None\n        self.right = None\ndef updateParent ( parent , node ) :\n    if ( node == None ) :\n        return parent\n    if ( node.left != None ) :\n        parent [ node.left.data ] = node.data\n    if ( node.right != None ) :\n        parent [ node.right.data ] = node.data\n    parent = updateParent ( parent , node.left )\n    parent = updateParent ( parent , node.right )\n    return parent\ndef getMaxXor ( root , n , val , x ) :\n    parent = [ 0 ] * ( n + 1 )\n    parent = updateParent ( parent , root )\n    maximum = x ^ val\n    val = parent [ val ]\n    while ( val != 0 ) :\n        maximum = max ( maximum , x ^ val )\n        val = parent [ val ]\n    return maximum\nn = 6\nroot = Node ( 1 )\nroot.left = Node ( 2 )\nroot.right = Node ( 3 )\nroot.left.left = Node ( 4 )\nroot.right.right = Node ( 5 )\nroot.right.right.left = Node ( 6 )\nval = 6\nx = 4\nprint ( getMaxXor ( root , n , val , x ) )\n", "python_code_tokenized": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def updateParent ( parent , node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return parent NEW_LINE DEDENT if ( node . left != None ) : NEW_LINE INDENT parent [ node . left . data ] = node . data NEW_LINE DEDENT if ( node . right != None ) : NEW_LINE INDENT parent [ node . right . data ] = node . data NEW_LINE DEDENT parent = updateParent ( parent , node . left ) NEW_LINE parent = updateParent ( parent , node . right ) NEW_LINE return parent NEW_LINE DEDENT def getMaxXor ( root , n , val , x ) : NEW_LINE INDENT parent = [ 0 ] * ( n + 1 ) NEW_LINE parent = updateParent ( parent , root ) NEW_LINE maximum = x ^ val NEW_LINE val = parent [ val ] NEW_LINE while ( val != 0 ) : NEW_LINE INDENT maximum = max ( maximum , x ^ val ) NEW_LINE val = parent [ val ] NEW_LINE DEDENT return maximum NEW_LINE DEDENT n = 6 NEW_LINE root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . right . right = Node ( 5 ) NEW_LINE root . right . right . left = Node ( 6 ) NEW_LINE val = 6 NEW_LINE x = 4 NEW_LINE print ( getMaxXor ( root , n , val , x ) ) NEW_LINE"}
{"id": "codeforces_754_B", "sol": 0, "python_code": "first = input ( )\nsecond = input ( )\nthird = input ( )\nfourth = input ( )\nrows = first + \"-\" + second + \"-\" + third + \"-\" + fourth\nif \"xx.\" in rows or \".xx\" in rows or \"x.x\" in rows :\n    print ( \"YES\" )\nelse :\n    columns = first [ 0 ] + second [ 1 ] + third [ 2 ] + fourth [ 3 ] + \"-\" + first [ 3 ] + second [ 2 ] + third [ 1 ] + fourth [ 0 ] + \"-\" + second [ 0 ] + third [ 1 ] + fourth [ 2 ] + \"-\" + second [ 3 ] + third [ 2 ] + fourth [ 1 ] + \"-\" + first [ 2 ] + second [ 1 ] + third [ 0 ] + \"-\" + first [ 1 ] + second [ 2 ] + third [ 3 ] + \"-\"\n    for i in range ( 4 ) :\n        columns += first [ i ] + second [ i ] + third [ i ] + fourth [ i ] + \"-\"\n    if \"xx.\" in columns or \".xx\" in columns or \"x.x\" in columns :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "first = input ( ) NEW_LINE second = input ( ) NEW_LINE third = input ( ) NEW_LINE fourth = input ( ) NEW_LINE rows = first + \" - \" + second + \" - \" + third + \" - \" + fourth NEW_LINE if \" xx . \" in rows or \" . xx \" in rows or \" x . x \" in rows : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT columns = first [ 0 ] + second [ 1 ] + third [ 2 ] + fourth [ 3 ] + \" - \" + first [ 3 ] + second [ 2 ] + third [ 1 ] + fourth [ 0 ] + \" - \" + second [ 0 ] + third [ 1 ] + fourth [ 2 ] + \" - \" + second [ 3 ] + third [ 2 ] + fourth [ 1 ] + \" - \" + first [ 2 ] + second [ 1 ] + third [ 0 ] + \" - \" + first [ 1 ] + second [ 2 ] + third [ 3 ] + \" - \" NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT columns += first [ i ] + second [ i ] + third [ i ] + fourth [ i ] + \" - \" NEW_LINE DEDENT if \" xx . \" in columns or \" . xx \" in columns or \" x . x \" in columns : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1568_A", "sol": 0, "python_code": "def countNonIncreasing ( arr , n ) :\n    cnt = 0 ;\n    len = 1 ;\n    for i in range ( 0 , n - 1 ) :\n        if ( arr [ i + 1 ] >= arr [ i ] ) :\n            len += 1 ;\n        else :\n            cnt += ( ( ( len + 1 ) * len ) / 2 ) ;\n            len = 1 ;\n    if ( len > 1 ) :\n        cnt += ( ( ( len - 1 ) * len ) / 2 ) ;\n    return int ( cnt ) ;\nif __name__ == '__main__' :\n    arr = [ 5 , 2 , 3 , 7 , 1 , 1 ] ;\n    n = len ( arr ) ;\n    print ( countNonIncreasing ( arr , n ) ) ;\n", "python_code_tokenized": "def countNonIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE len = 1 ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] >= arr [ i ] ) : NEW_LINE INDENT len += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) / 2 ) ; NEW_LINE len = 1 ; NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) / 2 ) ; NEW_LINE DEDENT return int ( cnt ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 2 , 3 , 7 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countNonIncreasing ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4035_A", "sol": 0, "python_code": "def isDivisible ( str , k ) :\n    n = len ( str )\n    c = 0\n    for i in range ( 0 , k ) :\n        if ( str [ n - i - 1 ] == '0' ) :\n            c += 1\n    return ( c == k )\nstr1 = \"10101100\"\nk = 2\nif ( isDivisible ( str1 , k ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\nstr2 = \"111010100\"\nk = 2\nif ( isDivisible ( str2 , k ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT str1 = \"10101100\" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str1 , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT str2 = \"111010100\" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str2 , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC145_B", "sol": 0, "python_code": "n = int ( input ( ) )\ns = input ( )\nif n % 2 != 0 : print ( 'No' )\nelif s [ : int ( n / 2 ) ] == s [ int ( n / 2 ) : ] : print ( 'Yes' )\nelse : print ( 'No' )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE if n % 2 != 0 : print ( ' No ' ) NEW_LINE elif s [ : int ( n / 2 ) ] == s [ int ( n / 2 ) : ] : print ( ' Yes ' ) NEW_LINE else : print ( ' No ' ) NEW_LINE"}
{"id": "geeksforgeeks_4638_A", "sol": 0, "python_code": "def wordReverse ( str ) :\n    i = len ( str ) - 1\n    start = end = i + 1\n    result = ''\n    while i >= 0 :\n        if str [ i ] == ' ' :\n            start = i + 1\n            while start != end :\n                result += str [ start ]\n                start += 1\n            result += ' '\n            end = i\n        i -= 1\n    start = 0\n    while start != end :\n        result += str [ start ]\n        start += 1\n    return result\nstr = 'I AM A GEEK'\nprint ( wordReverse ( str ) )\n", "python_code_tokenized": "def wordReverse ( str ) : NEW_LINE INDENT i = len ( str ) - 1 NEW_LINE start = end = i + 1 NEW_LINE result = ' ' NEW_LINE while i >= 0 : NEW_LINE INDENT if str [ i ] == ' \u2581 ' : NEW_LINE INDENT start = i + 1 NEW_LINE while start != end : NEW_LINE INDENT result += str [ start ] NEW_LINE start += 1 NEW_LINE DEDENT result += ' \u2581 ' NEW_LINE end = i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT start = 0 NEW_LINE while start != end : NEW_LINE INDENT result += str [ start ] NEW_LINE start += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT str = ' I \u2581 AM \u2581 A \u2581 GEEK ' NEW_LINE print ( wordReverse ( str ) ) NEW_LINE"}
{"id": "geeksforgeeks_3906_A", "sol": 0, "python_code": "def isPalindrome ( str , i , j ) :\n    while ( i < j ) :\n        if ( str [ i ] != str [ j ] ) :\n            return False ;\n        i += 1 ;\n        j -= 1 ;\n    return True ;\ndef maxLenPalindrome ( str , n , ch ) :\n    maxLen = 0 ;\n    for i in range ( n ) :\n        if ( str [ i ] == ch ) :\n            for j in range ( n - 1 , i + 1 , - 1 ) :\n                if ( str [ j ] == ch ) :\n                    if ( isPalindrome ( str , i , j ) ) :\n                        maxLen = max ( maxLen , j - i + 1 ) ;\n                        break ;\n    return maxLen ;\nstr = \"lapqooqpqpl\" ;\nn = len ( str ) ;\nch = 'p' ;\nprint ( maxLenPalindrome ( str , n , ch ) ) ;\n", "python_code_tokenized": "def isPalindrome ( str , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def maxLenPalindrome ( str , n , ch ) : NEW_LINE INDENT maxLen = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == ch ) : NEW_LINE INDENT for j in range ( n - 1 , i + 1 , - 1 ) : NEW_LINE INDENT if ( str [ j ] == ch ) : NEW_LINE INDENT if ( isPalindrome ( str , i , j ) ) : NEW_LINE INDENT maxLen = max ( maxLen , j - i + 1 ) ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return maxLen ; NEW_LINE DEDENT str = \" lapqooqpqpl \" ; NEW_LINE n = len ( str ) ; NEW_LINE ch = ' p ' ; NEW_LINE print ( maxLenPalindrome ( str , n , ch ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_1570_A", "sol": 0, "python_code": "MAX_CHAR = 256\ndef countSub ( ss ) :\n    last = [ - 1 for i in range ( MAX_CHAR + 1 ) ]\n    n = len ( ss )\n    dp = [ - 2 for i in range ( n + 1 ) ]\n    dp [ 0 ] = 1\n    for i in range ( 1 , n + 1 ) :\n        dp [ i ] = 2 * dp [ i - 1 ]\n        if last [ ord ( ss [ i - 1 ] ) ] != - 1 :\n            dp [ i ] = dp [ i ] - dp [ last [ ord ( ss [ i - 1 ] ) ] ]\n        last [ ord ( ss [ i - 1 ] ) ] = i - 1\n    return dp [ n ]\nprint ( countSub ( \"gfg\" ) )\n", "python_code_tokenized": "MAX_CHAR = 256 NEW_LINE def countSub ( ss ) : NEW_LINE INDENT last = [ - 1 for i in range ( MAX_CHAR + 1 ) ] NEW_LINE n = len ( ss ) NEW_LINE dp = [ - 2 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] = 2 * dp [ i - 1 ] NEW_LINE if last [ ord ( ss [ i - 1 ] ) ] != - 1 : NEW_LINE INDENT dp [ i ] = dp [ i ] - dp [ last [ ord ( ss [ i - 1 ] ) ] ] NEW_LINE DEDENT last [ ord ( ss [ i - 1 ] ) ] = i - 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT print ( countSub ( \" gfg \" ) ) NEW_LINE"}
{"id": "geeksforgeeks_2461_A", "sol": 0, "python_code": "def squarearea ( a , b ) :\n    if ( a < 0 or b < 0 ) :\n        return - 1\n    area = 4 * ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) )\n    return area\nif __name__ == '__main__' :\n    a = 4\n    b = 2\n    print ( squarearea ( a , b ) )\n", "python_code_tokenized": "def squarearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = 4 * ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE b = 2 NEW_LINE print ( squarearea ( a , b ) ) NEW_LINE DEDENT"}
{"id": "projecteuler_p038_A", "sol": 0, "python_code": "def compute ( ) :\n    ans = \"\"\n    for n in range ( 2 , 10 ) :\n        for i in range ( 1 , 10 ** ( 9 // n ) ) :\n            s = \"\".join ( str ( i * j ) for j in range ( 1 , n + 1 ) )\n            if \"\".join ( sorted ( s ) ) == \"123456789\" :\n                ans = max ( s , ans )\n    return ans\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT ans = \" \" NEW_LINE for n in range ( 2 , 10 ) : NEW_LINE INDENT for i in range ( 1 , 10 ** ( 9 // n ) ) : NEW_LINE INDENT s = \" \" . join ( str ( i * j ) for j in range ( 1 , n + 1 ) ) NEW_LINE if \" \" . join ( sorted ( s ) ) == \"123456789\" : NEW_LINE INDENT ans = max ( s , ans ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_899_A", "sol": 0, "python_code": "def solution ( n , arr ) :\n    ans = 0\n    num_of_ones = 0\n    num_of_twos = 0\n    for i in range ( n ) :\n        if arr [ i ] == 1 :\n            num_of_ones += 1\n        else :\n            num_of_twos += 1\n    min_val = min ( num_of_ones , num_of_twos )\n    diff = num_of_ones - min_val\n    if diff >= 3 :\n        ans = diff // 3\n    return min_val + ans\nn = int ( input ( ) )\narr = [ int ( x ) for x in input ( ).strip ( ).split ( \" \" ) ]\nprint ( solution ( n , arr ) )\n", "python_code_tokenized": "def solution ( n , arr ) : NEW_LINE INDENT ans = 0 NEW_LINE num_of_ones = 0 NEW_LINE num_of_twos = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT num_of_ones += 1 NEW_LINE DEDENT else : NEW_LINE INDENT num_of_twos += 1 NEW_LINE DEDENT DEDENT min_val = min ( num_of_ones , num_of_twos ) NEW_LINE diff = num_of_ones - min_val NEW_LINE if diff >= 3 : NEW_LINE INDENT ans = diff // 3 NEW_LINE DEDENT return min_val + ans NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE arr = [ int ( x ) for x in input ( ) . strip ( ) . split ( \" \u2581 \" ) ] NEW_LINE print ( solution ( n , arr ) ) NEW_LINE"}
{"id": "geeksforgeeks_1900_A", "sol": 0, "python_code": "import sys\ndef getMin ( arr , n , k ) :\n    res = sys.maxsize\n    for i in range ( n ) :\n        if ( arr [ i ] % k == 0 ) :\n            res = min ( res , arr [ i ] )\n    return res\ndef getMax ( arr , n , k ) :\n    res = 0\n    for i in range ( 1 , n ) :\n        if ( arr [ i ] % k == 0 ) :\n            res = max ( res , arr [ i ] )\n    return res\nif __name__ == \"__main__\" :\n    arr = [ 10 , 1230 , 45 , 67 , 1 ]\n    k = 10\n    n = len ( arr )\n    print ( \"Minimum element of array which\" , \"is divisible by k: \" , getMin ( arr , n , k ) )\n    print ( \"Maximum element of array which\" , \"is divisible by k: \" , getMax ( arr , n , k ) )\n", "python_code_tokenized": "import sys NEW_LINE def getMin ( arr , n , k ) : NEW_LINE INDENT res = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT res = min ( res , arr [ i ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def getMax ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT res = max ( res , arr [ i ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 1230 , 45 , 67 , 1 ] NEW_LINE k = 10 NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum \u2581 element \u2581 of \u2581 array \u2581 which \" , \" is \u2581 divisible \u2581 by \u2581 k : \u2581 \" , getMin ( arr , n , k ) ) NEW_LINE print ( \" Maximum \u2581 element \u2581 of \u2581 array \u2581 which \" , \" is \u2581 divisible \u2581 by \u2581 k : \u2581 \" , getMax ( arr , n , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5047_A", "sol": 0, "python_code": "class Graph :\n    v = None\n    e = None\n    diri = [ ]\n    def __init__ ( self , v , e ) :\n        self.v = v\n        self.e = e\n        self.diri = [ [ 0 for i in range ( v ) ] for j in range ( v ) ]\ndef createGraph ( v , e ) :\n    G = Graph ( v , e )\n    G.diri [ 0 ] [ 1 ] = 1\n    G.diri [ 0 ] [ 2 ] = 1\n    G.diri [ 0 ] [ 3 ] = 1\n    G.diri [ 1 ] [ 0 ] = 1\n    G.diri [ 1 ] [ 3 ] = 1\n    G.diri [ 2 ] [ 0 ] = 1\n    G.diri [ 2 ] [ 3 ] = 1\n    G.diri [ 3 ] [ 0 ] = 1\n    G.diri [ 3 ] [ 1 ] = 1\n    G.diri [ 3 ] [ 2 ] = 1\n    return G\ndef findDegree ( G , ver ) :\n    degree = 0\n    for i in range ( G.v ) :\n        if G.diri [ ver ] [ i ] == 1 :\n            degree += 1\n    return degree\nif __name__ == \"__main__\" :\n    vertices = 4\n    edges = 5\n    G = createGraph ( vertices , edges )\n    ver = 0\n    degree = findDegree ( G , ver )\n    print ( degree )\n", "python_code_tokenized": "class Graph : NEW_LINE INDENT v = None NEW_LINE e = None NEW_LINE diri = [ ] NEW_LINE def __init__ ( self , v , e ) : NEW_LINE INDENT self . v = v NEW_LINE self . e = e NEW_LINE self . diri = [ [ 0 for i in range ( v ) ] for j in range ( v ) ] NEW_LINE DEDENT DEDENT def createGraph ( v , e ) : NEW_LINE INDENT G = Graph ( v , e ) NEW_LINE G . diri [ 0 ] [ 1 ] = 1 NEW_LINE G . diri [ 0 ] [ 2 ] = 1 NEW_LINE G . diri [ 0 ] [ 3 ] = 1 NEW_LINE G . diri [ 1 ] [ 0 ] = 1 NEW_LINE G . diri [ 1 ] [ 3 ] = 1 NEW_LINE G . diri [ 2 ] [ 0 ] = 1 NEW_LINE G . diri [ 2 ] [ 3 ] = 1 NEW_LINE G . diri [ 3 ] [ 0 ] = 1 NEW_LINE G . diri [ 3 ] [ 1 ] = 1 NEW_LINE G . diri [ 3 ] [ 2 ] = 1 NEW_LINE return G NEW_LINE DEDENT def findDegree ( G , ver ) : NEW_LINE INDENT degree = 0 NEW_LINE for i in range ( G . v ) : NEW_LINE INDENT if G . diri [ ver ] [ i ] == 1 : NEW_LINE INDENT degree += 1 NEW_LINE DEDENT DEDENT return degree NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT vertices = 4 NEW_LINE edges = 5 NEW_LINE G = createGraph ( vertices , edges ) NEW_LINE ver = 0 NEW_LINE degree = findDegree ( G , ver ) NEW_LINE print ( degree ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC009_B", "sol": 0, "python_code": "import sys\nsys.setrecursionlimit ( 10 ** 8 )\nn , * a = map ( int , open ( 0 ).read ( ).split ( ) )\nlose_to = [ [ ] for _ in range ( n ) ]\nfor i , x in enumerate ( a , start = 1 ) :\n    lose_to [ x - 1 ].append ( i )\ndef dfs ( x ) :\n    if not lose_to [ x ] :\n        return 0\n    else :\n        s = sorted ( [ dfs ( y ) for y in lose_to [ x ] ] , reverse = True )\n        return max ( i + z for i , z in enumerate ( s , start = 1 ) )\nprint ( dfs ( 0 ) )\n", "python_code_tokenized": "import sys NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE lose_to = [ [ ] for _ in range ( n ) ] NEW_LINE for i , x in enumerate ( a , start = 1 ) : NEW_LINE INDENT lose_to [ x - 1 ] . append ( i ) NEW_LINE DEDENT def dfs ( x ) : NEW_LINE INDENT if not lose_to [ x ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT s = sorted ( [ dfs ( y ) for y in lose_to [ x ] ] , reverse = True ) NEW_LINE return max ( i + z for i , z in enumerate ( s , start = 1 ) ) NEW_LINE DEDENT DEDENT print ( dfs ( 0 ) ) NEW_LINE"}
{"id": "geeksforgeeks_3085_A", "sol": 0, "python_code": "class createNode :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.left = None\n        self.right = None\nflag = [ 0 ]\ndef NthPostordernode ( root , N ) :\n    if ( root == None ) :\n        return\n    if ( flag [ 0 ] <= N [ 0 ] ) :\n        NthPostordernode ( root.left , N )\n        NthPostordernode ( root.right , N )\n        flag [ 0 ] += 1\n        if ( flag [ 0 ] == N [ 0 ] ) :\n            print ( root.data )\nif __name__ == '__main__' :\n    root = createNode ( 25 )\n    root.left = createNode ( 20 )\n    root.right = createNode ( 30 )\n    root.left.left = createNode ( 18 )\n    root.left.right = createNode ( 22 )\n    root.right.left = createNode ( 24 )\n    root.right.right = createNode ( 32 )\n    N = [ 6 ]\n    NthPostordernode ( root , N )\n", "python_code_tokenized": "class createNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT flag = [ 0 ] NEW_LINE def NthPostordernode ( root , N ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( flag [ 0 ] <= N [ 0 ] ) : NEW_LINE INDENT NthPostordernode ( root . left , N ) NEW_LINE NthPostordernode ( root . right , N ) NEW_LINE flag [ 0 ] += 1 NEW_LINE if ( flag [ 0 ] == N [ 0 ] ) : NEW_LINE INDENT print ( root . data ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = createNode ( 25 ) NEW_LINE root . left = createNode ( 20 ) NEW_LINE root . right = createNode ( 30 ) NEW_LINE root . left . left = createNode ( 18 ) NEW_LINE root . left . right = createNode ( 22 ) NEW_LINE root . right . left = createNode ( 24 ) NEW_LINE root . right . right = createNode ( 32 ) NEW_LINE N = [ 6 ] NEW_LINE NthPostordernode ( root , N ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3692_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    if ( a == 0 ) :\n        return b\n    else :\n        return gcd ( b % a , a )\ndef solve ( n , m , x , y , a , b ) :\n    g = int ( gcd ( a , b ) )\n    a /= g\n    b /= g\n    k = int ( min ( n / a , m / b ) )\n    x1 = int ( x - ( k * a - k * a / 2 ) )\n    x2 = int ( x + k * a / 2 )\n    y1 = int ( y - ( k * b - k * b / 2 ) )\n    y2 = int ( y + k * b / 2 )\n    if ( int ( x1 ) < 0 ) :\n        x2 -= x1\n        x1 = 0\n    if ( int ( x2 ) > n ) :\n        x1 -= x2 - n\n        x2 = n\n    if ( int ( y1 ) < 0 ) :\n        y2 -= y1\n        y1 = 0\n    if ( int ( y2 ) > m ) :\n        y1 -= y2 - m\n        y2 = m\n    print ( x1 , \"\" , y1 , \"\" , x2 , \"\" , y2 , sep = \"\" )\nn = 70\nm = 10\nx = 20\ny = 5\na = 5\nb = 3\nsolve ( n , m , x , y , a , b )\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b % a , a ) NEW_LINE DEDENT DEDENT def solve ( n , m , x , y , a , b ) : NEW_LINE INDENT g = int ( gcd ( a , b ) ) NEW_LINE a /= g NEW_LINE b /= g NEW_LINE k = int ( min ( n / a , m / b ) ) NEW_LINE x1 = int ( x - ( k * a - k * a / 2 ) ) NEW_LINE x2 = int ( x + k * a / 2 ) NEW_LINE y1 = int ( y - ( k * b - k * b / 2 ) ) NEW_LINE y2 = int ( y + k * b / 2 ) NEW_LINE if ( int ( x1 ) < 0 ) : NEW_LINE INDENT x2 -= x1 NEW_LINE x1 = 0 NEW_LINE DEDENT if ( int ( x2 ) > n ) : NEW_LINE INDENT x1 -= x2 - n NEW_LINE x2 = n NEW_LINE DEDENT if ( int ( y1 ) < 0 ) : NEW_LINE INDENT y2 -= y1 NEW_LINE y1 = 0 NEW_LINE DEDENT if ( int ( y2 ) > m ) : NEW_LINE INDENT y1 -= y2 - m NEW_LINE y2 = m NEW_LINE DEDENT print ( x1 , \" \u2581 \" , y1 , \" \u2581 \" , x2 , \" \u2581 \" , y2 , sep = \" \" ) NEW_LINE DEDENT n = 70 NEW_LINE m = 10 NEW_LINE x = 20 NEW_LINE y = 5 NEW_LINE a = 5 NEW_LINE b = 3 NEW_LINE solve ( n , m , x , y , a , b ) NEW_LINE"}
{"id": "geeksforgeeks_2620_A", "sol": 0, "python_code": "def findMaxGCD ( arr , n ) :\n    high = 0\n    for i in range ( 0 , n ) :\n        high = max ( high , arr [ i ] )\n    count = [ 0 ] * ( high + 1 )\n    for i in range ( 0 , n ) :\n        count [ arr [ i ] ] += 1\n    counter = 0\n    for i in range ( high , 0 , - 1 ) :\n        j = i\n        while ( j <= high ) :\n            if ( count [ j ] > 0 ) :\n                counter += count [ j ]\n            j += i\n            if ( counter == 2 ) :\n                return i\n        counter = 0\narr = [ 1 , 2 , 4 , 8 , 8 , 12 ]\nn = len ( arr )\nprint ( findMaxGCD ( arr , n ) )\n", "python_code_tokenized": "def findMaxGCD ( arr , n ) : NEW_LINE INDENT high = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT high = max ( high , arr [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( high + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT counter = 0 NEW_LINE for i in range ( high , 0 , - 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( j <= high ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT counter += count [ j ] NEW_LINE DEDENT j += i NEW_LINE if ( counter == 2 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT counter = 0 NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 4 , 8 , 8 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxGCD ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1114_A", "sol": 0, "python_code": "def usingBinarySearch ( start , end , N , S ) :\n    if ( start >= end ) :\n        return start ;\n    mid = start + ( end - start ) // 2 ;\n    totalSum = ( N * ( N + 1 ) ) // 2 ;\n    midSum = ( mid * ( mid + 1 ) ) // 2 ;\n    if ( ( totalSum - midSum ) <= S ) :\n        return usingBinarySearch ( start , mid , N , S ) ;\n    return usingBinarySearch ( mid + 1 , end , N , S ) ;\nif __name__ == \"__main__\" :\n    N = 5 ;\n    S = 11 ;\n    print ( N - usingBinarySearch ( 1 , N , N , S ) + 1 ) ;\n", "python_code_tokenized": "def usingBinarySearch ( start , end , N , S ) : NEW_LINE INDENT if ( start >= end ) : NEW_LINE INDENT return start ; NEW_LINE DEDENT mid = start + ( end - start ) // 2 ; NEW_LINE totalSum = ( N * ( N + 1 ) ) // 2 ; NEW_LINE midSum = ( mid * ( mid + 1 ) ) // 2 ; NEW_LINE if ( ( totalSum - midSum ) <= S ) : NEW_LINE INDENT return usingBinarySearch ( start , mid , N , S ) ; NEW_LINE DEDENT return usingBinarySearch ( mid + 1 , end , N , S ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 ; NEW_LINE S = 11 ; NEW_LINE print ( N - usingBinarySearch ( 1 , N , N , S ) + 1 ) ; NEW_LINE DEDENT"}
{"id": "codeforces_638_A", "sol": 0, "python_code": "def solve ( s , a ) :\n    tmp = ( a + 1 ) // 2\n    ans = tmp\n    if a % 2 == 0 :\n        ans = s // 2 - tmp + 1\n    return ans\ns , a = map ( int , input ( ).split ( ) )\nprint ( solve ( s , a ) )\n", "python_code_tokenized": "def solve ( s , a ) : NEW_LINE INDENT tmp = ( a + 1 ) // 2 NEW_LINE ans = tmp NEW_LINE if a % 2 == 0 : NEW_LINE INDENT ans = s // 2 - tmp + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT s , a = map ( int , input ( ) . split ( ) ) NEW_LINE print ( solve ( s , a ) ) NEW_LINE"}
{"id": "codeforces_1020_B", "sol": 0, "python_code": "n = int ( input ( ) )\nmat = [ [ ] for i in range ( n ) ]\nb = [ int ( j ) - 1 for j in str ( input ( ) ).split ( '' ) ]\nfor i in range ( n ) :\n    mat [ i ].append ( b [ i ] )\ni = 0\nh = ''\ni = 0\nwhile i < n :\n    l = [ 0 for j in range ( n ) ]\n    a = i\n    while True :\n        l [ a ] += 1\n        if l [ a ] > 1 :\n            break\n        a = mat [ a ] [ 0 ]\n    m = 0\n    j = 0\n    while j < n :\n        if l [ j ] > m :\n            m = l [ j ]\n            x = j + 1\n        j = j + 1\n    h = h + str ( x ) + ''\n    i = i + 1\nprint ( h )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE mat = [ [ ] for i in range ( n ) ] NEW_LINE b = [ int ( j ) - 1 for j in str ( input ( ) ) . split ( ' \u2581 ' ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT mat [ i ] . append ( b [ i ] ) NEW_LINE DEDENT i = 0 NEW_LINE h = ' ' NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT l = [ 0 for j in range ( n ) ] NEW_LINE a = i NEW_LINE while True : NEW_LINE INDENT l [ a ] += 1 NEW_LINE if l [ a ] > 1 : NEW_LINE INDENT break NEW_LINE DEDENT a = mat [ a ] [ 0 ] NEW_LINE DEDENT m = 0 NEW_LINE j = 0 NEW_LINE while j < n : NEW_LINE INDENT if l [ j ] > m : NEW_LINE INDENT m = l [ j ] NEW_LINE x = j + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT h = h + str ( x ) + ' \u2581 ' NEW_LINE i = i + 1 NEW_LINE DEDENT print ( h ) NEW_LINE"}
{"id": "aizu_p01040_A", "sol": 0, "python_code": "import datetime\ny1 , m1 , d1 , y2 , m2 , d2 = map ( int , input ( ).split ( ) )\nqq , y1 = divmod ( y1 , 400 )\ny1 += 400\nqq -= 1\nq = ( y2 - y1 ) // 400\ny2 -= 400 * q\na = 688 * ( q - qq )\nd = datetime.date ( y1 , m1 , d1 )\nwhile d <= datetime.date ( y2 , m2 , d2 ) :\n    if d.day == 13 and d.weekday ( ) == 4 : a += 1\n    d += datetime.timedelta ( days = 1 )\nprint ( a )\n", "python_code_tokenized": "import datetime NEW_LINE y1 , m1 , d1 , y2 , m2 , d2 = map ( int , input ( ) . split ( ) ) NEW_LINE qq , y1 = divmod ( y1 , 400 ) NEW_LINE y1 += 400 NEW_LINE qq -= 1 NEW_LINE q = ( y2 - y1 ) // 400 NEW_LINE y2 -= 400 * q NEW_LINE a = 688 * ( q - qq ) NEW_LINE d = datetime . date ( y1 , m1 , d1 ) NEW_LINE while d <= datetime . date ( y2 , m2 , d2 ) : NEW_LINE INDENT if d . day == 13 and d . weekday ( ) == 4 : a += 1 NEW_LINE d += datetime . timedelta ( days = 1 ) NEW_LINE DEDENT print ( a ) NEW_LINE"}
{"id": "codeforces_911_A", "sol": 0, "python_code": "import math\nimport sys\ndef _input ( ) : return map ( int , input ( ).split ( ) )\nn = int ( input ( ) )\nlst = list ( _input ( ) )\nm = min ( lst ) ; l = [ ]\nfor i in range ( n ) :\n    if lst [ i ] == m : l.append ( i )\nres = sys.maxsize\nfor i in range ( 1 , len ( l ) ) :\n    res = min ( res , l [ i ] - l [ i - 1 ] )\nprint ( res )\n", "python_code_tokenized": "import math NEW_LINE import sys NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE lst = list ( _input ( ) ) NEW_LINE m = min ( lst ) ; l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if lst [ i ] == m : l . append ( i ) NEW_LINE DEDENT res = sys . maxsize NEW_LINE for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT res = min ( res , l [ i ] - l [ i - 1 ] ) NEW_LINE DEDENT print ( res ) NEW_LINE"}
{"id": "geeksforgeeks_3150_A", "sol": 0, "python_code": "def reversDigits ( num ) :\n    negativeFlag = False\n    if ( num < 0 ) :\n        negativeFlag = True\n        num = - num\n    prev_rev_num = 0\n    rev_num = 0\n    while ( num != 0 ) :\n        curr_digit = num % 10\n        rev_num = ( rev_num * 10 ) + curr_digit\n        if ( rev_num >= 2147483647 or rev_num <= - 2147483648 ) :\n            rev_num = 0\n        if ( ( rev_num - curr_digit ) // 10 != prev_rev_num ) :\n            print ( \"WARNING OVERFLOWED!!!\" )\n            return 0\n        prev_rev_num = rev_num\n        num = num // 10\n    return - rev_num if ( negativeFlag == True ) else rev_num\nif __name__ == \"__main__\" :\n    num = 12345\n    print ( \"Reverse of no.is \" , reversDigits ( num ) )\n    num = 1000000045\n    print ( \"Reverse of no.is \" , reversDigits ( num ) )\n", "python_code_tokenized": "def reversDigits ( num ) : NEW_LINE INDENT negativeFlag = False NEW_LINE if ( num < 0 ) : NEW_LINE INDENT negativeFlag = True NEW_LINE num = - num NEW_LINE DEDENT prev_rev_num = 0 NEW_LINE rev_num = 0 NEW_LINE while ( num != 0 ) : NEW_LINE INDENT curr_digit = num % 10 NEW_LINE rev_num = ( rev_num * 10 ) + curr_digit NEW_LINE if ( rev_num >= 2147483647 or rev_num <= - 2147483648 ) : NEW_LINE INDENT rev_num = 0 NEW_LINE DEDENT if ( ( rev_num - curr_digit ) // 10 != prev_rev_num ) : NEW_LINE INDENT print ( \" WARNING \u2581 OVERFLOWED ! ! ! \" ) NEW_LINE return 0 NEW_LINE DEDENT prev_rev_num = rev_num NEW_LINE num = num // 10 NEW_LINE DEDENT return - rev_num if ( negativeFlag == True ) else rev_num NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 12345 NEW_LINE print ( \" Reverse \u2581 of \u2581 no . \u2581 is \u2581 \" , reversDigits ( num ) ) NEW_LINE num = 1000000045 NEW_LINE print ( \" Reverse \u2581 of \u2581 no . \u2581 is \u2581 \" , reversDigits ( num ) ) NEW_LINE DEDENT"}
{"id": "codeforces_327_A", "sol": 0, "python_code": "import itertools\ndef find ( s , ch ) :\n    return [ i for i , ltr in enumerate ( s ) if ltr == ch ]\nif __name__ == '__main__' :\n    n = int ( input ( ) )\n    s = input ( ).replace ( \"\" , \"\" )\n    if '0' not in s :\n        print ( n - 1 )\n    else :\n        indices = find ( s , '0' )\n        if len ( indices ) == 1 :\n            print ( n )\n        else :\n            maximum = 0\n            combs = itertools.combinations ( indices , 2 )\n            for x in combs :\n                maximum = max ( maximum , 2 + 2 * ( abs ( indices.index ( x [ 0 ] ) - indices.index ( x [ 1 ] ) ) - 1 ) - ( abs ( x [ 0 ] - x [ 1 ] ) - 1 ) )\n            print ( s.count ( '1' ) + maximum )\n", "python_code_tokenized": "import itertools NEW_LINE def find ( s , ch ) : NEW_LINE INDENT return [ i for i , ltr in enumerate ( s ) if ltr == ch ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) . replace ( \" \u2581 \" , \" \" ) NEW_LINE if '0' not in s : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT indices = find ( s , '0' ) NEW_LINE if len ( indices ) == 1 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT maximum = 0 NEW_LINE combs = itertools . combinations ( indices , 2 ) NEW_LINE for x in combs : NEW_LINE INDENT maximum = max ( maximum , 2 + 2 * ( abs ( indices . index ( x [ 0 ] ) - indices . index ( x [ 1 ] ) ) - 1 ) - ( abs ( x [ 0 ] - x [ 1 ] ) - 1 ) ) NEW_LINE DEDENT print ( s . count ( '1' ) + maximum ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_1264_A", "sol": 0, "python_code": "def findTriangles ( n ) :\n    num = n\n    print ( num , end = \" \" )\n    print ( num * ( num - 4 ) * ( num - 5 ) // 6 )\nn = 6 ;\nfindTriangles ( n )\n", "python_code_tokenized": "def findTriangles ( n ) : NEW_LINE INDENT num = n NEW_LINE print ( num , end = \" \u2581 \" ) NEW_LINE print ( num * ( num - 4 ) * ( num - 5 ) // 6 ) NEW_LINE DEDENT n = 6 ; NEW_LINE findTriangles ( n ) NEW_LINE"}
{"id": "codeforces_1531_A", "sol": 0, "python_code": "n = int ( input ( ) )\ncolor = 'blue'\nblock = 0\ni = 0\nwhile i != n :\n    command = str ( input ( ) )\n    if command == 'lock' :\n        block = 1\n    elif command == 'unlock' :\n        block = 0\n    elif block == 0 :\n        color = command\n    i += 1\nprint ( color )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE color = ' blue ' NEW_LINE block = 0 NEW_LINE i = 0 NEW_LINE while i != n : NEW_LINE INDENT command = str ( input ( ) ) NEW_LINE if command == ' lock ' : NEW_LINE INDENT block = 1 NEW_LINE DEDENT elif command == ' unlock ' : NEW_LINE INDENT block = 0 NEW_LINE DEDENT elif block == 0 : NEW_LINE INDENT color = command NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( color ) NEW_LINE"}
{"id": "geeksforgeeks_339_A", "sol": 0, "python_code": "def Rank ( Edges , Vertices ) :\n    result = Edges - Vertices + 1\n    return result\nif __name__ == \"__main__\" :\n    Edges , Vertices = 7 , 5\n    print ( \"Circuit Rank =\" , Rank ( Edges , Vertices ) )\n", "python_code_tokenized": "def Rank ( Edges , Vertices ) : NEW_LINE INDENT result = Edges - Vertices + 1 NEW_LINE return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Edges , Vertices = 7 , 5 NEW_LINE print ( \" Circuit \u2581 Rank \u2581 = \" , Rank ( Edges , Vertices ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3271_A", "sol": 0, "python_code": "from math import gcd\ndef countNums ( a , b , c , d ) :\n    x = b // c - ( a - 1 ) // c ;\n    y = b // d - ( a - 1 ) // d ;\n    k = ( c * d ) // gcd ( c , d ) ;\n    z = b // k - ( a - 1 ) // k ;\n    return ( b - a + 1 - x - y + z ) ;\nif __name__ == \"__main__\" :\n    a = 10 ; b = 50 ; c = 4 ; d = 6 ;\n    print ( countNums ( a , b , c , d ) ) ;\n", "python_code_tokenized": "from math import gcd NEW_LINE def countNums ( a , b , c , d ) : NEW_LINE INDENT x = b // c - ( a - 1 ) // c ; NEW_LINE y = b // d - ( a - 1 ) // d ; NEW_LINE k = ( c * d ) // gcd ( c , d ) ; NEW_LINE z = b // k - ( a - 1 ) // k ; NEW_LINE return ( b - a + 1 - x - y + z ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10 ; b = 50 ; c = 4 ; d = 6 ; NEW_LINE print ( countNums ( a , b , c , d ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_593_A", "sol": 0, "python_code": "def minNum ( num , k ) :\n    len_ = len ( num )\n    if len_ == 0 or k == 0 :\n        return num\n    if len_ == 1 :\n        return \"0\"\n    if num [ 0 ] != '1' :\n        num = '1' + num [ 1 : ]\n        k -= 1\n    i = 1\n    while k > 0 and i < len_ :\n        if num [ i ] != '0' :\n            num = num [ : i ] + '0' + num [ i + 1 : ]\n            k -= 1\n        i += 1\n    return num\nnum = \"91945\"\nk = 3\nprint ( minNum ( num , k ) )\n", "python_code_tokenized": "def minNum ( num , k ) : NEW_LINE INDENT len_ = len ( num ) NEW_LINE if len_ == 0 or k == 0 : NEW_LINE INDENT return num NEW_LINE DEDENT if len_ == 1 : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT if num [ 0 ] != '1' : NEW_LINE INDENT num = '1' + num [ 1 : ] NEW_LINE k -= 1 NEW_LINE DEDENT i = 1 NEW_LINE while k > 0 and i < len_ : NEW_LINE INDENT if num [ i ] != '0' : NEW_LINE INDENT num = num [ : i ] + '0' + num [ i + 1 : ] NEW_LINE k -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return num NEW_LINE DEDENT num = \"91945\" NEW_LINE k = 3 NEW_LINE print ( minNum ( num , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_1542_A", "sol": 0, "python_code": "def binarySearch ( arr , l , r , x ) :\n    if ( r >= l ) :\n        mid = int ( l + ( r - l ) / 2 )\n        if ( arr [ mid ] == x ) : return mid\n        if ( mid > l and arr [ mid - 1 ] == x ) :\n            return ( mid - 1 )\n        if ( mid < r and arr [ mid + 1 ] == x ) :\n            return ( mid + 1 )\n        if ( arr [ mid ] > x ) :\n            return binarySearch ( arr , l , mid - 2 , x )\n        return binarySearch ( arr , mid + 2 , r , x )\n    return - 1\narr = [ 3 , 2 , 10 , 4 , 40 ]\nn = len ( arr )\nx = 4\nresult = binarySearch ( arr , 0 , n - 1 , x )\nif ( result == - 1 ) :\n    print ( \"Element is not present in array\" )\nelse :\n    print ( \"Element is present at index\" , result )\n", "python_code_tokenized": "def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r >= l ) : NEW_LINE INDENT mid = int ( l + ( r - l ) / 2 ) NEW_LINE if ( arr [ mid ] == x ) : return mid NEW_LINE if ( mid > l and arr [ mid - 1 ] == x ) : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if ( mid < r and arr [ mid + 1 ] == x ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( arr [ mid ] > x ) : NEW_LINE INDENT return binarySearch ( arr , l , mid - 2 , x ) NEW_LINE DEDENT return binarySearch ( arr , mid + 2 , r , x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 3 , 2 , 10 , 4 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE x = 4 NEW_LINE result = binarySearch ( arr , 0 , n - 1 , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( \" Element \u2581 is \u2581 not \u2581 present \u2581 in \u2581 array \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Element \u2581 is \u2581 present \u2581 at \u2581 index \" , result ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_570_A", "sol": 0, "python_code": "def getProbability ( p , q ) :\n    p /= 100\n    q /= 100\n    probability = ( p * p + q * q ) / ( p + q )\n    return probability\nif __name__ == \"__main__\" :\n    p = 80\n    q = 40\n    print ( getProbability ( p , q ) )\n", "python_code_tokenized": "def getProbability ( p , q ) : NEW_LINE INDENT p /= 100 NEW_LINE q /= 100 NEW_LINE probability = ( p * p + q * q ) / ( p + q ) NEW_LINE return probability NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p = 80 NEW_LINE q = 40 NEW_LINE print ( getProbability ( p , q ) ) NEW_LINE DEDENT"}
{"id": "codeforces_262_A", "sol": 0, "python_code": "n , k = input ( ).split ( )\nn = int ( n ) ; k = int ( k )\na = input ( )\nl = a.split ( )\nans = 0\nfor j in range ( len ( l ) ) :\n    lc = 0\n    for i in range ( len ( l [ j ] ) ) :\n        if l [ j ] [ i ] == '4' or l [ j ] [ i ] == '7' :\n            lc += 1\n    if lc <= k :\n        ans += 1\nprint ( ans )\n", "python_code_tokenized": "n , k = input ( ) . split ( ) NEW_LINE n = int ( n ) ; k = int ( k ) NEW_LINE a = input ( ) NEW_LINE l = a . split ( ) NEW_LINE ans = 0 NEW_LINE for j in range ( len ( l ) ) : NEW_LINE INDENT lc = 0 NEW_LINE for i in range ( len ( l [ j ] ) ) : NEW_LINE INDENT if l [ j ] [ i ] == '4' or l [ j ] [ i ] == '7' : NEW_LINE INDENT lc += 1 NEW_LINE DEDENT DEDENT if lc <= k : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_2385_A", "sol": 0, "python_code": "def nondecdigits ( s ) :\n    m = len ( s ) ;\n    a = [ 0 ] * m ;\n    for i in range ( m ) :\n        a [ i ] = ord ( s [ i ] ) - ord ( '0' ) ;\n    level = m - 1 ;\n    for i in range ( m - 1 , 0 , - 1 ) :\n        if ( a [ i ] < a [ i - 1 ] ) :\n            a [ i - 1 ] -= 1 ;\n            level = i - 1 ;\n    if ( a [ 0 ] != 0 ) :\n        for i in range ( level + 1 ) :\n            print ( a [ i ] , end = \"\" ) ;\n        for i in range ( level + 1 , m ) :\n            print ( \"9\" , end = \"\" ) ;\n    else :\n        for i in range ( 1 , level ) :\n            print ( a [ i ] , end = \"\" ) ;\n        for i in range ( level + 1 , m ) :\n            print ( \"9\" , end = \"\" ) ;\nn = \"200\" ;\nnondecdigits ( n ) ;\n", "python_code_tokenized": "def nondecdigits ( s ) : NEW_LINE INDENT m = len ( s ) ; NEW_LINE a = [ 0 ] * m ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT a [ i ] = ord ( s [ i ] ) - ord ( '0' ) ; NEW_LINE DEDENT level = m - 1 ; NEW_LINE for i in range ( m - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT a [ i - 1 ] -= 1 ; NEW_LINE level = i - 1 ; NEW_LINE DEDENT DEDENT if ( a [ 0 ] != 0 ) : NEW_LINE INDENT for i in range ( level + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = \" \" ) ; NEW_LINE DEDENT for i in range ( level + 1 , m ) : NEW_LINE INDENT print ( \"9\" , end = \" \" ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , level ) : NEW_LINE INDENT print ( a [ i ] , end = \" \" ) ; NEW_LINE DEDENT for i in range ( level + 1 , m ) : NEW_LINE INDENT print ( \"9\" , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT n = \"200\" ; NEW_LINE nondecdigits ( n ) ; NEW_LINE"}
{"id": "geeksforgeeks_3107_A", "sol": 0, "python_code": "def prevPermutation ( str ) :\n    n = len ( str ) - 1\n    i = n\n    while ( i > 0 and str [ i - 1 ] <= str [ i ] ) :\n        i -= 1\n    if ( i <= 0 ) :\n        return False\n    j = i - 1\n    while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) :\n        j += 1\n    str = list ( str )\n    temp = str [ i - 1 ]\n    str [ i - 1 ] = str [ j ]\n    str [ j ] = temp\n    str = ''.join ( str )\n    str [ : : - 1 ]\n    return True , str\nif __name__ == '__main__' :\n    str = \"4321\"\n    b , str = prevPermutation ( str )\n    if ( b == True ) :\n        print ( \"Previous permutation is\" , str )\n    else :\n        print ( \"Previous permutation doesn't exist\" )\n", "python_code_tokenized": "def prevPermutation ( str ) : NEW_LINE INDENT n = len ( str ) - 1 NEW_LINE i = n NEW_LINE while ( i > 0 and str [ i - 1 ] <= str [ i ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT str = list ( str ) NEW_LINE temp = str [ i - 1 ] NEW_LINE str [ i - 1 ] = str [ j ] NEW_LINE str [ j ] = temp NEW_LINE str = ' ' . join ( str ) NEW_LINE str [ : : - 1 ] NEW_LINE return True , str NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"4321\" NEW_LINE b , str = prevPermutation ( str ) NEW_LINE if ( b == True ) : NEW_LINE INDENT print ( \" Previous \u2581 permutation \u2581 is \" , str ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Previous \u2581 permutation \u2581 doesn ' t \u2581 exist \" ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC051_A", "sol": 0, "python_code": "print ( input ( ).replace ( \",\" , \" \" ) )\n", "python_code_tokenized": "print ( input ( ) . replace ( \" , \" , \" \u2581 \" ) ) NEW_LINE"}
{"id": "codeforces_596_A", "sol": 0, "python_code": "left = int ( input ( ) )\nX = list ( )\nY = list ( )\nout = False\nfor i in range ( left ) :\n    x , y = map ( int , input ( ).split ( ) )\n    X.append ( x )\n    Y.append ( y )\nif left <= 1 :\n    print ( - 1 )\nelif left == 2 :\n    if X [ 0 ] != X [ 1 ] and Y [ 0 ] != Y [ 1 ] :\n        print ( abs ( X [ 0 ] - X [ 1 ] ) * abs ( Y [ 0 ] - Y [ 1 ] ) )\n    else :\n        print ( - 1 )\nelif left == 3 :\n    for i in range ( 3 ) :\n        for j in range ( 3 ) :\n            if X [ j ] != X [ i ] and Y [ j ] != Y [ i ] :\n                x1 = X [ i ]\n                y1 = Y [ i ]\n                x2 = X [ j ]\n                y2 = Y [ j ]\n                out = True\n                break\n        if out == True :\n            break\n    print ( abs ( x1 - x2 ) * abs ( y1 - y2 ) )\nelif left == 4 :\n    for i in range ( 4 ) :\n        for j in range ( 4 ) :\n            if X [ j ] != X [ i ] and Y [ j ] != Y [ i ] :\n                x1 = X [ i ]\n                y1 = Y [ i ]\n                x2 = X [ j ]\n                y2 = Y [ j ]\n                out = True\n                break\n        if out == True :\n            break\n    print ( abs ( x1 - x2 ) * abs ( y1 - y2 ) )\n", "python_code_tokenized": "left = int ( input ( ) ) NEW_LINE X = list ( ) NEW_LINE Y = list ( ) NEW_LINE out = False NEW_LINE for i in range ( left ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE X . append ( x ) NEW_LINE Y . append ( y ) NEW_LINE DEDENT if left <= 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif left == 2 : NEW_LINE INDENT if X [ 0 ] != X [ 1 ] and Y [ 0 ] != Y [ 1 ] : NEW_LINE INDENT print ( abs ( X [ 0 ] - X [ 1 ] ) * abs ( Y [ 0 ] - Y [ 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT elif left == 3 : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if X [ j ] != X [ i ] and Y [ j ] != Y [ i ] : NEW_LINE INDENT x1 = X [ i ] NEW_LINE y1 = Y [ i ] NEW_LINE x2 = X [ j ] NEW_LINE y2 = Y [ j ] NEW_LINE out = True NEW_LINE break NEW_LINE DEDENT DEDENT if out == True : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( abs ( x1 - x2 ) * abs ( y1 - y2 ) ) NEW_LINE DEDENT elif left == 4 : NEW_LINE INDENT for i in range ( 4 ) : NEW_LINE INDENT for j in range ( 4 ) : NEW_LINE INDENT if X [ j ] != X [ i ] and Y [ j ] != Y [ i ] : NEW_LINE INDENT x1 = X [ i ] NEW_LINE y1 = Y [ i ] NEW_LINE x2 = X [ j ] NEW_LINE y2 = Y [ j ] NEW_LINE out = True NEW_LINE break NEW_LINE DEDENT DEDENT if out == True : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( abs ( x1 - x2 ) * abs ( y1 - y2 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2696_A", "sol": 0, "python_code": "def evenDecimalValue ( str , n ) :\n    result = 0\n    for i in range ( 0 , n ) :\n        if ( str [ i ] == '0' ) :\n            result += ( n - i )\n    return result\nstr = \"10010\"\nn = 5\nprint ( evenDecimalValue ( str , n ) )\n", "python_code_tokenized": "def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT result += ( n - i ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT str = \"10010\" NEW_LINE n = 5 NEW_LINE print ( evenDecimalValue ( str , n ) ) NEW_LINE"}
{"id": "codeforces_1360_A", "sol": 0, "python_code": "test = int ( input ( ) )\nfor i in range ( test ) :\n    a , b = input ( ).split ( )\n    a = int ( a )\n    b = int ( b )\n    c = ( min ( a , b ) * 2 ) ** 2\n    d = ( max ( a , b ) ** 2 )\n    print ( max ( c , d ) )\n", "python_code_tokenized": "test = int ( input ( ) ) NEW_LINE for i in range ( test ) : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE a = int ( a ) NEW_LINE b = int ( b ) NEW_LINE c = ( min ( a , b ) * 2 ) ** 2 NEW_LINE d = ( max ( a , b ) ** 2 ) NEW_LINE print ( max ( c , d ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4792_A", "sol": 0, "python_code": "def avg_of_even_num ( n ) :\n    sum = 0\n    for i in range ( 1 , n + 1 ) :\n        sum = sum + 2 * i\n    return sum / n\nn = 9\nprint ( avg_of_even_num ( n ) )\n", "python_code_tokenized": "def avg_of_even_num ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + 2 * i NEW_LINE DEDENT return sum / n NEW_LINE DEDENT n = 9 NEW_LINE print ( avg_of_even_num ( n ) ) NEW_LINE"}
{"id": "codeforces_876_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = int ( input ( ) )\nb = int ( input ( ) )\nc = int ( input ( ) )\nprint ( ( n > 1 ) * min ( a , b ) + max ( 0 , n - 2 ) * min ( a , b , c ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE c = int ( input ( ) ) NEW_LINE print ( ( n > 1 ) * min ( a , b ) + max ( 0 , n - 2 ) * min ( a , b , c ) ) NEW_LINE"}
{"id": "geeksforgeeks_3887_A", "sol": 0, "python_code": "import math\ndef findBucketNo ( p ) :\n    return math.ceil ( ( math.sqrt ( 8 * p + 1 ) - 1 ) / 2 )\np = 10\nprint ( findBucketNo ( p ) )\n", "python_code_tokenized": "import math NEW_LINE def findBucketNo ( p ) : NEW_LINE INDENT return math . ceil ( ( math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) NEW_LINE DEDENT p = 10 NEW_LINE print ( findBucketNo ( p ) ) NEW_LINE"}
{"id": "geeksforgeeks_586_A", "sol": 0, "python_code": "def count ( n ) :\n    table = [ 0 for i in range ( n + 1 ) ]\n    table [ 0 ] = 1\n    for i in range ( 3 , n + 1 ) :\n        table [ i ] += table [ i - 3 ]\n    for i in range ( 5 , n + 1 ) :\n        table [ i ] += table [ i - 5 ]\n    for i in range ( 10 , n + 1 ) :\n        table [ i ] += table [ i - 10 ]\n    return table [ n ]\nn = 20\nprint ( 'Count for' , n , 'is' , count ( n ) )\nn = 13\nprint ( 'Count for' , n , 'is' , count ( n ) )\n", "python_code_tokenized": "def count ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT n = 20 NEW_LINE print ( ' Count \u2581 for ' , n , ' is ' , count ( n ) ) NEW_LINE n = 13 NEW_LINE print ( ' Count \u2581 for ' , n , ' is ' , count ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4076_A", "sol": 0, "python_code": "def mostCommon ( lower , higher ) :\n    if ( lower == higher ) :\n        return lower\n    else :\n        return 2\nlower = 10\nhigher = 20\nprint ( \"The most frequent factor\" , mostCommon ( lower , higher ) )\n", "python_code_tokenized": "def mostCommon ( lower , higher ) : NEW_LINE INDENT if ( lower == higher ) : NEW_LINE INDENT return lower NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT lower = 10 NEW_LINE higher = 20 NEW_LINE print ( \" The \u2581 most \u2581 frequent \u2581 factor \" , mostCommon ( lower , higher ) ) NEW_LINE"}
{"id": "codeforces_1015_B", "sol": 0, "python_code": "n = int ( input ( ) )\ns = list ( str ( input ( ) ) )\nt = list ( str ( input ( ) ) )\ndic_s = { }\ndic_t = { }\nfor i in range ( 97 , 97 + 26 ) :\n    dic_s [ chr ( i ) ] = 0\n    dic_t [ chr ( i ) ] = 0\nfor i in range ( n ) :\n    dic_s [ s [ i ] ] += 1\n    dic_t [ t [ i ] ] += 1\nif dic_s != dic_t :\n    print ( - 1 )\nelse :\n    c = [ ]\n    for i in range ( n ) :\n        while True :\n            if s [ i ] == t [ i ] :\n                break\n            target = i + s [ i : ].index ( t [ i ] )\n            c.append ( target - 1 )\n            s [ target - 1 ] , s [ target ] = s [ target ] , s [ target - 1 ]\n    c = [ el + 1 for el in c ]\n    print ( len ( c ) )\n    for el in c :\n        print ( el , end = ' ' )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = list ( str ( input ( ) ) ) NEW_LINE t = list ( str ( input ( ) ) ) NEW_LINE dic_s = { } NEW_LINE dic_t = { } NEW_LINE for i in range ( 97 , 97 + 26 ) : NEW_LINE INDENT dic_s [ chr ( i ) ] = 0 NEW_LINE dic_t [ chr ( i ) ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT dic_s [ s [ i ] ] += 1 NEW_LINE dic_t [ t [ i ] ] += 1 NEW_LINE DEDENT if dic_s != dic_t : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT while True : NEW_LINE INDENT if s [ i ] == t [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT target = i + s [ i : ] . index ( t [ i ] ) NEW_LINE c . append ( target - 1 ) NEW_LINE s [ target - 1 ] , s [ target ] = s [ target ] , s [ target - 1 ] NEW_LINE DEDENT DEDENT c = [ el + 1 for el in c ] NEW_LINE print ( len ( c ) ) NEW_LINE for el in c : NEW_LINE INDENT print ( el , end = ' \u2581 ' ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1104_A", "sol": 0, "python_code": "numb = int ( input ( ) )\nprint ( numb )\nfor i in range ( numb ) :\n    print ( 1 , end = ' ' )\n", "python_code_tokenized": "numb = int ( input ( ) ) NEW_LINE print ( numb ) NEW_LINE for i in range ( numb ) : NEW_LINE INDENT print ( 1 , end = ' \u2581 ' ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC139_D", "sol": 0, "python_code": "n = int ( input ( ) )\nif n == 1 :\n    b = 0\nelse :\n    b = ( n * ( n - 1 ) ) // 2\nprint ( b )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT b = 0 NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * ( n - 1 ) ) // 2 NEW_LINE DEDENT print ( b ) NEW_LINE"}
{"id": "codeforces_1700_A", "sol": 0, "python_code": "for i in range ( int ( input ( ) ) ) :\n    n , m = map ( int , input ( ).split ( ) )\n    if n == 1 :\n        print ( m * ( m + 1 ) // 2 )\n    elif m == 1 :\n        print ( n * ( n + 1 ) // 2 )\n    else :\n        p = m * ( m - 1 ) // 2\n        q = n * ( n + 1 ) // 2\n        q *= m\n        print ( p + q )\n", "python_code_tokenized": "for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( m * ( m + 1 ) // 2 ) NEW_LINE DEDENT elif m == 1 : NEW_LINE INDENT print ( n * ( n + 1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT p = m * ( m - 1 ) // 2 NEW_LINE q = n * ( n + 1 ) // 2 NEW_LINE q *= m NEW_LINE print ( p + q ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1140_A", "sol": 0, "python_code": "def printPattern ( i , j , n ) :\n    if ( j >= n ) :\n        return 0\n    if ( i >= n ) :\n        return 1\n    if ( j == i or j == n - 1 - i ) :\n        if ( i == n - 1 - j ) :\n            print ( \"/\" , end = \"\" )\n        else :\n            print ( \"\\\\\" , end = \"\" )\n    else :\n        print ( \"*\" , end = \"\" )\n    if ( printPattern ( i , j + 1 , n ) == 1 ) :\n        return 1\n    print ( )\n    return printPattern ( i + 1 , 0 , n )\nif __name__ == \"__main__\" :\n    N = 9\n    printPattern ( 0 , 0 , N )\n", "python_code_tokenized": "def printPattern ( i , j , n ) : NEW_LINE INDENT if ( j >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( j == i or j == n - 1 - i ) : NEW_LINE INDENT if ( i == n - 1 - j ) : NEW_LINE INDENT print ( \" / \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \\ \\ \" , end = \" \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT if ( printPattern ( i , j + 1 , n ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT print ( ) NEW_LINE return printPattern ( i + 1 , 0 , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 NEW_LINE printPattern ( 0 , 0 , N ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC114_A", "sol": 0, "python_code": "X = int ( input ( ) )\nif X in [ 7 , 5 , 3 ] :\n    print ( 'YES' )\nelse :\n    print ( 'NO' )\n", "python_code_tokenized": "X = int ( input ( ) ) NEW_LINE if X in [ 7 , 5 , 3 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC112_C", "sol": 0, "python_code": "N = int ( input ( ) )\nedges = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( N ) ]\nfor cx in range ( 101 ) :\n    for cy in range ( 101 ) :\n        for i in range ( N ) :\n            x , y , h = map ( int , edges [ i ] )\n            if h > 0 :\n                htop = abs ( x - cx ) + abs ( y - cy ) + h\n        for i in range ( N ) :\n            x , y , h = map ( int , edges [ i ] )\n            if h == 0 :\n                if htop - ( abs ( x - cx ) + abs ( y - cy ) ) > 0 :\n                    break\n            if h > 0 :\n                if htop - ( abs ( x - cx ) + abs ( y - cy ) ) != h :\n                    break\n        else :\n            print ( cx , cy , htop )\n            exit ( )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE edges = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE for cx in range ( 101 ) : NEW_LINE INDENT for cy in range ( 101 ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT x , y , h = map ( int , edges [ i ] ) NEW_LINE if h > 0 : NEW_LINE INDENT htop = abs ( x - cx ) + abs ( y - cy ) + h NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT x , y , h = map ( int , edges [ i ] ) NEW_LINE if h == 0 : NEW_LINE INDENT if htop - ( abs ( x - cx ) + abs ( y - cy ) ) > 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if h > 0 : NEW_LINE INDENT if htop - ( abs ( x - cx ) + abs ( y - cy ) ) != h : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( cx , cy , htop ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "codeforces_91_A", "sol": 0, "python_code": "import bisect\nimport sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\ns1 = list ( input ( ).rstrip ( ) )\ns2 = list ( input ( ).rstrip ( ) )\nn = len ( s1 )\nx = [ [ ] for _ in range ( 26 ) ]\nfor i in range ( n ) :\n    s1 [ i ] -= 97\nfor i in range ( 2 ) :\n    for j in range ( n ) :\n        x [ s1 [ j ] ].append ( i * n + j )\ndp = [ ]\nfor i in range ( n ) :\n    dp0 = [ ]\n    for j in range ( 26 ) :\n        if not x [ j ] :\n            dp0.append ( - 1 )\n        else :\n            dp0.append ( x [ j ] [ bisect.bisect_right ( x [ j ] , i ) ] - i )\n    dp.append ( dp0 )\ns0 = s2 [ 0 ] - 97\nf = 0\nfor j in range ( n ) :\n    if not s0 ^ s1 [ j ] :\n        f = 1\n        break\nans = 0\nfor i in s2 [ 1 : ] :\n    k = dp [ j % n ] [ i - 97 ]\n    if k ^ - 1 and f :\n        j += k\n    else :\n        ans = - 1\n        break\nif not ans :\n    ans = j // n + 1\nprint ( ans )\n", "python_code_tokenized": "import bisect NEW_LINE import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE s1 = list ( input ( ) . rstrip ( ) ) NEW_LINE s2 = list ( input ( ) . rstrip ( ) ) NEW_LINE n = len ( s1 ) NEW_LINE x = [ [ ] for _ in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s1 [ i ] -= 97 NEW_LINE DEDENT for i in range ( 2 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT x [ s1 [ j ] ] . append ( i * n + j ) NEW_LINE DEDENT DEDENT dp = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = [ ] NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT if not x [ j ] : NEW_LINE INDENT dp0 . append ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp0 . append ( x [ j ] [ bisect . bisect_right ( x [ j ] , i ) ] - i ) NEW_LINE DEDENT DEDENT dp . append ( dp0 ) NEW_LINE DEDENT s0 = s2 [ 0 ] - 97 NEW_LINE f = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if not s0 ^ s1 [ j ] : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in s2 [ 1 : ] : NEW_LINE INDENT k = dp [ j % n ] [ i - 97 ] NEW_LINE if k ^ - 1 and f : NEW_LINE INDENT j += k NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE break NEW_LINE DEDENT DEDENT if not ans : NEW_LINE INDENT ans = j // n + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_2345_A", "sol": 0, "python_code": "import math\ndef isPerfectSquare ( x ) :\n    sr = math.sqrt ( x )\n    return ( ( sr - math.floor ( sr ) ) == 0 )\nx = 2500\nif ( isPerfectSquare ( x ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT x = 2500 NEW_LINE if ( isPerfectSquare ( x ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2166_A", "sol": 0, "python_code": "MAXN = 100000\nMOD = 1000000007\nfact = [ 0 ] * MAXN ;\ndef factorial ( ) :\n    fact [ 0 ] = 1\n    for i in range ( 1 , MAXN ) :\n        fact [ i ] = ( fact [ i - 1 ] * i ) % MOD\ndef power ( x , y , p ) :\n    res = 1\n    x = x % p\n    while ( y > 0 ) :\n        if ( y & 1 ) :\n            res = ( res * x ) % p\n        y = y >> 1 ;\n        x = ( x * x ) % p\n    return res\ndef modInverse ( x , p ) :\n    return power ( x , p - 2 , p )\ndef countDifferentNumbers ( arr , P ) :\n    factorial ( ) ;\n    res = 0 ; X = 0 ;\n    for i in range ( 10 ) :\n        X += arr [ i ]\n    res = fact [ X ]\n    for i in range ( 10 ) :\n        if ( arr [ i ] > 1 ) :\n            res = ( res * modInverse ( fact [ arr [ i ] ] , P ) ) % P ;\n    return res ;\nif __name__ == \"__main__\" :\n    arr = [ 1 , 0 , 2 , 0 , 0 , 7 , 4 , 0 , 0 , 3 ]\n    print ( countDifferentNumbers ( arr , MOD ) )\n", "python_code_tokenized": "MAXN = 100000 NEW_LINE MOD = 1000000007 NEW_LINE fact = [ 0 ] * MAXN ; NEW_LINE def factorial ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAXN ) : NEW_LINE INDENT fact [ i ] = ( fact [ i - 1 ] * i ) % MOD NEW_LINE DEDENT DEDENT def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 ; NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def modInverse ( x , p ) : NEW_LINE INDENT return power ( x , p - 2 , p ) NEW_LINE DEDENT def countDifferentNumbers ( arr , P ) : NEW_LINE INDENT factorial ( ) ; NEW_LINE res = 0 ; X = 0 ; NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT X += arr [ i ] NEW_LINE DEDENT res = fact [ X ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( arr [ i ] > 1 ) : NEW_LINE INDENT res = ( res * modInverse ( fact [ arr [ i ] ] , P ) ) % P ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 0 , 2 , 0 , 0 , 7 , 4 , 0 , 0 , 3 ] NEW_LINE print ( countDifferentNumbers ( arr , MOD ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4025_A", "sol": 0, "python_code": "def areElementsContiguous ( arr , n ) :\n    arr.sort ( )\n    for i in range ( 1 , n ) :\n        if ( arr [ i ] - arr [ i - 1 ] > 1 ) :\n            return 0\n    return 1\narr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ]\nn = len ( arr )\nif areElementsContiguous ( arr , n ) : print ( \"Yes\" )\nelse : print ( \"No\" )\n", "python_code_tokenized": "def areElementsContiguous ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] > 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if areElementsContiguous ( arr , n ) : print ( \" Yes \" ) NEW_LINE else : print ( \" No \" ) NEW_LINE"}
{"id": "geeksforgeeks_4367_A", "sol": 0, "python_code": "def ifPossible ( arr , n ) :\n    cp = [ 0 ] * n\n    cp = arr\n    cp.sort ( )\n    for i in range ( 0 , n ) :\n        if ( not ( arr [ i ] == cp [ i ] ) and not ( arr [ n - 1 - i ] == cp [ i ] ) ) :\n            return False\n    return True\narr = [ 1 , 7 , 6 , 4 , 5 , 3 , 2 , 8 ]\nn = len ( arr )\nif ( ifPossible ( arr , n ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def ifPossible ( arr , n ) : NEW_LINE INDENT cp = [ 0 ] * n NEW_LINE cp = arr NEW_LINE cp . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( not ( arr [ i ] == cp [ i ] ) and not ( arr [ n - 1 - i ] == cp [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 7 , 6 , 4 , 5 , 3 , 2 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE if ( ifPossible ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4947_A", "sol": 0, "python_code": "def checkIsAP ( arr , n ) :\n    if ( n == 1 ) : return True\n    arr.sort ( )\n    d = arr [ 1 ] - arr [ 0 ]\n    for i in range ( 2 , n ) :\n        if ( arr [ i ] - arr [ i - 1 ] != d ) :\n            return False\n    return True\narr = [ 20 , 15 , 5 , 0 , 10 ]\nn = len ( arr )\nprint ( \"Yes\" ) if ( checkIsAP ( arr , n ) ) else print ( \"No\" )\n", "python_code_tokenized": "def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return True NEW_LINE arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 20 , 15 , 5 , 0 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Yes \" ) if ( checkIsAP ( arr , n ) ) else print ( \" No \" ) NEW_LINE"}
{"id": "geeksforgeeks_1895_A", "sol": 0, "python_code": "def checkIsAP ( arr , n ) :\n    if ( n == 1 ) : return True\n    arr.sort ( )\n    d = arr [ 1 ] - arr [ 0 ]\n    for i in range ( 2 , n ) :\n        if ( arr [ i ] - arr [ i - 1 ] != d ) :\n            return False\n    return True\narr = [ 20 , 15 , 5 , 0 , 10 ]\nn = len ( arr )\nprint ( \"Yes\" ) if ( checkIsAP ( arr , n ) ) else print ( \"No\" )\n", "python_code_tokenized": "def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return True NEW_LINE arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 20 , 15 , 5 , 0 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Yes \" ) if ( checkIsAP ( arr , n ) ) else print ( \" No \" ) NEW_LINE"}
{"id": "geeksforgeeks_713_A", "sol": 0, "python_code": "def andOperator ( a , b ) :\n    while ( a < b ) :\n        b -= ( b & - b )\n    return b\na , b = 10 , 15\nprint ( andOperator ( a , b ) )\n", "python_code_tokenized": "def andOperator ( a , b ) : NEW_LINE INDENT while ( a < b ) : NEW_LINE INDENT b -= ( b & - b ) NEW_LINE DEDENT return b NEW_LINE DEDENT a , b = 10 , 15 NEW_LINE print ( andOperator ( a , b ) ) NEW_LINE"}
{"id": "atcoder_ABC168_C", "sol": 0, "python_code": "import math\na , b , h , m = map ( int , input ( ).split ( ) )\ntheta_h = 2.5 * math.pi - ( 2 * math.pi * ( ( h + ( m / 60 ) ) / 12 ) )\ntheta_m = 2.5 * math.pi - ( 2 * math.pi * ( m / 60 ) )\nx_h = a * math.cos ( theta_h )\ny_h = a * math.sin ( theta_h )\nx_m = b * math.cos ( theta_m )\ny_m = b * math.sin ( theta_m )\nprint ( ( ( x_h - x_m ) ** 2 + ( y_h - y_m ) ** 2 ) ** 0.5 )\n", "python_code_tokenized": "import math NEW_LINE a , b , h , m = map ( int , input ( ) . split ( ) ) NEW_LINE theta_h = 2.5 * math . pi - ( 2 * math . pi * ( ( h + ( m / 60 ) ) / 12 ) ) NEW_LINE theta_m = 2.5 * math . pi - ( 2 * math . pi * ( m / 60 ) ) NEW_LINE x_h = a * math . cos ( theta_h ) NEW_LINE y_h = a * math . sin ( theta_h ) NEW_LINE x_m = b * math . cos ( theta_m ) NEW_LINE y_m = b * math . sin ( theta_m ) NEW_LINE print ( ( ( x_h - x_m ) ** 2 + ( y_h - y_m ) ** 2 ) ** 0.5 ) NEW_LINE"}
{"id": "aizu_p00117_A", "sol": 0, "python_code": "n = int ( input ( ) )\ncost = [ [ float ( 'inf' ) ] * n for _ in range ( n ) ]\nm = int ( input ( ) )\nfor _ in range ( m ) :\n    a , b , c , d = map ( int , input ( ).split ( ',' ) )\n    cost [ a - 1 ] [ b - 1 ] = c\n    cost [ b - 1 ] [ a - 1 ] = d\ns , g , V , P = map ( int , input ( ).split ( ',' ) )\nfor k in range ( n ) :\n    for i in range ( n ) :\n        for j in range ( n ) :\n            if cost [ i ] [ j ] > cost [ i ] [ k ] + cost [ k ] [ j ] :\n                cost [ i ] [ j ] = cost [ i ] [ k ] + cost [ k ] [ j ]\nprint ( V - P - cost [ s - 1 ] [ g - 1 ] - cost [ g - 1 ] [ s - 1 ] )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE cost = [ [ float ( ' inf ' ) ] * n for _ in range ( n ) ] NEW_LINE m = int ( input ( ) ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ' , ' ) ) NEW_LINE cost [ a - 1 ] [ b - 1 ] = c NEW_LINE cost [ b - 1 ] [ a - 1 ] = d NEW_LINE DEDENT s , g , V , P = map ( int , input ( ) . split ( ' , ' ) ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if cost [ i ] [ j ] > cost [ i ] [ k ] + cost [ k ] [ j ] : NEW_LINE INDENT cost [ i ] [ j ] = cost [ i ] [ k ] + cost [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( V - P - cost [ s - 1 ] [ g - 1 ] - cost [ g - 1 ] [ s - 1 ] ) NEW_LINE"}
{"id": "geeksforgeeks_1753_A", "sol": 0, "python_code": "def getAvg ( x , n , sum ) :\n    sum = sum + x ;\n    return float ( sum ) / n ;\ndef streamAvg ( arr , n ) :\n    avg = 0 ;\n    sum = 0 ;\n    for i in range ( n ) :\n        avg = getAvg ( arr [ i ] , i + 1 , sum ) ;\n        sum = avg * ( i + 1 ) ;\n        print ( \"Average of \" , end = \"\" ) ;\n        print ( i + 1 , end = \"\" ) ;\n        print ( \" numbers is \" , end = \"\" ) ;\n        print ( avg ) ;\n    return ;\narr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ;\nn = len ( arr ) ;\nstreamAvg ( arr , n ) ;\n", "python_code_tokenized": "def getAvg ( x , n , sum ) : NEW_LINE INDENT sum = sum + x ; NEW_LINE return float ( sum ) / n ; NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( arr [ i ] , i + 1 , sum ) ; NEW_LINE sum = avg * ( i + 1 ) ; NEW_LINE print ( \" Average \u2581 of \u2581 \" , end = \" \" ) ; NEW_LINE print ( i + 1 , end = \" \" ) ; NEW_LINE print ( \" \u2581 numbers \u2581 is \u2581 \" , end = \" \" ) ; NEW_LINE print ( avg ) ; NEW_LINE DEDENT return ; NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE streamAvg ( arr , n ) ; NEW_LINE"}
{"id": "geeksforgeeks_108_A", "sol": 0, "python_code": "def fact ( n ) :\n    if ( n == 0 ) :\n        return 1\n    return n * fact ( n - 1 )\ndef div ( x ) :\n    ans = 0 ;\n    for i in range ( 1 , x + 1 ) :\n        if ( x % i == 0 ) :\n            ans += i\n    return ans\ndef sumFactDiv ( n ) :\n    return div ( fact ( n ) )\nn = 4\nprint ( sumFactDiv ( n ) )\n", "python_code_tokenized": "def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT def div ( x ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def sumFactDiv ( n ) : NEW_LINE INDENT return div ( fact ( n ) ) NEW_LINE DEDENT n = 4 NEW_LINE print ( sumFactDiv ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1126_A", "sol": 0, "python_code": "def findSumofEle ( arr1 , m , arr2 , n , k ) :\n    arraySum = 0\n    for i in range ( n ) :\n        arraySum += arr2 [ i ]\n    mean = arraySum / n\n    sumOfElements = 0\n    difference = 0\n    for i in range ( m ) :\n        difference = arr1 [ i ] - mean\n        if ( ( difference < 0 ) and ( k > ( - 1 ) * difference ) ) :\n            sumOfElements += arr1 [ i ]\n        if ( ( difference >= 0 ) and ( k > difference ) ) :\n            sumOfElements += arr1 [ i ]\n    return sumOfElements\narr1 = [ 1 , 2 , 3 , 4 , 7 , 9 ]\narr2 = [ 0 , 1 , 2 , 1 , 1 , 4 ]\nk = 2\nm = len ( arr1 )\nn = len ( arr2 )\nprint ( findSumofEle ( arr1 , m , arr2 , n , k ) )\n", "python_code_tokenized": "def findSumofEle ( arr1 , m , arr2 , n , k ) : NEW_LINE INDENT arraySum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arraySum += arr2 [ i ] NEW_LINE DEDENT mean = arraySum / n NEW_LINE sumOfElements = 0 NEW_LINE difference = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT difference = arr1 [ i ] - mean NEW_LINE if ( ( difference < 0 ) and ( k > ( - 1 ) * difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT if ( ( difference >= 0 ) and ( k > difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT DEDENT return sumOfElements NEW_LINE DEDENT arr1 = [ 1 , 2 , 3 , 4 , 7 , 9 ] NEW_LINE arr2 = [ 0 , 1 , 2 , 1 , 1 , 4 ] NEW_LINE k = 2 NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( findSumofEle ( arr1 , m , arr2 , n , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_3577_A", "sol": 0, "python_code": "def initializeDiffArray ( A ) :\n    n = len ( A )\n    D = [ 0 for i in range ( 0 , n + 1 ) ]\n    D [ 0 ] = A [ 0 ] ; D [ n ] = 0\n    for i in range ( 1 , n ) :\n        D [ i ] = A [ i ] - A [ i - 1 ]\n    return D\ndef update ( D , l , r , x ) :\n    D [ l ] += x\n    D [ r + 1 ] -= x\ndef printArray ( A , D ) :\n    for i in range ( 0 , len ( A ) ) :\n        if ( i == 0 ) :\n            A [ i ] = D [ i ]\n        else :\n            A [ i ] = D [ i ] + A [ i - 1 ]\n        print ( A [ i ] , end = \"\" )\n    print ( \"\" )\nA = [ 10 , 5 , 20 , 40 ]\nD = initializeDiffArray ( A )\nupdate ( D , 0 , 1 , 10 )\nprintArray ( A , D )\nupdate ( D , 1 , 3 , 20 )\nupdate ( D , 2 , 2 , 30 )\nprintArray ( A , D )\n", "python_code_tokenized": "def initializeDiffArray ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE D = [ 0 for i in range ( 0 , n + 1 ) ] NEW_LINE D [ 0 ] = A [ 0 ] ; D [ n ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT D [ i ] = A [ i ] - A [ i - 1 ] NEW_LINE DEDENT return D NEW_LINE DEDENT def update ( D , l , r , x ) : NEW_LINE INDENT D [ l ] += x NEW_LINE D [ r + 1 ] -= x NEW_LINE DEDENT def printArray ( A , D ) : NEW_LINE INDENT for i in range ( 0 , len ( A ) ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT A [ i ] = D [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE DEDENT print ( A [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT A = [ 10 , 5 , 20 , 40 ] NEW_LINE D = initializeDiffArray ( A ) NEW_LINE update ( D , 0 , 1 , 10 ) NEW_LINE printArray ( A , D ) NEW_LINE update ( D , 1 , 3 , 20 ) NEW_LINE update ( D , 2 , 2 , 30 ) NEW_LINE printArray ( A , D ) NEW_LINE"}
{"id": "geeksforgeeks_1719_A", "sol": 0, "python_code": "def center_pentadecagonal_num ( n ) :\n    return ( 15 * n * n - 15 * n + 2 ) // 2\nif __name__ == '__main__' :\n    n = 3\n    print ( n , \"rd number : \" , center_pentadecagonal_num ( n ) )\n    n = 10\n    print ( n , \"th number : \" , center_pentadecagonal_num ( n ) )\n", "python_code_tokenized": "def center_pentadecagonal_num ( n ) : NEW_LINE INDENT return ( 15 * n * n - 15 * n + 2 ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , \" rd \u2581 number \u2581 : \u2581 \" , center_pentadecagonal_num ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , \" th \u2581 number \u2581 : \u2581 \" , center_pentadecagonal_num ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1064_A", "sol": 0, "python_code": "import bisect\ndef getPairs ( A , B , n ) :\n    D = [ 0 ] * ( n )\n    for i in range ( n ) :\n        D [ i ] = A [ i ] - B [ i ]\n    D.sort ( )\n    total = 0\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        if ( D [ i ] > 0 ) :\n            total += n - i - 1\n        else :\n            k = bisect.bisect_right ( D , - D [ i ] , 0 , len ( D ) )\n            total += n - k\n    return total\nif __name__ == \"__main__\" :\n    n = 5\n    A = [ ]\n    B = [ ]\n    A.append ( 4 ) ;\n    A.append ( 8 ) ;\n    A.append ( 2 ) ;\n    A.append ( 6 ) ;\n    A.append ( 2 ) ;\n    B.append ( 4 ) ;\n    B.append ( 5 ) ;\n    B.append ( 4 ) ;\n    B.append ( 1 ) ;\n    B.append ( 3 ) ;\n    print ( getPairs ( A , B , n ) )\n", "python_code_tokenized": "import bisect NEW_LINE def getPairs ( A , B , n ) : NEW_LINE INDENT D = [ 0 ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT D [ i ] = A [ i ] - B [ i ] NEW_LINE DEDENT D . sort ( ) NEW_LINE total = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( D [ i ] > 0 ) : NEW_LINE INDENT total += n - i - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = bisect . bisect_right ( D , - D [ i ] , 0 , len ( D ) ) NEW_LINE total += n - k NEW_LINE DEDENT DEDENT return total NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE A = [ ] NEW_LINE B = [ ] NEW_LINE A . append ( 4 ) ; NEW_LINE A . append ( 8 ) ; NEW_LINE A . append ( 2 ) ; NEW_LINE A . append ( 6 ) ; NEW_LINE A . append ( 2 ) ; NEW_LINE B . append ( 4 ) ; NEW_LINE B . append ( 5 ) ; NEW_LINE B . append ( 4 ) ; NEW_LINE B . append ( 1 ) ; NEW_LINE B . append ( 3 ) ; NEW_LINE print ( getPairs ( A , B , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_758_A", "sol": 0, "python_code": "from math import sqrt\nfactors = [ ]\ndef findFactors ( n ) :\n    for i in range ( 1 , int ( sqrt ( n ) ) + 1 , 1 ) :\n        if ( n % i == 0 ) :\n            if ( ( n / i ) == i ) :\n                factors.append ( i )\n            else :\n                factors.append ( n / i )\n                factors.append ( i )\ndef findProduct ( n ) :\n    product = - 1\n    si = len ( factors )\n    for i in range ( si ) :\n        for j in range ( si ) :\n            for k in range ( si ) :\n                for l in range ( si ) :\n                    s = ( factors [ i ] + factors [ j ] + factors [ k ] + factors [ l ] )\n                    if ( s == n ) :\n                        p = ( factors [ i ] * factors [ j ] * factors [ k ] * factors [ l ] )\n                        if ( p > product ) :\n                            product = p\n    return product\nif __name__ == '__main__' :\n    n = 10\n    findFactors ( n )\n    print ( int ( findProduct ( n ) ) )\n", "python_code_tokenized": "from math import sqrt NEW_LINE factors = [ ] NEW_LINE def findFactors ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( ( n / i ) == i ) : NEW_LINE INDENT factors . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT factors . append ( n / i ) NEW_LINE factors . append ( i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def findProduct ( n ) : NEW_LINE INDENT product = - 1 NEW_LINE si = len ( factors ) NEW_LINE for i in range ( si ) : NEW_LINE INDENT for j in range ( si ) : NEW_LINE INDENT for k in range ( si ) : NEW_LINE INDENT for l in range ( si ) : NEW_LINE INDENT s = ( factors [ i ] + factors [ j ] + factors [ k ] + factors [ l ] ) NEW_LINE if ( s == n ) : NEW_LINE INDENT p = ( factors [ i ] * factors [ j ] * factors [ k ] * factors [ l ] ) NEW_LINE if ( p > product ) : NEW_LINE INDENT product = p NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return product NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE findFactors ( n ) NEW_LINE print ( int ( findProduct ( n ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5189_A", "sol": 0, "python_code": "def findFirstAndLast ( arr , n , x ) :\n    first = - 1\n    last = - 1\n    for i in range ( 0 , n ) :\n        if ( x != arr [ i ] ) :\n            continue\n        if ( first == - 1 ) :\n            first = i\n        last = i\n    if ( first != - 1 ) :\n        print ( \"First Occurrence = \" , first , \" \\nLast Occurrence = \" , last )\n    else :\n        print ( \"Not Found\" )\narr = [ 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ]\nn = len ( arr )\nx = 8\nfindFirstAndLast ( arr , n , x )\n", "python_code_tokenized": "def findFirstAndLast ( arr , n , x ) : NEW_LINE INDENT first = - 1 NEW_LINE last = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( x != arr [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( first == - 1 ) : NEW_LINE INDENT first = i NEW_LINE DEDENT last = i NEW_LINE DEDENT if ( first != - 1 ) : NEW_LINE INDENT print ( \" First \u2581 Occurrence \u2581 = \u2581 \" , first , \" \u2581 \\n Last \u2581 Occurrence \u2581 = \u2581 \" , last ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Found \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE x = 8 NEW_LINE findFirstAndLast ( arr , n , x ) NEW_LINE"}
{"id": "codeforces_1585_B", "sol": 0, "python_code": "t = int ( input ( ) )\nans = [ ]\nwhile ( t ) :\n    n = int ( input ( ) )\n    array_input = input ( ).split ( )\n    if len ( array_input ) == 1 :\n        ans.append ( 0 )\n    else :\n        array = [ int ( x ) for x in array_input ]\n        max_value = max ( array )\n        e = 0\n        x = array [ - 1 ]\n        while True :\n            for i in array [ : : - 1 ] :\n                if i > x :\n                    e += 1\n                    x = i\n                if i == max_value :\n                    break\n            if i == max_value :\n                ans.append ( e )\n                break\n            if e == 0 :\n                ans.append ( 0 )\n    t -= 1\nprint ( * ans , sep = \"\\n\" )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE while ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE array_input = input ( ) . split ( ) NEW_LINE if len ( array_input ) == 1 : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT array = [ int ( x ) for x in array_input ] NEW_LINE max_value = max ( array ) NEW_LINE e = 0 NEW_LINE x = array [ - 1 ] NEW_LINE while True : NEW_LINE INDENT for i in array [ : : - 1 ] : NEW_LINE INDENT if i > x : NEW_LINE INDENT e += 1 NEW_LINE x = i NEW_LINE DEDENT if i == max_value : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == max_value : NEW_LINE INDENT ans . append ( e ) NEW_LINE break NEW_LINE DEDENT if e == 0 : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT DEDENT DEDENT t -= 1 NEW_LINE DEDENT print ( * ans , sep = \" \\n \" ) NEW_LINE"}
{"id": "geeksforgeeks_2888_A", "sol": 0, "python_code": "def getXandYintercept ( P , Q ) :\n    a = P [ 1 ] - Q [ 1 ]\n    b = P [ 0 ] - Q [ 0 ]\n    if b == 0 :\n        print ( P [ 0 ] )\n        print ( \"infinity\" )\n        return\n    if a == 0 :\n        print ( \"infinity\" )\n        print ( P [ 1 ] )\n        return\n    m = a / b\n    x = P [ 0 ]\n    y = P [ 1 ]\n    c = y - m * x\n    y = 0\n    x = ( y - c ) / m\n    print ( x )\n    x = 0\n    y = m * x + c\n    print ( y )\np1 = [ 5 , 2 ]\np2 = [ 7 , 2 ]\ngetXandYintercept ( p1 , p2 )\n", "python_code_tokenized": "def getXandYintercept ( P , Q ) : NEW_LINE INDENT a = P [ 1 ] - Q [ 1 ] NEW_LINE b = P [ 0 ] - Q [ 0 ] NEW_LINE if b == 0 : NEW_LINE INDENT print ( P [ 0 ] ) NEW_LINE print ( \" infinity \" ) NEW_LINE return NEW_LINE DEDENT if a == 0 : NEW_LINE INDENT print ( \" infinity \" ) NEW_LINE print ( P [ 1 ] ) NEW_LINE return NEW_LINE DEDENT m = a / b NEW_LINE x = P [ 0 ] NEW_LINE y = P [ 1 ] NEW_LINE c = y - m * x NEW_LINE y = 0 NEW_LINE x = ( y - c ) / m NEW_LINE print ( x ) NEW_LINE x = 0 NEW_LINE y = m * x + c NEW_LINE print ( y ) NEW_LINE DEDENT p1 = [ 5 , 2 ] NEW_LINE p2 = [ 7 , 2 ] NEW_LINE getXandYintercept ( p1 , p2 ) NEW_LINE"}
{"id": "codeforces_998_A", "sol": 0, "python_code": "from operator import index\nn = int ( input ( ) )\narr = list ( map ( int , input ( ).split ( ) ) )\nif len ( arr ) == 1 or 2 * min ( arr ) == sum ( arr ) :\n    print ( - 1 )\nelse :\n    index = 0\n    for i , val in enumerate ( arr ) :\n        if val < arr [ index ] :\n            index = i\n    print ( 1 )\n    print ( index + 1 )\n", "python_code_tokenized": "from operator import index NEW_LINE n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if len ( arr ) == 1 or 2 * min ( arr ) == sum ( arr ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT index = 0 NEW_LINE for i , val in enumerate ( arr ) : NEW_LINE INDENT if val < arr [ index ] : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT print ( 1 ) NEW_LINE print ( index + 1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1575_A", "sol": 0, "python_code": "MAX = 1000\nf = [ 0 ] * MAX\ndef fib ( n ) :\n    if ( n == 0 ) :\n        return 0\n    if ( n == 1 or n == 2 ) :\n        f [ n ] = 1\n        return f [ n ]\n    if ( f [ n ] ) :\n        return f [ n ]\n    k = ( n + 1 ) // 2 if ( n & 1 ) else n // 2\n    if ( n & 1 ) :\n        f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) )\n    else :\n        f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k )\n    return f [ n ]\ndef gcd ( a , b ) :\n    if ( a == 0 ) :\n        return b\n    return gcd ( b % a , a )\ndef findLCMFibonacci ( a , b ) :\n    return ( fib ( a ) * fib ( b ) ) // fib ( gcd ( a , b ) )\nif __name__ == \"__main__\" :\n    a = 3\n    b = 12\n    print ( findLCMFibonacci ( a , b ) )\n", "python_code_tokenized": "MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return f [ n ] NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = ( n + 1 ) // 2 if ( n & 1 ) else n // 2 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findLCMFibonacci ( a , b ) : NEW_LINE INDENT return ( fib ( a ) * fib ( b ) ) // fib ( gcd ( a , b ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE b = 12 NEW_LINE print ( findLCMFibonacci ( a , b ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02417_A", "sol": 0, "python_code": "import sys\ns = sys.stdin.read ( ).lower ( )\ntable = { \"a\" : 0 , \"b\" : 0 , \"c\" : 0 , \"d\" : 0 , \"e\" : 0 , \"f\" : 0 , \"g\" : 0 , \"h\" : 0 , \"i\" : 0 , \"j\" : 0 , \"k\" : 0 , \"l\" : 0 , \"m\" : 0 , \"n\" : 0 , \"o\" : 0 , \"p\" : 0 , \"q\" : 0 , \"r\" : 0 , \"s\" : 0 , \"t\" : 0 , \"u\" : 0 , \"v\" : 0 , \"w\" : 0 , \"x\" : 0 , \"y\" : 0 , \"z\" : 0 , }\nfor i in list ( s ) :\n    if i in table :\n        table [ i ] += 1\n    else :\n        continue\nfor i in table :\n    print ( '{} : {}'.format ( i , table [ i ] ) )\n", "python_code_tokenized": "import sys NEW_LINE s = sys . stdin . read ( ) . lower ( ) NEW_LINE table = { \" a \" : 0 , \" b \" : 0 , \" c \" : 0 , \" d \" : 0 , \" e \" : 0 , \" f \" : 0 , \" g \" : 0 , \" h \" : 0 , \" i \" : 0 , \" j \" : 0 , \" k \" : 0 , \" l \" : 0 , \" m \" : 0 , \" n \" : 0 , \" o \" : 0 , \" p \" : 0 , \" q \" : 0 , \" r \" : 0 , \" s \" : 0 , \" t \" : 0 , \" u \" : 0 , \" v \" : 0 , \" w \" : 0 , \" x \" : 0 , \" y \" : 0 , \" z \" : 0 , } NEW_LINE for i in list ( s ) : NEW_LINE INDENT if i in table : NEW_LINE INDENT table [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT for i in table : NEW_LINE INDENT print ( ' { } \u2581 : \u2581 { } ' . format ( i , table [ i ] ) ) NEW_LINE DEDENT"}
{"id": "projecteuler_p125_A", "sol": 0, "python_code": "import itertools\ndef compute ( ) :\n    nums = set ( )\n    for i in range ( 1 , 10001 ) :\n        sigma = i * i\n        for j in itertools.count ( i + 1 ) :\n            sigma += j * j\n            if sigma >= 100000000 :\n                break\n            s = str ( sigma )\n            if s == s [ : : - 1 ] :\n                nums.add ( sigma )\n    return str ( sum ( nums ) )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT nums = set ( ) NEW_LINE for i in range ( 1 , 10001 ) : NEW_LINE INDENT sigma = i * i NEW_LINE for j in itertools . count ( i + 1 ) : NEW_LINE INDENT sigma += j * j NEW_LINE if sigma >= 100000000 : NEW_LINE INDENT break NEW_LINE DEDENT s = str ( sigma ) NEW_LINE if s == s [ : : - 1 ] : NEW_LINE INDENT nums . add ( sigma ) NEW_LINE DEDENT DEDENT DEDENT return str ( sum ( nums ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1772_A", "sol": 0, "python_code": "def sum ( N ) :\n    global S1 , S2 , S3\n    S1 = ( ( ( N // 3 ) ) * ( 2 * 3 + ( N // 3 - 1 ) * 3 ) // 2 )\n    S2 = ( ( ( N // 4 ) ) * ( 2 * 4 + ( N // 4 - 1 ) * 4 ) // 2 )\n    S3 = ( ( ( N // 12 ) ) * ( 2 * 12 + ( N // 12 - 1 ) * 12 ) // 2 )\n    return int ( S1 + S2 - S3 )\nif __name__ == '__main__' :\n    N = 12\n    print ( sum ( N ) )\n", "python_code_tokenized": "def sum ( N ) : NEW_LINE INDENT global S1 , S2 , S3 NEW_LINE S1 = ( ( ( N // 3 ) ) * ( 2 * 3 + ( N // 3 - 1 ) * 3 ) // 2 ) NEW_LINE S2 = ( ( ( N // 4 ) ) * ( 2 * 4 + ( N // 4 - 1 ) * 4 ) // 2 ) NEW_LINE S3 = ( ( ( N // 12 ) ) * ( 2 * 12 + ( N // 12 - 1 ) * 12 ) // 2 ) NEW_LINE return int ( S1 + S2 - S3 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE print ( sum ( N ) ) NEW_LINE DEDENT"}
{"id": "codeforces_202_A", "sol": 0, "python_code": "import sys\ninp = input ( )\nfreqs = [ 0 ] * 26\nfor letter in inp :\n    decimal = ord ( letter ) - ord ( 'a' )\n    freqs [ decimal ] += 1\ngreater = - 1\nfor i in reversed ( range ( len ( freqs ) ) ) :\n    if ( freqs [ i ] != 0 ) :\n        greater = i\n        break\nchar = chr ( ord ( 'a' ) + greater )\nllps = char * freqs [ greater ]\nprint ( llps )\n", "python_code_tokenized": "import sys NEW_LINE inp = input ( ) NEW_LINE freqs = [ 0 ] * 26 NEW_LINE for letter in inp : NEW_LINE INDENT decimal = ord ( letter ) - ord ( ' a ' ) NEW_LINE freqs [ decimal ] += 1 NEW_LINE DEDENT greater = - 1 NEW_LINE for i in reversed ( range ( len ( freqs ) ) ) : NEW_LINE INDENT if ( freqs [ i ] != 0 ) : NEW_LINE INDENT greater = i NEW_LINE break NEW_LINE DEDENT DEDENT char = chr ( ord ( ' a ' ) + greater ) NEW_LINE llps = char * freqs [ greater ] NEW_LINE print ( llps ) NEW_LINE"}
{"id": "codeforces_1621_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    n , k = list ( map ( int , input ( ).split ( ) ) )\n    if k > ( n + 1 ) // 2 :\n        print ( - 1 )\n    else :\n        for i in range ( n ) :\n            row = [ '.' ] * n\n            if i % 2 == 0 and k > 0 :\n                row [ i ] = 'R'\n                k -= 1\n            print ( \"\".join ( row ) )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if k > ( n + 1 ) // 2 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT row = [ ' . ' ] * n NEW_LINE if i % 2 == 0 and k > 0 : NEW_LINE INDENT row [ i ] = ' R ' NEW_LINE k -= 1 NEW_LINE DEDENT print ( \" \" . join ( row ) ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "aizu_p01305_A", "sol": 0, "python_code": "from itertools import permutations as pm\ndef main ( ) :\n    t = int ( input ( ) )\n    fact9 = 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2\n    for _ in range ( t ) :\n        l1 = list ( map ( int , input ( ).split ( ) ) )\n        l2 = list ( map ( int , input ( ).split ( ) ) )\n        ans1 = 0\n        ans2 = 0\n        for hand in pm ( l2 , 9 ) :\n            score1 = 0\n            score2 = 0\n            for i , j in zip ( l1 , hand ) :\n                if i < j :\n                    score2 += ( i + j )\n                else :\n                    score1 += ( i + j )\n            if score1 < score2 :\n                ans2 += 1\n            elif score1 > score2 :\n                ans1 += 1\n        print ( ans1 / fact9 , ans2 / fact9 )\nmain ( )\n", "python_code_tokenized": "from itertools import permutations as pm NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE fact9 = 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT l1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l2 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans1 = 0 NEW_LINE ans2 = 0 NEW_LINE for hand in pm ( l2 , 9 ) : NEW_LINE INDENT score1 = 0 NEW_LINE score2 = 0 NEW_LINE for i , j in zip ( l1 , hand ) : NEW_LINE INDENT if i < j : NEW_LINE INDENT score2 += ( i + j ) NEW_LINE DEDENT else : NEW_LINE INDENT score1 += ( i + j ) NEW_LINE DEDENT DEDENT if score1 < score2 : NEW_LINE INDENT ans2 += 1 NEW_LINE DEDENT elif score1 > score2 : NEW_LINE INDENT ans1 += 1 NEW_LINE DEDENT DEDENT print ( ans1 / fact9 , ans2 / fact9 ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "codeforces_1336_A", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nl = { i + 1 : [ ] for i in range ( n ) }\nfor _ in range ( n - 1 ) :\n    a , b = map ( int , input ( ).split ( ) )\n    l [ a ].append ( b )\n    l [ b ].append ( a )\nd = { i + 1 : - 1 for i in range ( n ) }\nd [ 1 ] = 0\nq = [ 1 ]\nwhile q :\n    q1 = [ ]\n    for a in q :\n        for b in l [ a ] :\n            if d [ b ] == - 1 :\n                d [ b ] = d [ a ] + 1\n                q1.append ( b )\n    q = q1\nind = { i + 1 : 0 for i in range ( n ) }\nind [ 1 ] = len ( l [ 1 ] )\nfor i in range ( 2 , n + 1 ) :\n    ind [ i ] = len ( l [ i ] ) - 1\nsize = { i + 1 : 0 for i in range ( n ) }\nq = [ ]\nfor i in range ( 1 , n + 1 ) :\n    if ind [ i ] == 0 :\n        q.append ( i )\n        ind [ i ] = - 1\nwhile q :\n    q1 = [ ]\n    for a in q :\n        for b in l [ a ] :\n            if d [ a ] == d [ b ] + 1 :\n                size [ b ] += size [ a ] + 1\n                ind [ b ] -= 1\n                if ind [ b ] == 0 :\n                    q1.append ( b )\n    q = q1\nx = [ ]\nfor i in range ( 1 , n + 1 ) :\n    x.append ( d [ i ] - size [ i ] )\nx = sorted ( x )\nprint ( sum ( x [ n - k : ] ) )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = { i + 1 : [ ] for i in range ( n ) } NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l [ a ] . append ( b ) NEW_LINE l [ b ] . append ( a ) NEW_LINE DEDENT d = { i + 1 : - 1 for i in range ( n ) } NEW_LINE d [ 1 ] = 0 NEW_LINE q = [ 1 ] NEW_LINE while q : NEW_LINE INDENT q1 = [ ] NEW_LINE for a in q : NEW_LINE INDENT for b in l [ a ] : NEW_LINE INDENT if d [ b ] == - 1 : NEW_LINE INDENT d [ b ] = d [ a ] + 1 NEW_LINE q1 . append ( b ) NEW_LINE DEDENT DEDENT DEDENT q = q1 NEW_LINE DEDENT ind = { i + 1 : 0 for i in range ( n ) } NEW_LINE ind [ 1 ] = len ( l [ 1 ] ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT ind [ i ] = len ( l [ i ] ) - 1 NEW_LINE DEDENT size = { i + 1 : 0 for i in range ( n ) } NEW_LINE q = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ind [ i ] == 0 : NEW_LINE INDENT q . append ( i ) NEW_LINE ind [ i ] = - 1 NEW_LINE DEDENT DEDENT while q : NEW_LINE INDENT q1 = [ ] NEW_LINE for a in q : NEW_LINE INDENT for b in l [ a ] : NEW_LINE INDENT if d [ a ] == d [ b ] + 1 : NEW_LINE INDENT size [ b ] += size [ a ] + 1 NEW_LINE ind [ b ] -= 1 NEW_LINE if ind [ b ] == 0 : NEW_LINE INDENT q1 . append ( b ) NEW_LINE DEDENT DEDENT DEDENT DEDENT q = q1 NEW_LINE DEDENT x = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x . append ( d [ i ] - size [ i ] ) NEW_LINE DEDENT x = sorted ( x ) NEW_LINE print ( sum ( x [ n - k : ] ) ) NEW_LINE"}
{"id": "geeksforgeeks_3952_A", "sol": 0, "python_code": "class getNode :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.left = self.right = None\ndef hasPath ( root , arr , x ) :\n    if ( not root ) :\n        return False\n    arr.append ( root.data )\n    if ( root.data == x ) :\n        return True\n    if ( hasPath ( root.left , arr , x ) or hasPath ( root.right , arr , x ) ) :\n        return True\n    arr.pop ( - 1 )\n    return False\ndef printPath ( root , x ) :\n    arr = [ ]\n    if ( hasPath ( root , arr , x ) ) :\n        for i in range ( len ( arr ) - 1 ) :\n            print ( arr [ i ] , end = \"->\" )\n        print ( arr [ len ( arr ) - 1 ] )\n    else :\n        print ( \"No Path\" )\nif __name__ == '__main__' :\n    root = getNode ( 1 )\n    root.left = getNode ( 2 )\n    root.right = getNode ( 3 )\n    root.left.left = getNode ( 4 )\n    root.left.right = getNode ( 5 )\n    root.right.left = getNode ( 6 )\n    root.right.right = getNode ( 7 )\n    x = 5\n    printPath ( root , x )\n", "python_code_tokenized": "class getNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def hasPath ( root , arr , x ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr . append ( root . data ) NEW_LINE if ( root . data == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( hasPath ( root . left , arr , x ) or hasPath ( root . right , arr , x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . pop ( - 1 ) NEW_LINE return False NEW_LINE DEDENT def printPath ( root , x ) : NEW_LINE INDENT arr = [ ] NEW_LINE if ( hasPath ( root , arr , x ) ) : NEW_LINE INDENT for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" - > \" ) NEW_LINE DEDENT print ( arr [ len ( arr ) - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 Path \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = getNode ( 1 ) NEW_LINE root . left = getNode ( 2 ) NEW_LINE root . right = getNode ( 3 ) NEW_LINE root . left . left = getNode ( 4 ) NEW_LINE root . left . right = getNode ( 5 ) NEW_LINE root . right . left = getNode ( 6 ) NEW_LINE root . right . right = getNode ( 7 ) NEW_LINE x = 5 NEW_LINE printPath ( root , x ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4515_A", "sol": 0, "python_code": "import math\ndef setBit ( xorValue ) :\n    count = 0\n    while ( xorValue ) :\n        if ( xorValue % 2 ) :\n            count += 1\n        xorValue = int ( xorValue / 2 )\n    return count\ndef minFlip ( n , k ) :\n    size = int ( math.log ( n ) / math.log ( 2 ) + 1 )\n    max = pow ( 2 , k ) - 1\n    max = max << ( size - k )\n    xorValue = ( n ^ max )\n    return ( setBit ( xorValue ) )\nn = 27\nk = 3\nprint ( \"Min Flips = \" , minFlip ( n , k ) )\n", "python_code_tokenized": "import math NEW_LINE def setBit ( xorValue ) : NEW_LINE INDENT count = 0 NEW_LINE while ( xorValue ) : NEW_LINE INDENT if ( xorValue % 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT xorValue = int ( xorValue / 2 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def minFlip ( n , k ) : NEW_LINE INDENT size = int ( math . log ( n ) / math . log ( 2 ) + 1 ) NEW_LINE max = pow ( 2 , k ) - 1 NEW_LINE max = max << ( size - k ) NEW_LINE xorValue = ( n ^ max ) NEW_LINE return ( setBit ( xorValue ) ) NEW_LINE DEDENT n = 27 NEW_LINE k = 3 NEW_LINE print ( \" Min \u2581 Flips \u2581 = \u2581 \" , minFlip ( n , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_1963_A", "sol": 0, "python_code": "def printNonConsecutive ( n ) :\n    p = ( 1 << n )\n    for i in range ( 1 , p ) :\n        if ( ( i & ( i << 1 ) ) == 0 ) :\n            print ( i , end = \" \" )\nn = 3\nprintNonConsecutive ( n )\n", "python_code_tokenized": "def printNonConsecutive ( n ) : NEW_LINE INDENT p = ( 1 << n ) NEW_LINE for i in range ( 1 , p ) : NEW_LINE INDENT if ( ( i & ( i << 1 ) ) == 0 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT n = 3 NEW_LINE printNonConsecutive ( n ) NEW_LINE"}
{"id": "aizu_p00554_A", "sol": 0, "python_code": "N , M = map ( int , input ( ).split ( ) )\na = [ ]\nfor _ in range ( M ) :\n    n , m = map ( int , input ( ).split ( ) )\n    a.append ( n )\na.sort ( reverse = True )\nresult = 0\nfor i in range ( M - 1 ) :\n    if a [ i ] < N : result += N - a [ i ]\nprint ( result )\n", "python_code_tokenized": "N , M = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( n ) NEW_LINE DEDENT a . sort ( reverse = True ) NEW_LINE result = 0 NEW_LINE for i in range ( M - 1 ) : NEW_LINE INDENT if a [ i ] < N : result += N - a [ i ] NEW_LINE DEDENT print ( result ) NEW_LINE"}
{"id": "geeksforgeeks_3351_A", "sol": 0, "python_code": "def printPattern ( n ) :\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , 2 * n ) :\n            if ( j == ( n - i + 1 ) or j == ( n + i - 1 ) ) :\n                print ( \"* \" , end = \"\" )\n            elif ( ( i >= 4 and i <= n - 4 ) and ( j == n - i + 4 or j == n + i - 4 ) ) :\n                print ( \"* \" , end = \"\" )\n            elif ( i == n or ( i == n - 4 and j >= n - ( n - 2 * 4 ) and j <= n + n - 2 * 4 ) ) :\n                print ( \"* \" , end = \"\" )\n            else :\n                print ( \"\" + \"\" , end = \"\" )\n        print ( )\nN = 9\nprintPattern ( N )\n", "python_code_tokenized": "def printPattern ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , 2 * n ) : NEW_LINE INDENT if ( j == ( n - i + 1 ) or j == ( n + i - 1 ) ) : NEW_LINE INDENT print ( \" * \u2581 \" , end = \" \" ) NEW_LINE DEDENT elif ( ( i >= 4 and i <= n - 4 ) and ( j == n - i + 4 or j == n + i - 4 ) ) : NEW_LINE INDENT print ( \" * \u2581 \" , end = \" \" ) NEW_LINE DEDENT elif ( i == n or ( i == n - 4 and j >= n - ( n - 2 * 4 ) and j <= n + n - 2 * 4 ) ) : NEW_LINE INDENT print ( \" * \u2581 \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \u2581 \" + \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT N = 9 NEW_LINE printPattern ( N ) NEW_LINE"}
{"id": "codeforces_1709_B", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nlst = [ ]\nfor i in range ( 0 , m ) :\n    x , y = map ( int , input ( ).split ( ) )\n    lst.append ( [ x , y ] )\ndp1 = [ 0 for i in range ( 0 , n ) ]\ndp2 = [ 0 for i in range ( 0 , n ) ]\nfor i in range ( 1 , n ) :\n    if a [ i ] < a [ i - 1 ] :\n        dp1 [ i ] = dp1 [ i - 1 ] + a [ i - 1 ] - a [ i ]\n    else :\n        dp1 [ i ] = dp1 [ i - 1 ]\nfor i in range ( n - 2 , - 1 , - 1 ) :\n    if a [ i + 1 ] > a [ i ] :\n        dp2 [ i ] = dp2 [ i + 1 ] + a [ i + 1 ] - a [ i ]\n    else :\n        dp2 [ i ] = dp2 [ i + 1 ]\nfor item in lst :\n    if item [ 0 ] < item [ 1 ] :\n        ans = dp1 [ item [ 1 ] - 1 ] - dp1 [ item [ 0 ] - 1 ]\n    else :\n        ans = dp2 [ item [ 1 ] - 1 ] - dp2 [ item [ 0 ] - 1 ]\n    print ( ans )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lst = [ ] NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE lst . append ( [ x , y ] ) NEW_LINE DEDENT dp1 = [ 0 for i in range ( 0 , n ) ] NEW_LINE dp2 = [ 0 for i in range ( 0 , n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] < a [ i - 1 ] : NEW_LINE INDENT dp1 [ i ] = dp1 [ i - 1 ] + a [ i - 1 ] - a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT dp1 [ i ] = dp1 [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i + 1 ] > a [ i ] : NEW_LINE INDENT dp2 [ i ] = dp2 [ i + 1 ] + a [ i + 1 ] - a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT dp2 [ i ] = dp2 [ i + 1 ] NEW_LINE DEDENT DEDENT for item in lst : NEW_LINE INDENT if item [ 0 ] < item [ 1 ] : NEW_LINE INDENT ans = dp1 [ item [ 1 ] - 1 ] - dp1 [ item [ 0 ] - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = dp2 [ item [ 1 ] - 1 ] - dp2 [ item [ 0 ] - 1 ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "codeforces_78_A", "sol": 0, "python_code": "x = 0\nfor i in range ( 3 ) :\n    s = input ( )\n    c = 0\n    if i == 0 or i == 2 :\n        for i in s :\n            if i in 'aeiou' :\n                c += 1\n        if c != 5 :\n            x += 1\n    else :\n        for i in s :\n            if i in 'aeiou' :\n                c += 1\n        if c != 7 :\n            x += 1\nif not x :\n    print ( \"YES\" )\nelse : print ( \"NO\" )\n", "python_code_tokenized": "x = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT s = input ( ) NEW_LINE c = 0 NEW_LINE if i == 0 or i == 2 : NEW_LINE INDENT for i in s : NEW_LINE INDENT if i in ' aeiou ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c != 5 : NEW_LINE INDENT x += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in s : NEW_LINE INDENT if i in ' aeiou ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c != 7 : NEW_LINE INDENT x += 1 NEW_LINE DEDENT DEDENT DEDENT if not x : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : print ( \" NO \" ) NEW_LINE"}
{"id": "geeksforgeeks_2636_A", "sol": 0, "python_code": "def seriesFunc ( n ) :\n    sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6\n    sumNatural = ( n * ( n + 1 ) / 2 )\n    return ( sumSquare + sumNatural + 1 )\nn = 8\nprint ( int ( seriesFunc ( n ) ) )\nn = 13\nprint ( int ( seriesFunc ( n ) ) )\n", "python_code_tokenized": "def seriesFunc ( n ) : NEW_LINE INDENT sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE sumNatural = ( n * ( n + 1 ) / 2 ) NEW_LINE return ( sumSquare + sumNatural + 1 ) NEW_LINE DEDENT n = 8 NEW_LINE print ( int ( seriesFunc ( n ) ) ) NEW_LINE n = 13 NEW_LINE print ( int ( seriesFunc ( n ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_632_A", "sol": 0, "python_code": "def distinctSubstring ( P , Q , K , N ) :\n    S = set ( )\n    for i in range ( 0 , N ) :\n        sum = 0 ;\n        s = ''\n        for j in range ( i , N ) :\n            pos = ord ( P [ j ] ) - 97\n            sum = sum + ord ( Q [ pos ] ) - 48\n            s += P [ j ]\n            if ( sum <= K ) :\n                S.add ( s )\n            else :\n                break\n    return len ( S )\nP = \"abcde\"\nQ = \"12345678912345678912345678\"\nK = 5\nN = len ( P )\nprint ( distinctSubstring ( P , Q , K , N ) )\n", "python_code_tokenized": "def distinctSubstring ( P , Q , K , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE s = ' ' NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - 97 NEW_LINE sum = sum + ord ( Q [ pos ] ) - 48 NEW_LINE s += P [ j ] NEW_LINE if ( sum <= K ) : NEW_LINE INDENT S . add ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( S ) NEW_LINE DEDENT P = \" abcde \" NEW_LINE Q = \"12345678912345678912345678\" NEW_LINE K = 5 NEW_LINE N = len ( P ) NEW_LINE print ( distinctSubstring ( P , Q , K , N ) ) NEW_LINE"}
{"id": "geeksforgeeks_2733_A", "sol": 0, "python_code": "def division_of_string ( string , k ) :\n    n = len ( string ) ;\n    has = { } ;\n    cnt = 0 ; i = 0 ;\n    while ( i < n ) :\n        if string [ i ] not in has :\n            cnt += 1 ;\n            has [ string [ i ] ] = True ;\n        if ( cnt == k ) :\n            ans = i ;\n            break ;\n        i += 1 ;\n    has.clear ( ) ;\n    cnt = 0 ;\n    while ( i < n ) :\n        if ( string [ i ] not in has ) :\n            cnt += 1 ;\n            has [ string [ i ] ] = True ;\n        if ( cnt == k ) :\n            break ;\n        i += 1 ;\n    if ( cnt < k ) :\n        print ( \"Not possible\" , end = \"\" ) ;\n    else :\n        i = 0 ;\n        while ( i <= ans ) :\n            print ( string [ i ] , end = \"\" ) ;\n            i += 1 ;\n        print ( ) ;\n        while ( i < n ) :\n            print ( string [ i ] , end = \"\" ) ;\n            i += 1 ;\n        print ( )\nif __name__ == \"__main__\" :\n    string = \"geeksforgeeks\" ;\n    k = 4 ;\n    division_of_string ( string , k ) ;\n", "python_code_tokenized": "def division_of_string ( string , k ) : NEW_LINE INDENT n = len ( string ) ; NEW_LINE has = { } ; NEW_LINE cnt = 0 ; i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if string [ i ] not in has : NEW_LINE INDENT cnt += 1 ; NEW_LINE has [ string [ i ] ] = True ; NEW_LINE DEDENT if ( cnt == k ) : NEW_LINE INDENT ans = i ; NEW_LINE break ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT has . clear ( ) ; NEW_LINE cnt = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( string [ i ] not in has ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE has [ string [ i ] ] = True ; NEW_LINE DEDENT if ( cnt == k ) : NEW_LINE INDENT break ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( cnt < k ) : NEW_LINE INDENT print ( \" Not \u2581 possible \" , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT i = 0 ; NEW_LINE while ( i <= ans ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT print ( ) ; NEW_LINE while ( i < n ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE k = 4 ; NEW_LINE division_of_string ( string , k ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_837_A", "sol": 0, "python_code": "def anglequichord ( z ) :\n    print ( \"The angle is \" , z , \" degrees\" )\nif __name__ == \"__main__\" :\n    z = 48\n    anglequichord ( z )\n", "python_code_tokenized": "def anglequichord ( z ) : NEW_LINE INDENT print ( \" The \u2581 angle \u2581 is \u2581 \" , z , \" \u2581 degrees \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT z = 48 NEW_LINE anglequichord ( z ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4659_A", "sol": 0, "python_code": "def checkPattern ( string , pattern ) :\n    l = len ( pattern )\n    if len ( string ) < l :\n        return False\n    for i in range ( l - 1 ) :\n        x = pattern [ i ]\n        y = pattern [ i + 1 ]\n        last = string.rindex ( x )\n        first = string.index ( y )\n        if last == - 1 or first == - 1 or last > first :\n            return False\n    return True\nif __name__ == \"__main__\" :\n    string = \"engineers rock\"\n    pattern = \"gsr\"\n    print ( checkPattern ( string , pattern ) )\n", "python_code_tokenized": "def checkPattern ( string , pattern ) : NEW_LINE INDENT l = len ( pattern ) NEW_LINE if len ( string ) < l : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( l - 1 ) : NEW_LINE INDENT x = pattern [ i ] NEW_LINE y = pattern [ i + 1 ] NEW_LINE last = string . rindex ( x ) NEW_LINE first = string . index ( y ) NEW_LINE if last == - 1 or first == - 1 or last > first : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" engineers \u2581 rock \" NEW_LINE pattern = \" gsr \" NEW_LINE print ( checkPattern ( string , pattern ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1536_B", "sol": 0, "python_code": "def solve ( ) :\n    n = int ( input ( ) )\n    s = input ( )\n    for a in range ( 26 ) :\n        c = chr ( a + ord ( 'a' ) )\n        if c not in s :\n            print ( c )\n            return\n    for a in range ( 26 ) :\n        c1 = chr ( a + ord ( 'a' ) )\n        for b in range ( 26 ) :\n            c2 = chr ( b + ord ( 'a' ) )\n            c = c1 + c2\n            if c not in s :\n                print ( c )\n                return\n    for a in range ( 26 ) :\n        c1 = chr ( a + ord ( 'a' ) )\n        for b in range ( 26 ) :\n            c2 = chr ( b + ord ( 'a' ) )\n            c4 = c1 + c2\n            for d in range ( 26 ) :\n                c3 = chr ( d + ord ( 'a' ) )\n                c = c4 + c3\n                if c not in s :\n                    print ( c )\n                    return\nt = int ( input ( ) )\nwhile t != 0 :\n    t -= 1\n    solve ( )\n", "python_code_tokenized": "def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE for a in range ( 26 ) : NEW_LINE INDENT c = chr ( a + ord ( ' a ' ) ) NEW_LINE if c not in s : NEW_LINE INDENT print ( c ) NEW_LINE return NEW_LINE DEDENT DEDENT for a in range ( 26 ) : NEW_LINE INDENT c1 = chr ( a + ord ( ' a ' ) ) NEW_LINE for b in range ( 26 ) : NEW_LINE INDENT c2 = chr ( b + ord ( ' a ' ) ) NEW_LINE c = c1 + c2 NEW_LINE if c not in s : NEW_LINE INDENT print ( c ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT for a in range ( 26 ) : NEW_LINE INDENT c1 = chr ( a + ord ( ' a ' ) ) NEW_LINE for b in range ( 26 ) : NEW_LINE INDENT c2 = chr ( b + ord ( ' a ' ) ) NEW_LINE c4 = c1 + c2 NEW_LINE for d in range ( 26 ) : NEW_LINE INDENT c3 = chr ( d + ord ( ' a ' ) ) NEW_LINE c = c4 + c3 NEW_LINE if c not in s : NEW_LINE INDENT print ( c ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT t = int ( input ( ) ) NEW_LINE while t != 0 : NEW_LINE INDENT t -= 1 NEW_LINE solve ( ) NEW_LINE DEDENT"}
{"id": "codeforces_160_B", "sol": 0, "python_code": "nick = int ( input ( ) )\nsam = input ( )\nl_1 = list ( )\nl_2 = list ( )\nfor c in sam [ : nick ] :\n    l_1.append ( int ( c ) )\nfor c in sam [ nick : ] :\n    l_2.append ( int ( c ) )\nl_1.sort ( )\nl_2.sort ( )\nif ( l_1 [ 0 ] == l_2 [ 0 ] ) :\n    print ( \"NO\" )\n    quit ( )\nelse :\n    g = l_1 [ 0 ] > l_2 [ 0 ]\nfor i in range ( 1 , nick ) :\n    if g and l_1 [ i ] > l_2 [ i ] :\n        pass\n    elif not g and l_1 [ i ] < l_2 [ i ] :\n        pass\n    else :\n        print ( \"NO\" )\n        quit ( )\nprint ( \"YES\" )\n", "python_code_tokenized": "nick = int ( input ( ) ) NEW_LINE sam = input ( ) NEW_LINE l_1 = list ( ) NEW_LINE l_2 = list ( ) NEW_LINE for c in sam [ : nick ] : NEW_LINE INDENT l_1 . append ( int ( c ) ) NEW_LINE DEDENT for c in sam [ nick : ] : NEW_LINE INDENT l_2 . append ( int ( c ) ) NEW_LINE DEDENT l_1 . sort ( ) NEW_LINE l_2 . sort ( ) NEW_LINE if ( l_1 [ 0 ] == l_2 [ 0 ] ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE quit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT g = l_1 [ 0 ] > l_2 [ 0 ] NEW_LINE DEDENT for i in range ( 1 , nick ) : NEW_LINE INDENT if g and l_1 [ i ] > l_2 [ i ] : NEW_LINE INDENT pass NEW_LINE DEDENT elif not g and l_1 [ i ] < l_2 [ i ] : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE quit ( ) NEW_LINE DEDENT DEDENT print ( \" YES \" ) NEW_LINE"}
{"id": "atcoder_ARC068_B", "sol": 0, "python_code": "from collections import defaultdict , deque\nfrom heapq import heappush , heappop\nfrom itertools import permutations , accumulate\nimport sys\nimport math\nimport bisect\ndef LI ( ) : return [ int ( x ) for x in sys.stdin.buffer.readline ( ).split ( ) ]\ndef I ( ) : return int ( sys.stdin.buffer.readline ( ) )\ndef LS ( ) : return [ list ( x ) for x in sys.stdin.readline ( ).split ( ) ]\ndef S ( ) :\n    res = list ( sys.stdin.readline ( ) )\n    if res [ - 1 ] == \"\\n\" :\n        return res [ : - 1 ]\n    return res\ndef IR ( n ) :\n    return [ I ( ) for i in range ( n ) ]\ndef LIR ( n ) :\n    return [ LI ( ) for i in range ( n ) ]\ndef SR ( n ) :\n    return [ S ( ) for i in range ( n ) ]\ndef LSR ( n ) :\n    return [ LS ( ) for i in range ( n ) ]\nsys.setrecursionlimit ( 1000000 )\nmod = 1000000007\ndef solve ( ) :\n    n = I ( )\n    a = LI ( )\n    c = defaultdict ( lambda : 0 )\n    for i in a :\n        c [ i ] += 1\n    a = [ [ i , 2 - ( j & 1 ) ] for ( i , j ) in c.items ( ) ]\n    a.sort ( )\n    s = 0\n    c = 0\n    for i in range ( len ( a ) ) :\n        if a [ i ] [ 1 ] == 2 :\n            c += 1\n        s += a [ i ] [ 1 ]\n    s -= c\n    if c & 1 :\n        s -= 1\n    print ( s )\n    return\nif __name__ == \"__main__\" :\n    solve ( )\n", "python_code_tokenized": "from collections import defaultdict , deque NEW_LINE from heapq import heappush , heappop NEW_LINE from itertools import permutations , accumulate NEW_LINE import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . buffer . readline ( ) . split ( ) ] NEW_LINE def I ( ) : return int ( sys . stdin . buffer . readline ( ) ) NEW_LINE def LS ( ) : return [ list ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def S ( ) : NEW_LINE INDENT res = list ( sys . stdin . readline ( ) ) NEW_LINE if res [ - 1 ] == \" \\n \" : NEW_LINE INDENT return res [ : - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT def IR ( n ) : NEW_LINE INDENT return [ I ( ) for i in range ( n ) ] NEW_LINE DEDENT def LIR ( n ) : NEW_LINE INDENT return [ LI ( ) for i in range ( n ) ] NEW_LINE DEDENT def SR ( n ) : NEW_LINE INDENT return [ S ( ) for i in range ( n ) ] NEW_LINE DEDENT def LSR ( n ) : NEW_LINE INDENT return [ LS ( ) for i in range ( n ) ] NEW_LINE DEDENT sys . setrecursionlimit ( 1000000 ) NEW_LINE mod = 1000000007 NEW_LINE def solve ( ) : NEW_LINE INDENT n = I ( ) NEW_LINE a = LI ( ) NEW_LINE c = defaultdict ( lambda : 0 ) NEW_LINE for i in a : NEW_LINE INDENT c [ i ] += 1 NEW_LINE DEDENT a = [ [ i , 2 - ( j & 1 ) ] for ( i , j ) in c . items ( ) ] NEW_LINE a . sort ( ) NEW_LINE s = 0 NEW_LINE c = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] [ 1 ] == 2 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT s += a [ i ] [ 1 ] NEW_LINE DEDENT s -= c NEW_LINE if c & 1 : NEW_LINE INDENT s -= 1 NEW_LINE DEDENT print ( s ) NEW_LINE return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC145_A", "sol": 0, "python_code": "r = int ( input ( ) )\nprint ( r * r )\n", "python_code_tokenized": "r = int ( input ( ) ) NEW_LINE print ( r * r ) NEW_LINE"}
{"id": "codejam_14_13", "sol": 0, "python_code": "import sys\ndef prework ( argv ) :\n    l = range ( 1000 )\n    def test ( func ) :\n        lg = list ( l )\n        func ( lg )\n        return check ( lg )\n    ans = [ ( test ( good ) , test ( bad ) ) for _ in range ( 20 ) ]\n    print ( * ans , sep = '\\n' , file = sys.stderr )\n    return \"above\"\nimport random\ndef good ( l ) :\n    n = len ( l )\n    for k in range ( n ) :\n        p = random.randint ( k , n - 1 )\n        l [ k ] , l [ p ] = l [ p ] , l [ k ]\ndef bad ( l ) :\n    n = len ( l )\n    for k in range ( n ) :\n        p = random.randint ( 0 , n - 1 )\n        l [ k ] , l [ p ] = l [ p ] , l [ k ]\ndef check ( l ) :\n    a = len ( [ 1 for i , x in enumerate ( l ) if i - x > 0 ] )\n    b = len ( [ 1 for i , x in enumerate ( l ) if i - x < 0 ] )\n    r = a / b\n    return r > 0.94\ndef once ( ) :\n    n = int ( input ( ) )\n    l = [ int ( x ) for x in input ( ).split ( ) ]\n    return \"GOOD\" if check ( l ) else \"BAD\"\n    pass\ndef printerr ( * v ) :\n    print ( * v , file = sys.stderr )\ndef main ( ) :\n    TT = int ( input ( ) )\n    for tt in range ( 1 , TT + 1 ) :\n        printerr ( \"coping Case %d..\" % ( tt ) )\n        ans = once ( )\n        print ( \"Case #%d: %s\" % ( tt , ( ans ) ) )\nif __name__ == '__main__' :\n    msg = prework ( sys.argv )\n    print ( \"prework down with\" , msg , file = sys.stderr )\n    main ( )\n", "python_code_tokenized": "import sys NEW_LINE def prework ( argv ) : NEW_LINE INDENT l = range ( 1000 ) NEW_LINE def test ( func ) : NEW_LINE INDENT lg = list ( l ) NEW_LINE func ( lg ) NEW_LINE return check ( lg ) NEW_LINE DEDENT ans = [ ( test ( good ) , test ( bad ) ) for _ in range ( 20 ) ] NEW_LINE print ( * ans , sep = ' \\n ' , file = sys . stderr ) NEW_LINE return \" above \" NEW_LINE DEDENT import random NEW_LINE def good ( l ) : NEW_LINE INDENT n = len ( l ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT p = random . randint ( k , n - 1 ) NEW_LINE l [ k ] , l [ p ] = l [ p ] , l [ k ] NEW_LINE DEDENT DEDENT def bad ( l ) : NEW_LINE INDENT n = len ( l ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT p = random . randint ( 0 , n - 1 ) NEW_LINE l [ k ] , l [ p ] = l [ p ] , l [ k ] NEW_LINE DEDENT DEDENT def check ( l ) : NEW_LINE INDENT a = len ( [ 1 for i , x in enumerate ( l ) if i - x > 0 ] ) NEW_LINE b = len ( [ 1 for i , x in enumerate ( l ) if i - x < 0 ] ) NEW_LINE r = a / b NEW_LINE return r > 0.94 NEW_LINE DEDENT def once ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE return \" GOOD \" if check ( l ) else \" BAD \" NEW_LINE pass NEW_LINE DEDENT def printerr ( * v ) : NEW_LINE INDENT print ( * v , file = sys . stderr ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT TT = int ( input ( ) ) NEW_LINE for tt in range ( 1 , TT + 1 ) : NEW_LINE INDENT printerr ( \" coping \u2581 Case \u2581 % d . . \" % ( tt ) ) NEW_LINE ans = once ( ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( tt , ( ans ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT msg = prework ( sys . argv ) NEW_LINE print ( \" prework \u2581 down \u2581 with \" , msg , file = sys . stderr ) NEW_LINE main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_1330_A", "sol": 0, "python_code": "R = lambda : map ( int , input ( ).split ( ) )\nt , = R ( )\nexec ( t * 'n,x=R();print(sorted({*range(1,202)}-{*R()})[x]-1);' )\n", "python_code_tokenized": "R = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE t , = R ( ) NEW_LINE exec ( t * ' n , x = R ( ) ; print ( sorted ( { * range ( 1,202 ) } - { * R ( ) } ) [ x ] -1 ) ; ' ) NEW_LINE"}
{"id": "aizu_p00258_A", "sol": 0, "python_code": "bitcount = [ bin ( i ).count ( '1' ) for i in range ( 0x10000 ) ]\ndef solve ( a , b ) :\n    global bitcount\n    b = [ 65535 ^ bi for bi in b ]\n    pdp = { a [ 0 ] : 0 }\n    ndp = { }\n    for ai in a [ 1 : ] + [ 0 ] :\n        for k , v in pdp.items ( ) :\n            v += bitcount [ k ]\n            for bi in b :\n                bi &= k\n                vb = v - bitcount [ bi ]\n                bi |= ai\n                try :\n                    if ndp [ bi ] < vb :\n                        ndp [ bi ] = vb\n                except KeyError :\n                    ndp [ bi ] = vb\n        pdp , ndp = ndp , { }\n    return max ( pdp.values ( ) )\nimport sys\nf = sys.stdin\nwhile True :\n    n , c = map ( int , f.readline ( ).split ( ) )\n    if n == c == 0 :\n        break\n    a = [ int ( ''.join ( f.readline ( ).split ( ) ) , 2 ) for i in range ( n ) ]\n    b = [ int ( ''.join ( f.readline ( ).split ( ) ) , 2 ) for i in range ( c ) ]\n    print ( solve ( a , b ) )\n", "python_code_tokenized": "bitcount = [ bin ( i ) . count ( '1' ) for i in range ( 0x10000 ) ] NEW_LINE def solve ( a , b ) : NEW_LINE INDENT global bitcount NEW_LINE b = [ 65535 ^ bi for bi in b ] NEW_LINE pdp = { a [ 0 ] : 0 } NEW_LINE ndp = { } NEW_LINE for ai in a [ 1 : ] + [ 0 ] : NEW_LINE INDENT for k , v in pdp . items ( ) : NEW_LINE INDENT v += bitcount [ k ] NEW_LINE for bi in b : NEW_LINE INDENT bi &= k NEW_LINE vb = v - bitcount [ bi ] NEW_LINE bi |= ai NEW_LINE try : NEW_LINE INDENT if ndp [ bi ] < vb : NEW_LINE INDENT ndp [ bi ] = vb NEW_LINE DEDENT DEDENT except KeyError : NEW_LINE INDENT ndp [ bi ] = vb NEW_LINE DEDENT DEDENT DEDENT pdp , ndp = ndp , { } NEW_LINE DEDENT return max ( pdp . values ( ) ) NEW_LINE DEDENT import sys NEW_LINE f = sys . stdin NEW_LINE while True : NEW_LINE INDENT n , c = map ( int , f . readline ( ) . split ( ) ) NEW_LINE if n == c == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ int ( ' ' . join ( f . readline ( ) . split ( ) ) , 2 ) for i in range ( n ) ] NEW_LINE b = [ int ( ' ' . join ( f . readline ( ) . split ( ) ) , 2 ) for i in range ( c ) ] NEW_LINE print ( solve ( a , b ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02266_A", "sol": 0, "python_code": "s1 = [ ]\ns2 = [ ]\na = 0\ns = input ( )\nfor i in range ( len ( s ) ) :\n    if s [ i ] == \"\\\\\" :\n        s1.append ( i )\n    elif s [ i ] == \"/\" and len ( s1 ) > 0 :\n        j = s1.pop ( )\n        a += i - j\n        a_splt = i - j\n        while ( len ( s2 ) > 0 and s2 [ - 1 ] [ 0 ] > j ) :\n            a_splt += s2.pop ( ) [ 1 ]\n        s2.append ( [ j , a_splt ] )\nprint ( a )\nans = \"\"\nans += str ( len ( s2 ) )\nfor area in s2 :\n    ans += \" \" + str ( area [ 1 ] )\nprint ( ans )\n", "python_code_tokenized": "s1 = [ ] NEW_LINE s2 = [ ] NEW_LINE a = 0 NEW_LINE s = input ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == \" \\ \\ \" : NEW_LINE INDENT s1 . append ( i ) NEW_LINE DEDENT elif s [ i ] == \" / \" and len ( s1 ) > 0 : NEW_LINE INDENT j = s1 . pop ( ) NEW_LINE a += i - j NEW_LINE a_splt = i - j NEW_LINE while ( len ( s2 ) > 0 and s2 [ - 1 ] [ 0 ] > j ) : NEW_LINE INDENT a_splt += s2 . pop ( ) [ 1 ] NEW_LINE DEDENT s2 . append ( [ j , a_splt ] ) NEW_LINE DEDENT DEDENT print ( a ) NEW_LINE ans = \" \" NEW_LINE ans += str ( len ( s2 ) ) NEW_LINE for area in s2 : NEW_LINE INDENT ans += \" \u2581 \" + str ( area [ 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_975_A", "sol": 0, "python_code": "def smallest ( s ) :\n    l = len ( s )\n    ans = \"\"\n    for i in range ( l ) :\n        if ( s [ i ] > s [ i + 1 ] ) :\n            for j in range ( l ) :\n                if ( i != j ) :\n                    ans += s [ j ]\n            return ans\n    ans = s [ 0 : l - 1 ]\n    return ans\nif __name__ == \"__main__\" :\n    s = \"abcda\"\n    print ( smallest ( s ) )\n", "python_code_tokenized": "def smallest ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE ans = \" \" NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT for j in range ( l ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT ans += s [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT ans = s [ 0 : l - 1 ] NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abcda \" NEW_LINE print ( smallest ( s ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00532_A", "sol": 0, "python_code": "n = int ( input ( ) )\nm = int ( input ( ) )\nans = [ 0 ] * n\na = list ( map ( int , input ( ).split ( ) ) )\nfor i in range ( m ) :\n    cnt = 0\n    b = list ( map ( int , input ( ).split ( ) ) )\n    for j in range ( n ) :\n        if b [ j ] == a [ i ] :\n            ans [ j ] += 1\n        else :\n            cnt += 1\n    ans [ a [ i ] - 1 ] += cnt\nfor i in range ( n ) :\n    print ( ans [ i ] )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE ans = [ 0 ] * n NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT cnt = 0 NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT if b [ j ] == a [ i ] : NEW_LINE INDENT ans [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT ans [ a [ i ] - 1 ] += cnt NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] ) NEW_LINE DEDENT"}
{"id": "atcoder_ARC085_B", "sol": 0, "python_code": "n , z , w = map ( int , input ( ).split ( ) )\na = [ int ( i ) for i in input ( ).split ( ) ]\nif n == 1 :\n    print ( abs ( a [ - 1 ] - w ) )\nelse :\n    print ( max ( abs ( a [ - 1 ] - w ) , abs ( a [ - 2 ] - a [ - 1 ] ) ) )\n", "python_code_tokenized": "n , z , w = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if n == 1 : NEW_LINE INDENT print ( abs ( a [ - 1 ] - w ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( abs ( a [ - 1 ] - w ) , abs ( a [ - 2 ] - a [ - 1 ] ) ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02268_A", "sol": 0, "python_code": "n = int ( input ( ) )\nS = list ( map ( int , input ( ).split ( ) ) )\nq = int ( input ( ) )\nT = list ( map ( int , input ( ).split ( ) ) )\nans = 0\ndef binary_search ( lis , item ) :\n    l = 0\n    r = len ( lis ) - 1\n    while l <= r :\n        mid = ( l + r ) // 2\n        guess = lis [ mid ]\n        if guess == item :\n            return 1\n        if guess > item :\n            r = mid - 1\n        else :\n            l = mid + 1\n    return 0\nfor i in T :\n    ans += binary_search ( S , i )\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE S = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE T = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE def binary_search ( lis , item ) : NEW_LINE INDENT l = 0 NEW_LINE r = len ( lis ) - 1 NEW_LINE while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE guess = lis [ mid ] NEW_LINE if guess == item : NEW_LINE INDENT return 1 NEW_LINE DEDENT if guess > item : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT for i in T : NEW_LINE INDENT ans += binary_search ( S , i ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "atcoder_ABC147_F", "sol": 0, "python_code": "def solve ( N , X , D ) :\n    if D == 0 :\n        if X == 0 :\n            return 1\n        return N + 1\n    L = { 0 : [ ( 0 , 1 ) , ( 1 , - 1 ) ] }\n    coef_l = 0\n    coef_r = 1\n    for coef_x in range ( 1 , N + 1 ) :\n        m = X * coef_x % D\n        l = X * coef_x // D + coef_l\n        r = X * coef_x // D + coef_x * N - coef_r\n        coef_l = coef_r\n        coef_r += coef_x + 1\n        if m not in L :\n            L [ m ] = [ ]\n        L [ m ].append ( ( l , 1 ) )\n        L [ m ].append ( ( r + 1 , - 1 ) )\n    ans = 0\n    for Q in L.values ( ) :\n        Q.sort ( )\n        cnt = 0\n        last = None\n        for val , sign in Q :\n            if cnt > 0 :\n                ans += val - last\n            cnt += sign\n            last = val\n    return ans\nN , X , D = map ( int , input ( ).split ( ) )\nprint ( solve ( N , X , D ) )\n", "python_code_tokenized": "def solve ( N , X , D ) : NEW_LINE INDENT if D == 0 : NEW_LINE INDENT if X == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return N + 1 NEW_LINE DEDENT L = { 0 : [ ( 0 , 1 ) , ( 1 , - 1 ) ] } NEW_LINE coef_l = 0 NEW_LINE coef_r = 1 NEW_LINE for coef_x in range ( 1 , N + 1 ) : NEW_LINE INDENT m = X * coef_x % D NEW_LINE l = X * coef_x // D + coef_l NEW_LINE r = X * coef_x // D + coef_x * N - coef_r NEW_LINE coef_l = coef_r NEW_LINE coef_r += coef_x + 1 NEW_LINE if m not in L : NEW_LINE INDENT L [ m ] = [ ] NEW_LINE DEDENT L [ m ] . append ( ( l , 1 ) ) NEW_LINE L [ m ] . append ( ( r + 1 , - 1 ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for Q in L . values ( ) : NEW_LINE INDENT Q . sort ( ) NEW_LINE cnt = 0 NEW_LINE last = None NEW_LINE for val , sign in Q : NEW_LINE INDENT if cnt > 0 : NEW_LINE INDENT ans += val - last NEW_LINE DEDENT cnt += sign NEW_LINE last = val NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N , X , D = map ( int , input ( ) . split ( ) ) NEW_LINE print ( solve ( N , X , D ) ) NEW_LINE"}
{"id": "geeksforgeeks_422_A", "sol": 0, "python_code": "def digit_count ( x ) :\n    sum = 0\n    while ( x ) :\n        sum += 1\n        x = x // 10\n    return sum\ndef find_count ( arr , k ) :\n    ans = 0\n    for i in arr :\n        x = digit_count ( i )\n        if ( x % k == 0 ) :\n            ans += 1\n    return ans\nif __name__ == '__main__' :\n    arr = [ 12 , 345 , 2 , 68 , 7896 ]\n    K = 2\n    print ( find_count ( arr , K ) )\n", "python_code_tokenized": "def digit_count ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( x ) : NEW_LINE INDENT sum += 1 NEW_LINE x = x // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def find_count ( arr , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = digit_count ( i ) NEW_LINE if ( x % k == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 345 , 2 , 68 , 7896 ] NEW_LINE K = 2 NEW_LINE print ( find_count ( arr , K ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3549_A", "sol": 0, "python_code": "MAX = 1e9\ndef minJumps ( arr , N ) :\n    fib = [ 0 for i in range ( 30 ) ]\n    fib [ 0 ] = 0\n    fib [ 1 ] = 1\n    for i in range ( 2 , 30 ) :\n        fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ]\n    DP = [ 0 for i in range ( N + 2 ) ]\n    DP [ 0 ] = 0\n    for i in range ( 1 , N + 2 ) :\n        DP [ i ] = MAX\n    for i in range ( 1 , N + 2 ) :\n        for j in range ( 1 , 30 ) :\n            if ( ( arr [ i - 1 ] == 1 or i == N + 1 ) and i - fib [ j ] >= 0 ) :\n                DP [ i ] = min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] )\n    if ( DP [ N + 1 ] != MAX ) :\n        return DP [ N + 1 ]\n    else :\n        return - 1\narr = [ 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ]\nn = len ( arr )\nprint ( minJumps ( arr , n - 1 ) )\n", "python_code_tokenized": "MAX = 1e9 NEW_LINE def minJumps ( arr , N ) : NEW_LINE INDENT fib = [ 0 for i in range ( 30 ) ] NEW_LINE fib [ 0 ] = 0 NEW_LINE fib [ 1 ] = 1 NEW_LINE for i in range ( 2 , 30 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT DP = [ 0 for i in range ( N + 2 ) ] NEW_LINE DP [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 2 ) : NEW_LINE INDENT DP [ i ] = MAX NEW_LINE DEDENT for i in range ( 1 , N + 2 ) : NEW_LINE INDENT for j in range ( 1 , 30 ) : NEW_LINE INDENT if ( ( arr [ i - 1 ] == 1 or i == N + 1 ) and i - fib [ j ] >= 0 ) : NEW_LINE INDENT DP [ i ] = min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) NEW_LINE DEDENT DEDENT DEDENT if ( DP [ N + 1 ] != MAX ) : NEW_LINE INDENT return DP [ N + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT arr = [ 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minJumps ( arr , n - 1 ) ) NEW_LINE"}
{"id": "geeksforgeeks_1393_A", "sol": 0, "python_code": "import sys\ndef areSetBitsIncreasing ( n ) :\n    prev_count = sys.maxsize\n    while ( n > 0 ) :\n        while ( n > 0 and n % 2 == 0 ) :\n            n = int ( n / 2 )\n        curr_count = 1\n        while ( n > 0 and n % 2 == 1 ) :\n            n = n / 2\n            curr_count += 1\n        if ( curr_count >= prev_count ) :\n            return False\n        prev_count = curr_count\n    return True\nn = 10\nif ( areSetBitsIncreasing ( n ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "import sys NEW_LINE def areSetBitsIncreasing ( n ) : NEW_LINE INDENT prev_count = sys . maxsize NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( n > 0 and n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT curr_count = 1 NEW_LINE while ( n > 0 and n % 2 == 1 ) : NEW_LINE INDENT n = n / 2 NEW_LINE curr_count += 1 NEW_LINE DEDENT if ( curr_count >= prev_count ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_count = curr_count NEW_LINE DEDENT return True NEW_LINE DEDENT n = 10 NEW_LINE if ( areSetBitsIncreasing ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4251_A", "sol": 0, "python_code": "def checkPalindrome ( s ) :\n    for i in range ( len ( s ) ) :\n        if ( s [ i ] != s [ len ( s ) - i - 1 ] ) :\n            return False\n    return True\ndef CheckOdd ( s ) :\n    n = len ( s )\n    for i in range ( n ) :\n        x = \"\"\n        for j in range ( i , n ) :\n            x += s [ j ]\n            if ( len ( x ) % 2 == 0 and checkPalindrome ( x ) == True ) :\n                return False\n    return True\ns = \"geeksforgeeks\"\nif ( CheckOdd ( s ) ) :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "def checkPalindrome ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ len ( s ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def CheckOdd ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = \" \" NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT x += s [ j ] NEW_LINE if ( len ( x ) % 2 == 0 and checkPalindrome ( x ) == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE if ( CheckOdd ( s ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "codeforces_463_B", "sol": 0, "python_code": "n = int ( input ( ) )\ns = list ( map ( int , input ( ).split ( ) ) )\nprint ( max ( s ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( max ( s ) ) NEW_LINE"}
{"id": "atcoder_ABC111_B", "sol": 0, "python_code": "a = input ( )\nif a [ 0 ] == a [ 1 ] and a [ 1 ] == a [ 2 ] :\n    print ( a )\nelse :\n    while 1 :\n        a = int ( a )\n        a += 1\n        a = str ( a )\n        if a [ 0 ] == a [ 1 ] and a [ 1 ] == a [ 2 ] :\n            print ( a )\n            break\n", "python_code_tokenized": "a = input ( ) NEW_LINE if a [ 0 ] == a [ 1 ] and a [ 1 ] == a [ 2 ] : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT while 1 : NEW_LINE INDENT a = int ( a ) NEW_LINE a += 1 NEW_LINE a = str ( a ) NEW_LINE if a [ 0 ] == a [ 1 ] and a [ 1 ] == a [ 2 ] : NEW_LINE INDENT print ( a ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "atcoder_ARC080_B", "sol": 0, "python_code": "import sys\ndef solve ( H : int , W : int , N : int , a : \"List[int]\" ) :\n    S = [ ]\n    for i , n in enumerate ( a ) :\n        j = i + 1\n        S.extend ( [ j ] * n )\n    for h in range ( H ) :\n        row = S [ h * W : h * W + W ]\n        if h % 2 == 0 :\n            print ( ' '.join ( map ( str , row ) ) )\n        else :\n            print ( ' '.join ( map ( str , row [ : : - 1 ] ) ) )\n    return\ndef main ( ) :\n    def iterate_tokens ( ) :\n        for line in sys.stdin :\n            for word in line.split ( ) :\n                yield word\n    tokens = iterate_tokens ( )\n    H = int ( next ( tokens ) )\n    W = int ( next ( tokens ) )\n    N = int ( next ( tokens ) )\n    a = [ int ( next ( tokens ) ) for _ in range ( N ) ]\n    solve ( H , W , N , a )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "import sys NEW_LINE def solve ( H : int , W : int , N : int , a : \" List [ int ] \" ) : NEW_LINE INDENT S = [ ] NEW_LINE for i , n in enumerate ( a ) : NEW_LINE INDENT j = i + 1 NEW_LINE S . extend ( [ j ] * n ) NEW_LINE DEDENT for h in range ( H ) : NEW_LINE INDENT row = S [ h * W : h * W + W ] NEW_LINE if h % 2 == 0 : NEW_LINE INDENT print ( ' \u2581 ' . join ( map ( str , row ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' \u2581 ' . join ( map ( str , row [ : : - 1 ] ) ) ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE H = int ( next ( tokens ) ) NEW_LINE W = int ( next ( tokens ) ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE a = [ int ( next ( tokens ) ) for _ in range ( N ) ] NEW_LINE solve ( H , W , N , a ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_522_B", "sol": 0, "python_code": "n = int ( input ( ) )\ns , maxh , smaxh = 0 , 0 , 0\nl = [ ]\nfor _ in range ( n ) :\n    w , h = map ( int , input ( ).split ( ) )\n    l.append ( [ w , h ] )\n    s += w\n    if h >= maxh :\n        smaxh = maxh\n        maxh = h\n    elif h > smaxh :\n        smaxh = h\nfor i in range ( n ) :\n    totalWidth = s - l [ i ] [ 0 ]\n    maxHeight = maxh if l [ i ] [ 1 ] != maxh else smaxh\n    print ( totalWidth * maxHeight , end = \" \" )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s , maxh , smaxh = 0 , 0 , 0 NEW_LINE l = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( [ w , h ] ) NEW_LINE s += w NEW_LINE if h >= maxh : NEW_LINE INDENT smaxh = maxh NEW_LINE maxh = h NEW_LINE DEDENT elif h > smaxh : NEW_LINE INDENT smaxh = h NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT totalWidth = s - l [ i ] [ 0 ] NEW_LINE maxHeight = maxh if l [ i ] [ 1 ] != maxh else smaxh NEW_LINE print ( totalWidth * maxHeight , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3571_A", "sol": 0, "python_code": "from collections import deque\ndef minimumColors ( N , E , U , V ) :\n    adj = [ [ ] for i in range ( N ) ]\n    count = [ 0 ] * N\n    colors = [ 1 ] * ( N )\n    for i in range ( N ) :\n        adj [ V [ i ] - 1 ].append ( U [ i ] - 1 )\n        count [ U [ i ] - 1 ] += 1\n    Q = deque ( )\n    for i in range ( N ) :\n        if ( count [ i ] == 0 ) :\n            Q.append ( i )\n    while len ( Q ) > 0 :\n        u = Q.popleft ( )\n        for x in adj [ u ] :\n            count [ x ] -= 1\n            if ( count [ x ] == 0 ) :\n                Q.append ( x )\n            if ( colors [ x ] <= colors [ u ] ) :\n                colors [ x ] = 1 + colors [ u ]\n    minColor = - 1\n    for i in range ( N ) :\n        minColor = max ( minColor , colors [ i ] )\n    print ( minColor )\nN = 5\nE = 6\nU = [ 1 , 2 , 3 , 1 , 2 , 3 ]\nV = [ 3 , 3 , 4 , 4 , 5 , 5 ]\nminimumColors ( N , E , U , V )\n", "python_code_tokenized": "from collections import deque NEW_LINE def minimumColors ( N , E , U , V ) : NEW_LINE INDENT adj = [ [ ] for i in range ( N ) ] NEW_LINE count = [ 0 ] * N NEW_LINE colors = [ 1 ] * ( N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT adj [ V [ i ] - 1 ] . append ( U [ i ] - 1 ) NEW_LINE count [ U [ i ] - 1 ] += 1 NEW_LINE DEDENT Q = deque ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( count [ i ] == 0 ) : NEW_LINE INDENT Q . append ( i ) NEW_LINE DEDENT DEDENT while len ( Q ) > 0 : NEW_LINE INDENT u = Q . popleft ( ) NEW_LINE for x in adj [ u ] : NEW_LINE INDENT count [ x ] -= 1 NEW_LINE if ( count [ x ] == 0 ) : NEW_LINE INDENT Q . append ( x ) NEW_LINE DEDENT if ( colors [ x ] <= colors [ u ] ) : NEW_LINE INDENT colors [ x ] = 1 + colors [ u ] NEW_LINE DEDENT DEDENT DEDENT minColor = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT minColor = max ( minColor , colors [ i ] ) NEW_LINE DEDENT print ( minColor ) NEW_LINE DEDENT N = 5 NEW_LINE E = 6 NEW_LINE U = [ 1 , 2 , 3 , 1 , 2 , 3 ] NEW_LINE V = [ 3 , 3 , 4 , 4 , 5 , 5 ] NEW_LINE minimumColors ( N , E , U , V ) NEW_LINE"}
{"id": "geeksforgeeks_3275_A", "sol": 0, "python_code": "def Permutations ( n , k ) :\n    ans = 1\n    if k >= 2 :\n        ans += ( n ) * ( n - 1 ) // 2\n    if k >= 3 :\n        ans += ( ( n ) * ( n - 1 ) * ( n - 2 ) * 2 // 6 )\n    if k >= 4 :\n        ans += ( ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 // 24 )\n    return ans\nif __name__ == \"__main__\" :\n    n , k = 5 , 2\n    print ( Permutations ( n , k ) )\n", "python_code_tokenized": "def Permutations ( n , k ) : NEW_LINE INDENT ans = 1 NEW_LINE if k >= 2 : NEW_LINE INDENT ans += ( n ) * ( n - 1 ) // 2 NEW_LINE DEDENT if k >= 3 : NEW_LINE INDENT ans += ( ( n ) * ( n - 1 ) * ( n - 2 ) * 2 // 6 ) NEW_LINE DEDENT if k >= 4 : NEW_LINE INDENT ans += ( ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 // 24 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 5 , 2 NEW_LINE print ( Permutations ( n , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3413_A", "sol": 0, "python_code": "def longestSubstring ( s ) :\n    cnt = 1 ;\n    maxi = 1 ;\n    n = len ( s ) ;\n    for i in range ( 1 , n ) :\n        if ( s [ i ] != s [ i - 1 ] ) :\n            cnt += 1 ;\n        else :\n            maxi = max ( cnt , maxi ) ;\n            cnt = 1 ;\n    maxi = max ( cnt , maxi ) ;\n    return maxi ;\nif __name__ == \"__main__\" :\n    s = \"ccccdeededff\" ;\n    print ( longestSubstring ( s ) ) ;\n", "python_code_tokenized": "def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 ; NEW_LINE maxi = 1 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) ; NEW_LINE return maxi ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ccccdeededff \" ; NEW_LINE print ( longestSubstring ( s ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1106_A", "sol": 0, "python_code": "def checkArray ( arr , n ) :\n    zero = 0 ; one = 0 ;\n    minusone = 0 ; other = 0\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] == 0 ) :\n            zero += 1\n        elif ( arr [ i ] == 1 ) :\n            one += 1\n        elif ( arr [ i ] == - 1 ) :\n            minusone += 1\n        else :\n            other += 1\n    if ( other > 1 ) :\n        return false\n    elif ( other != 0 and minusone != 0 ) :\n        return false\n    elif ( minusone >= 1 and one == 0 ) :\n        return false\n    return True\narr = [ 0 , 1 , 1 , 10 ]\nn = len ( arr )\nif ( checkArray ( arr , n ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def checkArray ( arr , n ) : NEW_LINE INDENT zero = 0 ; one = 0 ; NEW_LINE minusone = 0 ; other = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT elif ( arr [ i ] == 1 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT elif ( arr [ i ] == - 1 ) : NEW_LINE INDENT minusone += 1 NEW_LINE DEDENT else : NEW_LINE INDENT other += 1 NEW_LINE DEDENT DEDENT if ( other > 1 ) : NEW_LINE INDENT return false NEW_LINE DEDENT elif ( other != 0 and minusone != 0 ) : NEW_LINE INDENT return false NEW_LINE DEDENT elif ( minusone >= 1 and one == 0 ) : NEW_LINE INDENT return false NEW_LINE DEDENT return True NEW_LINE DEDENT arr = [ 0 , 1 , 1 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkArray ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4571_A", "sol": 0, "python_code": "from math import sqrt , floor\ndef isPerfect ( N ) :\n    if ( sqrt ( N ) - floor ( sqrt ( N ) ) != 0 ) :\n        return False\n    return True\ndef getClosestPerfectSquare ( N ) :\n    if ( isPerfect ( N ) ) :\n        print ( N , \"0\" )\n        return\n    aboveN = - 1\n    belowN = - 1\n    n1 = 0\n    n1 = N + 1\n    while ( True ) :\n        if ( isPerfect ( n1 ) ) :\n            aboveN = n1\n            break\n        else :\n            n1 += 1\n    n1 = N - 1\n    while ( True ) :\n        if ( isPerfect ( n1 ) ) :\n            belowN = n1\n            break\n        else :\n            n1 -= 1\n    diff1 = aboveN - N\n    diff2 = N - belowN\n    if ( diff1 > diff2 ) :\n        print ( belowN , diff2 )\n    else :\n        print ( aboveN , diff1 )\nN = 1500\ngetClosestPerfectSquare ( N )\n", "python_code_tokenized": "from math import sqrt , floor NEW_LINE def isPerfect ( N ) : NEW_LINE INDENT if ( sqrt ( N ) - floor ( sqrt ( N ) ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def getClosestPerfectSquare ( N ) : NEW_LINE INDENT if ( isPerfect ( N ) ) : NEW_LINE INDENT print ( N , \"0\" ) NEW_LINE return NEW_LINE DEDENT aboveN = - 1 NEW_LINE belowN = - 1 NEW_LINE n1 = 0 NEW_LINE n1 = N + 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPerfect ( n1 ) ) : NEW_LINE INDENT aboveN = n1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT n1 += 1 NEW_LINE DEDENT DEDENT n1 = N - 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPerfect ( n1 ) ) : NEW_LINE INDENT belowN = n1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT n1 -= 1 NEW_LINE DEDENT DEDENT diff1 = aboveN - N NEW_LINE diff2 = N - belowN NEW_LINE if ( diff1 > diff2 ) : NEW_LINE INDENT print ( belowN , diff2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( aboveN , diff1 ) NEW_LINE DEDENT DEDENT N = 1500 NEW_LINE getClosestPerfectSquare ( N ) NEW_LINE"}
{"id": "projecteuler_p040_A", "sol": 0, "python_code": "def compute ( ) :\n    s = \"\".join ( str ( i ) for i in range ( 1 , 1000000 ) )\n    ans = 1\n    for i in range ( 7 ) :\n        ans *= int ( s [ 10 ** i - 1 ] )\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT s = \" \" . join ( str ( i ) for i in range ( 1 , 1000000 ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT ans *= int ( s [ 10 ** i - 1 ] ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3436_A", "sol": 0, "python_code": "def findSet ( arr , k , m ) :\n    arr_size = len ( arr ) ;\n    remainder_set = [ 0 ] * k ;\n    for i in range ( k ) :\n        remainder_set [ i ] = [ ] ;\n    for i in range ( arr_size ) :\n        rem = arr [ i ] % k ;\n        remainder_set [ rem ].append ( arr [ i ] ) ;\n    for i in range ( k ) :\n        if ( len ( remainder_set [ i ] ) >= m ) :\n            print ( \"Yes\" ) ;\n            for j in range ( m ) :\n                print ( remainder_set [ i ] [ j ] , end = \"\" ) ;\n                print ( \"\" , end = \"\" ) ;\n            return ;\n    print ( \"No\" ) ;\narr = [ 5 , 8 , 9 , 12 , 13 , 7 , 11 , 15 ] ;\nk = 4 ;\nm = 3 ;\nfindSet ( arr , k , m ) ;\n", "python_code_tokenized": "def findSet ( arr , k , m ) : NEW_LINE INDENT arr_size = len ( arr ) ; NEW_LINE remainder_set = [ 0 ] * k ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT remainder_set [ i ] = [ ] ; NEW_LINE DEDENT for i in range ( arr_size ) : NEW_LINE INDENT rem = arr [ i ] % k ; NEW_LINE remainder_set [ rem ] . append ( arr [ i ] ) ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT if ( len ( remainder_set [ i ] ) >= m ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE for j in range ( m ) : NEW_LINE INDENT print ( remainder_set [ i ] [ j ] , end = \" \" ) ; NEW_LINE print ( \" \u2581 \" , end = \" \" ) ; NEW_LINE DEDENT return ; NEW_LINE DEDENT DEDENT print ( \" No \" ) ; NEW_LINE DEDENT arr = [ 5 , 8 , 9 , 12 , 13 , 7 , 11 , 15 ] ; NEW_LINE k = 4 ; NEW_LINE m = 3 ; NEW_LINE findSet ( arr , k , m ) ; NEW_LINE"}
{"id": "codeforces_887_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = [ list ( map ( int , input ( ).split ( ) ) ) for x in range ( n ) ]\ndef valid ( di ) :\n    b = [ ]\n    for i in di :\n        t = [ ]\n        for j in range ( n ) :\n            if i in a [ j ] :\n                t.append ( j )\n        b.append ( sorted ( t ) )\n    for i in b [ 0 ] :\n        if len ( b ) > 1 :\n            for j in b [ 1 ] :\n                if len ( b ) > 2 :\n                    for k in b [ 2 ] :\n                        if i != j :\n                            return True\n                else :\n                    if i != j :\n                        return True\n        else :\n            return True\n    return False\nx = 1\nwhile True :\n    temp = x\n    done = [ ]\n    flag = 0\n    while temp > 0 :\n        done.append ( temp % 10 )\n        temp = temp // 10\n    if valid ( done [ : : - 1 ] ) :\n        x += 1\n    else :\n        break\nprint ( x - 1 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for x in range ( n ) ] NEW_LINE def valid ( di ) : NEW_LINE INDENT b = [ ] NEW_LINE for i in di : NEW_LINE INDENT t = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if i in a [ j ] : NEW_LINE INDENT t . append ( j ) NEW_LINE DEDENT DEDENT b . append ( sorted ( t ) ) NEW_LINE DEDENT for i in b [ 0 ] : NEW_LINE INDENT if len ( b ) > 1 : NEW_LINE INDENT for j in b [ 1 ] : NEW_LINE INDENT if len ( b ) > 2 : NEW_LINE INDENT for k in b [ 2 ] : NEW_LINE INDENT if i != j : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if i != j : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT x = 1 NEW_LINE while True : NEW_LINE INDENT temp = x NEW_LINE done = [ ] NEW_LINE flag = 0 NEW_LINE while temp > 0 : NEW_LINE INDENT done . append ( temp % 10 ) NEW_LINE temp = temp // 10 NEW_LINE DEDENT if valid ( done [ : : - 1 ] ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( x - 1 ) NEW_LINE"}
{"id": "geeksforgeeks_380_A", "sol": 0, "python_code": "def maxSubArraySum ( a , size ) :\n    max_so_far = - 10 ** 9\n    max_ending_here = 0\n    for i in range ( size ) :\n        max_ending_here = max_ending_here + a [ i ]\n        if ( max_so_far < max_ending_here ) :\n            max_so_far = max_ending_here\n        if ( max_ending_here < 0 ) :\n            max_ending_here = 0\n    return max_so_far\ndef minPossibleSum ( a , n , x ) :\n    mxSum = maxSubArraySum ( a , n )\n    sum = 0\n    for i in range ( n ) :\n        sum += a [ i ]\n    sum = sum - mxSum + mxSum / x\n    print ( round ( sum , 2 ) )\nif __name__ == '__main__' :\n    N = 3\n    X = 2\n    A = [ 1 , - 2 , 3 ]\n    minPossibleSum ( A , N , X )\n", "python_code_tokenized": "def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - 10 ** 9 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT def minPossibleSum ( a , n , x ) : NEW_LINE INDENT mxSum = maxSubArraySum ( a , n ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum = sum - mxSum + mxSum / x NEW_LINE print ( round ( sum , 2 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE X = 2 NEW_LINE A = [ 1 , - 2 , 3 ] NEW_LINE minPossibleSum ( A , N , X ) NEW_LINE DEDENT"}
{"id": "codeforces_358_B", "sol": 0, "python_code": "from typing import List\ndef werify_message ( n : int , words : List [ str ] , message : str ) -> str :\n    true_message = ''.join ( [ '<3' , '<3'.join ( words ) , '<3' ] )\n    i = 0\n    for litera in message :\n        if len ( true_message ) != i :\n            if litera == true_message [ i ] :\n                i += 1\n        else :\n            return 'yes'\n    if i == len ( true_message ) :\n        return 'yes'\n    else :\n        return 'no'\nn = int ( input ( ) )\nwords = list ( )\nfor i in range ( n ) :\n    word = input ( )\n    words.append ( word )\nmessage = input ( )\nprint ( werify_message ( n , words , message ) )\n", "python_code_tokenized": "from typing import List NEW_LINE def werify_message ( n : int , words : List [ str ] , message : str ) -> str : NEW_LINE INDENT true_message = ' ' . join ( [ ' < 3' , ' < 3' . join ( words ) , ' < 3' ] ) NEW_LINE i = 0 NEW_LINE for litera in message : NEW_LINE INDENT if len ( true_message ) != i : NEW_LINE INDENT if litera == true_message [ i ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return ' yes ' NEW_LINE DEDENT DEDENT if i == len ( true_message ) : NEW_LINE INDENT return ' yes ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' no ' NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE words = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT word = input ( ) NEW_LINE words . append ( word ) NEW_LINE DEDENT message = input ( ) NEW_LINE print ( werify_message ( n , words , message ) ) NEW_LINE"}
{"id": "aizu_p01106_A", "sol": 0, "python_code": "ans , low = [ 0 ] * 62 , [ 0 ] * 62\nwhile True :\n    n , i , j = map ( int , input ( ).split ( ) )\n    if n == 0 : break\n    i -= 1 ; j -= 1\n    for k in range ( 1 , n + 1 ) :\n        low [ n - k ] = ( i >> ( n - k ) ) & 1\n        if low [ n - k ] == 0 : i = ~ i\n    for k in range ( 1 , n + 1 ) :\n        ans [ k ] = 'L' if ( ( j >> ( n - k ) ) & 1 ) == low [ k - 1 ] else 'R'\n        if low [ k - 1 ] == 0 : j = ~ j\n    print ( ''.join ( ans [ 1 : n + 1 ] ) )\n", "python_code_tokenized": "ans , low = [ 0 ] * 62 , [ 0 ] * 62 NEW_LINE while True : NEW_LINE INDENT n , i , j = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE i -= 1 ; j -= 1 NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT low [ n - k ] = ( i >> ( n - k ) ) & 1 NEW_LINE if low [ n - k ] == 0 : i = ~ i NEW_LINE DEDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT ans [ k ] = ' L ' if ( ( j >> ( n - k ) ) & 1 ) == low [ k - 1 ] else ' R ' NEW_LINE if low [ k - 1 ] == 0 : j = ~ j NEW_LINE DEDENT print ( ' ' . join ( ans [ 1 : n + 1 ] ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3547_A", "sol": 0, "python_code": "import sys\ndef steps ( source , step , dest ) :\n    if ( abs ( source ) > ( dest ) ) :\n        return sys.maxsize\n    if ( source == dest ) :\n        return step\n    pos = steps ( source + step + 1 , step + 1 , dest )\n    neg = steps ( source - step - 1 , step + 1 , dest )\n    return min ( pos , neg )\ndest = 11 ;\nprint ( \"No.of steps required\" , \" to reach \" , dest , \" is \" , steps ( 0 , 0 , dest ) ) ;\n", "python_code_tokenized": "import sys NEW_LINE def steps ( source , step , dest ) : NEW_LINE INDENT if ( abs ( source ) > ( dest ) ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( source == dest ) : NEW_LINE INDENT return step NEW_LINE DEDENT pos = steps ( source + step + 1 , step + 1 , dest ) NEW_LINE neg = steps ( source - step - 1 , step + 1 , dest ) NEW_LINE return min ( pos , neg ) NEW_LINE DEDENT dest = 11 ; NEW_LINE print ( \" No . \u2581 of \u2581 steps \u2581 required \" , \" \u2581 to \u2581 reach \u2581 \" , dest , \" \u2581 is \u2581 \" , steps ( 0 , 0 , dest ) ) ; NEW_LINE"}
{"id": "codeforces_60_B", "sol": 0, "python_code": "z , n , m = [ int ( x ) for x in input ( ).split ( ) ]\nadj = [ ]\nvis = [ ]\nfor i in range ( 15 ) :\n    adj.append ( [ ] )\n    vis.append ( [ ] )\n    for j in range ( 15 ) :\n        adj [ i ].append ( [ \"\" ] * 15 )\n        vis [ i ].append ( [ False ] * 15 )\nfor i in range ( 1 , z + 1 ) :\n    input ( )\n    for j in range ( 1 , n + 1 ) :\n        c = list ( input ( ) )\n        for l in range ( 1 , len ( c ) + 1 ) :\n            adj [ i ] [ j ] [ l ] = c [ l - 1 ]\ninput ( )\nx , y = [ int ( e ) for e in input ( ).split ( ) ]\ndef dfs ( l , x , y , z ) :\n    if ( x > 0 and y > 0 and l > 0 and l <= z and x <= n and y <= m and not vis [ l ] [ x ] [ y ] ) :\n        if ( adj [ l ] [ x ] [ y ] == '#' ) :\n            return\n        vis [ l ] [ x ] [ y ] = True\n        dfs ( l + 1 , x , y , z )\n        dfs ( l - 1 , x , y , z )\n        dfs ( l , x + 1 , y , z )\n        dfs ( l , x - 1 , y , z )\n        dfs ( l , x , y + 1 , z )\n        dfs ( l , x , y - 1 , z )\ndfs ( 1 , x , y , z )\nout = 0\nfor i in range ( 1 , z + 1 ) :\n    for j in range ( 1 , n + 1 ) :\n        for l in range ( 1 , m + 1 ) :\n            if ( vis [ i ] [ j ] [ l ] ) :\n                out += 1\nprint ( out )\n", "python_code_tokenized": "z , n , m = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE adj = [ ] NEW_LINE vis = [ ] NEW_LINE for i in range ( 15 ) : NEW_LINE INDENT adj . append ( [ ] ) NEW_LINE vis . append ( [ ] ) NEW_LINE for j in range ( 15 ) : NEW_LINE INDENT adj [ i ] . append ( [ \" \" ] * 15 ) NEW_LINE vis [ i ] . append ( [ False ] * 15 ) NEW_LINE DEDENT DEDENT for i in range ( 1 , z + 1 ) : NEW_LINE INDENT input ( ) NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT c = list ( input ( ) ) NEW_LINE for l in range ( 1 , len ( c ) + 1 ) : NEW_LINE INDENT adj [ i ] [ j ] [ l ] = c [ l - 1 ] NEW_LINE DEDENT DEDENT DEDENT input ( ) NEW_LINE x , y = [ int ( e ) for e in input ( ) . split ( ) ] NEW_LINE def dfs ( l , x , y , z ) : NEW_LINE INDENT if ( x > 0 and y > 0 and l > 0 and l <= z and x <= n and y <= m and not vis [ l ] [ x ] [ y ] ) : NEW_LINE INDENT if ( adj [ l ] [ x ] [ y ] == ' # ' ) : NEW_LINE INDENT return NEW_LINE DEDENT vis [ l ] [ x ] [ y ] = True NEW_LINE dfs ( l + 1 , x , y , z ) NEW_LINE dfs ( l - 1 , x , y , z ) NEW_LINE dfs ( l , x + 1 , y , z ) NEW_LINE dfs ( l , x - 1 , y , z ) NEW_LINE dfs ( l , x , y + 1 , z ) NEW_LINE dfs ( l , x , y - 1 , z ) NEW_LINE DEDENT DEDENT dfs ( 1 , x , y , z ) NEW_LINE out = 0 NEW_LINE for i in range ( 1 , z + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT for l in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( vis [ i ] [ j ] [ l ] ) : NEW_LINE INDENT out += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( out ) NEW_LINE"}
{"id": "geeksforgeeks_3628_A", "sol": 0, "python_code": "from math import gcd as __gcd\ndef isPossible ( arr , n , p ) :\n    gcd = 0 ;\n    for i in range ( n ) :\n        gcd = __gcd ( gcd , arr [ i ] ) ;\n    if ( p % gcd == 0 ) :\n        return True ;\n    return False ;\nif __name__ == \"__main__\" :\n    arr = [ 6 , 9 ] ;\n    n = len ( arr ) ;\n    p = 3 ;\n    if ( isPossible ( arr , n , p ) ) :\n        print ( \"Yes\" ) ;\n    else :\n        print ( \"No\" ) ;\n", "python_code_tokenized": "from math import gcd as __gcd NEW_LINE def isPossible ( arr , n , p ) : NEW_LINE INDENT gcd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = __gcd ( gcd , arr [ i ] ) ; NEW_LINE DEDENT if ( p % gcd == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 6 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE p = 3 ; NEW_LINE if ( isPossible ( arr , n , p ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00106_A", "sol": 0, "python_code": "import sys\nimport os\nfor s in sys.stdin :\n    n = int ( s )\n    if n == 0 :\n        break\n    costs = [ ]\n    for a in range ( 0 , 26 ) :\n        for b in range ( 0 , 17 ) :\n            for c in range ( 0 , 11 ) :\n                if a * 200 + b * 300 + c * 500 == n :\n                    cost = 0\n                    a_bulk_num = a // 5\n                    a_price_down_num = a_bulk_num * 5\n                    a_normal_price_num = a - a_price_down_num\n                    cost += 380 * 0.8 * a_price_down_num + 380 * a_normal_price_num\n                    b_bulk_num = b // 4\n                    b_price_down_num = b_bulk_num * 4\n                    b_normal_price_num = b - b_price_down_num\n                    cost += 550 * 0.85 * b_price_down_num + 550 * b_normal_price_num\n                    c_bulk_num = c // 3\n                    c_price_down_num = c_bulk_num * 3\n                    c_normal_price_num = c - c_price_down_num\n                    cost += 850 * 0.88 * c_price_down_num + 850 * c_normal_price_num\n                    costs.append ( cost )\n    print ( int ( min ( costs ) ) )\n", "python_code_tokenized": "import sys NEW_LINE import os NEW_LINE for s in sys . stdin : NEW_LINE INDENT n = int ( s ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT costs = [ ] NEW_LINE for a in range ( 0 , 26 ) : NEW_LINE INDENT for b in range ( 0 , 17 ) : NEW_LINE INDENT for c in range ( 0 , 11 ) : NEW_LINE INDENT if a * 200 + b * 300 + c * 500 == n : NEW_LINE INDENT cost = 0 NEW_LINE a_bulk_num = a // 5 NEW_LINE a_price_down_num = a_bulk_num * 5 NEW_LINE a_normal_price_num = a - a_price_down_num NEW_LINE cost += 380 * 0.8 * a_price_down_num + 380 * a_normal_price_num NEW_LINE b_bulk_num = b // 4 NEW_LINE b_price_down_num = b_bulk_num * 4 NEW_LINE b_normal_price_num = b - b_price_down_num NEW_LINE cost += 550 * 0.85 * b_price_down_num + 550 * b_normal_price_num NEW_LINE c_bulk_num = c // 3 NEW_LINE c_price_down_num = c_bulk_num * 3 NEW_LINE c_normal_price_num = c - c_price_down_num NEW_LINE cost += 850 * 0.88 * c_price_down_num + 850 * c_normal_price_num NEW_LINE costs . append ( cost ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( int ( min ( costs ) ) ) NEW_LINE DEDENT"}
{"id": "codeforces_959_B", "sol": 0, "python_code": "n , k , m = map ( int , input ( ).split ( ) )\nd = { }\narr , cost = input ( ).split ( ) , tuple ( map ( int , input ( ).split ( ) ) )\nfor _ in ' ' * k :\n    tmp = tuple ( map ( int , input ( ).split ( ) ) )\n    if len ( tmp ) == 2 : a , b = tmp ; d [ arr [ b - 1 ] ] = cost [ b - 1 ]\n    else :\n        tmp = tmp [ 1 : ]\n        mn = 1000000001\n        for i in tmp : mn = min ( mn , cost [ i - 1 ] )\n        for i in tmp : d.setdefault ( arr [ i - 1 ] , 1000000001 ) ; d [ arr [ i - 1 ] ] = min ( d [ arr [ i - 1 ] ] , mn )\nres = 0\nfor i in input ( ).split ( ) : res += d [ i ]\nprint ( res )\n", "python_code_tokenized": "n , k , m = map ( int , input ( ) . split ( ) ) NEW_LINE d = { } NEW_LINE arr , cost = input ( ) . split ( ) , tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for _ in ' \u2581 ' * k : NEW_LINE INDENT tmp = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if len ( tmp ) == 2 : a , b = tmp ; d [ arr [ b - 1 ] ] = cost [ b - 1 ] NEW_LINE else : NEW_LINE INDENT tmp = tmp [ 1 : ] NEW_LINE mn = 1000000001 NEW_LINE for i in tmp : mn = min ( mn , cost [ i - 1 ] ) NEW_LINE for i in tmp : d . setdefault ( arr [ i - 1 ] , 1000000001 ) ; d [ arr [ i - 1 ] ] = min ( d [ arr [ i - 1 ] ] , mn ) NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for i in input ( ) . split ( ) : res += d [ i ] NEW_LINE print ( res ) NEW_LINE"}
{"id": "geeksforgeeks_213_A", "sol": 0, "python_code": "def makeSeq ( s , a ) :\n    seq = [ ] ;\n    for i in range ( len ( s ) ) :\n        if ( s [ i ] == 'A' ) :\n            seq.append ( a [ i ] ) ;\n    for i in range ( len ( s ) ) :\n        if ( s [ i ] == 'B' ) :\n            seq.append ( a [ i ] ) ;\n    return seq ;\ndef checkSeq ( v ) :\n    check = True ;\n    for i in range ( 1 , len ( v ) ) :\n        if ( v [ i ] < v [ i - 1 ] ) :\n            check = False ;\n    return check ;\ndef digitPartition ( X ) :\n    num = str ( X ) ;\n    l = len ( num ) ;\n    a = [ 0 ] * l ;\n    for i in range ( l ) :\n        a [ i ] = ( ord ( num [ i ] ) - ord ( '0' ) ) ;\n    for D in range ( 10 ) :\n        res = \"\" ;\n        for i in range ( l ) :\n            if ( a [ i ] < D ) :\n                res += 'A' ;\n            elif ( a [ i ] > D ) :\n                res += 'B' ;\n            else :\n                res += 'C' ;\n        flag = False ;\n        for i in range ( l ) :\n            if ( res [ i ] == 'B' ) :\n                flag = True ;\n            res = list ( res ) ;\n            if ( res [ i ] == 'C' ) :\n                res [ i ] = 'A' if flag else 'B' ;\n        seq = makeSeq ( res , a ) ;\n        if ( checkSeq ( seq ) ) :\n            return \"\".join ( res ) ;\n    return \"-1\" ;\nif __name__ == \"__main__\" :\n    X = 777147777 ;\n    print ( digitPartition ( X ) ) ;\n", "python_code_tokenized": "def makeSeq ( s , a ) : NEW_LINE INDENT seq = [ ] ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' A ' ) : NEW_LINE INDENT seq . append ( a [ i ] ) ; NEW_LINE DEDENT DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' B ' ) : NEW_LINE INDENT seq . append ( a [ i ] ) ; NEW_LINE DEDENT DEDENT return seq ; NEW_LINE DEDENT def checkSeq ( v ) : NEW_LINE INDENT check = True ; NEW_LINE for i in range ( 1 , len ( v ) ) : NEW_LINE INDENT if ( v [ i ] < v [ i - 1 ] ) : NEW_LINE INDENT check = False ; NEW_LINE DEDENT DEDENT return check ; NEW_LINE DEDENT def digitPartition ( X ) : NEW_LINE INDENT num = str ( X ) ; NEW_LINE l = len ( num ) ; NEW_LINE a = [ 0 ] * l ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT a [ i ] = ( ord ( num [ i ] ) - ord ( '0' ) ) ; NEW_LINE DEDENT for D in range ( 10 ) : NEW_LINE INDENT res = \" \" ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] < D ) : NEW_LINE INDENT res += ' A ' ; NEW_LINE DEDENT elif ( a [ i ] > D ) : NEW_LINE INDENT res += ' B ' ; NEW_LINE DEDENT else : NEW_LINE INDENT res += ' C ' ; NEW_LINE DEDENT DEDENT flag = False ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( res [ i ] == ' B ' ) : NEW_LINE INDENT flag = True ; NEW_LINE DEDENT res = list ( res ) ; NEW_LINE if ( res [ i ] == ' C ' ) : NEW_LINE INDENT res [ i ] = ' A ' if flag else ' B ' ; NEW_LINE DEDENT DEDENT seq = makeSeq ( res , a ) ; NEW_LINE if ( checkSeq ( seq ) ) : NEW_LINE INDENT return \" \" . join ( res ) ; NEW_LINE DEDENT DEDENT return \" - 1\" ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 777147777 ; NEW_LINE print ( digitPartition ( X ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_22_B", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nc = [ input ( ) for i in range ( n ) ]\ns = 0\nfor i in range ( n ) :\n    for j in range ( m ) :\n        for k in range ( i , n ) :\n            for l in range ( j , m ) :\n                if all ( c [ x ] [ j : l + 1 ] == \"0\" * ( l - j + 1 ) for x in range ( i , k + 1 ) ) :\n                    s = max ( s , 2 * ( k - i + l - j + 2 ) )\nprint ( s )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE c = [ input ( ) for i in range ( n ) ] NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT for k in range ( i , n ) : NEW_LINE INDENT for l in range ( j , m ) : NEW_LINE INDENT if all ( c [ x ] [ j : l + 1 ] == \"0\" * ( l - j + 1 ) for x in range ( i , k + 1 ) ) : NEW_LINE INDENT s = max ( s , 2 * ( k - i + l - j + 2 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( s ) NEW_LINE"}
{"id": "geeksforgeeks_1569_A", "sol": 0, "python_code": "MAX = 100\ndef countSubsequence ( s , n ) :\n    cntG = 0\n    cntF = 0\n    result = 0\n    C = 0\n    for i in range ( n ) :\n        if ( s [ i ] == 'G' ) :\n            cntG += 1\n            result += C\n            continue\n        if ( s [ i ] == 'F' ) :\n            cntF += 1\n            C += cntG\n            continue\n        else :\n            continue\n    print ( result )\nif __name__ == '__main__' :\n    s = \"GFGFG\"\n    n = len ( s )\n    countSubsequence ( s , n )\n", "python_code_tokenized": "MAX = 100 NEW_LINE def countSubsequence ( s , n ) : NEW_LINE INDENT cntG = 0 NEW_LINE cntF = 0 NEW_LINE result = 0 NEW_LINE C = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' G ' ) : NEW_LINE INDENT cntG += 1 NEW_LINE result += C NEW_LINE continue NEW_LINE DEDENT if ( s [ i ] == ' F ' ) : NEW_LINE INDENT cntF += 1 NEW_LINE C += cntG NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" GFGFG \" NEW_LINE n = len ( s ) NEW_LINE countSubsequence ( s , n ) NEW_LINE DEDENT"}
{"id": "projecteuler_p087_A", "sol": 0, "python_code": "import eulerlib\ndef compute ( ) :\n    LIMIT = 50000000\n    primes = eulerlib.list_primes ( eulerlib.sqrt ( LIMIT ) )\n    sums = { 0 }\n    for i in range ( 2 , 5 ) :\n        newsums = set ( )\n        for p in primes :\n            q = p ** i\n            if q > LIMIT :\n                break\n            for x in sums :\n                if x + q <= LIMIT :\n                    newsums.add ( x + q )\n        sums = newsums\n    return str ( len ( sums ) )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( LIMIT ) ) NEW_LINE sums = { 0 } NEW_LINE for i in range ( 2 , 5 ) : NEW_LINE INDENT newsums = set ( ) NEW_LINE for p in primes : NEW_LINE INDENT q = p ** i NEW_LINE if q > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT for x in sums : NEW_LINE INDENT if x + q <= LIMIT : NEW_LINE INDENT newsums . add ( x + q ) NEW_LINE DEDENT DEDENT DEDENT sums = newsums NEW_LINE DEDENT return str ( len ( sums ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00257_A", "sol": 0, "python_code": "def reachable ( graph , init ) :\n    if init not in graph or graph [ init ] is None :\n        return set ( )\n    tmp , graph [ init ] = graph [ init ] , None\n    return tmp.union ( * [ reachable ( graph , i ) for i in tmp ] )\ndef sugoroku ( m , d ) :\n    d = [ 0 ] + d + [ 0 ]\n    start , goal = 0 , len ( d ) - 1\n    graph_to = { goal : { goal } }\n    graph_from = { start : { start } }\n    for init in range ( len ( d ) - 1 ) :\n        for xi in range ( 1 , 1 + m ) :\n            pos = min ( init + xi , goal )\n            to = max ( start , min ( pos + d [ pos ] , goal ) )\n            try :\n                graph_to [ to ].add ( init )\n            except KeyError :\n                graph_to [ to ] = { init }\n            try :\n                graph_from [ init ].add ( to )\n            except KeyError :\n                graph_from [ init ] = { to }\n    unreachable_node = reachable ( graph_from , start ).difference ( reachable ( graph_to , goal ) )\n    return 0 == len ( unreachable_node )\nimport sys\nf = sys.stdin\nwhile True :\n    m = int ( f.readline ( ) )\n    if m == 0 :\n        break\n    d = [ int ( f.readline ( ) ) for _ in range ( int ( f.readline ( ) ) ) ]\n    print ( 'OK' if sugoroku ( m , d ) else 'NG' )\n", "python_code_tokenized": "def reachable ( graph , init ) : NEW_LINE INDENT if init not in graph or graph [ init ] is None : NEW_LINE INDENT return set ( ) NEW_LINE DEDENT tmp , graph [ init ] = graph [ init ] , None NEW_LINE return tmp . union ( * [ reachable ( graph , i ) for i in tmp ] ) NEW_LINE DEDENT def sugoroku ( m , d ) : NEW_LINE INDENT d = [ 0 ] + d + [ 0 ] NEW_LINE start , goal = 0 , len ( d ) - 1 NEW_LINE graph_to = { goal : { goal } } NEW_LINE graph_from = { start : { start } } NEW_LINE for init in range ( len ( d ) - 1 ) : NEW_LINE INDENT for xi in range ( 1 , 1 + m ) : NEW_LINE INDENT pos = min ( init + xi , goal ) NEW_LINE to = max ( start , min ( pos + d [ pos ] , goal ) ) NEW_LINE try : NEW_LINE INDENT graph_to [ to ] . add ( init ) NEW_LINE DEDENT except KeyError : NEW_LINE INDENT graph_to [ to ] = { init } NEW_LINE DEDENT try : NEW_LINE INDENT graph_from [ init ] . add ( to ) NEW_LINE DEDENT except KeyError : NEW_LINE INDENT graph_from [ init ] = { to } NEW_LINE DEDENT DEDENT DEDENT unreachable_node = reachable ( graph_from , start ) . difference ( reachable ( graph_to , goal ) ) NEW_LINE return 0 == len ( unreachable_node ) NEW_LINE DEDENT import sys NEW_LINE f = sys . stdin NEW_LINE while True : NEW_LINE INDENT m = int ( f . readline ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT d = [ int ( f . readline ( ) ) for _ in range ( int ( f . readline ( ) ) ) ] NEW_LINE print ( ' OK ' if sugoroku ( m , d ) else ' NG ' ) NEW_LINE DEDENT"}
{"id": "aizu_p00291_A", "sol": 0, "python_code": "a , b , c , d , e , f = map ( int , input ( ).split ( ) )\nsum = a + b * 5 + c * 10 + d * 50 + e * 100 + f * 500\nprint ( 1 if sum >= 1000 else 0 )\n", "python_code_tokenized": "a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) NEW_LINE sum = a + b * 5 + c * 10 + d * 50 + e * 100 + f * 500 NEW_LINE print ( 1 if sum >= 1000 else 0 ) NEW_LINE"}
{"id": "geeksforgeeks_2512_A", "sol": 0, "python_code": "def makearrayequal ( arr , n ) :\n    x = 0 ;\n    for i in range ( n ) :\n        x += arr [ i ] & 1 ;\n    print ( min ( x , n - x ) ) ;\nif __name__ == \"__main__\" :\n    arr = [ 4 , 3 , 2 , 1 ] ;\n    n = len ( arr ) ;\n    makearrayequal ( arr , n ) ;\n", "python_code_tokenized": "def makearrayequal ( arr , n ) : NEW_LINE INDENT x = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += arr [ i ] & 1 ; NEW_LINE DEDENT print ( min ( x , n - x ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE makearrayequal ( arr , n ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5102_A", "sol": 0, "python_code": "def findMinimal ( a , n ) :\n    a.sort ( )\n    sum = 0\n    for i in range ( n // 2 ) :\n        sum += ( ( a [ i ] + a [ n - i - 1 ] ) * ( a [ i ] + a [ n - i - 1 ] ) )\n    return sum\nif __name__ == \"__main__\" :\n    a = [ 8 , 5 , 2 , 3 ]\n    n = len ( a )\n    print ( findMinimal ( a , n ) )\n", "python_code_tokenized": "def findMinimal ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT sum += ( ( a [ i ] + a [ n - i - 1 ] ) * ( a [ i ] + a [ n - i - 1 ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 8 , 5 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimal ( a , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1244_A", "sol": 0, "python_code": "from math import ceil\nfor _ in range ( int ( input ( ) ) ) :\n    a , b , c , d , k = map ( int , input ( ).split ( ) )\n    first = ceil ( a / c )\n    second = ceil ( b / d )\n    print ( - 1 if first + second > k else f\"{first} {k - first}\" )\n", "python_code_tokenized": "from math import ceil NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c , d , k = map ( int , input ( ) . split ( ) ) NEW_LINE first = ceil ( a / c ) NEW_LINE second = ceil ( b / d ) NEW_LINE print ( - 1 if first + second > k else f \" { first } \u2581 { k \u2581 - \u2581 first } \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3382_A", "sol": 0, "python_code": "def findCost ( str , arr , n ) :\n    costofC , costofO = 0 , 0\n    costofD , costofE = 0 , 0\n    for i in range ( n ) :\n        if ( str [ i ] == 'c' ) :\n            costofC += arr [ i ]\n        elif ( str [ i ] == 'o' ) :\n            costofO = min ( costofC , costofO + arr [ i ] )\n        elif ( str [ i ] == 'd' ) :\n            costofD = min ( costofO , costofD + arr [ i ] )\n        elif ( str [ i ] == 'e' ) :\n            costofE = min ( costofD , costofE + arr [ i ] )\n    return costofE\nif __name__ == '__main__' :\n    str = \"geekcodergeeks\"\n    arr = [ 1 , 2 , 1 , 3 , 4 , 2 , 6 , 4 , 6 , 2 , 3 , 3 , 3 , 2 ]\n    n = len ( arr )\n    print ( findCost ( str , arr , n ) )\n", "python_code_tokenized": "def findCost ( str , arr , n ) : NEW_LINE INDENT costofC , costofO = 0 , 0 NEW_LINE costofD , costofE = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == ' c ' ) : NEW_LINE INDENT costofC += arr [ i ] NEW_LINE DEDENT elif ( str [ i ] == ' o ' ) : NEW_LINE INDENT costofO = min ( costofC , costofO + arr [ i ] ) NEW_LINE DEDENT elif ( str [ i ] == ' d ' ) : NEW_LINE INDENT costofD = min ( costofO , costofD + arr [ i ] ) NEW_LINE DEDENT elif ( str [ i ] == ' e ' ) : NEW_LINE INDENT costofE = min ( costofD , costofE + arr [ i ] ) NEW_LINE DEDENT DEDENT return costofE NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geekcodergeeks \" NEW_LINE arr = [ 1 , 2 , 1 , 3 , 4 , 2 , 6 , 4 , 6 , 2 , 3 , 3 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findCost ( str , arr , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_111_A", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nn , x , y = map ( int , input ( ).split ( ) )\nans = [ - 1 ] if y < n or n - 1 + pow ( y - n + 1 , 2 ) < x else [ 1 ] * ( n - 1 ) + [ y - n + 1 ]\nsys.stdout.write ( \"\\n\".join ( map ( str , ans ) ) )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ - 1 ] if y < n or n - 1 + pow ( y - n + 1 , 2 ) < x else [ 1 ] * ( n - 1 ) + [ y - n + 1 ] NEW_LINE sys . stdout . write ( \" \\n \" . join ( map ( str , ans ) ) ) NEW_LINE"}
{"id": "codeforces_214_A", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nx = min ( n , m )\nli = [ ]\nfor i in range ( x + 1 ) :\n    x1 = pow ( i , 2 )\n    for j in range ( x + 1 ) :\n        y1 = pow ( j , 2 )\n        if ( x1 + j == n and i + y1 == m ) :\n            li.append ( ( i , j ) )\nprint ( len ( li ) )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE x = min ( n , m ) NEW_LINE li = [ ] NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT x1 = pow ( i , 2 ) NEW_LINE for j in range ( x + 1 ) : NEW_LINE INDENT y1 = pow ( j , 2 ) NEW_LINE if ( x1 + j == n and i + y1 == m ) : NEW_LINE INDENT li . append ( ( i , j ) ) NEW_LINE DEDENT DEDENT DEDENT print ( len ( li ) ) NEW_LINE"}
{"id": "geeksforgeeks_4998_A", "sol": 0, "python_code": "def maxProduct ( arr , n ) :\n    if n < 3 :\n        return - 1\n    arr.sort ( )\n    return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] )\nif __name__ == \"__main__\" :\n    arr = [ - 10 , - 3 , 5 , 6 , - 20 ]\n    n = len ( arr )\n    _max = maxProduct ( arr , n )\n    if _max == - 1 :\n        print ( \"No Triplet Exists\" )\n    else :\n        print ( \"Maximum product is\" , _max )\n", "python_code_tokenized": "def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 10 , - 3 , 5 , 6 , - 20 ] NEW_LINE n = len ( arr ) NEW_LINE _max = maxProduct ( arr , n ) NEW_LINE if _max == - 1 : NEW_LINE INDENT print ( \" No \u2581 Triplet \u2581 Exists \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Maximum \u2581 product \u2581 is \" , _max ) NEW_LINE DEDENT DEDENT"}
{"id": "projecteuler_p169_A", "sol": 0, "python_code": "import eulerlib , sys\ndef compute ( ) :\n    sys.setrecursionlimit ( 3000 )\n    NUMBER = 10 ** 25\n    ans = count_ways ( NUMBER , NUMBER.bit_length ( ) - 1 , 2 )\n    return str ( ans )\n@ eulerlib.memoize\ndef count_ways ( number , exponent , repetitions ) :\n    if exponent < 0 :\n        return 1 if number == 0 else 0\n    else :\n        result = count_ways ( number , exponent - 1 , 2 )\n        power = 1 << exponent\n        upper = power * ( repetitions + 2 )\n        if repetitions > 0 and power <= number < upper :\n            result += count_ways ( number - power , exponent , repetitions - 1 )\n        return result\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib , sys NEW_LINE def compute ( ) : NEW_LINE INDENT sys . setrecursionlimit ( 3000 ) NEW_LINE NUMBER = 10 ** 25 NEW_LINE ans = count_ways ( NUMBER , NUMBER . bit_length ( ) - 1 , 2 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT @ eulerlib . memoize NEW_LINE def count_ways ( number , exponent , repetitions ) : NEW_LINE INDENT if exponent < 0 : NEW_LINE INDENT return 1 if number == 0 else 0 NEW_LINE DEDENT else : NEW_LINE INDENT result = count_ways ( number , exponent - 1 , 2 ) NEW_LINE power = 1 << exponent NEW_LINE upper = power * ( repetitions + 2 ) NEW_LINE if repetitions > 0 and power <= number < upper : NEW_LINE INDENT result += count_ways ( number - power , exponent , repetitions - 1 ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2531_A", "sol": 0, "python_code": "def MinSteps ( SourceX , SourceY , DestX , DestY ) :\n    print ( max ( abs ( SourceX - DestX ) , abs ( SourceY - DestY ) ) )\n    while ( ( SourceX != DestX ) or ( SourceY != DestY ) ) :\n        if ( SourceX < DestX ) :\n            print ( 'U' , end = \"\" )\n            SourceX += 1\n        if ( SourceX > DestX ) :\n            print ( 'D' , end = \"\" )\n            SourceX -= 1\n        if ( SourceY > DestY ) :\n            print ( 'L' )\n            SourceY -= 1\n        if ( SourceY < DestY ) :\n            print ( 'R' , end = \"\" )\n            SourceY += 1\nif __name__ == '__main__' :\n    sourceX = 4\n    sourceY = 4\n    destinationX = 7\n    destinationY = 0\n    MinSteps ( sourceX , sourceY , destinationX , destinationY )\n", "python_code_tokenized": "def MinSteps ( SourceX , SourceY , DestX , DestY ) : NEW_LINE INDENT print ( max ( abs ( SourceX - DestX ) , abs ( SourceY - DestY ) ) ) NEW_LINE while ( ( SourceX != DestX ) or ( SourceY != DestY ) ) : NEW_LINE INDENT if ( SourceX < DestX ) : NEW_LINE INDENT print ( ' U ' , end = \" \" ) NEW_LINE SourceX += 1 NEW_LINE DEDENT if ( SourceX > DestX ) : NEW_LINE INDENT print ( ' D ' , end = \" \" ) NEW_LINE SourceX -= 1 NEW_LINE DEDENT if ( SourceY > DestY ) : NEW_LINE INDENT print ( ' L ' ) NEW_LINE SourceY -= 1 NEW_LINE DEDENT if ( SourceY < DestY ) : NEW_LINE INDENT print ( ' R ' , end = \" \" ) NEW_LINE SourceY += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sourceX = 4 NEW_LINE sourceY = 4 NEW_LINE destinationX = 7 NEW_LINE destinationY = 0 NEW_LINE MinSteps ( sourceX , sourceY , destinationX , destinationY ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4570_A", "sol": 0, "python_code": "def minAbsDiff ( n ) :\n    mod = n % 4 ;\n    if ( mod == 0 or mod == 3 ) :\n        return 0 ;\n    return 1 ;\nif __name__ == \"__main__\" :\n    n = 5 ;\n    print ( minAbsDiff ( n ) )\n", "python_code_tokenized": "def minAbsDiff ( n ) : NEW_LINE INDENT mod = n % 4 ; NEW_LINE if ( mod == 0 or mod == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5251_A", "sol": 0, "python_code": "N = 3\ndef MaxTraceSub ( mat ) :\n    max_trace = 0\n    for i in range ( N ) :\n        for j in range ( N ) :\n            r = i\n            s = j\n            trace = 0\n            while ( r < N and s < N ) :\n                trace += mat [ r ]\n                r += 1\n                s += 1\n                max_trace = max ( trace , max_trace )\n    return max_trace\nif __name__ == '__main__' :\n    mat = [ [ 10 , 2 , 5 ] , [ 6 , 10 , 4 ] , [ 2 , 7 , - 10 ] ]\n    print ( MaxTraceSub ( mat ) )\n", "python_code_tokenized": "N = 3 NEW_LINE def MaxTraceSub ( mat ) : NEW_LINE INDENT max_trace = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT r = i NEW_LINE s = j NEW_LINE trace = 0 NEW_LINE while ( r < N and s < N ) : NEW_LINE INDENT trace += mat [ r ] NEW_LINE r += 1 NEW_LINE s += 1 NEW_LINE max_trace = max ( trace , max_trace ) NEW_LINE DEDENT DEDENT DEDENT return max_trace NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 10 , 2 , 5 ] , [ 6 , 10 , 4 ] , [ 2 , 7 , - 10 ] ] NEW_LINE print ( MaxTraceSub ( mat ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00629_A", "sol": 0, "python_code": "def pr ( i , u ) :\n    global total\n    print ( team [ i ] [ 0 ] )\n    total , affi [ u ] = total + 1 , affi [ u ] + 1\nwhile True :\n    n = int ( input ( ) )\n    if n == 0 : break\n    team = [ ]\n    for i in range ( n ) :\n        id , u , a , p = map ( int , input ( ).split ( ) )\n        team.append ( ( id , u , a , p ) )\n    team.sort ( key = lambda x : ( - x [ 2 ] , x [ 3 ] , x [ 0 ] ) )\n    total , affi = 0 , [ 0 ] * 1002\n    for i in range ( n ) :\n        u = team [ i ] [ 1 ]\n        if total < 10 and affi [ u ] < 3 : pr ( i , u )\n        elif total < 20 and affi [ u ] < 2 : pr ( i , u )\n        elif total < 26 and affi [ u ] < 1 : pr ( i , u )\n", "python_code_tokenized": "def pr ( i , u ) : NEW_LINE INDENT global total NEW_LINE print ( team [ i ] [ 0 ] ) NEW_LINE total , affi [ u ] = total + 1 , affi [ u ] + 1 NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE team = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT id , u , a , p = map ( int , input ( ) . split ( ) ) NEW_LINE team . append ( ( id , u , a , p ) ) NEW_LINE DEDENT team . sort ( key = lambda x : ( - x [ 2 ] , x [ 3 ] , x [ 0 ] ) ) NEW_LINE total , affi = 0 , [ 0 ] * 1002 NEW_LINE for i in range ( n ) : NEW_LINE INDENT u = team [ i ] [ 1 ] NEW_LINE if total < 10 and affi [ u ] < 3 : pr ( i , u ) NEW_LINE elif total < 20 and affi [ u ] < 2 : pr ( i , u ) NEW_LINE elif total < 26 and affi [ u ] < 1 : pr ( i , u ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_162_A", "sol": 0, "python_code": "def isPrime ( c ) :\n    return ( c == '2' or c == '3' or c == '5' or c == '7' )\ndef decrease ( s , i ) :\n    if ( s [ i ] <= '2' ) :\n        s [ i ] = '7'\n    elif ( s [ i ] == '3' ) :\n        s [ i ] = '2'\n    elif ( s [ i ] <= '5' ) :\n        s [ i ] = '3'\n    elif ( s [ i ] <= '7' ) :\n        s [ i ] = '5'\n    else :\n        s [ i ] = '7'\ndef primeDigits ( s ) :\n    s = [ i for i in s ]\n    i = 0\n    while i < len ( s ) :\n        if ( isPrime ( s [ i ] ) == False ) :\n            while ( s [ i ] <= '2' and i >= 0 ) :\n                i -= 1\n            if ( i < 0 ) :\n                i = 0\n                decrease ( s , i )\n            else :\n                decrease ( s , i )\n            for j in range ( i + 1 , len ( s ) ) :\n                s [ j ] = '7'\n            break\n        i += 1\n    return \"\".join ( s )\ns = \"45\"\nprint ( primeDigits ( s ) )\ns = \"1000\"\nprint ( primeDigits ( s ) )\ns = \"7721\"\nprint ( primeDigits ( s ) )\ns = \"7221\"\nprint ( primeDigits ( s ) )\ns = \"74545678912345689748593275897894708927680\"\nprint ( primeDigits ( s ) )\n", "python_code_tokenized": "def isPrime ( c ) : NEW_LINE INDENT return ( c == '2' or c == '3' or c == '5' or c == '7' ) NEW_LINE DEDENT def decrease ( s , i ) : NEW_LINE INDENT if ( s [ i ] <= '2' ) : NEW_LINE INDENT s [ i ] = '7' NEW_LINE DEDENT elif ( s [ i ] == '3' ) : NEW_LINE INDENT s [ i ] = '2' NEW_LINE DEDENT elif ( s [ i ] <= '5' ) : NEW_LINE INDENT s [ i ] = '3' NEW_LINE DEDENT elif ( s [ i ] <= '7' ) : NEW_LINE INDENT s [ i ] = '5' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = '7' NEW_LINE DEDENT DEDENT def primeDigits ( s ) : NEW_LINE INDENT s = [ i for i in s ] NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if ( isPrime ( s [ i ] ) == False ) : NEW_LINE INDENT while ( s [ i ] <= '2' and i >= 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i < 0 ) : NEW_LINE INDENT i = 0 NEW_LINE decrease ( s , i ) NEW_LINE DEDENT else : NEW_LINE INDENT decrease ( s , i ) NEW_LINE DEDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT s [ j ] = '7' NEW_LINE DEDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return \" \" . join ( s ) NEW_LINE DEDENT s = \"45\" NEW_LINE print ( primeDigits ( s ) ) NEW_LINE s = \"1000\" NEW_LINE print ( primeDigits ( s ) ) NEW_LINE s = \"7721\" NEW_LINE print ( primeDigits ( s ) ) NEW_LINE s = \"7221\" NEW_LINE print ( primeDigits ( s ) ) NEW_LINE s = \"74545678912345689748593275897894708927680\" NEW_LINE print ( primeDigits ( s ) ) NEW_LINE"}
{"id": "geeksforgeeks_1476_A", "sol": 0, "python_code": "def shuffleArray ( a , n ) :\n    i , q , k = 0 , 1 , n\n    while ( i < n ) :\n        j = k\n        while ( j > i + q ) :\n            a [ j - 1 ] , a [ j ] = a [ j ] , a [ j - 1 ]\n            j -= 1\n        i += 1\n        k += 1\n        q += 1\na = [ 1 , 3 , 5 , 7 , 2 , 4 , 6 , 8 ]\nn = len ( a )\nshuffleArray ( a , int ( n / 2 ) )\nfor i in range ( 0 , n ) :\n    print ( a [ i ] , end = \" \" )\n", "python_code_tokenized": "def shuffleArray ( a , n ) : NEW_LINE INDENT i , q , k = 0 , 1 , n NEW_LINE while ( i < n ) : NEW_LINE INDENT j = k NEW_LINE while ( j > i + q ) : NEW_LINE INDENT a [ j - 1 ] , a [ j ] = a [ j ] , a [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE k += 1 NEW_LINE q += 1 NEW_LINE DEDENT DEDENT a = [ 1 , 3 , 5 , 7 , 2 , 4 , 6 , 8 ] NEW_LINE n = len ( a ) NEW_LINE shuffleArray ( a , int ( n / 2 ) ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "aizu_p01634_A", "sol": 0, "python_code": "s = input ( )\nif len ( s ) >= 6 and any ( [ ( c in s ) for c in \"1234567890\" ] ) and any ( [ ( c in s ) for c in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ] ) and any ( [ ( c in s ) for c in \"abcdefghijklmnopqrstuvwxyz\" ] ) :\n    print ( \"VALID\" )\nelse :\n    print ( \"INVALID\" )\n", "python_code_tokenized": "s = input ( ) NEW_LINE if len ( s ) >= 6 and any ( [ ( c in s ) for c in \"1234567890\" ] ) and any ( [ ( c in s ) for c in \" ABCDEFGHIJKLMNOPQRSTUVWXYZ \" ] ) and any ( [ ( c in s ) for c in \" abcdefghijklmnopqrstuvwxyz \" ] ) : NEW_LINE INDENT print ( \" VALID \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" INVALID \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1076_B", "sol": 0, "python_code": "import math\nlista = [ ]\nlista.append ( 2 )\ndef prime ( a ) :\n    counter = 0\n    for i in range ( 1 , math.ceil ( math.sqrt ( a ) + 1 ) ) :\n        if a % i == 0 :\n            counter += 1\n    if counter <= 1 :\n        lista.append ( a )\nn = int ( input ( ) )\ncounter = 0\nfor j in range ( 2 , math.ceil ( math.sqrt ( n ) + 1 ) ) :\n    prime ( j )\nres = 1\nfor i in range ( len ( lista ) ) :\n    if n % lista [ i ] == 0 :\n        d = lista [ i ]\n        if n % 2 == 0 :\n            res = n // d\n            break\n        else :\n            res = ( ( n - d ) // 2 ) + 1\n            break\nprint ( res )\n", "python_code_tokenized": "import math NEW_LINE lista = [ ] NEW_LINE lista . append ( 2 ) NEW_LINE def prime ( a ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , math . ceil ( math . sqrt ( a ) + 1 ) ) : NEW_LINE INDENT if a % i == 0 : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT if counter <= 1 : NEW_LINE INDENT lista . append ( a ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE counter = 0 NEW_LINE for j in range ( 2 , math . ceil ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT prime ( j ) NEW_LINE DEDENT res = 1 NEW_LINE for i in range ( len ( lista ) ) : NEW_LINE INDENT if n % lista [ i ] == 0 : NEW_LINE INDENT d = lista [ i ] NEW_LINE if n % 2 == 0 : NEW_LINE INDENT res = n // d NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT res = ( ( n - d ) // 2 ) + 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE"}
{"id": "codeforces_735_A", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\ns = input ( )\nif s.index ( \"G\" ) > s.index ( \"T\" ) :\n    s = s [ : : - 1 ]\nif \"T\" in s [ s.index ( \"G\" ) : : k ].split ( \"#\" ) [ 0 ] :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE if s . index ( \" G \" ) > s . index ( \" T \" ) : NEW_LINE INDENT s = s [ : : - 1 ] NEW_LINE DEDENT if \" T \" in s [ s . index ( \" G \" ) : : k ] . split ( \" # \" ) [ 0 ] : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC132_F", "sol": 0, "python_code": "mod = 10 ** 9 + 7\nn , k = map ( int , input ( ).split ( ) )\ncoef = [ ]\nfor i in range ( 1 , int ( n ** 0.5 ) + 1 ) :\n    coef.append ( ( n // i ) - ( n // ( i + 1 ) ) )\ncoef += [ 1 ] * ( n - sum ( coef ) )\ncoef = coef [ : : - 1 ]\nnn = len ( coef )\ndp = [ [ 0 ] * nn for _ in range ( k + 1 ) ]\ndp [ 0 ] [ 0 ] = 1\nfor i in range ( 1 , k + 1 ) :\n    tmp = 0\n    for j in range ( nn - 1 , - 1 , - 1 ) :\n        tmp += dp [ i - 1 ] [ ( nn - 1 ) - j ]\n        tmp %= mod\n        dp [ i ] [ j ] = coef [ j ] * tmp\n        dp [ i ] [ j ] %= mod\nprint ( sum ( dp [ k ] ) % mod )\n", "python_code_tokenized": "mod = 10 ** 9 + 7 NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE coef = [ ] NEW_LINE for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT coef . append ( ( n // i ) - ( n // ( i + 1 ) ) ) NEW_LINE DEDENT coef += [ 1 ] * ( n - sum ( coef ) ) NEW_LINE coef = coef [ : : - 1 ] NEW_LINE nn = len ( coef ) NEW_LINE dp = [ [ 0 ] * nn for _ in range ( k + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT tmp = 0 NEW_LINE for j in range ( nn - 1 , - 1 , - 1 ) : NEW_LINE INDENT tmp += dp [ i - 1 ] [ ( nn - 1 ) - j ] NEW_LINE tmp %= mod NEW_LINE dp [ i ] [ j ] = coef [ j ] * tmp NEW_LINE dp [ i ] [ j ] %= mod NEW_LINE DEDENT DEDENT print ( sum ( dp [ k ] ) % mod ) NEW_LINE"}
{"id": "aizu_p00667_A", "sol": 0, "python_code": "def f3 ( n ) :\n    a = b = c = 0\n    for _ in range ( n ) :\n        a , b , c = ( a + b + c + 1 ) % 100000007 , a , b\n    return a\ndef f5 ( n ) :\n    a = b = c = d = e = 0\n    for _ in range ( n ) :\n        a , b , c , d , e = ( a + b + c + d + e + 1 ) % 100000007 , a , b , c , d\n    return a\nwhile 1 :\n    s = input ( )\n    if s == \"#\" : break\n    ans = 1\n    num = \"_\"\n    cnt = 1\n    for n in s + \"_\" :\n        if n == num :\n            cnt += 1\n        else :\n            if num in \"80\" :\n                ans = ans * f3 ( cnt ) % 100000007\n            else :\n                ans = ans * f5 ( cnt ) % 100000007\n            num = n\n            cnt = 1\n    print ( ans )\n", "python_code_tokenized": "def f3 ( n ) : NEW_LINE INDENT a = b = c = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b , c = ( a + b + c + 1 ) % 100000007 , a , b NEW_LINE DEDENT return a NEW_LINE DEDENT def f5 ( n ) : NEW_LINE INDENT a = b = c = d = e = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b , c , d , e = ( a + b + c + d + e + 1 ) % 100000007 , a , b , c , d NEW_LINE DEDENT return a NEW_LINE DEDENT while 1 : NEW_LINE INDENT s = input ( ) NEW_LINE if s == \" # \" : break NEW_LINE ans = 1 NEW_LINE num = \" _ \" NEW_LINE cnt = 1 NEW_LINE for n in s + \" _ \" : NEW_LINE INDENT if n == num : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if num in \"80\" : NEW_LINE INDENT ans = ans * f3 ( cnt ) % 100000007 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans * f5 ( cnt ) % 100000007 NEW_LINE DEDENT num = n NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "aizu_p01283_A", "sol": 0, "python_code": "import math\nM = 256\ndef entropy_if_smallest ( ctr , bound ) :\n    ret = 0\n    for v in ctr :\n        if v == 0 : continue\n        ret -= ( v / N ) * math.log2 ( v / N )\n        if ret >= bound :\n            return None\n    return ret\ndef solve ( src ) :\n    ans_h = float ( 'inf' )\n    ans = None\n    for s in range ( 16 ) :\n        for a in range ( 16 ) :\n            for c in range ( 16 ) :\n                ctr = [ 0 ] * M\n                r = s\n                for i in src :\n                    r = ( a * r + c ) % M\n                    o = ( i + r ) % M\n                    ctr [ o ] += 1\n                h = entropy_if_smallest ( ctr , ans_h )\n                if h is not None :\n                    ans = ( s , a , c )\n                    ans_h = h\n                    if ans_h == 0 :\n                        return ans\n    return ans\nwhile True :\n    N = int ( input ( ) )\n    if N == 0 : break\n    src = list ( map ( int , input ( ).split ( ) ) )\n    print ( ' '.join ( map ( str , solve ( src ) ) ) )\n", "python_code_tokenized": "import math NEW_LINE M = 256 NEW_LINE def entropy_if_smallest ( ctr , bound ) : NEW_LINE INDENT ret = 0 NEW_LINE for v in ctr : NEW_LINE INDENT if v == 0 : continue NEW_LINE ret -= ( v / N ) * math . log2 ( v / N ) NEW_LINE if ret >= bound : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT def solve ( src ) : NEW_LINE INDENT ans_h = float ( ' inf ' ) NEW_LINE ans = None NEW_LINE for s in range ( 16 ) : NEW_LINE INDENT for a in range ( 16 ) : NEW_LINE INDENT for c in range ( 16 ) : NEW_LINE INDENT ctr = [ 0 ] * M NEW_LINE r = s NEW_LINE for i in src : NEW_LINE INDENT r = ( a * r + c ) % M NEW_LINE o = ( i + r ) % M NEW_LINE ctr [ o ] += 1 NEW_LINE DEDENT h = entropy_if_smallest ( ctr , ans_h ) NEW_LINE if h is not None : NEW_LINE INDENT ans = ( s , a , c ) NEW_LINE ans_h = h NEW_LINE if ans_h == 0 : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : break NEW_LINE src = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( ' \u2581 ' . join ( map ( str , solve ( src ) ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4833_A", "sol": 0, "python_code": "def countSol ( coeff , n , rhs ) :\n    dp = [ 0 for i in range ( rhs + 1 ) ]\n    dp [ 0 ] = 1\n    for i in range ( n ) :\n        for j in range ( coeff [ i ] , rhs + 1 ) :\n            dp [ j ] += dp [ j - coeff [ i ] ]\n    return dp [ rhs ]\ncoeff = [ 2 , 2 , 5 ]\nrhs = 4\nn = len ( coeff )\nprint ( countSol ( coeff , n , rhs ) )\n", "python_code_tokenized": "def countSol ( coeff , n , rhs ) : NEW_LINE INDENT dp = [ 0 for i in range ( rhs + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( coeff [ i ] , rhs + 1 ) : NEW_LINE INDENT dp [ j ] += dp [ j - coeff [ i ] ] NEW_LINE DEDENT DEDENT return dp [ rhs ] NEW_LINE DEDENT coeff = [ 2 , 2 , 5 ] NEW_LINE rhs = 4 NEW_LINE n = len ( coeff ) NEW_LINE print ( countSol ( coeff , n , rhs ) ) NEW_LINE"}
{"id": "atcoder_ABC174_E", "sol": 0, "python_code": "ceil = lambda a , b : ( a + b - 1 ) // b\nN , K = map ( int , input ( ).split ( ) )\nA = tuple ( map ( int , input ( ).split ( ) ) )\nl , r = 0 , max ( A )\nwhile r - l > 1 :\n    m = ( l + r ) // 2\n    if sum ( ceil ( x , m ) - 1 for x in A ) > K :\n        l = m\n    else :\n        r = m\nprint ( r )\n", "python_code_tokenized": "ceil = lambda a , b : ( a + b - 1 ) // b NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l , r = 0 , max ( A ) NEW_LINE while r - l > 1 : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if sum ( ceil ( x , m ) - 1 for x in A ) > K : NEW_LINE INDENT l = m NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT print ( r ) NEW_LINE"}
{"id": "geeksforgeeks_2393_A", "sol": 0, "python_code": "import sys\ndef prevNum ( string , n ) :\n    index = - 1\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if int ( string [ i ] ) > int ( string [ i + 1 ] ) :\n            index = i\n            break\n    smallGreatDgt = - 1\n    for i in range ( n - 1 , index , - 1 ) :\n        if ( smallGreatDgt == - 1 and int ( string [ i ] ) < int ( string [ index ] ) ) :\n            smallGreatDgt = i\n        elif ( index > - 1 and int ( string [ i ] ) >= int ( string [ smallGreatDgt ] ) and int ( string [ i ] ) < int ( string [ index ] ) ) :\n            smallGreatDgt = i\n    if index == - 1 :\n        return \"\".join ( \"-1\" )\n    else :\n        ( string [ index ] , string [ smallGreatDgt ] ) = ( string [ smallGreatDgt ] , string [ index ] )\n    return \"\".join ( string )\nif __name__ == '__main__' :\n    n_str = \"34125\"\n    ans = prevNum ( list ( n_str ) , len ( n_str ) )\n    print ( ans )\n", "python_code_tokenized": "import sys NEW_LINE def prevNum ( string , n ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if int ( string [ i ] ) > int ( string [ i + 1 ] ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT smallGreatDgt = - 1 NEW_LINE for i in range ( n - 1 , index , - 1 ) : NEW_LINE INDENT if ( smallGreatDgt == - 1 and int ( string [ i ] ) < int ( string [ index ] ) ) : NEW_LINE INDENT smallGreatDgt = i NEW_LINE DEDENT elif ( index > - 1 and int ( string [ i ] ) >= int ( string [ smallGreatDgt ] ) and int ( string [ i ] ) < int ( string [ index ] ) ) : NEW_LINE INDENT smallGreatDgt = i NEW_LINE DEDENT DEDENT if index == - 1 : NEW_LINE INDENT return \" \" . join ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT ( string [ index ] , string [ smallGreatDgt ] ) = ( string [ smallGreatDgt ] , string [ index ] ) NEW_LINE DEDENT return \" \" . join ( string ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n_str = \"34125\" NEW_LINE ans = prevNum ( list ( n_str ) , len ( n_str ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC105_C", "sol": 0, "python_code": "n = int ( input ( ) )\nans = [ ]\nwhile ( n != 0 ) :\n    r = n % 2\n    if r < 0 :\n        r += 2\n    n = ( n - r ) // ( - 2 )\n    ans.append ( r )\nif ans == [ ] :\n    ans.append ( 0 )\nans = ans [ : : - 1 ]\nprint ( * ans , sep = '' )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 2 NEW_LINE if r < 0 : NEW_LINE INDENT r += 2 NEW_LINE DEDENT n = ( n - r ) // ( - 2 ) NEW_LINE ans . append ( r ) NEW_LINE DEDENT if ans == [ ] : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT ans = ans [ : : - 1 ] NEW_LINE print ( * ans , sep = ' ' ) NEW_LINE"}
{"id": "codeforces_1374_B", "sol": 0, "python_code": "n = int ( input ( ) )\nfor i in range ( n ) :\n    test = int ( input ( ) )\n    move = 0\n    while test != 1 :\n        if test % 6 == 0 :\n            test = test / 6\n            move += 1\n        elif test % 3 == 0 :\n            test = test * 2\n            move += 1\n        else :\n            print ( - 1 )\n            break\n    else :\n        print ( move )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT test = int ( input ( ) ) NEW_LINE move = 0 NEW_LINE while test != 1 : NEW_LINE INDENT if test % 6 == 0 : NEW_LINE INDENT test = test / 6 NEW_LINE move += 1 NEW_LINE DEDENT elif test % 3 == 0 : NEW_LINE INDENT test = test * 2 NEW_LINE move += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( move ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC168_D", "sol": 0, "python_code": "from collections import deque\nn , m = map ( int , input ( ).split ( ) )\nINF = 100050\nq = deque ( )\nclass Room :\n    def __init__ ( self , num ) :\n        self.number = num\n        self.frontier = True\n        self.neighbor = [ ]\n        self.arrow = 0\n        self.deepness = INF\n    def set ( self , room ) :\n        self.neighbor.append ( room )\n    def search ( self , num , deps ) :\n        self.arrow = num\n        self.deepness = deps\n        self.frontier = False\n    def dfs ( self ) :\n        for i in self.neighbor :\n            if rooms [ i ].frontier :\n                rooms [ i ].search ( self.number , self.deepness + 1 )\n                q.append ( i )\nrooms = [ ]\nfor i in range ( n + 1 ) :\n    rooms.append ( Room ( i ) )\nfor _ in range ( m ) :\n    a , b = map ( int , input ( ).split ( ) )\n    rooms [ a ].set ( b )\n    rooms [ b ].set ( a )\nq.append ( 1 )\nwhile q :\n    rooms [ q.popleft ( ) ].dfs ( )\nprint ( \"Yes\" )\nfor i in range ( 2 , len ( rooms ) ) :\n    if rooms [ i ].frontier == False :\n        print ( rooms [ i ].arrow )\n", "python_code_tokenized": "from collections import deque NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE INF = 100050 NEW_LINE q = deque ( ) NEW_LINE class Room : NEW_LINE INDENT def __init__ ( self , num ) : NEW_LINE INDENT self . number = num NEW_LINE self . frontier = True NEW_LINE self . neighbor = [ ] NEW_LINE self . arrow = 0 NEW_LINE self . deepness = INF NEW_LINE DEDENT def set ( self , room ) : NEW_LINE INDENT self . neighbor . append ( room ) NEW_LINE DEDENT def search ( self , num , deps ) : NEW_LINE INDENT self . arrow = num NEW_LINE self . deepness = deps NEW_LINE self . frontier = False NEW_LINE DEDENT def dfs ( self ) : NEW_LINE INDENT for i in self . neighbor : NEW_LINE INDENT if rooms [ i ] . frontier : NEW_LINE INDENT rooms [ i ] . search ( self . number , self . deepness + 1 ) NEW_LINE q . append ( i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT rooms = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT rooms . append ( Room ( i ) ) NEW_LINE DEDENT for _ in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE rooms [ a ] . set ( b ) NEW_LINE rooms [ b ] . set ( a ) NEW_LINE DEDENT q . append ( 1 ) NEW_LINE while q : NEW_LINE INDENT rooms [ q . popleft ( ) ] . dfs ( ) NEW_LINE DEDENT print ( \" Yes \" ) NEW_LINE for i in range ( 2 , len ( rooms ) ) : NEW_LINE INDENT if rooms [ i ] . frontier == False : NEW_LINE INDENT print ( rooms [ i ] . arrow ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3815_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    if ( b == 0 ) :\n        return a\n    return gcd ( b , a % b )\ndef maxLengthSubArray ( arr , n ) :\n    maxLen = - 1\n    for i in range ( n - 1 ) :\n        for j in range ( n ) :\n            lcm = arr [ i ]\n            product = arr [ i ]\n            for k in range ( i + 1 , j + 1 ) :\n                lcm = ( ( ( arr [ k ] * lcm ) ) // ( gcd ( arr [ k ] , lcm ) ) )\n                product = product * arr [ k ]\n            if ( lcm == product ) :\n                maxLen = max ( maxLen , j - i + 1 )\n    return maxLen\narr = [ 6 , 10 , 21 ]\nn = len ( arr )\nprint ( maxLengthSubArray ( arr , n ) )\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def maxLengthSubArray ( arr , n ) : NEW_LINE INDENT maxLen = - 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT lcm = arr [ i ] NEW_LINE product = arr [ i ] NEW_LINE for k in range ( i + 1 , j + 1 ) : NEW_LINE INDENT lcm = ( ( ( arr [ k ] * lcm ) ) // ( gcd ( arr [ k ] , lcm ) ) ) NEW_LINE product = product * arr [ k ] NEW_LINE DEDENT if ( lcm == product ) : NEW_LINE INDENT maxLen = max ( maxLen , j - i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT arr = [ 6 , 10 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxLengthSubArray ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2612_A", "sol": 0, "python_code": "import math\ndef findX ( n , k ) :\n    r = n\n    m = int ( math.sqrt ( k ) ) + 1\n    i = 2\n    while i <= m and k > 1 :\n        if ( i == m ) :\n            i = k\n        u = 0\n        v = 0\n        while k % i == 0 :\n            k //= i\n            v += 1\n        if ( v > 0 ) :\n            t = n\n            while ( t > 0 ) :\n                t //= i\n                u += t\n            r = min ( r , u // v )\n        i += 1\n    return r\nif __name__ == \"__main__\" :\n    n = 5\n    k = 2\n    print ( findX ( n , k ) )\n", "python_code_tokenized": "import math NEW_LINE def findX ( n , k ) : NEW_LINE INDENT r = n NEW_LINE m = int ( math . sqrt ( k ) ) + 1 NEW_LINE i = 2 NEW_LINE while i <= m and k > 1 : NEW_LINE INDENT if ( i == m ) : NEW_LINE INDENT i = k NEW_LINE DEDENT u = 0 NEW_LINE v = 0 NEW_LINE while k % i == 0 : NEW_LINE INDENT k //= i NEW_LINE v += 1 NEW_LINE DEDENT if ( v > 0 ) : NEW_LINE INDENT t = n NEW_LINE while ( t > 0 ) : NEW_LINE INDENT t //= i NEW_LINE u += t NEW_LINE DEDENT r = min ( r , u // v ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return r NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( findX ( n , k ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1148_A", "sol": 0, "python_code": "a , b , c = map ( int , input ( ).split ( ) )\nprint ( 2 * ( min ( a , b ) + c ) + ( a != b ) )\n", "python_code_tokenized": "a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 2 * ( min ( a , b ) + c ) + ( a != b ) ) NEW_LINE"}
{"id": "aizu_p00025_A", "sol": 0, "python_code": "import sys\nEven = True\nfor s in sys.stdin :\n    if Even :\n        Even = False\n        a = list ( map ( int , s.split ( ) ) )\n    else :\n        Even = True\n        b = list ( map ( int , s.split ( ) ) )\n        hit = sum ( a [ i ] == b [ i ] for i in range ( 4 ) )\n        blow = sum ( b [ i ] in a for i in range ( 4 ) ) - hit\n        print ( hit , blow )\n", "python_code_tokenized": "import sys NEW_LINE Even = True NEW_LINE for s in sys . stdin : NEW_LINE INDENT if Even : NEW_LINE INDENT Even = False NEW_LINE a = list ( map ( int , s . split ( ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT Even = True NEW_LINE b = list ( map ( int , s . split ( ) ) ) NEW_LINE hit = sum ( a [ i ] == b [ i ] for i in range ( 4 ) ) NEW_LINE blow = sum ( b [ i ] in a for i in range ( 4 ) ) - hit NEW_LINE print ( hit , blow ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1672_A", "sol": 0, "python_code": "a = int ( input ( ) )\nfor i in range ( a ) :\n    b = int ( input ( ) )\n    arr = list ( map ( int , input ( ).split ( ) ) )\n    tmp = b\n    win1 = 0\n    win2 = 0\n    cnt = 0\n    for j in arr :\n        if j % 2 == 0 :\n            cnt += 1\n    if cnt % 2 == 1 :\n        print ( \"errorgorn\" )\n    else :\n        print ( \"maomao90\" )\n", "python_code_tokenized": "a = int ( input ( ) ) NEW_LINE for i in range ( a ) : NEW_LINE INDENT b = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE tmp = b NEW_LINE win1 = 0 NEW_LINE win2 = 0 NEW_LINE cnt = 0 NEW_LINE for j in arr : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt % 2 == 1 : NEW_LINE INDENT print ( \" errorgorn \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" maomao90\" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_997_B", "sol": 0, "python_code": "a = [ 0 , 4 , 10 , 20 , 35 , 56 , 83 , 116 , 155 , 198 , 244 , 292 ]\nn = int ( input ( ) )\nif n < 11 :\n    print ( a [ n ] )\nelse :\n    print ( ( n - 11 ) * 49 + 292 )\n", "python_code_tokenized": "a = [ 0 , 4 , 10 , 20 , 35 , 56 , 83 , 116 , 155 , 198 , 244 , 292 ] NEW_LINE n = int ( input ( ) ) NEW_LINE if n < 11 : NEW_LINE INDENT print ( a [ n ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n - 11 ) * 49 + 292 ) NEW_LINE DEDENT"}
{"id": "codeforces_727_A", "sol": 0, "python_code": "n1 , n2 = map ( int , ( input ( ).split ( ) ) )\nsequence = [ ]\nfound = False\ndef change ( num , seq , n2 ) :\n    if num == n2 :\n        global found , sequence\n        found = True\n        sequence = seq.copy ( )\n        return\n    if num > n2 :\n        return\n    change ( num * 2 , seq + [ num * 2 ] , n2 )\n    change ( ( num * 10 ) + 1 , seq + [ ( num * 10 ) + 1 ] , n2 )\nchange ( n1 , [ n1 ] , n2 )\nif found :\n    print ( \"YES\" )\n    print ( len ( sequence ) )\n    for n in sequence :\n        print ( n , end = \" \" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "n1 , n2 = map ( int , ( input ( ) . split ( ) ) ) NEW_LINE sequence = [ ] NEW_LINE found = False NEW_LINE def change ( num , seq , n2 ) : NEW_LINE INDENT if num == n2 : NEW_LINE INDENT global found , sequence NEW_LINE found = True NEW_LINE sequence = seq . copy ( ) NEW_LINE return NEW_LINE DEDENT if num > n2 : NEW_LINE INDENT return NEW_LINE DEDENT change ( num * 2 , seq + [ num * 2 ] , n2 ) NEW_LINE change ( ( num * 10 ) + 1 , seq + [ ( num * 10 ) + 1 ] , n2 ) NEW_LINE DEDENT change ( n1 , [ n1 ] , n2 ) NEW_LINE if found : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE print ( len ( sequence ) ) NEW_LINE for n in sequence : NEW_LINE INDENT print ( n , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "codeforces_383_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = [ int ( x ) for x in input ( ).split ( ) ]\ns = 0\nres = 0\nfor i in a :\n    if i == 0 :\n        res += s\n    else :\n        s += 1\nprint ( res )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE s = 0 NEW_LINE res = 0 NEW_LINE for i in a : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT res += s NEW_LINE DEDENT else : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE"}
{"id": "codeforces_772_B", "sol": 0, "python_code": "import math\ndef dist ( p1 , p2 ) :\n    return math.sqrt ( ( p1 [ 0 ] - p2 [ 0 ] ) ** 2 + ( p1 [ 1 ] - p2 [ 1 ] ) ** 2 )\ndef cross ( p1 , p2 ) :\n    return p1 [ 0 ] * p2 [ 1 ] - p1 [ 1 ] * p2 [ 0 ]\ndef parse_point ( line ) :\n    tokens = line.split ( )\n    return int ( tokens [ 0 ] ) , int ( tokens [ 1 ] )\nn = int ( input ( ) )\npt = [ parse_point ( input ( ) ) for _ in range ( n ) ]\nres = 1e100\npr1 , pr2 = None , None\nfor i in range ( len ( pt ) ) :\n    pr1 = pt [ i - 2 ]\n    pr2 = pt [ i - 1 ]\n    cur = pt [ i ]\n    p1 = ( pr1 [ 0 ] - pr2 [ 0 ] , pr1 [ 1 ] - pr2 [ 1 ] )\n    p2 = ( cur [ 0 ] - pr2 [ 0 ] , cur [ 1 ] - pr2 [ 1 ] )\n    c = dist ( pr1 , cur )\n    if abs ( cross ( p1 , p2 ) / 2 ) / c < res :\n        res = abs ( cross ( p1 , p2 ) / 2 ) / c\nprint ( res )\n", "python_code_tokenized": "import math NEW_LINE def dist ( p1 , p2 ) : NEW_LINE INDENT return math . sqrt ( ( p1 [ 0 ] - p2 [ 0 ] ) ** 2 + ( p1 [ 1 ] - p2 [ 1 ] ) ** 2 ) NEW_LINE DEDENT def cross ( p1 , p2 ) : NEW_LINE INDENT return p1 [ 0 ] * p2 [ 1 ] - p1 [ 1 ] * p2 [ 0 ] NEW_LINE DEDENT def parse_point ( line ) : NEW_LINE INDENT tokens = line . split ( ) NEW_LINE return int ( tokens [ 0 ] ) , int ( tokens [ 1 ] ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE pt = [ parse_point ( input ( ) ) for _ in range ( n ) ] NEW_LINE res = 1e100 NEW_LINE pr1 , pr2 = None , None NEW_LINE for i in range ( len ( pt ) ) : NEW_LINE INDENT pr1 = pt [ i - 2 ] NEW_LINE pr2 = pt [ i - 1 ] NEW_LINE cur = pt [ i ] NEW_LINE p1 = ( pr1 [ 0 ] - pr2 [ 0 ] , pr1 [ 1 ] - pr2 [ 1 ] ) NEW_LINE p2 = ( cur [ 0 ] - pr2 [ 0 ] , cur [ 1 ] - pr2 [ 1 ] ) NEW_LINE c = dist ( pr1 , cur ) NEW_LINE if abs ( cross ( p1 , p2 ) / 2 ) / c < res : NEW_LINE INDENT res = abs ( cross ( p1 , p2 ) / 2 ) / c NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE"}
{"id": "atcoder_AGC039_A", "sol": 0, "python_code": "def p ( st ) :\n    l = len ( st )\n    tc = 1\n    ac = 0\n    p = s [ 0 ]\n    for i in range ( 1 , l ) :\n        if st [ i ] == p :\n            tc += 1\n        else :\n            ac += tc // 2\n            tc = 1\n            p = st [ i ]\n    else :\n        ac += tc // 2\n    return ac\ns = input ( )\nk = int ( input ( ) )\nn = len ( s )\nif n == 1 :\n    print ( k // 2 )\n    exit ( )\nif n == 2 :\n    if s [ 0 ] == s [ 1 ] :\n        print ( k )\n    else :\n        print ( 0 )\n    exit ( )\nac = p ( s )\nif k > 1 :\n    ac4 = p ( s + s + s + s )\n    if ac * 4 == ac4 :\n        print ( ac * k )\n    elif ac4 - ac * 4 == 3 :\n        print ( ac * k + ( k - 1 ) )\n    elif ac4 - ac * 4 == 2 :\n        print ( ac * k + ( k // 2 ) )\nelse :\n    print ( ac )\n", "python_code_tokenized": "def p ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE tc = 1 NEW_LINE ac = 0 NEW_LINE p = s [ 0 ] NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if st [ i ] == p : NEW_LINE INDENT tc += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ac += tc // 2 NEW_LINE tc = 1 NEW_LINE p = st [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ac += tc // 2 NEW_LINE DEDENT return ac NEW_LINE DEDENT s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE n = len ( s ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( k // 2 ) NEW_LINE exit ( ) NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT if s [ 0 ] == s [ 1 ] : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT exit ( ) NEW_LINE DEDENT ac = p ( s ) NEW_LINE if k > 1 : NEW_LINE INDENT ac4 = p ( s + s + s + s ) NEW_LINE if ac * 4 == ac4 : NEW_LINE INDENT print ( ac * k ) NEW_LINE DEDENT elif ac4 - ac * 4 == 3 : NEW_LINE INDENT print ( ac * k + ( k - 1 ) ) NEW_LINE DEDENT elif ac4 - ac * 4 == 2 : NEW_LINE INDENT print ( ac * k + ( k // 2 ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ac ) NEW_LINE DEDENT"}
{"id": "codeforces_579_B", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nn = int ( input ( ) )\nava = [ 1 ] * ( 2 * n + 1 )\nteam = [ 0 ] * ( 2 * n + 1 )\nmember = [ ]\nhigh = [ ]\ndef check ( a , b ) :\n    team [ b ] = a\n    team [ a ] = b\n    ava [ b ] = 0\n    ava [ a ] = 0\nfor _ in range ( 2 * n - 1 ) :\n    a = list ( map ( int , input ( ).split ( ) ) )\n    member.append ( a )\n    high.append ( max ( a ) )\ndef mak_high ( ) :\n    hi = [ ]\n    for i in range ( 2 * n - 1 ) :\n        if ava [ i + 2 ] :\n            canb = [ ]\n            for j in range ( i + 1 ) :\n                if ava [ j + 1 ] :\n                    canb.append ( member [ i ] [ j ] )\n                else :\n                    canb.append ( 0 )\n            hi.append ( max ( canb ) )\n        else :\n            hi.append ( 0 )\n    ma = max ( hi )\n    A = hi.index ( ma )\n    B = member [ A ].index ( ma )\n    check ( A + 2 , B + 1 )\n    return\nfor i in range ( n ) :\n    mak_high ( )\nlast = [ ]\nfor m in range ( 1 , 2 * n + 1 ) :\n    if ava [ m ] :\n        last.append ( m )\nfor j in range ( 1 , 2 * n + 1 ) :\n    print ( team [ j ] , end = \" \" )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE ava = [ 1 ] * ( 2 * n + 1 ) NEW_LINE team = [ 0 ] * ( 2 * n + 1 ) NEW_LINE member = [ ] NEW_LINE high = [ ] NEW_LINE def check ( a , b ) : NEW_LINE INDENT team [ b ] = a NEW_LINE team [ a ] = b NEW_LINE ava [ b ] = 0 NEW_LINE ava [ a ] = 0 NEW_LINE DEDENT for _ in range ( 2 * n - 1 ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE member . append ( a ) NEW_LINE high . append ( max ( a ) ) NEW_LINE DEDENT def mak_high ( ) : NEW_LINE INDENT hi = [ ] NEW_LINE for i in range ( 2 * n - 1 ) : NEW_LINE INDENT if ava [ i + 2 ] : NEW_LINE INDENT canb = [ ] NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT if ava [ j + 1 ] : NEW_LINE INDENT canb . append ( member [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT canb . append ( 0 ) NEW_LINE DEDENT DEDENT hi . append ( max ( canb ) ) NEW_LINE DEDENT else : NEW_LINE INDENT hi . append ( 0 ) NEW_LINE DEDENT DEDENT ma = max ( hi ) NEW_LINE A = hi . index ( ma ) NEW_LINE B = member [ A ] . index ( ma ) NEW_LINE check ( A + 2 , B + 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT mak_high ( ) NEW_LINE DEDENT last = [ ] NEW_LINE for m in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT if ava [ m ] : NEW_LINE INDENT last . append ( m ) NEW_LINE DEDENT DEDENT for j in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT print ( team [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1438_A", "sol": 0, "python_code": "def makeOdd ( n ) :\n    if ( n % 2 != 0 ) :\n        return 1 ;\n    resul = 1 ;\n    while ( n % 2 == 0 ) :\n        n = n / 2 ;\n        resul = resul * 2 ;\n    return resul ;\nn = 36 ;\nprint ( makeOdd ( n ) ) ;\n", "python_code_tokenized": "def makeOdd ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT resul = 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 ; NEW_LINE resul = resul * 2 ; NEW_LINE DEDENT return resul ; NEW_LINE DEDENT n = 36 ; NEW_LINE print ( makeOdd ( n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_656_A", "sol": 0, "python_code": "def maxSum1 ( arr , n ) :\n    dp = [ 0 ] * n\n    maxi = 0\n    for i in range ( n - 1 ) :\n        dp [ i ] = arr [ i ]\n        if ( maxi < arr [ i ] ) :\n            maxi = arr [ i ]\n    for i in range ( 2 , n - 1 ) :\n        for j in range ( i - 1 ) :\n            if ( dp [ i ] < dp [ j ] + arr [ i ] ) :\n                dp [ i ] = dp [ j ] + arr [ i ]\n                if ( maxi < dp [ i ] ) :\n                    maxi = dp [ i ]\n    return maxi\ndef maxSum2 ( arr , n ) :\n    dp = [ 0 ] * n\n    maxi = 0\n    for i in range ( 1 , n ) :\n        dp [ i ] = arr [ i ]\n        if ( maxi < arr [ i ] ) :\n            maxi = arr [ i ]\n    for i in range ( 3 , n ) :\n        for j in range ( 1 , i - 1 ) :\n            if ( dp [ i ] < arr [ i ] + dp [ j ] ) :\n                dp [ i ] = arr [ i ] + dp [ j ]\n                if ( maxi < dp [ i ] ) :\n                    maxi = dp [ i ]\n    return maxi\ndef findMaxSum ( arr , n ) :\n    return max ( maxSum1 ( arr , n ) , maxSum2 ( arr , n ) )\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 3 , 1 ]\n    n = len ( arr )\n    print ( findMaxSum ( arr , n ) )\n", "python_code_tokenized": "def maxSum1 ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE maxi = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE if ( maxi < arr [ i ] ) : NEW_LINE INDENT maxi = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 2 , n - 1 ) : NEW_LINE INDENT for j in range ( i - 1 ) : NEW_LINE INDENT if ( dp [ i ] < dp [ j ] + arr [ i ] ) : NEW_LINE INDENT dp [ i ] = dp [ j ] + arr [ i ] NEW_LINE if ( maxi < dp [ i ] ) : NEW_LINE INDENT maxi = dp [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return maxi NEW_LINE DEDENT def maxSum2 ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE maxi = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE if ( maxi < arr [ i ] ) : NEW_LINE INDENT maxi = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT for j in range ( 1 , i - 1 ) : NEW_LINE INDENT if ( dp [ i ] < arr [ i ] + dp [ j ] ) : NEW_LINE INDENT dp [ i ] = arr [ i ] + dp [ j ] NEW_LINE if ( maxi < dp [ i ] ) : NEW_LINE INDENT maxi = dp [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return maxi NEW_LINE DEDENT def findMaxSum ( arr , n ) : NEW_LINE INDENT return max ( maxSum1 ( arr , n ) , maxSum2 ( arr , n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2630_A", "sol": 0, "python_code": "from math import pow\ndef nthTermOfTheSeries ( n ) :\n    if ( n % 2 == 0 ) :\n        nthTerm = pow ( n - 1 , 2 ) + n\n    else :\n        nthTerm = pow ( n + 1 , 2 ) + n\n    return nthTerm\nif __name__ == '__main__' :\n    n = 8\n    print ( int ( nthTermOfTheSeries ( n ) ) )\n    n = 12\n    print ( int ( nthTermOfTheSeries ( n ) ) )\n    n = 102\n    print ( int ( nthTermOfTheSeries ( n ) ) )\n    n = 999\n    print ( int ( nthTermOfTheSeries ( n ) ) )\n    n = 9999\n    print ( int ( nthTermOfTheSeries ( n ) ) )\n", "python_code_tokenized": "from math import pow NEW_LINE def nthTermOfTheSeries ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT nthTerm = pow ( n - 1 , 2 ) + n NEW_LINE DEDENT else : NEW_LINE INDENT nthTerm = pow ( n + 1 , 2 ) + n NEW_LINE DEDENT return nthTerm NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( int ( nthTermOfTheSeries ( n ) ) ) NEW_LINE n = 12 NEW_LINE print ( int ( nthTermOfTheSeries ( n ) ) ) NEW_LINE n = 102 NEW_LINE print ( int ( nthTermOfTheSeries ( n ) ) ) NEW_LINE n = 999 NEW_LINE print ( int ( nthTermOfTheSeries ( n ) ) ) NEW_LINE n = 9999 NEW_LINE print ( int ( nthTermOfTheSeries ( n ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_934_A", "sol": 0, "python_code": "import math\nclass Sum :\n    tsum = None\nclass Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.next = None\ndef push ( head , data ) :\n    if not head :\n        return Node ( data )\n    new_node = Node ( data )\n    new_node.next = head\n    head = new_node\n    return head\ndef sumOfNode ( head , S ) :\n    if not head :\n        return\n    sumOfNode ( head.next , S )\n    S.tsum += head.data\ndef sumOfNodesUtil ( head ) :\n    S = Sum ( )\n    S.tsum = 0\n    sumOfNode ( head , S )\n    return S.tsum\nif __name__ == '__main__' :\n    head = None\n    head = push ( head , 7 )\n    head = push ( head , 6 )\n    head = push ( head , 8 )\n    head = push ( head , 4 )\n    head = push ( head , 1 )\n    print ( \"Sum of Nodes = {}\".format ( sumOfNodesUtil ( head ) ) )\n", "python_code_tokenized": "import math NEW_LINE class Sum : NEW_LINE INDENT tsum = None NEW_LINE DEDENT class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head , data ) : NEW_LINE INDENT if not head : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT new_node = Node ( data ) NEW_LINE new_node . next = head NEW_LINE head = new_node NEW_LINE return head NEW_LINE DEDENT def sumOfNode ( head , S ) : NEW_LINE INDENT if not head : NEW_LINE INDENT return NEW_LINE DEDENT sumOfNode ( head . next , S ) NEW_LINE S . tsum += head . data NEW_LINE DEDENT def sumOfNodesUtil ( head ) : NEW_LINE INDENT S = Sum ( ) NEW_LINE S . tsum = 0 NEW_LINE sumOfNode ( head , S ) NEW_LINE return S . tsum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 1 ) NEW_LINE print ( \" Sum \u2581 of \u2581 Nodes \u2581 = \u2581 { } \" . format ( sumOfNodesUtil ( head ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_935_A", "sol": 0, "python_code": "import math\nclass Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.next = None\ndef push ( head_ref , new_data ) :\n    new_node = Node ( new_data )\n    new_node.data = new_data\n    new_node.next = head_ref\n    head_ref = new_node\n    return head_ref\ndef sumOfNodes ( head ) :\n    ptr = head\n    sum = 0\n    while ( ptr != None ) :\n        sum = sum + ptr.data\n        ptr = ptr.next\n    return sum\nif __name__ == '__main__' :\n    head = None\n    head = push ( head , 7 )\n    head = push ( head , 6 )\n    head = push ( head , 8 )\n    head = push ( head , 4 )\n    head = push ( head , 1 )\n    print ( \"Sum of nodes =\" , sumOfNodes ( head ) )\n", "python_code_tokenized": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def sumOfNodes ( head ) : NEW_LINE INDENT ptr = head NEW_LINE sum = 0 NEW_LINE while ( ptr != None ) : NEW_LINE INDENT sum = sum + ptr . data NEW_LINE ptr = ptr . next NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 1 ) NEW_LINE print ( \" Sum \u2581 of \u2581 nodes \u2581 = \" , sumOfNodes ( head ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC070_A", "sol": 0, "python_code": "n = input ( )\nif n [ 0 ] == n [ - 1 ] :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "n = input ( ) NEW_LINE if n [ 0 ] == n [ - 1 ] : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "aizu_p00017_A", "sol": 0, "python_code": "while True :\n    try :\n        s = input ( )\n    except :\n        break\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for i in range ( 26 ) :\n        decoded_s = ''\n        for j in range ( len ( s ) ) :\n            if s [ j ] not in alphabet :\n                decoded_s += s [ j ]\n                continue\n            decoded_s += alphabet [ alphabet.index ( s [ j ] ) - i ]\n        if 'the' in decoded_s or 'this' in decoded_s or 'that' in decoded_s :\n            break\n    print ( decoded_s )\n", "python_code_tokenized": "while True : NEW_LINE INDENT try : NEW_LINE INDENT s = input ( ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT alphabet = ' abcdefghijklmnopqrstuvwxyz ' NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT decoded_s = ' ' NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if s [ j ] not in alphabet : NEW_LINE INDENT decoded_s += s [ j ] NEW_LINE continue NEW_LINE DEDENT decoded_s += alphabet [ alphabet . index ( s [ j ] ) - i ] NEW_LINE DEDENT if ' the ' in decoded_s or ' this ' in decoded_s or ' that ' in decoded_s : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( decoded_s ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2067_A", "sol": 0, "python_code": "def minimumMoves ( k , l , r ) :\n    count = r - l + 1\n    if ( count % k == 0 ) :\n        return 0\n    return ( k - ( count % k ) )\nif __name__ == '__main__' :\n    k = 3\n    l = 10\n    r = 10\n    print ( minimumMoves ( k , l , r ) )\n", "python_code_tokenized": "def minimumMoves ( k , l , r ) : NEW_LINE INDENT count = r - l + 1 NEW_LINE if ( count % k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( k - ( count % k ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 3 NEW_LINE l = 10 NEW_LINE r = 10 NEW_LINE print ( minimumMoves ( k , l , r ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC111_A", "sol": 0, "python_code": "n = str ( input ( ) )\nans = ''\nfor i in range ( 3 ) :\n    if n [ i ] == '1' :\n        ans += '9'\n    elif n [ i ] == '9' :\n        ans += '1'\nprint ( int ( ans ) )\n", "python_code_tokenized": "n = str ( input ( ) ) NEW_LINE ans = ' ' NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if n [ i ] == '1' : NEW_LINE INDENT ans += '9' NEW_LINE DEDENT elif n [ i ] == '9' : NEW_LINE INDENT ans += '1' NEW_LINE DEDENT DEDENT print ( int ( ans ) ) NEW_LINE"}
{"id": "geeksforgeeks_3405_A", "sol": 0, "python_code": "def isToOne ( n ) :\n    return ( n > 0 )\nn = 5\nif isToOne ( n ) == True :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def isToOne ( n ) : NEW_LINE INDENT return ( n > 0 ) NEW_LINE DEDENT n = 5 NEW_LINE if isToOne ( n ) == True : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "projecteuler_p028_A", "sol": 0, "python_code": "def compute ( ) :\n    SIZE = 1001\n    ans = 1\n    ans += sum ( 4 * i * i - 6 * ( i - 1 ) for i in range ( 3 , SIZE + 1 , 2 ) )\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT SIZE = 1001 NEW_LINE ans = 1 NEW_LINE ans += sum ( 4 * i * i - 6 * ( i - 1 ) for i in range ( 3 , SIZE + 1 , 2 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00654_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    while b != 0 :\n        r = a % b\n        a , b = b , r\n    return a\nwhile True :\n    n = int ( input ( ) )\n    if n == 0 : break\n    even , odd = [ ] , [ ]\n    b = list ( map ( int , input ( ).split ( ) ) )\n    for i in b :\n        if i & 1 : odd.append ( i )\n        else : even.append ( i )\n    even.sort ( )\n    odd.sort ( )\n    e1 , e2 , o1 = even [ 0 ] , even [ 1 ] , odd [ 0 ] ;\n    g = gcd ( e1 , o1 )\n    e1 , o1 = e1 // g , o1 // g\n    g = gcd ( e2 , o1 )\n    e2 , o1 = e2 // g , o1 // g\n    g = int ( ( e1 * e2 ) ** 0.5 )\n    print ( g )\n    print ( * [ i // g for i in even ] )\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT while b != 0 : NEW_LINE INDENT r = a % b NEW_LINE a , b = b , r NEW_LINE DEDENT return a NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE even , odd = [ ] , [ ] NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in b : NEW_LINE INDENT if i & 1 : odd . append ( i ) NEW_LINE else : even . append ( i ) NEW_LINE DEDENT even . sort ( ) NEW_LINE odd . sort ( ) NEW_LINE e1 , e2 , o1 = even [ 0 ] , even [ 1 ] , odd [ 0 ] ; NEW_LINE g = gcd ( e1 , o1 ) NEW_LINE e1 , o1 = e1 // g , o1 // g NEW_LINE g = gcd ( e2 , o1 ) NEW_LINE e2 , o1 = e2 // g , o1 // g NEW_LINE g = int ( ( e1 * e2 ) ** 0.5 ) NEW_LINE print ( g ) NEW_LINE print ( * [ i // g for i in even ] ) NEW_LINE DEDENT"}
{"id": "codeforces_1097_B", "sol": 0, "python_code": "numb = int ( input ( ) )\nlst = [ ]\ni = 0\nwhile i < numb :\n    lst.append ( int ( input ( ) ) )\n    i += 1\nbin_lst = [ ]\ndef genbin ( n , bs = '' ) :\n    if n - 1 :\n        genbin ( n - 1 , bs + '0' )\n        genbin ( n - 1 , bs + '1' )\n    else :\n        bin_lst.append ( '1' + bs )\ngenbin ( numb )\nind = True\nfor i in range ( len ( bin_lst ) ) :\n    numb = 0\n    for j in range ( len ( bin_lst [ i ] ) ) :\n        if bin_lst [ i ] [ j ] == '1' :\n            numb += lst [ j ]\n        else :\n            numb -= lst [ j ]\n    if numb % 360 == 0 :\n        ind = False\n        print ( \"YES\" )\n        break\nif ind :\n    print ( \"NO\" )\n", "python_code_tokenized": "numb = int ( input ( ) ) NEW_LINE lst = [ ] NEW_LINE i = 0 NEW_LINE while i < numb : NEW_LINE INDENT lst . append ( int ( input ( ) ) ) NEW_LINE i += 1 NEW_LINE DEDENT bin_lst = [ ] NEW_LINE def genbin ( n , bs = ' ' ) : NEW_LINE INDENT if n - 1 : NEW_LINE INDENT genbin ( n - 1 , bs + '0' ) NEW_LINE genbin ( n - 1 , bs + '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT bin_lst . append ( '1' + bs ) NEW_LINE DEDENT DEDENT genbin ( numb ) NEW_LINE ind = True NEW_LINE for i in range ( len ( bin_lst ) ) : NEW_LINE INDENT numb = 0 NEW_LINE for j in range ( len ( bin_lst [ i ] ) ) : NEW_LINE INDENT if bin_lst [ i ] [ j ] == '1' : NEW_LINE INDENT numb += lst [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT numb -= lst [ j ] NEW_LINE DEDENT DEDENT if numb % 360 == 0 : NEW_LINE INDENT ind = False NEW_LINE print ( \" YES \" ) NEW_LINE break NEW_LINE DEDENT DEDENT if ind : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5079_A", "sol": 0, "python_code": "def getsum ( a ) :\n    r = 0\n    sum = 0\n    while ( a > 0 ) :\n        r = a % 10\n        sum = sum + r\n        a = a // 10\n    return sum\ndef value ( a , b , c ) :\n    x = 0\n    q = 0\n    w = 0\n    v = [ ]\n    for i in range ( 1 , 82 ) :\n        no = pow ( i , a )\n        no = b * no + c\n        if ( no > 0 and no < 1000000000 ) :\n            x = getsum ( no )\n            if ( x == i ) :\n                q += 1\n                v.append ( no )\n                w += 1\n    for i in range ( len ( v ) ) :\n        print ( v [ i ] , end = \" \" )\nif __name__ == \"__main__\" :\n    a = 2\n    b = 2\n    c = - 1\n    value ( a , b , c )\n", "python_code_tokenized": "def getsum ( a ) : NEW_LINE INDENT r = 0 NEW_LINE sum = 0 NEW_LINE while ( a > 0 ) : NEW_LINE INDENT r = a % 10 NEW_LINE sum = sum + r NEW_LINE a = a // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def value ( a , b , c ) : NEW_LINE INDENT x = 0 NEW_LINE q = 0 NEW_LINE w = 0 NEW_LINE v = [ ] NEW_LINE for i in range ( 1 , 82 ) : NEW_LINE INDENT no = pow ( i , a ) NEW_LINE no = b * no + c NEW_LINE if ( no > 0 and no < 1000000000 ) : NEW_LINE INDENT x = getsum ( no ) NEW_LINE if ( x == i ) : NEW_LINE INDENT q += 1 NEW_LINE v . append ( no ) NEW_LINE w += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT print ( v [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 2 NEW_LINE b = 2 NEW_LINE c = - 1 NEW_LINE value ( a , b , c ) NEW_LINE DEDENT"}
{"id": "codeforces_120_A", "sol": 0, "python_code": "import sys\nsys.stdin = open ( \"input.txt\" , \"r\" )\nsys.stdout = open ( \"output.txt\" , \"w\" )\na = input ( )\nt = int ( input ( ) )\nif a == \"front\" and t == 1 :\n    print ( \"L\" )\nelif t == 1 :\n    print ( \"R\" )\nelif a == \"front\" and t == 2 :\n    print ( \"R\" )\nelse :\n    print ( \"L\" )\n", "python_code_tokenized": "import sys NEW_LINE sys . stdin = open ( \" input . txt \" , \" r \" ) NEW_LINE sys . stdout = open ( \" output . txt \" , \" w \" ) NEW_LINE a = input ( ) NEW_LINE t = int ( input ( ) ) NEW_LINE if a == \" front \" and t == 1 : NEW_LINE INDENT print ( \" L \" ) NEW_LINE DEDENT elif t == 1 : NEW_LINE INDENT print ( \" R \" ) NEW_LINE DEDENT elif a == \" front \" and t == 2 : NEW_LINE INDENT print ( \" R \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" L \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4579_A", "sol": 0, "python_code": "def bubble_count ( arr , start , end ) :\n    count = 0 ;\n    for i in range ( start , end ) :\n        for j in range ( i + 1 , end ) :\n            if ( arr [ i ] > arr [ j ] ) :\n                count += 1 ;\n    return count ;\ndef inversion_count ( n , k , a ) :\n    count = 0 ;\n    for start in range ( 0 , n - k + 1 ) :\n        end = start + k ;\n        count += bubble_count ( a , start , end ) ;\n    return count ;\nif __name__ == '__main__' :\n    n = 10 ;\n    arr = [ 15 , 51 , 44 , 44 , 76 , 50 , 29 , 88 , 48 , 50 ] ;\n    k = 5 ;\n    result = inversion_count ( n , k , arr ) ;\n    print ( result ) ;\n", "python_code_tokenized": "def bubble_count ( arr , start , end ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT for j in range ( i + 1 , end ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT def inversion_count ( n , k , a ) : NEW_LINE INDENT count = 0 ; NEW_LINE for start in range ( 0 , n - k + 1 ) : NEW_LINE INDENT end = start + k ; NEW_LINE count += bubble_count ( a , start , end ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 ; NEW_LINE arr = [ 15 , 51 , 44 , 44 , 76 , 50 , 29 , 88 , 48 , 50 ] ; NEW_LINE k = 5 ; NEW_LINE result = inversion_count ( n , k , arr ) ; NEW_LINE print ( result ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_673_A", "sol": 0, "python_code": "def CheckArray ( arr , n ) :\n    prod = 1\n    for i in range ( 0 , n , 1 ) :\n        prod *= arr [ i ]\n    for i in range ( 0 , n , 1 ) :\n        if ( arr [ i ] == prod / arr [ i ] ) :\n            return True\n    return False\nif __name__ == '__main__' :\n    arr = [ 1 , 2 , 12 , 3 , 2 ]\n    n = len ( arr )\n    if ( CheckArray ( arr , n ) ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == prod / arr [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 12 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_579_A", "sol": 0, "python_code": "def kPresentProbability ( a , n , k ) :\n    count = a.count ( k )\n    return round ( count / n , 2 )\nif __name__ == \"__main__\" :\n    A = [ 4 , 7 , 2 , 0 , 8 , 7 , 5 ]\n    K = 2\n    N = len ( A )\n    print ( kPresentProbability ( A , N , K ) )\n", "python_code_tokenized": "def kPresentProbability ( a , n , k ) : NEW_LINE INDENT count = a . count ( k ) NEW_LINE return round ( count / n , 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 4 , 7 , 2 , 0 , 8 , 7 , 5 ] NEW_LINE K = 2 NEW_LINE N = len ( A ) NEW_LINE print ( kPresentProbability ( A , N , K ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1607_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    x , n = map ( int , input ( ).split ( ) )\n    q , r = divmod ( n - 1 , 4 )\n    r += 1\n    if x % 2 == 0 :\n        if r == 1 :\n            print ( x - 4 * q - r )\n        elif r == 2 :\n            print ( x + 1 )\n        elif r == 3 :\n            print ( x + 1 + 4 * q + r )\n        else :\n            print ( x )\n    else :\n        if r == 1 :\n            print ( x + 4 * q + r )\n        elif r == 2 :\n            print ( x - 1 )\n        elif r == 3 :\n            print ( x - 1 - 4 * q - r )\n        else :\n            print ( x )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x , n = map ( int , input ( ) . split ( ) ) NEW_LINE q , r = divmod ( n - 1 , 4 ) NEW_LINE r += 1 NEW_LINE if x % 2 == 0 : NEW_LINE INDENT if r == 1 : NEW_LINE INDENT print ( x - 4 * q - r ) NEW_LINE DEDENT elif r == 2 : NEW_LINE INDENT print ( x + 1 ) NEW_LINE DEDENT elif r == 3 : NEW_LINE INDENT print ( x + 1 + 4 * q + r ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if r == 1 : NEW_LINE INDENT print ( x + 4 * q + r ) NEW_LINE DEDENT elif r == 2 : NEW_LINE INDENT print ( x - 1 ) NEW_LINE DEDENT elif r == 3 : NEW_LINE INDENT print ( x - 1 - 4 * q - r ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "codeforces_1690_A", "sol": 0, "python_code": "import math\nt = eval ( input ( ) )\nfor i in range ( t ) :\n    n = eval ( input ( ) )\n    h1 = math.ceil ( n / 3 )\n    h2 = h1\n    h3 = h1\n    if n - ( h1 + h2 + h3 ) < 0 :\n        h3 -= ( h1 + h2 + h3 ) - n\n    elif n - ( h1 + h2 + h3 ) == 0 :\n        h1 += 1\n    if h1 == h2 :\n        h1 += 1\n        h2 -= 1\n    if h2 == h3 and ( h1 + h2 + h3 ) == n :\n        h2 += 1\n        h3 -= 1\n    elif h2 == h3 :\n        h3 -= ( h1 + h2 + h3 ) - n\n    print ( h2 , h1 , h3 )\n", "python_code_tokenized": "import math NEW_LINE t = eval ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = eval ( input ( ) ) NEW_LINE h1 = math . ceil ( n / 3 ) NEW_LINE h2 = h1 NEW_LINE h3 = h1 NEW_LINE if n - ( h1 + h2 + h3 ) < 0 : NEW_LINE INDENT h3 -= ( h1 + h2 + h3 ) - n NEW_LINE DEDENT elif n - ( h1 + h2 + h3 ) == 0 : NEW_LINE INDENT h1 += 1 NEW_LINE DEDENT if h1 == h2 : NEW_LINE INDENT h1 += 1 NEW_LINE h2 -= 1 NEW_LINE DEDENT if h2 == h3 and ( h1 + h2 + h3 ) == n : NEW_LINE INDENT h2 += 1 NEW_LINE h3 -= 1 NEW_LINE DEDENT elif h2 == h3 : NEW_LINE INDENT h3 -= ( h1 + h2 + h3 ) - n NEW_LINE DEDENT print ( h2 , h1 , h3 ) NEW_LINE DEDENT"}
{"id": "leetcode_852_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def peakIndexInMountainArray ( self , A ) :\n        lo , hi = 0 , len ( A ) - 1\n        while lo < hi :\n            mid = ( lo + hi ) / 2\n            if A [ mid ] < A [ mid + 1 ] :\n                lo = mid + 1\n            else :\n                hi = mid\n        return lo\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def peakIndexInMountainArray ( self , A ) : NEW_LINE INDENT lo , hi = 0 , len ( A ) - 1 NEW_LINE while lo < hi : NEW_LINE INDENT mid = ( lo + hi ) / 2 NEW_LINE if A [ mid ] < A [ mid + 1 ] : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid NEW_LINE DEDENT DEDENT return lo NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1593_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    n = input ( )\n    length = len ( n )\n    minval = 10000\n    for i in range ( length - 1 ) :\n        n1 = n [ i ]\n        for j in range ( i + 1 , length ) :\n            n2 = n [ j ]\n            if int ( n1 + n2 ) % 25 == 0 :\n                val = length - i - 2\n                if val < minval :\n                    minval = val\n    print ( minval )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = input ( ) NEW_LINE length = len ( n ) NEW_LINE minval = 10000 NEW_LINE for i in range ( length - 1 ) : NEW_LINE INDENT n1 = n [ i ] NEW_LINE for j in range ( i + 1 , length ) : NEW_LINE INDENT n2 = n [ j ] NEW_LINE if int ( n1 + n2 ) % 25 == 0 : NEW_LINE INDENT val = length - i - 2 NEW_LINE if val < minval : NEW_LINE INDENT minval = val NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( minval ) NEW_LINE DEDENT"}
{"id": "aizu_p01037_A", "sol": 0, "python_code": "N , M = map ( int , input ( ).split ( ) )\nL = [ 0 ] * ( N * 2 )\nfor i in range ( M ) :\n    a , l = map ( int , input ( ).split ( ) )\n    for ll in range ( a , a + l ) :\n        L [ ll ] = 1\nfor i in range ( N , 2 * N ) :\n    L [ i - N ] = max ( L [ i - N ] , L [ i ] )\nleft = 0\ni = 0\nwhile L [ i ] == 1 :\n    left += 1\n    i += 1\n    if i == N :\n        print ( N , 1 )\n        exit ( )\nA = [ ]\ns = 0\nfor i in range ( i , N ) :\n    li = L [ i ]\n    if li == 0 :\n        if s != 0 :\n            A.append ( s )\n        s = 0\n    else :\n        s += 1\nif s + left != 0 :\n    A.append ( s + left )\nA.sort ( reverse = True )\nv = A [ 0 ]\nn = 0\nfor a in A :\n    if a == v :\n        n += 1\n    else :\n        print ( v , n )\n        n = 1\n        v = a\nprint ( v , n )\n", "python_code_tokenized": "N , M = map ( int , input ( ) . split ( ) ) NEW_LINE L = [ 0 ] * ( N * 2 ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT a , l = map ( int , input ( ) . split ( ) ) NEW_LINE for ll in range ( a , a + l ) : NEW_LINE INDENT L [ ll ] = 1 NEW_LINE DEDENT DEDENT for i in range ( N , 2 * N ) : NEW_LINE INDENT L [ i - N ] = max ( L [ i - N ] , L [ i ] ) NEW_LINE DEDENT left = 0 NEW_LINE i = 0 NEW_LINE while L [ i ] == 1 : NEW_LINE INDENT left += 1 NEW_LINE i += 1 NEW_LINE if i == N : NEW_LINE INDENT print ( N , 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT A = [ ] NEW_LINE s = 0 NEW_LINE for i in range ( i , N ) : NEW_LINE INDENT li = L [ i ] NEW_LINE if li == 0 : NEW_LINE INDENT if s != 0 : NEW_LINE INDENT A . append ( s ) NEW_LINE DEDENT s = 0 NEW_LINE DEDENT else : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT if s + left != 0 : NEW_LINE INDENT A . append ( s + left ) NEW_LINE DEDENT A . sort ( reverse = True ) NEW_LINE v = A [ 0 ] NEW_LINE n = 0 NEW_LINE for a in A : NEW_LINE INDENT if a == v : NEW_LINE INDENT n += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( v , n ) NEW_LINE n = 1 NEW_LINE v = a NEW_LINE DEDENT DEDENT print ( v , n ) NEW_LINE"}
{"id": "geeksforgeeks_3482_A", "sol": 0, "python_code": "N = 4\ndef maxDecimalValue ( mat , i , j , p ) :\n    if i >= N or j >= N :\n        return 0\n    result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) )\n    if mat [ i ] [ j ] == 1 :\n        return pow ( 2 , p ) + result\n    else :\n        return result\nmat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 ] ]\nprint ( maxDecimalValue ( mat , 0 , 0 , 0 ) )\n", "python_code_tokenized": "N = 4 NEW_LINE def maxDecimalValue ( mat , i , j , p ) : NEW_LINE INDENT if i >= N or j >= N : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) NEW_LINE if mat [ i ] [ j ] == 1 : NEW_LINE INDENT return pow ( 2 , p ) + result NEW_LINE DEDENT else : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT mat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 ] ] NEW_LINE print ( maxDecimalValue ( mat , 0 , 0 , 0 ) ) NEW_LINE"}
{"id": "geeksforgeeks_3308_A", "sol": 0, "python_code": "N = 1000\ndp = [ - 1 ] * N\ndef minOperations ( k ) :\n    if ( k <= 0 or k >= 1000 ) :\n        return 1e9\n    if ( k == m ) :\n        return 0\n    dp [ k ] = dp [ k ]\n    if ( dp [ k ] != - 1 ) :\n        return dp [ k ]\n    dp [ k ] = 1e9\n    dp [ k ] = 1 + min ( minOperations ( 2 * k ) , minOperations ( k - 1 ) )\n    return dp [ k ]\nif __name__ == '__main__' :\n    n = 4\n    m = 6\n    print ( minOperations ( n ) )\n", "python_code_tokenized": "N = 1000 NEW_LINE dp = [ - 1 ] * N NEW_LINE def minOperations ( k ) : NEW_LINE INDENT if ( k <= 0 or k >= 1000 ) : NEW_LINE INDENT return 1e9 NEW_LINE DEDENT if ( k == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp [ k ] = dp [ k ] NEW_LINE if ( dp [ k ] != - 1 ) : NEW_LINE INDENT return dp [ k ] NEW_LINE DEDENT dp [ k ] = 1e9 NEW_LINE dp [ k ] = 1 + min ( minOperations ( 2 * k ) , minOperations ( k - 1 ) ) NEW_LINE return dp [ k ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE m = 6 NEW_LINE print ( minOperations ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2319_A", "sol": 0, "python_code": "ax = 5\nay = 0\nbx = 1\nby = 1\ncx = 2\ncy = 5\nprint ( ax + bx - cx , \", \" , ay + by - cy )\nprint ( ax + cx - bx , \", \" , ay + cy - by )\nprint ( cx + bx - ax , \", \" , cy + by - ax )\n", "python_code_tokenized": "ax = 5 NEW_LINE ay = 0 NEW_LINE bx = 1 NEW_LINE by = 1 NEW_LINE cx = 2 NEW_LINE cy = 5 NEW_LINE print ( ax + bx - cx , \" , \u2581 \" , ay + by - cy ) NEW_LINE print ( ax + cx - bx , \" , \u2581 \" , ay + cy - by ) NEW_LINE print ( cx + bx - ax , \" , \u2581 \" , cy + by - ax ) NEW_LINE"}
{"id": "codeforces_809_A", "sol": 0, "python_code": "mod = 1000000007\nn = int ( input ( ) )\nx = sorted ( list ( map ( int , input ( ).split ( ) ) ) )\ns = sum ( x )\np = [ ]\nj = 1\nfor i in range ( n + 1 ) :\n    p.append ( j )\n    j = ( j * 2 ) % mod\nd = 0\nfor i in range ( n ) :\n    d = ( d + ( x [ i ] * p [ i ] ) % mod ) % mod\n    d = ( d - ( x [ i ] * p [ n - i - 1 ] ) % mod ) % mod\nprint ( int ( d ) )\n", "python_code_tokenized": "mod = 1000000007 NEW_LINE n = int ( input ( ) ) NEW_LINE x = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE s = sum ( x ) NEW_LINE p = [ ] NEW_LINE j = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT p . append ( j ) NEW_LINE j = ( j * 2 ) % mod NEW_LINE DEDENT d = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d = ( d + ( x [ i ] * p [ i ] ) % mod ) % mod NEW_LINE d = ( d - ( x [ i ] * p [ n - i - 1 ] ) % mod ) % mod NEW_LINE DEDENT print ( int ( d ) ) NEW_LINE"}
{"id": "geeksforgeeks_1072_A", "sol": 0, "python_code": "MOD = 1000000007\ndef SieveOfEratosthenes ( prime , p_size ) :\n    prime [ 0 ] = False\n    prime [ 1 ] = False\n    for p in range ( 2 , p_size ) :\n        if ( prime [ p ] ) :\n            for i in range ( 2 * p , p_size , p ) :\n                prime [ i ] = False\ndef productPrimeFreq ( arr , n ) :\n    prime = [ True for i in range ( n + 1 ) ]\n    SieveOfEratosthenes ( prime , n + 1 )\n    i , j = 0 , 0\n    m = dict ( )\n    for i in range ( n ) :\n        m [ arr [ i ] ] = m.get ( arr [ i ] , 0 ) + 1\n    product = 1\n    for it in m :\n        if ( prime [ m [ it ] ] ) :\n            product *= it % MOD\n            product %= MOD\n    return product\narr = [ 5 , 4 , 6 , 5 , 4 , 6 ]\nn = len ( arr )\nprint ( productPrimeFreq ( arr , n ) )\n", "python_code_tokenized": "MOD = 1000000007 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , p_size , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def productPrimeFreq ( arr , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) NEW_LINE i , j = 0 , 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT product = 1 NEW_LINE for it in m : NEW_LINE INDENT if ( prime [ m [ it ] ] ) : NEW_LINE INDENT product *= it % MOD NEW_LINE product %= MOD NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productPrimeFreq ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3729_A", "sol": 0, "python_code": "from math import sqrt , gcd\ndef SieveOfEratosthenes ( prime , p_size ) :\n    prime [ 0 ] = False ;\n    prime [ 1 ] = False ;\n    for p in range ( 2 , int ( sqrt ( p_size ) ) + 1 ) :\n        if ( prime [ p ] ) :\n            for i in range ( 2 * p , p_size , p ) :\n                prime [ i ] = False ;\ndef gcdPrimeFreq ( arr , n ) :\n    prime = [ True ] * ( n + 1 ) ;\n    SieveOfEratosthenes ( prime , n + 1 ) ;\n    m = dict.fromkeys ( arr , 0 ) ;\n    for i in range ( n ) :\n        m [ arr [ i ] ] += 1 ;\n    __gcd = 0 ;\n    for key , value in m.items ( ) :\n        if ( prime [ value ] ) :\n            __gcd = gcd ( __gcd , key ) ;\n    return __gcd ;\nif __name__ == \"__main__\" :\n    arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] ;\n    n = len ( arr ) ;\n    print ( gcdPrimeFreq ( arr , n ) ) ;\n", "python_code_tokenized": "from math import sqrt , gcd NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , p_size , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def gcdPrimeFreq ( arr , n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) ; NEW_LINE m = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 ; NEW_LINE DEDENT __gcd = 0 ; NEW_LINE for key , value in m . items ( ) : NEW_LINE INDENT if ( prime [ value ] ) : NEW_LINE INDENT __gcd = gcd ( __gcd , key ) ; NEW_LINE DEDENT DEDENT return __gcd ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( gcdPrimeFreq ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3835_A", "sol": 0, "python_code": "import sys\ndef minimumX ( n , k ) :\n    mini = sys.maxsize\n    i = 1\n    while i * i <= n :\n        if ( n % i == 0 ) :\n            fir = i\n            sec = n // i\n            num1 = fir * k + sec\n            res = ( num1 // k ) * ( num1 % k )\n            if ( res == n ) :\n                mini = min ( num1 , mini )\n            num2 = sec * k + fir\n            res = ( num2 // k ) * ( num2 % k )\n            if ( res == n ) :\n                mini = min ( num2 , mini )\n        i += 1\n    return mini\nif __name__ == \"__main__\" :\n    n = 4\n    k = 6\n    print ( minimumX ( n , k ) )\n    n = 5\n    k = 5\n    print ( minimumX ( n , k ) )\n", "python_code_tokenized": "import sys NEW_LINE def minimumX ( n , k ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT fir = i NEW_LINE sec = n // i NEW_LINE num1 = fir * k + sec NEW_LINE res = ( num1 // k ) * ( num1 % k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num1 , mini ) NEW_LINE DEDENT num2 = sec * k + fir NEW_LINE res = ( num2 // k ) * ( num2 % k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num2 , mini ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return mini NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE k = 6 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE n = 5 NEW_LINE k = 5 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2167_A", "sol": 0, "python_code": "def findK ( n , k ) :\n    if ( n % 2 == 0 ) :\n        pos = n // 2 ;\n    else :\n        pos = ( n // 2 ) + 1 ;\n    if ( k <= pos ) :\n        return ( k * 2 - 1 ) ;\n    else :\n        return ( ( k - pos ) * 2 ) ;\ndef countSetBits ( n , k ) :\n    kth = findK ( n , k ) ;\n    return bin ( kth ).count ( '1' ) ;\nif __name__ == \"__main__\" :\n    n = 18 ; k = 12 ;\n    print ( countSetBits ( n , k ) ) ;\n", "python_code_tokenized": "def findK ( n , k ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT pos = n // 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT pos = ( n // 2 ) + 1 ; NEW_LINE DEDENT if ( k <= pos ) : NEW_LINE INDENT return ( k * 2 - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( k - pos ) * 2 ) ; NEW_LINE DEDENT DEDENT def countSetBits ( n , k ) : NEW_LINE INDENT kth = findK ( n , k ) ; NEW_LINE return bin ( kth ) . count ( '1' ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 18 ; k = 12 ; NEW_LINE print ( countSetBits ( n , k ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1286_A", "sol": 0, "python_code": "def longestSubseq ( s ) :\n    n = len ( s )\n    pre_count_0 = [ 0 for i in range ( n + 2 ) ]\n    pre_count_1 = [ 0 for i in range ( n + 1 ) ]\n    post_count_0 = [ 0 for i in range ( n + 2 ) ]\n    pre_count_0 [ 0 ] = 0\n    post_count_0 [ n + 1 ] = 0\n    pre_count_1 [ 0 ] = 0\n    for j in range ( 1 , n + 1 ) :\n        pre_count_0 [ j ] = pre_count_0 [ j - 1 ]\n        pre_count_1 [ j ] = pre_count_1 [ j - 1 ]\n        post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ]\n        if ( s [ j - 1 ] == '0' ) :\n            pre_count_0 [ j ] += 1\n        else :\n            pre_count_1 [ j ] += 1\n        if ( s [ n - j ] == '0' ) :\n            post_count_0 [ n - j + 1 ] += 1\n    if ( pre_count_0 [ n ] == n or pre_count_0 [ n ] == 0 ) :\n        return n\n    ans = 0\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( i , n + 1 , 1 ) :\n            ans = max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans )\n    return ans\nif __name__ == '__main__' :\n    s = \"000011100000\"\n    print ( longestSubseq ( s ) )\n", "python_code_tokenized": "def longestSubseq ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE pre_count_0 = [ 0 for i in range ( n + 2 ) ] NEW_LINE pre_count_1 = [ 0 for i in range ( n + 1 ) ] NEW_LINE post_count_0 = [ 0 for i in range ( n + 2 ) ] NEW_LINE pre_count_0 [ 0 ] = 0 NEW_LINE post_count_0 [ n + 1 ] = 0 NEW_LINE pre_count_1 [ 0 ] = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT pre_count_0 [ j ] = pre_count_0 [ j - 1 ] NEW_LINE pre_count_1 [ j ] = pre_count_1 [ j - 1 ] NEW_LINE post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] NEW_LINE if ( s [ j - 1 ] == '0' ) : NEW_LINE INDENT pre_count_0 [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre_count_1 [ j ] += 1 NEW_LINE DEDENT if ( s [ n - j ] == '0' ) : NEW_LINE INDENT post_count_0 [ n - j + 1 ] += 1 NEW_LINE DEDENT DEDENT if ( pre_count_0 [ n ] == n or pre_count_0 [ n ] == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 , 1 ) : NEW_LINE INDENT ans = max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"000011100000\" NEW_LINE print ( longestSubseq ( s ) ) NEW_LINE DEDENT"}
{"id": "aizu_p01872_A", "sol": 0, "python_code": "import array\ndef is_valid_number ( sequence ) :\n    q = lambda n : ( n + 1 ) if 1 <= n <= 6 else ( n - 5 )\n    sum_pq = 0\n    for index in range ( 1 , 12 ) :\n        sum_pq += sequence [ index ] * q ( index )\n    rem_pq = sum_pq % 11\n    check_digit = 0 if rem_pq <= 1 else ( 11 - rem_pq )\n    return sequence [ 0 ] == check_digit\ndef string2array ( st ) :\n    return array.array ( \"B\" , map ( int , st [ : : - 1 ] ) )\ndef solve ( s ) :\n    candidates = set ( )\n    for r in range ( 0 , 10 ) :\n        sequence = string2array ( s.replace ( \"?\" , str ( r ) ) )\n        if is_valid_number ( sequence ) :\n            candidates.add ( r )\n    if len ( candidates ) == 1 :\n        return candidates.pop ( )\n    else :\n        return - 1\ndef main ( ) :\n    answer = solve ( input ( ) )\n    print ( \"MULTIPLE\" if answer == - 1 else answer )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "import array NEW_LINE def is_valid_number ( sequence ) : NEW_LINE INDENT q = lambda n : ( n + 1 ) if 1 <= n <= 6 else ( n - 5 ) NEW_LINE sum_pq = 0 NEW_LINE for index in range ( 1 , 12 ) : NEW_LINE INDENT sum_pq += sequence [ index ] * q ( index ) NEW_LINE DEDENT rem_pq = sum_pq % 11 NEW_LINE check_digit = 0 if rem_pq <= 1 else ( 11 - rem_pq ) NEW_LINE return sequence [ 0 ] == check_digit NEW_LINE DEDENT def string2array ( st ) : NEW_LINE INDENT return array . array ( \" B \" , map ( int , st [ : : - 1 ] ) ) NEW_LINE DEDENT def solve ( s ) : NEW_LINE INDENT candidates = set ( ) NEW_LINE for r in range ( 0 , 10 ) : NEW_LINE INDENT sequence = string2array ( s . replace ( \" ? \" , str ( r ) ) ) NEW_LINE if is_valid_number ( sequence ) : NEW_LINE INDENT candidates . add ( r ) NEW_LINE DEDENT DEDENT if len ( candidates ) == 1 : NEW_LINE INDENT return candidates . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT answer = solve ( input ( ) ) NEW_LINE print ( \" MULTIPLE \" if answer == - 1 else answer ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3179_A", "sol": 0, "python_code": "def power ( x , y ) :\n    res = 1 ;\n    while ( y > 0 ) :\n        if ( y % 2 == 1 ) :\n            res = ( res * x ) ;\n        y = int ( y ) >> 1 ;\n        x = ( x * x ) ;\n    return res ;\ndef solve ( L ) :\n    n = L / 2 + 1 ;\n    ans = power ( n , n - 2 ) ;\n    return int ( ans ) ;\nL = 6 ;\nprint ( solve ( L ) ) ;\n", "python_code_tokenized": "def power ( x , y ) : NEW_LINE INDENT res = 1 ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) ; NEW_LINE DEDENT y = int ( y ) >> 1 ; NEW_LINE x = ( x * x ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def solve ( L ) : NEW_LINE INDENT n = L / 2 + 1 ; NEW_LINE ans = power ( n , n - 2 ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT L = 6 ; NEW_LINE print ( solve ( L ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_2548_A", "sol": 0, "python_code": "def findCart ( arr1 , arr2 , n , n1 ) :\n    for i in range ( 0 , n ) :\n        for j in range ( 0 , n1 ) :\n            print ( \"{\" , arr1 [ i ] , \", \" , arr2 [ j ] , \"}, \" , sep = \"\" , end = \"\" )\narr1 = [ 1 , 2 , 3 ]\narr2 = [ 4 , 5 , 6 ]\nn1 = len ( arr1 )\nn2 = len ( arr2 )\nfindCart ( arr1 , arr2 , n1 , n2 ) ;\n", "python_code_tokenized": "def findCart ( arr1 , arr2 , n , n1 ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n1 ) : NEW_LINE INDENT print ( \" { \" , arr1 [ i ] , \" , \u2581 \" , arr2 [ j ] , \" } , \u2581 \" , sep = \" \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 1 , 2 , 3 ] NEW_LINE arr2 = [ 4 , 5 , 6 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE findCart ( arr1 , arr2 , n1 , n2 ) ; NEW_LINE"}
{"id": "codeforces_137_B", "sol": 0, "python_code": "from sys import stdin\ninput = stdin.readline\nfrom collections import Counter\nn = int ( input ( ) ) ; arr = list ( map ( int , input ( ).split ( ) ) ) ; count = Counter ( arr ) ; dic = dict ( ) ; c = 0\nfor i in range ( 1 , 5001 ) :\n    dic [ i ] = 0\nfor i in count :\n    dic [ i ] = count [ i ]\nfor i in range ( 1 , n + 1 ) :\n    if dic [ i ] == 0 :\n        c += 1\nprint ( c )\n", "python_code_tokenized": "from sys import stdin NEW_LINE input = stdin . readline NEW_LINE from collections import Counter NEW_LINE n = int ( input ( ) ) ; arr = list ( map ( int , input ( ) . split ( ) ) ) ; count = Counter ( arr ) ; dic = dict ( ) ; c = 0 NEW_LINE for i in range ( 1 , 5001 ) : NEW_LINE INDENT dic [ i ] = 0 NEW_LINE DEDENT for i in count : NEW_LINE INDENT dic [ i ] = count [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if dic [ i ] == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE"}
{"id": "geeksforgeeks_1184_A", "sol": 0, "python_code": "def minCost ( arr , n ) :\n    cost = 999999 ;\n    XOR = 0 ;\n    for i in range ( 0 , n ) :\n        XOR ^= arr [ i ] ;\n    for i in range ( 0 , n ) :\n        if ( cost > abs ( ( XOR ^ arr [ i ] ) - arr [ i ] ) ) :\n            cost = abs ( ( XOR ^ arr [ i ] ) - arr [ i ] )\n            element = arr [ i ]\n    print ( \"Element = \" , element )\n    print ( \"Operation required = \" , abs ( cost ) )\narr = [ 2 , 8 , 4 , 16 ]\nn = len ( arr )\nminCost ( arr , n )\n", "python_code_tokenized": "def minCost ( arr , n ) : NEW_LINE INDENT cost = 999999 ; NEW_LINE XOR = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT XOR ^= arr [ i ] ; NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( cost > abs ( ( XOR ^ arr [ i ] ) - arr [ i ] ) ) : NEW_LINE INDENT cost = abs ( ( XOR ^ arr [ i ] ) - arr [ i ] ) NEW_LINE element = arr [ i ] NEW_LINE DEDENT DEDENT print ( \" Element \u2581 = \u2581 \" , element ) NEW_LINE print ( \" Operation \u2581 required \u2581 = \u2581 \" , abs ( cost ) ) NEW_LINE DEDENT arr = [ 2 , 8 , 4 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE minCost ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_4725_A", "sol": 0, "python_code": "def trailingZeroes ( n ) :\n    cnt = 0\n    while n > 0 :\n        n = int ( n / 5 )\n        cnt += n\n    return cnt\ndef binarySearch ( n ) :\n    low = 0\n    high = 1e6\n    while low < high :\n        mid = int ( ( low + high ) / 2 )\n        count = trailingZeroes ( mid )\n        if count < n :\n            low = mid + 1\n        else :\n            high = mid\n    result = list ( )\n    while trailingZeroes ( low ) == n :\n        result.append ( low )\n        low += 1\n    for i in range ( len ( result ) ) :\n        print ( result [ i ] , end = \" \" )\nn = 2\nbinarySearch ( n )\n", "python_code_tokenized": "def trailingZeroes ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n = int ( n / 5 ) NEW_LINE cnt += n NEW_LINE DEDENT return cnt NEW_LINE DEDENT def binarySearch ( n ) : NEW_LINE INDENT low = 0 NEW_LINE high = 1e6 NEW_LINE while low < high : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE count = trailingZeroes ( mid ) NEW_LINE if count < n : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT result = list ( ) NEW_LINE while trailingZeroes ( low ) == n : NEW_LINE INDENT result . append ( low ) NEW_LINE low += 1 NEW_LINE DEDENT for i in range ( len ( result ) ) : NEW_LINE INDENT print ( result [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT n = 2 NEW_LINE binarySearch ( n ) NEW_LINE"}
{"id": "geeksforgeeks_4980_A", "sol": 0, "python_code": "def printKDistinct ( arr , size , KthIndex ) :\n    dict = { }\n    vect = [ ]\n    for i in range ( size ) :\n        if ( arr [ i ] in dict ) :\n            dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1\n        else :\n            dict [ arr [ i ] ] = 1\n    for i in range ( size ) :\n        if ( dict [ arr [ i ] ] > 1 ) :\n            continue\n        else :\n            KthIndex = KthIndex - 1\n        if ( KthIndex == 0 ) :\n            return arr [ i ]\n    return - 1\narr = [ 1 , 2 , 1 , 3 , 4 , 2 ]\nsize = len ( arr )\nprint ( printKDistinct ( arr , size , 2 ) )\n", "python_code_tokenized": "def printKDistinct ( arr , size , KthIndex ) : NEW_LINE INDENT dict = { } NEW_LINE vect = [ ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] in dict ) : NEW_LINE INDENT dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( dict [ arr [ i ] ] > 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT KthIndex = KthIndex - 1 NEW_LINE DEDENT if ( KthIndex == 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 1 , 3 , 4 , 2 ] NEW_LINE size = len ( arr ) NEW_LINE print ( printKDistinct ( arr , size , 2 ) ) NEW_LINE"}
{"id": "geeksforgeeks_3304_A", "sol": 0, "python_code": "def partitions ( n ) :\n    p = [ 0 ] * ( n + 1 )\n    p [ 0 ] = 1\n    for i in range ( 1 , n + 1 ) :\n        k = 1\n        while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) :\n            p [ i ] += ( ( 1 if k % 2 else - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) // 2 ] )\n            if ( k > 0 ) :\n                k *= - 1\n            else :\n                k = 1 - k\n    return p [ n ]\nif __name__ == \"__main__\" :\n    N = 20\n    print ( partitions ( N ) )\n", "python_code_tokenized": "def partitions ( n ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) NEW_LINE p [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) : NEW_LINE INDENT p [ i ] += ( ( 1 if k % 2 else - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) // 2 ] ) NEW_LINE if ( k > 0 ) : NEW_LINE INDENT k *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 1 - k NEW_LINE DEDENT DEDENT DEDENT return p [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 20 NEW_LINE print ( partitions ( N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5149_A", "sol": 0, "python_code": "def isHeterogram ( s , n ) :\n    hash = [ 0 ] * 26\n    for i in range ( n ) :\n        if s [ i ] != ' ' :\n            if hash [ ord ( s [ i ] ) - ord ( 'a' ) ] == 0 :\n                hash [ ord ( s [ i ] ) - ord ( 'a' ) ] = 1\n            else :\n                return False\n    return True\ns = \"the big dwarf only jumps\"\nn = len ( s )\nprint ( \"YES\" if isHeterogram ( s , n ) else \"NO\" )\n", "python_code_tokenized": "def isHeterogram ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != ' \u2581 ' : NEW_LINE INDENT if hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT s = \" the \u2581 big \u2581 dwarf \u2581 only \u2581 jumps \" NEW_LINE n = len ( s ) NEW_LINE print ( \" YES \" if isHeterogram ( s , n ) else \" NO \" ) NEW_LINE"}
{"id": "geeksforgeeks_4511_A", "sol": 0, "python_code": "def swapBits ( x , p1 , p2 , n ) :\n    set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 )\n    set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 )\n    xor = ( set1 ^ set2 )\n    xor = ( xor << p1 ) | ( xor << p2 )\n    result = x ^ xor\n    return result\nres = swapBits ( 28 , 0 , 3 , 2 )\nprint ( \"Result =\" , res )\n", "python_code_tokenized": "def swapBits ( x , p1 , p2 , n ) : NEW_LINE INDENT set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) NEW_LINE set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) NEW_LINE xor = ( set1 ^ set2 ) NEW_LINE xor = ( xor << p1 ) | ( xor << p2 ) NEW_LINE result = x ^ xor NEW_LINE return result NEW_LINE DEDENT res = swapBits ( 28 , 0 , 3 , 2 ) NEW_LINE print ( \" Result \u2581 = \" , res ) NEW_LINE"}
{"id": "geeksforgeeks_4709_A", "sol": 0, "python_code": "def printSmallest ( a , n ) :\n    sum0 , sum1 = 0 , 0\n    a = sorted ( a )\n    for i in range ( n ) :\n        if ( a [ i ] % 3 == 0 ) :\n            return a [ i ]\n    for i in range ( n ) :\n        for j in range ( n ) :\n            num = ( a [ i ] * 10 ) + a [ j ]\n            if ( num % 3 == 0 ) :\n                return num\n    return a [ 0 ] * 100 + a [ 0 ] * 10 + a [ 0 ]\narr = [ 7 , 7 , 1 ]\nn = len ( arr )\nprint ( printSmallest ( arr , n ) )\n", "python_code_tokenized": "def printSmallest ( a , n ) : NEW_LINE INDENT sum0 , sum1 = 0 , 0 NEW_LINE a = sorted ( a ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 3 == 0 ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT num = ( a [ i ] * 10 ) + a [ j ] NEW_LINE if ( num % 3 == 0 ) : NEW_LINE INDENT return num NEW_LINE DEDENT DEDENT DEDENT return a [ 0 ] * 100 + a [ 0 ] * 10 + a [ 0 ] NEW_LINE DEDENT arr = [ 7 , 7 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( printSmallest ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_493_B", "sol": 0, "python_code": "def lex ( f , s ) :\n    for i in range ( len ( f ) ) :\n        if ( f [ i ] > s [ i ] ) :\n            return \"first\" ;\n        if ( s [ i ] > f [ i ] ) :\n            return \"second\"\n    if ( len ( f ) > len ( s ) ) :\n        return \"first\"\n    if ( len ( s ) > len ( f ) ) :\n        return 'second'\n    return - 1\nf = [ ]\ns = [ ]\ns1 = 0\ns2 = 0\nn = int ( input ( ) )\nlast = \"\"\nfor i in range ( n ) :\n    x = int ( input ( ) )\n    if ( x < 0 ) :\n        s1 += abs ( x )\n        s.append ( abs ( x ) )\n    else :\n        s2 += abs ( x )\n        f.append ( abs ( x ) )\n    if ( i == n - 1 ) :\n        if ( x < 0 ) :\n            last = 'second'\n        else :\n            last = 'first'\nif ( s1 < s2 ) :\n    print ( 'first' )\nelif s2 < s1 :\n    print ( 'second' )\nelse :\n    ans = lex ( f , s ) ;\n    if ( ans == - 1 ) :\n        print ( last )\n    else :\n        print ( ans )\n", "python_code_tokenized": "def lex ( f , s ) : NEW_LINE INDENT for i in range ( len ( f ) ) : NEW_LINE INDENT if ( f [ i ] > s [ i ] ) : NEW_LINE INDENT return \" first \" ; NEW_LINE DEDENT if ( s [ i ] > f [ i ] ) : NEW_LINE INDENT return \" second \" NEW_LINE DEDENT DEDENT if ( len ( f ) > len ( s ) ) : NEW_LINE INDENT return \" first \" NEW_LINE DEDENT if ( len ( s ) > len ( f ) ) : NEW_LINE INDENT return ' second ' NEW_LINE DEDENT return - 1 NEW_LINE DEDENT f = [ ] NEW_LINE s = [ ] NEW_LINE s1 = 0 NEW_LINE s2 = 0 NEW_LINE n = int ( input ( ) ) NEW_LINE last = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE if ( x < 0 ) : NEW_LINE INDENT s1 += abs ( x ) NEW_LINE s . append ( abs ( x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT s2 += abs ( x ) NEW_LINE f . append ( abs ( x ) ) NEW_LINE DEDENT if ( i == n - 1 ) : NEW_LINE INDENT if ( x < 0 ) : NEW_LINE INDENT last = ' second ' NEW_LINE DEDENT else : NEW_LINE INDENT last = ' first ' NEW_LINE DEDENT DEDENT DEDENT if ( s1 < s2 ) : NEW_LINE INDENT print ( ' first ' ) NEW_LINE DEDENT elif s2 < s1 : NEW_LINE INDENT print ( ' second ' ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = lex ( f , s ) ; NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( last ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4032_A", "sol": 0, "python_code": "def max_length_substring ( st , n , k ) :\n    max_len = 0\n    len = 0\n    for i in range ( 0 , n ) :\n        if ( st [ i ] == '0' ) :\n            len = len + 1 ;\n        else :\n            len = 0\n        max_len = max ( max_len , len )\n    if ( max_len == n ) :\n        return n * k\n    pref = 0\n    suff = 0\n    i = 0\n    while ( st [ i ] == '0' ) :\n        i = i + 1\n        pref = pref + 1\n    i = n - 1\n    while ( st [ i ] == '0' ) :\n        i = i - 1\n        suff = suff + 1\n    if ( k > 1 ) :\n        max_len = max ( max_len , pref + suff )\n    return max_len\nn = 6\nk = 3\nst = \"110010\"\nans = max_length_substring ( st , n , k )\nprint ( ans )\n", "python_code_tokenized": "def max_length_substring ( st , n , k ) : NEW_LINE INDENT max_len = 0 NEW_LINE len = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '0' ) : NEW_LINE INDENT len = len + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT len = 0 NEW_LINE DEDENT max_len = max ( max_len , len ) NEW_LINE DEDENT if ( max_len == n ) : NEW_LINE INDENT return n * k NEW_LINE DEDENT pref = 0 NEW_LINE suff = 0 NEW_LINE i = 0 NEW_LINE while ( st [ i ] == '0' ) : NEW_LINE INDENT i = i + 1 NEW_LINE pref = pref + 1 NEW_LINE DEDENT i = n - 1 NEW_LINE while ( st [ i ] == '0' ) : NEW_LINE INDENT i = i - 1 NEW_LINE suff = suff + 1 NEW_LINE DEDENT if ( k > 1 ) : NEW_LINE INDENT max_len = max ( max_len , pref + suff ) NEW_LINE DEDENT return max_len NEW_LINE DEDENT n = 6 NEW_LINE k = 3 NEW_LINE st = \"110010\" NEW_LINE ans = max_length_substring ( st , n , k ) NEW_LINE print ( ans ) NEW_LINE"}
{"id": "codeforces_376_A", "sol": 0, "python_code": "a = input ( )\np = a.index ( '^' )\nc = sum ( ( i - p ) * int ( y ) for i , y in enumerate ( a ) if y.isdigit ( ) )\nprint ( [ [ 'balance' , 'right' ] [ c > 0 ] , 'left' ] [ c < 0 ] )\n", "python_code_tokenized": "a = input ( ) NEW_LINE p = a . index ( ' ^ ' ) NEW_LINE c = sum ( ( i - p ) * int ( y ) for i , y in enumerate ( a ) if y . isdigit ( ) ) NEW_LINE print ( [ [ ' balance ' , ' right ' ] [ c > 0 ] , ' left ' ] [ c < 0 ] ) NEW_LINE"}
{"id": "leetcode_1337_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def kWeakestRows ( self , mat , k ) :\n        res = [ ]\n        num_row = len ( mat )\n        num_col = len ( mat [ 0 ] )\n        col = 0\n        flag = 1\n        while col < num_col and flag :\n            for i in range ( num_row ) :\n                if i in res :\n                    continue\n                if mat [ i ] [ col ] == 0 :\n                    res.append ( i )\n                if len ( res ) == k :\n                    flag = 0\n                    break\n            col += 1\n        if len ( res ) == k :\n            return res\n        for i in range ( num_row ) :\n            if i in res :\n                continue\n            res.append ( i )\n            if len ( res ) == k :\n                break\n        return res\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def kWeakestRows ( self , mat , k ) : NEW_LINE INDENT res = [ ] NEW_LINE num_row = len ( mat ) NEW_LINE num_col = len ( mat [ 0 ] ) NEW_LINE col = 0 NEW_LINE flag = 1 NEW_LINE while col < num_col and flag : NEW_LINE INDENT for i in range ( num_row ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT if mat [ i ] [ col ] == 0 : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT if len ( res ) == k : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT col += 1 NEW_LINE DEDENT if len ( res ) == k : NEW_LINE INDENT return res NEW_LINE DEDENT for i in range ( num_row ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT res . append ( i ) NEW_LINE if len ( res ) == k : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_5109_A", "sol": 0, "python_code": "def maxSum ( arr , n ) :\n    s = 0\n    l = [ ]\n    for i in range ( len ( a ) ) :\n        s += abs ( a [ i ] )\n        if ( a [ i ] >= 0 ) :\n            continue\n        if ( i == 0 ) :\n            l.append ( i + 1 )\n        else :\n            l.append ( i + 1 )\n            l.append ( i )\n    print ( s )\n    print ( * l )\nn = 4\na = [ 1 , - 2 , - 3 , 4 ]\nmaxSum ( a , n )\n", "python_code_tokenized": "def maxSum ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE l = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT s += abs ( a [ i ] ) NEW_LINE if ( a [ i ] >= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE l . append ( i ) NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE print ( * l ) NEW_LINE DEDENT n = 4 NEW_LINE a = [ 1 , - 2 , - 3 , 4 ] NEW_LINE maxSum ( a , n ) NEW_LINE"}
{"id": "atcoder_AGC037_E", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\ns = list ( input ( ) )\nl = 0\nc = 0\nfor i in range ( n ) :\n    if s [ i ] == min ( s ) :\n        c += 1\n        l = max ( l , c )\n    else :\n        c = 0\ns.reverse ( )\nif ( 2 ** ( k - 1 ) ) * l > n :\n    print ( min ( s ) * n )\nelse :\n    for i in range ( min ( k , 13 ) ) :\n        t = list ( reversed ( s ) )\n        u = t + s\n        uu = u [ : n ]\n        for j in range ( 1 , n + 1 ) :\n            x = u [ j : j + n ]\n            if uu > x :\n                uu = x\n        s = uu\n    print ( \"\".join ( s ) )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = list ( input ( ) ) NEW_LINE l = 0 NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == min ( s ) : NEW_LINE INDENT c += 1 NEW_LINE l = max ( l , c ) NEW_LINE DEDENT else : NEW_LINE INDENT c = 0 NEW_LINE DEDENT DEDENT s . reverse ( ) NEW_LINE if ( 2 ** ( k - 1 ) ) * l > n : NEW_LINE INDENT print ( min ( s ) * n ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( min ( k , 13 ) ) : NEW_LINE INDENT t = list ( reversed ( s ) ) NEW_LINE u = t + s NEW_LINE uu = u [ : n ] NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT x = u [ j : j + n ] NEW_LINE if uu > x : NEW_LINE INDENT uu = x NEW_LINE DEDENT DEDENT s = uu NEW_LINE DEDENT print ( \" \" . join ( s ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4877_A", "sol": 0, "python_code": "M = 4 ;\ndef maximumSum ( a , n ) :\n    global M ;\n    for i in range ( 0 , n ) :\n        a [ i ].sort ( ) ;\n    sum = a [ n - 1 ] [ M - 1 ] ;\n    prev = a [ n - 1 ] [ M - 1 ] ;\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        for j in range ( M - 1 , - 1 , - 1 ) :\n            if ( a [ i ] [ j ] < prev ) :\n                prev = a [ i ] [ j ] ;\n                sum += prev ;\n                break ;\n        if ( j == - 1 ) :\n            return 0 ;\n    return sum ;\narr = [ [ 1 , 7 , 3 , 4 ] , [ 4 , 2 , 5 , 1 ] , [ 9 , 5 , 1 , 8 ] ] ;\nn = len ( arr ) ;\nprint ( maximumSum ( arr , n ) ) ;\n", "python_code_tokenized": "M = 4 ; NEW_LINE def maximumSum ( a , n ) : NEW_LINE INDENT global M ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a [ i ] . sort ( ) ; NEW_LINE DEDENT sum = a [ n - 1 ] [ M - 1 ] ; NEW_LINE prev = a [ n - 1 ] [ M - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] [ j ] < prev ) : NEW_LINE INDENT prev = a [ i ] [ j ] ; NEW_LINE sum += prev ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( j == - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT arr = [ [ 1 , 7 , 3 , 4 ] , [ 4 , 2 , 5 , 1 ] , [ 9 , 5 , 1 , 8 ] ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maximumSum ( arr , n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_601_A", "sol": 0, "python_code": "import math\ndef findIndex ( n ) :\n    fibo = 2.078087 * math.log ( n ) + 1.672276\n    return round ( fibo )\nn = 21\nprint ( findIndex ( n ) )\n", "python_code_tokenized": "import math NEW_LINE def findIndex ( n ) : NEW_LINE INDENT fibo = 2.078087 * math . log ( n ) + 1.672276 NEW_LINE return round ( fibo ) NEW_LINE DEDENT n = 21 NEW_LINE print ( findIndex ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2257_A", "sol": 0, "python_code": "def isSubSeqDivisible ( str ) :\n    n = len ( str )\n    dp = [ [ 0 for i in range ( 10 ) ] for i in range ( n + 1 ) ]\n    arr = [ 0 for i in range ( n + 1 ) ]\n    for i in range ( 1 , n + 1 ) :\n        arr [ i ] = int ( str [ i - 1 ] ) ;\n    for i in range ( 1 , n + 1 ) :\n        dp [ i ] [ arr [ i ] % 8 ] = 1 ;\n        for j in range ( 8 ) :\n            if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) :\n                dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ]\n            if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) :\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j ]\n    for i in range ( 1 , n + 1 ) :\n        if ( dp [ i ] [ 0 ] == 1 ) :\n            return True\n    return False\nstr = \"3144\"\nif ( isSubSeqDivisible ( str ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def isSubSeqDivisible ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( 10 ) ] for i in range ( n + 1 ) ] NEW_LINE arr = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] = int ( str [ i - 1 ] ) ; NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i ] % 8 ] = 1 ; NEW_LINE for j in range ( 8 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) : NEW_LINE INDENT dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( dp [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT str = \"3144\" NEW_LINE if ( isSubSeqDivisible ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "aizu_p00948_A", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\na = { }\nfor i in range ( m ) :\n    b , c = map ( int , input ( ).split ( ) )\n    a [ i ] = ( b , c - 1 )\na = sorted ( a.items ( ) , key = lambda x : x [ 1 ] )\nb = [ 0 ] * ( n + 1 ) ; c = [ 0 ] * ( n + 1 )\nfor i in range ( n ) : b [ i ] = c [ i ] = i\nfor i in range ( m ) :\n    x = a [ i ] [ 1 ] [ 1 ]\n    b [ x ] = max ( b [ x ] , b [ x + 1 ] )\n    c [ x + 1 ] = min ( c [ x ] , c [ x + 1 ] )\nprint ( * [ b [ i ] - c [ i ] + 1 for i in range ( n ) ] )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = { } NEW_LINE for i in range ( m ) : NEW_LINE INDENT b , c = map ( int , input ( ) . split ( ) ) NEW_LINE a [ i ] = ( b , c - 1 ) NEW_LINE DEDENT a = sorted ( a . items ( ) , key = lambda x : x [ 1 ] ) NEW_LINE b = [ 0 ] * ( n + 1 ) ; c = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : b [ i ] = c [ i ] = i NEW_LINE for i in range ( m ) : NEW_LINE INDENT x = a [ i ] [ 1 ] [ 1 ] NEW_LINE b [ x ] = max ( b [ x ] , b [ x + 1 ] ) NEW_LINE c [ x + 1 ] = min ( c [ x ] , c [ x + 1 ] ) NEW_LINE DEDENT print ( * [ b [ i ] - c [ i ] + 1 for i in range ( n ) ] ) NEW_LINE"}
{"id": "aizu_p00429_A", "sol": 0, "python_code": "def convert ( s ) :\n    convertStr = \"\"\n    l = len ( s )\n    i = 0\n    while i < l :\n        if i + 1 < l :\n            word = s [ i ]\n            sequenceNum = 1\n            j = i + 1\n            while j < l :\n                if ( word == s [ j ] ) :\n                    sequenceNum += 1\n                else :\n                    break\n                j += 1\n            convertStr += str ( sequenceNum ) + word\n            i = i + sequenceNum - 1\n        else :\n            convertStr += \"1\" + str ( s [ i ] )\n        i += 1\n    return convertStr\nwhile True :\n    try :\n        n = int ( input ( ) )\n        s = input ( )\n        for i in range ( 0 , n ) :\n            s = convert ( s )\n        print ( s )\n    except :\n        break\n", "python_code_tokenized": "def convert ( s ) : NEW_LINE INDENT convertStr = \" \" NEW_LINE l = len ( s ) NEW_LINE i = 0 NEW_LINE while i < l : NEW_LINE INDENT if i + 1 < l : NEW_LINE INDENT word = s [ i ] NEW_LINE sequenceNum = 1 NEW_LINE j = i + 1 NEW_LINE while j < l : NEW_LINE INDENT if ( word == s [ j ] ) : NEW_LINE INDENT sequenceNum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT convertStr += str ( sequenceNum ) + word NEW_LINE i = i + sequenceNum - 1 NEW_LINE DEDENT else : NEW_LINE INDENT convertStr += \"1\" + str ( s [ i ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return convertStr NEW_LINE DEDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s = convert ( s ) NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1451_A", "sol": 0, "python_code": "def maxElement ( a , n ) :\n    if n < 3 :\n        return - 1\n    maxElement = a [ 0 ]\n    maxProd = a [ n - 1 ] * a [ 1 ]\n    for i in range ( 1 , n ) :\n        currprod = a [ i - 1 ] * a [ ( i + 1 ) % n ]\n        if currprod > maxProd :\n            maxProd = currprod\n            maxElement = a [ i ]\n        elif currprod == maxProd :\n            maxElement = max ( maxElement , a [ i ] )\n    return maxElement\na = [ 5 , 6 , 4 , 3 , 2 ]\nn = len ( a )\nprint ( maxElement ( a , n ) )\n", "python_code_tokenized": "def maxElement ( a , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT maxElement = a [ 0 ] NEW_LINE maxProd = a [ n - 1 ] * a [ 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currprod = a [ i - 1 ] * a [ ( i + 1 ) % n ] NEW_LINE if currprod > maxProd : NEW_LINE INDENT maxProd = currprod NEW_LINE maxElement = a [ i ] NEW_LINE DEDENT elif currprod == maxProd : NEW_LINE INDENT maxElement = max ( maxElement , a [ i ] ) NEW_LINE DEDENT DEDENT return maxElement NEW_LINE DEDENT a = [ 5 , 6 , 4 , 3 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( maxElement ( a , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3479_A", "sol": 0, "python_code": "SIZE = 10\nINT_MIN = - 10000000\ndef maxSum ( mat , n ) :\n    if n == 1 :\n        return mat [ 0 ] [ 0 ]\n    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    maxSum = INT_MIN\n    for j in range ( n ) :\n        dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        for j in range ( n ) :\n            maxi = INT_MIN\n            if ( ( ( ( j - 1 ) >= 0 ) and ( maxi < dp [ i + 1 ] [ j - 1 ] ) ) ) :\n                maxi = dp [ i + 1 ] [ j - 1 ]\n            if ( ( ( ( j + 1 ) < n ) and ( maxi < dp [ i + 1 ] [ j + 1 ] ) ) ) :\n                maxi = dp [ i + 1 ] [ j + 1 ]\n            dp [ i ] [ j ] = mat [ i ] [ j ] + maxi\n    for j in range ( n ) :\n        if ( maxSum < dp [ 0 ] [ j ] ) :\n            maxSum = dp [ 0 ] [ j ]\n    return maxSum\nif __name__ == '__main__' :\n    mat = [ [ 5 , 6 , 1 , 7 ] , [ - 2 , 10 , 8 , - 1 ] , [ 3 , - 7 , - 9 , 11 ] , [ 12 , - 4 , 2 , 6 ] ]\n    n = 4\n    print ( \"Maximum Sum=\" , maxSum ( mat , n ) )\n", "python_code_tokenized": "SIZE = 10 NEW_LINE INT_MIN = - 10000000 NEW_LINE def maxSum ( mat , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return mat [ 0 ] [ 0 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE maxSum = INT_MIN NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT maxi = INT_MIN NEW_LINE if ( ( ( ( j - 1 ) >= 0 ) and ( maxi < dp [ i + 1 ] [ j - 1 ] ) ) ) : NEW_LINE INDENT maxi = dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT if ( ( ( ( j + 1 ) < n ) and ( maxi < dp [ i + 1 ] [ j + 1 ] ) ) ) : NEW_LINE INDENT maxi = dp [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT dp [ i ] [ j ] = mat [ i ] [ j ] + maxi NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT if ( maxSum < dp [ 0 ] [ j ] ) : NEW_LINE INDENT maxSum = dp [ 0 ] [ j ] NEW_LINE DEDENT DEDENT return maxSum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 5 , 6 , 1 , 7 ] , [ - 2 , 10 , 8 , - 1 ] , [ 3 , - 7 , - 9 , 11 ] , [ 12 , - 4 , 2 , 6 ] ] NEW_LINE n = 4 NEW_LINE print ( \" Maximum \u2581 Sum = \" , maxSum ( mat , n ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02284_A", "sol": 0, "python_code": "import sys\nclass Node :\n    __slots__ = [ 'key' , 'left' , 'right' ]\n    def __init__ ( self , key ) :\n        self.key = key\n        self.left = self.right = None\nroot = None\ndef insert ( key ) :\n    global root\n    x , y = root , None\n    while x != None : x , y = x.left if key < x.key else x.right , x\n    if y == None : root = Node ( key )\n    elif key < y.key : y.left = Node ( key )\n    else : y.right = Node ( key )\ndef find ( target ) :\n    result = root\n    while result and target != result.key :\n        result = result.left if target < result.key else result.right\n    return result != None\ndef inorder ( node ) :\n    return inorder ( node.left ) + f' {node.key}' + inorder ( node.right ) if node else ''\ndef preorder ( node ) :\n    return f' {node.key}' + preorder ( node.left ) + preorder ( node.right ) if node else ''\ninput ( )\nfor e in sys.stdin :\n    if e [ 0 ] == 'i' : insert ( int ( e [ 7 : ] ) )\n    elif e [ 0 ] == 'f' : print ( [ 'no' , 'yes' ] [ find ( int ( e [ 5 : ] ) ) ] )\n    else : print ( inorder ( root ) ) ; print ( preorder ( root ) )\n", "python_code_tokenized": "import sys NEW_LINE class Node : NEW_LINE INDENT __slots__ = [ ' key ' , ' left ' , ' right ' ] NEW_LINE def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT root = None NEW_LINE def insert ( key ) : NEW_LINE INDENT global root NEW_LINE x , y = root , None NEW_LINE while x != None : x , y = x . left if key < x . key else x . right , x NEW_LINE if y == None : root = Node ( key ) NEW_LINE elif key < y . key : y . left = Node ( key ) NEW_LINE else : y . right = Node ( key ) NEW_LINE DEDENT def find ( target ) : NEW_LINE INDENT result = root NEW_LINE while result and target != result . key : NEW_LINE INDENT result = result . left if target < result . key else result . right NEW_LINE DEDENT return result != None NEW_LINE DEDENT def inorder ( node ) : NEW_LINE INDENT return inorder ( node . left ) + f ' \u2581 { node . key } ' + inorder ( node . right ) if node else ' ' NEW_LINE DEDENT def preorder ( node ) : NEW_LINE INDENT return f ' \u2581 { node . key } ' + preorder ( node . left ) + preorder ( node . right ) if node else ' ' NEW_LINE DEDENT input ( ) NEW_LINE for e in sys . stdin : NEW_LINE INDENT if e [ 0 ] == ' i ' : insert ( int ( e [ 7 : ] ) ) NEW_LINE elif e [ 0 ] == ' f ' : print ( [ ' no ' , ' yes ' ] [ find ( int ( e [ 5 : ] ) ) ] ) NEW_LINE else : print ( inorder ( root ) ) ; print ( preorder ( root ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3745_A", "sol": 0, "python_code": "def TwentyoneMatchstick ( arr , N ) :\n    for i in range ( N ) :\n        print ( 5 - arr [ i ] , end = \" \" )\narr = [ 3 , 4 , 2 , 2 ]\nN = len ( arr )\nTwentyoneMatchstick ( arr , N )\n", "python_code_tokenized": "def TwentyoneMatchstick ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( 5 - arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE TwentyoneMatchstick ( arr , N ) NEW_LINE"}
{"id": "geeksforgeeks_1514_A", "sol": 0, "python_code": "def findOptimalSolution ( a , N ) :\n    a.sort ( )\n    points = 0\n    for i in range ( 0 , N ) :\n        points += a [ i ] * i\n    return points\nif __name__ == \"__main__\" :\n    a = [ 1 , 4 , 2 , 3 , 9 ]\n    N = len ( a )\n    print ( findOptimalSolution ( a , N ) )\n", "python_code_tokenized": "def findOptimalSolution ( a , N ) : NEW_LINE INDENT a . sort ( ) NEW_LINE points = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT points += a [ i ] * i NEW_LINE DEDENT return points NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 2 , 3 , 9 ] NEW_LINE N = len ( a ) NEW_LINE print ( findOptimalSolution ( a , N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_813_A", "sol": 0, "python_code": "MAX = 1000000000 ;\ndef findTriangle ( S ) :\n    X1 = 0 ; Y1 = 0 ;\n    X2 = MAX ; Y2 = 1 ;\n    X3 = ( MAX - S % MAX ) % MAX ;\n    Y3 = ( S + X3 ) / MAX ;\n    print ( \"(\" , X1 , \",\" , Y1 , \")\" ) ;\n    print ( \"(\" , X2 , \",\" , Y2 , \")\" ) ;\n    print ( \"(\" , X3 , \",\" , Y3 , \")\" ) ;\nif __name__ == \"__main__\" :\n    S = 4 ;\n    findTriangle ( S ) ;\n", "python_code_tokenized": "MAX = 1000000000 ; NEW_LINE def findTriangle ( S ) : NEW_LINE INDENT X1 = 0 ; Y1 = 0 ; NEW_LINE X2 = MAX ; Y2 = 1 ; NEW_LINE X3 = ( MAX - S % MAX ) % MAX ; NEW_LINE Y3 = ( S + X3 ) / MAX ; NEW_LINE print ( \" ( \" , X1 , \" , \" , Y1 , \" ) \" ) ; NEW_LINE print ( \" ( \" , X2 , \" , \" , Y2 , \" ) \" ) ; NEW_LINE print ( \" ( \" , X3 , \" , \" , Y3 , \" ) \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = 4 ; NEW_LINE findTriangle ( S ) ; NEW_LINE DEDENT"}
{"id": "projecteuler_p109_A", "sol": 0, "python_code": "def compute ( ) :\n    points = [ i * j for i in range ( 1 , 21 ) for j in range ( 1 , 4 ) ] + [ 25 , 50 ]\n    doublepoints = [ i * 2 for i in range ( 1 , 21 ) ] + [ 25 * 2 ]\n    ways = [ [ [ None ] * len ( points ) for j in range ( 101 ) ] for i in range ( 3 ) ]\n    def calc_ways ( throws , total , maxindex ) :\n        if ways [ throws ] [ total ] [ maxindex ] is None :\n            if throws == 0 :\n                result = 1 if total == 0 else 0\n            else :\n                result = 0\n                if maxindex > 0 :\n                    result += calc_ways ( throws , total , maxindex - 1 )\n                if points [ maxindex ] <= total :\n                    result += calc_ways ( throws - 1 , total - points [ maxindex ] , maxindex )\n            ways [ throws ] [ total ] [ maxindex ] = result\n        return ways [ throws ] [ total ] [ maxindex ]\n    checkouts = 0\n    for remainingpoints in range ( 1 , 100 ) :\n        for throws in range ( 3 ) :\n            for p in doublepoints :\n                if p <= remainingpoints :\n                    checkouts += calc_ways ( throws , remainingpoints - p , len ( points ) - 1 )\n    return str ( checkouts )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT points = [ i * j for i in range ( 1 , 21 ) for j in range ( 1 , 4 ) ] + [ 25 , 50 ] NEW_LINE doublepoints = [ i * 2 for i in range ( 1 , 21 ) ] + [ 25 * 2 ] NEW_LINE ways = [ [ [ None ] * len ( points ) for j in range ( 101 ) ] for i in range ( 3 ) ] NEW_LINE def calc_ways ( throws , total , maxindex ) : NEW_LINE INDENT if ways [ throws ] [ total ] [ maxindex ] is None : NEW_LINE INDENT if throws == 0 : NEW_LINE INDENT result = 1 if total == 0 else 0 NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE if maxindex > 0 : NEW_LINE INDENT result += calc_ways ( throws , total , maxindex - 1 ) NEW_LINE DEDENT if points [ maxindex ] <= total : NEW_LINE INDENT result += calc_ways ( throws - 1 , total - points [ maxindex ] , maxindex ) NEW_LINE DEDENT DEDENT ways [ throws ] [ total ] [ maxindex ] = result NEW_LINE DEDENT return ways [ throws ] [ total ] [ maxindex ] NEW_LINE DEDENT checkouts = 0 NEW_LINE for remainingpoints in range ( 1 , 100 ) : NEW_LINE INDENT for throws in range ( 3 ) : NEW_LINE INDENT for p in doublepoints : NEW_LINE INDENT if p <= remainingpoints : NEW_LINE INDENT checkouts += calc_ways ( throws , remainingpoints - p , len ( points ) - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return str ( checkouts ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1936_A", "sol": 0, "python_code": "def binary_conversion ( s , m ) :\n    while ( m ) :\n        temp = m % 2\n        s += str ( temp )\n        m = m // 2\n    return s [ : : - 1 ]\ndef find_character ( n , m , i ) :\n    s = \"\"\n    s = binary_conversion ( s , m )\n    s1 = \"\"\n    for x in range ( n ) :\n        for j in range ( len ( s ) ) :\n            if s [ j ] == \"1\" :\n                s1 += \"10\"\n            else :\n                s1 += \"01\"\n        s = s1\n        s1 = \"\"\n    e = ord ( s [ i ] )\n    r = ord ( '0' )\n    return e - r\nm , n , i = 5 , 2 , 8\nprint ( find_character ( n , m , i ) )\n", "python_code_tokenized": "def binary_conversion ( s , m ) : NEW_LINE INDENT while ( m ) : NEW_LINE INDENT temp = m % 2 NEW_LINE s += str ( temp ) NEW_LINE m = m // 2 NEW_LINE DEDENT return s [ : : - 1 ] NEW_LINE DEDENT def find_character ( n , m , i ) : NEW_LINE INDENT s = \" \" NEW_LINE s = binary_conversion ( s , m ) NEW_LINE s1 = \" \" NEW_LINE for x in range ( n ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT if s [ j ] == \"1\" : NEW_LINE INDENT s1 += \"10\" NEW_LINE DEDENT else : NEW_LINE INDENT s1 += \"01\" NEW_LINE DEDENT DEDENT s = s1 NEW_LINE s1 = \" \" NEW_LINE DEDENT e = ord ( s [ i ] ) NEW_LINE r = ord ( '0' ) NEW_LINE return e - r NEW_LINE DEDENT m , n , i = 5 , 2 , 8 NEW_LINE print ( find_character ( n , m , i ) ) NEW_LINE"}
{"id": "codeforces_1721_B", "sol": 0, "python_code": "n = int ( input ( ) )\nfor i in range ( n ) :\n    n , m , sx , sy , d = str ( input ( ) ).split ( )\n    n , m , sx , sy , d = int ( n ) , int ( m ) , int ( sx ) , int ( sy ) , int ( d )\n    pos1 , pos2 , pos3 , pos4 = sx - d , sx + d , sy - d , sy + d\n    if min ( sx - 1 , m - sy ) <= d and min ( n - sx , sy - 1 ) <= d :\n        print ( - 1 )\n    else :\n        print ( n - 1 + m - 1 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT n , m , sx , sy , d = str ( input ( ) ) . split ( ) NEW_LINE n , m , sx , sy , d = int ( n ) , int ( m ) , int ( sx ) , int ( sy ) , int ( d ) NEW_LINE pos1 , pos2 , pos3 , pos4 = sx - d , sx + d , sy - d , sy + d NEW_LINE if min ( sx - 1 , m - sy ) <= d and min ( n - sx , sy - 1 ) <= d : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - 1 + m - 1 ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2853_A", "sol": 0, "python_code": "def solveEven ( s ) :\n    if len ( s ) % 2 == 1 :\n        return 2\n    ls = s [ 0 : len ( s ) // 2 ]\n    rs = s [ len ( s ) // 2 : len ( s ) ]\n    if ls != rs :\n        return 1\n    return solveEven ( ls )\ndef solveOdd ( s ) :\n    return 2\ndef solve ( s ) :\n    if len ( s ) <= 3 :\n        return - 1\n    cnt = [ 0 ] * 25\n    for i in range ( 0 , len ( s ) ) :\n        cnt [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1\n    if max ( cnt ) >= len ( s ) - 1 :\n        return - 1\n    if len ( s ) % 2 == 0 :\n        return solveEven ( s )\n    if len ( s ) % 2 == 1 :\n        return solveOdd ( s )\nif __name__ == \"__main__\" :\n    s = \"nolon\"\n    print ( solve ( s ) )\n", "python_code_tokenized": "def solveEven ( s ) : NEW_LINE INDENT if len ( s ) % 2 == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT ls = s [ 0 : len ( s ) // 2 ] NEW_LINE rs = s [ len ( s ) // 2 : len ( s ) ] NEW_LINE if ls != rs : NEW_LINE INDENT return 1 NEW_LINE DEDENT return solveEven ( ls ) NEW_LINE DEDENT def solveOdd ( s ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT def solve ( s ) : NEW_LINE INDENT if len ( s ) <= 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT cnt = [ 0 ] * 25 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if max ( cnt ) >= len ( s ) - 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if len ( s ) % 2 == 0 : NEW_LINE INDENT return solveEven ( s ) NEW_LINE DEDENT if len ( s ) % 2 == 1 : NEW_LINE INDENT return solveOdd ( s ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" nolon \" NEW_LINE print ( solve ( s ) ) NEW_LINE DEDENT"}
{"id": "codeforces_549_A", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\na = [ ]\nfor i in range ( n ) :\n    x = [ i for i in input ( ) ]\n    a.append ( x )\ncount = 0\nfor j in range ( m - 1 ) :\n    for i in range ( n - 1 ) :\n        x = set ( [ a [ i ] [ j ] , a [ i + 1 ] [ j ] , a [ i ] [ j + 1 ] , a [ i + 1 ] [ j + 1 ] ] )\n        if x == { 'a' , 'f' , 'c' , 'e' } :\n            count += 1\nprint ( count )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = [ i for i in input ( ) ] NEW_LINE a . append ( x ) NEW_LINE DEDENT count = 0 NEW_LINE for j in range ( m - 1 ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT x = set ( [ a [ i ] [ j ] , a [ i + 1 ] [ j ] , a [ i ] [ j + 1 ] , a [ i + 1 ] [ j + 1 ] ] ) NEW_LINE if x == { ' a ' , ' f ' , ' c ' , ' e ' } : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE"}
{"id": "geeksforgeeks_3518_A", "sol": 0, "python_code": "def nthPalindrome ( n , k ) :\n    if ( k & 1 ) :\n        temp = k // 2\n    else :\n        temp = k // 2 - 1\n    palindrome = 10 ** temp\n    palindrome = palindrome + n - 1\n    print ( palindrome , end = \"\" )\n    if ( k & 1 ) :\n        palindrome = palindrome // 10\n    while ( palindrome ) :\n        print ( palindrome % 10 , end = \"\" )\n        palindrome = palindrome // 10\nif __name__ == '__main__' :\n    n = 6\n    k = 5\n    print ( n , \"th palindrome of\" , k , \" digit = \" , end = \" \" )\n    nthPalindrome ( n , k )\n    print ( )\n    n = 10\n    k = 6\n    print ( n , \"th palindrome of\" , k , \"digit = \" , end = \" \" )\n    nthPalindrome ( n , k )\n", "python_code_tokenized": "def nthPalindrome ( n , k ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT temp = k // 2 NEW_LINE DEDENT else : NEW_LINE INDENT temp = k // 2 - 1 NEW_LINE DEDENT palindrome = 10 ** temp NEW_LINE palindrome = palindrome + n - 1 NEW_LINE print ( palindrome , end = \" \" ) NEW_LINE if ( k & 1 ) : NEW_LINE INDENT palindrome = palindrome // 10 NEW_LINE DEDENT while ( palindrome ) : NEW_LINE INDENT print ( palindrome % 10 , end = \" \" ) NEW_LINE palindrome = palindrome // 10 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE k = 5 NEW_LINE print ( n , \" th \u2581 palindrome \u2581 of \" , k , \" \u2581 digit \u2581 = \u2581 \" , end = \" \u2581 \" ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE print ( ) NEW_LINE n = 10 NEW_LINE k = 6 NEW_LINE print ( n , \" th \u2581 palindrome \u2581 of \" , k , \" digit \u2581 = \u2581 \" , end = \" \u2581 \" ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3785_A", "sol": 0, "python_code": "def min_changes ( a , n ) :\n    ans_a = 0 ;\n    ans_b = 0 ;\n    for i in range ( n ) :\n        if ( i % 2 == 0 ) :\n            if ( a [ i ] == 0 ) :\n                ans_a += 1 ;\n            else :\n                ans_b += 1 ;\n        else :\n            if ( a [ i ] == 0 ) :\n                ans_b += 1 ;\n            else :\n                ans_a += 1 ;\n    return min ( ans_a , ans_b ) ;\nif __name__ == '__main__' :\n    a = [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;\n    n = len ( a ) ;\n    print ( min_changes ( a , n ) ) ;\n", "python_code_tokenized": "def min_changes ( a , n ) : NEW_LINE INDENT ans_a = 0 ; NEW_LINE ans_b = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT ans_a += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans_b += 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT ans_b += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans_a += 1 ; NEW_LINE DEDENT DEDENT DEDENT return min ( ans_a , ans_b ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( min_changes ( a , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_588_A", "sol": 0, "python_code": "n = 3\nMAX = 60\ndp = [ [ [ 0 for i in range ( 30 ) ] for i in range ( 30 ) ] for i in range ( MAX + 1 ) ]\nv = [ [ [ 0 for i in range ( 30 ) ] for i in range ( 30 ) ] for i in range ( MAX + 1 ) ]\ndef findCount ( mat , i , j , m ) :\n    if ( i == 0 and j == 0 ) :\n        if ( m == mat [ 0 ] [ 0 ] ) :\n            return 1\n        else :\n            return 0\n    if ( m < 0 ) :\n        return 0\n    if ( i < 0 or j < 0 ) :\n        return 0\n    if ( v [ i ] [ j ] [ m ] > 0 ) :\n        return dp [ i ] [ j ] [ m ]\n    v [ i ] [ j ] [ m ] = True\n    dp [ i ] [ j ] [ m ] = ( findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) )\n    return dp [ i ] [ j ] [ m ]\nmat = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ]\nm = 5\nprint ( findCount ( mat , n - 1 , n - 1 , m ) )\n", "python_code_tokenized": "n = 3 NEW_LINE MAX = 60 NEW_LINE dp = [ [ [ 0 for i in range ( 30 ) ] for i in range ( 30 ) ] for i in range ( MAX + 1 ) ] NEW_LINE v = [ [ [ 0 for i in range ( 30 ) ] for i in range ( 30 ) ] for i in range ( MAX + 1 ) ] NEW_LINE def findCount ( mat , i , j , m ) : NEW_LINE INDENT if ( i == 0 and j == 0 ) : NEW_LINE INDENT if ( m == mat [ 0 ] [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i < 0 or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ j ] [ m ] > 0 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT v [ i ] [ j ] [ m ] = True NEW_LINE dp [ i ] [ j ] [ m ] = ( findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ) NEW_LINE return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT mat = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] NEW_LINE m = 5 NEW_LINE print ( findCount ( mat , n - 1 , n - 1 , m ) ) NEW_LINE"}
{"id": "geeksforgeeks_2462_A", "sol": 0, "python_code": "import math as mt\ndef Area ( a ) :\n    if ( a < 0 ) :\n        return - 1\n    x = 0.464 * a\n    A = 0.70477 * pow ( x , 2 )\n    return A\na = 5\nprint ( Area ( a ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = 0.464 * a NEW_LINE A = 0.70477 * pow ( x , 2 ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) ) NEW_LINE"}
{"id": "codeforces_1638_B", "sol": 0, "python_code": "import collections\nimport heapq\nimport sys\nimport math\nimport itertools\nimport bisect\nfrom io import BytesIO , IOBase\nimport os\ndef valid ( i , j , n , m ) :\n    if i < n and i >= 0 and j >= 0 and j < m : return True\n    return False\ndef sumn ( i , n ) :\n    return ( n - i ) * ( i + n ) / 2\ndef sqfun ( a , b , c ) :\n    return ( - b + math.sqrt ( b * b - 4 * a * c ) ) / 2 * a\ndef getprime ( num ) :\n    if all ( num % i != 0 for i in range ( 2 , int ( math.sqrt ( num ) ) + 1 ) ) : return True\ndef value ( ) : return tuple ( map ( int , input ( ).split ( ) ) )\ndef values ( ) : return tuple ( map ( int , sys.stdin.readline ( ).split ( ) ) )\ndef inlst ( ) : return [ int ( i ) for i in input ( ).split ( ) ]\ndef inlsts ( ) : return [ int ( i ) for i in sys.stdin.readline ( ).split ( ) ]\ndef inp ( ) : return int ( input ( ) )\ndef inps ( ) : return int ( sys.stdin.readline ( ) )\ndef instr ( ) : return input ( )\ndef stlst ( ) : return [ i for i in input ( ).split ( ) ]\ndef solve ( ) :\n    n = inp ( )\n    l = inlsts ( )\n    odd = [ ]\n    even = [ ]\n    for i in l :\n        if i % 2 == 0 :\n            if even and even [ - 1 ] > i : return \"No\"\n            even.append ( i )\n        if i % 2 == 1 :\n            if odd and odd [ - 1 ] > i : return \"No\"\n            odd.append ( i )\n    return \"Yes\"\nif __name__ == \"__main__\" :\n    for i in range ( inp ( ) ) :\n        print ( solve ( ) )\n", "python_code_tokenized": "import collections NEW_LINE import heapq NEW_LINE import sys NEW_LINE import math NEW_LINE import itertools NEW_LINE import bisect NEW_LINE from io import BytesIO , IOBase NEW_LINE import os NEW_LINE def valid ( i , j , n , m ) : NEW_LINE INDENT if i < n and i >= 0 and j >= 0 and j < m : return True NEW_LINE return False NEW_LINE DEDENT def sumn ( i , n ) : NEW_LINE INDENT return ( n - i ) * ( i + n ) / 2 NEW_LINE DEDENT def sqfun ( a , b , c ) : NEW_LINE INDENT return ( - b + math . sqrt ( b * b - 4 * a * c ) ) / 2 * a NEW_LINE DEDENT def getprime ( num ) : NEW_LINE INDENT if all ( num % i != 0 for i in range ( 2 , int ( math . sqrt ( num ) ) + 1 ) ) : return True NEW_LINE DEDENT def value ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def values ( ) : return tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def inlst ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE def inlsts ( ) : return [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def inp ( ) : return int ( input ( ) ) NEW_LINE def inps ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def instr ( ) : return input ( ) NEW_LINE def stlst ( ) : return [ i for i in input ( ) . split ( ) ] NEW_LINE def solve ( ) : NEW_LINE INDENT n = inp ( ) NEW_LINE l = inlsts ( ) NEW_LINE odd = [ ] NEW_LINE even = [ ] NEW_LINE for i in l : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT if even and even [ - 1 ] > i : return \" No \" NEW_LINE even . append ( i ) NEW_LINE DEDENT if i % 2 == 1 : NEW_LINE INDENT if odd and odd [ - 1 ] > i : return \" No \" NEW_LINE odd . append ( i ) NEW_LINE DEDENT DEDENT return \" Yes \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT for i in range ( inp ( ) ) : NEW_LINE INDENT print ( solve ( ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4346_A", "sol": 0, "python_code": "def fact ( n ) :\n    if n == 1 :\n        return 1\n    else :\n        return n * fact ( n - 1 )\ndef sum ( x , n ) :\n    total = 1.0\n    for i in range ( 1 , n + 1 , 1 ) :\n        total = total + ( pow ( x , i ) / fact ( i + 1 ) )\n    return total\nif __name__ == '__main__' :\n    x = 5\n    n = 4\n    print ( \"Sum is: {0:.4f}\".format ( sum ( x , n ) ) )\n", "python_code_tokenized": "def fact ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n * fact ( n - 1 ) NEW_LINE DEDENT DEDENT def sum ( x , n ) : NEW_LINE INDENT total = 1.0 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT total = total + ( pow ( x , i ) / fact ( i + 1 ) ) NEW_LINE DEDENT return total NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 5 NEW_LINE n = 4 NEW_LINE print ( \" Sum \u2581 is : \u2581 { 0 : . 4f } \" . format ( sum ( x , n ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_900_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    if ( a == 0 ) :\n        return b\n    return gcd ( b % a , a )\ndef commDiv ( a , b ) :\n    n = gcd ( a , b )\n    a = a // n\n    b = b // n\n    print ( \"A =\" , a , \", B =\" , b )\na , b = 10 , 15\ncommDiv ( a , b )\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def commDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE a = a // n NEW_LINE b = b // n NEW_LINE print ( \" A \u2581 = \" , a , \" , \u2581 B \u2581 = \" , b ) NEW_LINE DEDENT a , b = 10 , 15 NEW_LINE commDiv ( a , b ) NEW_LINE"}
{"id": "codeforces_1100_A", "sol": 0, "python_code": "import sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\nn , k = map ( int , input ( ).split ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\ns = sum ( a )\nans = 0\nfor i in range ( k ) :\n    d = 0\n    for j in range ( i , n , k ) :\n        d += a [ j ]\n    ans = max ( ans , abs ( s - d ) )\nprint ( ans )\n", "python_code_tokenized": "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( a ) NEW_LINE ans = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT d = 0 NEW_LINE for j in range ( i , n , k ) : NEW_LINE INDENT d += a [ j ] NEW_LINE DEDENT ans = max ( ans , abs ( s - d ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_191_A", "sol": 0, "python_code": "def check ( H , S ) :\n    return H * H >= 4 * S\ndef findPairs ( H , n , S , m ) :\n    count = 0\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if check ( H [ i ] , S [ j ] ) :\n                count += 1\n    return count\nif __name__ == \"__main__\" :\n    H = [ 1 , 6 , 4 ]\n    n = len ( H )\n    S = [ 23 , 3 , 42 , 14 ]\n    m = len ( S )\n    print ( findPairs ( H , n , S , m ) )\n", "python_code_tokenized": "def check ( H , S ) : NEW_LINE INDENT return H * H >= 4 * S NEW_LINE DEDENT def findPairs ( H , n , S , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if check ( H [ i ] , S [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT H = [ 1 , 6 , 4 ] NEW_LINE n = len ( H ) NEW_LINE S = [ 23 , 3 , 42 , 14 ] NEW_LINE m = len ( S ) NEW_LINE print ( findPairs ( H , n , S , m ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4750_A", "sol": 0, "python_code": "def findOddPair ( A , N ) :\n    count = 0\n    for i in range ( 0 , N ) :\n        if ( A [ i ] % 2 == 0 ) :\n            count += 1\n    return count * ( N - count )\nif __name__ == '__main__' :\n    a = [ 5 , 4 , 7 , 2 , 1 ]\n    n = len ( a )\n    print ( findOddPair ( a , n ) )\n", "python_code_tokenized": "def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( N - count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findOddPair ( a , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1654_B", "sol": 0, "python_code": "import math\nt = int ( input ( ) )\nfor i in range ( t ) :\n    s = input ( )\n    while s [ 0 ] in s [ 1 : ] :\n        i = 0\n        while s [ i ] in s [ i + 1 : ] :\n            i += 1\n        s = s [ i : ]\n    print ( s )\n", "python_code_tokenized": "import math NEW_LINE t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE while s [ 0 ] in s [ 1 : ] : NEW_LINE INDENT i = 0 NEW_LINE while s [ i ] in s [ i + 1 : ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT s = s [ i : ] NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3123_A", "sol": 0, "python_code": "def countOddSquares ( n , m ) :\n    return ( int ( pow ( m , 0.5 ) ) - int ( pow ( n - 1 , 0.5 ) ) )\nif __name__ == \"__main__\" :\n    n = 5 ; m = 100 ;\n    print ( \"Count is\" , ( m - n + 1 ) - countOddSquares ( n , m ) )\n", "python_code_tokenized": "def countOddSquares ( n , m ) : NEW_LINE INDENT return ( int ( pow ( m , 0.5 ) ) - int ( pow ( n - 1 , 0.5 ) ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; m = 100 ; NEW_LINE print ( \" Count \u2581 is \" , ( m - n + 1 ) - countOddSquares ( n , m ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3859_A", "sol": 0, "python_code": "def kthString ( n , k ) :\n    total = 0\n    i = 1\n    while ( total < k ) :\n        total = total + n - i\n        i += 1\n    first_y_position = i - 1\n    second_y_position = k - ( total - n + first_y_position )\n    for j in range ( 1 , first_y_position , 1 ) :\n        print ( \"x\" , end = \"\" )\n    print ( \"y\" , end = \"\" )\n    j = first_y_position + 1\n    while ( second_y_position > 1 ) :\n        print ( \"x\" , end = \"\" )\n        second_y_position -= 1\n        j += 1\n    print ( \"y\" , end = \"\" )\n    while ( j < n ) :\n        print ( \"x\" )\n        j += 1\nif __name__ == '__main__' :\n    n = 5\n    k = 7\n    kthString ( n , k )\n", "python_code_tokenized": "def kthString ( n , k ) : NEW_LINE INDENT total = 0 NEW_LINE i = 1 NEW_LINE while ( total < k ) : NEW_LINE INDENT total = total + n - i NEW_LINE i += 1 NEW_LINE DEDENT first_y_position = i - 1 NEW_LINE second_y_position = k - ( total - n + first_y_position ) NEW_LINE for j in range ( 1 , first_y_position , 1 ) : NEW_LINE INDENT print ( \" x \" , end = \" \" ) NEW_LINE DEDENT print ( \" y \" , end = \" \" ) NEW_LINE j = first_y_position + 1 NEW_LINE while ( second_y_position > 1 ) : NEW_LINE INDENT print ( \" x \" , end = \" \" ) NEW_LINE second_y_position -= 1 NEW_LINE j += 1 NEW_LINE DEDENT print ( \" y \" , end = \" \" ) NEW_LINE while ( j < n ) : NEW_LINE INDENT print ( \" x \" ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 7 NEW_LINE kthString ( n , k ) NEW_LINE DEDENT"}
{"id": "aizu_p00232_A", "sol": 0, "python_code": "def solve ( X , Y , Z , V , E , A ) :\n    dp = [ [ 0.0 ] * 6001 for _ in range ( Y + max ( V ) + 1 ) ]\n    dp [ 0 ] [ 0 ] = 1.0\n    for i in range ( Y ) :\n        for j in range ( 5001 ) :\n            if dp [ i ] [ j ] <= 0.0 :\n                continue\n            for k in V :\n                t = i + k\n                if t > Y :\n                    dp [ Y ] [ j ] += dp [ i ] [ j ] / X\n                elif E [ t ] == 1 :\n                    dp [ min ( Y , t + A [ t ] ) ] [ j ] += dp [ i ] [ j ] / X\n                else :\n                    dp [ t ] [ max ( 0 , j + A [ t ] ) ] += dp [ i ] [ j ] / X\n    s = 0\n    for i in range ( 5001 ) :\n        if dp [ Y ] [ i ] <= 0.0 :\n            continue\n        s += i * dp [ Y ] [ i ]\n    print ( int ( s ) )\nif __name__ == \"__main__\" :\n    import sys\n    while True :\n        X , Y , Z = map ( int , raw_input ( ).split ( ) )\n        if X | Y | Z == 0 :\n            sys.exit ( )\n        V = map ( int , raw_input ( ).split ( ) )\n        E = [ 0 ] * 100\n        A = [ 0 ] * 100\n        for _ in range ( Z ) :\n            n , e , a = map ( int , raw_input ( ).split ( ) )\n            E [ n ] = e\n            if e == 3 :\n                A [ n ] = - a\n            else :\n                A [ n ] = a\n        solve ( X , Y , Z , V , E , A )\n", "python_code_tokenized": "def solve ( X , Y , Z , V , E , A ) : NEW_LINE INDENT dp = [ [ 0.0 ] * 6001 for _ in range ( Y + max ( V ) + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1.0 NEW_LINE for i in range ( Y ) : NEW_LINE INDENT for j in range ( 5001 ) : NEW_LINE INDENT if dp [ i ] [ j ] <= 0.0 : NEW_LINE INDENT continue NEW_LINE DEDENT for k in V : NEW_LINE INDENT t = i + k NEW_LINE if t > Y : NEW_LINE INDENT dp [ Y ] [ j ] += dp [ i ] [ j ] / X NEW_LINE DEDENT elif E [ t ] == 1 : NEW_LINE INDENT dp [ min ( Y , t + A [ t ] ) ] [ j ] += dp [ i ] [ j ] / X NEW_LINE DEDENT else : NEW_LINE INDENT dp [ t ] [ max ( 0 , j + A [ t ] ) ] += dp [ i ] [ j ] / X NEW_LINE DEDENT DEDENT DEDENT DEDENT s = 0 NEW_LINE for i in range ( 5001 ) : NEW_LINE INDENT if dp [ Y ] [ i ] <= 0.0 : NEW_LINE INDENT continue NEW_LINE DEDENT s += i * dp [ Y ] [ i ] NEW_LINE DEDENT print ( int ( s ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT import sys NEW_LINE while True : NEW_LINE INDENT X , Y , Z = map ( int , raw_input ( ) . split ( ) ) NEW_LINE if X | Y | Z == 0 : NEW_LINE INDENT sys . exit ( ) NEW_LINE DEDENT V = map ( int , raw_input ( ) . split ( ) ) NEW_LINE E = [ 0 ] * 100 NEW_LINE A = [ 0 ] * 100 NEW_LINE for _ in range ( Z ) : NEW_LINE INDENT n , e , a = map ( int , raw_input ( ) . split ( ) ) NEW_LINE E [ n ] = e NEW_LINE if e == 3 : NEW_LINE INDENT A [ n ] = - a NEW_LINE DEDENT else : NEW_LINE INDENT A [ n ] = a NEW_LINE DEDENT DEDENT solve ( X , Y , Z , V , E , A ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_5246_A", "sol": 0, "python_code": "MAX_CHAR = 26\ndef distributingBalls ( k , n , string ) :\n    a = [ 0 ] * MAX_CHAR\n    for i in range ( n ) :\n        a [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1\n    for i in range ( MAX_CHAR ) :\n        if ( a [ i ] > k ) :\n            return False\n    return True\nif __name__ == \"__main__\" :\n    n , k = 6 , 3\n    string = \"aacaab\"\n    if ( distributingBalls ( k , n , string ) ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "MAX_CHAR = 26 NEW_LINE def distributingBalls ( k , n , string ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 6 , 3 NEW_LINE string = \" aacaab \" NEW_LINE if ( distributingBalls ( k , n , string ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_221_A", "sol": 0, "python_code": "n = int ( input ( ) )\nprint ( n , end = \" \" )\nfor i in range ( 1 , n ) :\n    print ( i , end = \" \" )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE print ( n , end = \" \u2581 \" ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4556_A", "sol": 0, "python_code": "mod = 10 ** 9 + 7\ndef ways ( arr , n ) :\n    dp = [ 0 ] * ( n + 1 )\n    dp [ n - 1 ] = 1\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        dp [ i ] = 0\n        j = 1\n        while ( ( j + i ) < n and j <= arr [ i ] ) :\n            dp [ i ] += dp [ i + j ]\n            dp [ i ] %= mod\n            j += 1\n    return dp [ 0 ] % mod\narr = [ 5 , 3 , 1 , 4 , 3 ]\nn = len ( arr )\nprint ( ways ( arr , n ) % mod )\n", "python_code_tokenized": "mod = 10 ** 9 + 7 NEW_LINE def ways ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] = 0 NEW_LINE j = 1 NEW_LINE while ( ( j + i ) < n and j <= arr [ i ] ) : NEW_LINE INDENT dp [ i ] += dp [ i + j ] NEW_LINE dp [ i ] %= mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] % mod NEW_LINE DEDENT arr = [ 5 , 3 , 1 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ways ( arr , n ) % mod ) NEW_LINE"}
{"id": "geeksforgeeks_4704_A", "sol": 0, "python_code": "def solve ( a , b ) :\n    l = len ( a )\n    min = 0\n    max = 0\n    for i in range ( l ) :\n        if ( a [ i ] == '+' or b [ i ] == '+' or a [ i ] != b [ i ] ) :\n            max += 1\n        if ( a [ i ] != '+' and b [ i ] != '+' and a [ i ] != b [ i ] ) :\n            min += 1\n    print ( min + max )\nif __name__ == '__main__' :\n    s1 = \"a+c\"\n    s2 = \"++b\"\n    solve ( s1 , s2 )\n", "python_code_tokenized": "def solve ( a , b ) : NEW_LINE INDENT l = len ( a ) NEW_LINE min = 0 NEW_LINE max = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] == ' + ' or b [ i ] == ' + ' or a [ i ] != b [ i ] ) : NEW_LINE INDENT max += 1 NEW_LINE DEDENT if ( a [ i ] != ' + ' and b [ i ] != ' + ' and a [ i ] != b [ i ] ) : NEW_LINE INDENT min += 1 NEW_LINE DEDENT DEDENT print ( min + max ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" a + c \" NEW_LINE s2 = \" + + b \" NEW_LINE solve ( s1 , s2 ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC102_C", "sol": 0, "python_code": "n = input ( )\nn = int ( n )\na = input ( ).split ( )\na = [ int ( aa ) for aa in a ]\nans = 10000000000000000\nl = - 100000000000\nr = 100000000000\nfor count in range ( 100 ) :\n    mid1 = 1 * ( r - l ) // 3 + l\n    mid2 = 2 * ( r - l ) // 3 + l\n    temp1 = 0\n    temp2 = 0\n    for i in range ( n ) :\n        temp1 += abs ( a [ i ] - ( mid1 + i + 1 ) )\n        temp2 += abs ( a [ i ] - ( mid2 + i + 1 ) )\n    if temp1 < temp2 :\n        r = mid2\n    else :\n        l = mid1\nfor b in range ( l , r + 1 ) :\n    temp = 0\n    for i in range ( n ) :\n        temp += abs ( a [ i ] - ( b + i + 1 ) )\n    ans = min ( ans , temp )\nprint ( ans )\n", "python_code_tokenized": "n = input ( ) NEW_LINE n = int ( n ) NEW_LINE a = input ( ) . split ( ) NEW_LINE a = [ int ( aa ) for aa in a ] NEW_LINE ans = 10000000000000000 NEW_LINE l = - 100000000000 NEW_LINE r = 100000000000 NEW_LINE for count in range ( 100 ) : NEW_LINE INDENT mid1 = 1 * ( r - l ) // 3 + l NEW_LINE mid2 = 2 * ( r - l ) // 3 + l NEW_LINE temp1 = 0 NEW_LINE temp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp1 += abs ( a [ i ] - ( mid1 + i + 1 ) ) NEW_LINE temp2 += abs ( a [ i ] - ( mid2 + i + 1 ) ) NEW_LINE DEDENT if temp1 < temp2 : NEW_LINE INDENT r = mid2 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid1 NEW_LINE DEDENT DEDENT for b in range ( l , r + 1 ) : NEW_LINE INDENT temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp += abs ( a [ i ] - ( b + i + 1 ) ) NEW_LINE DEDENT ans = min ( ans , temp ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "aizu_p02431_A", "sol": 0, "python_code": "import sys\nA = [ ]\nQ = int ( sys.stdin.readline ( ).rstrip ( ) )\nfor _ in range ( Q ) :\n    s = sys.stdin.readline ( ).rstrip ( ).split ( )\n    if s [ 0 ] == \"0\" :\n        A.append ( s [ 1 ] )\n    elif s [ 0 ] == \"1\" :\n        print ( A [ int ( s [ 1 ] ) ] )\n    else :\n        A.pop ( )\n", "python_code_tokenized": "import sys NEW_LINE A = [ ] NEW_LINE Q = int ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT s = sys . stdin . readline ( ) . rstrip ( ) . split ( ) NEW_LINE if s [ 0 ] == \"0\" : NEW_LINE INDENT A . append ( s [ 1 ] ) NEW_LINE DEDENT elif s [ 0 ] == \"1\" : NEW_LINE INDENT print ( A [ int ( s [ 1 ] ) ] ) NEW_LINE DEDENT else : NEW_LINE INDENT A . pop ( ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2066_A", "sol": 0, "python_code": "def gcdExtended ( a , b ) :\n    if a == 0 :\n        return b , 0 , 1\n    gcd , x1 , y1 = gcdExtended ( b % a , a )\n    x = y1 - ( b // a ) * x1\n    y = x1\n    return gcd , x , y\na , b = 35 , 15\ng , x , y = gcdExtended ( a , b )\nprint ( \"gcd(\" , a , \",\" , b , \") = \" , g )\n", "python_code_tokenized": "def gcdExtended ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b , 0 , 1 NEW_LINE DEDENT gcd , x1 , y1 = gcdExtended ( b % a , a ) NEW_LINE x = y1 - ( b // a ) * x1 NEW_LINE y = x1 NEW_LINE return gcd , x , y NEW_LINE DEDENT a , b = 35 , 15 NEW_LINE g , x , y = gcdExtended ( a , b ) NEW_LINE print ( \" gcd ( \" , a , \" , \" , b , \" ) \u2581 = \u2581 \" , g ) NEW_LINE"}
{"id": "geeksforgeeks_786_A", "sol": 0, "python_code": "def gcdExtended ( a , b ) :\n    if a == 0 :\n        return b , 0 , 1\n    gcd , x1 , y1 = gcdExtended ( b % a , a )\n    x = y1 - ( b // a ) * x1\n    y = x1\n    return gcd , x , y\na , b = 35 , 15\ng , x , y = gcdExtended ( a , b )\nprint ( \"gcd(\" , a , \",\" , b , \") = \" , g )\n", "python_code_tokenized": "def gcdExtended ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b , 0 , 1 NEW_LINE DEDENT gcd , x1 , y1 = gcdExtended ( b % a , a ) NEW_LINE x = y1 - ( b // a ) * x1 NEW_LINE y = x1 NEW_LINE return gcd , x , y NEW_LINE DEDENT a , b = 35 , 15 NEW_LINE g , x , y = gcdExtended ( a , b ) NEW_LINE print ( \" gcd ( \" , a , \" , \" , b , \" ) \u2581 = \u2581 \" , g ) NEW_LINE"}
{"id": "geeksforgeeks_2664_A", "sol": 0, "python_code": "def CommomSubsequencesCount ( s , t ) :\n    n1 = len ( s )\n    n2 = len ( t )\n    dp = [ [ 0 for i in range ( n2 + 1 ) ] for i in range ( n1 + 1 ) ]\n    for i in range ( 1 , n1 + 1 ) :\n        for j in range ( 1 , n2 + 1 ) :\n            if ( s [ i - 1 ] == t [ j - 1 ] ) :\n                dp [ i ] [ j ] = ( 1 + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] )\n            else :\n                dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] - dp [ i - 1 ] [ j - 1 ] )\n    return dp [ n1 ] [ n2 ]\ns = \"ajblqcpdz\"\nt = \"aefcnbtdi\"\nprint ( CommomSubsequencesCount ( s , t ) )\n", "python_code_tokenized": "def CommomSubsequencesCount ( s , t ) : NEW_LINE INDENT n1 = len ( s ) NEW_LINE n2 = len ( t ) NEW_LINE dp = [ [ 0 for i in range ( n2 + 1 ) ] for i in range ( n1 + 1 ) ] NEW_LINE for i in range ( 1 , n1 + 1 ) : NEW_LINE INDENT for j in range ( 1 , n2 + 1 ) : NEW_LINE INDENT if ( s [ i - 1 ] == t [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( 1 + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] - dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n1 ] [ n2 ] NEW_LINE DEDENT s = \" ajblqcpdz \" NEW_LINE t = \" aefcnbtdi \" NEW_LINE print ( CommomSubsequencesCount ( s , t ) ) NEW_LINE"}
{"id": "geeksforgeeks_5192_A", "sol": 0, "python_code": "def partition ( arr , si , ei ) :\n    x = arr [ ei ]\n    i = ( si - 1 )\n    for j in range ( si , ei ) :\n        if ( arr [ j ] <= x ) :\n            i += 1\n            arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]\n    arr [ i + 1 ] , arr [ ei ] = arr [ ei ] , arr [ i + 1 ]\n    return ( i + 1 )\ndef quickSort ( arr , si , ei ) :\n    pi = 0\n    if ( si < ei ) :\n        pi = partition ( arr , si , ei )\n        quickSort ( arr , si , pi - 1 )\n        quickSort ( arr , pi + 1 , ei )\ndef minAbsSumPair ( arr , n ) :\n    sum , min_sum = 0 , 10 ** 9\n    l = 0\n    r = n - 1\n    min_l = l\n    min_r = n - 1\n    if ( n < 2 ) :\n        print ( \"Invalid Input\" , end = \"\" )\n        return\n    quickSort ( arr , l , r )\n    while ( l < r ) :\n        sum = arr [ l ] + arr [ r ]\n        if ( abs ( sum ) < abs ( min_sum ) ) :\n            min_sum = sum\n            min_l = l\n            min_r = r\n        if ( sum < 0 ) :\n            l += 1\n        else :\n            r -= 1\n    print ( \"The two elements whose sum is minimum are\" , arr [ min_l ] , \"and\" , arr [ min_r ] )\narr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ]\nn = len ( arr )\nminAbsSumPair ( arr , n )\n", "python_code_tokenized": "def partition ( arr , si , ei ) : NEW_LINE INDENT x = arr [ ei ] NEW_LINE i = ( si - 1 ) NEW_LINE for j in range ( si , ei ) : NEW_LINE INDENT if ( arr [ j ] <= x ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ ei ] = arr [ ei ] , arr [ i + 1 ] NEW_LINE return ( i + 1 ) NEW_LINE DEDENT def quickSort ( arr , si , ei ) : NEW_LINE INDENT pi = 0 NEW_LINE if ( si < ei ) : NEW_LINE INDENT pi = partition ( arr , si , ei ) NEW_LINE quickSort ( arr , si , pi - 1 ) NEW_LINE quickSort ( arr , pi + 1 , ei ) NEW_LINE DEDENT DEDENT def minAbsSumPair ( arr , n ) : NEW_LINE INDENT sum , min_sum = 0 , 10 ** 9 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE min_l = l NEW_LINE min_r = n - 1 NEW_LINE if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT quickSort ( arr , l , r ) NEW_LINE while ( l < r ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if ( abs ( sum ) < abs ( min_sum ) ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT print ( \" The \u2581 two \u2581 elements \u2581 whose \u2581 sum \u2581 is \u2581 minimum \u2581 are \" , arr [ min_l ] , \" and \" , arr [ min_r ] ) NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE minAbsSumPair ( arr , n ) NEW_LINE"}
{"id": "codeforces_1715_B", "sol": 0, "python_code": "for s in [ * open ( 0 ) ] [ 1 : ] : n , k , b , s = map ( int , s.split ( ) ) ; s -= k * b ; x = s // n ; r = s % n ; print ( * n * k - n >= s >= 0 and [ k * b + x ] + r * [ x + 1 ] + ( n - r - 1 ) * [ x ] or [ - 1 ] )\n", "python_code_tokenized": "for s in [ * open ( 0 ) ] [ 1 : ] : n , k , b , s = map ( int , s . split ( ) ) ; s -= k * b ; x = s // n ; r = s % n ; print ( * n * k - n >= s >= 0 and [ k * b + x ] + r * [ x + 1 ] + ( n - r - 1 ) * [ x ] or [ - 1 ] ) NEW_LINE"}
{"id": "projecteuler_p005_A", "sol": 0, "python_code": "import fractions\ndef compute ( ) :\n    ans = 1\n    for i in range ( 1 , 21 ) :\n        ans *= i // fractions.gcd ( i , ans )\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import fractions NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , 21 ) : NEW_LINE INDENT ans *= i // fractions . gcd ( i , ans ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00129_A", "sol": 0, "python_code": "import math as M\ndef R ( A ) : return ( A [ 0 ] ** 2 + A [ 1 ] ** 2 ) **.5\ndef I ( i ) : return [ map ( int , raw_input ( ).split ( ) ) for _ in [ 0 ] * i ]\ndef C ( a , b ) : return a > b or abs ( a - b ) < 1e-6\ndef f ( e1 ) :\n    tx , ty , sx , sy = e1\n    x = [ ]\n    for e2 in WP :\n        wx , wy , r = e2\n        wt = [ tx - wx , ty - wy ] ; rwt = R ( wt )\n        sw = [ wx - sx , wy - sy ] ; rsw = R ( sw )\n        st = [ tx - sx , ty - sy ] ; rst = R ( st )\n        F = [ rwt < r , rsw < r ]\n        if rst == 0 : c = 1\n        elif F == [ 1 , 1 ] : c = 1\n        elif F == [ 1 , 0 ] or F == [ 0 , 1 ] : c = 0\n        elif F == [ 0 , 0 ] :\n            a = M.pi / 2 - M.acos ( r / rsw )\n            b = M.acos ( round ( ( sw [ 0 ] * st [ 0 ] + sw [ 1 ] * st [ 1 ] ) / rsw / rst , 4 ) )\n            if C ( a , b ) and C ( rst ** 2 , rsw ** 2 - r ** 2 ) : c = 0\n            else : c = 1\n        x.append ( c )\n    return all ( x )\nwhile 1 :\n    n = input ( )\n    if n == 0 : break\n    WP = I ( n )\n    P = I ( input ( ) )\n    for e in P : print [ \"Safe\" , \"Danger\" ] [ f ( e ) ]\n", "python_code_tokenized": "import math as M NEW_LINE def R ( A ) : return ( A [ 0 ] ** 2 + A [ 1 ] ** 2 ) ** .5 NEW_LINE def I ( i ) : return [ map ( int , raw_input ( ) . split ( ) ) for _ in [ 0 ] * i ] NEW_LINE def C ( a , b ) : return a > b or abs ( a - b ) < 1e-6 NEW_LINE def f ( e1 ) : NEW_LINE INDENT tx , ty , sx , sy = e1 NEW_LINE x = [ ] NEW_LINE for e2 in WP : NEW_LINE INDENT wx , wy , r = e2 NEW_LINE wt = [ tx - wx , ty - wy ] ; rwt = R ( wt ) NEW_LINE sw = [ wx - sx , wy - sy ] ; rsw = R ( sw ) NEW_LINE st = [ tx - sx , ty - sy ] ; rst = R ( st ) NEW_LINE F = [ rwt < r , rsw < r ] NEW_LINE if rst == 0 : c = 1 NEW_LINE elif F == [ 1 , 1 ] : c = 1 NEW_LINE elif F == [ 1 , 0 ] or F == [ 0 , 1 ] : c = 0 NEW_LINE elif F == [ 0 , 0 ] : NEW_LINE INDENT a = M . pi / 2 - M . acos ( r / rsw ) NEW_LINE b = M . acos ( round ( ( sw [ 0 ] * st [ 0 ] + sw [ 1 ] * st [ 1 ] ) / rsw / rst , 4 ) ) NEW_LINE if C ( a , b ) and C ( rst ** 2 , rsw ** 2 - r ** 2 ) : c = 0 NEW_LINE else : c = 1 NEW_LINE DEDENT x . append ( c ) NEW_LINE DEDENT return all ( x ) NEW_LINE DEDENT while 1 : NEW_LINE INDENT n = input ( ) NEW_LINE if n == 0 : break NEW_LINE WP = I ( n ) NEW_LINE P = I ( input ( ) ) NEW_LINE for e in P : print [ \" Safe \" , \" Danger \" ] [ f ( e ) ] NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2362_A", "sol": 0, "python_code": "def countSubarrWithEqualZeroAndOne ( arr , n ) :\n    um = dict ( )\n    curr_sum = 0\n    for i in range ( n ) :\n        curr_sum += ( - 1 if ( arr [ i ] == 0 ) else arr [ i ] )\n        if um.get ( curr_sum ) :\n            um [ curr_sum ] += 1\n        else :\n            um [ curr_sum ] = 1\n    count = 0\n    for itr in um :\n        if um [ itr ] > 1 :\n            count += ( ( um [ itr ] * int ( um [ itr ] - 1 ) ) / 2 )\n    if um.get ( 0 ) :\n        count += um [ 0 ]\n    return int ( count )\narr = [ 1 , 0 , 0 , 1 , 0 , 1 , 1 ]\nn = len ( arr )\nprint ( \"Count =\" , countSubarrWithEqualZeroAndOne ( arr , n ) )\n", "python_code_tokenized": "def countSubarrWithEqualZeroAndOne ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += ( - 1 if ( arr [ i ] == 0 ) else arr [ i ] ) NEW_LINE if um . get ( curr_sum ) : NEW_LINE INDENT um [ curr_sum ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT um [ curr_sum ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for itr in um : NEW_LINE INDENT if um [ itr ] > 1 : NEW_LINE INDENT count += ( ( um [ itr ] * int ( um [ itr ] - 1 ) ) / 2 ) NEW_LINE DEDENT DEDENT if um . get ( 0 ) : NEW_LINE INDENT count += um [ 0 ] NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT arr = [ 1 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Count \u2581 = \" , countSubarrWithEqualZeroAndOne ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_284_A", "sol": 0, "python_code": "def max_U_element ( a , N , M ) :\n    hsh = dict ( )\n    dist_count = 0\n    res = 0\n    for i in range ( M ) :\n        if ( arr [ i ] not in hsh.keys ( ) ) :\n            hsh [ a [ i ] ] = 1\n            dist_count += 1\n        else :\n            hsh [ a [ i ] ] += 1\n    res = dist_count\n    for i in range ( M , N ) :\n        if ( a [ i - M ] in hsh.keys ( ) and hsh [ a [ i - M ] ] == 1 ) :\n            del hsh [ a [ i - M ] ]\n            dist_count -= 1\n        else :\n            hsh [ a [ i - M ] ] -= 1\n        if ( a [ i ] not in hsh.keys ( ) ) :\n            hsh [ a [ i ] ] = 1\n            dist_count += 1\n        else :\n            hsh [ a [ i ] ] += 1\n        res = max ( res , dist_count )\n    return res\narr = [ 1 , 2 , 1 , 3 , 4 , 2 , 3 ]\nM = 4\nN = len ( arr )\nprint ( max_U_element ( arr , N , M ) )\n", "python_code_tokenized": "def max_U_element ( a , N , M ) : NEW_LINE INDENT hsh = dict ( ) NEW_LINE dist_count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if ( arr [ i ] not in hsh . keys ( ) ) : NEW_LINE INDENT hsh [ a [ i ] ] = 1 NEW_LINE dist_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hsh [ a [ i ] ] += 1 NEW_LINE DEDENT DEDENT res = dist_count NEW_LINE for i in range ( M , N ) : NEW_LINE INDENT if ( a [ i - M ] in hsh . keys ( ) and hsh [ a [ i - M ] ] == 1 ) : NEW_LINE INDENT del hsh [ a [ i - M ] ] NEW_LINE dist_count -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT hsh [ a [ i - M ] ] -= 1 NEW_LINE DEDENT if ( a [ i ] not in hsh . keys ( ) ) : NEW_LINE INDENT hsh [ a [ i ] ] = 1 NEW_LINE dist_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hsh [ a [ i ] ] += 1 NEW_LINE DEDENT res = max ( res , dist_count ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 2 , 1 , 3 , 4 , 2 , 3 ] NEW_LINE M = 4 NEW_LINE N = len ( arr ) NEW_LINE print ( max_U_element ( arr , N , M ) ) NEW_LINE"}
{"id": "geeksforgeeks_4342_A", "sol": 0, "python_code": "MAX = 100\ndef sortRows ( mat , n ) :\n    for i in range ( 0 , n ) :\n        mat [ i ].sort ( ) ;\ndef findAndPrintCommonElements ( mat , n ) :\n    sortRows ( mat , n )\n    curr_index = [ 0 ] * n\n    for i in range ( 0 , n ) :\n        curr_index [ i ] = 0\n    f = 0\n    while ( curr_index [ 0 ] < n ) :\n        value = mat [ 0 ] [ curr_index [ 0 ] ]\n        present = True\n        for i in range ( 1 , n ) :\n            while ( curr_index [ i ] < n and mat [ i ] [ curr_index [ i ] ] <= value ) :\n                curr_index [ i ] = curr_index [ i ] + 1\n            if ( mat [ i ] [ curr_index [ i ] - 1 ] != value ) :\n                present = False\n            if ( curr_index [ i ] == n ) :\n                f = 1\n                break\n        if ( present ) :\n            print ( value , end = \" \" )\n        if ( f == 1 ) :\n            break\n        curr_index [ 0 ] = curr_index [ 0 ] + 1\nmat = [ [ 12 , 1 , 14 , 3 , 16 ] , [ 14 , 2 , 1 , 3 , 35 ] , [ 14 , 1 , 14 , 3 , 11 ] , [ 14 , 25 , 3 , 2 , 1 ] , [ 1 , 18 , 3 , 21 , 14 ] ]\nn = 5\nfindAndPrintCommonElements ( mat , n )\n", "python_code_tokenized": "MAX = 100 NEW_LINE def sortRows ( mat , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT mat [ i ] . sort ( ) ; NEW_LINE DEDENT DEDENT def findAndPrintCommonElements ( mat , n ) : NEW_LINE INDENT sortRows ( mat , n ) NEW_LINE curr_index = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_index [ i ] = 0 NEW_LINE DEDENT f = 0 NEW_LINE while ( curr_index [ 0 ] < n ) : NEW_LINE INDENT value = mat [ 0 ] [ curr_index [ 0 ] ] NEW_LINE present = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( curr_index [ i ] < n and mat [ i ] [ curr_index [ i ] ] <= value ) : NEW_LINE INDENT curr_index [ i ] = curr_index [ i ] + 1 NEW_LINE DEDENT if ( mat [ i ] [ curr_index [ i ] - 1 ] != value ) : NEW_LINE INDENT present = False NEW_LINE DEDENT if ( curr_index [ i ] == n ) : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( present ) : NEW_LINE INDENT print ( value , end = \" \u2581 \" ) NEW_LINE DEDENT if ( f == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT curr_index [ 0 ] = curr_index [ 0 ] + 1 NEW_LINE DEDENT DEDENT mat = [ [ 12 , 1 , 14 , 3 , 16 ] , [ 14 , 2 , 1 , 3 , 35 ] , [ 14 , 1 , 14 , 3 , 11 ] , [ 14 , 25 , 3 , 2 , 1 ] , [ 1 , 18 , 3 , 21 , 14 ] ] NEW_LINE n = 5 NEW_LINE findAndPrintCommonElements ( mat , n ) NEW_LINE"}
{"id": "geeksforgeeks_309_A", "sol": 0, "python_code": "def longSubarrWthSumDivByK ( arr , n , k ) :\n    um = { i : 0 for i in range ( 8 ) }\n    mod_arr = [ 0 for i in range ( n ) ]\n    max = 0\n    curr_sum = 0\n    for i in range ( n ) :\n        curr_sum += arr [ i ]\n        mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k\n    for i in range ( n ) :\n        if ( mod_arr [ i ] == 0 ) :\n            max = i + 1\n        elif ( mod_arr [ i ] in um ) :\n            um [ mod_arr [ i ] ] = i\n        else :\n            if ( max < ( i - um [ mod_arr [ i ] ] ) ) :\n                max = i - um [ mod_arr [ i ] ]\n    return max\nif __name__ == '__main__' :\n    arr = [ 2 , 7 , 6 , 1 , 4 , 5 ]\n    n = len ( arr )\n    k = 3\n    print ( \"Length =\" , longSubarrWthSumDivByK ( arr , n , k ) )\n", "python_code_tokenized": "def longSubarrWthSumDivByK ( arr , n , k ) : NEW_LINE INDENT um = { i : 0 for i in range ( 8 ) } NEW_LINE mod_arr = [ 0 for i in range ( n ) ] NEW_LINE max = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mod_arr [ i ] == 0 ) : NEW_LINE INDENT max = i + 1 NEW_LINE DEDENT elif ( mod_arr [ i ] in um ) : NEW_LINE INDENT um [ mod_arr [ i ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT if ( max < ( i - um [ mod_arr [ i ] ] ) ) : NEW_LINE INDENT max = i - um [ mod_arr [ i ] ] NEW_LINE DEDENT DEDENT DEDENT return max NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 7 , 6 , 1 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( \" Length \u2581 = \" , longSubarrWthSumDivByK ( arr , n , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5256_A", "sol": 0, "python_code": "def find_ans ( ar , j , k ) :\n    l = len ( ar )\n    for i in range ( 1 , l ) :\n        ar [ i ] = ar [ i ] + ar [ i - 1 ]\n    print ( ar [ k ] - ar [ j - 1 ] )\n    return ;\npr = [ 1 , 2 , 3 , 4 , 5 ]\nar = pr [ : ]\nfind_ans ( ar , 1 , 3 )\nar = pr [ : ]\nfind_ans ( ar , 2 , 4 )\n", "python_code_tokenized": "def find_ans ( ar , j , k ) : NEW_LINE INDENT l = len ( ar ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT ar [ i ] = ar [ i ] + ar [ i - 1 ] NEW_LINE DEDENT print ( ar [ k ] - ar [ j - 1 ] ) NEW_LINE return ; NEW_LINE DEDENT pr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE ar = pr [ : ] NEW_LINE find_ans ( ar , 1 , 3 ) NEW_LINE ar = pr [ : ] NEW_LINE find_ans ( ar , 2 , 4 ) NEW_LINE"}
{"id": "codeforces_1651_A", "sol": 0, "python_code": "for i in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    print ( 2 ** n - 1 )\n", "python_code_tokenized": "for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( 2 ** n - 1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1632_A", "sol": 0, "python_code": "MAX_SIZE = 10\ndef sortByRow ( mat , n , ascending ) :\n    for i in range ( n ) :\n        if ( ascending ) :\n            mat [ i ].sort ( )\n        else :\n            mat [ i ].sort ( reverse = True )\ndef transpose ( mat , n ) :\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            temp = mat [ i ] [ j ]\n            mat [ i ] [ j ] = mat [ j ] [ i ]\n            mat [ j ] [ i ] = temp\ndef sortMatRowAndColWise ( mat , n ) :\n    sortByRow ( mat , n , True )\n    transpose ( mat , n )\n    sortByRow ( mat , n , False )\n    transpose ( mat , n )\ndef printMat ( mat , n ) :\n    for i in range ( n ) :\n        for j in range ( n ) :\n            print ( mat [ i ] [ j ] , \"\" , end = \"\" )\n        print ( )\nn = 3\nmat = [ [ 3 , 2 , 1 ] , [ 9 , 8 , 7 ] , [ 6 , 5 , 4 ] ]\nprint ( \"Original Matrix:\" )\nprintMat ( mat , n )\nsortMatRowAndColWise ( mat , n )\nprint ( \"Matrix After Sorting:\" )\nprintMat ( mat , n )\n", "python_code_tokenized": "MAX_SIZE = 10 NEW_LINE def sortByRow ( mat , n , ascending ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ascending ) : NEW_LINE INDENT mat [ i ] . sort ( ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] . sort ( reverse = True ) NEW_LINE DEDENT DEDENT DEDENT def transpose ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT temp = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE mat [ j ] [ i ] = temp NEW_LINE DEDENT DEDENT DEDENT def sortMatRowAndColWise ( mat , n ) : NEW_LINE INDENT sortByRow ( mat , n , True ) NEW_LINE transpose ( mat , n ) NEW_LINE sortByRow ( mat , n , False ) NEW_LINE transpose ( mat , n ) NEW_LINE DEDENT def printMat ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 3 NEW_LINE mat = [ [ 3 , 2 , 1 ] , [ 9 , 8 , 7 ] , [ 6 , 5 , 4 ] ] NEW_LINE print ( \" Original \u2581 Matrix : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE sortMatRowAndColWise ( mat , n ) NEW_LINE print ( \" Matrix \u2581 After \u2581 Sorting : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE"}
{"id": "geeksforgeeks_3291_A", "sol": 0, "python_code": "def isDigit ( ch ) :\n    if ch >= '0' and ch <= '9' :\n        return True\n    return False\ndef nextNonDigit ( string , i ) :\n    while i < len ( string ) and isDigit ( string [ i ] ) :\n        i += 1\n    if i >= len ( string ) :\n        return - 1\n    return i\ndef appendRepeated ( sb , string , times ) :\n    for i in range ( times ) :\n        sb.append ( string )\ndef findString ( string , n ) :\n    sb = list ( )\n    startStr = nextNonDigit ( string , 0 )\n    while startStr != - 1 :\n        endStr = startStr\n        while ( endStr + 1 < n and not isDigit ( string [ endStr + 1 ] ) ) :\n            endStr += 1\n        startNum = endStr + 1\n        if startNum == - 1 :\n            break\n        endNum = startNum\n        while ( endNum + 1 < n and isDigit ( string [ endNum + 1 ] ) ) :\n            endNum += 1\n        num = int ( string [ startNum : endNum + 1 ] )\n        appendRepeated ( sb , string [ startStr : endStr + 1 ] , num )\n        startStr = nextNonDigit ( string , endStr + 1 )\n    sb = ''.join ( sb )\n    return sb\nif __name__ == \"__main__\" :\n    string = \"g1ee1ks1for1g1e2ks1\"\n    n = len ( string )\n    print ( findString ( string , n ) )\n", "python_code_tokenized": "def isDigit ( ch ) : NEW_LINE INDENT if ch >= '0' and ch <= '9' : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def nextNonDigit ( string , i ) : NEW_LINE INDENT while i < len ( string ) and isDigit ( string [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i >= len ( string ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return i NEW_LINE DEDENT def appendRepeated ( sb , string , times ) : NEW_LINE INDENT for i in range ( times ) : NEW_LINE INDENT sb . append ( string ) NEW_LINE DEDENT DEDENT def findString ( string , n ) : NEW_LINE INDENT sb = list ( ) NEW_LINE startStr = nextNonDigit ( string , 0 ) NEW_LINE while startStr != - 1 : NEW_LINE INDENT endStr = startStr NEW_LINE while ( endStr + 1 < n and not isDigit ( string [ endStr + 1 ] ) ) : NEW_LINE INDENT endStr += 1 NEW_LINE DEDENT startNum = endStr + 1 NEW_LINE if startNum == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT endNum = startNum NEW_LINE while ( endNum + 1 < n and isDigit ( string [ endNum + 1 ] ) ) : NEW_LINE INDENT endNum += 1 NEW_LINE DEDENT num = int ( string [ startNum : endNum + 1 ] ) NEW_LINE appendRepeated ( sb , string [ startStr : endStr + 1 ] , num ) NEW_LINE startStr = nextNonDigit ( string , endStr + 1 ) NEW_LINE DEDENT sb = ' ' . join ( sb ) NEW_LINE return sb NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" g1ee1ks1for1g1e2ks1\" NEW_LINE n = len ( string ) NEW_LINE print ( findString ( string , n ) ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC007_B", "sol": 0, "python_code": "N = int ( input ( ) )\nP = list ( map ( int , input ( ).split ( ) ) )\nA = [ 45678 * i for i in range ( 1 , N + 1 ) ]\nB = A [ : : - 1 ]\nfor i , p in enumerate ( P ) :\n    A [ p - 1 ] += i\n    B [ p - 1 ] += i\nprint ( * A )\nprint ( * B )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE P = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A = [ 45678 * i for i in range ( 1 , N + 1 ) ] NEW_LINE B = A [ : : - 1 ] NEW_LINE for i , p in enumerate ( P ) : NEW_LINE INDENT A [ p - 1 ] += i NEW_LINE B [ p - 1 ] += i NEW_LINE DEDENT print ( * A ) NEW_LINE print ( * B ) NEW_LINE"}
{"id": "atcoder_ABC119_A", "sol": 0, "python_code": "Y , M , D = map ( int , input ( ).split ( '/' ) )\nif Y >= 2019 and M >= 5 :\n    print ( \"TBD\" )\nelse :\n    print ( \"Heisei\" )\n", "python_code_tokenized": "Y , M , D = map ( int , input ( ) . split ( ' / ' ) ) NEW_LINE if Y >= 2019 and M >= 5 : NEW_LINE INDENT print ( \" TBD \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Heisei \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3565_A", "sol": 0, "python_code": "def minimumNumbers ( n , s ) :\n    if ( s % n ) :\n        return s / n + 1 ;\n    else :\n        return s / n ;\nn = 5 ;\ns = 11 ;\nprint ( int ( minimumNumbers ( n , s ) ) ) ;\n", "python_code_tokenized": "def minimumNumbers ( n , s ) : NEW_LINE INDENT if ( s % n ) : NEW_LINE INDENT return s / n + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return s / n ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE s = 11 ; NEW_LINE print ( int ( minimumNumbers ( n , s ) ) ) ; NEW_LINE"}
{"id": "aizu_p02098_A", "sol": 0, "python_code": "t1 = int ( input ( ) )\nt2 = int ( input ( ) )\nif not t1 < t2 :\n    t1 , t2 = t2 , t1\nif t2 - t1 <= 180 :\n    print ( ( t2 + t1 ) / 2 )\nelse :\n    print ( ( ( t2 + t1 + 360 ) % 720 ) / 2 )\n", "python_code_tokenized": "t1 = int ( input ( ) ) NEW_LINE t2 = int ( input ( ) ) NEW_LINE if not t1 < t2 : NEW_LINE INDENT t1 , t2 = t2 , t1 NEW_LINE DEDENT if t2 - t1 <= 180 : NEW_LINE INDENT print ( ( t2 + t1 ) / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ( t2 + t1 + 360 ) % 720 ) / 2 ) NEW_LINE DEDENT"}
{"id": "aizu_p00478_A", "sol": 0, "python_code": "s = input ( )\nn = int ( input ( ) )\nst = [ input ( ) for _ in range ( n ) ]\nfor i in range ( n ) :\n    st [ i ] = st [ i ] + st [ i ] [ : len ( st [ i ] ) - 1 ]\ncnt = 0\nfor i in range ( n ) :\n    if s in st [ i ] :\n        cnt += 1\nprint ( cnt )\n", "python_code_tokenized": "s = input ( ) NEW_LINE n = int ( input ( ) ) NEW_LINE st = [ input ( ) for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT st [ i ] = st [ i ] + st [ i ] [ : len ( st [ i ] ) - 1 ] NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s in st [ i ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE"}
{"id": "geeksforgeeks_897_A", "sol": 0, "python_code": "import math\ndef divSum ( n ) :\n    sum = 1 ;\n    i = 2 ;\n    while ( i * i <= n ) :\n        if ( n % i == 0 ) :\n            sum = ( sum + i + math.floor ( n / i ) ) ;\n        i += 1 ;\n    return sum ;\ndef areEquivalent ( num1 , num2 ) :\n    return divSum ( num1 ) == divSum ( num2 ) ;\nnum1 = 559 ;\nnum2 = 703 ;\nif ( areEquivalent ( num1 , num2 ) == True ) :\n    print ( \"Equivalent\" ) ;\nelse :\n    print ( \"Not Equivalent\" ) ;\n", "python_code_tokenized": "import math NEW_LINE def divSum ( n ) : NEW_LINE INDENT sum = 1 ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sum = ( sum + i + math . floor ( n / i ) ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def areEquivalent ( num1 , num2 ) : NEW_LINE INDENT return divSum ( num1 ) == divSum ( num2 ) ; NEW_LINE DEDENT num1 = 559 ; NEW_LINE num2 = 703 ; NEW_LINE if ( areEquivalent ( num1 , num2 ) == True ) : NEW_LINE INDENT print ( \" Equivalent \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Equivalent \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3572_A", "sol": 0, "python_code": "MAX = 100 ;\nn = 0 ;\nstore = [ 0 ] * MAX ;\ngraph = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] ;\nd = [ 0 ] * MAX ;\ndef is_clique ( b ) :\n    for i in range ( 1 , b ) :\n        for j in range ( i + 1 , b ) :\n            if ( graph [ store [ i ] ] [ store [ j ] ] == 0 ) :\n                return False ;\n    return True ;\ndef maxCliques ( i , l ) :\n    max_ = 0 ;\n    for j in range ( i + 1 , n + 1 ) :\n        store [ l ] = j ;\n        if ( is_clique ( l + 1 ) ) :\n            max_ = max ( max_ , l ) ;\n            max_ = max ( max_ , maxCliques ( j , l + 1 ) ) ;\n    return max_ ;\nif __name__ == '__main__' :\n    edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 1 ] , [ 4 , 3 ] , [ 4 , 1 ] , [ 4 , 2 ] ] ;\n    size = len ( edges ) ;\n    n = 4 ;\n    for i in range ( size ) :\n        graph [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = 1 ;\n        graph [ edges [ i ] [ 1 ] ] [ edges [ i ] [ 0 ] ] = 1 ;\n        d [ edges [ i ] [ 0 ] ] += 1 ;\n        d [ edges [ i ] [ 1 ] ] += 1 ;\n    print ( maxCliques ( 0 , 1 ) ) ;\n", "python_code_tokenized": "MAX = 100 ; NEW_LINE n = 0 ; NEW_LINE store = [ 0 ] * MAX ; NEW_LINE graph = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] ; NEW_LINE d = [ 0 ] * MAX ; NEW_LINE def is_clique ( b ) : NEW_LINE INDENT for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( i + 1 , b ) : NEW_LINE INDENT if ( graph [ store [ i ] ] [ store [ j ] ] == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT def maxCliques ( i , l ) : NEW_LINE INDENT max_ = 0 ; NEW_LINE for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT store [ l ] = j ; NEW_LINE if ( is_clique ( l + 1 ) ) : NEW_LINE INDENT max_ = max ( max_ , l ) ; NEW_LINE max_ = max ( max_ , maxCliques ( j , l + 1 ) ) ; NEW_LINE DEDENT DEDENT return max_ ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 1 ] , [ 4 , 3 ] , [ 4 , 1 ] , [ 4 , 2 ] ] ; NEW_LINE size = len ( edges ) ; NEW_LINE n = 4 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT graph [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = 1 ; NEW_LINE graph [ edges [ i ] [ 1 ] ] [ edges [ i ] [ 0 ] ] = 1 ; NEW_LINE d [ edges [ i ] [ 0 ] ] += 1 ; NEW_LINE d [ edges [ i ] [ 1 ] ] += 1 ; NEW_LINE DEDENT print ( maxCliques ( 0 , 1 ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_411_A", "sol": 0, "python_code": "def checkPass ( mypass : str ) -> bool :\n    if len ( mypass ) < 5 :\n        return False\n    cntlrg = 0\n    smlrg = 0\n    dig = 0\n    for c in mypass :\n        if c.isupper ( ) :\n            cntlrg += 1\n        if c.islower ( ) :\n            smlrg += 1\n        if c.isdigit ( ) :\n            dig += 1\n    if cntlrg < 1 or smlrg < 1 or dig < 1 :\n        return False\n    return True\nx = input ( )\nif checkPass ( x ) :\n    print ( \"Correct\" )\nelse :\n    print ( \"Too weak\" )\n", "python_code_tokenized": "def checkPass ( mypass : str ) -> bool : NEW_LINE INDENT if len ( mypass ) < 5 : NEW_LINE INDENT return False NEW_LINE DEDENT cntlrg = 0 NEW_LINE smlrg = 0 NEW_LINE dig = 0 NEW_LINE for c in mypass : NEW_LINE INDENT if c . isupper ( ) : NEW_LINE INDENT cntlrg += 1 NEW_LINE DEDENT if c . islower ( ) : NEW_LINE INDENT smlrg += 1 NEW_LINE DEDENT if c . isdigit ( ) : NEW_LINE INDENT dig += 1 NEW_LINE DEDENT DEDENT if cntlrg < 1 or smlrg < 1 or dig < 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT x = input ( ) NEW_LINE if checkPass ( x ) : NEW_LINE INDENT print ( \" Correct \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Too \u2581 weak \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1375_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    n = int ( input ( ) )\n    case = list ( map ( int , input ( ).split ( ) ) )\n    for x in range ( n ) :\n        if case [ x ] < 0 :\n            case [ x ] *= - 1\n    for x in range ( n ) :\n        if x % 2 == 0 :\n            case [ x ] *= - 1\n        else :\n            continue\n    case = list ( map ( str , case ) )\n    print ( \" \".join ( case ) )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE case = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for x in range ( n ) : NEW_LINE INDENT if case [ x ] < 0 : NEW_LINE INDENT case [ x ] *= - 1 NEW_LINE DEDENT DEDENT for x in range ( n ) : NEW_LINE INDENT if x % 2 == 0 : NEW_LINE INDENT case [ x ] *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT case = list ( map ( str , case ) ) NEW_LINE print ( \" \u2581 \" . join ( case ) ) NEW_LINE DEDENT"}
{"id": "codeforces_143_B", "sol": 0, "python_code": "def parse_int ( num : int ) :\n    to_str = str ( num )\n    count = 0\n    sumstr = ''\n    for one_str in to_str [ : : - 1 ] :\n        count += 1\n        if count % 3 == 0 and count != len ( to_str ) :\n            one_str = ',' + one_str\n            sumstr = one_str + sumstr\n        else :\n            sumstr = one_str + sumstr\n    return sumstr\nn = input ( )\nn1 = n.split ( \".\" ) [ 0 ]\nn2 = \"\"\nn1 = parse_int ( abs ( int ( n1 ) ) )\nif n.count ( '.' ) > 0 :\n    n2 = n.split ( '.' ) [ 1 ] [ : 2 ]\n    if len ( n2 ) < 2 :\n        n2 = n2 + \"0\"\n    n2 = \".\" + n2\nelse :\n    n2 = \".00\"\nif n [ 0 ] == '-' :\n    print ( \"($\" + n1 + n2 + \")\" , end = \"\" )\nelse :\n    print ( \"$\" + n1 + n2 , end = \"\" )\n", "python_code_tokenized": "def parse_int ( num : int ) : NEW_LINE INDENT to_str = str ( num ) NEW_LINE count = 0 NEW_LINE sumstr = ' ' NEW_LINE for one_str in to_str [ : : - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE if count % 3 == 0 and count != len ( to_str ) : NEW_LINE INDENT one_str = ' , ' + one_str NEW_LINE sumstr = one_str + sumstr NEW_LINE DEDENT else : NEW_LINE INDENT sumstr = one_str + sumstr NEW_LINE DEDENT DEDENT return sumstr NEW_LINE DEDENT n = input ( ) NEW_LINE n1 = n . split ( \" . \" ) [ 0 ] NEW_LINE n2 = \" \" NEW_LINE n1 = parse_int ( abs ( int ( n1 ) ) ) NEW_LINE if n . count ( ' . ' ) > 0 : NEW_LINE INDENT n2 = n . split ( ' . ' ) [ 1 ] [ : 2 ] NEW_LINE if len ( n2 ) < 2 : NEW_LINE INDENT n2 = n2 + \"0\" NEW_LINE DEDENT n2 = \" . \" + n2 NEW_LINE DEDENT else : NEW_LINE INDENT n2 = \" . 00\" NEW_LINE DEDENT if n [ 0 ] == ' - ' : NEW_LINE INDENT print ( \" ( $ \" + n1 + n2 + \" ) \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" $ \" + n1 + n2 , end = \" \" ) NEW_LINE DEDENT"}
{"id": "codejam_14_31", "sol": 0, "python_code": "import functools\nimport multiprocessing\nimport fractions\ndef pow2 ( x ) :\n    return x != 0 and ( ( x & ( x - 1 ) ) == 0 )\ndef solve ( cs , f ) :\n    if not pow2 ( f.denominator ) :\n        return cs , 'impossible'\n    ret = 1\n    while f < fractions.Fraction ( 1 , 2 ) :\n        ret += 1\n        f *= 2\n    return cs , ret\ndef reducer ( l , result ) :\n    l.append ( result )\nif __name__ == '__main__' :\n    T = int ( input ( ) )\n    l = [ ]\n    with multiprocessing.Pool ( processes = 8 ) as pool :\n        for cs in range ( T ) :\n            f = fractions.Fraction ( input ( ) )\n            solve ( cs , f )\n            pool.apply_async ( solve , args = ( cs + 1 , f , ) , callback = functools.partial ( reducer , l ) )\n        pool.close ( )\n        pool.join ( )\n    for cs , result in sorted ( l , key = lambda x : x [ 0 ] ) :\n        print ( 'Case #{}: {}'.format ( cs , result ) )\n", "python_code_tokenized": "import functools NEW_LINE import multiprocessing NEW_LINE import fractions NEW_LINE def pow2 ( x ) : NEW_LINE INDENT return x != 0 and ( ( x & ( x - 1 ) ) == 0 ) NEW_LINE DEDENT def solve ( cs , f ) : NEW_LINE INDENT if not pow2 ( f . denominator ) : NEW_LINE INDENT return cs , ' impossible ' NEW_LINE DEDENT ret = 1 NEW_LINE while f < fractions . Fraction ( 1 , 2 ) : NEW_LINE INDENT ret += 1 NEW_LINE f *= 2 NEW_LINE DEDENT return cs , ret NEW_LINE DEDENT def reducer ( l , result ) : NEW_LINE INDENT l . append ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE with multiprocessing . Pool ( processes = 8 ) as pool : NEW_LINE INDENT for cs in range ( T ) : NEW_LINE INDENT f = fractions . Fraction ( input ( ) ) NEW_LINE solve ( cs , f ) NEW_LINE pool . apply_async ( solve , args = ( cs + 1 , f , ) , callback = functools . partial ( reducer , l ) ) NEW_LINE DEDENT pool . close ( ) NEW_LINE pool . join ( ) NEW_LINE DEDENT for cs , result in sorted ( l , key = lambda x : x [ 0 ] ) : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( cs , result ) ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00736_A", "sol": 0, "python_code": "class Ternary :\n    def __init__ ( self , n ) :\n        self.n = n\n    def __int__ ( self ) :\n        return self.n\n    def __neg__ ( self ) :\n        return Ternary ( 2 - int ( self ) )\n    def __mul__ ( self , o ) :\n        return Ternary ( min ( int ( self ) , int ( o ) ) )\n    def __add__ ( self , o ) :\n        return Ternary ( max ( int ( self ) , int ( o ) ) )\nimport sys , itertools\nfrom functools import reduce\nR = [ 0 , 1 , 2 ]\nwhile True :\n    s = sys.stdin.readline ( ).rstrip ( )\n    if s == '.' : break\n    r = 0\n    for ( a , b , c ) in itertools.product ( R , repeat = 3 ) :\n        t = reduce ( lambda t , e : t.replace ( e [ 0 ] , 'Ternary(%d)' % e [ 1 ] ) , [ [ '0' , 0 ] , [ '1' , 1 ] , [ '2' , 2 ] , [ 'P' , a ] , [ 'Q' , b ] , [ 'R' , c ] ] , s )\n        if int ( eval ( t ) ) == 2 : r += 1\n    print ( r )\n", "python_code_tokenized": "class Ternary : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT def __int__ ( self ) : NEW_LINE INDENT return self . n NEW_LINE DEDENT def __neg__ ( self ) : NEW_LINE INDENT return Ternary ( 2 - int ( self ) ) NEW_LINE DEDENT def __mul__ ( self , o ) : NEW_LINE INDENT return Ternary ( min ( int ( self ) , int ( o ) ) ) NEW_LINE DEDENT def __add__ ( self , o ) : NEW_LINE INDENT return Ternary ( max ( int ( self ) , int ( o ) ) ) NEW_LINE DEDENT DEDENT import sys , itertools NEW_LINE from functools import reduce NEW_LINE R = [ 0 , 1 , 2 ] NEW_LINE while True : NEW_LINE INDENT s = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE if s == ' . ' : break NEW_LINE r = 0 NEW_LINE for ( a , b , c ) in itertools . product ( R , repeat = 3 ) : NEW_LINE INDENT t = reduce ( lambda t , e : t . replace ( e [ 0 ] , ' Ternary ( % d ) ' % e [ 1 ] ) , [ [ '0' , 0 ] , [ '1' , 1 ] , [ '2' , 2 ] , [ ' P ' , a ] , [ ' Q ' , b ] , [ ' R ' , c ] ] , s ) NEW_LINE if int ( eval ( t ) ) == 2 : r += 1 NEW_LINE DEDENT print ( r ) NEW_LINE DEDENT"}
{"id": "codeforces_1176_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    arr = list ( map ( int , input ( ).split ( ) ) )\n    a = [ 0 ] * 3\n    for x in arr :\n        a [ x % 3 ] += 1\n    while a [ 1 ] and a [ 2 ] :\n        a [ 0 ] += 1\n        a [ 1 ] -= 1\n        a [ 2 ] -= 1\n    a [ 0 ] += a [ 1 ] // 3\n    a [ 0 ] += a [ 2 ] // 3\n    print ( a [ 0 ] )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = [ 0 ] * 3 NEW_LINE for x in arr : NEW_LINE INDENT a [ x % 3 ] += 1 NEW_LINE DEDENT while a [ 1 ] and a [ 2 ] : NEW_LINE INDENT a [ 0 ] += 1 NEW_LINE a [ 1 ] -= 1 NEW_LINE a [ 2 ] -= 1 NEW_LINE DEDENT a [ 0 ] += a [ 1 ] // 3 NEW_LINE a [ 0 ] += a [ 2 ] // 3 NEW_LINE print ( a [ 0 ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2379_A", "sol": 0, "python_code": "def countOfMultiples ( n ) :\n    return ( int ( n / 3 ) + int ( n / 5 ) - int ( n / 15 ) ) ;\nprint ( countOfMultiples ( 6 ) )\nprint ( countOfMultiples ( 16 ) )\n", "python_code_tokenized": "def countOfMultiples ( n ) : NEW_LINE INDENT return ( int ( n / 3 ) + int ( n / 5 ) - int ( n / 15 ) ) ; NEW_LINE DEDENT print ( countOfMultiples ( 6 ) ) NEW_LINE print ( countOfMultiples ( 16 ) ) NEW_LINE"}
{"id": "aizu_p01415_A", "sol": 0, "python_code": "N , K , T , U , V , L = map ( int , input ( ).split ( ) )\nans = 0\nl = 0\nt = 0\nk = 0\nfor _ in range ( N + 1 ) :\n    if _ == N :\n        d = L\n    else :\n        d = int ( input ( ) )\n    length = d - l\n    l = d\n    while t > 0 or k > 0 :\n        if t > 0 :\n            if t * V >= length :\n                tmp = ( t * V - length ) / V\n                ans += t - tmp\n                t = tmp\n                if K > k :\n                    k += 1\n                else :\n                    t = T\n                length = 0\n                break\n            else :\n                length = length - t * V\n                ans += t\n                t = 0\n                if k > 0 :\n                    k -= 1\n                    t = T\n        elif k > 0 :\n            k -= 1\n            t = T\n    if length > 0 :\n        ans += length / U\n        if K > k :\n            k += 1\n        else :\n            t = T\nprint ( ans )\n", "python_code_tokenized": "N , K , T , U , V , L = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE l = 0 NEW_LINE t = 0 NEW_LINE k = 0 NEW_LINE for _ in range ( N + 1 ) : NEW_LINE INDENT if _ == N : NEW_LINE INDENT d = L NEW_LINE DEDENT else : NEW_LINE INDENT d = int ( input ( ) ) NEW_LINE DEDENT length = d - l NEW_LINE l = d NEW_LINE while t > 0 or k > 0 : NEW_LINE INDENT if t > 0 : NEW_LINE INDENT if t * V >= length : NEW_LINE INDENT tmp = ( t * V - length ) / V NEW_LINE ans += t - tmp NEW_LINE t = tmp NEW_LINE if K > k : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT t = T NEW_LINE DEDENT length = 0 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT length = length - t * V NEW_LINE ans += t NEW_LINE t = 0 NEW_LINE if k > 0 : NEW_LINE INDENT k -= 1 NEW_LINE t = T NEW_LINE DEDENT DEDENT DEDENT elif k > 0 : NEW_LINE INDENT k -= 1 NEW_LINE t = T NEW_LINE DEDENT DEDENT if length > 0 : NEW_LINE INDENT ans += length / U NEW_LINE if K > k : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT t = T NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_1369_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor testcase in range ( t ) :\n    n = int ( input ( ) )\n    s = input ( )\n    lef , rig , sw = 1 , 1 , 0\n    for i in range ( n - 1 ) :\n        if ( s [ i ] > s [ i + 1 ] ) :\n            sw = 1\n            break\n    if ( sw == 0 ) :\n        print ( s )\n        continue\n    for i in range ( n ) :\n        if ( s [ i ] == '1' ) :\n            lef = i\n            break\n    for i in range ( n - 1 , 0 , - 1 ) :\n        if ( s [ i ] == '0' ) :\n            rig = i\n            break\n    st = s [ : lef ] + '0' + s [ rig + 1 : ]\n    print ( st )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for testcase in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE lef , rig , sw = 1 , 1 , 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT sw = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( sw == 0 ) : NEW_LINE INDENT print ( s ) NEW_LINE continue NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT lef = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT rig = i NEW_LINE break NEW_LINE DEDENT DEDENT st = s [ : lef ] + '0' + s [ rig + 1 : ] NEW_LINE print ( st ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC140_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\na = [ i - 1 for i in a ]\nb = list ( map ( int , input ( ).split ( ) ) )\nc = list ( map ( int , input ( ).split ( ) ) )\nans = 0\nfor i , v in enumerate ( a ) :\n    ans += b [ v ]\n    if i != n - 1 :\n        if a [ i ] + 1 == a [ i + 1 ] :\n            ans += c [ v ]\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = [ i - 1 for i in a ] NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i , v in enumerate ( a ) : NEW_LINE INDENT ans += b [ v ] NEW_LINE if i != n - 1 : NEW_LINE INDENT if a [ i ] + 1 == a [ i + 1 ] : NEW_LINE INDENT ans += c [ v ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_3428_A", "sol": 0, "python_code": "def lis ( arr , n ) :\n    result = 0\n    lis = [ 0 for i in range ( n ) ]\n    for i in range ( n ) :\n        lis [ i ] = 1\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) :\n                lis [ i ] = lis [ j ] + 1\n    for i in range ( n ) :\n        if ( result < lis [ i ] ) :\n            result = lis [ i ]\n    return result\ndef minimumNumberOfDeletions ( arr , n ) :\n    len = lis ( arr , n )\n    return ( n - len )\narr = [ 30 , 40 , 2 , 5 , 1 , 7 , 45 , 50 , 8 ]\nn = len ( arr )\nprint ( \"Minimum number of deletions = \" , minimumNumberOfDeletions ( arr , n ) )\n", "python_code_tokenized": "def lis ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE lis = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( result < lis [ i ] ) : NEW_LINE INDENT result = lis [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def minimumNumberOfDeletions ( arr , n ) : NEW_LINE INDENT len = lis ( arr , n ) NEW_LINE return ( n - len ) NEW_LINE DEDENT arr = [ 30 , 40 , 2 , 5 , 1 , 7 , 45 , 50 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum \u2581 number \u2581 of \u2581 deletions \u2581 = \u2581 \" , minimumNumberOfDeletions ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_52_A", "sol": 0, "python_code": "def primeFactors ( n ) :\n    Prime = [ ] ;\n    if ( n % 2 == 0 ) :\n        Prime.append ( 2 ) ;\n    while ( n % 2 == 0 ) :\n        n = n // 2 ;\n    for i in range ( 3 , int ( n ** ( 1 / 2 ) ) , 2 ) :\n        if ( n % i == 0 ) :\n            Prime.append ( i ) ;\n        while ( n % i == 0 ) :\n            n = n // i ;\n    if ( n > 2 ) :\n        Prime.append ( n ) ;\n    return Prime ;\ndef checkDistinctPrime ( n ) :\n    Prime = primeFactors ( n ) ;\n    product = 1 ;\n    for i in Prime :\n        product *= i ;\n    if ( product == n ) :\n        print ( \"YES\" ) ;\n    else :\n        print ( \"NO\" ) ;\nif __name__ == \"__main__\" :\n    N = 30 ;\n    checkDistinctPrime ( N ) ;\n", "python_code_tokenized": "def primeFactors ( n ) : NEW_LINE INDENT Prime = [ ] ; NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT Prime . append ( 2 ) ; NEW_LINE DEDENT while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 ; NEW_LINE DEDENT for i in range ( 3 , int ( n ** ( 1 / 2 ) ) , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT Prime . append ( i ) ; NEW_LINE DEDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n // i ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT Prime . append ( n ) ; NEW_LINE DEDENT return Prime ; NEW_LINE DEDENT def checkDistinctPrime ( n ) : NEW_LINE INDENT Prime = primeFactors ( n ) ; NEW_LINE product = 1 ; NEW_LINE for i in Prime : NEW_LINE INDENT product *= i ; NEW_LINE DEDENT if ( product == n ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 30 ; NEW_LINE checkDistinctPrime ( N ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1064_A", "sol": 0, "python_code": "a , b , c = map ( int , input ( ).split ( ) )\ns = a + b + c\np = min ( a , b , c )\nq = max ( a , b , c )\nr = s - ( p + q )\nt = p + r\nif t > q :\n    print ( 0 )\nelse :\n    print ( q - t + 1 )\n", "python_code_tokenized": "a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE s = a + b + c NEW_LINE p = min ( a , b , c ) NEW_LINE q = max ( a , b , c ) NEW_LINE r = s - ( p + q ) NEW_LINE t = p + r NEW_LINE if t > q : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( q - t + 1 ) NEW_LINE DEDENT"}
{"id": "codeforces_1606_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    s = input ( )\n    n = len ( s )\n    count_ab = 0\n    count_ba = 0\n    for i in range ( n - 1 ) :\n        if s [ i ] + s [ i + 1 ] == 'ab' :\n            count_ab += 1\n        elif s [ i ] + s [ i + 1 ] == 'ba' :\n            count_ba += 1\n    if count_ba == count_ab :\n        print ( s )\n    elif count_ab > count_ba :\n        a = list ( s )\n        if s [ 0 ] + s [ 1 ] == 'ab' :\n            a [ 0 ] = \"b\"\n            print ( \"\".join ( a ) )\n        else :\n            a [ n - 1 ] = \"a\"\n            print ( \"\".join ( a ) )\n    else :\n        a = list ( s )\n        if s [ 0 ] + s [ 1 ] == 'ba' :\n            a [ 0 ] = \"a\"\n            print ( \"\".join ( a ) )\n        else :\n            a [ n - 1 ] = \"b\"\n            print ( \"\".join ( a ) )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE n = len ( s ) NEW_LINE count_ab = 0 NEW_LINE count_ba = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] + s [ i + 1 ] == ' ab ' : NEW_LINE INDENT count_ab += 1 NEW_LINE DEDENT elif s [ i ] + s [ i + 1 ] == ' ba ' : NEW_LINE INDENT count_ba += 1 NEW_LINE DEDENT DEDENT if count_ba == count_ab : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT elif count_ab > count_ba : NEW_LINE INDENT a = list ( s ) NEW_LINE if s [ 0 ] + s [ 1 ] == ' ab ' : NEW_LINE INDENT a [ 0 ] = \" b \" NEW_LINE print ( \" \" . join ( a ) ) NEW_LINE DEDENT else : NEW_LINE INDENT a [ n - 1 ] = \" a \" NEW_LINE print ( \" \" . join ( a ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT a = list ( s ) NEW_LINE if s [ 0 ] + s [ 1 ] == ' ba ' : NEW_LINE INDENT a [ 0 ] = \" a \" NEW_LINE print ( \" \" . join ( a ) ) NEW_LINE DEDENT else : NEW_LINE INDENT a [ n - 1 ] = \" b \" NEW_LINE print ( \" \" . join ( a ) ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_3348_A", "sol": 0, "python_code": "import sys\ndef isPowerOf ( val , base ) :\n    while ( val > 1 ) :\n        if ( val % base != 0 ) :\n            return False\n        val //= base\n    return True\ndef numberOfPartitions ( binaryNo ) :\n    n = len ( binaryNo )\n    dp = [ 0 ] * n\n    if ( ( ord ( binaryNo [ n - 1 ] ) - ord ( '0' ) ) == 0 ) :\n        dp [ n - 1 ] = - 1\n    else :\n        dp [ n - 1 ] = 1\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        val = 0\n        if ( ( ord ( binaryNo [ i ] ) - ord ( '0' ) ) == 0 ) :\n            dp [ i ] = - 1\n            continue\n        dp [ i ] = sys.maxsize\n        for j in range ( i , n ) :\n            val = ( val * 2 ) + ( ord ( binaryNo [ j ] ) - ord ( '0' ) )\n            if ( isPowerOf ( val , 4 ) or isPowerOf ( val , 6 ) ) :\n                if ( j == n - 1 ) :\n                    dp [ i ] = 1\n                else :\n                    if ( dp [ j + 1 ] != - 1 ) :\n                        dp [ i ] = min ( dp [ i ] , dp [ j + 1 ] + 1 )\n        if ( dp [ i ] == sys.maxsize ) :\n            dp [ i ] = - 1\n    return dp [ 0 ]\nif __name__ == \"__main__\" :\n    binaryNo = \"100110110\"\n    print ( numberOfPartitions ( binaryNo ) )\n", "python_code_tokenized": "import sys NEW_LINE def isPowerOf ( val , base ) : NEW_LINE INDENT while ( val > 1 ) : NEW_LINE INDENT if ( val % base != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT val //= base NEW_LINE DEDENT return True NEW_LINE DEDENT def numberOfPartitions ( binaryNo ) : NEW_LINE INDENT n = len ( binaryNo ) NEW_LINE dp = [ 0 ] * n NEW_LINE if ( ( ord ( binaryNo [ n - 1 ] ) - ord ( '0' ) ) == 0 ) : NEW_LINE INDENT dp [ n - 1 ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ n - 1 ] = 1 NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT val = 0 NEW_LINE if ( ( ord ( binaryNo [ i ] ) - ord ( '0' ) ) == 0 ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE continue NEW_LINE DEDENT dp [ i ] = sys . maxsize NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT val = ( val * 2 ) + ( ord ( binaryNo [ j ] ) - ord ( '0' ) ) NEW_LINE if ( isPowerOf ( val , 4 ) or isPowerOf ( val , 6 ) ) : NEW_LINE INDENT if ( j == n - 1 ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( dp [ j + 1 ] != - 1 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ j + 1 ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( dp [ i ] == sys . maxsize ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT binaryNo = \"100110110\" NEW_LINE print ( numberOfPartitions ( binaryNo ) ) NEW_LINE DEDENT"}
{"id": "codeforces_479_B", "sol": 0, "python_code": "def main ( ) :\n    n , k = map ( int , input ( ).split ( ) )\n    towers = list ( map ( int , input ( ).split ( ) ) )\n    min_i = 0\n    max_i = n - 1\n    operations = [ ]\n    for i in range ( k ) :\n        for i in range ( n ) :\n            if towers [ i ] > towers [ max_i ] : max_i = i\n            if towers [ i ] < towers [ min_i ] : min_i = i\n        if towers [ max_i ] - 1 <= towers [ min_i ] :\n            break\n        towers [ max_i ] -= 1\n        towers [ min_i ] += 1\n        operations.append ( ( max_i + 1 , min_i + 1 ) )\n    for i in range ( n ) :\n        if towers [ i ] > towers [ max_i ] : max_i = i\n        if towers [ i ] < towers [ min_i ] : min_i = i\n    print ( towers [ max_i ] - towers [ min_i ] , len ( operations ) )\n    for op in operations :\n        print ( op [ 0 ] , op [ 1 ] )\nmain ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE towers = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE min_i = 0 NEW_LINE max_i = n - 1 NEW_LINE operations = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if towers [ i ] > towers [ max_i ] : max_i = i NEW_LINE if towers [ i ] < towers [ min_i ] : min_i = i NEW_LINE DEDENT if towers [ max_i ] - 1 <= towers [ min_i ] : NEW_LINE INDENT break NEW_LINE DEDENT towers [ max_i ] -= 1 NEW_LINE towers [ min_i ] += 1 NEW_LINE operations . append ( ( max_i + 1 , min_i + 1 ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if towers [ i ] > towers [ max_i ] : max_i = i NEW_LINE if towers [ i ] < towers [ min_i ] : min_i = i NEW_LINE DEDENT print ( towers [ max_i ] - towers [ min_i ] , len ( operations ) ) NEW_LINE for op in operations : NEW_LINE INDENT print ( op [ 0 ] , op [ 1 ] ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_125_A", "sol": 0, "python_code": "def pow ( x , y ) :\n    if ( y == 1 ) :\n        return x\n    if ( y == 0 ) :\n        return 1\n    temp = pow ( x , y // 2 )\n    temp *= temp\n    if ( y & 1 ) :\n        temp *= x\n    return temp\ndef noOfPermutations ( a , n ) :\n    if ( n == 1 ) :\n        return 1\n    a.sort ( )\n    if ( a [ n - 1 ] == a [ n - 2 ] ) :\n        return 0\n    x = 0\n    for i in range ( n - 2 ) :\n        if ( a [ i ] == a [ i + 1 ] ) :\n            if ( a [ i ] == a [ i + 2 ] ) :\n                return 0\n            x += 1\n            i += 1\n    return pow ( 2 , n - 2 * x - 1 )\nif __name__ == \"__main__\" :\n    a = [ 1 , 2 , 2 , 3 , 4 ]\n    n = len ( a )\n    num = noOfPermutations ( a , n )\n    print ( num )\n", "python_code_tokenized": "def pow ( x , y ) : NEW_LINE INDENT if ( y == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = pow ( x , y // 2 ) NEW_LINE temp *= temp NEW_LINE if ( y & 1 ) : NEW_LINE INDENT temp *= x NEW_LINE DEDENT return temp NEW_LINE DEDENT def noOfPermutations ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT a . sort ( ) NEW_LINE if ( a [ n - 1 ] == a [ n - 2 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT x = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 2 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT x += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return pow ( 2 , n - 2 * x - 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 2 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE num = noOfPermutations ( a , n ) NEW_LINE print ( num ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1935_A", "sol": 0, "python_code": "def KthCharacter ( m , n , k ) :\n    distance = pow ( 2 , n )\n    Block_number = int ( k / distance )\n    remaining = k % distance\n    s = [ 0 ] * 32\n    x = 0\n    while ( m > 0 ) :\n        s [ x ] = m % 2\n        m = int ( m / 2 )\n        x += 1\n    root = s [ x - 1 - Block_number ]\n    if ( remaining == 0 ) :\n        print ( root )\n        return\n    flip = True\n    while ( remaining > 1 ) :\n        if ( remaining & 1 ) :\n            flip = not ( flip )\n        remaining = remaining >> 1\n    if ( flip ) :\n        print ( not ( root ) )\n    else :\n        print ( root )\nm = 5\nk = 5\nn = 3\nKthCharacter ( m , n , k )\n", "python_code_tokenized": "def KthCharacter ( m , n , k ) : NEW_LINE INDENT distance = pow ( 2 , n ) NEW_LINE Block_number = int ( k / distance ) NEW_LINE remaining = k % distance NEW_LINE s = [ 0 ] * 32 NEW_LINE x = 0 NEW_LINE while ( m > 0 ) : NEW_LINE INDENT s [ x ] = m % 2 NEW_LINE m = int ( m / 2 ) NEW_LINE x += 1 NEW_LINE DEDENT root = s [ x - 1 - Block_number ] NEW_LINE if ( remaining == 0 ) : NEW_LINE INDENT print ( root ) NEW_LINE return NEW_LINE DEDENT flip = True NEW_LINE while ( remaining > 1 ) : NEW_LINE INDENT if ( remaining & 1 ) : NEW_LINE INDENT flip = not ( flip ) NEW_LINE DEDENT remaining = remaining >> 1 NEW_LINE DEDENT if ( flip ) : NEW_LINE INDENT print ( not ( root ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( root ) NEW_LINE DEDENT DEDENT m = 5 NEW_LINE k = 5 NEW_LINE n = 3 NEW_LINE KthCharacter ( m , n , k ) NEW_LINE"}
{"id": "geeksforgeeks_3677_A", "sol": 0, "python_code": "def printRect ( X , Y , n ) :\n    Xmax = max ( X )\n    Xmin = min ( X )\n    Ymax = max ( Y )\n    Ymin = min ( Y )\n    print ( \"{\" , Xmin , \", \" , Ymin , \"}\" , sep = \"\" )\n    print ( \"{\" , Xmin , \", \" , Ymax , \"}\" , sep = \"\" )\n    print ( \"{\" , Xmax , \", \" , Ymax , \"}\" , sep = \"\" )\n    print ( \"{\" , Xmax , \", \" , Ymin , \"}\" , sep = \"\" )\nX = [ 4 , 3 , 6 , 1 , - 1 , 12 ]\nY = [ 4 , 1 , 10 , 3 , 7 , - 1 ]\nn = len ( X )\nprintRect ( X , Y , n )\n", "python_code_tokenized": "def printRect ( X , Y , n ) : NEW_LINE INDENT Xmax = max ( X ) NEW_LINE Xmin = min ( X ) NEW_LINE Ymax = max ( Y ) NEW_LINE Ymin = min ( Y ) NEW_LINE print ( \" { \" , Xmin , \" , \u2581 \" , Ymin , \" } \" , sep = \" \" ) NEW_LINE print ( \" { \" , Xmin , \" , \u2581 \" , Ymax , \" } \" , sep = \" \" ) NEW_LINE print ( \" { \" , Xmax , \" , \u2581 \" , Ymax , \" } \" , sep = \" \" ) NEW_LINE print ( \" { \" , Xmax , \" , \u2581 \" , Ymin , \" } \" , sep = \" \" ) NEW_LINE DEDENT X = [ 4 , 3 , 6 , 1 , - 1 , 12 ] NEW_LINE Y = [ 4 , 1 , 10 , 3 , 7 , - 1 ] NEW_LINE n = len ( X ) NEW_LINE printRect ( X , Y , n ) NEW_LINE"}
{"id": "geeksforgeeks_2732_A", "sol": 0, "python_code": "def prefix ( string ) :\n    k = 1 ;\n    n = len ( string ) ;\n    g = [ ] ;\n    flag = 0 ;\n    for i in range ( 1 , n ) :\n        if ( string [ i ] == string [ 0 ] ) :\n            g.append ( i ) ;\n            flag = 1 ;\n    if ( flag == 0 ) :\n        print ( string ) ;\n    else :\n        length = len ( g ) ;\n        while ( k < g [ 0 ] ) :\n            cnt = 0 ;\n            for j in range ( length ) :\n                if ( string [ g [ j ] + k ] == string [ k ] ) :\n                    cnt += 1 ;\n            if ( cnt == len ) :\n                k += 1 ;\n            else :\n                break ;\n        for i in range ( k + 1 ) :\n            print ( string [ i ] , end = \"\" ) ;\n        print ( )\nif __name__ == \"__main__\" :\n    string = \"abcab\" ;\n    prefix ( string ) ;\n", "python_code_tokenized": "def prefix ( string ) : NEW_LINE INDENT k = 1 ; NEW_LINE n = len ( string ) ; NEW_LINE g = [ ] ; NEW_LINE flag = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( string [ i ] == string [ 0 ] ) : NEW_LINE INDENT g . append ( i ) ; NEW_LINE flag = 1 ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( string ) ; NEW_LINE DEDENT else : NEW_LINE INDENT length = len ( g ) ; NEW_LINE while ( k < g [ 0 ] ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for j in range ( length ) : NEW_LINE INDENT if ( string [ g [ j ] + k ] == string [ k ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT if ( cnt == len ) : NEW_LINE INDENT k += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT for i in range ( k + 1 ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) ; NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcab \" ; NEW_LINE prefix ( string ) ; NEW_LINE DEDENT"}
{"id": "codeforces_920_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    now = - 1\n    for i in range ( n ) :\n        l , r = map ( int , input ( ).split ( ) )\n        if now <= l :\n            print ( l , end = ' ' )\n            now = l + 1\n        elif now <= r :\n            print ( now , end = ' ' )\n            now += 1\n        else :\n            print ( 0 , end = ' ' )\n    print ( )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE now = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE if now <= l : NEW_LINE INDENT print ( l , end = ' \u2581 ' ) NEW_LINE now = l + 1 NEW_LINE DEDENT elif now <= r : NEW_LINE INDENT print ( now , end = ' \u2581 ' ) NEW_LINE now += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = ' \u2581 ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5222_A", "sol": 0, "python_code": "def printCubeFree ( n ) :\n    cubFree = [ 1 ] * ( n + 1 ) ;\n    i = 2 ;\n    while ( i * i * i <= n ) :\n        if ( cubFree [ i ] == 1 ) :\n            multiple = 1 ;\n            while ( i * i * i * multiple <= n ) :\n                cubFree [ i * i * i * multiple ] = 0 ;\n                multiple += 1 ;\n        i += 1 ;\n    for i in range ( 2 , n + 1 ) :\n        if ( cubFree [ i ] == 1 ) :\n            print ( i , end = \" \" ) ;\nif __name__ == \"__main__\" :\n    printCubeFree ( 20 ) ;\n", "python_code_tokenized": "def printCubeFree ( n ) : NEW_LINE INDENT cubFree = [ 1 ] * ( n + 1 ) ; NEW_LINE i = 2 ; NEW_LINE while ( i * i * i <= n ) : NEW_LINE INDENT if ( cubFree [ i ] == 1 ) : NEW_LINE INDENT multiple = 1 ; NEW_LINE while ( i * i * i * multiple <= n ) : NEW_LINE INDENT cubFree [ i * i * i * multiple ] = 0 ; NEW_LINE multiple += 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( cubFree [ i ] == 1 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT printCubeFree ( 20 ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5280_A", "sol": 0, "python_code": "import math as mt\nMAX = 100001\nprime = [ 0 for i in range ( MAX + 1 ) ]\ncountdiv = [ 0 for i in range ( MAX + 1 ) ]\ndef SieveOfEratosthenes ( ) :\n    for i in range ( 2 , mt.ceil ( mt.sqrt ( MAX + 1 ) ) ) :\n        if ( prime [ i ] == 0 ) :\n            for j in range ( i * 2 , MAX + 1 , i ) :\n                prime [ j ] = i\n    for i in range ( 1 , MAX ) :\n        if ( prime [ i ] == 0 ) :\n            prime [ i ] = i\ndef largestGCDSubsequence ( arr , n ) :\n    ans = 0\n    for i in range ( n ) :\n        element = arr [ i ]\n        while ( element > 1 ) :\n            div = prime [ element ]\n            countdiv [ div ] += 1\n            ans = max ( ans , countdiv [ div ] )\n            while ( element % div == 0 ) :\n                element = element // div\n    return ans\nSieveOfEratosthenes ( )\narr = [ 10 , 15 , 7 , 25 , 9 , 35 ]\nsize = len ( arr )\nprint ( largestGCDSubsequence ( arr , size ) )\n", "python_code_tokenized": "import math as mt NEW_LINE MAX = 100001 NEW_LINE prime = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE countdiv = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( 2 , mt . ceil ( mt . sqrt ( MAX + 1 ) ) ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT prime [ i ] = i NEW_LINE DEDENT DEDENT DEDENT def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT element = arr [ i ] NEW_LINE while ( element > 1 ) : NEW_LINE INDENT div = prime [ element ] NEW_LINE countdiv [ div ] += 1 NEW_LINE ans = max ( ans , countdiv [ div ] ) NEW_LINE while ( element % div == 0 ) : NEW_LINE INDENT element = element // div NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE arr = [ 10 , 15 , 7 , 25 , 9 , 35 ] NEW_LINE size = len ( arr ) NEW_LINE print ( largestGCDSubsequence ( arr , size ) ) NEW_LINE"}
{"id": "codejam_11_04", "sol": 0, "python_code": "data = [ l.strip ( ) for l in open ( \"infile\" , \"r\" ).readlines ( ) ]\nout = open ( \"outfile\" , \"w\" )\nncases = int ( data.pop ( 0 ) )\nfor case in range ( ncases ) :\n    numelements = int ( data.pop ( 0 ) )\n    elements = [ int ( s ) for s in data.pop ( 0 ).split ( ' ' ) ]\n    inwrongplace = 0\n    for i in range ( len ( elements ) ) :\n        if elements [ i ] != i + 1 :\n            inwrongplace += 1\n    out.write ( \"Case #\" + str ( case + 1 ) + \": \" + str ( \"%.6f\" % inwrongplace ) + \"\\n\" )\n", "python_code_tokenized": "data = [ l . strip ( ) for l in open ( \" infile \" , \" r \" ) . readlines ( ) ] NEW_LINE out = open ( \" outfile \" , \" w \" ) NEW_LINE ncases = int ( data . pop ( 0 ) ) NEW_LINE for case in range ( ncases ) : NEW_LINE INDENT numelements = int ( data . pop ( 0 ) ) NEW_LINE elements = [ int ( s ) for s in data . pop ( 0 ) . split ( ' \u2581 ' ) ] NEW_LINE inwrongplace = 0 NEW_LINE for i in range ( len ( elements ) ) : NEW_LINE INDENT if elements [ i ] != i + 1 : NEW_LINE INDENT inwrongplace += 1 NEW_LINE DEDENT DEDENT out . write ( \" Case \u2581 # \" + str ( case + 1 ) + \" : \u2581 \" + str ( \" % .6f \" % inwrongplace ) + \" \\n \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3794_A", "sol": 0, "python_code": "MAX = 100001 ;\ndef find_distinct ( a , n , q , queries ) :\n    check = [ 0 ] * MAX ;\n    idx = [ 0 ] * MAX ;\n    cnt = 1 ;\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        if ( check [ a [ i ] ] == 0 ) :\n            idx [ i ] = cnt ;\n            check [ a [ i ] ] = 1 ;\n            cnt += 1 ;\n        else :\n            idx [ i ] = cnt - 1 ;\n    for i in range ( 0 , q ) :\n        m = queries [ i ] ;\n        print ( idx [ m ] , end = \" \" ) ;\na = [ 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 ] ;\nn = len ( a ) ;\nqueries = [ 0 , 3 , 5 , 7 ] ;\nq = len ( queries ) ;\nfind_distinct ( a , n , q , queries ) ;\n", "python_code_tokenized": "MAX = 100001 ; NEW_LINE def find_distinct ( a , n , q , queries ) : NEW_LINE INDENT check = [ 0 ] * MAX ; NEW_LINE idx = [ 0 ] * MAX ; NEW_LINE cnt = 1 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( check [ a [ i ] ] == 0 ) : NEW_LINE INDENT idx [ i ] = cnt ; NEW_LINE check [ a [ i ] ] = 1 ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT idx [ i ] = cnt - 1 ; NEW_LINE DEDENT DEDENT for i in range ( 0 , q ) : NEW_LINE INDENT m = queries [ i ] ; NEW_LINE print ( idx [ m ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( a ) ; NEW_LINE queries = [ 0 , 3 , 5 , 7 ] ; NEW_LINE q = len ( queries ) ; NEW_LINE find_distinct ( a , n , q , queries ) ; NEW_LINE"}
{"id": "geeksforgeeks_5106_A", "sol": 0, "python_code": "def findCombinationsUtil ( arr , index , num , reducedNum ) :\n    if ( reducedNum < 0 ) :\n        return ;\n    if ( reducedNum == 0 ) :\n        for i in range ( index ) :\n            print ( arr [ i ] , end = \"\" ) ;\n        print ( \"\" ) ;\n        return ;\n    prev = 1 if ( index == 0 ) else arr [ index - 1 ] ;\n    for k in range ( prev , num + 1 ) :\n        arr [ index ] = k ;\n        findCombinationsUtil ( arr , index + 1 , num , reducedNum - k ) ;\ndef findCombinations ( n ) :\n    arr = [ 0 ] * n ;\n    findCombinationsUtil ( arr , 0 , n , n ) ;\nn = 5 ;\nfindCombinations ( n ) ;\n", "python_code_tokenized": "def findCombinationsUtil ( arr , index , num , reducedNum ) : NEW_LINE INDENT if ( reducedNum < 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT if ( reducedNum == 0 ) : NEW_LINE INDENT for i in range ( index ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT prev = 1 if ( index == 0 ) else arr [ index - 1 ] ; NEW_LINE for k in range ( prev , num + 1 ) : NEW_LINE INDENT arr [ index ] = k ; NEW_LINE findCombinationsUtil ( arr , index + 1 , num , reducedNum - k ) ; NEW_LINE DEDENT DEDENT def findCombinations ( n ) : NEW_LINE INDENT arr = [ 0 ] * n ; NEW_LINE findCombinationsUtil ( arr , 0 , n , n ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE findCombinations ( n ) ; NEW_LINE"}
{"id": "geeksforgeeks_252_A", "sol": 0, "python_code": "def nextGap ( gap ) :\n    if ( gap <= 1 ) :\n        return 0 ;\n    res = ( gap // 2 ) + ( gap % 2 ) ;\n    return res ;\ndef mergeTwoSortedArray ( arr1 , arr2 , n , m ) :\n    x = min ( n , m ) ;\n    for i in range ( x ) :\n        if ( arr1 [ n - i - 1 ] > arr2 [ i ] ) :\n            arr1 [ n - i - 1 ] , arr2 [ i ] = arr2 [ i ] , arr1 [ n - i - 1 ] ;\n    gap = nextGap ( n ) ;\n    while gap > 0 :\n        i = 0 ;\n        while i + gap < n :\n            if ( arr1 [ i ] > arr1 [ i + gap ] ) :\n                arr1 [ i ] , arr1 [ i + gap ] = arr1 [ i + gap ] , arr1 [ i ] ;\n            i += 1 ;\n        gap = nextGap ( gap )\n    gap = nextGap ( m ) ;\n    while gap > 0 :\n        i = 0\n        while i + gap < m :\n            if ( arr2 [ i ] > arr2 [ i + gap ] ) :\n                arr2 [ i ] , arr2 [ i + gap ] = arr2 [ i + gap ] , arr2 [ i ] ;\n            i += 1 ;\n        gap = nextGap ( gap )\n    for i in range ( n ) :\n        print ( arr1 [ i ] , end = \" \" ) ;\n    for j in range ( m ) :\n        print ( arr2 [ j ] , end = \" \" ) ;\nif __name__ == \"__main__\" :\n    arr1 = [ 1 , 5 , 9 , 10 , 15 , 20 ] ;\n    n = len ( arr1 ) ;\n    arr2 = [ 2 , 3 , 8 , 13 ] ;\n    m = len ( arr2 ) ;\n    mergeTwoSortedArray ( arr1 , arr2 , n , m ) ;\n", "python_code_tokenized": "def nextGap ( gap ) : NEW_LINE INDENT if ( gap <= 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT res = ( gap // 2 ) + ( gap % 2 ) ; NEW_LINE return res ; NEW_LINE DEDENT def mergeTwoSortedArray ( arr1 , arr2 , n , m ) : NEW_LINE INDENT x = min ( n , m ) ; NEW_LINE for i in range ( x ) : NEW_LINE INDENT if ( arr1 [ n - i - 1 ] > arr2 [ i ] ) : NEW_LINE INDENT arr1 [ n - i - 1 ] , arr2 [ i ] = arr2 [ i ] , arr1 [ n - i - 1 ] ; NEW_LINE DEDENT DEDENT gap = nextGap ( n ) ; NEW_LINE while gap > 0 : NEW_LINE INDENT i = 0 ; NEW_LINE while i + gap < n : NEW_LINE INDENT if ( arr1 [ i ] > arr1 [ i + gap ] ) : NEW_LINE INDENT arr1 [ i ] , arr1 [ i + gap ] = arr1 [ i + gap ] , arr1 [ i ] ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT gap = nextGap ( gap ) NEW_LINE DEDENT gap = nextGap ( m ) ; NEW_LINE while gap > 0 : NEW_LINE INDENT i = 0 NEW_LINE while i + gap < m : NEW_LINE INDENT if ( arr2 [ i ] > arr2 [ i + gap ] ) : NEW_LINE INDENT arr2 [ i ] , arr2 [ i + gap ] = arr2 [ i + gap ] , arr2 [ i ] ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT gap = nextGap ( gap ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT for j in range ( m ) : NEW_LINE INDENT print ( arr2 [ j ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 1 , 5 , 9 , 10 , 15 , 20 ] ; NEW_LINE n = len ( arr1 ) ; NEW_LINE arr2 = [ 2 , 3 , 8 , 13 ] ; NEW_LINE m = len ( arr2 ) ; NEW_LINE mergeTwoSortedArray ( arr1 , arr2 , n , m ) ; NEW_LINE DEDENT"}
{"id": "aizu_p00769_A", "sol": 0, "python_code": "def parser ( l , r ) :\n    if all ( S [ i ].isdigit ( ) for i in range ( l , r + 1 ) ) :\n        return int ( S [ l : r + 1 ] ) // 2 + 1\n    ret = [ ]\n    cnt = 0\n    start = 0\n    for i in range ( l , r + 1 ) :\n        if S [ i ] == '[' :\n            cnt += 1\n            if cnt == 1 :\n                start = i\n        elif S [ i ] == ']' :\n            if cnt == 1 :\n                ret.append ( parser ( start + 1 , i - 1 ) )\n            cnt -= 1\n    ret.sort ( )\n    return sum ( ret [ : len ( ret ) // 2 + 1 ] )\nN = int ( input ( ) )\nfor _ in range ( N ) :\n    S = input ( )\n    print ( parser ( 0 , len ( S ) - 1 ) )\n", "python_code_tokenized": "def parser ( l , r ) : NEW_LINE INDENT if all ( S [ i ] . isdigit ( ) for i in range ( l , r + 1 ) ) : NEW_LINE INDENT return int ( S [ l : r + 1 ] ) // 2 + 1 NEW_LINE DEDENT ret = [ ] NEW_LINE cnt = 0 NEW_LINE start = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if S [ i ] == ' [ ' : NEW_LINE INDENT cnt += 1 NEW_LINE if cnt == 1 : NEW_LINE INDENT start = i NEW_LINE DEDENT DEDENT elif S [ i ] == ' ] ' : NEW_LINE INDENT if cnt == 1 : NEW_LINE INDENT ret . append ( parser ( start + 1 , i - 1 ) ) NEW_LINE DEDENT cnt -= 1 NEW_LINE DEDENT DEDENT ret . sort ( ) NEW_LINE return sum ( ret [ : len ( ret ) // 2 + 1 ] ) NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE for _ in range ( N ) : NEW_LINE INDENT S = input ( ) NEW_LINE print ( parser ( 0 , len ( S ) - 1 ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1632_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor qwe in range ( t ) :\n    input ( )\n    s = input ( )\n    if len ( s ) == 1 :\n        print ( \"YES\" )\n        continue\n    if len ( s ) == 2 :\n        if s == \"11\" or s == \"00\" :\n            print ( \"NO\" )\n        else :\n            print ( \"YES\" )\n        continue\n    print ( \"NO\" )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for qwe in range ( t ) : NEW_LINE INDENT input ( ) NEW_LINE s = input ( ) NEW_LINE if len ( s ) == 1 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE continue NEW_LINE DEDENT if len ( s ) == 2 : NEW_LINE INDENT if s == \"11\" or s == \"00\" : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT continue NEW_LINE DEDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC098_C", "sol": 0, "python_code": "import sys\nimport math\nfrom fractions import gcd\nfrom itertools import accumulate\ndef lcm ( a , b ) :\n    return a * b // gcd ( a , b )\ndef combination_count ( n , r ) :\n    return math.factorial ( n ) // ( math.factorial ( n - r ) * math.factorial ( r ) )\ndef permutations_count ( n , r ) :\n    return math.factorial ( n ) // math.factorial ( n - r )\nbig_prime = 1000000007\nN = int ( sys.stdin.readline ( ) )\nS = list ( sys.stdin.readline ( ).rstrip ( ) )\nWn = [ 0 ] * N\nEn = [ 0 ] * N\nWc = 0\nEc = 0\nfor i , s in enumerate ( S ) :\n    if s == \"W\" :\n        Wc += 1\n    else :\n        Ec += 1\n    Wn [ i ] = Wc\n    En [ i ] = Ec\nans = 10 ** 10\nWn = [ 0 ] + Wn\nEn = [ 0 ] + En\nfor i , ( w , e ) in enumerate ( zip ( Wn [ 1 : : ] , En [ 1 : : ] ) ) :\n    ans = min ( Wn [ i ] + En [ N ] - En [ i + 1 ] , ans )\nprint ( ans )\n", "python_code_tokenized": "import sys NEW_LINE import math NEW_LINE from fractions import gcd NEW_LINE from itertools import accumulate NEW_LINE def lcm ( a , b ) : NEW_LINE INDENT return a * b // gcd ( a , b ) NEW_LINE DEDENT def combination_count ( n , r ) : NEW_LINE INDENT return math . factorial ( n ) // ( math . factorial ( n - r ) * math . factorial ( r ) ) NEW_LINE DEDENT def permutations_count ( n , r ) : NEW_LINE INDENT return math . factorial ( n ) // math . factorial ( n - r ) NEW_LINE DEDENT big_prime = 1000000007 NEW_LINE N = int ( sys . stdin . readline ( ) ) NEW_LINE S = list ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE Wn = [ 0 ] * N NEW_LINE En = [ 0 ] * N NEW_LINE Wc = 0 NEW_LINE Ec = 0 NEW_LINE for i , s in enumerate ( S ) : NEW_LINE INDENT if s == \" W \" : NEW_LINE INDENT Wc += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Ec += 1 NEW_LINE DEDENT Wn [ i ] = Wc NEW_LINE En [ i ] = Ec NEW_LINE DEDENT ans = 10 ** 10 NEW_LINE Wn = [ 0 ] + Wn NEW_LINE En = [ 0 ] + En NEW_LINE for i , ( w , e ) in enumerate ( zip ( Wn [ 1 : : ] , En [ 1 : : ] ) ) : NEW_LINE INDENT ans = min ( Wn [ i ] + En [ N ] - En [ i + 1 ] , ans ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_5279_A", "sol": 0, "python_code": "def largestGCDSubsequence ( arr , n ) :\n    ans = 0\n    maxele = max ( arr )\n    for i in range ( 2 , maxele + 1 ) :\n        count = 0\n        for j in range ( n ) :\n            if ( arr [ j ] % i == 0 ) :\n                count += 1\n        ans = max ( ans , count )\n    return ans\nif __name__ == '__main__' :\n    arr = [ 3 , 6 , 2 , 5 , 4 ]\n    size = len ( arr )\n    print ( largestGCDSubsequence ( arr , size ) )\n", "python_code_tokenized": "def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxele = max ( arr ) NEW_LINE for i in range ( 2 , maxele + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 6 , 2 , 5 , 4 ] NEW_LINE size = len ( arr ) NEW_LINE print ( largestGCDSubsequence ( arr , size ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1393_B", "sol": 0, "python_code": "from collections import Counter\nn = int ( input ( ) )\narr = list ( map ( int , input ( ).split ( ) ) )\ncount = dict ( Counter ( arr ) )\ntwo = 0\nfour = 0\nfor i in count.values ( ) :\n    two += i // 2\n    four += i // 4\nt = int ( input ( ) )\nwhile t :\n    t -= 1\n    operation , stick = input ( ).split ( )\n    stick = int ( stick )\n    if operation == \"+\" :\n        if stick in count :\n            count [ stick ] += 1\n        else :\n            count [ stick ] = 1\n        if count [ stick ] % 2 == 0 :\n            two += 1\n        if count [ stick ] % 4 == 0 :\n            four += 1\n    else :\n        if count [ stick ] % 2 == 0 :\n            two -= 1\n        if count [ stick ] % 4 == 0 :\n            four -= 1\n        count [ stick ] -= 1\n    if two >= 4 and four >= 1 :\n        print ( 'YES' )\n    else :\n        print ( 'NO' )\n", "python_code_tokenized": "from collections import Counter NEW_LINE n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = dict ( Counter ( arr ) ) NEW_LINE two = 0 NEW_LINE four = 0 NEW_LINE for i in count . values ( ) : NEW_LINE INDENT two += i // 2 NEW_LINE four += i // 4 NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE operation , stick = input ( ) . split ( ) NEW_LINE stick = int ( stick ) NEW_LINE if operation == \" + \" : NEW_LINE INDENT if stick in count : NEW_LINE INDENT count [ stick ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ stick ] = 1 NEW_LINE DEDENT if count [ stick ] % 2 == 0 : NEW_LINE INDENT two += 1 NEW_LINE DEDENT if count [ stick ] % 4 == 0 : NEW_LINE INDENT four += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if count [ stick ] % 2 == 0 : NEW_LINE INDENT two -= 1 NEW_LINE DEDENT if count [ stick ] % 4 == 0 : NEW_LINE INDENT four -= 1 NEW_LINE DEDENT count [ stick ] -= 1 NEW_LINE DEDENT if two >= 4 and four >= 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_517_A", "sol": 0, "python_code": "import math\ndef isPrime ( n ) :\n    if ( n <= 1 ) :\n        return False\n    if ( n <= 3 ) :\n        return True\n    if ( n % 2 == 0 or n % 3 == 0 ) :\n        return False\n    for i in range ( 5 , int ( math.sqrt ( n ) + 1 ) , 6 ) :\n        if ( n % i == 0 or n % ( i + 2 ) == 0 ) :\n            return False\n    return True\ndef nextPrime ( N ) :\n    if ( N <= 1 ) :\n        return 2\n    prime = N\n    found = False\n    while ( not found ) :\n        prime = prime + 1\n        if ( isPrime ( prime ) == True ) :\n            found = True\n    return prime\nN = 3\nprint ( nextPrime ( N ) )\n", "python_code_tokenized": "import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( math . sqrt ( n ) + 1 ) , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def nextPrime ( N ) : NEW_LINE INDENT if ( N <= 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT prime = N NEW_LINE found = False NEW_LINE while ( not found ) : NEW_LINE INDENT prime = prime + 1 NEW_LINE if ( isPrime ( prime ) == True ) : NEW_LINE INDENT found = True NEW_LINE DEDENT DEDENT return prime NEW_LINE DEDENT N = 3 NEW_LINE print ( nextPrime ( N ) ) NEW_LINE"}
{"id": "geeksforgeeks_5055_A", "sol": 0, "python_code": "class Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.left = None\n        self.right = None\ndef newNode ( data ) :\n    temp = Node ( 0 )\n    temp.data = data\n    temp.left = temp.right = None\n    return temp\ndef maxOfRightElement ( root ) :\n    res = - 999999\n    if ( root == None ) :\n        return - 1\n    if ( root.right != None ) :\n        res = root.right.data\n    return max ( maxOfRightElement ( root.right ) , res , maxOfRightElement ( root.left ) )\nroot = newNode ( 7 )\nroot.left = newNode ( 6 )\nroot.right = newNode ( 5 )\nroot.left.left = newNode ( 4 )\nroot.left.right = newNode ( 3 )\nroot.right.left = newNode ( 2 )\nroot.right.right = newNode ( 1 )\nprint ( maxOfRightElement ( root ) )\n", "python_code_tokenized": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT temp = Node ( 0 ) NEW_LINE temp . data = data NEW_LINE temp . left = temp . right = None NEW_LINE return temp NEW_LINE DEDENT def maxOfRightElement ( root ) : NEW_LINE INDENT res = - 999999 NEW_LINE if ( root == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( root . right != None ) : NEW_LINE INDENT res = root . right . data NEW_LINE DEDENT return max ( maxOfRightElement ( root . right ) , res , maxOfRightElement ( root . left ) ) NEW_LINE DEDENT root = newNode ( 7 ) NEW_LINE root . left = newNode ( 6 ) NEW_LINE root . right = newNode ( 5 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 3 ) NEW_LINE root . right . left = newNode ( 2 ) NEW_LINE root . right . right = newNode ( 1 ) NEW_LINE print ( maxOfRightElement ( root ) ) NEW_LINE"}
{"id": "codeforces_909_A", "sol": 0, "python_code": "a , b = [ i for i in input ( ).split ( ) ]\nal = list ( a )\nbl = list ( b )\ns = al [ 0 ]\nc = bl [ 0 ]\nfor i in al [ 1 : ] :\n    if i < c :\n        s = s + i\n    else :\n        break\ns = s + c\nprint ( s )\n", "python_code_tokenized": "a , b = [ i for i in input ( ) . split ( ) ] NEW_LINE al = list ( a ) NEW_LINE bl = list ( b ) NEW_LINE s = al [ 0 ] NEW_LINE c = bl [ 0 ] NEW_LINE for i in al [ 1 : ] : NEW_LINE INDENT if i < c : NEW_LINE INDENT s = s + i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT s = s + c NEW_LINE print ( s ) NEW_LINE"}
{"id": "geeksforgeeks_5054_A", "sol": 0, "python_code": "def printSequence ( v , n , s , k ) :\n    if ( s == 0 ) :\n        for i in range ( 0 , len ( v ) ) :\n            print ( \"{} \".format ( v [ i ] ) , end = \"\" )\n        print ( \"\" )\n        return ;\n    for i in range ( 0 , k ) :\n        v.append ( n + i )\n        printSequence ( v , n + i , s - 1 , k )\n        v.pop ( )\n    for i in range ( 1 , k ) :\n        v.append ( n - i )\n        printSequence ( v , n - i , s - 1 , k )\n        v.pop ( )\ndef wrapper ( n , s , k ) :\n    v = [ ]\n    v.append ( n )\n    printSequence ( v , n , s - 1 , k )\nn = 5 ; s = 3 ; k = 2 ;\nwrapper ( n , s , k ) ;\n", "python_code_tokenized": "def printSequence ( v , n , s , k ) : NEW_LINE INDENT if ( s == 0 ) : NEW_LINE INDENT for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT print ( \" { } \u2581 \" . format ( v [ i ] ) , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE return ; NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT v . append ( n + i ) NEW_LINE printSequence ( v , n + i , s - 1 , k ) NEW_LINE v . pop ( ) NEW_LINE DEDENT for i in range ( 1 , k ) : NEW_LINE INDENT v . append ( n - i ) NEW_LINE printSequence ( v , n - i , s - 1 , k ) NEW_LINE v . pop ( ) NEW_LINE DEDENT DEDENT def wrapper ( n , s , k ) : NEW_LINE INDENT v = [ ] NEW_LINE v . append ( n ) NEW_LINE printSequence ( v , n , s - 1 , k ) NEW_LINE DEDENT n = 5 ; s = 3 ; k = 2 ; NEW_LINE wrapper ( n , s , k ) ; NEW_LINE"}
{"id": "atcoder_ABC127_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\nif a > 12 :\n    print ( b )\nelif a > 5 and a < 13 :\n    print ( b // 2 )\nelse :\n    print ( 0 )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > 12 : NEW_LINE INDENT print ( b ) NEW_LINE DEDENT elif a > 5 and a < 13 : NEW_LINE INDENT print ( b // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT"}
{"id": "aizu_p02256_A", "sol": 0, "python_code": "def gcd ( x , y ) :\n    if y == 0 :\n        return x\n    else :\n        return gcd ( y , x % y )\ndef main ( ) :\n    l , r = tuple ( map ( int , input ( ).split ( ' ' ) ) )\n    print ( gcd ( l , r ) )\nmain ( )\n", "python_code_tokenized": "def gcd ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( y , x % y ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT l , r = tuple ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE print ( gcd ( l , r ) ) NEW_LINE DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_4237_A", "sol": 0, "python_code": "MAX = 50\ndef solve ( dp , a , low , high , turn ) :\n    if ( low == high ) :\n        return a [ low ] * turn\n    if ( dp [ low ] [ high ] != 0 ) :\n        return dp [ low ] [ high ]\n    dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ;\n    return dp [ low ] [ high ]\nif __name__ == \"__main__\" :\n    arr = [ 1 , 3 , 1 , 5 , 2 ]\n    n = len ( arr )\n    dp = [ [ 0 for x in range ( MAX ) ] for y in range ( MAX ) ]\n    print ( solve ( dp , arr , 0 , n - 1 , 1 ) )\n", "python_code_tokenized": "MAX = 50 NEW_LINE def solve ( dp , a , low , high , turn ) : NEW_LINE INDENT if ( low == high ) : NEW_LINE INDENT return a [ low ] * turn NEW_LINE DEDENT if ( dp [ low ] [ high ] != 0 ) : NEW_LINE INDENT return dp [ low ] [ high ] NEW_LINE DEDENT dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; NEW_LINE return dp [ low ] [ high ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 1 , 5 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE dp = [ [ 0 for x in range ( MAX ) ] for y in range ( MAX ) ] NEW_LINE print ( solve ( dp , arr , 0 , n - 1 , 1 ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC124_D", "sol": 0, "python_code": "def compress ( list01 ) :\n    newList = [ ]\n    n = len ( list01 )\n    now = 1\n    count0 = 0\n    count1 = 0\n    list01.append ( ( list01 [ - 1 ] + 1 ) % 2 )\n    for i in range ( n + 1 ) :\n        nex = list01 [ i ]\n        if now == 0 :\n            if nex == 0 :\n                count0 += 1\n            if nex == 1 :\n                count1 += 1\n                newList.append ( count0 )\n                count0 = 0\n        if now == 1 :\n            if nex == 0 :\n                count0 += 1\n                newList.append ( count1 )\n                count1 = 0\n            if nex == 1 :\n                count1 += 1\n        now = nex\n    if list01 [ - 2 ] == 0 :\n        newList.append ( 0 )\n    return newList\ndef measure_insect ( mixed_list , k ) :\n    n = ( len ( mixed_list ) - 1 ) // 2\n    now = sum ( mixed_list [ : 2 * k + 1 ] )\n    maximum = now\n    for i in range ( n - k ) :\n        now -= mixed_list [ 2 * i ]\n        now -= mixed_list [ 2 * i + 1 ]\n        now += mixed_list [ 2 * i + 2 * k + 1 ]\n        now += mixed_list [ 2 * i + 2 * k + 2 ]\n        if now > maximum :\n            maximum = now\n    return maximum\nN , K = map ( int , input ( ).split ( ) )\nS = [ int ( _ ) for _ in input ( ) ]\nprint ( measure_insect ( compress ( S ) , K ) )\n", "python_code_tokenized": "def compress ( list01 ) : NEW_LINE INDENT newList = [ ] NEW_LINE n = len ( list01 ) NEW_LINE now = 1 NEW_LINE count0 = 0 NEW_LINE count1 = 0 NEW_LINE list01 . append ( ( list01 [ - 1 ] + 1 ) % 2 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT nex = list01 [ i ] NEW_LINE if now == 0 : NEW_LINE INDENT if nex == 0 : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT if nex == 1 : NEW_LINE INDENT count1 += 1 NEW_LINE newList . append ( count0 ) NEW_LINE count0 = 0 NEW_LINE DEDENT DEDENT if now == 1 : NEW_LINE INDENT if nex == 0 : NEW_LINE INDENT count0 += 1 NEW_LINE newList . append ( count1 ) NEW_LINE count1 = 0 NEW_LINE DEDENT if nex == 1 : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT DEDENT now = nex NEW_LINE DEDENT if list01 [ - 2 ] == 0 : NEW_LINE INDENT newList . append ( 0 ) NEW_LINE DEDENT return newList NEW_LINE DEDENT def measure_insect ( mixed_list , k ) : NEW_LINE INDENT n = ( len ( mixed_list ) - 1 ) // 2 NEW_LINE now = sum ( mixed_list [ : 2 * k + 1 ] ) NEW_LINE maximum = now NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT now -= mixed_list [ 2 * i ] NEW_LINE now -= mixed_list [ 2 * i + 1 ] NEW_LINE now += mixed_list [ 2 * i + 2 * k + 1 ] NEW_LINE now += mixed_list [ 2 * i + 2 * k + 2 ] NEW_LINE if now > maximum : NEW_LINE INDENT maximum = now NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ int ( _ ) for _ in input ( ) ] NEW_LINE print ( measure_insect ( compress ( S ) , K ) ) NEW_LINE"}
{"id": "geeksforgeeks_4597_A", "sol": 0, "python_code": "import math ;\ndef discreteLogarithm ( a , b , m ) :\n    n = int ( math.sqrt ( m ) + 1 ) ;\n    an = 1 ;\n    for i in range ( n ) :\n        an = ( an * a ) % m ;\n    value = [ 0 ] * m ;\n    cur = an ;\n    for i in range ( 1 , n + 1 ) :\n        if ( value [ cur ] == 0 ) :\n            value [ cur ] = i ;\n        cur = ( cur * an ) % m ;\n    cur = b ;\n    for i in range ( n + 1 ) :\n        if ( value [ cur ] > 0 ) :\n            ans = value [ cur ] * n - i ;\n            if ( ans < m ) :\n                return ans ;\n        cur = ( cur * a ) % m ;\n    return - 1 ;\na = 2 ;\nb = 3 ;\nm = 5 ;\nprint ( discreteLogarithm ( a , b , m ) ) ;\na = 3 ;\nb = 7 ;\nm = 11 ;\nprint ( discreteLogarithm ( a , b , m ) ) ;\n", "python_code_tokenized": "import math ; NEW_LINE def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) ; NEW_LINE an = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT an = ( an * a ) % m ; NEW_LINE DEDENT value = [ 0 ] * m ; NEW_LINE cur = an ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] == 0 ) : NEW_LINE INDENT value [ cur ] = i ; NEW_LINE DEDENT cur = ( cur * an ) % m ; NEW_LINE DEDENT cur = b ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( value [ cur ] > 0 ) : NEW_LINE INDENT ans = value [ cur ] * n - i ; NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT DEDENT cur = ( cur * a ) % m ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT a = 2 ; NEW_LINE b = 3 ; NEW_LINE m = 5 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE a = 3 ; NEW_LINE b = 7 ; NEW_LINE m = 11 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE"}
{"id": "codeforces_387_A", "sol": 0, "python_code": "current_time = input ( )\ntime_duration = input ( )\ncurrent_time_min = int ( current_time [ : 2 ] ) * 60 + int ( current_time [ 3 : ] )\ntime_duration_min = int ( time_duration [ : 2 ] ) * 60 + int ( time_duration [ 3 : ] )\nt_min = current_time_min - time_duration_min\nif current_time_min < time_duration_min :\n    t_min = 24 * 60 - abs ( t_min )\nhour = \"0\" + str ( t_min // 60 ) if t_min // 60 < 10 else str ( t_min // 60 )\nminute = \"0\" + str ( t_min % 60 ) if t_min % 60 < 10 else str ( t_min % 60 )\nprint ( f\"{hour}:{minute}\" )\n", "python_code_tokenized": "current_time = input ( ) NEW_LINE time_duration = input ( ) NEW_LINE current_time_min = int ( current_time [ : 2 ] ) * 60 + int ( current_time [ 3 : ] ) NEW_LINE time_duration_min = int ( time_duration [ : 2 ] ) * 60 + int ( time_duration [ 3 : ] ) NEW_LINE t_min = current_time_min - time_duration_min NEW_LINE if current_time_min < time_duration_min : NEW_LINE INDENT t_min = 24 * 60 - abs ( t_min ) NEW_LINE DEDENT hour = \"0\" + str ( t_min // 60 ) if t_min // 60 < 10 else str ( t_min // 60 ) NEW_LINE minute = \"0\" + str ( t_min % 60 ) if t_min % 60 < 10 else str ( t_min % 60 ) NEW_LINE print ( f \" { hour } : { minute } \" ) NEW_LINE"}
{"id": "codeforces_709_B", "sol": 0, "python_code": "import sys\ndef read_input ( input_path = None ) :\n    if input_path is None :\n        f = sys.stdin\n    else :\n        f = open ( input_path , 'r' )\n    n , start = map ( int , f.readline ( ).split ( ) )\n    checkpoints = list ( map ( int , f.readline ( ).split ( ) ) )\n    return n , start , checkpoints\ndef f ( a , left , right ) :\n    dl , dr = a - left , right - a\n    return 2 * max ( 0 , min ( dl , dr ) ) + max ( dl , dr )\ndef sol ( n , start , checkpoints ) :\n    if n == 1 :\n        return [ \"0\" ]\n    checkpoints = sorted ( checkpoints )\n    ans = min ( f ( start , checkpoints [ 0 ] , checkpoints [ - 2 ] ) , f ( start , checkpoints [ 1 ] , checkpoints [ - 1 ] ) )\n    return [ f\"{ans}\" ]\ndef solve ( input_path = None ) :\n    return sol ( * read_input ( input_path ) )\ndef main ( ) :\n    for line in sol ( * read_input ( ) ) :\n        print ( f\"{line}\" )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "import sys NEW_LINE def read_input ( input_path = None ) : NEW_LINE INDENT if input_path is None : NEW_LINE INDENT f = sys . stdin NEW_LINE DEDENT else : NEW_LINE INDENT f = open ( input_path , ' r ' ) NEW_LINE DEDENT n , start = map ( int , f . readline ( ) . split ( ) ) NEW_LINE checkpoints = list ( map ( int , f . readline ( ) . split ( ) ) ) NEW_LINE return n , start , checkpoints NEW_LINE DEDENT def f ( a , left , right ) : NEW_LINE INDENT dl , dr = a - left , right - a NEW_LINE return 2 * max ( 0 , min ( dl , dr ) ) + max ( dl , dr ) NEW_LINE DEDENT def sol ( n , start , checkpoints ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return [ \"0\" ] NEW_LINE DEDENT checkpoints = sorted ( checkpoints ) NEW_LINE ans = min ( f ( start , checkpoints [ 0 ] , checkpoints [ - 2 ] ) , f ( start , checkpoints [ 1 ] , checkpoints [ - 1 ] ) ) NEW_LINE return [ f \" { ans } \" ] NEW_LINE DEDENT def solve ( input_path = None ) : NEW_LINE INDENT return sol ( * read_input ( input_path ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT for line in sol ( * read_input ( ) ) : NEW_LINE INDENT print ( f \" { line } \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_1673_A", "sol": 0, "python_code": "import string\nletter = string.ascii_lowercase\nfor _ in range ( int ( input ( ) ) ) :\n    s = input ( )\n    if len ( s ) % 2 == 0 :\n        c = 0\n        for i in s :\n            c += letter.index ( i ) + 1\n        print ( f'Alice {c}' )\n    elif len ( s ) == 1 :\n        print ( 'Bob' , letter.index ( s ) + 1 )\n    else :\n        a = letter.index ( s [ 0 ] ) + 1\n        b = letter.index ( s [ - 1 ] ) + 1\n        if a >= b :\n            c = 0\n            for i in s [ 0 : - 1 ] :\n                c += letter.index ( i ) + 1\n            print ( f'Alice {abs(c-b)}' )\n        else :\n            c = 0\n            for i in s [ 1 : : ] :\n                c += letter.index ( i ) + 1\n            print ( f'Alice {abs(c-a)}' )\n", "python_code_tokenized": "import string NEW_LINE letter = string . ascii_lowercase NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE if len ( s ) % 2 == 0 : NEW_LINE INDENT c = 0 NEW_LINE for i in s : NEW_LINE INDENT c += letter . index ( i ) + 1 NEW_LINE DEDENT print ( f ' Alice \u2581 { c } ' ) NEW_LINE DEDENT elif len ( s ) == 1 : NEW_LINE INDENT print ( ' Bob ' , letter . index ( s ) + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT a = letter . index ( s [ 0 ] ) + 1 NEW_LINE b = letter . index ( s [ - 1 ] ) + 1 NEW_LINE if a >= b : NEW_LINE INDENT c = 0 NEW_LINE for i in s [ 0 : - 1 ] : NEW_LINE INDENT c += letter . index ( i ) + 1 NEW_LINE DEDENT print ( f ' Alice \u2581 { abs ( c - b ) } ' ) NEW_LINE DEDENT else : NEW_LINE INDENT c = 0 NEW_LINE for i in s [ 1 : : ] : NEW_LINE INDENT c += letter . index ( i ) + 1 NEW_LINE DEDENT print ( f ' Alice \u2581 { abs ( c - a ) } ' ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_3376_A", "sol": 0, "python_code": "mod = 1000000007\ndp = [ [ - 1 for i in range ( 1000 ) ] for j in range ( 1000 ) ] ;\ndef calculate ( pos , prev , s , index ) :\n    if ( pos == len ( s ) ) :\n        return 1\n    if ( dp [ pos ] [ prev ] != - 1 ) :\n        return dp [ pos ] [ prev ]\n    c = ord ( s [ pos ] ) - ord ( 'a' ) ;\n    answer = 0\n    for i in range ( len ( index ) ) :\n        if ( index [ i ] > prev ) :\n            answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod\n    dp [ pos ] [ prev ] = 4\n    return dp [ pos ] [ prev ]\ndef countWays ( a , s ) :\n    n = len ( a )\n    index = [ [ ] for i in range ( 26 ) ]\n    for i in range ( n ) :\n        for j in range ( len ( a [ i ] ) ) :\n            index [ ord ( a [ i ] [ j ] ) - ord ( 'a' ) ].append ( j + 1 ) ;\n    return calculate ( 0 , 0 , s , index [ 0 ] )\nif __name__ == '__main__' :\n    A = [ ]\n    A.append ( \"adc\" )\n    A.append ( \"aec\" )\n    A.append ( \"erg\" )\n    S = \"ac\"\n    print ( countWays ( A , S ) )\n", "python_code_tokenized": "mod = 1000000007 NEW_LINE dp = [ [ - 1 for i in range ( 1000 ) ] for j in range ( 1000 ) ] ; NEW_LINE def calculate ( pos , prev , s , index ) : NEW_LINE INDENT if ( pos == len ( s ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ prev ] NEW_LINE DEDENT c = ord ( s [ pos ] ) - ord ( ' a ' ) ; NEW_LINE answer = 0 NEW_LINE for i in range ( len ( index ) ) : NEW_LINE INDENT if ( index [ i ] > prev ) : NEW_LINE INDENT answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ prev ] = 4 NEW_LINE return dp [ pos ] [ prev ] NEW_LINE DEDENT def countWays ( a , s ) : NEW_LINE INDENT n = len ( a ) NEW_LINE index = [ [ ] for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( a [ i ] ) ) : NEW_LINE INDENT index [ ord ( a [ i ] [ j ] ) - ord ( ' a ' ) ] . append ( j + 1 ) ; NEW_LINE DEDENT DEDENT return calculate ( 0 , 0 , s , index [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ ] NEW_LINE A . append ( \" adc \" ) NEW_LINE A . append ( \" aec \" ) NEW_LINE A . append ( \" erg \" ) NEW_LINE S = \" ac \" NEW_LINE print ( countWays ( A , S ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3447_A", "sol": 0, "python_code": "def harmonicMean ( arr , n ) :\n    sm = 0\n    for i in range ( 0 , n ) :\n        sm = sm + ( 1 ) / arr [ i ] ;\n    return n / sm\narr = [ 13.5 , 14.5 , 14.8 , 15.2 , 16.1 ] ;\nn = len ( arr )\nprint ( harmonicMean ( arr , n ) )\n", "python_code_tokenized": "def harmonicMean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( 1 ) / arr [ i ] ; NEW_LINE DEDENT return n / sm NEW_LINE DEDENT arr = [ 13.5 , 14.5 , 14.8 , 15.2 , 16.1 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( harmonicMean ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3673_A", "sol": 0, "python_code": "def LiesInsieRectangle ( a , b , x , y ) :\n    if ( x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and x + y - b >= 0 ) :\n        return True\n    return False\nif __name__ == \"__main__\" :\n    a , b , x , y = 7 , 2 , 4 , 5\n    if LiesInsieRectangle ( a , b , x , y ) :\n        print ( \"Given point lies inside\" \" the rectangle\" )\n    else :\n        print ( \"Given point does not lie\" \" on the rectangle\" )\n", "python_code_tokenized": "def LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT if ( x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and x + y - b >= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , x , y = 7 , 2 , 4 , 5 NEW_LINE if LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT print ( \" Given \u2581 point \u2581 lies \u2581 inside \" \" \u2581 the \u2581 rectangle \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Given \u2581 point \u2581 does \u2581 not \u2581 lie \" \" \u2581 on \u2581 the \u2581 rectangle \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_30_A", "sol": 0, "python_code": "def isPrime ( n ) :\n    if ( n <= 1 ) :\n        return False\n    if ( n <= 3 ) :\n        return True\n    if ( n % 2 == 0 or n % 3 == 0 ) :\n        return False\n    i = 5\n    while ( i * i <= n ) :\n        if ( n % i == 0 or n % ( i + 2 ) == 0 ) :\n            return False\n        i += 6\n    return True\ndef findSmallest ( N ) :\n    if ( N == 0 ) :\n        return 2\n    if ( N == 1 ) :\n        return 1\n    prime , counter = N , 0\n    found = False\n    while ( not found ) :\n        if ( isPrime ( prime ) ) :\n            found = True\n        else :\n            prime += 1\n            counter += 1\n    return counter\nif __name__ == \"__main__\" :\n    N = 10\n    print ( findSmallest ( N ) )\n", "python_code_tokenized": "def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def findSmallest ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT prime , counter = N , 0 NEW_LINE found = False NEW_LINE while ( not found ) : NEW_LINE INDENT if ( isPrime ( prime ) ) : NEW_LINE INDENT found = True NEW_LINE DEDENT else : NEW_LINE INDENT prime += 1 NEW_LINE counter += 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 NEW_LINE print ( findSmallest ( N ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1455_B", "sol": 0, "python_code": "t = int ( input ( ) )\ndef solve ( x ) :\n    y = 0\n    j = 1\n    while y < x :\n        y += j\n        if y == x :\n            return ( j )\n        j += 1\n    if y - x == 1 :\n        return ( j )\n    else :\n        return ( j - 1 )\nfor i in range ( t ) :\n    i = int ( input ( ) )\n    print ( solve ( i ) )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE def solve ( x ) : NEW_LINE INDENT y = 0 NEW_LINE j = 1 NEW_LINE while y < x : NEW_LINE INDENT y += j NEW_LINE if y == x : NEW_LINE INDENT return ( j ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if y - x == 1 : NEW_LINE INDENT return ( j ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( j - 1 ) NEW_LINE DEDENT DEDENT for i in range ( t ) : NEW_LINE INDENT i = int ( input ( ) ) NEW_LINE print ( solve ( i ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1450_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    input ( )\n    l = list ( input ( ) )\n    s = set ( 'trygub' )\n    print ( ''.join ( l ) if not s.issubset ( l ) else ''.join ( sorted ( l ) ) )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT input ( ) NEW_LINE l = list ( input ( ) ) NEW_LINE s = set ( ' trygub ' ) NEW_LINE print ( ' ' . join ( l ) if not s . issubset ( l ) else ' ' . join ( sorted ( l ) ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1691_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    n = int ( input ( ) )\n    l = list ( map ( int , input ( ).split ( ) ) )\n    count = 0\n    for i in l :\n        count += i % 2\n    print ( min ( count , n - count ) )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE for i in l : NEW_LINE INDENT count += i % 2 NEW_LINE DEDENT print ( min ( count , n - count ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4201_A", "sol": 0, "python_code": "import sys\ndef getPairsCount ( arr , n , sum ) :\n    m = [ 0 ] * 1000\n    for i in range ( 0 , n ) :\n        m [ arr [ i ] ]\n        m [ arr [ i ] ] += 1\n    twice_count = 0\n    for i in range ( 0 , n ) :\n        twice_count += m [ sum - arr [ i ] ]\n        if ( sum - arr [ i ] == arr [ i ] ) :\n            twice_count -= 1\n    return int ( twice_count / 2 )\narr = [ 1 , 5 , 7 , - 1 , 5 ]\nn = len ( arr )\nsum = 6\nprint ( \"Count of pairs is\" , getPairsCount ( arr , n , sum ) )\n", "python_code_tokenized": "import sys NEW_LINE def getPairsCount ( arr , n , sum ) : NEW_LINE INDENT m = [ 0 ] * 1000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT m [ arr [ i ] ] NEW_LINE m [ arr [ i ] ] += 1 NEW_LINE DEDENT twice_count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT twice_count += m [ sum - arr [ i ] ] NEW_LINE if ( sum - arr [ i ] == arr [ i ] ) : NEW_LINE INDENT twice_count -= 1 NEW_LINE DEDENT DEDENT return int ( twice_count / 2 ) NEW_LINE DEDENT arr = [ 1 , 5 , 7 , - 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 6 NEW_LINE print ( \" Count \u2581 of \u2581 pairs \u2581 is \" , getPairsCount ( arr , n , sum ) ) NEW_LINE"}
{"id": "geeksforgeeks_1590_A", "sol": 0, "python_code": "def firstFactorialDivisibleNumber ( x ) :\n    i = 1 ;\n    fact = 1 ;\n    for i in range ( 1 , x ) :\n        fact = fact * i\n        if ( fact % x == 0 ) :\n            break\n    return i\nx = 16\nprint ( firstFactorialDivisibleNumber ( x ) )\n", "python_code_tokenized": "def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT i = 1 ; NEW_LINE fact = 1 ; NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( fact % x == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT x = 16 NEW_LINE print ( firstFactorialDivisibleNumber ( x ) ) NEW_LINE"}
{"id": "codeforces_834_A", "sol": 0, "python_code": "c = '^>v<'\na , b = map ( c.index , input ( ).split ( ) )\nn = int ( input ( ) )\nprint ( [ [ 'ccw' , 'cw' ] [ ( a + n ) % 4 == b ] , 'undefined' ] [ abs ( a - b ) % 2 == 0 ] )\n", "python_code_tokenized": "c = ' ^ > v < ' NEW_LINE a , b = map ( c . index , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE print ( [ [ ' ccw ' , ' cw ' ] [ ( a + n ) % 4 == b ] , ' undefined ' ] [ abs ( a - b ) % 2 == 0 ] ) NEW_LINE"}
{"id": "geeksforgeeks_720_A", "sol": 0, "python_code": "def CalculatePairs ( a , n ) :\n    cnt_zero = 0\n    cnt_one = 0\n    for i in range ( 0 , n ) :\n        if ( a [ i ] % 2 == 0 ) :\n            cnt_zero += 1\n        else :\n            cnt_one += 1\n    total_XOR_pairs = cnt_zero * cnt_one\n    total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2\n    total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2\n    print ( \"cntXOR = \" , int ( total_XOR_pairs ) )\n    print ( \"cntAND = \" , int ( total_AND_pairs ) )\n    print ( \"cntOR = \" , int ( total_OR_pairs ) )\nif __name__ == '__main__' :\n    a = [ 1 , 3 , 4 , 2 ]\n    n = len ( a )\n    CalculatePairs ( a , n )\n", "python_code_tokenized": "def CalculatePairs ( a , n ) : NEW_LINE INDENT cnt_zero = 0 NEW_LINE cnt_one = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT cnt_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one += 1 NEW_LINE DEDENT DEDENT total_XOR_pairs = cnt_zero * cnt_one NEW_LINE total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 NEW_LINE total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 NEW_LINE print ( \" cntXOR \u2581 = \u2581 \" , int ( total_XOR_pairs ) ) NEW_LINE print ( \" cntAND \u2581 = \u2581 \" , int ( total_AND_pairs ) ) NEW_LINE print ( \" cntOR \u2581 = \u2581 \" , int ( total_OR_pairs ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 3 , 4 , 2 ] NEW_LINE n = len ( a ) NEW_LINE CalculatePairs ( a , n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4462_A", "sol": 0, "python_code": "def OctToBin ( octnum ) :\n    binary = \"\"\n    while octnum != 0 :\n        d = int ( octnum % 10 )\n        if d == 0 :\n            binary = \"\".join ( [ \"000\" , binary ] )\n        elif d == 1 :\n            binary = \"\".join ( [ \"001\" , binary ] )\n        elif d == 2 :\n            binary = \"\".join ( [ \"010\" , binary ] )\n        elif d == 3 :\n            binary = \"\".join ( [ \"011\" , binary ] )\n        elif d == 4 :\n            binary = \"\".join ( [ \"100\" , binary ] )\n        elif d == 5 :\n            binary = \"\".join ( [ \"101\" , binary ] )\n        elif d == 6 :\n            binary = \"\".join ( [ \"110\" , binary ] )\n        elif d == 7 :\n            binary = \"\".join ( [ \"111\" , binary ] )\n        else :\n            binary = \"Invalid Octal Digit\"\n            break\n        octnum = int ( octnum / 10 )\n    return binary\noctnum = 345\nfinal_bin = \"\" + OctToBin ( octnum )\nprint ( \"Equivalent Binary Value =\" , final_bin )\n", "python_code_tokenized": "def OctToBin ( octnum ) : NEW_LINE INDENT binary = \" \" NEW_LINE while octnum != 0 : NEW_LINE INDENT d = int ( octnum % 10 ) NEW_LINE if d == 0 : NEW_LINE INDENT binary = \" \" . join ( [ \"000\" , binary ] ) NEW_LINE DEDENT elif d == 1 : NEW_LINE INDENT binary = \" \" . join ( [ \"001\" , binary ] ) NEW_LINE DEDENT elif d == 2 : NEW_LINE INDENT binary = \" \" . join ( [ \"010\" , binary ] ) NEW_LINE DEDENT elif d == 3 : NEW_LINE INDENT binary = \" \" . join ( [ \"011\" , binary ] ) NEW_LINE DEDENT elif d == 4 : NEW_LINE INDENT binary = \" \" . join ( [ \"100\" , binary ] ) NEW_LINE DEDENT elif d == 5 : NEW_LINE INDENT binary = \" \" . join ( [ \"101\" , binary ] ) NEW_LINE DEDENT elif d == 6 : NEW_LINE INDENT binary = \" \" . join ( [ \"110\" , binary ] ) NEW_LINE DEDENT elif d == 7 : NEW_LINE INDENT binary = \" \" . join ( [ \"111\" , binary ] ) NEW_LINE DEDENT else : NEW_LINE INDENT binary = \" Invalid \u2581 Octal \u2581 Digit \" NEW_LINE break NEW_LINE DEDENT octnum = int ( octnum / 10 ) NEW_LINE DEDENT return binary NEW_LINE DEDENT octnum = 345 NEW_LINE final_bin = \" \" + OctToBin ( octnum ) NEW_LINE print ( \" Equivalent \u2581 Binary \u2581 Value \u2581 = \" , final_bin ) NEW_LINE"}
{"id": "atcoder_AGC013_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nd = [ 0 for _ in range ( n - 1 ) ]\nfor i in range ( n - 1 ) :\n    d [ i ] = a [ i + 1 ] - a [ i ]\ncnt = 1\nl = r = cur = 0\nwhile l < n - 1 :\n    while r < n - 1 and cur * d [ r ] >= 0 :\n        if cur == 0 :\n            cur = d [ r ]\n        r += 1\n    if r < n - 1 and cur * d [ r ] < 0 :\n        cnt += 1\n    r += 1\n    l = r\n    cur = 0\nprint ( cnt )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = [ 0 for _ in range ( n - 1 ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT d [ i ] = a [ i + 1 ] - a [ i ] NEW_LINE DEDENT cnt = 1 NEW_LINE l = r = cur = 0 NEW_LINE while l < n - 1 : NEW_LINE INDENT while r < n - 1 and cur * d [ r ] >= 0 : NEW_LINE INDENT if cur == 0 : NEW_LINE INDENT cur = d [ r ] NEW_LINE DEDENT r += 1 NEW_LINE DEDENT if r < n - 1 and cur * d [ r ] < 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT r += 1 NEW_LINE l = r NEW_LINE cur = 0 NEW_LINE DEDENT print ( cnt ) NEW_LINE"}
{"id": "codeforces_1118_A", "sol": 0, "python_code": "q = int ( input ( ) )\nr = [ ]\nfor i in range ( q ) :\n    x = list ( map ( int , input ( ).split ( ) ) )\n    n = x [ 0 ]\n    a = x [ 1 ]\n    b = x [ 2 ]\n    if a >= b :\n        c = n // 2\n        d = c * b\n        c1 = n - c * 2\n        d1 = c1 * a\n        r.append ( d + d1 )\n    else :\n        if b >= ( 2 * a ) :\n            d = a * n\n            r.append ( d )\n        else :\n            c = n // 2\n            d = c * b\n            c1 = n - c * 2\n            d1 = c1 * a\n            r.append ( d + d1 )\nfor i in range ( len ( r ) ) :\n    print ( r [ i ] )\n", "python_code_tokenized": "q = int ( input ( ) ) NEW_LINE r = [ ] NEW_LINE for i in range ( q ) : NEW_LINE INDENT x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE n = x [ 0 ] NEW_LINE a = x [ 1 ] NEW_LINE b = x [ 2 ] NEW_LINE if a >= b : NEW_LINE INDENT c = n // 2 NEW_LINE d = c * b NEW_LINE c1 = n - c * 2 NEW_LINE d1 = c1 * a NEW_LINE r . append ( d + d1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if b >= ( 2 * a ) : NEW_LINE INDENT d = a * n NEW_LINE r . append ( d ) NEW_LINE DEDENT else : NEW_LINE INDENT c = n // 2 NEW_LINE d = c * b NEW_LINE c1 = n - c * 2 NEW_LINE d1 = c1 * a NEW_LINE r . append ( d + d1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( r ) ) : NEW_LINE INDENT print ( r [ i ] ) NEW_LINE DEDENT"}
{"id": "aizu_p01074_A", "sol": 0, "python_code": "N , M , L = map ( int , input ( ).split ( ) )\ntbl = [ [ ] for i in range ( 45 ) ]\nfor i in range ( M ) :\n    d , a , k , t = map ( int , input ( ).split ( ) )\n    tbl [ d * N + a - 1 ].append ( ( k , t ) )\ndp = [ [ 0 for i in range ( 45 ) ] for j in range ( 45 ) ]\nfor da in range ( 5 * N ) :\n    for i in range ( L + 1 ) :\n        if i < L :\n            for k , t in tbl [ da ] :\n                dp [ da + k ] [ i + 1 ] = max ( dp [ da + k ] [ i + 1 ] , dp [ da ] [ i ] + t )\n        dp [ da + 1 ] [ i ] = max ( dp [ da + 1 ] [ i ] , dp [ da ] [ i ] )\nprint ( dp [ 5 * N ] [ L ] )\n", "python_code_tokenized": "N , M , L = map ( int , input ( ) . split ( ) ) NEW_LINE tbl = [ [ ] for i in range ( 45 ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT d , a , k , t = map ( int , input ( ) . split ( ) ) NEW_LINE tbl [ d * N + a - 1 ] . append ( ( k , t ) ) NEW_LINE DEDENT dp = [ [ 0 for i in range ( 45 ) ] for j in range ( 45 ) ] NEW_LINE for da in range ( 5 * N ) : NEW_LINE INDENT for i in range ( L + 1 ) : NEW_LINE INDENT if i < L : NEW_LINE INDENT for k , t in tbl [ da ] : NEW_LINE INDENT dp [ da + k ] [ i + 1 ] = max ( dp [ da + k ] [ i + 1 ] , dp [ da ] [ i ] + t ) NEW_LINE DEDENT DEDENT dp [ da + 1 ] [ i ] = max ( dp [ da + 1 ] [ i ] , dp [ da ] [ i ] ) NEW_LINE DEDENT DEDENT print ( dp [ 5 * N ] [ L ] ) NEW_LINE"}
{"id": "geeksforgeeks_4569_A", "sol": 0, "python_code": "def getClosest ( a , b , x ) :\n    num = pow ( a , b )\n    floor = num // x\n    numOnLeft = x * floor\n    numOnRight = x * ( floor + 1 )\n    if ( ( num - numOnLeft ) < ( numOnRight - num ) ) :\n        return numOnLeft\n    else :\n        return numOnRight\nif __name__ == \"__main__\" :\n    a , b , x = 349 , 1 , 4\n    print ( getClosest ( a , b , x ) )\n", "python_code_tokenized": "def getClosest ( a , b , x ) : NEW_LINE INDENT num = pow ( a , b ) NEW_LINE floor = num // x NEW_LINE numOnLeft = x * floor NEW_LINE numOnRight = x * ( floor + 1 ) NEW_LINE if ( ( num - numOnLeft ) < ( numOnRight - num ) ) : NEW_LINE INDENT return numOnLeft NEW_LINE DEDENT else : NEW_LINE INDENT return numOnRight NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , x = 349 , 1 , 4 NEW_LINE print ( getClosest ( a , b , x ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1430_B", "sol": 0, "python_code": "for t in range ( int ( input ( ) ) ) :\n    n , k = list ( map ( int , input ( ).split ( ) ) )\n    a = list ( map ( int , input ( ).split ( ) ) )\n    a.sort ( reverse = True )\n    result = 0\n    for i in range ( k + 1 ) :\n        result += a [ i ]\n    print ( result )\n", "python_code_tokenized": "for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE result = 0 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT result += a [ i ] NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT"}
{"id": "aizu_p02473_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\nprint ( a - b )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a - b ) NEW_LINE"}
{"id": "geeksforgeeks_4600_A", "sol": 0, "python_code": "def nth_term ( a , b , n ) :\n    z = 0\n    if ( n % 6 == 1 ) :\n        z = a\n    elif ( n % 6 == 2 ) :\n        z = b\n    elif ( n % 6 == 3 ) :\n        z = b - a\n    elif ( n % 6 == 4 ) :\n        z = - a\n    elif ( n % 6 == 5 ) :\n        z = - b\n    if ( n % 6 == 0 ) :\n        z = - ( b - a )\n    return z\nif __name__ == '__main__' :\n    a = 10\n    b = 17\n    n = 3\n    print ( nth_term ( a , b , n ) )\n", "python_code_tokenized": "def nth_term ( a , b , n ) : NEW_LINE INDENT z = 0 NEW_LINE if ( n % 6 == 1 ) : NEW_LINE INDENT z = a NEW_LINE DEDENT elif ( n % 6 == 2 ) : NEW_LINE INDENT z = b NEW_LINE DEDENT elif ( n % 6 == 3 ) : NEW_LINE INDENT z = b - a NEW_LINE DEDENT elif ( n % 6 == 4 ) : NEW_LINE INDENT z = - a NEW_LINE DEDENT elif ( n % 6 == 5 ) : NEW_LINE INDENT z = - b NEW_LINE DEDENT if ( n % 6 == 0 ) : NEW_LINE INDENT z = - ( b - a ) NEW_LINE DEDENT return z NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 17 NEW_LINE n = 3 NEW_LINE print ( nth_term ( a , b , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2805_A", "sol": 0, "python_code": "def replaceRemove ( s , X , Y , Z ) :\n    s = list ( s ) ;\n    start = 0 ;\n    end = len ( s ) - 1 ;\n    while ( start <= end ) :\n        if ( s [ start ] == Z ) :\n            while ( end >= 0 and s [ end ] == Z ) :\n                end -= 1 ;\n            if ( end > start ) :\n                s [ start ] , s [ end ] = s [ end ] , s [ start ]\n                if ( s [ start ] == X ) :\n                    s [ start ] = Y ;\n                start += 1\n        else :\n            if ( s [ start ] == X ) :\n                s [ start ] = Y ;\n            start += 1 ;\n    while ( len ( s ) > 0 and s [ len ( s ) - 1 ] == Z ) :\n        s.pop ( ) ;\n    return \"\".join ( s )\nif __name__ == \"__main__\" :\n    string = \"batman\" ;\n    X = 'a' ; Y = 'd' ; Z = 'b' ;\n    string = replaceRemove ( string , X , Y , Z ) ;\n    if ( len ( string ) == 0 ) :\n        print ( - 1 ) ;\n    else :\n        print ( string ) ;\n", "python_code_tokenized": "def replaceRemove ( s , X , Y , Z ) : NEW_LINE INDENT s = list ( s ) ; NEW_LINE start = 0 ; NEW_LINE end = len ( s ) - 1 ; NEW_LINE while ( start <= end ) : NEW_LINE INDENT if ( s [ start ] == Z ) : NEW_LINE INDENT while ( end >= 0 and s [ end ] == Z ) : NEW_LINE INDENT end -= 1 ; NEW_LINE DEDENT if ( end > start ) : NEW_LINE INDENT s [ start ] , s [ end ] = s [ end ] , s [ start ] NEW_LINE if ( s [ start ] == X ) : NEW_LINE INDENT s [ start ] = Y ; NEW_LINE DEDENT start += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( s [ start ] == X ) : NEW_LINE INDENT s [ start ] = Y ; NEW_LINE DEDENT start += 1 ; NEW_LINE DEDENT DEDENT while ( len ( s ) > 0 and s [ len ( s ) - 1 ] == Z ) : NEW_LINE INDENT s . pop ( ) ; NEW_LINE DEDENT return \" \" . join ( s ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" batman \" ; NEW_LINE X = ' a ' ; Y = ' d ' ; Z = ' b ' ; NEW_LINE string = replaceRemove ( string , X , Y , Z ) ; NEW_LINE if ( len ( string ) == 0 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( string ) ; NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1206_A", "sol": 0, "python_code": "MAX = 1000001\nMAX_sqrt = MAX ** ( 0.5 )\nprimeUpto = [ 0 ] * ( MAX )\ndef SieveOfEratosthenes ( ) :\n    isPrime = [ 1 ] * ( MAX )\n    isPrime [ 0 ] , isPrime [ 1 ] = 0 , 0\n    for i in range ( 2 , int ( MAX_sqrt ) ) :\n        if isPrime [ i ] == 1 :\n            for j in range ( i * 2 , MAX , i ) :\n                isPrime [ j ] = 0\n    for i in range ( 1 , MAX ) :\n        primeUpto [ i ] = primeUpto [ i - 1 ]\n        if isPrime [ i ] == 1 :\n            primeUpto [ i ] += 1\ndef countOfNumbers ( N , K ) :\n    SieveOfEratosthenes ( )\n    low , high , ans = 1 , N , 0\n    while low <= high :\n        mid = ( low + high ) >> 1\n        if mid - primeUpto [ mid ] >= K :\n            ans = mid\n            high = mid - 1\n        else :\n            low = mid + 1\n    return ( N - ans + 1 ) if ans else 0\nif __name__ == \"__main__\" :\n    N , K = 10 , 3\n    print ( countOfNumbers ( N , K ) )\n", "python_code_tokenized": "MAX = 1000001 NEW_LINE MAX_sqrt = MAX ** ( 0.5 ) NEW_LINE primeUpto = [ 0 ] * ( MAX ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT isPrime = [ 1 ] * ( MAX ) NEW_LINE isPrime [ 0 ] , isPrime [ 1 ] = 0 , 0 NEW_LINE for i in range ( 2 , int ( MAX_sqrt ) ) : NEW_LINE INDENT if isPrime [ i ] == 1 : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT primeUpto [ i ] = primeUpto [ i - 1 ] NEW_LINE if isPrime [ i ] == 1 : NEW_LINE INDENT primeUpto [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE low , high , ans = 1 , N , 0 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if mid - primeUpto [ mid ] >= K : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return ( N - ans + 1 ) if ans else 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , K = 10 , 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_425_A", "sol": 0, "python_code": "def CntcontSubs ( a , n ) :\n    c = 0\n    d = 0\n    sum = 1\n    for i in range ( n ) :\n        if ( a [ i ] % 2 != 0 or a [ i ] % 4 == 0 ) :\n            d += 1\n        sum = a [ i ]\n        for j in range ( i + 1 , n ) :\n            sum = sum * a [ j ]\n            if ( sum % 2 != 0 or sum % 4 == 0 ) :\n                c += 1\n        sum = 1\n    return c + d\nif __name__ == '__main__' :\n    arr = [ 5 , 4 , 2 , 9 , 8 ]\n    n = len ( arr )\n    print ( CntcontSubs ( arr , n ) )\n", "python_code_tokenized": "def CntcontSubs ( a , n ) : NEW_LINE INDENT c = 0 NEW_LINE d = 0 NEW_LINE sum = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 != 0 or a [ i ] % 4 == 0 ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT sum = a [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = sum * a [ j ] NEW_LINE if ( sum % 2 != 0 or sum % 4 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT sum = 1 NEW_LINE DEDENT return c + d NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 4 , 2 , 9 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CntcontSubs ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2495_A", "sol": 0, "python_code": "def countOdd ( L , R ) :\n    N = ( R - L ) // 2\n    if ( R % 2 != 0 or L % 2 != 0 ) :\n        N += 1\n    return N\nif __name__ == \"__main__\" :\n    L = 3\n    R = 7\n    odds = countOdd ( L , R )\n    evens = ( R - L + 1 ) - odds\n    print ( \"Count of odd numbers is\" , odds )\n    print ( \"Count of even numbers is\" , evens )\n", "python_code_tokenized": "def countOdd ( L , R ) : NEW_LINE INDENT N = ( R - L ) // 2 NEW_LINE if ( R % 2 != 0 or L % 2 != 0 ) : NEW_LINE INDENT N += 1 NEW_LINE DEDENT return N NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 3 NEW_LINE R = 7 NEW_LINE odds = countOdd ( L , R ) NEW_LINE evens = ( R - L + 1 ) - odds NEW_LINE print ( \" Count \u2581 of \u2581 odd \u2581 numbers \u2581 is \" , odds ) NEW_LINE print ( \" Count \u2581 of \u2581 even \u2581 numbers \u2581 is \" , evens ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3022_A", "sol": 0, "python_code": "def isCyclic ( N ) :\n    num = N\n    count = 0\n    digit = ( num % 10 )\n    allSame = True\n    while ( num > 0 ) :\n        count += 1\n        if ( num % 10 != digit ) :\n            allSame = False\n        num = num // 10\n    if ( allSame == True ) :\n        return False\n    if ( count % 2 == 0 ) :\n        halfPower = pow ( 10 , count // 2 )\n        firstHalf = N % halfPower\n        secondHalf = N / halfPower\n        if ( firstHalf == firstHalf and isCyclic ( firstHalf ) ) :\n            return False\n    num = N\n    while ( True ) :\n        rem = num % 10\n        div = num // 10\n        num = pow ( 10 , count - 1 ) * rem + div\n        if ( num == N ) :\n            break\n        if ( num % N != 0 ) :\n            return False\n    return True\nN = 142857\nif ( isCyclic ( N ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def isCyclic ( N ) : NEW_LINE INDENT num = N NEW_LINE count = 0 NEW_LINE digit = ( num % 10 ) NEW_LINE allSame = True NEW_LINE while ( num > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE if ( num % 10 != digit ) : NEW_LINE INDENT allSame = False NEW_LINE DEDENT num = num // 10 NEW_LINE DEDENT if ( allSame == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT halfPower = pow ( 10 , count // 2 ) NEW_LINE firstHalf = N % halfPower NEW_LINE secondHalf = N / halfPower NEW_LINE if ( firstHalf == firstHalf and isCyclic ( firstHalf ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT num = N NEW_LINE while ( True ) : NEW_LINE INDENT rem = num % 10 NEW_LINE div = num // 10 NEW_LINE num = pow ( 10 , count - 1 ) * rem + div NEW_LINE if ( num == N ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( num % N != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT N = 142857 NEW_LINE if ( isCyclic ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_828_A", "sol": 0, "python_code": "from math import sqrt\ndef find_Area ( a ) :\n    R = a * ( 2.0 - sqrt ( 2 ) ) ;\n    area = 3.14 * R * R / 2.0 ;\n    return area ;\nif __name__ == \"__main__\" :\n    a = 4 ;\n    print ( \"Area of semicircle =\" , find_Area ( a ) ) ;\n", "python_code_tokenized": "from math import sqrt NEW_LINE def find_Area ( a ) : NEW_LINE INDENT R = a * ( 2.0 - sqrt ( 2 ) ) ; NEW_LINE area = 3.14 * R * R / 2.0 ; NEW_LINE return area ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 4 ; NEW_LINE print ( \" Area \u2581 of \u2581 semicircle \u2581 = \" , find_Area ( a ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_936_A", "sol": 0, "python_code": "import sys , math , heapq , queue\nfrom collections import deque\nfrom functools import cmp_to_key\nfast_input = sys.stdin.readline\nk , d , t = map ( int , fast_input ( ).split ( ) )\nc = math.ceil ( k / d ) * d\nr = c - k\none_round = k + r / 2\nreq = math.floor ( ( t / one_round ) )\nrem = t - req * one_round\nif rem <= k :\n    print ( rem + req * ( r + k ) )\nelse :\n    rem -= k\n    print ( k + rem * 2 + req * ( r + k ) )\n", "python_code_tokenized": "import sys , math , heapq , queue NEW_LINE from collections import deque NEW_LINE from functools import cmp_to_key NEW_LINE fast_input = sys . stdin . readline NEW_LINE k , d , t = map ( int , fast_input ( ) . split ( ) ) NEW_LINE c = math . ceil ( k / d ) * d NEW_LINE r = c - k NEW_LINE one_round = k + r / 2 NEW_LINE req = math . floor ( ( t / one_round ) ) NEW_LINE rem = t - req * one_round NEW_LINE if rem <= k : NEW_LINE INDENT print ( rem + req * ( r + k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT rem -= k NEW_LINE print ( k + rem * 2 + req * ( r + k ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC078_D", "sol": 0, "python_code": "N , Z , W = list ( map ( int , input ( ).split ( ) ) )\nA = [ W ] + list ( map ( int , input ( ).split ( ) ) )\nX = [ 0 ] * ( N + 1 )\nY = [ 1e9 ] * ( N + 1 )\nfor i in range ( N , 0 , - 1 ) :\n    X [ i ] = max ( [ abs ( A [ i - 1 ] - A [ N ] ) ] + [ Y [ j ] for j in range ( i + 1 , N + 1 ) ] )\n    Y [ i ] = min ( [ abs ( A [ i - 1 ] - A [ N ] ) ] + [ X [ j ] for j in range ( i + 1 , N + 1 ) ] )\nprint ( X [ 1 ] )\n", "python_code_tokenized": "N , Z , W = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A = [ W ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE X = [ 0 ] * ( N + 1 ) NEW_LINE Y = [ 1e9 ] * ( N + 1 ) NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT X [ i ] = max ( [ abs ( A [ i - 1 ] - A [ N ] ) ] + [ Y [ j ] for j in range ( i + 1 , N + 1 ) ] ) NEW_LINE Y [ i ] = min ( [ abs ( A [ i - 1 ] - A [ N ] ) ] + [ X [ j ] for j in range ( i + 1 , N + 1 ) ] ) NEW_LINE DEDENT print ( X [ 1 ] ) NEW_LINE"}
{"id": "aizu_p02263_A", "sol": 0, "python_code": "def operator ( arg1 , arg2 , op ) :\n    if op == '+' : return arg1 + arg2\n    elif op == '-' : return arg1 - arg2\n    elif op == '*' : return arg1 * arg2\n    else : return arg1 / arg2\ndef main ( ) :\n    description = list ( input ( ).split ( ) )\n    stack = [ ]\n    for st in description :\n        if st.isdigit ( ) :\n            stack.append ( st )\n        else :\n            op = st\n            arg2 = int ( stack.pop ( ) )\n            arg1 = int ( stack.pop ( ) )\n            ans = operator ( arg1 , arg2 , op )\n            stack.append ( ans )\n    print ( stack.pop ( ) )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "def operator ( arg1 , arg2 , op ) : NEW_LINE INDENT if op == ' + ' : return arg1 + arg2 NEW_LINE elif op == ' - ' : return arg1 - arg2 NEW_LINE elif op == ' * ' : return arg1 * arg2 NEW_LINE else : return arg1 / arg2 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT description = list ( input ( ) . split ( ) ) NEW_LINE stack = [ ] NEW_LINE for st in description : NEW_LINE INDENT if st . isdigit ( ) : NEW_LINE INDENT stack . append ( st ) NEW_LINE DEDENT else : NEW_LINE INDENT op = st NEW_LINE arg2 = int ( stack . pop ( ) ) NEW_LINE arg1 = int ( stack . pop ( ) ) NEW_LINE ans = operator ( arg1 , arg2 , op ) NEW_LINE stack . append ( ans ) NEW_LINE DEDENT DEDENT print ( stack . pop ( ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_930_B", "sol": 0, "python_code": "s = input ( )\ndef uniq ( iii ) :\n    tmp = 0\n    for jj in range ( 1 , len ( s ) ) :\n        bb = { }\n        for ii in iii :\n            bb.setdefault ( s [ ii - jj ] , [ ] ).append ( ii )\n        tmp = max ( tmp , sum ( 1 for vvv in bb.values ( ) if len ( vvv ) == 1 ) )\n    return tmp\naa = { }\nfor ii , ss in enumerate ( s ) :\n    aa.setdefault ( ss , [ ] ).append ( ii )\nans = 0\nfor iii in aa.values ( ) :\n    ans += uniq ( iii )\nprint ( ans / len ( s ) )\n", "python_code_tokenized": "s = input ( ) NEW_LINE def uniq ( iii ) : NEW_LINE INDENT tmp = 0 NEW_LINE for jj in range ( 1 , len ( s ) ) : NEW_LINE INDENT bb = { } NEW_LINE for ii in iii : NEW_LINE INDENT bb . setdefault ( s [ ii - jj ] , [ ] ) . append ( ii ) NEW_LINE DEDENT tmp = max ( tmp , sum ( 1 for vvv in bb . values ( ) if len ( vvv ) == 1 ) ) NEW_LINE DEDENT return tmp NEW_LINE DEDENT aa = { } NEW_LINE for ii , ss in enumerate ( s ) : NEW_LINE INDENT aa . setdefault ( ss , [ ] ) . append ( ii ) NEW_LINE DEDENT ans = 0 NEW_LINE for iii in aa . values ( ) : NEW_LINE INDENT ans += uniq ( iii ) NEW_LINE DEDENT print ( ans / len ( s ) ) NEW_LINE"}
{"id": "atcoder_AGC012_C", "sol": 0, "python_code": "mod = 1000000007\neps = 10 ** - 9\ndef main ( ) :\n    import sys\n    input = sys.stdin.readline\n    N = bin ( int ( input ( ) ) ) [ 2 : ]\n    ans = [ 100 , 100 ] + list ( range ( 1 , len ( N ) ) ) + list ( range ( 1 , len ( N ) ) )\n    k = len ( N )\n    for i in range ( len ( N ) - 1 ) :\n        if N [ - i - 1 ] == \"1\" :\n            for j in range ( len ( ans ) ) :\n                if ans [ j ] == i + 1 :\n                    ans.insert ( j , k )\n                    k += 1\n                    break\n    ans += list ( range ( k - 1 , len ( N ) - 1 , - 1 ) )\n    print ( len ( ans ) )\n    print ( * ans )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "mod = 1000000007 NEW_LINE eps = 10 ** - 9 NEW_LINE def main ( ) : NEW_LINE INDENT import sys NEW_LINE input = sys . stdin . readline NEW_LINE N = bin ( int ( input ( ) ) ) [ 2 : ] NEW_LINE ans = [ 100 , 100 ] + list ( range ( 1 , len ( N ) ) ) + list ( range ( 1 , len ( N ) ) ) NEW_LINE k = len ( N ) NEW_LINE for i in range ( len ( N ) - 1 ) : NEW_LINE INDENT if N [ - i - 1 ] == \"1\" : NEW_LINE INDENT for j in range ( len ( ans ) ) : NEW_LINE INDENT if ans [ j ] == i + 1 : NEW_LINE INDENT ans . insert ( j , k ) NEW_LINE k += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT ans += list ( range ( k - 1 , len ( N ) - 1 , - 1 ) ) NEW_LINE print ( len ( ans ) ) NEW_LINE print ( * ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3560_A", "sol": 0, "python_code": "MAX = 100005\nprime = [ True for i in range ( MAX ) ]\ndef SieveOfEratosthenes ( ) :\n    prime [ 0 ] = False\n    prime [ 1 ] = False\n    for p in range ( MAX ) :\n        if ( p * p > MAX ) :\n            break\n        if ( prime [ p ] ) :\n            for i in range ( 2 * p , MAX , p ) :\n                prime [ i ] = False\ndef countPrimes ( n ) :\n    SieveOfEratosthenes ( )\n    cnt = 0\n    for i in range ( 2 , n ) :\n        if ( prime [ i ] and prime [ i - 2 ] ) :\n            cnt += 1\n    return cnt\nn = 11\nprint ( countPrimes ( n ) )\n", "python_code_tokenized": "MAX = 100005 NEW_LINE prime = [ True for i in range ( MAX ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( MAX ) : NEW_LINE INDENT if ( p * p > MAX ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def countPrimes ( n ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i - 2 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT n = 11 NEW_LINE print ( countPrimes ( n ) ) NEW_LINE"}
{"id": "aizu_p00015_A", "sol": 0, "python_code": "import sys\nimport math\nn = int ( sys.stdin.readline ( ) )\nfor i in range ( n ) :\n    n1 = int ( sys.stdin.readline ( ) )\n    n2 = int ( sys.stdin.readline ( ) )\n    if n1 + n2 < 100000000000000000000000000000000000000000000000000000000000000000000000000000000 :\n        print ( n1 + n2 )\n    else :\n        print ( \"overflow\" )\n", "python_code_tokenized": "import sys NEW_LINE import math NEW_LINE n = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT n1 = int ( sys . stdin . readline ( ) ) NEW_LINE n2 = int ( sys . stdin . readline ( ) ) NEW_LINE if n1 + n2 < 100000000000000000000000000000000000000000000000000000000000000000000000000000000 : NEW_LINE INDENT print ( n1 + n2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" overflow \" ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC054_B", "sol": 0, "python_code": "N , M = map ( int , input ( ).split ( ) )\nA = [ input ( ) for i in range ( N ) ]\nB = [ input ( ) for i in range ( M ) ]\ndxy = [ ]\nfor y in range ( M ) :\n    for x in range ( M ) :\n        dxy.append ( ( x , y ) )\nflag = 0\nfor y in range ( N ) :\n    for x in range ( N ) :\n        if A [ y ] [ x ] == B [ 0 ] [ 0 ] and flag == 0 :\n            counter = 0\n            for dx , dy in dxy :\n                if flag == 0 :\n                    nx = x + dx\n                    ny = y + dy\n                    if not ( 0 <= nx <= N - 1 ) :\n                        break\n                    if not ( 0 <= ny <= N - 1 ) :\n                        break\n                    if A [ ny ] [ nx ] == B [ dy ] [ dx ] :\n                        counter += 1\n            if counter == M ** 2 :\n                flag = 1\nif flag == 1 :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "N , M = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ input ( ) for i in range ( N ) ] NEW_LINE B = [ input ( ) for i in range ( M ) ] NEW_LINE dxy = [ ] NEW_LINE for y in range ( M ) : NEW_LINE INDENT for x in range ( M ) : NEW_LINE INDENT dxy . append ( ( x , y ) ) NEW_LINE DEDENT DEDENT flag = 0 NEW_LINE for y in range ( N ) : NEW_LINE INDENT for x in range ( N ) : NEW_LINE INDENT if A [ y ] [ x ] == B [ 0 ] [ 0 ] and flag == 0 : NEW_LINE INDENT counter = 0 NEW_LINE for dx , dy in dxy : NEW_LINE INDENT if flag == 0 : NEW_LINE INDENT nx = x + dx NEW_LINE ny = y + dy NEW_LINE if not ( 0 <= nx <= N - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT if not ( 0 <= ny <= N - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT if A [ ny ] [ nx ] == B [ dy ] [ dx ] : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT if counter == M ** 2 : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if flag == 1 : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_266_A", "sol": 0, "python_code": "import math ;\ndef isPerfectSquareString ( str ) :\n    sum = 0 ;\n    l = len ( str ) ;\n    for i in range ( l ) :\n        sum = sum + ord ( str [ i ] ) ;\n    squareRoot = math.sqrt ( sum ) ;\n    return ( ( squareRoot - math.floor ( squareRoot ) ) == 0 ) ;\nstr = \"d\" ;\nif ( isPerfectSquareString ( str ) ) :\n    print ( \"Yes\" ) ;\nelse :\n    print ( \"No\" ) ;\n", "python_code_tokenized": "import math ; NEW_LINE def isPerfectSquareString ( str ) : NEW_LINE INDENT sum = 0 ; NEW_LINE l = len ( str ) ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT sum = sum + ord ( str [ i ] ) ; NEW_LINE DEDENT squareRoot = math . sqrt ( sum ) ; NEW_LINE return ( ( squareRoot - math . floor ( squareRoot ) ) == 0 ) ; NEW_LINE DEDENT str = \" d \" ; NEW_LINE if ( isPerfectSquareString ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3972_A", "sol": 0, "python_code": "import sys\ndef kthSmallest ( arr , l , r , k ) :\n    if ( k > 0 and k <= r - l + 1 ) :\n        pos = partition ( arr , l , r )\n        if ( pos - l == k - 1 ) :\n            return arr [ pos ]\n        if ( pos - l > k - 1 ) :\n            return kthSmallest ( arr , l , pos - 1 , k )\n        return kthSmallest ( arr , pos + 1 , r , k - pos + l - 1 )\n    return sys.maxsize\ndef partition ( arr , l , r ) :\n    x = arr [ r ]\n    i = l\n    for j in range ( l , r ) :\n        if ( arr [ j ] <= x ) :\n            arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]\n            i += 1\n    arr [ i ] , arr [ r ] = arr [ r ] , arr [ i ]\n    return i\nif __name__ == \"__main__\" :\n    arr = [ 12 , 3 , 5 , 7 , 4 , 19 , 26 ]\n    n = len ( arr )\n    k = 3 ;\n    print ( \"K'th smallest element is\" , kthSmallest ( arr , 0 , n - 1 , k ) )\n", "python_code_tokenized": "import sys NEW_LINE def kthSmallest ( arr , l , r , k ) : NEW_LINE INDENT if ( k > 0 and k <= r - l + 1 ) : NEW_LINE INDENT pos = partition ( arr , l , r ) NEW_LINE if ( pos - l == k - 1 ) : NEW_LINE INDENT return arr [ pos ] NEW_LINE DEDENT if ( pos - l > k - 1 ) : NEW_LINE INDENT return kthSmallest ( arr , l , pos - 1 , k ) NEW_LINE DEDENT return kthSmallest ( arr , pos + 1 , r , k - pos + l - 1 ) NEW_LINE DEDENT return sys . maxsize NEW_LINE DEDENT def partition ( arr , l , r ) : NEW_LINE INDENT x = arr [ r ] NEW_LINE i = l NEW_LINE for j in range ( l , r ) : NEW_LINE INDENT if ( arr [ j ] <= x ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT arr [ i ] , arr [ r ] = arr [ r ] , arr [ i ] NEW_LINE return i NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , 3 , 5 , 7 , 4 , 19 , 26 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 ; NEW_LINE print ( \" K ' th \u2581 smallest \u2581 element \u2581 is \" , kthSmallest ( arr , 0 , n - 1 , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1119_A", "sol": 0, "python_code": "def solve ( n , k ) :\n    mini = 0\n    x1 = 1\n    a = [ 0 for i in range ( k ) ]\n    for i in range ( 1 , k + 1 ) :\n        mini += x1\n        a [ i - 1 ] = x1\n        x1 += 1\n    if ( n < mini ) :\n        print ( \"-1\" , end = \"\" )\n        return\n    rem = n - mini\n    cnt = int ( rem / k )\n    rem = rem % k\n    for i in range ( k ) :\n        a [ i ] += cnt\n    i = k - 1\n    while ( i > 0 and rem > 0 ) :\n        xx = a [ i - 1 ] * 2\n        left = xx - a [ i ]\n        if ( rem >= left ) :\n            a [ i ] = xx\n            rem -= left\n        else :\n            a [ i ] += rem\n            rem = 0\n        i -= 1\n    sum = a [ 0 ]\n    for i in range ( 1 , k ) :\n        if ( a [ i ] > 2 * a [ i - 1 ] ) :\n            print ( \"-1\" , end = \"\" )\n            return\n        sum += a [ i ]\n    if ( sum != n ) :\n        print ( \"-1\" , end = \"\" )\n        return\n    for i in range ( k ) :\n        print ( a [ i ] , end = \" \" )\nif __name__ == '__main__' :\n    n = 26\n    k = 6\n    solve ( n , k )\n", "python_code_tokenized": "def solve ( n , k ) : NEW_LINE INDENT mini = 0 NEW_LINE x1 = 1 NEW_LINE a = [ 0 for i in range ( k ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT mini += x1 NEW_LINE a [ i - 1 ] = x1 NEW_LINE x1 += 1 NEW_LINE DEDENT if ( n < mini ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT rem = n - mini NEW_LINE cnt = int ( rem / k ) NEW_LINE rem = rem % k NEW_LINE for i in range ( k ) : NEW_LINE INDENT a [ i ] += cnt NEW_LINE DEDENT i = k - 1 NEW_LINE while ( i > 0 and rem > 0 ) : NEW_LINE INDENT xx = a [ i - 1 ] * 2 NEW_LINE left = xx - a [ i ] NEW_LINE if ( rem >= left ) : NEW_LINE INDENT a [ i ] = xx NEW_LINE rem -= left NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] += rem NEW_LINE rem = 0 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT sum = a [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT if ( a [ i ] > 2 * a [ i - 1 ] ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT sum += a [ i ] NEW_LINE DEDENT if ( sum != n ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 26 NEW_LINE k = 6 NEW_LINE solve ( n , k ) NEW_LINE DEDENT"}
{"id": "projecteuler_p172_A", "sol": 0, "python_code": "import math\nLENGTH = 18\nMAX_COUNT = 3\nBASE = 10\ndef compute ( ) :\n    ans = partition_and_count ( LENGTH , MAX_COUNT , [ ] )\n    ans = divide_exactly ( ans * ( BASE - 1 ) , BASE )\n    return str ( ans )\ndef partition_and_count ( sum , max , terms ) :\n    if len ( terms ) == BASE :\n        return count_ways ( terms ) if ( sum == 0 ) else 0\n    else :\n        result = 0\n        for i in reversed ( range ( min ( max , sum ) + 1 ) ) :\n            terms.append ( i )\n            result += partition_and_count ( sum - i , i , terms )\n            terms.pop ( )\n        return result\ndef count_ways ( freqs ) :\n    histogram = [ 0 ] * ( MAX_COUNT + 1 )\n    for x in freqs :\n        histogram [ x ] += 1\n    ways = math.factorial ( BASE )\n    for x in histogram :\n        ways //= math.factorial ( x )\n    ways *= math.factorial ( LENGTH )\n    for x in freqs :\n        ways //= math.factorial ( x )\n    return ways\ndef divide_exactly ( x , y ) :\n    if x % y != 0 :\n        raise ValueError ( \"Not divisible\" )\n    return x // y\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import math NEW_LINE LENGTH = 18 NEW_LINE MAX_COUNT = 3 NEW_LINE BASE = 10 NEW_LINE def compute ( ) : NEW_LINE INDENT ans = partition_and_count ( LENGTH , MAX_COUNT , [ ] ) NEW_LINE ans = divide_exactly ( ans * ( BASE - 1 ) , BASE ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def partition_and_count ( sum , max , terms ) : NEW_LINE INDENT if len ( terms ) == BASE : NEW_LINE INDENT return count_ways ( terms ) if ( sum == 0 ) else 0 NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE for i in reversed ( range ( min ( max , sum ) + 1 ) ) : NEW_LINE INDENT terms . append ( i ) NEW_LINE result += partition_and_count ( sum - i , i , terms ) NEW_LINE terms . pop ( ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT def count_ways ( freqs ) : NEW_LINE INDENT histogram = [ 0 ] * ( MAX_COUNT + 1 ) NEW_LINE for x in freqs : NEW_LINE INDENT histogram [ x ] += 1 NEW_LINE DEDENT ways = math . factorial ( BASE ) NEW_LINE for x in histogram : NEW_LINE INDENT ways //= math . factorial ( x ) NEW_LINE DEDENT ways *= math . factorial ( LENGTH ) NEW_LINE for x in freqs : NEW_LINE INDENT ways //= math . factorial ( x ) NEW_LINE DEDENT return ways NEW_LINE DEDENT def divide_exactly ( x , y ) : NEW_LINE INDENT if x % y != 0 : NEW_LINE INDENT raise ValueError ( \" Not \u2581 divisible \" ) NEW_LINE DEDENT return x // y NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2640_A", "sol": 0, "python_code": "def max_intersection ( center , length , k ) :\n    center.sort ( ) ;\n    if ( center [ 2 ] - center [ 0 ] >= 2 * k + length ) :\n        return 0 ;\n    elif ( center [ 2 ] - center [ 0 ] >= 2 * k ) :\n        return ( 2 * k - ( center [ 2 ] - center [ 0 ] - length ) ) ;\n    else :\n        return length ;\ncenter = [ 1 , 2 , 3 ] ;\nL = 1 ;\nK = 1 ;\nprint ( max_intersection ( center , L , K ) ) ;\n", "python_code_tokenized": "def max_intersection ( center , length , k ) : NEW_LINE INDENT center . sort ( ) ; NEW_LINE if ( center [ 2 ] - center [ 0 ] >= 2 * k + length ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( center [ 2 ] - center [ 0 ] >= 2 * k ) : NEW_LINE INDENT return ( 2 * k - ( center [ 2 ] - center [ 0 ] - length ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return length ; NEW_LINE DEDENT DEDENT center = [ 1 , 2 , 3 ] ; NEW_LINE L = 1 ; NEW_LINE K = 1 ; NEW_LINE print ( max_intersection ( center , L , K ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_1480_A", "sol": 0, "python_code": "def printRepeating ( arr , size ) :\n    print ( \"The repeating elements are: \" )\n    for i in range ( 0 , size ) :\n        if arr [ abs ( arr [ i ] ) ] >= 0 :\n            arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ]\n        else :\n            print ( abs ( arr [ i ] ) , end = \" \" )\narr = [ 1 , 2 , 3 , 1 , 3 , 6 , 6 ]\narr_size = len ( arr )\nprintRepeating ( arr , arr_size )\n", "python_code_tokenized": "def printRepeating ( arr , size ) : NEW_LINE INDENT print ( \" The \u2581 repeating \u2581 elements \u2581 are : \u2581 \" ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if arr [ abs ( arr [ i ] ) ] >= 0 : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ i ] ) , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 1 , 3 , 6 , 6 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE"}
{"id": "geeksforgeeks_1495_A", "sol": 0, "python_code": "def printRepeating ( arr , size ) :\n    print ( \" The repeating elements are\" , end = \" \" )\n    for i in range ( 0 , size ) :\n        if ( arr [ abs ( arr [ i ] ) ] > 0 ) :\n            arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ]\n        else :\n            print ( abs ( arr [ i ] ) , end = \" \" )\narr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ]\narr_size = len ( arr )\nprintRepeating ( arr , arr_size )\n", "python_code_tokenized": "def printRepeating ( arr , size ) : NEW_LINE INDENT print ( \" \u2581 The \u2581 repeating \u2581 elements \u2581 are \" , end = \" \u2581 \" ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ abs ( arr [ i ] ) ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ i ] ) , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE"}
{"id": "codeforces_681_B", "sol": 0, "python_code": "nums = input ( ).split ( )\nn = int ( nums [ 0 ] )\na = 0\nwhile ( a <= n ) :\n    if ( a * 1234567 > n ) :\n        print ( \"NO\" )\n        a = n\n    else :\n        b = 0\n        while ( b <= n ) :\n            if ( a * 1234567 + b * 123456 > n ) :\n                b = n\n            else :\n                m = n - ( a * 1234567 + b * 123456 )\n                if ( m % 1234 == 0 ) :\n                    print ( \"YES\" )\n                    b = n\n                    a = n\n            b = b + 1\n    a = a + 1\n", "python_code_tokenized": "nums = input ( ) . split ( ) NEW_LINE n = int ( nums [ 0 ] ) NEW_LINE a = 0 NEW_LINE while ( a <= n ) : NEW_LINE INDENT if ( a * 1234567 > n ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE a = n NEW_LINE DEDENT else : NEW_LINE INDENT b = 0 NEW_LINE while ( b <= n ) : NEW_LINE INDENT if ( a * 1234567 + b * 123456 > n ) : NEW_LINE INDENT b = n NEW_LINE DEDENT else : NEW_LINE INDENT m = n - ( a * 1234567 + b * 123456 ) NEW_LINE if ( m % 1234 == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE b = n NEW_LINE a = n NEW_LINE DEDENT DEDENT b = b + 1 NEW_LINE DEDENT DEDENT a = a + 1 NEW_LINE DEDENT"}
{"id": "codeforces_1608_A", "sol": 0, "python_code": "from lib2to3.pgen2.token import NEWLINE\nt = int ( input ( ) ) ;\nfor j in range ( 0 , t ) :\n    x = int ( input ( ) ) ;\n    if ( x == 1 ) :\n        print ( 1 ) ;\n    else :\n        for i in range ( 1 , x + 1 ) :\n            print ( i + 1 , end = \" \" ) ;\n", "python_code_tokenized": "from lib2to3 . pgen2 . token import NEWLINE NEW_LINE t = int ( input ( ) ) ; NEW_LINE for j in range ( 0 , t ) : NEW_LINE INDENT x = int ( input ( ) ) ; NEW_LINE if ( x == 1 ) : NEW_LINE INDENT print ( 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , x + 1 ) : NEW_LINE INDENT print ( i + 1 , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "aizu_p01447_A", "sol": 0, "python_code": "import math\nprint ( math.ceil ( math.log ( int ( input ( ) ) ) / math.log ( 3 ) ) )\n", "python_code_tokenized": "import math NEW_LINE print ( math . ceil ( math . log ( int ( input ( ) ) ) / math . log ( 3 ) ) ) NEW_LINE"}
{"id": "codeforces_519_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = sum ( list ( map ( int , input ( ).split ( ) ) ) )\nb = sum ( list ( map ( int , input ( ).split ( ) ) ) )\nc = sum ( list ( map ( int , input ( ).split ( ) ) ) )\nprint ( a - b , b - c , sep = '\\n' )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = sum ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE b = sum ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE c = sum ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE print ( a - b , b - c , sep = ' \\n ' ) NEW_LINE"}
{"id": "geeksforgeeks_2828_A", "sol": 0, "python_code": "def findMinLength ( arr , n ) :\n    min = len ( arr [ 0 ] )\n    for i in range ( 1 , n ) :\n        if ( len ( arr [ i ] ) < min ) :\n            min = len ( arr [ i ] )\n    return ( min )\ndef commonPrefix ( arr , n ) :\n    minlen = findMinLength ( arr , n )\n    result = \"\"\n    for i in range ( minlen ) :\n        current = arr [ 0 ] [ i ]\n        for j in range ( 1 , n ) :\n            if ( arr [ j ] [ i ] != current ) :\n                return result\n        result = result + current\n    return ( result )\nif __name__ == \"__main__\" :\n    arr = [ \"geeksforgeeks\" , \"geeks\" , \"geek\" , \"geezer\" ]\n    n = len ( arr )\n    ans = commonPrefix ( arr , n )\n    if ( len ( ans ) ) :\n        print ( \"The longest common prefix is \" , ans )\n    else :\n        print ( \"There is no common prefix\" )\n", "python_code_tokenized": "def findMinLength ( arr , n ) : NEW_LINE INDENT min = len ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( len ( arr [ i ] ) < min ) : NEW_LINE INDENT min = len ( arr [ i ] ) NEW_LINE DEDENT DEDENT return ( min ) NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT minlen = findMinLength ( arr , n ) NEW_LINE result = \" \" NEW_LINE for i in range ( minlen ) : NEW_LINE INDENT current = arr [ 0 ] [ i ] NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ j ] [ i ] != current ) : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT result = result + current NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeksforgeeks \" , \" geeks \" , \" geek \" , \" geezer \" ] NEW_LINE n = len ( arr ) NEW_LINE ans = commonPrefix ( arr , n ) NEW_LINE if ( len ( ans ) ) : NEW_LINE INDENT print ( \" The \u2581 longest \u2581 common \u2581 prefix \u2581 is \u2581 \" , ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" There \u2581 is \u2581 no \u2581 common \u2581 prefix \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3023_A", "sol": 0, "python_code": "def minRotation ( input , unlock_code ) :\n    rotation = 0 ;\n    while ( input > 0 or unlock_code > 0 ) :\n        input_digit = input % 10 ;\n        code_digit = unlock_code % 10 ;\n        rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ;\n        input = int ( input / 10 ) ;\n        unlock_code = int ( unlock_code / 10 ) ;\n    return rotation ;\ninput = 28756 ;\nunlock_code = 98234 ;\nprint ( \"Minimum Rotation =\" , minRotation ( input , unlock_code ) ) ;\n", "python_code_tokenized": "def minRotation ( input , unlock_code ) : NEW_LINE INDENT rotation = 0 ; NEW_LINE while ( input > 0 or unlock_code > 0 ) : NEW_LINE INDENT input_digit = input % 10 ; NEW_LINE code_digit = unlock_code % 10 ; NEW_LINE rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ; NEW_LINE input = int ( input / 10 ) ; NEW_LINE unlock_code = int ( unlock_code / 10 ) ; NEW_LINE DEDENT return rotation ; NEW_LINE DEDENT input = 28756 ; NEW_LINE unlock_code = 98234 ; NEW_LINE print ( \" Minimum \u2581 Rotation \u2581 = \" , minRotation ( input , unlock_code ) ) ; NEW_LINE"}
{"id": "aizu_p00142_A", "sol": 0, "python_code": "import itertools\ndef func ( n ) :\n    rest = { i ** 2 % n for i in range ( 1 , n ) }\n    count = [ 0 ] * n\n    for x , y in itertools.combinations ( rest , 2 ) :\n        count [ x - y ] += 2\n    for i in range ( n // 2 ) :\n        print ( count [ i + 1 ] + count [ n - i - 1 ] )\ndef main ( ) :\n    while True :\n        n = int ( input ( ) )\n        if n == 0 :\n            break\n        func ( n )\nmain ( )\n", "python_code_tokenized": "import itertools NEW_LINE def func ( n ) : NEW_LINE INDENT rest = { i ** 2 % n for i in range ( 1 , n ) } NEW_LINE count = [ 0 ] * n NEW_LINE for x , y in itertools . combinations ( rest , 2 ) : NEW_LINE INDENT count [ x - y ] += 2 NEW_LINE DEDENT for i in range ( n // 2 ) : NEW_LINE INDENT print ( count [ i + 1 ] + count [ n - i - 1 ] ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT func ( n ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "aizu_p00564_A", "sol": 0, "python_code": "N , A , B , C , D = map ( int , input ( ).split ( ) )\nif ( A <= N or C <= N ) :\n    if N % A == 0 :\n        X = int ( N / A ) * B\n    else :\n        X = int ( N / A + 1 ) * B\n    if N % C == 0 :\n        Y = int ( N / C ) * D\n    else :\n        Y = int ( N / C + 1 ) * D\nelse :\n    X = B\n    Y = D\nif X <= Y :\n    print ( int ( X ) )\nelse :\n    print ( int ( Y ) )\n", "python_code_tokenized": "N , A , B , C , D = map ( int , input ( ) . split ( ) ) NEW_LINE if ( A <= N or C <= N ) : NEW_LINE INDENT if N % A == 0 : NEW_LINE INDENT X = int ( N / A ) * B NEW_LINE DEDENT else : NEW_LINE INDENT X = int ( N / A + 1 ) * B NEW_LINE DEDENT if N % C == 0 : NEW_LINE INDENT Y = int ( N / C ) * D NEW_LINE DEDENT else : NEW_LINE INDENT Y = int ( N / C + 1 ) * D NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT X = B NEW_LINE Y = D NEW_LINE DEDENT if X <= Y : NEW_LINE INDENT print ( int ( X ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( Y ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC048_A", "sol": 0, "python_code": "name = input ( ).split ( )\nb = list ( name [ 1 ] )\nprint ( \"A\" + b [ 0 ] + \"C\" )\n", "python_code_tokenized": "name = input ( ) . split ( ) NEW_LINE b = list ( name [ 1 ] ) NEW_LINE print ( \" A \" + b [ 0 ] + \" C \" ) NEW_LINE"}
{"id": "geeksforgeeks_2260_A", "sol": 0, "python_code": "def smallestEven ( n ) :\n    if ( n == 1 ) :\n        return 0\n    return pow ( 10 , n - 1 )\nn = 4\nprint ( smallestEven ( n ) )\n", "python_code_tokenized": "def smallestEven ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return pow ( 10 , n - 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( smallestEven ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2259_A", "sol": 0, "python_code": "def smallestOdd ( n ) :\n    if ( n == 1 ) :\n        return 1\n    return pow ( 10 , n - 1 ) + 1\nn = 4\nprint ( smallestOdd ( n ) )\n", "python_code_tokenized": "def smallestOdd ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return pow ( 10 , n - 1 ) + 1 NEW_LINE DEDENT n = 4 NEW_LINE print ( smallestOdd ( n ) ) NEW_LINE"}
{"id": "codeforces_1619_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    s = input ( )\n    if len ( s ) % 2 == 0 and s [ : len ( s ) // 2 ] == s [ len ( s ) // 2 : ] :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE if len ( s ) % 2 == 0 and s [ : len ( s ) // 2 ] == s [ len ( s ) // 2 : ] : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1040_B", "sol": 0, "python_code": "import sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\nn , k = map ( int , input ( ).split ( ) )\nm = 2 * k + 1\nx = [ [ ] for _ in range ( m ) ]\nfor i in range ( 1 , n + 1 ) :\n    x [ i % m ].append ( i )\nl = n + 1\nfor y in x :\n    if not y or l <= len ( y ) :\n        continue\n    if y [ 0 ] - k <= 1 and n <= y [ - 1 ] + k :\n        l , ans = len ( y ) , y\nprint ( l )\nsys.stdout.write ( \" \".join ( map ( str , ans ) ) )\n", "python_code_tokenized": "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE m = 2 * k + 1 NEW_LINE x = [ [ ] for _ in range ( m ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x [ i % m ] . append ( i ) NEW_LINE DEDENT l = n + 1 NEW_LINE for y in x : NEW_LINE INDENT if not y or l <= len ( y ) : NEW_LINE INDENT continue NEW_LINE DEDENT if y [ 0 ] - k <= 1 and n <= y [ - 1 ] + k : NEW_LINE INDENT l , ans = len ( y ) , y NEW_LINE DEDENT DEDENT print ( l ) NEW_LINE sys . stdout . write ( \" \u2581 \" . join ( map ( str , ans ) ) ) NEW_LINE"}
{"id": "codeforces_1481_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    r = 0\n    u = 0\n    d = 0\n    l = 0\n    x , y = map ( int , input ( ).split ( ) )\n    li = list ( input ( ) )\n    res = 0\n    if x > 0 :\n        r = x\n    elif x < 0 :\n        l = abs ( x )\n    if y > 0 :\n        u = y\n    elif y < 0 :\n        d = abs ( y )\n    for i in li :\n        if i == 'R' :\n            if r != 0 :\n                r -= 1\n        elif i == \"U\" :\n            if u != 0 :\n                u -= 1\n        elif i == \"D\" :\n            if d != 0 :\n                d -= 1\n        elif i == 'L' :\n            if l != 0 :\n                l -= 1\n        if r == 0 and u == 0 and d == 0 and l == 0 :\n            res = 1\n            break\n    if res == 0 :\n        print ( \"NO\" )\n    elif res == 1 :\n        print ( \"YES\" )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT r = 0 NEW_LINE u = 0 NEW_LINE d = 0 NEW_LINE l = 0 NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE li = list ( input ( ) ) NEW_LINE res = 0 NEW_LINE if x > 0 : NEW_LINE INDENT r = x NEW_LINE DEDENT elif x < 0 : NEW_LINE INDENT l = abs ( x ) NEW_LINE DEDENT if y > 0 : NEW_LINE INDENT u = y NEW_LINE DEDENT elif y < 0 : NEW_LINE INDENT d = abs ( y ) NEW_LINE DEDENT for i in li : NEW_LINE INDENT if i == ' R ' : NEW_LINE INDENT if r != 0 : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT elif i == \" U \" : NEW_LINE INDENT if u != 0 : NEW_LINE INDENT u -= 1 NEW_LINE DEDENT DEDENT elif i == \" D \" : NEW_LINE INDENT if d != 0 : NEW_LINE INDENT d -= 1 NEW_LINE DEDENT DEDENT elif i == ' L ' : NEW_LINE INDENT if l != 0 : NEW_LINE INDENT l -= 1 NEW_LINE DEDENT DEDENT if r == 0 and u == 0 and d == 0 and l == 0 : NEW_LINE INDENT res = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if res == 0 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT elif res == 1 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_322_A", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nprint ( m + n - 1 )\nif n == 1 and m == 1 :\n    print ( 1 , 1 )\nelse :\n    for i in range ( 1 , n + 1 ) :\n        print ( i , 1 )\n    for i in range ( 2 , m + 1 ) :\n        print ( 1 , i )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( m + n - 1 ) NEW_LINE if n == 1 and m == 1 : NEW_LINE INDENT print ( 1 , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( i , 1 ) NEW_LINE DEDENT for i in range ( 2 , m + 1 ) : NEW_LINE INDENT print ( 1 , i ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_707_B", "sol": 0, "python_code": "from collections import defaultdict , deque\nfrom functools import lru_cache\nfrom heapq import heappush , heappop\ndef solution ( ) :\n    _ , m , k = map ( int , input ( ).split ( ) )\n    if k == 0 :\n        print ( - 1 )\n        return ;\n    graph = defaultdict ( list )\n    for _ in range ( m ) :\n        a , b , w = map ( int , input ( ).split ( ) )\n        graph [ a ].append ( ( b , w ) )\n        graph [ b ].append ( ( a , w ) )\n    store = set ( map ( int , input ( ).split ( ) ) )\n    ans = float ( \"inf\" )\n    for node in store :\n        for nbr , w in graph [ node ] :\n            if nbr not in store :\n                ans = min ( ans , w )\n    if ans == float ( \"inf\" ) :\n        print ( - 1 )\n        return ;\n    print ( ans )\nimport sys\nimport threading\nsys.setrecursionlimit ( 1 << 30 )\nthreading.stack_size ( 1 << 27 )\nthread = threading.Thread ( target = solution )\nthread.start ( ) ; thread.join ( )\n", "python_code_tokenized": "from collections import defaultdict , deque NEW_LINE from functools import lru_cache NEW_LINE from heapq import heappush , heappop NEW_LINE def solution ( ) : NEW_LINE INDENT _ , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return ; NEW_LINE DEDENT graph = defaultdict ( list ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b , w = map ( int , input ( ) . split ( ) ) NEW_LINE graph [ a ] . append ( ( b , w ) ) NEW_LINE graph [ b ] . append ( ( a , w ) ) NEW_LINE DEDENT store = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = float ( \" inf \" ) NEW_LINE for node in store : NEW_LINE INDENT for nbr , w in graph [ node ] : NEW_LINE INDENT if nbr not in store : NEW_LINE INDENT ans = min ( ans , w ) NEW_LINE DEDENT DEDENT DEDENT if ans == float ( \" inf \" ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return ; NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT import sys NEW_LINE import threading NEW_LINE sys . setrecursionlimit ( 1 << 30 ) NEW_LINE threading . stack_size ( 1 << 27 ) NEW_LINE thread = threading . Thread ( target = solution ) NEW_LINE thread . start ( ) ; thread . join ( ) NEW_LINE"}
{"id": "geeksforgeeks_1601_A", "sol": 0, "python_code": "def sumArr ( arr , n ) :\n    sum = 0\n    for i in range ( n ) :\n        sum += arr [ i ]\n    return sum\ndef maxSum ( arr , n , k ) :\n    arr.sort ( reverse = False )\n    i = 0\n    while ( i < n and k > 0 and arr [ i ] < 0 ) :\n        arr [ i ] *= - 1\n        k -= 1\n        i += 1\n    if ( k % 2 == 1 ) :\n        min = 0\n        for i in range ( 1 , n ) :\n            if ( arr [ min ] > arr [ i ] ) :\n                min = i\n        arr [ min ] *= - 1\n    return sumArr ( arr , n )\nif __name__ == '__main__' :\n    arr = [ - 5 , 4 , 1 , 3 , 2 ]\n    n = len ( arr )\n    k = 4\n    print ( maxSum ( arr , n , k ) )\n", "python_code_tokenized": "def sumArr ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT def maxSum ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE i = 0 NEW_LINE while ( i < n and k > 0 and arr [ i ] < 0 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE k -= 1 NEW_LINE i += 1 NEW_LINE DEDENT if ( k % 2 == 1 ) : NEW_LINE INDENT min = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ min ] > arr [ i ] ) : NEW_LINE INDENT min = i NEW_LINE DEDENT DEDENT arr [ min ] *= - 1 NEW_LINE DEDENT return sumArr ( arr , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ - 5 , 4 , 1 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( maxSum ( arr , n , k ) ) NEW_LINE DEDENT"}
{"id": "codeforces_408_B", "sol": 0, "python_code": "from collections import defaultdict , deque\nfrom functools import lru_cache\nfrom heapq import heappush , heappop\nfrom typing import Counter\nfrom bisect import bisect_right , bisect_left\nimport math\nhpop = heappop\nhpush = heappush\ndef solution ( ) :\n    line = input ( )\n    bought_count = Counter ( line )\n    line = input ( )\n    made_cout = Counter ( line )\n    res = 0\n    for color in made_cout :\n        if color not in bought_count :\n            return print ( - 1 )\n        res += min ( bought_count [ color ] , made_cout [ color ] )\n    print ( res )\ndef main ( ) :\n    t = 1\n    for _ in range ( t ) :\n        solution ( )\nmain ( )\n", "python_code_tokenized": "from collections import defaultdict , deque NEW_LINE from functools import lru_cache NEW_LINE from heapq import heappush , heappop NEW_LINE from typing import Counter NEW_LINE from bisect import bisect_right , bisect_left NEW_LINE import math NEW_LINE hpop = heappop NEW_LINE hpush = heappush NEW_LINE def solution ( ) : NEW_LINE INDENT line = input ( ) NEW_LINE bought_count = Counter ( line ) NEW_LINE line = input ( ) NEW_LINE made_cout = Counter ( line ) NEW_LINE res = 0 NEW_LINE for color in made_cout : NEW_LINE INDENT if color not in bought_count : NEW_LINE INDENT return print ( - 1 ) NEW_LINE DEDENT res += min ( bought_count [ color ] , made_cout [ color ] ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = 1 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT solution ( ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_62_A", "sol": 0, "python_code": "def find_value ( a , n , k ) :\n    sum = 0\n    for i in range ( n ) :\n        sum += a [ i ]\n    return sum % k\nif __name__ == \"__main__\" :\n    n , k = 5 , 3 ;\n    a = [ 12 , 4 , 13 , 0 , 5 ] ;\n    print ( find_value ( a , n , k ) )\n", "python_code_tokenized": "def find_value ( a , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return sum % k NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 5 , 3 ; NEW_LINE a = [ 12 , 4 , 13 , 0 , 5 ] ; NEW_LINE print ( find_value ( a , n , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_722_A", "sol": 0, "python_code": "def maxOR ( arr , n ) :\n    maxVal = 0 ;\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            maxVal = max ( maxVal , arr [ i ] | arr [ j ] ) ;\n    return maxVal ;\nif __name__ == '__main__' :\n    arr = [ 4 , 8 , 12 , 16 ] ;\n    n = len ( arr ) ;\n    print ( maxOR ( arr , n ) ) ;\n", "python_code_tokenized": "def maxOR ( arr , n ) : NEW_LINE INDENT maxVal = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] | arr [ j ] ) ; NEW_LINE DEDENT DEDENT return maxVal ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxOR ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2243_A", "sol": 0, "python_code": "def findFourElements ( arr , n , X ) :\n    mp = { }\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            mp [ arr [ i ] + arr [ j ] ] = [ i , j ]\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            summ = arr [ i ] + arr [ j ]\n            if ( X - summ ) in mp :\n                p = mp [ X - summ ]\n                if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) :\n                    print ( arr [ i ] , \", \" , arr [ j ] , \", \" , arr [ p [ 0 ] ] , \", \" , arr [ p [ 1 ] ] , sep = \"\" )\n                    return\narr = [ 10 , 20 , 30 , 40 , 1 , 2 ]\nn = len ( arr )\nX = 91\nfindFourElements ( arr , n , X )\n", "python_code_tokenized": "def findFourElements ( arr , n , X ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = [ i , j ] NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT summ = arr [ i ] + arr [ j ] NEW_LINE if ( X - summ ) in mp : NEW_LINE INDENT p = mp [ X - summ ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : NEW_LINE INDENT print ( arr [ i ] , \" , \u2581 \" , arr [ j ] , \" , \u2581 \" , arr [ p [ 0 ] ] , \" , \u2581 \" , arr [ p [ 1 ] ] , sep = \" \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT arr = [ 10 , 20 , 30 , 40 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE X = 91 NEW_LINE findFourElements ( arr , n , X ) NEW_LINE"}
{"id": "geeksforgeeks_735_A", "sol": 0, "python_code": "dp = [ 0 ] * 1024 ;\ndef get_binary ( u ) :\n    ans = 0 ;\n    while ( u ) :\n        rem = u % 10 ;\n        ans |= ( 1 << rem ) ;\n        u //= 10 ;\n    return ans ;\ndef recur ( u , array , n ) :\n    if ( u == 0 ) :\n        return 0 ;\n    if ( dp [ u ] != - 1 ) :\n        return dp [ u ] ;\n    temp = 0 ;\n    for i in range ( n ) :\n        mask = get_binary ( array [ i ] ) ;\n        if ( ( mask | u ) == u ) :\n            dp [ u ] = max ( max ( 0 , dp [ u ^ mask ] ) + array [ i ] , dp [ u ] ) ;\n    return dp [ u ] ;\ndef solve ( array , n ) :\n    i = 0\n    while ( i < ( 1 << 10 ) ) :\n        dp [ i ] = - 1 ;\n        i += 1\n    ans = 0 ;\n    i = 0\n    while ( i < ( 1 << 10 ) ) :\n        ans = max ( ans , recur ( i , array , n ) ) ;\n        i += 1\n    return ans ;\nif __name__ == \"__main__\" :\n    array = [ 22 , 132 , 4 , 45 , 12 , 223 ] ;\n    n = len ( array ) ;\n    print ( solve ( array , n ) ) ;\n", "python_code_tokenized": "dp = [ 0 ] * 1024 ; NEW_LINE def get_binary ( u ) : NEW_LINE INDENT ans = 0 ; NEW_LINE while ( u ) : NEW_LINE INDENT rem = u % 10 ; NEW_LINE ans |= ( 1 << rem ) ; NEW_LINE u //= 10 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def recur ( u , array , n ) : NEW_LINE INDENT if ( u == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ u ] != - 1 ) : NEW_LINE INDENT return dp [ u ] ; NEW_LINE DEDENT temp = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mask = get_binary ( array [ i ] ) ; NEW_LINE if ( ( mask | u ) == u ) : NEW_LINE INDENT dp [ u ] = max ( max ( 0 , dp [ u ^ mask ] ) + array [ i ] , dp [ u ] ) ; NEW_LINE DEDENT DEDENT return dp [ u ] ; NEW_LINE DEDENT def solve ( array , n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < ( 1 << 10 ) ) : NEW_LINE INDENT dp [ i ] = - 1 ; NEW_LINE i += 1 NEW_LINE DEDENT ans = 0 ; NEW_LINE i = 0 NEW_LINE while ( i < ( 1 << 10 ) ) : NEW_LINE INDENT ans = max ( ans , recur ( i , array , n ) ) ; NEW_LINE i += 1 NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT array = [ 22 , 132 , 4 , 45 , 12 , 223 ] ; NEW_LINE n = len ( array ) ; NEW_LINE print ( solve ( array , n ) ) ; NEW_LINE DEDENT"}
{"id": "codejam_11_22", "sol": 0, "python_code": "inFile = open ( \"B-large.in.in\" , 'r' )\noutFile = open ( \"B.out\" , 'w' )\nN = int ( inFile.readline ( ) )\nfor I in range ( 1 , N + 1 ) :\n    numPoints , minDist = tuple ( [ int ( x ) for x in inFile.readline ( ).split ( ) ] )\n    vendors = [ ]\n    for i in range ( numPoints ) :\n        point , numVendors = tuple ( [ int ( x ) for x in inFile.readline ( ).split ( ) ] )\n        for j in range ( numVendors ) :\n            vendors.append ( point )\n    maxMove = 0\n    for i in range ( 1 , len ( vendors ) ) :\n        if vendors [ i ] - vendors [ i - 1 ] < minDist :\n            maxMove = max ( maxMove , vendors [ i - 1 ] - vendors [ i ] + minDist )\n            vendors [ i ] = vendors [ i - 1 ] + minDist\n    outFile.write ( \"Case #\" + str ( I ) + \": \" + str ( maxMove / 2 ) + \"\\n\" )\n    print ( \"Case #\" + str ( I ) + \": \" + str ( maxMove / 2 ) )\n", "python_code_tokenized": "inFile = open ( \" B - large . in . in \" , ' r ' ) NEW_LINE outFile = open ( \" B . out \" , ' w ' ) NEW_LINE N = int ( inFile . readline ( ) ) NEW_LINE for I in range ( 1 , N + 1 ) : NEW_LINE INDENT numPoints , minDist = tuple ( [ int ( x ) for x in inFile . readline ( ) . split ( ) ] ) NEW_LINE vendors = [ ] NEW_LINE for i in range ( numPoints ) : NEW_LINE INDENT point , numVendors = tuple ( [ int ( x ) for x in inFile . readline ( ) . split ( ) ] ) NEW_LINE for j in range ( numVendors ) : NEW_LINE INDENT vendors . append ( point ) NEW_LINE DEDENT DEDENT maxMove = 0 NEW_LINE for i in range ( 1 , len ( vendors ) ) : NEW_LINE INDENT if vendors [ i ] - vendors [ i - 1 ] < minDist : NEW_LINE INDENT maxMove = max ( maxMove , vendors [ i - 1 ] - vendors [ i ] + minDist ) NEW_LINE vendors [ i ] = vendors [ i - 1 ] + minDist NEW_LINE DEDENT DEDENT outFile . write ( \" Case \u2581 # \" + str ( I ) + \" : \u2581 \" + str ( maxMove / 2 ) + \" \\n \" ) NEW_LINE print ( \" Case \u2581 # \" + str ( I ) + \" : \u2581 \" + str ( maxMove / 2 ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1257_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    x , y = [ int ( c ) for c in input ( ).split ( ) ]\n    print ( 'yes' if x > 3 or x >= y or ( x == 2 and y == 3 ) else 'no' )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x , y = [ int ( c ) for c in input ( ) . split ( ) ] NEW_LINE print ( ' yes ' if x > 3 or x >= y or ( x == 2 and y == 3 ) else ' no ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5098_A", "sol": 0, "python_code": "def count ( n ) :\n    if ( n < 4 ) :\n        return - 1\n    rem = n % 4\n    if ( rem == 0 ) :\n        return n // 4\n    if ( rem == 1 ) :\n        if ( n < 9 ) :\n            return - 1\n        return ( n - 9 ) // 4 + 1\n    if ( rem == 2 ) :\n        return ( n - 6 ) // 4 + 1\n    if ( rem == 3 ) :\n        if ( n < 15 ) :\n            return - 1\n        return ( n - 15 ) // 4 + 2\nn = 90\nprint ( count ( n ) )\nn = 143\nprint ( count ( n ) )\n", "python_code_tokenized": "def count ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT rem = n % 4 NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return n // 4 NEW_LINE DEDENT if ( rem == 1 ) : NEW_LINE INDENT if ( n < 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n - 9 ) // 4 + 1 NEW_LINE DEDENT if ( rem == 2 ) : NEW_LINE INDENT return ( n - 6 ) // 4 + 1 NEW_LINE DEDENT if ( rem == 3 ) : NEW_LINE INDENT if ( n < 15 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n - 15 ) // 4 + 2 NEW_LINE DEDENT DEDENT n = 90 NEW_LINE print ( count ( n ) ) NEW_LINE n = 143 NEW_LINE print ( count ( n ) ) NEW_LINE"}
{"id": "codeforces_878_A", "sol": 0, "python_code": "n = int ( input ( ) )\na , b = 1023 , 0\nfor _ in range ( n ) :\n    c , d = input ( ).split ( )\n    d = int ( d )\n    if c == '|' :\n        a , b = a | d , b | d\n    elif c == '&' :\n        a , b = a & d , b & d\n    elif c == '^' :\n        a , b = a ^ d , b ^ d\nprint ( f'2\\n| {a^b^1023}\\n^ {a^1023}' )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a , b = 1023 , 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT c , d = input ( ) . split ( ) NEW_LINE d = int ( d ) NEW_LINE if c == ' | ' : NEW_LINE INDENT a , b = a | d , b | d NEW_LINE DEDENT elif c == ' & ' : NEW_LINE INDENT a , b = a & d , b & d NEW_LINE DEDENT elif c == ' ^ ' : NEW_LINE INDENT a , b = a ^ d , b ^ d NEW_LINE DEDENT DEDENT print ( f ' 2 \\n | \u2581 { a ^ b ^ 1023 } \\n ^ \u2581 { a ^ 1023 } ' ) NEW_LINE"}
{"id": "codeforces_451_B", "sol": 0, "python_code": "n = int ( input ( ) )\nl = list ( map ( int , input ( ).split ( ) ) )\nfirst = - 1\nlast = - 1\nf = 0\nc = 0\ns = 0\nfor i in range ( 1 , n ) :\n    if ( l [ i ] < l [ i - 1 ] ) :\n        if ( first == - 1 ) :\n            first = i - 1\n        if ( first != - 1 and f != 1 ) :\n            last = i\n        if ( f == 1 ) :\n            s = 1\n            print ( \"no\" )\n            break\n    else :\n        if ( first != - 1 ) :\n            f = 1\n            c = 0\nif ( first == - 1 and last == - 1 ) :\n    c = 1\nif ( c == 1 ) :\n    print ( \"yes\" )\n    print ( n , n )\nelse :\n    if ( s != 1 ) :\n        l [ first : last + 1 ] = l [ first : last + 1 ] [ : : - 1 ]\n        if ( sorted ( l ) == l ) :\n            print ( \"yes\" )\n            print ( first + 1 , last + 1 )\n        else :\n            print ( \"no\" )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE first = - 1 NEW_LINE last = - 1 NEW_LINE f = 0 NEW_LINE c = 0 NEW_LINE s = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( l [ i ] < l [ i - 1 ] ) : NEW_LINE INDENT if ( first == - 1 ) : NEW_LINE INDENT first = i - 1 NEW_LINE DEDENT if ( first != - 1 and f != 1 ) : NEW_LINE INDENT last = i NEW_LINE DEDENT if ( f == 1 ) : NEW_LINE INDENT s = 1 NEW_LINE print ( \" no \" ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( first != - 1 ) : NEW_LINE INDENT f = 1 NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT if ( first == - 1 and last == - 1 ) : NEW_LINE INDENT c = 1 NEW_LINE DEDENT if ( c == 1 ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE print ( n , n ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( s != 1 ) : NEW_LINE INDENT l [ first : last + 1 ] = l [ first : last + 1 ] [ : : - 1 ] NEW_LINE if ( sorted ( l ) == l ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE print ( first + 1 , last + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_789_A", "sol": 0, "python_code": "def sumOfLastDig ( n , m ) :\n    sum = 0 ;\n    k = n // m ;\n    arr = [ 0 ] * 10 ;\n    for i in range ( 10 ) :\n        arr [ i ] = m * ( i + 1 ) % 10 ;\n        sum += arr [ i ] ;\n    rem = k % 10 ;\n    ans = ( k // 10 ) * sum ;\n    for i in range ( rem ) :\n        ans += arr [ i ] ;\n    return ans ;\nif __name__ == \"__main__\" :\n    n = 100 ; m = 3 ;\n    print ( sumOfLastDig ( n , m ) ) ;\n", "python_code_tokenized": "def sumOfLastDig ( n , m ) : NEW_LINE INDENT sum = 0 ; NEW_LINE k = n // m ; NEW_LINE arr = [ 0 ] * 10 ; NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT arr [ i ] = m * ( i + 1 ) % 10 ; NEW_LINE sum += arr [ i ] ; NEW_LINE DEDENT rem = k % 10 ; NEW_LINE ans = ( k // 10 ) * sum ; NEW_LINE for i in range ( rem ) : NEW_LINE INDENT ans += arr [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 100 ; m = 3 ; NEW_LINE print ( sumOfLastDig ( n , m ) ) ; NEW_LINE DEDENT"}
{"id": "aizu_p00218_A", "sol": 0, "python_code": "def bar ( a , b , c ) :\n    x = ( a + b + c ) / 3\n    return x\nwhile True :\n    n = int ( input ( ) )\n    if n == 0 :\n        break\n    for i in range ( n ) :\n        m , e , j = map ( int , input ( ).split ( ) )\n        y = ( m + e ) / 2\n        x = bar ( m , e , j )\n        if ( m == 100 or e == 100 or j == 100 ) or y >= 90 or x >= 80 :\n            print ( \"A\" )\n        elif x >= 70 :\n            print ( \"B\" )\n        elif x >= 50 :\n            if m >= 80 or e >= 80 :\n                print ( \"B\" )\n            else :\n                print ( \"C\" )\n        else :\n            print ( \"C\" )\n", "python_code_tokenized": "def bar ( a , b , c ) : NEW_LINE INDENT x = ( a + b + c ) / 3 NEW_LINE return x NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT m , e , j = map ( int , input ( ) . split ( ) ) NEW_LINE y = ( m + e ) / 2 NEW_LINE x = bar ( m , e , j ) NEW_LINE if ( m == 100 or e == 100 or j == 100 ) or y >= 90 or x >= 80 : NEW_LINE INDENT print ( \" A \" ) NEW_LINE DEDENT elif x >= 70 : NEW_LINE INDENT print ( \" B \" ) NEW_LINE DEDENT elif x >= 50 : NEW_LINE INDENT if m >= 80 or e >= 80 : NEW_LINE INDENT print ( \" B \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" C \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" C \" ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_3883_A", "sol": 0, "python_code": "MAX = 100\ndef CountDecreasingPathsCell ( mat , dp , n , x , y ) :\n    if ( dp [ x ] [ y ] != - 1 ) :\n        return dp [ x ] [ y ]\n    delta = [ [ 0 , 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ]\n    newx , newy = 0 , 0\n    ans = 1\n    for i in range ( 4 ) :\n        newx = x + delta [ i ] [ 0 ]\n        newy = y + delta [ i ] [ 1 ]\n        if ( newx >= 0 and newx < n and newy >= 0 and newy < n and mat [ newx ] [ newy ] < mat [ x ] [ y ] ) :\n            ans += CountDecreasingPathsCell ( mat , dp , n , newx , newy )\n    dp [ x ] [ y ] = ans\n    return dp [ x ] [ y ]\ndef countDecreasingPathsMatrix ( n , mat ) :\n    dp = [ ]\n    for i in range ( n ) :\n        l = [ ]\n        for j in range ( n ) :\n            l.append ( - 1 )\n        dp.append ( l )\n    sum = 0\n    for i in range ( n ) :\n        for j in range ( n ) :\n            sum += CountDecreasingPathsCell ( mat , dp , n , i , j )\n    return sum\nn = 2\nmat = [ [ 1 , 2 ] , [ 1 , 3 ] ]\nprint ( countDecreasingPathsMatrix ( n , mat ) )\n", "python_code_tokenized": "MAX = 100 NEW_LINE def CountDecreasingPathsCell ( mat , dp , n , x , y ) : NEW_LINE INDENT if ( dp [ x ] [ y ] != - 1 ) : NEW_LINE INDENT return dp [ x ] [ y ] NEW_LINE DEDENT delta = [ [ 0 , 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] NEW_LINE newx , newy = 0 , 0 NEW_LINE ans = 1 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT newx = x + delta [ i ] [ 0 ] NEW_LINE newy = y + delta [ i ] [ 1 ] NEW_LINE if ( newx >= 0 and newx < n and newy >= 0 and newy < n and mat [ newx ] [ newy ] < mat [ x ] [ y ] ) : NEW_LINE INDENT ans += CountDecreasingPathsCell ( mat , dp , n , newx , newy ) NEW_LINE DEDENT DEDENT dp [ x ] [ y ] = ans NEW_LINE return dp [ x ] [ y ] NEW_LINE DEDENT def countDecreasingPathsMatrix ( n , mat ) : NEW_LINE INDENT dp = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT l . append ( - 1 ) NEW_LINE DEDENT dp . append ( l ) NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += CountDecreasingPathsCell ( mat , dp , n , i , j ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 2 NEW_LINE mat = [ [ 1 , 2 ] , [ 1 , 3 ] ] NEW_LINE print ( countDecreasingPathsMatrix ( n , mat ) ) NEW_LINE"}
{"id": "codeforces_226_A", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nprint ( ( pow ( 3 , n , m ) - 1 ) % m )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( pow ( 3 , n , m ) - 1 ) % m ) NEW_LINE"}
{"id": "geeksforgeeks_4903_A", "sol": 0, "python_code": "def maxDiff ( arr , n ) :\n    maxDiff = - 1\n    maxRight = arr [ n - 1 ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if ( arr [ i ] > maxRight ) :\n            maxRight = arr [ i ]\n        else :\n            diff = maxRight - arr [ i ]\n            if ( diff > maxDiff ) :\n                maxDiff = diff\n    return maxDiff\nif __name__ == '__main__' :\n    arr = [ 1 , 2 , 90 , 10 , 110 ]\n    n = len ( arr )\n    print ( \"Maximum difference is\" , maxDiff ( arr , n ) )\n", "python_code_tokenized": "def maxDiff ( arr , n ) : NEW_LINE INDENT maxDiff = - 1 NEW_LINE maxRight = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > maxRight ) : NEW_LINE INDENT maxRight = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT diff = maxRight - arr [ i ] NEW_LINE if ( diff > maxDiff ) : NEW_LINE INDENT maxDiff = diff NEW_LINE DEDENT DEDENT DEDENT return maxDiff NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 90 , 10 , 110 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum \u2581 difference \u2581 is \" , maxDiff ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4527_A", "sol": 0, "python_code": "import math\ndef bitAtGivenPosSetOrUnset ( n , k ) :\n    new_num = n >> ( k - 1 )\n    return ( new_num & 1 )\nn = 10\nk = 2\nif ( bitAtGivenPosSetOrUnset ( n , k ) ) :\n    print ( \"Set\" )\nelse :\n    print ( \"Unset\" )\n", "python_code_tokenized": "import math NEW_LINE def bitAtGivenPosSetOrUnset ( n , k ) : NEW_LINE INDENT new_num = n >> ( k - 1 ) NEW_LINE return ( new_num & 1 ) NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE if ( bitAtGivenPosSetOrUnset ( n , k ) ) : NEW_LINE INDENT print ( \" Set \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Unset \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1783_A", "sol": 0, "python_code": "def getArray ( n ) :\n    ans = [ ] ;\n    p2 = 1 ;\n    while ( n > 0 ) :\n        if ( n & 1 ) :\n            ans.append ( p2 ) ;\n        n >>= 1 ;\n        p2 *= 2 ;\n    return ans ;\nif __name__ == \"__main__\" :\n    n = 15 ;\n    ans = getArray ( n ) ;\n    for i in ans :\n        print ( i , end = \" \" ) ;\n", "python_code_tokenized": "def getArray ( n ) : NEW_LINE INDENT ans = [ ] ; NEW_LINE p2 = 1 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT ans . append ( p2 ) ; NEW_LINE DEDENT n >>= 1 ; NEW_LINE p2 *= 2 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 15 ; NEW_LINE ans = getArray ( n ) ; NEW_LINE for i in ans : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_390_B", "sol": 0, "python_code": "import math\nn = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nb = list ( map ( int , input ( ).split ( ) ) )\nresult = 0\nfor i in range ( n ) :\n    if b [ i ] < 2 or b [ i ] > 2 * a [ i ] :\n        result -= 1\n    else :\n        result += math.floor ( b [ i ] / 2 ) * math.ceil ( b [ i ] / 2 )\nprint ( result )\n", "python_code_tokenized": "import math NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] < 2 or b [ i ] > 2 * a [ i ] : NEW_LINE INDENT result -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += math . floor ( b [ i ] / 2 ) * math . ceil ( b [ i ] / 2 ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE"}
{"id": "atcoder_ABC156_B", "sol": 0, "python_code": "from fractions import gcd\nimport math\nfrom math import factorial as f\nfrom math import ceil , floor , sqrt\nimport bisect\nimport re\nimport heapq\nfrom copy import deepcopy\nimport itertools\nfrom sys import exit\nii = lambda : int ( input ( ) )\nmi = lambda : map ( int , input ( ).split ( ) )\nli = lambda : list ( map ( int , input ( ).split ( ) ) )\nyes = \"Yes\"\nno = \"No\"\ndef main ( ) :\n    n , k = mi ( )\n    cnt = 0\n    while n :\n        n //= k\n        cnt += 1\n    print ( cnt )\nmain ( )\n", "python_code_tokenized": "from fractions import gcd NEW_LINE import math NEW_LINE from math import factorial as f NEW_LINE from math import ceil , floor , sqrt NEW_LINE import bisect NEW_LINE import re NEW_LINE import heapq NEW_LINE from copy import deepcopy NEW_LINE import itertools NEW_LINE from sys import exit NEW_LINE ii = lambda : int ( input ( ) ) NEW_LINE mi = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE li = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE yes = \" Yes \" NEW_LINE no = \" No \" NEW_LINE def main ( ) : NEW_LINE INDENT n , k = mi ( ) NEW_LINE cnt = 0 NEW_LINE while n : NEW_LINE INDENT n //= k NEW_LINE cnt += 1 NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT main ( ) NEW_LINE"}
{"id": "atcoder_ABC169_E", "sol": 0, "python_code": "def resolve ( ) :\n    n = int ( input ( ) )\n    low = [ ]\n    high = [ ]\n    for i in range ( n ) :\n        a , b = map ( int , input ( ).split ( ) )\n        low.append ( a )\n        high.append ( b )\n    low.sort ( )\n    high.sort ( )\n    if n % 2 :\n        print ( high [ ( n + 1 ) // 2 - 1 ] - low [ ( n + 1 ) // 2 - 1 ] + 1 )\n    else :\n        hh = ( high [ ( n ) // 2 - 1 ] + high [ ( n ) // 2 ] ) / 2\n        ll = ( low [ ( n ) // 2 - 1 ] + low [ ( n ) // 2 ] ) / 2\n        print ( int ( ( hh - ll ) * 2 ) + 1 )\nif __name__ == \"__main__\" :\n    resolve ( )\n", "python_code_tokenized": "def resolve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE low = [ ] NEW_LINE high = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE low . append ( a ) NEW_LINE high . append ( b ) NEW_LINE DEDENT low . sort ( ) NEW_LINE high . sort ( ) NEW_LINE if n % 2 : NEW_LINE INDENT print ( high [ ( n + 1 ) // 2 - 1 ] - low [ ( n + 1 ) // 2 - 1 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT hh = ( high [ ( n ) // 2 - 1 ] + high [ ( n ) // 2 ] ) / 2 NEW_LINE ll = ( low [ ( n ) // 2 - 1 ] + low [ ( n ) // 2 ] ) / 2 NEW_LINE print ( int ( ( hh - ll ) * 2 ) + 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT resolve ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2470_A", "sol": 0, "python_code": "import math\nclass Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.next = None\ndef addToEmpty ( head , data ) :\n    if ( head != None ) :\n        return head\n    temp = Node ( data )\n    temp.data = data\n    head = temp\n    head.next = head\n    return head\ndef addBegin ( head , data ) :\n    if ( head == None ) :\n        return addToEmpty ( head , data )\n    temp = Node ( data )\n    temp.data = data\n    temp.next = head.next\n    head.next = temp\n    return head\ndef traverse ( head ) :\n    if ( head == None ) :\n        print ( \"List is empty.\" )\n        return\n    p = head\n    print ( p.data , end = \"\" )\n    p = p.next\n    while ( p != head ) :\n        print ( p.data , end = \"\" )\n        p = p.next\ndef exchangeNodes ( head ) :\n    p = head\n    while ( p.next.next != head ) :\n        p = p.next\n    p.next.next = head.next\n    head.next = p.next\n    p.next = head\n    head = head.next\n    return head\nif __name__ == '__main__' :\n    head = None\n    head = addToEmpty ( head , 6 )\n    for x in range ( 5 , 0 , - 1 ) :\n        head = addBegin ( head , x )\n    print ( \"List Before: \" , end = \"\" )\n    traverse ( head )\n    print ( )\n    print ( \"List After: \" , end = \"\" )\n    head = exchangeNodes ( head )\n    traverse ( head )\n", "python_code_tokenized": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def addToEmpty ( head , data ) : NEW_LINE INDENT if ( head != None ) : NEW_LINE INDENT return head NEW_LINE DEDENT temp = Node ( data ) NEW_LINE temp . data = data NEW_LINE head = temp NEW_LINE head . next = head NEW_LINE return head NEW_LINE DEDENT def addBegin ( head , data ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return addToEmpty ( head , data ) NEW_LINE DEDENT temp = Node ( data ) NEW_LINE temp . data = data NEW_LINE temp . next = head . next NEW_LINE head . next = temp NEW_LINE return head NEW_LINE DEDENT def traverse ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT print ( \" List \u2581 is \u2581 empty . \" ) NEW_LINE return NEW_LINE DEDENT p = head NEW_LINE print ( p . data , end = \" \u2581 \" ) NEW_LINE p = p . next NEW_LINE while ( p != head ) : NEW_LINE INDENT print ( p . data , end = \" \u2581 \" ) NEW_LINE p = p . next NEW_LINE DEDENT DEDENT def exchangeNodes ( head ) : NEW_LINE INDENT p = head NEW_LINE while ( p . next . next != head ) : NEW_LINE INDENT p = p . next NEW_LINE DEDENT p . next . next = head . next NEW_LINE head . next = p . next NEW_LINE p . next = head NEW_LINE head = head . next NEW_LINE return head NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = addToEmpty ( head , 6 ) NEW_LINE for x in range ( 5 , 0 , - 1 ) : NEW_LINE INDENT head = addBegin ( head , x ) NEW_LINE DEDENT print ( \" List \u2581 Before : \u2581 \" , end = \" \" ) NEW_LINE traverse ( head ) NEW_LINE print ( ) NEW_LINE print ( \" List \u2581 After : \u2581 \" , end = \" \" ) NEW_LINE head = exchangeNodes ( head ) NEW_LINE traverse ( head ) NEW_LINE DEDENT"}
{"id": "aizu_p02240_A", "sol": 0, "python_code": "import array\nfrom collections import deque\ndef groupify ( length , adj_list ) :\n    group = array.array ( 'l' , ( - 1 for _ in range ( length ) ) )\n    g_id = 0\n    dq = deque ( )\n    for idx in range ( length ) :\n        if group [ idx ] == - 1 :\n            group [ idx ] = g_id\n            dq.append ( idx )\n            while len ( dq ) :\n                v = dq.popleft ( )\n                for t in adj_list [ v ] :\n                    if group [ t ] == - 1 :\n                        group [ t ] = g_id\n                        dq.append ( t )\n            g_id += 1\n    return group\nn , m = map ( int , input ( ).split ( ) )\nadj_list = [ set ( ) for _ in range ( n ) ]\nfor _ in range ( m ) :\n    i , j = map ( int , input ( ).split ( ) )\n    adj_list [ i ].add ( j )\n    adj_list [ j ].add ( i )\ngroup = groupify ( n , adj_list )\nq = int ( input ( ) )\nfor _ in range ( q ) :\n    s , t = map ( int , input ( ).split ( ) )\n    if group [ s ] == group [ t ] : print ( 'yes' )\n    else : print ( 'no' )\n", "python_code_tokenized": "import array NEW_LINE from collections import deque NEW_LINE def groupify ( length , adj_list ) : NEW_LINE INDENT group = array . array ( ' l ' , ( - 1 for _ in range ( length ) ) ) NEW_LINE g_id = 0 NEW_LINE dq = deque ( ) NEW_LINE for idx in range ( length ) : NEW_LINE INDENT if group [ idx ] == - 1 : NEW_LINE INDENT group [ idx ] = g_id NEW_LINE dq . append ( idx ) NEW_LINE while len ( dq ) : NEW_LINE INDENT v = dq . popleft ( ) NEW_LINE for t in adj_list [ v ] : NEW_LINE INDENT if group [ t ] == - 1 : NEW_LINE INDENT group [ t ] = g_id NEW_LINE dq . append ( t ) NEW_LINE DEDENT DEDENT DEDENT g_id += 1 NEW_LINE DEDENT DEDENT return group NEW_LINE DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE adj_list = [ set ( ) for _ in range ( n ) ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT i , j = map ( int , input ( ) . split ( ) ) NEW_LINE adj_list [ i ] . add ( j ) NEW_LINE adj_list [ j ] . add ( i ) NEW_LINE DEDENT group = groupify ( n , adj_list ) NEW_LINE q = int ( input ( ) ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT s , t = map ( int , input ( ) . split ( ) ) NEW_LINE if group [ s ] == group [ t ] : print ( ' yes ' ) NEW_LINE else : print ( ' no ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3668_A", "sol": 0, "python_code": "def wastedWater ( V , M , N ) :\n    amt_per_min = M - N\n    time_to_fill = V / amt_per_min\n    wasted_amt = N * time_to_fill\n    return wasted_amt\nV = 700\nM = 10\nN = 3\nprint ( wastedWater ( V , M , N ) )\nV = 1000\nM = 100\nN = 50\nprint ( wastedWater ( V , M , N ) )\n", "python_code_tokenized": "def wastedWater ( V , M , N ) : NEW_LINE INDENT amt_per_min = M - N NEW_LINE time_to_fill = V / amt_per_min NEW_LINE wasted_amt = N * time_to_fill NEW_LINE return wasted_amt NEW_LINE DEDENT V = 700 NEW_LINE M = 10 NEW_LINE N = 3 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE V = 1000 NEW_LINE M = 100 NEW_LINE N = 50 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE"}
{"id": "leetcode_665_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def checkPossibility ( self , nums ) :\n        broken_num = 0\n        for i in range ( len ( nums ) - 1 ) :\n            if ( nums [ i ] > nums [ i + 1 ] ) :\n                broken_num += 1\n                if broken_num >= 2 :\n                    return False\n                if ( i - 1 < 0 or nums [ i - 1 ] <= nums [ i + 1 ] ) :\n                    nums [ i ] = nums [ i + 1 ]\n                else :\n                    nums [ i + 1 ] = nums [ i ]\n        return True\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def checkPossibility ( self , nums ) : NEW_LINE INDENT broken_num = 0 NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT if ( nums [ i ] > nums [ i + 1 ] ) : NEW_LINE INDENT broken_num += 1 NEW_LINE if broken_num >= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i - 1 < 0 or nums [ i - 1 ] <= nums [ i + 1 ] ) : NEW_LINE INDENT nums [ i ] = nums [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nums [ i + 1 ] = nums [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4331_A", "sol": 0, "python_code": "import sys\ndef thirdLargest ( arr , arr_size ) :\n    if ( arr_size < 3 ) :\n        print ( \" Invalid Input \" )\n        return\n    first = arr [ 0 ]\n    for i in range ( 1 , arr_size ) :\n        if ( arr [ i ] > first ) :\n            first = arr [ i ]\n    second = - sys.maxsize\n    for i in range ( 0 , arr_size ) :\n        if ( arr [ i ] > second and arr [ i ] < first ) :\n            second = arr [ i ]\n    third = - sys.maxsize\n    for i in range ( 0 , arr_size ) :\n        if ( arr [ i ] > third and arr [ i ] < second ) :\n            third = arr [ i ]\n    print ( \"The Third Largest\" , \"element is\" , third )\narr = [ 12 , 13 , 1 , 10 , 34 , 16 ]\nn = len ( arr )\nthirdLargest ( arr , n )\n", "python_code_tokenized": "import sys NEW_LINE def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( \" \u2581 Invalid \u2581 Input \u2581 \" ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT first = arr [ i ] NEW_LINE DEDENT DEDENT second = - sys . maxsize NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > second and arr [ i ] < first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT third = - sys . maxsize NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > third and arr [ i ] < second ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( \" The \u2581 Third \u2581 Largest \" , \" element \u2581 is \" , third ) NEW_LINE DEDENT arr = [ 12 , 13 , 1 , 10 , 34 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE thirdLargest ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_4332_A", "sol": 0, "python_code": "import sys\ndef thirdLargest ( arr , arr_size ) :\n    if ( arr_size < 3 ) :\n        print ( \" Invalid Input \" )\n        return\n    first = arr [ 0 ]\n    second = - sys.maxsize\n    third = - sys.maxsize\n    for i in range ( 1 , arr_size ) :\n        if ( arr [ i ] > first ) :\n            third = second\n            second = first\n            first = arr [ i ]\n        elif ( arr [ i ] > second ) :\n            third = second\n            second = arr [ i ]\n        elif ( arr [ i ] > third ) :\n            third = arr [ i ]\n    print ( \"The third Largest\" , \"element is\" , third )\narr = [ 12 , 13 , 1 , 10 , 34 , 16 ]\nn = len ( arr )\nthirdLargest ( arr , n )\n", "python_code_tokenized": "import sys NEW_LINE def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( \" \u2581 Invalid \u2581 Input \u2581 \" ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE second = - sys . maxsize NEW_LINE third = - sys . maxsize NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT third = second NEW_LINE second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT third = second NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > third ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( \" The \u2581 third \u2581 Largest \" , \" element \u2581 is \" , third ) NEW_LINE DEDENT arr = [ 12 , 13 , 1 , 10 , 34 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE thirdLargest ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_2807_A", "sol": 0, "python_code": "def substrDeletion ( string , length ) :\n    count0 = 0 ;\n    count1 = 0 ;\n    for i in range ( length ) :\n        if ( string [ i ] == '0' ) :\n            count0 += 1 ;\n        else :\n            count1 += 1 ;\n    return min ( count0 , count1 ) ;\nif __name__ == \"__main__\" :\n    string = \"010\" ;\n    length = len ( string ) ;\n    print ( substrDeletion ( string , length ) ) ;\n", "python_code_tokenized": "def substrDeletion ( string , length ) : NEW_LINE INDENT count0 = 0 ; NEW_LINE count1 = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT count0 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 ; NEW_LINE DEDENT DEDENT return min ( count0 , count1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"010\" ; NEW_LINE length = len ( string ) ; NEW_LINE print ( substrDeletion ( string , length ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4676_A", "sol": 0, "python_code": "def __gcd ( a , b ) :\n    if ( a == 0 or b == 0 ) :\n        return 0 ;\n    if ( a == b ) :\n        return a ;\n    if ( a > b ) :\n        return __gcd ( a - b , b ) ;\n    return __gcd ( a , b - a ) ;\ndef find_Gcd ( crr , n ) :\n    result = crr [ 0 ] ;\n    for i in range ( 1 , n ) :\n        result = __gcd ( crr [ i ] , result ) ;\n    return result ;\ndef profitRatio ( amountArr , timeTrr , n ) :\n    i = 0 ;\n    crr = [ 0 ] * n ;\n    for i in range ( n ) :\n        crr [ i ] = amountArr [ i ] * timeTrr [ i ] ;\n    Share = find_Gcd ( crr , n ) ;\n    for i in range ( n - 1 ) :\n        print ( int ( crr [ i ] / Share ) , end = \" : \" ) ;\n    print ( int ( crr [ i + 1 ] / Share ) ) ;\namountArr = [ 5000 , 6000 , 1000 ] ;\ntimeTrr = [ 6 , 6 , 12 ] ;\nn = len ( amountArr ) ;\nprofitRatio ( amountArr , timeTrr , n ) ;\n", "python_code_tokenized": "def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) ; NEW_LINE DEDENT return __gcd ( a , b - a ) ; NEW_LINE DEDENT def find_Gcd ( crr , n ) : NEW_LINE INDENT result = crr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT result = __gcd ( crr [ i ] , result ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def profitRatio ( amountArr , timeTrr , n ) : NEW_LINE INDENT i = 0 ; NEW_LINE crr = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT crr [ i ] = amountArr [ i ] * timeTrr [ i ] ; NEW_LINE DEDENT Share = find_Gcd ( crr , n ) ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT print ( int ( crr [ i ] / Share ) , end = \" \u2581 : \u2581 \" ) ; NEW_LINE DEDENT print ( int ( crr [ i + 1 ] / Share ) ) ; NEW_LINE DEDENT amountArr = [ 5000 , 6000 , 1000 ] ; NEW_LINE timeTrr = [ 6 , 6 , 12 ] ; NEW_LINE n = len ( amountArr ) ; NEW_LINE profitRatio ( amountArr , timeTrr , n ) ; NEW_LINE"}
{"id": "aizu_p00004_A", "sol": 0, "python_code": "EPS = 0.0001\nwhile True :\n    try :\n        a = list ( map ( float , input ( ).split ( ) ) )\n        dd = a [ 0 ] * a [ 4 ] - a [ 3 ] * a [ 1 ]\n        d1 = a [ 2 ] * a [ 4 ] - a [ 5 ] * a [ 1 ]\n        d2 = a [ 0 ] * a [ 5 ] - a [ 3 ] * a [ 2 ]\n        print ( \"{0:.3f} {1:.3f}\".format ( d1 / dd + EPS , d2 / dd + EPS ) )\n    except EOFError :\n        break\n", "python_code_tokenized": "EPS = 0.0001 NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT a = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE dd = a [ 0 ] * a [ 4 ] - a [ 3 ] * a [ 1 ] NEW_LINE d1 = a [ 2 ] * a [ 4 ] - a [ 5 ] * a [ 1 ] NEW_LINE d2 = a [ 0 ] * a [ 5 ] - a [ 3 ] * a [ 2 ] NEW_LINE print ( \" { 0 : . 3f } \u2581 { 1 : . 3f } \" . format ( d1 / dd + EPS , d2 / dd + EPS ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT"}
{"id": "leetcode_543_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def diameterOfBinaryTree ( self , root ) :\n        self.ans = 1\n        def depth ( node ) :\n            if not node : return 0\n            L = depth ( node.left )\n            R = depth ( node.right )\n            self.ans = max ( self.ans , L + R + 1 )\n            return max ( L , R ) + 1\n        depth ( root )\n        return self.ans - 1\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def diameterOfBinaryTree ( self , root ) : NEW_LINE INDENT self . ans = 1 NEW_LINE def depth ( node ) : NEW_LINE INDENT if not node : return 0 NEW_LINE L = depth ( node . left ) NEW_LINE R = depth ( node . right ) NEW_LINE self . ans = max ( self . ans , L + R + 1 ) NEW_LINE return max ( L , R ) + 1 NEW_LINE DEDENT depth ( root ) NEW_LINE return self . ans - 1 NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_139_A", "sol": 0, "python_code": "class Node :\n    def __init__ ( self , key ) :\n        self.key = key\n        self.left = None\n        self.right = None\ndef insert ( node : Node , key : int ) -> Node :\n    if node is None :\n        return Node ( key )\n    if key < node.key :\n        node.left = insert ( node.left , key )\n    elif key > node.key :\n        node.right = insert ( node.right , key )\n    return node\ndef maxDepth ( node : Node ) -> int :\n    if node is None :\n        return 0\n    else :\n        lDepth = maxDepth ( node.left )\n        rDepth = maxDepth ( node.right )\n        if lDepth > rDepth :\n            return lDepth + 1\n        else :\n            return rDepth + 1\ndef maxHeight ( a : list , n : int ) -> int :\n    rootA = Node ( a [ 0 ] )\n    for i in range ( 1 , n ) :\n        rootA = insert ( rootA , a [ i ] )\n    rootB = Node ( a [ n - 1 ] )\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        rootB = insert ( rootB , a [ i ] )\n    A = maxDepth ( rootA ) - 1\n    B = maxDepth ( rootB ) - 1\n    return max ( A , B )\nif __name__ == \"__main__\" :\n    a = [ 2 , 1 , 3 , 4 ]\n    n = len ( a )\n    print ( maxHeight ( a , n ) )\n", "python_code_tokenized": "class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( node : Node , key : int ) -> Node : NEW_LINE INDENT if node is None : NEW_LINE INDENT return Node ( key ) NEW_LINE DEDENT if key < node . key : NEW_LINE INDENT node . left = insert ( node . left , key ) NEW_LINE DEDENT elif key > node . key : NEW_LINE INDENT node . right = insert ( node . right , key ) NEW_LINE DEDENT return node NEW_LINE DEDENT def maxDepth ( node : Node ) -> int : NEW_LINE INDENT if node is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT lDepth = maxDepth ( node . left ) NEW_LINE rDepth = maxDepth ( node . right ) NEW_LINE if lDepth > rDepth : NEW_LINE INDENT return lDepth + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return rDepth + 1 NEW_LINE DEDENT DEDENT DEDENT def maxHeight ( a : list , n : int ) -> int : NEW_LINE INDENT rootA = Node ( a [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT rootA = insert ( rootA , a [ i ] ) NEW_LINE DEDENT rootB = Node ( a [ n - 1 ] ) NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT rootB = insert ( rootB , a [ i ] ) NEW_LINE DEDENT A = maxDepth ( rootA ) - 1 NEW_LINE B = maxDepth ( rootB ) - 1 NEW_LINE return max ( A , B ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 1 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( maxHeight ( a , n ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02484_A", "sol": 0, "python_code": "for x in range ( 1000 ) :\n    print ( \"Hello World\" )\n", "python_code_tokenized": "for x in range ( 1000 ) : NEW_LINE INDENT print ( \" Hello \u2581 World \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1616_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    m = int ( input ( ) )\n    p = input ( )\n    i = 1\n    while ( i < m and ( p [ i - 1 ] > p [ i ] or ( i > 1 and p [ i ] == p [ i - 1 ] ) ) ) :\n        i += 1\n    print ( p [ : i ] + p [ i - 1 : : - 1 ] )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE p = input ( ) NEW_LINE i = 1 NEW_LINE while ( i < m and ( p [ i - 1 ] > p [ i ] or ( i > 1 and p [ i ] == p [ i - 1 ] ) ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( p [ : i ] + p [ i - 1 : : - 1 ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4033_A", "sol": 0, "python_code": "def maximum_one ( s , n ) :\n    cnt_one = 0\n    cnt , max_cnt = 0 , 0\n    for i in range ( n ) :\n        if ( s [ i ] == '1' ) :\n            cnt_one += 1\n            cnt += 1\n        else :\n            max_cnt = max ( max_cnt , cnt )\n            cnt = 0\n    max_cnt = max ( max_cnt , cnt )\n    left = [ 0 ] * n\n    right = [ 0 ] * n\n    if ( s [ 0 ] == '1' ) :\n        left [ 0 ] = 1\n    else :\n        left [ 0 ] = 0\n    if ( s [ n - 1 ] == '1' ) :\n        right [ n - 1 ] = 1\n    else :\n        right [ n - 1 ] = 0\n    for i in range ( 1 , n ) :\n        if ( s [ i ] == '1' ) :\n            left [ i ] = left [ i - 1 ] + 1\n        else :\n            left [ i ] = 0\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if ( s [ i ] == '1' ) :\n            right [ i ] = right [ i + 1 ] + 1\n        else :\n            right [ i ] = 0\n    for i in range ( 1 , n ) :\n        if ( s [ i ] == '0' ) :\n            sum = left [ i - 1 ] + right [ i + 1 ]\n            if ( sum < cnt_one ) :\n                max_cnt = max ( max_cnt , sum + 1 )\n            else :\n                max_cnt = max ( max_cnt , sum )\n    return max_cnt\nif __name__ == \"__main__\" :\n    s = \"111011101\"\n    print ( maximum_one ( s , len ( s ) ) )\n", "python_code_tokenized": "def maximum_one ( s , n ) : NEW_LINE INDENT cnt_one = 0 NEW_LINE cnt , max_cnt = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT cnt_one += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , cnt ) NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT max_cnt = max ( max_cnt , cnt ) NEW_LINE left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT left [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ 0 ] = 0 NEW_LINE DEDENT if ( s [ n - 1 ] == '1' ) : NEW_LINE INDENT right [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ n - 1 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT sum = left [ i - 1 ] + right [ i + 1 ] NEW_LINE if ( sum < cnt_one ) : NEW_LINE INDENT max_cnt = max ( max_cnt , sum + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , sum ) NEW_LINE DEDENT DEDENT DEDENT return max_cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"111011101\" NEW_LINE print ( maximum_one ( s , len ( s ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2249_A", "sol": 0, "python_code": "from math import gcd as __gcd\ndef getCount ( a , n ) :\n    gcd = 0\n    for i in range ( n ) :\n        gcd = __gcd ( gcd , a [ i ] )\n    cnt = 0\n    for i in range ( 1 , gcd + 1 ) :\n        if i * i > gcd :\n            break\n        if ( gcd % i == 0 ) :\n            if ( i * i == gcd ) :\n                cnt += 1\n            else :\n                cnt += 2\n    return cnt\na = [ 4 , 16 , 1024 , 48 ]\nn = len ( a )\nprint ( getCount ( a , n ) )\n", "python_code_tokenized": "from math import gcd as __gcd NEW_LINE def getCount ( a , n ) : NEW_LINE INDENT gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = __gcd ( gcd , a [ i ] ) NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 1 , gcd + 1 ) : NEW_LINE INDENT if i * i > gcd : NEW_LINE INDENT break NEW_LINE DEDENT if ( gcd % i == 0 ) : NEW_LINE INDENT if ( i * i == gcd ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 2 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT a = [ 4 , 16 , 1024 , 48 ] NEW_LINE n = len ( a ) NEW_LINE print ( getCount ( a , n ) ) NEW_LINE"}
{"id": "aizu_p01556_A", "sol": 0, "python_code": "def solve ( lis , N ) :\n    x = ( lis [ 0 ] [ 0 ] + lis [ N // 2 ] [ 0 ] )\n    y = ( lis [ 0 ] [ 1 ] + lis [ N // 2 ] [ 1 ] )\n    for i in range ( 1 , N // 2 ) :\n        if ( lis [ i ] [ 0 ] + lis [ i + N // 2 ] [ 0 ] ) != x or ( lis [ i ] [ 1 ] + lis [ i + N // 2 ] [ 1 ] ) != y :\n            return \"NA\"\n    return str ( x / 2 ) + \" \" + str ( y / 2 )\nN = int ( input ( ) )\nif N % 2 == 1 :\n    print ( \"NA\" )\nelse :\n    lis = [ ]\n    for i in range ( N ) :\n        lis.append ( tuple ( map ( int , input ( ).split ( ) ) ) )\n    ans = solve ( lis , N )\n    print ( ans )\n", "python_code_tokenized": "def solve ( lis , N ) : NEW_LINE INDENT x = ( lis [ 0 ] [ 0 ] + lis [ N // 2 ] [ 0 ] ) NEW_LINE y = ( lis [ 0 ] [ 1 ] + lis [ N // 2 ] [ 1 ] ) NEW_LINE for i in range ( 1 , N // 2 ) : NEW_LINE INDENT if ( lis [ i ] [ 0 ] + lis [ i + N // 2 ] [ 0 ] ) != x or ( lis [ i ] [ 1 ] + lis [ i + N // 2 ] [ 1 ] ) != y : NEW_LINE INDENT return \" NA \" NEW_LINE DEDENT DEDENT return str ( x / 2 ) + \" \u2581 \" + str ( y / 2 ) NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE if N % 2 == 1 : NEW_LINE INDENT print ( \" NA \" ) NEW_LINE DEDENT else : NEW_LINE INDENT lis = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT lis . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT ans = solve ( lis , N ) NEW_LINE print ( ans ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2121_A", "sol": 0, "python_code": "def KthMinValAfterMconcatenate ( A , N , M , K ) :\n    V = [ ]\n    for i in range ( 0 , M ) :\n        for j in range ( 0 , N ) :\n            V.append ( A [ j ] )\n    V.sort ( )\n    return V [ K - 1 ]\nif __name__ == \"__main__\" :\n    A = [ 3 , 1 , 2 ]\n    M , K = 3 , 4\n    N = len ( A )\n    print ( KthMinValAfterMconcatenate ( A , N , M , K ) )\n", "python_code_tokenized": "def KthMinValAfterMconcatenate ( A , N , M , K ) : NEW_LINE INDENT V = [ ] NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT V . append ( A [ j ] ) NEW_LINE DEDENT DEDENT V . sort ( ) NEW_LINE return V [ K - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 3 , 1 , 2 ] NEW_LINE M , K = 3 , 4 NEW_LINE N = len ( A ) NEW_LINE print ( KthMinValAfterMconcatenate ( A , N , M , K ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02030_A", "sol": 0, "python_code": "N , M = map ( int , input ( ).split ( ) )\nA = set ( map ( int , input ( ).split ( ) ) )\nB = set ( map ( int , input ( ).split ( ) ) )\nAandB = sorted ( A & B )\nAorB = sorted ( A | B )\nprint ( len ( AandB ) , len ( AorB ) )\nfor x in AandB :\n    print ( x )\nfor x in AorB :\n    print ( x )\n", "python_code_tokenized": "N , M = map ( int , input ( ) . split ( ) ) NEW_LINE A = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE AandB = sorted ( A & B ) NEW_LINE AorB = sorted ( A | B ) NEW_LINE print ( len ( AandB ) , len ( AorB ) ) NEW_LINE for x in AandB : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT for x in AorB : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC134_C", "sol": 0, "python_code": "import copy\nimport random\nimport bisect\nimport fractions\nimport math\nimport sys\nmod = 10 ** 9 + 7\nsys.setrecursionlimit ( mod )\ndef LI ( ) : return list ( map ( int , sys.stdin.readline ( ).split ( ) ) )\nN = int ( input ( ) )\nA = [ 0 for i in range ( N ) ]\nfor i in range ( N ) :\n    A [ i ] = int ( input ( ) )\nA_c = copy.deepcopy ( A )\nA_c.sort ( )\nfor i in range ( N ) :\n    if A_c [ - 1 ] == A [ i ] :\n        print ( A_c [ - 2 ] )\n    else :\n        print ( A_c [ - 1 ] )\n", "python_code_tokenized": "import copy NEW_LINE import random NEW_LINE import bisect NEW_LINE import fractions NEW_LINE import math NEW_LINE import sys NEW_LINE mod = 10 ** 9 + 7 NEW_LINE sys . setrecursionlimit ( mod ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT A [ i ] = int ( input ( ) ) NEW_LINE DEDENT A_c = copy . deepcopy ( A ) NEW_LINE A_c . sort ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A_c [ - 1 ] == A [ i ] : NEW_LINE INDENT print ( A_c [ - 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( A_c [ - 1 ] ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_628_B", "sol": 0, "python_code": "s = input ( )\nn = len ( s )\nres = 0\nfor i in range ( n ) :\n    v = int ( s [ i ] )\n    if v % 4 == 0 :\n        res += 1\nfor i in range ( n - 1 ) :\n    v = int ( s [ i : i + 2 ] )\n    if v % 4 == 0 :\n        res += 1 + i\nprint ( res )\n", "python_code_tokenized": "s = input ( ) NEW_LINE n = len ( s ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT v = int ( s [ i ] ) NEW_LINE if v % 4 == 0 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT v = int ( s [ i : i + 2 ] ) NEW_LINE if v % 4 == 0 : NEW_LINE INDENT res += 1 + i NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE"}
{"id": "geeksforgeeks_2126_A", "sol": 0, "python_code": "def fact ( n ) :\n    res = 1\n    for i in range ( 2 , n + 1 ) :\n        res = res * i\n    return res\ndef Count_number ( N ) :\n    return ( N * fact ( N ) )\nN = 2\nprint ( Count_number ( N ) )\n", "python_code_tokenized": "def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def Count_number ( N ) : NEW_LINE INDENT return ( N * fact ( N ) ) NEW_LINE DEDENT N = 2 NEW_LINE print ( Count_number ( N ) ) NEW_LINE"}
{"id": "geeksforgeeks_3349_A", "sol": 0, "python_code": "def minSteps ( str ) :\n    count = 0\n    i = 0\n    while i < len ( str ) - 2 :\n        if str [ i ] == '0' :\n            if ( str [ i + 1 ] == '1' ) :\n                if ( str [ i + 2 ] == '0' ) :\n                    count = count + 1\n                    i = i + 2\n        i = i + 1\n    return count\nstr = \"0101010\"\nprint ( minSteps ( str ) )\n", "python_code_tokenized": "def minSteps ( str ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str ) - 2 : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT if ( str [ i + 1 ] == '1' ) : NEW_LINE INDENT if ( str [ i + 2 ] == '0' ) : NEW_LINE INDENT count = count + 1 NEW_LINE i = i + 2 NEW_LINE DEDENT DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT str = \"0101010\" NEW_LINE print ( minSteps ( str ) ) NEW_LINE"}
{"id": "aizu_p02493_A", "sol": 0, "python_code": "input ( )\nnums = input ( ).split ( )\nreversed_nums = reversed ( nums )\nprint ( ' '.join ( reversed_nums ) )\n", "python_code_tokenized": "input ( ) NEW_LINE nums = input ( ) . split ( ) NEW_LINE reversed_nums = reversed ( nums ) NEW_LINE print ( ' \u2581 ' . join ( reversed_nums ) ) NEW_LINE"}
{"id": "geeksforgeeks_746_A", "sol": 0, "python_code": "import math\nC = 3\ndef solveQuery ( arr , n , Q , query ) :\n    even = [ 0 ] * ( n + 1 )\n    odd = [ 0 ] * ( n + 1 )\n    even [ 0 ] = 0\n    odd [ 0 ] = 0\n    for i in range ( n ) :\n        if ( arr [ i ] & 1 ) :\n            odd [ i + 1 ] = odd [ i ] + 1\n            even [ i + 1 ] = even [ i ]\n        else :\n            even [ i + 1 ] = even [ i ] + 1\n            odd [ i + 1 ] = odd [ i ]\n    for i in range ( Q ) :\n        r = query [ i ] [ 2 ]\n        l = query [ i ] [ 1 ]\n        k = query [ i ] [ 0 ]\n        q = r - l + 1\n        if ( k ) :\n            p = odd [ r ] - odd [ l - 1 ]\n        else :\n            p = even [ r ] - even [ l - 1 ]\n        if ( not p ) :\n            print ( \"0\" )\n        elif ( p == q ) :\n            print ( \"1\" )\n        else :\n            g = math.gcd ( p , q )\n            print ( ( p // g ) , ( q // g ) )\nif __name__ == \"__main__\" :\n    arr = [ 6 , 5 , 2 , 1 , 7 ]\n    n = len ( arr )\n    Q = 2\n    query = [ [ 0 , 2 , 2 ] , [ 1 , 2 , 5 ] ]\n    solveQuery ( arr , n , Q , query )\n", "python_code_tokenized": "import math NEW_LINE C = 3 NEW_LINE def solveQuery ( arr , n , Q , query ) : NEW_LINE INDENT even = [ 0 ] * ( n + 1 ) NEW_LINE odd = [ 0 ] * ( n + 1 ) NEW_LINE even [ 0 ] = 0 NEW_LINE odd [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd [ i + 1 ] = odd [ i ] + 1 NEW_LINE even [ i + 1 ] = even [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT even [ i + 1 ] = even [ i ] + 1 NEW_LINE odd [ i + 1 ] = odd [ i ] NEW_LINE DEDENT DEDENT for i in range ( Q ) : NEW_LINE INDENT r = query [ i ] [ 2 ] NEW_LINE l = query [ i ] [ 1 ] NEW_LINE k = query [ i ] [ 0 ] NEW_LINE q = r - l + 1 NEW_LINE if ( k ) : NEW_LINE INDENT p = odd [ r ] - odd [ l - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT p = even [ r ] - even [ l - 1 ] NEW_LINE DEDENT if ( not p ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT elif ( p == q ) : NEW_LINE INDENT print ( \"1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT g = math . gcd ( p , q ) NEW_LINE print ( ( p // g ) , ( q // g ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 6 , 5 , 2 , 1 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE Q = 2 NEW_LINE query = [ [ 0 , 2 , 2 ] , [ 1 , 2 , 5 ] ] NEW_LINE solveQuery ( arr , n , Q , query ) NEW_LINE DEDENT"}
{"id": "aizu_p02425_A", "sol": 0, "python_code": "l = [ 0 for _ in range ( 64 ) ]\nfor i in range ( int ( input ( ) ) ) :\n    query = list ( input ( ).split ( ) )\n    order = query [ 0 ]\n    if order == \"0\" :\n        print ( 1 if l [ int ( query [ 1 ] ) ] else 0 )\n    elif order == \"1\" :\n        l [ int ( query [ 1 ] ) ] = 1\n    elif order == \"2\" :\n        l [ int ( query [ 1 ] ) ] = 0\n    elif order == \"3\" :\n        l [ int ( query [ 1 ] ) ] ^= 1\n    elif order == \"4\" :\n        print ( 1 if all ( l ) else 0 )\n    elif order == \"5\" :\n        print ( 1 if any ( l ) else 0 )\n    elif order == \"6\" :\n        print ( 1 if not any ( l ) else 0 )\n    elif order == \"7\" :\n        print ( sum ( l ) )\n    elif order == \"8\" :\n        tmp = 0\n        for i in reversed ( range ( 64 ) ) :\n            tmp += l [ i ] * 2 ** i\n        print ( tmp )\n", "python_code_tokenized": "l = [ 0 for _ in range ( 64 ) ] NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT query = list ( input ( ) . split ( ) ) NEW_LINE order = query [ 0 ] NEW_LINE if order == \"0\" : NEW_LINE INDENT print ( 1 if l [ int ( query [ 1 ] ) ] else 0 ) NEW_LINE DEDENT elif order == \"1\" : NEW_LINE INDENT l [ int ( query [ 1 ] ) ] = 1 NEW_LINE DEDENT elif order == \"2\" : NEW_LINE INDENT l [ int ( query [ 1 ] ) ] = 0 NEW_LINE DEDENT elif order == \"3\" : NEW_LINE INDENT l [ int ( query [ 1 ] ) ] ^= 1 NEW_LINE DEDENT elif order == \"4\" : NEW_LINE INDENT print ( 1 if all ( l ) else 0 ) NEW_LINE DEDENT elif order == \"5\" : NEW_LINE INDENT print ( 1 if any ( l ) else 0 ) NEW_LINE DEDENT elif order == \"6\" : NEW_LINE INDENT print ( 1 if not any ( l ) else 0 ) NEW_LINE DEDENT elif order == \"7\" : NEW_LINE INDENT print ( sum ( l ) ) NEW_LINE DEDENT elif order == \"8\" : NEW_LINE INDENT tmp = 0 NEW_LINE for i in reversed ( range ( 64 ) ) : NEW_LINE INDENT tmp += l [ i ] * 2 ** i NEW_LINE DEDENT print ( tmp ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_641_A", "sol": 0, "python_code": "def findFibSubset ( arr , n ) :\n    m = max ( arr )\n    a = 0\n    b = 1\n    hash = [ ]\n    hash.append ( a )\n    hash.append ( b )\n    while ( b < m ) :\n        c = a + b\n        a = b\n        b = c\n        hash.append ( b )\n    for i in range ( n ) :\n        if arr [ i ] in hash :\n            print ( arr [ i ] , end = \" \" )\nif __name__ == \"__main__\" :\n    arr = [ 4 , 2 , 8 , 5 , 20 , 1 , 40 , 13 , 23 ]\n    n = len ( arr )\n    findFibSubset ( arr , n )\n", "python_code_tokenized": "def findFibSubset ( arr , n ) : NEW_LINE INDENT m = max ( arr ) NEW_LINE a = 0 NEW_LINE b = 1 NEW_LINE hash = [ ] NEW_LINE hash . append ( a ) NEW_LINE hash . append ( b ) NEW_LINE while ( b < m ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE hash . append ( b ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in hash : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 2 , 8 , 5 , 20 , 1 , 40 , 13 , 23 ] NEW_LINE n = len ( arr ) NEW_LINE findFibSubset ( arr , n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2231_A", "sol": 0, "python_code": "def productDivisible ( n , k ) :\n    product = 1\n    position = 1\n    while n > 0 :\n        if position % 2 == 0 :\n            product *= n % 10\n        n = n / 10\n        position += 1\n    if product % k == 0 :\n        return True\n    return False\nn = 321922\nk = 3\nif productDivisible ( n , k ) == True :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "def productDivisible ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE position = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if position % 2 == 0 : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT n = n / 10 NEW_LINE position += 1 NEW_LINE DEDENT if product % k == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 321922 NEW_LINE k = 3 NEW_LINE if productDivisible ( n , k ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2665_A", "sol": 0, "python_code": "def countPairs ( s1 , n1 , s2 , n2 ) :\n    freq1 = [ 0 ] * 26 ;\n    freq2 = [ 0 ] * 26 ;\n    count = 0 ;\n    for i in range ( n1 ) :\n        freq1 [ ord ( s1 [ i ] ) - ord ( 'a' ) ] += 1 ;\n    for i in range ( n2 ) :\n        freq2 [ ord ( s2 [ i ] ) - ord ( 'a' ) ] += 1 ;\n    for i in range ( 26 ) :\n        count += min ( freq1 [ i ] , freq2 [ i ] ) ;\n    return count ;\nif __name__ == \"__main__\" :\n    s1 = \"geeksforgeeks\" ;\n    s2 = \"platformforgeeks\" ;\n    n1 = len ( s1 ) ;\n    n2 = len ( s2 ) ;\n    print ( countPairs ( s1 , n1 , s2 , n2 ) ) ;\n", "python_code_tokenized": "def countPairs ( s1 , n1 , s2 , n2 ) : NEW_LINE INDENT freq1 = [ 0 ] * 26 ; NEW_LINE freq2 = [ 0 ] * 26 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT freq1 [ ord ( s1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT freq2 [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT count += min ( freq1 [ i ] , freq2 [ i ] ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeksforgeeks \" ; NEW_LINE s2 = \" platformforgeeks \" ; NEW_LINE n1 = len ( s1 ) ; NEW_LINE n2 = len ( s2 ) ; NEW_LINE print ( countPairs ( s1 , n1 , s2 , n2 ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_415_B", "sol": 0, "python_code": "n , a , b = map ( int , input ( ).split ( ) )\nl = list ( map ( int , input ( ).split ( ) ) )\nfor i in range ( len ( l ) ) :\n    print ( str ( ( l [ i ] * a ) % b // a ) , end = ' ' )\n", "python_code_tokenized": "n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT print ( str ( ( l [ i ] * a ) % b // a ) , end = ' \u2581 ' ) NEW_LINE DEDENT"}
{"id": "codeforces_1508_A", "sol": 0, "python_code": "import itertools\ndef solve ( a , b ) :\n    if a.count ( \"1\" ) * 2 >= len ( a ) and b.count ( \"1\" ) * 2 >= len ( b ) :\n        ch = \"1\"\n        other = \"0\"\n    else :\n        ch = \"0\"\n        other = \"1\"\n    res = [ ]\n    i = 0\n    j = 0\n    ilast = - 1\n    jlast = - 1\n    while i < len ( a ) and j < len ( b ) :\n        while i < len ( a ) and a [ i ] != ch :\n            i += 1\n        while j < len ( b ) and b [ j ] != ch :\n            j += 1\n        res.append ( other * max ( i - ilast - 1 , j - jlast - 1 ) )\n        if i != len ( a ) or j != len ( b ) :\n            res.append ( ch )\n        ilast = i\n        jlast = j\n        i += 1\n        j += 1\n    while i < len ( a ) :\n        res.append ( a [ i ] )\n        i += 1\n    while j < len ( b ) :\n        res.append ( b [ j ] )\n        j += 1\n    return ''.join ( res )\nfor _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    a = input ( )\n    b = input ( )\n    c = input ( )\n    na1 = a.count ( \"1\" )\n    nb1 = b.count ( \"1\" )\n    nc1 = c.count ( \"1\" )\n    res = None\n    if na1 >= n and nb1 >= n or na1 <= n and nb1 <= n :\n        res = solve ( a , b )\n    elif na1 >= n and nc1 >= n or na1 <= n and nc1 <= n :\n        res = solve ( a , c )\n    elif nb1 >= n and nc1 >= n or nb1 <= n and nc1 <= n :\n        res = solve ( b , c )\n    else :\n        raise RuntimeError ( \"unexpected\" )\n    print ( res )\n", "python_code_tokenized": "import itertools NEW_LINE def solve ( a , b ) : NEW_LINE INDENT if a . count ( \"1\" ) * 2 >= len ( a ) and b . count ( \"1\" ) * 2 >= len ( b ) : NEW_LINE INDENT ch = \"1\" NEW_LINE other = \"0\" NEW_LINE DEDENT else : NEW_LINE INDENT ch = \"0\" NEW_LINE other = \"1\" NEW_LINE DEDENT res = [ ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE ilast = - 1 NEW_LINE jlast = - 1 NEW_LINE while i < len ( a ) and j < len ( b ) : NEW_LINE INDENT while i < len ( a ) and a [ i ] != ch : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while j < len ( b ) and b [ j ] != ch : NEW_LINE INDENT j += 1 NEW_LINE DEDENT res . append ( other * max ( i - ilast - 1 , j - jlast - 1 ) ) NEW_LINE if i != len ( a ) or j != len ( b ) : NEW_LINE INDENT res . append ( ch ) NEW_LINE DEDENT ilast = i NEW_LINE jlast = j NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT while i < len ( a ) : NEW_LINE INDENT res . append ( a [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT while j < len ( b ) : NEW_LINE INDENT res . append ( b [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT return ' ' . join ( res ) NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE c = input ( ) NEW_LINE na1 = a . count ( \"1\" ) NEW_LINE nb1 = b . count ( \"1\" ) NEW_LINE nc1 = c . count ( \"1\" ) NEW_LINE res = None NEW_LINE if na1 >= n and nb1 >= n or na1 <= n and nb1 <= n : NEW_LINE INDENT res = solve ( a , b ) NEW_LINE DEDENT elif na1 >= n and nc1 >= n or na1 <= n and nc1 <= n : NEW_LINE INDENT res = solve ( a , c ) NEW_LINE DEDENT elif nb1 >= n and nc1 >= n or nb1 <= n and nc1 <= n : NEW_LINE INDENT res = solve ( b , c ) NEW_LINE DEDENT else : NEW_LINE INDENT raise RuntimeError ( \" unexpected \" ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC074_B", "sol": 0, "python_code": "N = int ( input ( ) )\nK = int ( input ( ) )\nx = list ( map ( int , input ( ).split ( ) ) )\nnum = 0\nfor i in range ( N ) :\n    a = x [ i ]\n    if a <= K - a :\n        num += 2 * a\n    else :\n        num += ( K - a ) * 2\nprint ( num )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE K = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE num = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = x [ i ] NEW_LINE if a <= K - a : NEW_LINE INDENT num += 2 * a NEW_LINE DEDENT else : NEW_LINE INDENT num += ( K - a ) * 2 NEW_LINE DEDENT DEDENT print ( num ) NEW_LINE"}
{"id": "codeforces_1119_A", "sol": 0, "python_code": "import math\ndef _input ( ) : return map ( int , input ( ).split ( ) )\nn = int ( input ( ) )\nlst = list ( _input ( ) )\nif lst [ 0 ] != lst [ - 1 ] : print ( n - 1 )\nelse :\n    i = 1\n    while i < n and lst [ i ] == lst [ 0 ] : i += 1\n    j = n - 2\n    while j >= 0 and lst [ j ] == lst [ 0 ] : j -= 1\n    print ( max ( n - i - 1 , j ) )\n", "python_code_tokenized": "import math NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE lst = list ( _input ( ) ) NEW_LINE if lst [ 0 ] != lst [ - 1 ] : print ( n - 1 ) NEW_LINE else : NEW_LINE INDENT i = 1 NEW_LINE while i < n and lst [ i ] == lst [ 0 ] : i += 1 NEW_LINE j = n - 2 NEW_LINE while j >= 0 and lst [ j ] == lst [ 0 ] : j -= 1 NEW_LINE print ( max ( n - i - 1 , j ) ) NEW_LINE DEDENT"}
{"id": "projecteuler_p203_A", "sol": 0, "python_code": "import eulerlib\ndef compute ( ) :\n    numbers = set ( eulerlib.binomial ( n , k ) for n in range ( 51 ) for k in range ( n + 1 ) )\n    maximum = max ( numbers )\n    primes = eulerlib.list_primes ( eulerlib.sqrt ( maximum ) )\n    primessquared = [ p * p for p in primes ]\n    def is_squarefree ( n ) :\n        for p2 in primessquared :\n            if p2 > n :\n                break\n            if n % p2 == 0 :\n                return False\n        return True\n    ans = sum ( n for n in numbers if is_squarefree ( n ) )\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT numbers = set ( eulerlib . binomial ( n , k ) for n in range ( 51 ) for k in range ( n + 1 ) ) NEW_LINE maximum = max ( numbers ) NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( maximum ) ) NEW_LINE primessquared = [ p * p for p in primes ] NEW_LINE def is_squarefree ( n ) : NEW_LINE INDENT for p2 in primessquared : NEW_LINE INDENT if p2 > n : NEW_LINE INDENT break NEW_LINE DEDENT if n % p2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT ans = sum ( n for n in numbers if is_squarefree ( n ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5229_A", "sol": 0, "python_code": "def smallestIndex ( a , n ) :\n    right1 = 0\n    right0 = 0\n    for i in range ( n ) :\n        if ( a [ i ] == 1 ) :\n            right1 = i\n        else :\n            right0 = i\n    return min ( right1 , right0 )\nif __name__ == '__main__' :\n    a = [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ]\n    n = len ( a )\n    print ( smallestIndex ( a , n ) )\n", "python_code_tokenized": "def smallestIndex ( a , n ) : NEW_LINE INDENT right1 = 0 NEW_LINE right0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = i NEW_LINE DEDENT else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT DEDENT return min ( right1 , right0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( smallestIndex ( a , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5239_A", "sol": 0, "python_code": "MAX = 50\ndef solveQuery ( n , q , qi , qj ) :\n    arr = [ None ] * MAX\n    for i in range ( n + 1 ) :\n        arr [ i ] = 0\n    for k in range ( q ) :\n        flag = 0\n        if ( qj [ k ] < qi [ k ] ) :\n            qj [ k ] , qi [ k ] = qi [ k ] , qj [ k ]\n        if ( arr [ qi [ k ] ] != 0 or arr [ qj [ k ] ] != 0 ) :\n            flag = 1\n        elif ( qi [ k ] == qj [ k ] ) :\n            flag = 1\n        else :\n            for i in range ( 1 , qi [ k ] ) :\n                if ( arr [ i ] != 0 and arr [ i ] < qj [ k ] and qi [ k ] < arr [ i ] ) :\n                    flag = 1\n                    break\n            if ( flag == 0 ) :\n                for i in range ( qi [ k ] + 1 , qj [ k ] ) :\n                    if ( arr [ i ] != 0 and arr [ i ] > qj [ k ] ) :\n                        flag = 1\n                        break\n        if ( flag == 0 ) :\n            print ( \"YES\" )\n            arr [ qi [ k ] ] = qj [ k ]\n            arr [ qj [ k ] ] = qi [ k ]\n        else :\n            print ( \"NO\" )\nif __name__ == \"__main__\" :\n    n = 10\n    q = 7\n    qi = [ 1 , 2 , 2 , 2 , 9 , 10 , 8 ]\n    qj = [ 5 , 7 , 3 , 4 , 9 , 9 , 6 ]\n    solveQuery ( n , q , qi , qj )\n", "python_code_tokenized": "MAX = 50 NEW_LINE def solveQuery ( n , q , qi , qj ) : NEW_LINE INDENT arr = [ None ] * MAX NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT for k in range ( q ) : NEW_LINE INDENT flag = 0 NEW_LINE if ( qj [ k ] < qi [ k ] ) : NEW_LINE INDENT qj [ k ] , qi [ k ] = qi [ k ] , qj [ k ] NEW_LINE DEDENT if ( arr [ qi [ k ] ] != 0 or arr [ qj [ k ] ] != 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif ( qi [ k ] == qj [ k ] ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , qi [ k ] ) : NEW_LINE INDENT if ( arr [ i ] != 0 and arr [ i ] < qj [ k ] and qi [ k ] < arr [ i ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT for i in range ( qi [ k ] + 1 , qj [ k ] ) : NEW_LINE INDENT if ( arr [ i ] != 0 and arr [ i ] > qj [ k ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE arr [ qi [ k ] ] = qj [ k ] NEW_LINE arr [ qj [ k ] ] = qi [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE q = 7 NEW_LINE qi = [ 1 , 2 , 2 , 2 , 9 , 10 , 8 ] NEW_LINE qj = [ 5 , 7 , 3 , 4 , 9 , 9 , 6 ] NEW_LINE solveQuery ( n , q , qi , qj ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2725_A", "sol": 0, "python_code": "def longestPrefixSuffix ( s ) :\n    n = len ( s )\n    for res in range ( n // 2 , 0 , - 1 ) :\n        prefix = s [ 0 : res ]\n        suffix = s [ n - res : n ]\n        if ( prefix == suffix ) :\n            return res\n    return 0\ns = \"blablabla\"\nprint ( longestPrefixSuffix ( s ) )\n", "python_code_tokenized": "def longestPrefixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for res in range ( n // 2 , 0 , - 1 ) : NEW_LINE INDENT prefix = s [ 0 : res ] NEW_LINE suffix = s [ n - res : n ] NEW_LINE if ( prefix == suffix ) : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT s = \" blablabla \" NEW_LINE print ( longestPrefixSuffix ( s ) ) NEW_LINE"}
{"id": "geeksforgeeks_82_A", "sol": 0, "python_code": "def atMostK ( arr , n , k ) :\n    count = 0\n    left = 0\n    right = 0\n    map = { }\n    while ( right < n ) :\n        if arr [ right ] not in map :\n            map [ arr [ right ] ] = 0\n        map [ arr [ right ] ] += 1\n        while ( len ( map ) > k ) :\n            if arr [ left ] not in map :\n                map [ arr [ left ] ] = 0\n            map [ arr [ left ] ] -= 1\n            if map [ arr [ left ] ] == 0 :\n                del map [ arr [ left ] ]\n            left += 1\n        count += right - left + 1\n        right += 1\n    return count\ndef exactlyK ( arr , n , k ) :\n    return ( atMostK ( arr , n , k ) - atMostK ( arr , n , k - 1 ) )\nif __name__ == \"__main__\" :\n    arr = [ 2 , 1 , 2 , 1 , 6 ]\n    n = len ( arr )\n    k = 2\n    print ( exactlyK ( arr , n , k ) )\n", "python_code_tokenized": "def atMostK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE map = { } NEW_LINE while ( right < n ) : NEW_LINE INDENT if arr [ right ] not in map : NEW_LINE INDENT map [ arr [ right ] ] = 0 NEW_LINE DEDENT map [ arr [ right ] ] += 1 NEW_LINE while ( len ( map ) > k ) : NEW_LINE INDENT if arr [ left ] not in map : NEW_LINE INDENT map [ arr [ left ] ] = 0 NEW_LINE DEDENT map [ arr [ left ] ] -= 1 NEW_LINE if map [ arr [ left ] ] == 0 : NEW_LINE INDENT del map [ arr [ left ] ] NEW_LINE DEDENT left += 1 NEW_LINE DEDENT count += right - left + 1 NEW_LINE right += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def exactlyK ( arr , n , k ) : NEW_LINE INDENT return ( atMostK ( arr , n , k ) - atMostK ( arr , n , k - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( exactlyK ( arr , n , k ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1130_B", "sol": 0, "python_code": "import sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\nn = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nx = [ [ ] for _ in range ( n + 1 ) ]\nfor i in range ( 2 * n ) :\n    x [ a [ i ] ].append ( i )\nx [ 0 ] = [ 0 , 0 ]\nans = 0\nfor i in range ( n ) :\n    u , v = x [ i ] , x [ i + 1 ]\n    ans += min ( abs ( u [ 0 ] - v [ 0 ] ) + abs ( u [ 1 ] - v [ 1 ] ) , abs ( u [ 0 ] - v [ 1 ] ) + abs ( u [ 1 ] - v [ 0 ] ) )\nprint ( ans )\n", "python_code_tokenized": "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = [ [ ] for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT x [ a [ i ] ] . append ( i ) NEW_LINE DEDENT x [ 0 ] = [ 0 , 0 ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT u , v = x [ i ] , x [ i + 1 ] NEW_LINE ans += min ( abs ( u [ 0 ] - v [ 0 ] ) + abs ( u [ 1 ] - v [ 1 ] ) , abs ( u [ 0 ] - v [ 1 ] ) + abs ( u [ 1 ] - v [ 0 ] ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "projecteuler_p162_A", "sol": 0, "python_code": "def compute ( ) :\n    ans = sum ( ( 15 * 16 ** ( n - 1 ) - 43 * 15 ** ( n - 1 ) + 41 * 14 ** ( n - 1 ) - 13 ** n ) for n in range ( 1 , 17 ) )\n    return f\"{ans:X}\"\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT ans = sum ( ( 15 * 16 ** ( n - 1 ) - 43 * 15 ** ( n - 1 ) + 41 * 14 ** ( n - 1 ) - 13 ** n ) for n in range ( 1 , 17 ) ) NEW_LINE return f \" { ans : X } \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4150_A", "sol": 0, "python_code": "from collections import defaultdict\ndef SieveOfEratosthenes ( prime , p_size ) :\n    prime [ 0 ] = False\n    prime [ 1 ] = False\n    p = 2\n    while p * p <= p_size :\n        if prime [ p ] :\n            for i in range ( p * 2 , p_size + 1 , p ) :\n                prime [ i ] = False\n        p += 1\ndef xorOfPrime ( s ) :\n    prime = [ True ] * 100005\n    SieveOfEratosthenes ( prime , 10005 )\n    m = defaultdict ( lambda : 0 )\n    for i in range ( 0 , len ( s ) ) :\n        m [ s [ i ] ] += 1\n    result = flag = 0\n    for it in m :\n        if prime [ m [ it ] ] :\n            result ^= m [ it ]\n            flag = 1\n    if not flag :\n        return - 1\n    return result\nif __name__ == \"__main__\" :\n    s = \"gggggeeekkkks\"\n    print ( xorOfPrime ( s ) )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= p_size : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def xorOfPrime ( s ) : NEW_LINE INDENT prime = [ True ] * 100005 NEW_LINE SieveOfEratosthenes ( prime , 10005 ) NEW_LINE m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT result = flag = 0 NEW_LINE for it in m : NEW_LINE INDENT if prime [ m [ it ] ] : NEW_LINE INDENT result ^= m [ it ] NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" gggggeeekkkks \" NEW_LINE print ( xorOfPrime ( s ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00144_A", "sol": 0, "python_code": "n = int ( raw_input ( ) )\ng = [ [ 1000000 ] * n for _ in xrange ( n ) ]\nfor i in xrange ( n ) :\n    g [ i ] [ i ] = 0\nfor i in xrange ( n ) :\n    r = map ( int , raw_input ( ).split ( ) )\n    for j in r [ 2 : ] :\n        g [ r [ 0 ] - 1 ] [ j - 1 ] = 1\nfor k in xrange ( n ) :\n    for i in xrange ( n ) :\n        for j in xrange ( n ) :\n            g [ i ] [ j ] = min ( g [ i ] [ j ] , g [ i ] [ k ] + g [ k ] [ j ] )\nm = int ( raw_input ( ) )\nfor i in xrange ( m ) :\n    s , d , v = map ( int , raw_input ( ).split ( ) )\n    s -= 1\n    d -= 1\n    if g [ s ] [ d ] < v :\n        print ( g [ s ] [ d ] + 1 )\n    else :\n        print ( 'NA' )\n", "python_code_tokenized": "n = int ( raw_input ( ) ) NEW_LINE g = [ [ 1000000 ] * n for _ in xrange ( n ) ] NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT g [ i ] [ i ] = 0 NEW_LINE DEDENT for i in xrange ( n ) : NEW_LINE INDENT r = map ( int , raw_input ( ) . split ( ) ) NEW_LINE for j in r [ 2 : ] : NEW_LINE INDENT g [ r [ 0 ] - 1 ] [ j - 1 ] = 1 NEW_LINE DEDENT DEDENT for k in xrange ( n ) : NEW_LINE INDENT for i in xrange ( n ) : NEW_LINE INDENT for j in xrange ( n ) : NEW_LINE INDENT g [ i ] [ j ] = min ( g [ i ] [ j ] , g [ i ] [ k ] + g [ k ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT m = int ( raw_input ( ) ) NEW_LINE for i in xrange ( m ) : NEW_LINE INDENT s , d , v = map ( int , raw_input ( ) . split ( ) ) NEW_LINE s -= 1 NEW_LINE d -= 1 NEW_LINE if g [ s ] [ d ] < v : NEW_LINE INDENT print ( g [ s ] [ d ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NA ' ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1969_A", "sol": 0, "python_code": "from math import gcd\ndef getWinner ( arr , n ) :\n    __gcd = arr [ 0 ] ;\n    maxEle = arr [ 0 ] ;\n    for i in range ( 1 , n ) :\n        __gcd = gcd ( __gcd , arr [ i ] ) ;\n        maxEle = max ( maxEle , arr [ i ] ) ;\n    totalMoves = ( maxEle / __gcd ) - n ;\n    if ( totalMoves % 2 == 1 ) :\n        return 'A' ;\n    return 'B' ;\nif __name__ == \"__main__\" :\n    arr = [ 5 , 6 , 7 ] ;\n    n = len ( arr )\n    print ( getWinner ( arr , n ) )\n", "python_code_tokenized": "from math import gcd NEW_LINE def getWinner ( arr , n ) : NEW_LINE INDENT __gcd = arr [ 0 ] ; NEW_LINE maxEle = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT __gcd = gcd ( __gcd , arr [ i ] ) ; NEW_LINE maxEle = max ( maxEle , arr [ i ] ) ; NEW_LINE DEDENT totalMoves = ( maxEle / __gcd ) - n ; NEW_LINE if ( totalMoves % 2 == 1 ) : NEW_LINE INDENT return ' A ' ; NEW_LINE DEDENT return ' B ' ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 6 , 7 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( getWinner ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4779_A", "sol": 0, "python_code": "def swapNibbles ( x ) :\n    return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 )\nx = 100\nprint ( swapNibbles ( x ) )\n", "python_code_tokenized": "def swapNibbles ( x ) : NEW_LINE INDENT return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) NEW_LINE DEDENT x = 100 NEW_LINE print ( swapNibbles ( x ) ) NEW_LINE"}
{"id": "geeksforgeeks_4347_A", "sol": 0, "python_code": "def sum ( x , n ) :\n    total = 1.0 ;\n    previous = 1.0 ;\n    for i in range ( 1 , n + 1 ) :\n        previous = ( previous * x ) / ( i + 1 ) ;\n        total = total + previous ;\n    return total ;\nif __name__ == '__main__' :\n    x = 5 ;\n    n = 4 ;\n    print ( \"Sum is: \" , sum ( x , n ) ) ;\n", "python_code_tokenized": "def sum ( x , n ) : NEW_LINE INDENT total = 1.0 ; NEW_LINE previous = 1.0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT previous = ( previous * x ) / ( i + 1 ) ; NEW_LINE total = total + previous ; NEW_LINE DEDENT return total ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 5 ; NEW_LINE n = 4 ; NEW_LINE print ( \" Sum \u2581 is : \u2581 \" , sum ( x , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2104_A", "sol": 0, "python_code": "def findMinOperations ( S ) :\n    S = S [ : : - 1 ]\n    n = len ( S )\n    dp = [ [ 0 ] * 2 ] * ( n + 1 )\n    if ( S [ 0 ] == '0' ) :\n        dp [ 0 ] [ 0 ] = 0\n    else :\n        dp [ 0 ] [ 0 ] = 1\n    dp [ 0 ] [ 1 ] = 1\n    for i in range ( 1 , n ) :\n        if ( S [ i ] == '0' ) :\n            dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ]\n            dp [ i ] [ 1 ] = 1 + min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] )\n        else :\n            dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ;\n            dp [ i ] [ 0 ] = 1 + min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] )\n    return dp [ n - 1 ] [ 0 ]\nif __name__ == \"__main__\" :\n    S = \"100\"\n    print ( findMinOperations ( S ) )\n    S = \"111\" ;\n    print ( findMinOperations ( S ) )\n", "python_code_tokenized": "def findMinOperations ( S ) : NEW_LINE INDENT S = S [ : : - 1 ] NEW_LINE n = len ( S ) NEW_LINE dp = [ [ 0 ] * 2 ] * ( n + 1 ) NEW_LINE if ( S [ 0 ] == '0' ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT dp [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( S [ i ] == '0' ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = 1 + min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ; NEW_LINE dp [ i ] [ 0 ] = 1 + min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] [ 0 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"100\" NEW_LINE print ( findMinOperations ( S ) ) NEW_LINE S = \"111\" ; NEW_LINE print ( findMinOperations ( S ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4605_A", "sol": 0, "python_code": "import math\nsize = 101\nfib = [ 0 ] * 100010\nfreq = [ 0 ] * ( 100010 )\ndef isPerfectSquare ( x ) :\n    s = int ( math.sqrt ( x ) )\n    return ( s * s ) == x\ndef isFibonacci ( n ) :\n    if ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) :\n        return 1 ;\n    return 0 ;\ndef compute ( a , b ) :\n    for i in range ( 1 , 100010 ) :\n        fib [ i ] = isFibonacci ( i )\n    for x in range ( 1 , 100010 ) :\n        for y in range ( 1 , size ) :\n            if ( fib [ x ] == 1 and fib [ y ] == 1 and a * x + b * y < 100010 ) :\n                freq [ a * x + b * y ] += 1\nQ = 2\nA = 5\nB = 10\ncompute ( A , B ) ;\narr = [ 50 , 150 ]\nfor i in range ( Q ) :\n    print ( freq [ arr [ i ] ] , end = \" \" )\n", "python_code_tokenized": "import math NEW_LINE size = 101 NEW_LINE fib = [ 0 ] * 100010 NEW_LINE freq = [ 0 ] * ( 100010 ) NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = int ( math . sqrt ( x ) ) NEW_LINE return ( s * s ) == x NEW_LINE DEDENT def isFibonacci ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT def compute ( a , b ) : NEW_LINE INDENT for i in range ( 1 , 100010 ) : NEW_LINE INDENT fib [ i ] = isFibonacci ( i ) NEW_LINE DEDENT for x in range ( 1 , 100010 ) : NEW_LINE INDENT for y in range ( 1 , size ) : NEW_LINE INDENT if ( fib [ x ] == 1 and fib [ y ] == 1 and a * x + b * y < 100010 ) : NEW_LINE INDENT freq [ a * x + b * y ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT Q = 2 NEW_LINE A = 5 NEW_LINE B = 10 NEW_LINE compute ( A , B ) ; NEW_LINE arr = [ 50 , 150 ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT print ( freq [ arr [ i ] ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "codeforces_86_A", "sol": 0, "python_code": "l , r = [ int ( x ) for x in input ( ).split ( ) ]\ncurr = r\ns = 0\nwhile curr :\n    s += 1\n    curr //= 10\nfirst = 10 ** s\nsecond = first // 2\nans = - 1\nfor i in [ l , r , first , second ] :\n    if i >= l and i <= r :\n        curr = i\n        rev = ''\n        for k in str ( curr ) :\n            rev += str ( 9 - int ( k ) )\n        ans = max ( ans , int ( rev ) * curr )\nprint ( ans )\n", "python_code_tokenized": "l , r = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE curr = r NEW_LINE s = 0 NEW_LINE while curr : NEW_LINE INDENT s += 1 NEW_LINE curr //= 10 NEW_LINE DEDENT first = 10 ** s NEW_LINE second = first // 2 NEW_LINE ans = - 1 NEW_LINE for i in [ l , r , first , second ] : NEW_LINE INDENT if i >= l and i <= r : NEW_LINE INDENT curr = i NEW_LINE rev = ' ' NEW_LINE for k in str ( curr ) : NEW_LINE INDENT rev += str ( 9 - int ( k ) ) NEW_LINE DEDENT ans = max ( ans , int ( rev ) * curr ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_4386_A", "sol": 0, "python_code": "def pattern ( N ) :\n    k , space , rows = 0 , 1 , N\n    for i in range ( rows , 0 , - 1 ) :\n        for j in range ( 1 , i + 1 ) :\n            print ( '*' , end = '' )\n        if i != rows :\n            for k in range ( 1 , space + 1 ) :\n                print ( '' , end = '' )\n            space += 2\n        for j in range ( i , 0 , - 1 ) :\n            if j != rows :\n                print ( '*' , end = '' )\n        print ( )\n    print ( )\nN = 6\npattern ( N )\n", "python_code_tokenized": "def pattern ( N ) : NEW_LINE INDENT k , space , rows = 0 , 1 , N NEW_LINE for i in range ( rows , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( ' * ' , end = ' ' ) NEW_LINE DEDENT if i != rows : NEW_LINE INDENT for k in range ( 1 , space + 1 ) : NEW_LINE INDENT print ( ' \u2581 ' , end = ' ' ) NEW_LINE DEDENT space += 2 NEW_LINE DEDENT for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT if j != rows : NEW_LINE INDENT print ( ' * ' , end = ' ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT N = 6 NEW_LINE pattern ( N ) NEW_LINE"}
{"id": "geeksforgeeks_1937_A", "sol": 0, "python_code": "def isRotated ( str1 , str2 ) :\n    if ( len ( str1 ) != len ( str2 ) ) :\n        return False\n    clock_rot = \"\"\n    anticlock_rot = \"\"\n    l = len ( str2 )\n    anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] )\n    clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ]\n    return ( str1 == clock_rot or str1 == anticlock_rot )\nif __name__ == \"__main__\" :\n    str1 = \"geeks\"\n    str2 = \"eksge\"\nif isRotated ( str1 , str2 ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def isRotated ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT clock_rot = \" \" NEW_LINE anticlock_rot = \" \" NEW_LINE l = len ( str2 ) NEW_LINE anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] ) NEW_LINE clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ] NEW_LINE return ( str1 == clock_rot or str1 == anticlock_rot ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeks \" NEW_LINE str2 = \" eksge \" NEW_LINE DEDENT if isRotated ( str1 , str2 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "codeforces_551_A", "sol": 0, "python_code": "def gukiz ( n ) :\n    ls = list ( map ( int , input ( ).split ( ) ) ) [ : n ]\n    for i in range ( n ) :\n        c = 1\n        for j in range ( n ) :\n            if ( ls [ i ] < ls [ j ] ) :\n                c += 1\n        print ( c , end = \" \" )\na = int ( input ( ) )\ngukiz ( a )\n", "python_code_tokenized": "def gukiz ( n ) : NEW_LINE INDENT ls = list ( map ( int , input ( ) . split ( ) ) ) [ : n ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ls [ i ] < ls [ j ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT a = int ( input ( ) ) NEW_LINE gukiz ( a ) NEW_LINE"}
{"id": "aizu_p00166_A", "sol": 0, "python_code": "from math import *\ndef area ( x ) :\n    ret = 0.\n    theta = 360.\n    for i in range ( x - 1 ) :\n        tmp = float ( input ( ) )\n        theta -= tmp\n        tmp = tmp * pi / 180.\n        ret += ( sin ( tmp / 2 ) * cos ( tmp / 2 ) )\n    theta = pi * theta / 180.\n    ret += sin ( theta / 2 ) * cos ( theta / 2 ) ;\n    return ret ;\nwhile 1 :\n    m = int ( input ( ) )\n    if m == 0 : break\n    a = area ( m )\n    b = area ( int ( input ( ) ) )\n    print ( 0 if a == b else ( 1 if a > b else 2 ) )\n", "python_code_tokenized": "from math import * NEW_LINE def area ( x ) : NEW_LINE INDENT ret = 0. NEW_LINE theta = 360. NEW_LINE for i in range ( x - 1 ) : NEW_LINE INDENT tmp = float ( input ( ) ) NEW_LINE theta -= tmp NEW_LINE tmp = tmp * pi / 180. NEW_LINE ret += ( sin ( tmp / 2 ) * cos ( tmp / 2 ) ) NEW_LINE DEDENT theta = pi * theta / 180. NEW_LINE ret += sin ( theta / 2 ) * cos ( theta / 2 ) ; NEW_LINE return ret ; NEW_LINE DEDENT while 1 : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE if m == 0 : break NEW_LINE a = area ( m ) NEW_LINE b = area ( int ( input ( ) ) ) NEW_LINE print ( 0 if a == b else ( 1 if a > b else 2 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1638_A", "sol": 0, "python_code": "def partition ( arr , low , high ) :\n    pivot = arr [ high ]\n    i = ( low - 1 )\n    for j in range ( low , high ) :\n        if ( arr [ j ] <= pivot ) :\n            i += 1\n            arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]\n    arr [ i + 1 ] , arr [ high ] = arr [ high ] , arr [ i + 1 ]\n    return ( i + 1 )\ndef quickSort ( arr , low , high ) :\n    if ( low < high ) :\n        pi = partition ( arr , low , high )\n        quickSort ( arr , low , pi - 1 )\n        quickSort ( arr , pi + 1 , high )\ndef printArray ( arr , size ) :\n    for i in range ( size ) :\n        print ( arr [ i ] , end = \" \" )\n    print ( )\narr = [ 10 , 7 , 8 , 9 , 1 , 5 ]\nn = len ( arr )\nquickSort ( arr , 0 , n - 1 )\nprint ( \"Sorted array:\" )\nprintArray ( arr , n )\n", "python_code_tokenized": "def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ high ] NEW_LINE i = ( low - 1 ) NEW_LINE for j in range ( low , high ) : NEW_LINE INDENT if ( arr [ j ] <= pivot ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ high ] = arr [ high ] , arr [ i + 1 ] NEW_LINE return ( i + 1 ) NEW_LINE DEDENT def quickSort ( arr , low , high ) : NEW_LINE INDENT if ( low < high ) : NEW_LINE INDENT pi = partition ( arr , low , high ) NEW_LINE quickSort ( arr , low , pi - 1 ) NEW_LINE quickSort ( arr , pi + 1 , high ) NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 10 , 7 , 8 , 9 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE quickSort ( arr , 0 , n - 1 ) NEW_LINE print ( \" Sorted \u2581 array : \" ) NEW_LINE printArray ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_1639_A", "sol": 0, "python_code": "def partition ( arr , low , high ) :\n    pivot = arr [ low ]\n    i = low - 1\n    j = high + 1\n    while ( True ) :\n        i += 1\n        while ( arr [ i ] < pivot ) :\n            i += 1\n        j -= 1\n        while ( arr [ j ] > pivot ) :\n            j -= 1\n        if ( i >= j ) :\n            return j\n        arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]\ndef quickSort ( arr , low , high ) :\n    if ( low < high ) :\n        pi = partition ( arr , low , high )\n        quickSort ( arr , low , pi )\n        quickSort ( arr , pi + 1 , high )\ndef printArray ( arr , n ) :\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" )\n    print ( )\narr = [ 10 , 7 , 8 , 9 , 1 , 5 ]\nn = len ( arr )\nquickSort ( arr , 0 , n - 1 )\nprint ( \"Sorted array:\" )\nprintArray ( arr , n )\n", "python_code_tokenized": "def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ low ] NEW_LINE i = low - 1 NEW_LINE j = high + 1 NEW_LINE while ( True ) : NEW_LINE INDENT i += 1 NEW_LINE while ( arr [ i ] < pivot ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT j -= 1 NEW_LINE while ( arr [ j ] > pivot ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i >= j ) : NEW_LINE INDENT return j NEW_LINE DEDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT def quickSort ( arr , low , high ) : NEW_LINE INDENT if ( low < high ) : NEW_LINE INDENT pi = partition ( arr , low , high ) NEW_LINE quickSort ( arr , low , pi ) NEW_LINE quickSort ( arr , pi + 1 , high ) NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 10 , 7 , 8 , 9 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE quickSort ( arr , 0 , n - 1 ) NEW_LINE print ( \" Sorted \u2581 array : \" ) NEW_LINE printArray ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_3980_A", "sol": 0, "python_code": "def printPrevSmaller ( arr , n ) :\n    print ( \"_, \" , end = \"\" )\n    for i in range ( 1 , n ) :\n        for j in range ( i - 1 , - 2 , - 1 ) :\n            if ( arr [ j ] < arr [ i ] ) :\n                print ( arr [ j ] , \", \" , end = \"\" )\n                break\n        if ( j == - 1 ) :\n            print ( \"_, \" , end = \"\" )\narr = [ 1 , 3 , 0 , 2 , 5 ]\nn = len ( arr )\nprintPrevSmaller ( arr , n )\n", "python_code_tokenized": "def printPrevSmaller ( arr , n ) : NEW_LINE INDENT print ( \" _ , \u2581 \" , end = \" \" ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] ) : NEW_LINE INDENT print ( arr [ j ] , \" , \u2581 \" , end = \" \" ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == - 1 ) : NEW_LINE INDENT print ( \" _ , \u2581 \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 3 , 0 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printPrevSmaller ( arr , n ) NEW_LINE"}
{"id": "codeforces_362_B", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nif m == 0 :\n    print ( \"YES\" )\n    exit ( )\na = list ( map ( int , input ( ).split ( ) ) )\na.sort ( )\nif a [ 0 ] == 1 or a [ - 1 ] == n :\n    print ( \"NO\" )\n    exit ( )\nfor i in range ( m - 2 ) :\n    if a [ i + 2 ] == ( a [ i ] + 2 ) :\n        print ( \"NO\" )\n        exit ( )\nprint ( \"YES\" )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE exit ( ) NEW_LINE DEDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if a [ 0 ] == 1 or a [ - 1 ] == n : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( m - 2 ) : NEW_LINE INDENT if a [ i + 2 ] == ( a [ i ] + 2 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( \" YES \" ) NEW_LINE"}
{"id": "geeksforgeeks_3905_A", "sol": 0, "python_code": "def isPalindrome ( str ) :\n    n = len ( str )\n    for i in range ( n // 2 ) :\n        if ( str [ i ] != str [ n - i - 1 ] ) :\n            return False\n    return True\ndef maxLengthNonPalinSubstring ( str ) :\n    n = len ( str )\n    ch = str [ 0 ]\n    i = 1\n    for i in range ( 1 , n ) :\n        if ( str [ i ] != ch ) :\n            break\n    if ( i == n ) :\n        return 0\n    if ( isPalindrome ( str ) ) :\n        return n - 1\n    return n\nif __name__ == \"__main__\" :\n    str = \"abba\"\n    print ( \"Maximum length =\" , maxLengthNonPalinSubstring ( str ) )\n", "python_code_tokenized": "def isPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT if ( str [ i ] != str [ n - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def maxLengthNonPalinSubstring ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE ch = str [ 0 ] NEW_LINE i = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( str [ i ] != ch ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( isPalindrome ( str ) ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT return n NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" abba \" NEW_LINE print ( \" Maximum \u2581 length \u2581 = \" , maxLengthNonPalinSubstring ( str ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1067_A", "sol": 0, "python_code": "seg = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ]\ndef LedRequired ( s , led ) :\n    count = 0\n    for i in range ( len ( s ) ) :\n        count += seg [ ord ( s [ i ] ) - 48 ]\n    if ( count <= led ) :\n        return \"YES\"\n    else :\n        return \"NO\"\nif __name__ == \"__main__\" :\n    S = \"123456789\"\n    led = 20\n    print ( LedRequired ( S , led ) )\n", "python_code_tokenized": "seg = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] NEW_LINE def LedRequired ( s , led ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT count += seg [ ord ( s [ i ] ) - 48 ] NEW_LINE DEDENT if ( count <= led ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"123456789\" NEW_LINE led = 20 NEW_LINE print ( LedRequired ( S , led ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2599_A", "sol": 0, "python_code": "def decimalToBinary ( num , k_prec ) :\n    binary = \"\"\n    Integral = int ( num )\n    fractional = num - Integral\n    while ( Integral ) :\n        rem = Integral % 2\n        binary += str ( rem ) ;\n        Integral //= 2\n    binary = binary [ : : - 1 ]\n    binary += '.'\n    while ( k_prec ) :\n        fractional *= 2\n        fract_bit = int ( fractional )\n        if ( fract_bit == 1 ) :\n            fractional -= fract_bit\n            binary += '1'\n        else :\n            binary += '0'\n        k_prec -= 1\n    return binary\nif __name__ == \"__main__\" :\n    n = 4.47\n    k = 3\n    print ( decimalToBinary ( n , k ) )\n    n = 6.986\n    k = 5\n    print ( decimalToBinary ( n , k ) )\n", "python_code_tokenized": "def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = \" \" NEW_LINE Integral = int ( num ) NEW_LINE fractional = num - Integral NEW_LINE while ( Integral ) : NEW_LINE INDENT rem = Integral % 2 NEW_LINE binary += str ( rem ) ; NEW_LINE Integral //= 2 NEW_LINE DEDENT binary = binary [ : : - 1 ] NEW_LINE binary += ' . ' NEW_LINE while ( k_prec ) : NEW_LINE INDENT fractional *= 2 NEW_LINE fract_bit = int ( fractional ) NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENT fractional -= fract_bit NEW_LINE binary += '1' NEW_LINE DEDENT else : NEW_LINE INDENT binary += '0' NEW_LINE DEDENT k_prec -= 1 NEW_LINE DEDENT return binary NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4.47 NEW_LINE k = 3 NEW_LINE print ( decimalToBinary ( n , k ) ) NEW_LINE n = 6.986 NEW_LINE k = 5 NEW_LINE print ( decimalToBinary ( n , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3863_A", "sol": 0, "python_code": "def largest_alphabet ( a , n ) :\n    max = 'A'\n    for i in range ( n ) :\n        if ( a [ i ] > max ) :\n            max = a [ i ]\n    return max\ndef smallest_alphabet ( a , n ) :\n    min = 'z' ;\n    for i in range ( n - 1 ) :\n        if ( a [ i ] < min ) :\n            min = a [ i ]\n    return min\nif __name__ == '__main__' :\n    a = \"GeEksforGeeks\"\n    size = len ( a )\n    print ( \"Largest and smallest alphabet is : \" , end = \"\" )\n    print ( largest_alphabet ( a , size ) , end = \" and \" )\n    print ( smallest_alphabet ( a , size ) )\n", "python_code_tokenized": "def largest_alphabet ( a , n ) : NEW_LINE INDENT max = ' A ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > max ) : NEW_LINE INDENT max = a [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT def smallest_alphabet ( a , n ) : NEW_LINE INDENT min = ' z ' ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] < min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \" GeEksforGeeks \" NEW_LINE size = len ( a ) NEW_LINE print ( \" Largest \u2581 and \u2581 smallest \u2581 alphabet \u2581 is \u2581 : \u2581 \" , end = \" \" ) NEW_LINE print ( largest_alphabet ( a , size ) , end = \" \u2581 and \u2581 \" ) NEW_LINE print ( smallest_alphabet ( a , size ) ) NEW_LINE DEDENT"}
{"id": "codejam_09_22", "sol": 0, "python_code": "from sys import stdin\nfrom sys import stdout\ndef find_least ( s , p , x ) :\n    m = None\n    b = len ( s )\n    for i in xrange ( p , len ( s ) ) :\n        if s [ i ] > x and ( m is None or s [ i ] < m ) :\n            m = s [ i ]\n            b = i\n    return b\ndef next_number ( N ) :\n    for i in xrange ( len ( N ) - 1 , 0 , - 1 ) :\n        if N [ i - 1 ] < N [ i ] :\n            K = N [ : i - 1 ]\n            p = find_least ( N , i , N [ i - 1 ] )\n            d = N [ p ]\n            s = list ( N [ i - 1 : p ] + N [ p + 1 : ] )\n            s.sort ( )\n            K += d + ''.join ( s )\n            break\n    else :\n        p = find_least ( N , 0 , '0' )\n        d = N [ p ]\n        s = list ( N [ : p ] + N [ p + 1 : ] )\n        s.sort ( )\n        K = d + '0' + ''.join ( s )\n    return K\nT = int ( stdin.readline ( ).strip ( ) )\nfor X in xrange ( 1 , T + 1 ) :\n    N = stdin.readline ( ).strip ( )\n    K = next_number ( N )\n    stdout.write ( 'Case #%d: %s\\n' % ( X , K ) )\n", "python_code_tokenized": "from sys import stdin NEW_LINE from sys import stdout NEW_LINE def find_least ( s , p , x ) : NEW_LINE INDENT m = None NEW_LINE b = len ( s ) NEW_LINE for i in xrange ( p , len ( s ) ) : NEW_LINE INDENT if s [ i ] > x and ( m is None or s [ i ] < m ) : NEW_LINE INDENT m = s [ i ] NEW_LINE b = i NEW_LINE DEDENT DEDENT return b NEW_LINE DEDENT def next_number ( N ) : NEW_LINE INDENT for i in xrange ( len ( N ) - 1 , 0 , - 1 ) : NEW_LINE INDENT if N [ i - 1 ] < N [ i ] : NEW_LINE INDENT K = N [ : i - 1 ] NEW_LINE p = find_least ( N , i , N [ i - 1 ] ) NEW_LINE d = N [ p ] NEW_LINE s = list ( N [ i - 1 : p ] + N [ p + 1 : ] ) NEW_LINE s . sort ( ) NEW_LINE K += d + ' ' . join ( s ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT p = find_least ( N , 0 , '0' ) NEW_LINE d = N [ p ] NEW_LINE s = list ( N [ : p ] + N [ p + 1 : ] ) NEW_LINE s . sort ( ) NEW_LINE K = d + '0' + ' ' . join ( s ) NEW_LINE DEDENT return K NEW_LINE DEDENT T = int ( stdin . readline ( ) . strip ( ) ) NEW_LINE for X in xrange ( 1 , T + 1 ) : NEW_LINE INDENT N = stdin . readline ( ) . strip ( ) NEW_LINE K = next_number ( N ) NEW_LINE stdout . write ( ' Case \u2581 # % d : \u2581 % s \\n ' % ( X , K ) ) NEW_LINE DEDENT"}
{"id": "codeforces_135_A", "sol": 0, "python_code": "input ( )\na = sorted ( list ( map ( int , input ( ).split ( ) ) ) )\na [ - 1 ] = [ 1 , 2 ] [ a [ - 1 ] == 1 ]\nprint ( * ( sorted ( a ) ) )\n", "python_code_tokenized": "input ( ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE a [ - 1 ] = [ 1 , 2 ] [ a [ - 1 ] == 1 ] NEW_LINE print ( * ( sorted ( a ) ) ) NEW_LINE"}
{"id": "atcoder_ABC064_D", "sol": 0, "python_code": "import bisect\nimport collections\nimport itertools\ndef getint ( ) : return int ( input ( ) )\ndef getints ( ) : return list ( map ( int , input ( ).split ( ) ) )\ndef getint2d ( rows ) : return [ getints ( ) for _ in range ( rows ) ]\ndef getgrid ( rows ) : return [ input ( ) for _ in range ( rows ) ]\ndef array1d ( n , value ) : return [ value for _ in range ( n ) ]\ndef array2d ( n , m , value ) : return [ array1d ( m , value ) for _ in range ( n ) ]\nn = input ( )\ns = input ( )\nl , r = 0 , 0\nfor c in s :\n    if c == '(' :\n        r += 1\n    else :\n        if r :\n            r -= 1\n        else :\n            l += 1\nres = \"(\" * l + s + \")\" * r\nprint ( res )\n", "python_code_tokenized": "import bisect NEW_LINE import collections NEW_LINE import itertools NEW_LINE def getint ( ) : return int ( input ( ) ) NEW_LINE def getints ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def getint2d ( rows ) : return [ getints ( ) for _ in range ( rows ) ] NEW_LINE def getgrid ( rows ) : return [ input ( ) for _ in range ( rows ) ] NEW_LINE def array1d ( n , value ) : return [ value for _ in range ( n ) ] NEW_LINE def array2d ( n , m , value ) : return [ array1d ( m , value ) for _ in range ( n ) ] NEW_LINE n = input ( ) NEW_LINE s = input ( ) NEW_LINE l , r = 0 , 0 NEW_LINE for c in s : NEW_LINE INDENT if c == ' ( ' : NEW_LINE INDENT r += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if r : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT res = \" ( \" * l + s + \" ) \" * r NEW_LINE print ( res ) NEW_LINE"}
{"id": "codeforces_287_A", "sol": 0, "python_code": "arr = [ input ( ) , input ( ) , input ( ) , input ( ) ]\nexit = False\nfor i in range ( 3 ) :\n    if exit :\n        break\n    for j in range ( 3 ) :\n        countw = 0\n        countb = 0\n        if arr [ i ] [ j ] == \"#\" :\n            countb += 1\n        else :\n            countw += 1\n        if arr [ i + 1 ] [ j ] == \"#\" :\n            countb += 1\n        else :\n            countw += 1\n        if arr [ i ] [ j + 1 ] == \"#\" :\n            countb += 1\n        else :\n            countw += 1\n        if arr [ i + 1 ] [ j + 1 ] == \"#\" :\n            countb += 1\n        else :\n            countw += 1\n        if countw >= 3 or countb >= 3 :\n            print ( \"YES\" )\n            exit = True\n            break\nif not exit :\n    print ( \"NO\" )\n", "python_code_tokenized": "arr = [ input ( ) , input ( ) , input ( ) , input ( ) ] NEW_LINE exit = False NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if exit : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( 3 ) : NEW_LINE INDENT countw = 0 NEW_LINE countb = 0 NEW_LINE if arr [ i ] [ j ] == \" # \" : NEW_LINE INDENT countb += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countw += 1 NEW_LINE DEDENT if arr [ i + 1 ] [ j ] == \" # \" : NEW_LINE INDENT countb += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countw += 1 NEW_LINE DEDENT if arr [ i ] [ j + 1 ] == \" # \" : NEW_LINE INDENT countb += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countw += 1 NEW_LINE DEDENT if arr [ i + 1 ] [ j + 1 ] == \" # \" : NEW_LINE INDENT countb += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countw += 1 NEW_LINE DEDENT if countw >= 3 or countb >= 3 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE exit = True NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if not exit : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "leetcode_367_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def isPerfectSquare ( self , num ) :\n        low , high = 1 , num\n        while low <= high :\n            mid = ( low + high ) / 2\n            mid_square = mid * mid\n            if mid_square == num :\n                return True\n            elif mid_square < num :\n                low = mid + 1\n            else :\n                high = mid - 1\n        return False\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def isPerfectSquare ( self , num ) : NEW_LINE INDENT low , high = 1 , num NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) / 2 NEW_LINE mid_square = mid * mid NEW_LINE if mid_square == num : NEW_LINE INDENT return True NEW_LINE DEDENT elif mid_square < num : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00027_A", "sol": 0, "python_code": "days = [ 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ]\nans = [ \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" , \"Sunday\" ]\nwhile True :\n    idx = 3\n    m , d = map ( int , input ( ).split ( ) )\n    if m == 0 : break\n    print ( ans [ ( idx + sum ( days [ : m - 1 ] ) + d - 1 ) % 7 ] )\n", "python_code_tokenized": "days = [ 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE ans = [ \" Monday \" , \" Tuesday \" , \" Wednesday \" , \" Thursday \" , \" Friday \" , \" Saturday \" , \" Sunday \" ] NEW_LINE while True : NEW_LINE INDENT idx = 3 NEW_LINE m , d = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : break NEW_LINE print ( ans [ ( idx + sum ( days [ : m - 1 ] ) + d - 1 ) % 7 ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_179_A", "sol": 0, "python_code": "def even_or_odd ( N ) :\n    l = len ( N )\n    if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' or N [ l - 1 ] == '8' or N [ l - 1 ] == 'A' or N [ l - 1 ] == 'C' or N [ l - 1 ] == 'E' ) :\n        return ( \"Even\" )\n    else :\n        return ( \"Odd\" )\nN = \"AB3454D\"\nprint ( even_or_odd ( N ) )\n", "python_code_tokenized": "def even_or_odd ( N ) : NEW_LINE INDENT l = len ( N ) NEW_LINE if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' or N [ l - 1 ] == '8' or N [ l - 1 ] == ' A ' or N [ l - 1 ] == ' C ' or N [ l - 1 ] == ' E ' ) : NEW_LINE INDENT return ( \" Even \" ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( \" Odd \" ) NEW_LINE DEDENT DEDENT N = \" AB3454D \" NEW_LINE print ( even_or_odd ( N ) ) NEW_LINE"}
{"id": "aizu_p00145_A", "sol": 0, "python_code": "INF = 10 ** 20\nn = int ( input ( ) )\ntop = [ ]\nbottom = [ ]\nfor _ in range ( n ) :\n    a , b = map ( int , input ( ).split ( ) )\n    top.append ( a )\n    bottom.append ( b )\ndp = [ [ INF ] * ( n + 1 ) for _ in range ( n + 1 ) ]\nfor j in range ( n ) :\n    dp [ 0 ] [ j ] = 0\nfor i in range ( 1 , n ) :\n    for j in range ( n - i ) :\n        dp [ i ] [ j ] = min ( dp [ k ] [ j ] + dp [ i - k - 1 ] [ j + k + 1 ] + top [ j ] * bottom [ j + k ] * top [ j + k + 1 ] * bottom [ j + i ] for k in range ( i ) )\nprint ( dp [ n - 1 ] [ 0 ] )\n", "python_code_tokenized": "INF = 10 ** 20 NEW_LINE n = int ( input ( ) ) NEW_LINE top = [ ] NEW_LINE bottom = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE top . append ( a ) NEW_LINE bottom . append ( b ) NEW_LINE DEDENT dp = [ [ INF ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ j ] = 0 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n - i ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ k ] [ j ] + dp [ i - k - 1 ] [ j + k + 1 ] + top [ j ] * bottom [ j + k ] * top [ j + k + 1 ] * bottom [ j + i ] for k in range ( i ) ) NEW_LINE DEDENT DEDENT print ( dp [ n - 1 ] [ 0 ] ) NEW_LINE"}
{"id": "codeforces_1426_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    n , m = map ( int , input ( ).split ( ) )\n    f = False\n    for _ in range ( n ) :\n        a , b = map ( int , input ( ).split ( ) )\n        c , d = map ( int , input ( ).split ( ) )\n        if b == c :\n            f = True\n    if m & 1 :\n        print ( \"NO\" )\n    else :\n        print ( \"YES\" if f else \"NO\" )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE f = False NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if b == c : NEW_LINE INDENT f = True NEW_LINE DEDENT DEDENT if m & 1 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" if f else \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p02380_A", "sol": 0, "python_code": "import math\na , b , c = [ float ( i ) for i in input ( ).split ( ) ]\nc = math.radians ( c )\nh = math.sin ( c ) * b\ns = a * h / 2\nq = math.sqrt ( pow ( a , 2 ) + pow ( b , 2 ) - 2 * a * b * math.cos ( c ) )\nl = a + b + q\nprint ( s )\nprint ( l )\nprint ( h )\n", "python_code_tokenized": "import math NEW_LINE a , b , c = [ float ( i ) for i in input ( ) . split ( ) ] NEW_LINE c = math . radians ( c ) NEW_LINE h = math . sin ( c ) * b NEW_LINE s = a * h / 2 NEW_LINE q = math . sqrt ( pow ( a , 2 ) + pow ( b , 2 ) - 2 * a * b * math . cos ( c ) ) NEW_LINE l = a + b + q NEW_LINE print ( s ) NEW_LINE print ( l ) NEW_LINE print ( h ) NEW_LINE"}
{"id": "geeksforgeeks_3334_A", "sol": 0, "python_code": "def minOperations ( n , a , b , c ) :\n    ans = 0\n    for i in range ( n ) :\n        x = a [ i ]\n        y = b [ i ]\n        z = c [ i ]\n        if ( x == y and y == z ) :\n            continue\n        elif ( x == y or y == z or x == z ) :\n            ans += 1\n        else :\n            ans += 2\n    return ans\nif __name__ == '__main__' :\n    a = \"place\"\n    b = \"abcde\"\n    c = \"plybe\"\n    n = len ( a )\n    print ( minOperations ( n , a , b , c ) )\n", "python_code_tokenized": "def minOperations ( n , a , b , c ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE y = b [ i ] NEW_LINE z = c [ i ] NEW_LINE if ( x == y and y == z ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( x == y or y == z or x == z ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \" place \" NEW_LINE b = \" abcde \" NEW_LINE c = \" plybe \" NEW_LINE n = len ( a ) NEW_LINE print ( minOperations ( n , a , b , c ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC098_A", "sol": 0, "python_code": "def main ( ) :\n    A , B = map ( int , input ( ).split ( ) )\n    print ( max ( A + B , A - B , A * B ) )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( A + B , A - B , A * B ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_710_B", "sol": 0, "python_code": "import sys\nfrom os import path\nif path.exists ( 'input.txt' ) :\n    sys.stdin = open ( 'input.txt' , 'r' )\n    sys.stdout = open ( 'output.txt' , 'w' )\nn = int ( input ( ) )\nprint ( sorted ( map ( int , input ( ).split ( ) ) ) [ ( n - 1 ) // 2 ] )\n", "python_code_tokenized": "import sys NEW_LINE from os import path NEW_LINE if path . exists ( ' input . txt ' ) : NEW_LINE INDENT sys . stdin = open ( ' input . txt ' , ' r ' ) NEW_LINE sys . stdout = open ( ' output . txt ' , ' w ' ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE print ( sorted ( map ( int , input ( ) . split ( ) ) ) [ ( n - 1 ) // 2 ] ) NEW_LINE"}
{"id": "geeksforgeeks_3361_A", "sol": 0, "python_code": "def countMinimalReplacements ( s ) :\n    n = len ( s )\n    cnt = 0\n    for i in range ( 1 , n ) :\n        if ( s [ i ] == s [ i - 1 ] ) :\n            cnt += 1 ;\n            if ( i != ( n - 1 ) ) :\n                s = list ( s )\n                for j in \"012\" :\n                    if ( j != s [ i + 1 ] and j != s [ i - 1 ] ) :\n                        s [ i ] = j\n                        break\n                s = ''.join ( s )\n            else :\n                s = list ( s )\n                for k in \"012\" :\n                    if ( k != s [ i - 1 ] ) :\n                        s [ i ] = k\n                        break\n                s = ''.join ( s )\n    return cnt\nif __name__ == '__main__' :\n    s = \"201220211\"\n    print ( countMinimalReplacements ( s ) )\n", "python_code_tokenized": "def countMinimalReplacements ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE if ( i != ( n - 1 ) ) : NEW_LINE INDENT s = list ( s ) NEW_LINE for j in \"012\" : NEW_LINE INDENT if ( j != s [ i + 1 ] and j != s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] = j NEW_LINE break NEW_LINE DEDENT DEDENT s = ' ' . join ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT s = list ( s ) NEW_LINE for k in \"012\" : NEW_LINE INDENT if ( k != s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] = k NEW_LINE break NEW_LINE DEDENT DEDENT s = ' ' . join ( s ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"201220211\" NEW_LINE print ( countMinimalReplacements ( s ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4430_A", "sol": 0, "python_code": "def findMinAvgSubarray ( arr , n , k ) :\n    if ( n < k ) : return 0\n    res_index = 0\n    curr_sum = 0\n    for i in range ( k ) :\n        curr_sum += arr [ i ]\n    min_sum = curr_sum\n    for i in range ( k , n ) :\n        curr_sum += arr [ i ] - arr [ i - k ]\n        if ( curr_sum < min_sum ) :\n            min_sum = curr_sum\n            res_index = ( i - k + 1 )\n    print ( \"Subarray between [\" , res_index , \", \" , ( res_index + k - 1 ) , \"] has minimum average\" )\narr = [ 3 , 7 , 90 , 20 , 10 , 50 , 40 ]\nk = 3\nn = len ( arr )\nfindMinAvgSubarray ( arr , n , k )\n", "python_code_tokenized": "def findMinAvgSubarray ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : return 0 NEW_LINE res_index = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT min_sum = curr_sum NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum += arr [ i ] - arr [ i - k ] NEW_LINE if ( curr_sum < min_sum ) : NEW_LINE INDENT min_sum = curr_sum NEW_LINE res_index = ( i - k + 1 ) NEW_LINE DEDENT DEDENT print ( \" Subarray \u2581 between \u2581 [ \" , res_index , \" , \u2581 \" , ( res_index + k - 1 ) , \" ] \u2581 has \u2581 minimum \u2581 average \" ) NEW_LINE DEDENT arr = [ 3 , 7 , 90 , 20 , 10 , 50 , 40 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE findMinAvgSubarray ( arr , n , k ) NEW_LINE"}
{"id": "geeksforgeeks_4992_A", "sol": 0, "python_code": "from math import sqrt , floor\ndef isPerfectSquare ( x ) :\n    sr = sqrt ( x )\n    return ( ( sr - floor ( sr ) ) == 0 )\ndef isFibonacci ( n ) :\n    return ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) )\ndef totalPairs ( a , b , n , m ) :\n    s = set ( ) ;\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if ( isFibonacci ( a [ i ] + b [ j ] ) == True ) :\n                if ( a [ i ] < b [ j ] ) :\n                    s.add ( ( a [ i ] , b [ j ] ) ) ;\n                else :\n                    s.add ( ( b [ j ] , a [ i ] ) ) ;\n    return len ( s ) ;\nif __name__ == \"__main__\" :\n    a = [ 99 , 1 , 33 , 2 ] ;\n    b = [ 1 , 11 , 2 ] ;\n    n = len ( a ) ;\n    m = len ( b ) ;\n    print ( totalPairs ( a , b , n , m ) ) ;\n", "python_code_tokenized": "from math import sqrt , floor NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isFibonacci ( n ) : NEW_LINE INDENT return ( isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) ) NEW_LINE DEDENT def totalPairs ( a , b , n , m ) : NEW_LINE INDENT s = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( isFibonacci ( a [ i ] + b [ j ] ) == True ) : NEW_LINE INDENT if ( a [ i ] < b [ j ] ) : NEW_LINE INDENT s . add ( ( a [ i ] , b [ j ] ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( ( b [ j ] , a [ i ] ) ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( s ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 99 , 1 , 33 , 2 ] ; NEW_LINE b = [ 1 , 11 , 2 ] ; NEW_LINE n = len ( a ) ; NEW_LINE m = len ( b ) ; NEW_LINE print ( totalPairs ( a , b , n , m ) ) ; NEW_LINE DEDENT"}
{"id": "projecteuler_p206_A", "sol": 0, "python_code": "def compute ( ) :\n    n = 1000000000\n    ndigits = [ 0 ] * 10\n    temp = n\n    for i in range ( len ( ndigits ) ) :\n        ndigits [ i ] = temp % 10\n        temp //= 10\n    n2digits = [ 0 ] * 19\n    temp = n * n\n    for i in range ( len ( n2digits ) ) :\n        n2digits [ i ] = temp % 10\n        temp //= 10\n    while not is_concealed_square ( n2digits ) :\n        add_20n ( ndigits , n2digits )\n        add_10pow ( n2digits , 2 )\n        n += 10\n        add_10pow ( ndigits , 1 )\n    return str ( n )\ndef is_concealed_square ( n ) :\n    for i in range ( 1 , 10 ) :\n        if n [ 20 - i * 2 ] != i :\n            return False\n    return n [ 0 ] == 0\ndef add_10pow ( n , i ) :\n    while n [ i ] == 9 :\n        n [ i ] = 0\n        i += 1\n    n [ i ] += 1\ndef add_20n ( n , n2 ) :\n    carry = 0\n    i = 0\n    while i < len ( n ) :\n        sum = n [ i ] * 2 + n2 [ i + 1 ] + carry\n        n2 [ i + 1 ] = sum % 10\n        carry = sum // 10\n        i += 1\n    i += 1\n    while carry > 0 :\n        sum = n2 [ i ] + carry\n        n2 [ i ] = sum % 10\n        carry = sum // 10\n        i += 1\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT n = 1000000000 NEW_LINE ndigits = [ 0 ] * 10 NEW_LINE temp = n NEW_LINE for i in range ( len ( ndigits ) ) : NEW_LINE INDENT ndigits [ i ] = temp % 10 NEW_LINE temp //= 10 NEW_LINE DEDENT n2digits = [ 0 ] * 19 NEW_LINE temp = n * n NEW_LINE for i in range ( len ( n2digits ) ) : NEW_LINE INDENT n2digits [ i ] = temp % 10 NEW_LINE temp //= 10 NEW_LINE DEDENT while not is_concealed_square ( n2digits ) : NEW_LINE INDENT add_20n ( ndigits , n2digits ) NEW_LINE add_10pow ( n2digits , 2 ) NEW_LINE n += 10 NEW_LINE add_10pow ( ndigits , 1 ) NEW_LINE DEDENT return str ( n ) NEW_LINE DEDENT def is_concealed_square ( n ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if n [ 20 - i * 2 ] != i : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return n [ 0 ] == 0 NEW_LINE DEDENT def add_10pow ( n , i ) : NEW_LINE INDENT while n [ i ] == 9 : NEW_LINE INDENT n [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT n [ i ] += 1 NEW_LINE DEDENT def add_20n ( n , n2 ) : NEW_LINE INDENT carry = 0 NEW_LINE i = 0 NEW_LINE while i < len ( n ) : NEW_LINE INDENT sum = n [ i ] * 2 + n2 [ i + 1 ] + carry NEW_LINE n2 [ i + 1 ] = sum % 10 NEW_LINE carry = sum // 10 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE while carry > 0 : NEW_LINE INDENT sum = n2 [ i ] + carry NEW_LINE n2 [ i ] = sum % 10 NEW_LINE carry = sum // 10 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_107_A", "sol": 0, "python_code": "inf = 2 * ( 10 ** 9 )\nres = [ ]\nIn = [ 0 ] * 1001\nout = [ 0 ] * 1001\nf = [ 0 ] * 1001\ns = input ( ).split ( )\nn = int ( s [ 0 ] )\nm = int ( s [ 1 ] )\nu , v , d = ( 0 , ) * 3\nfor i in range ( 1001 ) :\n    In [ i ] , out [ i ] , f [ i ] = ( - 1 , ) * 3\nfor i in range ( m ) :\n    s = input ( ).split ( )\n    u , v , d = int ( s [ 0 ] ) , int ( s [ 1 ] ) , int ( s [ 2 ] )\n    f [ u ] , In [ v ] , out [ u ] = d , u , v\nfor i in range ( 1 , n + 1 ) :\n    if ( In [ i ] == - 1 ) :\n        u , v , w , cnt , c = i , 0 , inf , 0 , 0\n        while ( out [ u ] != - 1 ) :\n            cnt += 1\n            if ( cnt > n - 1 ) :\n                c = 1\n                break\n            v = out [ u ]\n            w = min ( w , f [ u ] )\n            u = v\n        if ( c or ( w == inf ) ) :\n            continue\n        res.append ( [ i , v , w ] )\nprint ( len ( res ) , end = '\\n' )\nfor i in range ( len ( res ) ) :\n    print ( res [ i ] [ 0 ] , res [ i ] [ 1 ] , res [ i ] [ 2 ] , sep = ' ' )\n", "python_code_tokenized": "inf = 2 * ( 10 ** 9 ) NEW_LINE res = [ ] NEW_LINE In = [ 0 ] * 1001 NEW_LINE out = [ 0 ] * 1001 NEW_LINE f = [ 0 ] * 1001 NEW_LINE s = input ( ) . split ( ) NEW_LINE n = int ( s [ 0 ] ) NEW_LINE m = int ( s [ 1 ] ) NEW_LINE u , v , d = ( 0 , ) * 3 NEW_LINE for i in range ( 1001 ) : NEW_LINE INDENT In [ i ] , out [ i ] , f [ i ] = ( - 1 , ) * 3 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT s = input ( ) . split ( ) NEW_LINE u , v , d = int ( s [ 0 ] ) , int ( s [ 1 ] ) , int ( s [ 2 ] ) NEW_LINE f [ u ] , In [ v ] , out [ u ] = d , u , v NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( In [ i ] == - 1 ) : NEW_LINE INDENT u , v , w , cnt , c = i , 0 , inf , 0 , 0 NEW_LINE while ( out [ u ] != - 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE if ( cnt > n - 1 ) : NEW_LINE INDENT c = 1 NEW_LINE break NEW_LINE DEDENT v = out [ u ] NEW_LINE w = min ( w , f [ u ] ) NEW_LINE u = v NEW_LINE DEDENT if ( c or ( w == inf ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT res . append ( [ i , v , w ] ) NEW_LINE DEDENT DEDENT print ( len ( res ) , end = ' \\n ' ) NEW_LINE for i in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ i ] [ 0 ] , res [ i ] [ 1 ] , res [ i ] [ 2 ] , sep = ' \u2581 ' ) NEW_LINE DEDENT"}
{"id": "leetcode_238_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def productExceptSelf ( self , nums ) :\n        ans = [ 1 ] * len ( nums )\n        for i in range ( 1 , len ( nums ) ) :\n            ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ]\n        right = 1\n        for i in range ( len ( nums ) - 1 , - 1 , - 1 ) :\n            ans [ i ] *= right\n            right *= nums [ i ]\n        return ans\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def productExceptSelf ( self , nums ) : NEW_LINE INDENT ans = [ 1 ] * len ( nums ) NEW_LINE for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ] NEW_LINE DEDENT right = 1 NEW_LINE for i in range ( len ( nums ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans [ i ] *= right NEW_LINE right *= nums [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1437_A", "sol": 0, "python_code": "def makeOdd ( n ) :\n    if n % 2 != 0 :\n        return 1 ;\n    for i in range ( 2 , n ) :\n        if ( n % i == 0 and ( int ) ( n / i ) % 2 == 1 ) :\n            return i ;\nn = 36 ;\nprint ( makeOdd ( n ) ) ;\n", "python_code_tokenized": "def makeOdd ( n ) : NEW_LINE INDENT if n % 2 != 0 : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 and ( int ) ( n / i ) % 2 == 1 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT DEDENT n = 36 ; NEW_LINE print ( makeOdd ( n ) ) ; NEW_LINE"}
{"id": "atcoder_ABC066_B", "sol": 0, "python_code": "s = list ( input ( ) )\ndel s [ - 1 ]\nfor i in range ( 1 , len ( s ) ) :\n    if len ( s ) % 2 == 1 :\n        del s [ - 1 ]\n    else :\n        if s [ : int ( len ( s ) / 2 ) ] == s [ int ( len ( s ) / 2 ) : ] :\n            print ( len ( s ) )\n            exit ( )\n        else :\n            del s [ - 1 ]\n", "python_code_tokenized": "s = list ( input ( ) ) NEW_LINE del s [ - 1 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if len ( s ) % 2 == 1 : NEW_LINE INDENT del s [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if s [ : int ( len ( s ) / 2 ) ] == s [ int ( len ( s ) / 2 ) : ] : NEW_LINE INDENT print ( len ( s ) ) NEW_LINE exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT del s [ - 1 ] NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "codeforces_496_B", "sol": 0, "python_code": "import collections\nimport heapq\nimport sys\nimport math\nimport itertools\nimport bisect\nfrom io import BytesIO , IOBase\nimport os\ndef value ( ) : return tuple ( map ( int , input ( ).split ( ) ) )\ndef values ( ) : return tuple ( map ( int , sys.stdin.readline ( ).split ( ) ) )\ndef inlst ( ) : return [ int ( i ) for i in input ( ).split ( ) ]\ndef inlsts ( ) : return [ int ( i ) for i in sys.stdin.readline ( ).split ( ) ]\ndef inp ( ) : return int ( input ( ) )\ndef inps ( ) : return int ( sys.stdin.readline ( ) )\ndef instr ( ) : return input ( )\ndef stlst ( ) : return [ i for i in input ( ).split ( ) ]\ndef solve ( ) :\n    n = inp ( )\n    nums = list ( input ( ) )\n    mn = float ( 'inf' )\n    for j in range ( n ) :\n        num = nums.copy ( )\n        num = num [ j : ] + num [ : j ]\n        for i in range ( n ) :\n            num [ i ] = str ( ( int ( num [ i ] ) - int ( nums [ j ] ) + 10 ) % 10 )\n        mn = min ( mn , int ( \"\".join ( num ) ) )\n    print ( str ( mn ).zfill ( n ) )\nif __name__ == \"__main__\" :\n    solve ( )\n", "python_code_tokenized": "import collections NEW_LINE import heapq NEW_LINE import sys NEW_LINE import math NEW_LINE import itertools NEW_LINE import bisect NEW_LINE from io import BytesIO , IOBase NEW_LINE import os NEW_LINE def value ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def values ( ) : return tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def inlst ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE def inlsts ( ) : return [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def inp ( ) : return int ( input ( ) ) NEW_LINE def inps ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def instr ( ) : return input ( ) NEW_LINE def stlst ( ) : return [ i for i in input ( ) . split ( ) ] NEW_LINE def solve ( ) : NEW_LINE INDENT n = inp ( ) NEW_LINE nums = list ( input ( ) ) NEW_LINE mn = float ( ' inf ' ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT num = nums . copy ( ) NEW_LINE num = num [ j : ] + num [ : j ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num [ i ] = str ( ( int ( num [ i ] ) - int ( nums [ j ] ) + 10 ) % 10 ) NEW_LINE DEDENT mn = min ( mn , int ( \" \" . join ( num ) ) ) NEW_LINE DEDENT print ( str ( mn ) . zfill ( n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2549_A", "sol": 0, "python_code": "def digit_product_Sum ( N ) :\n    a = [ 0 ] * ( N + 1 ) ;\n    product = 1 ;\n    a [ 0 ] = 1 ;\n    for i in range ( 1 , N + 1 ) :\n        product = int ( a [ i - 1 ] / 10 ) ;\n        if ( product == 0 ) :\n            product = 1 ;\n        else :\n            product = a [ i - 1 ] % 10 ;\n        val = int ( a [ i - 1 ] / 10 ) ;\n        if ( val == 0 ) :\n            val = a [ i - 1 ] ;\n        a [ i ] = a [ i - 1 ] + ( val * product ) ;\n    for i in range ( N ) :\n        print ( a [ i ] , end = \" \" ) ;\nN = 10 ;\ndigit_product_Sum ( N ) ;\n", "python_code_tokenized": "def digit_product_Sum ( N ) : NEW_LINE INDENT a = [ 0 ] * ( N + 1 ) ; NEW_LINE product = 1 ; NEW_LINE a [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = int ( a [ i - 1 ] / 10 ) ; NEW_LINE if ( product == 0 ) : NEW_LINE INDENT product = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT product = a [ i - 1 ] % 10 ; NEW_LINE DEDENT val = int ( a [ i - 1 ] / 10 ) ; NEW_LINE if ( val == 0 ) : NEW_LINE INDENT val = a [ i - 1 ] ; NEW_LINE DEDENT a [ i ] = a [ i - 1 ] + ( val * product ) ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT N = 10 ; NEW_LINE digit_product_Sum ( N ) ; NEW_LINE"}
{"id": "codeforces_577_B", "sol": 0, "python_code": "l = lambda : map ( int , input ( ).split ( ) )\nn , k = l ( ) ; a = set ( )\nfor i in l ( ) :\n    b = set ( ( ( i + j ) % k ) for j in a ) ; a |= b ; a.add ( i % k )\n    if 0 in a : print ( \"YES\" ) ; exit ( )\nprint ( \"NO\" )\n", "python_code_tokenized": "l = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE n , k = l ( ) ; a = set ( ) NEW_LINE for i in l ( ) : NEW_LINE INDENT b = set ( ( ( i + j ) % k ) for j in a ) ; a |= b ; a . add ( i % k ) NEW_LINE if 0 in a : print ( \" YES \" ) ; exit ( ) NEW_LINE DEDENT print ( \" NO \" ) NEW_LINE"}
{"id": "atcoder_AGC007_C", "sol": 0, "python_code": "from decimal import Decimal , getcontext\ngetcontext ( ).prec = 200\nn , d , x = map ( Decimal , input ( ).split ( ) )\nans = 0\nfor i in range ( 1 , int ( n ) + 1 ) :\n    i = Decimal ( str ( i ) )\n    ans += Decimal ( str ( ( int ( n ) - int ( i ) + 1 ) ) ) / Decimal ( str ( i ) ) * ( d + x * Decimal ( str ( int ( n ) * 2 - 1 ) ) / Decimal ( \"2\" ) )\nprint ( ans )\n", "python_code_tokenized": "from decimal import Decimal , getcontext NEW_LINE getcontext ( ) . prec = 200 NEW_LINE n , d , x = map ( Decimal , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , int ( n ) + 1 ) : NEW_LINE INDENT i = Decimal ( str ( i ) ) NEW_LINE ans += Decimal ( str ( ( int ( n ) - int ( i ) + 1 ) ) ) / Decimal ( str ( i ) ) * ( d + x * Decimal ( str ( int ( n ) * 2 - 1 ) ) / Decimal ( \"2\" ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_1300_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    l = sorted ( map ( int , input ( ).split ( ) ) )\n    print ( l [ n ] - l [ n - 1 ] )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( l [ n ] - l [ n - 1 ] ) NEW_LINE DEDENT"}
{"id": "codeforces_5_B", "sol": 0, "python_code": "import sys\na = [ ]\nmx = 0\nwhile True :\n    try :\n        i = input ( )\n        start = 0\n        end = len ( i ) - 1\n        while i and i [ start ] == '' :\n            start += 1\n        while i and i [ end ] == '' :\n            end -= 1\n        mx = max ( mx , end - start + 1 )\n        a.append ( i [ start : end + 1 ] )\n    except :\n        break\nprint ( '*' * ( mx + 2 ) )\nc = 0\nfor i in a :\n    print ( '*' , end = '' )\n    if ( mx - len ( i ) ) % 2 == 0 :\n        print ( '' * ( ( mx - len ( i ) ) // 2 ) , end = '' )\n        print ( i , end = '' )\n        print ( '' * ( ( mx - len ( i ) ) // 2 ) , end = '' )\n    elif ( mx - len ( i ) ) % 2 != 0 and c % 2 == 0 :\n        print ( '' * ( ( mx - len ( i ) ) // 2 ) , end = '' )\n        print ( i , end = '' )\n        print ( '' * ( ( ( mx - len ( i ) ) - ( ( mx - len ( i ) ) // 2 ) ) ) , end = '' )\n        c += 1\n    elif ( mx - len ( i ) ) % 2 != 0 and c % 2 == 1 :\n        print ( '' * ( ( ( mx - len ( i ) ) - ( ( mx - len ( i ) ) // 2 ) ) ) , end = '' )\n        print ( i , end = '' )\n        print ( '' * ( ( mx - len ( i ) ) // 2 ) , end = '' )\n        c += 1\n    print ( '*' )\nprint ( '*' * ( mx + 2 ) )\n", "python_code_tokenized": "import sys NEW_LINE a = [ ] NEW_LINE mx = 0 NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT i = input ( ) NEW_LINE start = 0 NEW_LINE end = len ( i ) - 1 NEW_LINE while i and i [ start ] == ' \u2581 ' : NEW_LINE INDENT start += 1 NEW_LINE DEDENT while i and i [ end ] == ' \u2581 ' : NEW_LINE INDENT end -= 1 NEW_LINE DEDENT mx = max ( mx , end - start + 1 ) NEW_LINE a . append ( i [ start : end + 1 ] ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ' * ' * ( mx + 2 ) ) NEW_LINE c = 0 NEW_LINE for i in a : NEW_LINE INDENT print ( ' * ' , end = ' ' ) NEW_LINE if ( mx - len ( i ) ) % 2 == 0 : NEW_LINE INDENT print ( ' \u2581 ' * ( ( mx - len ( i ) ) // 2 ) , end = ' ' ) NEW_LINE print ( i , end = ' ' ) NEW_LINE print ( ' \u2581 ' * ( ( mx - len ( i ) ) // 2 ) , end = ' ' ) NEW_LINE DEDENT elif ( mx - len ( i ) ) % 2 != 0 and c % 2 == 0 : NEW_LINE INDENT print ( ' \u2581 ' * ( ( mx - len ( i ) ) // 2 ) , end = ' ' ) NEW_LINE print ( i , end = ' ' ) NEW_LINE print ( ' \u2581 ' * ( ( ( mx - len ( i ) ) - ( ( mx - len ( i ) ) // 2 ) ) ) , end = ' ' ) NEW_LINE c += 1 NEW_LINE DEDENT elif ( mx - len ( i ) ) % 2 != 0 and c % 2 == 1 : NEW_LINE INDENT print ( ' \u2581 ' * ( ( ( mx - len ( i ) ) - ( ( mx - len ( i ) ) // 2 ) ) ) , end = ' ' ) NEW_LINE print ( i , end = ' ' ) NEW_LINE print ( ' \u2581 ' * ( ( mx - len ( i ) ) // 2 ) , end = ' ' ) NEW_LINE c += 1 NEW_LINE DEDENT print ( ' * ' ) NEW_LINE DEDENT print ( ' * ' * ( mx + 2 ) ) NEW_LINE"}
{"id": "aizu_p02383_A", "sol": 0, "python_code": "class Dice :\n    def __init__ ( self , eyes ) :\n        self._eyes = [ 'dummy' ] + eyes\n    @ property\n    def eye ( self ) :\n        return self._eyes [ 1 ]\n    def roll ( self , direction ) :\n        a = self._eyes\n        if direction == 'N' :\n            self._eyes = [ 'dummy' , a [ 2 ] , a [ 6 ] , a [ 3 ] , a [ 4 ] , a [ 1 ] , a [ 5 ] ]\n        elif direction == 'S' :\n            self._eyes = [ 'dummy' , a [ 5 ] , a [ 1 ] , a [ 3 ] , a [ 4 ] , a [ 6 ] , a [ 2 ] ]\n        elif direction == 'W' :\n            self._eyes = [ 'dummy' , a [ 3 ] , a [ 2 ] , a [ 6 ] , a [ 1 ] , a [ 5 ] , a [ 4 ] ]\n        elif direction == 'E' :\n            self._eyes = [ 'dummy' , a [ 4 ] , a [ 2 ] , a [ 1 ] , a [ 6 ] , a [ 5 ] , a [ 3 ] ]\n        else :\n            raise ValueError ( 'NEWS\u7bb1\u63a8\u3057' )\neyes = input ( ).split ( )\ndice = Dice ( eyes )\ndirection_text = input ( )\nfor d in direction_text :\n    dice.roll ( d )\nprint ( dice.eye )\n", "python_code_tokenized": "class Dice : NEW_LINE INDENT def __init__ ( self , eyes ) : NEW_LINE INDENT self . _eyes = [ ' dummy ' ] + eyes NEW_LINE DEDENT @ property NEW_LINE def eye ( self ) : NEW_LINE INDENT return self . _eyes [ 1 ] NEW_LINE DEDENT def roll ( self , direction ) : NEW_LINE INDENT a = self . _eyes NEW_LINE if direction == ' N ' : NEW_LINE INDENT self . _eyes = [ ' dummy ' , a [ 2 ] , a [ 6 ] , a [ 3 ] , a [ 4 ] , a [ 1 ] , a [ 5 ] ] NEW_LINE DEDENT elif direction == ' S ' : NEW_LINE INDENT self . _eyes = [ ' dummy ' , a [ 5 ] , a [ 1 ] , a [ 3 ] , a [ 4 ] , a [ 6 ] , a [ 2 ] ] NEW_LINE DEDENT elif direction == ' W ' : NEW_LINE INDENT self . _eyes = [ ' dummy ' , a [ 3 ] , a [ 2 ] , a [ 6 ] , a [ 1 ] , a [ 5 ] , a [ 4 ] ] NEW_LINE DEDENT elif direction == ' E ' : NEW_LINE INDENT self . _eyes = [ ' dummy ' , a [ 4 ] , a [ 2 ] , a [ 1 ] , a [ 6 ] , a [ 5 ] , a [ 3 ] ] NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( ' NEWS\u7bb1\u63a8\u3057 ' ) NEW_LINE DEDENT DEDENT DEDENT eyes = input ( ) . split ( ) NEW_LINE dice = Dice ( eyes ) NEW_LINE direction_text = input ( ) NEW_LINE for d in direction_text : NEW_LINE INDENT dice . roll ( d ) NEW_LINE DEDENT print ( dice . eye ) NEW_LINE"}
{"id": "aizu_p00380_A", "sol": 0, "python_code": "def solve ( ) :\n    N = int ( input ( ) )\n    a = [ int ( i ) for i in input ( ).split ( ) ]\n    Q = int ( input ( ) )\n    sort_a = sorted ( a )\n    judge = 0\n    for i in range ( N ) :\n        if a [ i ] != sort_a [ i ] :\n            judge += 1\n    if judge == 0 :\n        print ( 0 )\n    else :\n        for i in range ( Q ) :\n            x , y = map ( int , input ( ).split ( ) )\n            tmp = a [ x - 1 ]\n            a [ x - 1 ] = a [ y - 1 ]\n            a [ y - 1 ] = tmp\n            if a [ x - 1 ] == sort_a [ x - 1 ] and a [ y - 1 ] != sort_a [ x - 1 ] :\n                judge -= 1\n            if a [ x - 1 ] != sort_a [ x - 1 ] and a [ y - 1 ] == sort_a [ x - 1 ] :\n                judge += 1\n            if a [ y - 1 ] == sort_a [ y - 1 ] and a [ x - 1 ] != sort_a [ y - 1 ] :\n                judge -= 1\n            if a [ y - 1 ] != sort_a [ y - 1 ] and a [ x - 1 ] == sort_a [ y - 1 ] :\n                judge += 1\n            if judge == 0 :\n                print ( i + 1 )\n                break\n        else :\n            print ( - 1 )\nif __name__ == '__main__' :\n    solve ( )\n", "python_code_tokenized": "def solve ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE Q = int ( input ( ) ) NEW_LINE sort_a = sorted ( a ) NEW_LINE judge = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if a [ i ] != sort_a [ i ] : NEW_LINE INDENT judge += 1 NEW_LINE DEDENT DEDENT if judge == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( Q ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE tmp = a [ x - 1 ] NEW_LINE a [ x - 1 ] = a [ y - 1 ] NEW_LINE a [ y - 1 ] = tmp NEW_LINE if a [ x - 1 ] == sort_a [ x - 1 ] and a [ y - 1 ] != sort_a [ x - 1 ] : NEW_LINE INDENT judge -= 1 NEW_LINE DEDENT if a [ x - 1 ] != sort_a [ x - 1 ] and a [ y - 1 ] == sort_a [ x - 1 ] : NEW_LINE INDENT judge += 1 NEW_LINE DEDENT if a [ y - 1 ] == sort_a [ y - 1 ] and a [ x - 1 ] != sort_a [ y - 1 ] : NEW_LINE INDENT judge -= 1 NEW_LINE DEDENT if a [ y - 1 ] != sort_a [ y - 1 ] and a [ x - 1 ] == sort_a [ y - 1 ] : NEW_LINE INDENT judge += 1 NEW_LINE DEDENT if judge == 0 : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"}
{"id": "codeforces_672_A", "sol": 0, "python_code": "li = [ ]\nind = 0\nfor i in range ( 1 , 371 ) :\n    temp = [ ]\n    p , q = i , i\n    count = 0\n    while p != 0 :\n        p //= 10\n        count += 1\n    if count == 1 :\n        li.append ( i )\n    if count == 2 :\n        temp = [ ]\n        while q != 0 :\n            x = q % 10\n            q //= 10\n            temp.append ( x )\n        li = li + temp [ : : - 1 ]\n    if count == 3 :\n        temp = [ ]\n        while q != 0 :\n            x = q % 10\n            q //= 10\n            temp.append ( x )\n        li = li + temp [ : : - 1 ]\nli.pop ( )\nli.pop ( )\nn = int ( input ( '' ) )\nprint ( li [ n - 1 ] )\n", "python_code_tokenized": "li = [ ] NEW_LINE ind = 0 NEW_LINE for i in range ( 1 , 371 ) : NEW_LINE INDENT temp = [ ] NEW_LINE p , q = i , i NEW_LINE count = 0 NEW_LINE while p != 0 : NEW_LINE INDENT p //= 10 NEW_LINE count += 1 NEW_LINE DEDENT if count == 1 : NEW_LINE INDENT li . append ( i ) NEW_LINE DEDENT if count == 2 : NEW_LINE INDENT temp = [ ] NEW_LINE while q != 0 : NEW_LINE INDENT x = q % 10 NEW_LINE q //= 10 NEW_LINE temp . append ( x ) NEW_LINE DEDENT li = li + temp [ : : - 1 ] NEW_LINE DEDENT if count == 3 : NEW_LINE INDENT temp = [ ] NEW_LINE while q != 0 : NEW_LINE INDENT x = q % 10 NEW_LINE q //= 10 NEW_LINE temp . append ( x ) NEW_LINE DEDENT li = li + temp [ : : - 1 ] NEW_LINE DEDENT DEDENT li . pop ( ) NEW_LINE li . pop ( ) NEW_LINE n = int ( input ( ' ' ) ) NEW_LINE print ( li [ n - 1 ] ) NEW_LINE"}
{"id": "aizu_p00267_A", "sol": 0, "python_code": "while 1 :\n    if input ( ) == '0' : break\n    a = sorted ( list ( map ( int , input ( ).split ( ) ) ) ) [ : : - 1 ]\n    b = sorted ( list ( map ( int , input ( ).split ( ) ) ) ) [ : : - 1 ]\n    p = 0 ; c = 0 ;\n    for i , x in enumerate ( a ) :\n        if i / 2 < c : print ( i ) ; break\n        if x <= b [ p ] : p += 1\n        else : c += 1\n    else : print ( 'NA' )\n", "python_code_tokenized": "while 1 : NEW_LINE INDENT if input ( ) == '0' : break NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ : : - 1 ] NEW_LINE b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) [ : : - 1 ] NEW_LINE p = 0 ; c = 0 ; NEW_LINE for i , x in enumerate ( a ) : NEW_LINE INDENT if i / 2 < c : print ( i ) ; break NEW_LINE if x <= b [ p ] : p += 1 NEW_LINE else : c += 1 NEW_LINE DEDENT else : print ( ' NA ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3028_A", "sol": 0, "python_code": "import sys\ndef findMaxValue ( ) :\n    res = 2 ;\n    fact = 2 ;\n    while ( True ) :\n        if ( fact < 0 or fact > sys.maxsize ) :\n            break ;\n        res += 1 ;\n        fact = fact * res ;\n    return res - 1 ;\nif __name__ == '__main__' :\n    print ( \"Maximum value of integer:\" , findMaxValue ( ) ) ;\n", "python_code_tokenized": "import sys NEW_LINE def findMaxValue ( ) : NEW_LINE INDENT res = 2 ; NEW_LINE fact = 2 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( fact < 0 or fact > sys . maxsize ) : NEW_LINE INDENT break ; NEW_LINE DEDENT res += 1 ; NEW_LINE fact = fact * res ; NEW_LINE DEDENT return res - 1 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( \" Maximum \u2581 value \u2581 of \u2581 integer : \" , findMaxValue ( ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4262_A", "sol": 0, "python_code": "def printPaths ( inputchar , R , C ) :\n    for i in range ( C ) :\n        dfs ( inputchar , \"\" , 0 , i , R , C ) ;\n        print ( )\ndef dfs ( inputchar , res , i , j , R , C ) :\n    if ( i == R ) :\n        print ( res , end = \" \" ) ;\n        return ;\n    res = res + inputchar [ i ] [ j ] ;\n    for k in range ( C ) :\n        dfs ( inputchar , res , i + 1 , k , R , C ) ;\n        if ( i + 1 == R ) :\n            break ;\nif __name__ == \"__main__\" :\n    inputchar = [ [ 'a' , 'b' ] , [ 'd' , 'e' ] ] ;\n    R = len ( inputchar ) ;\n    C = len ( inputchar [ 0 ] ) ;\n    printPaths ( inputchar , R , C ) ;\n", "python_code_tokenized": "def printPaths ( inputchar , R , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT dfs ( inputchar , \" \" , 0 , i , R , C ) ; NEW_LINE print ( ) NEW_LINE DEDENT DEDENT def dfs ( inputchar , res , i , j , R , C ) : NEW_LINE INDENT if ( i == R ) : NEW_LINE INDENT print ( res , end = \" \u2581 \" ) ; NEW_LINE return ; NEW_LINE DEDENT res = res + inputchar [ i ] [ j ] ; NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( inputchar , res , i + 1 , k , R , C ) ; NEW_LINE if ( i + 1 == R ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT inputchar = [ [ ' a ' , ' b ' ] , [ ' d ' , ' e ' ] ] ; NEW_LINE R = len ( inputchar ) ; NEW_LINE C = len ( inputchar [ 0 ] ) ; NEW_LINE printPaths ( inputchar , R , C ) ; NEW_LINE DEDENT"}
{"id": "codeforces_34_A", "sol": 0, "python_code": "n = int ( input ( ) )\nheights = [ int ( h ) for h in input ( ).split ( \" \" , n - 1 ) ]\nlist = [ ]\nfor i in range ( 0 , n ) :\n    if i != ( n - 1 ) :\n        list.append ( abs ( heights [ i ] - heights [ i + 1 ] ) )\n    else :\n        list.append ( abs ( heights [ i ] - heights [ 0 ] ) )\nk = min ( list )\nif list [ n - 1 ] == k :\n    print ( 1 , n )\nelse :\n    for j in range ( 0 , n ) :\n        if list [ j ] == k :\n            print ( j + 1 , j + 2 )\n            break\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE heights = [ int ( h ) for h in input ( ) . split ( \" \u2581 \" , n - 1 ) ] NEW_LINE list = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if i != ( n - 1 ) : NEW_LINE INDENT list . append ( abs ( heights [ i ] - heights [ i + 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT list . append ( abs ( heights [ i ] - heights [ 0 ] ) ) NEW_LINE DEDENT DEDENT k = min ( list ) NEW_LINE if list [ n - 1 ] == k : NEW_LINE INDENT print ( 1 , n ) NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if list [ j ] == k : NEW_LINE INDENT print ( j + 1 , j + 2 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_135_A", "sol": 0, "python_code": "maxSize = 50\ndp = [ 0 ] * maxSize\nv = [ 0 ] * maxSize\ndef expectedSteps ( x ) :\n    if ( x == 0 ) :\n        return 0\n    if ( x <= 5 ) :\n        return 6\n    if ( v [ x ] ) :\n        return dp [ x ]\n    v [ x ] = 1\n    dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6\n    return dp [ x ]\nn = 10\nprint ( round ( expectedSteps ( n - 1 ) , 5 ) )\n", "python_code_tokenized": "maxSize = 50 NEW_LINE dp = [ 0 ] * maxSize NEW_LINE v = [ 0 ] * maxSize NEW_LINE def expectedSteps ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( x <= 5 ) : NEW_LINE INDENT return 6 NEW_LINE DEDENT if ( v [ x ] ) : NEW_LINE INDENT return dp [ x ] NEW_LINE DEDENT v [ x ] = 1 NEW_LINE dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 NEW_LINE return dp [ x ] NEW_LINE DEDENT n = 10 NEW_LINE print ( round ( expectedSteps ( n - 1 ) , 5 ) ) NEW_LINE"}
{"id": "geeksforgeeks_3465_A", "sol": 0, "python_code": "def line ( x0 , y0 ) :\n    c = 2 * y0 * x0\n    print ( y0 , \"x\" , \"+\" , x0 , \"y=\" , c )\nif __name__ == '__main__' :\n    x0 = 4\n    y0 = 3\n    line ( x0 , y0 )\n", "python_code_tokenized": "def line ( x0 , y0 ) : NEW_LINE INDENT c = 2 * y0 * x0 NEW_LINE print ( y0 , \" x \" , \" + \" , x0 , \" y = \" , c ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x0 = 4 NEW_LINE y0 = 3 NEW_LINE line ( x0 , y0 ) NEW_LINE DEDENT"}
{"id": "codeforces_43_B", "sol": 0, "python_code": "s1 = input ( )\ns2 = input ( )\nfreq = { }\nfor ch in s1 :\n    if ch == ' ' :\n        continue\n    if ch in freq :\n        freq [ ch ] += 1\n    else :\n        freq [ ch ] = 1\nans = True\nfor ch in s2 :\n    if ch == ' ' :\n        continue\n    if ch not in freq :\n        ans = False\n        break\n    freq [ ch ] -= 1\n    if freq [ ch ] < 0 :\n        ans = False\n        break\nprint ( 'YES' if ans else 'NO' )\n", "python_code_tokenized": "s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE freq = { } NEW_LINE for ch in s1 : NEW_LINE INDENT if ch == ' \u2581 ' : NEW_LINE INDENT continue NEW_LINE DEDENT if ch in freq : NEW_LINE INDENT freq [ ch ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ ch ] = 1 NEW_LINE DEDENT DEDENT ans = True NEW_LINE for ch in s2 : NEW_LINE INDENT if ch == ' \u2581 ' : NEW_LINE INDENT continue NEW_LINE DEDENT if ch not in freq : NEW_LINE INDENT ans = False NEW_LINE break NEW_LINE DEDENT freq [ ch ] -= 1 NEW_LINE if freq [ ch ] < 0 : NEW_LINE INDENT ans = False NEW_LINE break NEW_LINE DEDENT DEDENT print ( ' YES ' if ans else ' NO ' ) NEW_LINE"}
{"id": "geeksforgeeks_978_A", "sol": 0, "python_code": "import numpy as np\nimport sys\nC_MAX = 30\nmax_arr_len = 10\ndp = np.zeros ( ( max_arr_len , C_MAX + 1 ) ) ;\nv = np.zeros ( ( max_arr_len , C_MAX + 1 ) ) ;\nINT_MIN = - ( sys.maxsize ) + 1\ndef findMax ( i , r , w , n ) :\n    if ( r < 0 ) :\n        return INT_MIN ;\n    if ( i == n ) :\n        return 0 ;\n    if ( v [ i ] [ r ] ) :\n        return dp [ i ] [ r ] ;\n    v [ i ] [ r ] = 1 ;\n    dp [ i ] [ r ] = max ( w [ i ] + findMax ( i + 1 , r - w [ i ] , w , n ) , findMax ( i + 1 , r , w , n ) ) ;\n    return dp [ i ] [ r ] ;\ndef preCompute ( w , n ) :\n    for i in range ( C_MAX , - 1 , - 1 ) :\n        findMax ( 0 , i , w , n ) ;\ndef ansQuery ( w ) :\n    return dp [ 0 ] [ w ] ;\nif __name__ == \"__main__\" :\n    w = [ 3 , 8 , 9 ] ;\n    n = len ( w )\n    preCompute ( w , n ) ;\n    queries = [ 11 , 10 , 4 ] ;\n    q = len ( queries )\n    for i in range ( q ) :\n        print ( ansQuery ( queries [ i ] ) ) ;\n", "python_code_tokenized": "import numpy as np NEW_LINE import sys NEW_LINE C_MAX = 30 NEW_LINE max_arr_len = 10 NEW_LINE dp = np . zeros ( ( max_arr_len , C_MAX + 1 ) ) ; NEW_LINE v = np . zeros ( ( max_arr_len , C_MAX + 1 ) ) ; NEW_LINE INT_MIN = - ( sys . maxsize ) + 1 NEW_LINE def findMax ( i , r , w , n ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return INT_MIN ; NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( v [ i ] [ r ] ) : NEW_LINE INDENT return dp [ i ] [ r ] ; NEW_LINE DEDENT v [ i ] [ r ] = 1 ; NEW_LINE dp [ i ] [ r ] = max ( w [ i ] + findMax ( i + 1 , r - w [ i ] , w , n ) , findMax ( i + 1 , r , w , n ) ) ; NEW_LINE return dp [ i ] [ r ] ; NEW_LINE DEDENT def preCompute ( w , n ) : NEW_LINE INDENT for i in range ( C_MAX , - 1 , - 1 ) : NEW_LINE INDENT findMax ( 0 , i , w , n ) ; NEW_LINE DEDENT DEDENT def ansQuery ( w ) : NEW_LINE INDENT return dp [ 0 ] [ w ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT w = [ 3 , 8 , 9 ] ; NEW_LINE n = len ( w ) NEW_LINE preCompute ( w , n ) ; NEW_LINE queries = [ 11 , 10 , 4 ] ; NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( ansQuery ( queries [ i ] ) ) ; NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1539_B", "sol": 0, "python_code": "a , b = list ( map ( int , input ( ).split ( ) ) )\ns = input ( )\nalp = \"abcdefghijklmnopqrstuvwxyz\"\nsum_array = [ ]\nfor x in s :\n    sum_array.append ( alp.index ( x ) + 1 )\nfor y in range ( 1 , len ( s ) ) :\n    sum_array [ y ] = sum_array [ y - 1 ] + sum_array [ y ]\nfor i in range ( b ) :\n    l , r = list ( map ( int , input ( ).split ( ) ) )\n    if l == 1 :\n        print ( sum_array [ r - 1 ] )\n    else :\n        print ( sum_array [ r - 1 ] - sum_array [ l - 2 ] )\n", "python_code_tokenized": "a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = input ( ) NEW_LINE alp = \" abcdefghijklmnopqrstuvwxyz \" NEW_LINE sum_array = [ ] NEW_LINE for x in s : NEW_LINE INDENT sum_array . append ( alp . index ( x ) + 1 ) NEW_LINE DEDENT for y in range ( 1 , len ( s ) ) : NEW_LINE INDENT sum_array [ y ] = sum_array [ y - 1 ] + sum_array [ y ] NEW_LINE DEDENT for i in range ( b ) : NEW_LINE INDENT l , r = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if l == 1 : NEW_LINE INDENT print ( sum_array [ r - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sum_array [ r - 1 ] - sum_array [ l - 2 ] ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2010_A", "sol": 0, "python_code": "def squareSide ( a ) :\n    if ( a < 0 ) :\n        return - 1\n    x = 0.423 * a\n    return x\nif __name__ == '__main__' :\n    a = 8\n    print ( squareSide ( a ) )\n", "python_code_tokenized": "def squareSide ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = 0.423 * a NEW_LINE return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 8 NEW_LINE print ( squareSide ( a ) ) NEW_LINE DEDENT"}
{"id": "codeforces_128_A", "sol": 0, "python_code": "r , s = [ 63 ] , ''.join ( input ( ) + 'T' for i in range ( 8 ) ) + 'T' * 9\nfor i in range ( 0 , 72 , 9 ) :\n    t = set ( )\n    for x in r :\n        for y in ( x , x - 1 , x + 1 , x - 9 , x + 9 , x - 10 , x - 8 , x + 10 , x + 8 ) :\n            if s [ y ] == 'T' : continue\n            if ( y < i or s [ y - i ] != 'S' ) and ( y < i + 9 or s [ y - i - 9 ] != 'S' ) : t.add ( y )\n    r = t\nprint ( 'WIN' if r else 'LOSE' )\n", "python_code_tokenized": "r , s = [ 63 ] , ' ' . join ( input ( ) + ' T ' for i in range ( 8 ) ) + ' T ' * 9 NEW_LINE for i in range ( 0 , 72 , 9 ) : NEW_LINE INDENT t = set ( ) NEW_LINE for x in r : NEW_LINE INDENT for y in ( x , x - 1 , x + 1 , x - 9 , x + 9 , x - 10 , x - 8 , x + 10 , x + 8 ) : NEW_LINE INDENT if s [ y ] == ' T ' : continue NEW_LINE if ( y < i or s [ y - i ] != ' S ' ) and ( y < i + 9 or s [ y - i - 9 ] != ' S ' ) : t . add ( y ) NEW_LINE DEDENT DEDENT r = t NEW_LINE DEDENT print ( ' WIN ' if r else ' LOSE ' ) NEW_LINE"}
{"id": "geeksforgeeks_3620_A", "sol": 0, "python_code": "def count_of_ways ( n ) :\n    count = 0\n    count = ( n + 1 ) * ( n + 2 ) // 2\n    return count\nn = 3\nprint ( count_of_ways ( n ) )\n", "python_code_tokenized": "def count_of_ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE count = ( n + 1 ) * ( n + 2 ) // 2 NEW_LINE return count NEW_LINE DEDENT n = 3 NEW_LINE print ( count_of_ways ( n ) ) NEW_LINE"}
{"id": "atcoder_ABC145_C", "sol": 0, "python_code": "import math\nn = int ( input ( ) )\ngraph = [ [ ] for i in range ( n ) ]\nfor i in range ( n ) :\n    a , b = list ( map ( int , input ( ).split ( ) ) )\n    graph [ i ] = [ a , b ]\ndef inasi ( ls , i ) :\n    n = [ ]\n    for j in range ( len ( ls ) ) :\n        if j == i : continue\n        n.append ( ls [ j ] )\n    return n\ndef kyori ( ls ) :\n    ans = 0\n    for i in range ( len ( ls ) - 1 ) :\n        ans += math.sqrt ( ( graph [ ls [ i ] ] [ 0 ] - graph [ ls [ i + 1 ] ] [ 0 ] ) ** 2 + ( graph [ ls [ i ] ] [ 1 ] - graph [ ls [ i + 1 ] ] [ 1 ] ) ** 2 )\n    return ans\ncheck = 0\ncount = 0\ndef keisan ( n , pls , ls ) :\n    global check , count\n    if len ( ls ) == 0 :\n        check += kyori ( pls )\n        count += 1\n        return\n    for i in range ( len ( ls ) ) :\n        pls.append ( ls [ i ] )\n        keisan ( n - 1 , pls , inasi ( ls , i ) )\n        try : pls.pop ( )\n        except : pass\n    return\nkeisan ( 10 , [ ] , [ i for i in range ( n ) ] )\nprint ( check / count )\n", "python_code_tokenized": "import math NEW_LINE n = int ( input ( ) ) NEW_LINE graph = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE graph [ i ] = [ a , b ] NEW_LINE DEDENT def inasi ( ls , i ) : NEW_LINE INDENT n = [ ] NEW_LINE for j in range ( len ( ls ) ) : NEW_LINE INDENT if j == i : continue NEW_LINE n . append ( ls [ j ] ) NEW_LINE DEDENT return n NEW_LINE DEDENT def kyori ( ls ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( ls ) - 1 ) : NEW_LINE INDENT ans += math . sqrt ( ( graph [ ls [ i ] ] [ 0 ] - graph [ ls [ i + 1 ] ] [ 0 ] ) ** 2 + ( graph [ ls [ i ] ] [ 1 ] - graph [ ls [ i + 1 ] ] [ 1 ] ) ** 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT check = 0 NEW_LINE count = 0 NEW_LINE def keisan ( n , pls , ls ) : NEW_LINE INDENT global check , count NEW_LINE if len ( ls ) == 0 : NEW_LINE INDENT check += kyori ( pls ) NEW_LINE count += 1 NEW_LINE return NEW_LINE DEDENT for i in range ( len ( ls ) ) : NEW_LINE INDENT pls . append ( ls [ i ] ) NEW_LINE keisan ( n - 1 , pls , inasi ( ls , i ) ) NEW_LINE try : pls . pop ( ) NEW_LINE except : pass NEW_LINE DEDENT return NEW_LINE DEDENT keisan ( 10 , [ ] , [ i for i in range ( n ) ] ) NEW_LINE print ( check / count ) NEW_LINE"}
{"id": "geeksforgeeks_3060_A", "sol": 0, "python_code": "def squareDigitSum ( num ) :\n    summ = 0\n    num = int ( num )\n    squareNum = num * num\n    while squareNum > 0 :\n        summ = summ + ( squareNum % 10 )\n        squareNum = squareNum // 10\n    return summ\nif __name__ == \"__main__\" :\n    N = \"1111\"\n    print ( squareDigitSum ( N ) )\n", "python_code_tokenized": "def squareDigitSum ( num ) : NEW_LINE INDENT summ = 0 NEW_LINE num = int ( num ) NEW_LINE squareNum = num * num NEW_LINE while squareNum > 0 : NEW_LINE INDENT summ = summ + ( squareNum % 10 ) NEW_LINE squareNum = squareNum // 10 NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = \"1111\" NEW_LINE print ( squareDigitSum ( N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2590_A", "sol": 0, "python_code": "def areAllBitsSet ( n ) :\n    if ( n == 0 ) :\n        return False ;\n    if ( ( ( n + 1 ) & n ) == 0 ) :\n        return True ;\n    return False ;\ndef isOnesComplementOfOther ( a , b ) :\n    return areAllBitsSet ( a ^ b )\na = 1\nb = 14\nif ( isOnesComplementOfOther ( a , b ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def areAllBitsSet ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def isOnesComplementOfOther ( a , b ) : NEW_LINE INDENT return areAllBitsSet ( a ^ b ) NEW_LINE DEDENT a = 1 NEW_LINE b = 14 NEW_LINE if ( isOnesComplementOfOther ( a , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1785_A", "sol": 0, "python_code": "def printDistinct ( arr , n ) :\n    arr.sort ( ) ;\n    for i in range ( n ) :\n        if ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) :\n            while ( i < n - 1 and ( arr [ i ] == arr [ i + 1 ] ) ) :\n                i += 1 ;\n        else :\n            print ( arr [ i ] , end = \" \" ) ;\narr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] ;\nn = len ( arr ) ;\nprintDistinct ( arr , n ) ;\n", "python_code_tokenized": "def printDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT while ( i < n - 1 and ( arr [ i ] == arr [ i + 1 ] ) ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printDistinct ( arr , n ) ; NEW_LINE"}
{"id": "geeksforgeeks_1484_A", "sol": 0, "python_code": "def findElements ( arr , n ) :\n    arr.sort ( )\n    for i in range ( 0 , n - 2 ) :\n        print ( arr [ i ] , end = \" \" )\narr = [ 2 , - 6 , 3 , 5 , 1 ]\nn = len ( arr )\nfindElements ( arr , n )\n", "python_code_tokenized": "def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE"}
{"id": "codeforces_1230_A", "sol": 0, "python_code": "ls = list ( map ( int , input ( ).split ( ) ) )\nls.sort ( )\nif sum ( ls [ : 3 ] ) == ls [ 3 ] :\n    print ( 'YES' )\nelif ls [ 0 ] + ls [ 3 ] == ls [ 1 ] + ls [ 2 ] :\n    print ( 'YES' )\nelif ls [ 1 ] + ls [ 3 ] == ls [ 0 ] + ls [ 2 ] :\n    print ( 'YES' )\nelse :\n    print ( 'NO' )\n", "python_code_tokenized": "ls = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ls . sort ( ) NEW_LINE if sum ( ls [ : 3 ] ) == ls [ 3 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT elif ls [ 0 ] + ls [ 3 ] == ls [ 1 ] + ls [ 2 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT elif ls [ 1 ] + ls [ 3 ] == ls [ 0 ] + ls [ 2 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_919_A", "sol": 0, "python_code": "def power ( x , y , p ) :\n    res = 1\n    x = x % p\n    while ( y > 0 ) :\n        if ( y & 1 ) :\n            res = ( res * x ) % p\n        y = y >> 1\n        x = ( x * x ) % p\n    return res\ndef gcd ( a , b ) :\n    if ( a == 0 ) :\n        return b\n    return gcd ( b % a , a )\ndef powerGCD ( a , b , n ) :\n    e = power ( a , n , b )\n    return gcd ( e , b )\nif __name__ == \"__main__\" :\n    a = 5\n    b = 4\n    n = 2\n    print ( powerGCD ( a , b , n ) )\n", "python_code_tokenized": "def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def powerGCD ( a , b , n ) : NEW_LINE INDENT e = power ( a , n , b ) NEW_LINE return gcd ( e , b ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 5 NEW_LINE b = 4 NEW_LINE n = 2 NEW_LINE print ( powerGCD ( a , b , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_186_A", "sol": 0, "python_code": "a = input ( )\nb = input ( )\nx = sorted ( a )\ny = sorted ( b )\ncnt = 0\nif x != y :\n    print ( \"NO\" )\nelse :\n    n = min ( len ( a ) , len ( b ) )\n    for i in range ( n ) :\n        if a [ i ] != b [ i ] :\n            cnt += 1\n        if cnt > 2 :\n            print ( \"NO\" )\n            break\n    else :\n        if cnt == 2 :\n            print ( \"YES\" )\n        else :\n            print ( \"NO\" )\n", "python_code_tokenized": "a = input ( ) NEW_LINE b = input ( ) NEW_LINE x = sorted ( a ) NEW_LINE y = sorted ( b ) NEW_LINE cnt = 0 NEW_LINE if x != y : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT n = min ( len ( a ) , len ( b ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != b [ i ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if cnt > 2 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if cnt == 2 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "codeforces_439_A", "sol": 0, "python_code": "i = lambda : map ( int , input ( ).split ( ) ) ; n , d = i ( ) ; d -= sum ( i ( ) ) ; print ( [ d // 5 , - 1 ] [ d < 10 * ~ - n ] )\n", "python_code_tokenized": "i = lambda : map ( int , input ( ) . split ( ) ) ; n , d = i ( ) ; d -= sum ( i ( ) ) ; print ( [ d // 5 , - 1 ] [ d < 10 * ~ - n ] ) NEW_LINE"}
{"id": "codeforces_797_A", "sol": 0, "python_code": "def decomp ( n , k ) :\n    i = 2\n    mylist = [ ]\n    while i * i <= n and len ( mylist ) < k - 1 :\n        if n % i == 0 :\n            mylist.append ( i )\n            n //= i\n        else :\n            i += 1\n    mylist.append ( n )\n    return mylist\nn , k = map ( int , input ( ).split ( ) )\nresult = decomp ( n , k )\nif len ( result ) == k :\n    print ( * result )\nelse :\n    print ( - 1 )\n", "python_code_tokenized": "def decomp ( n , k ) : NEW_LINE INDENT i = 2 NEW_LINE mylist = [ ] NEW_LINE while i * i <= n and len ( mylist ) < k - 1 : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT mylist . append ( i ) NEW_LINE n //= i NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT mylist . append ( n ) NEW_LINE return mylist NEW_LINE DEDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE result = decomp ( n , k ) NEW_LINE if len ( result ) == k : NEW_LINE INDENT print ( * result ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"}
{"id": "codeforces_1327_B", "sol": 0, "python_code": "import math\nimport os\nimport random\nimport re\nimport sys\nfrom math import gcd\nfrom math import sqrt\nfor _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    count = [ False for i in range ( n ) ]\n    ans = - 1\n    for i in range ( n ) :\n        arr = [ int ( x ) - 1 for x in input ( ).split ( ) ] [ 1 : ]\n        for j in arr :\n            if not count [ j ] :\n                count [ j ] = True\n                break\n        else :\n            ans = i\n    if ans == - 1 :\n        print ( 'OPTIMAL' )\n    else :\n        fi = count.index ( False )\n        print ( 'IMPROVE\\n' + str ( ans + 1 ) + \" \" + str ( fi + 1 ) )\n", "python_code_tokenized": "import math NEW_LINE import os NEW_LINE import random NEW_LINE import re NEW_LINE import sys NEW_LINE from math import gcd NEW_LINE from math import sqrt NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE count = [ False for i in range ( n ) ] NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr = [ int ( x ) - 1 for x in input ( ) . split ( ) ] [ 1 : ] NEW_LINE for j in arr : NEW_LINE INDENT if not count [ j ] : NEW_LINE INDENT count [ j ] = True NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = i NEW_LINE DEDENT DEDENT if ans == - 1 : NEW_LINE INDENT print ( ' OPTIMAL ' ) NEW_LINE DEDENT else : NEW_LINE INDENT fi = count . index ( False ) NEW_LINE print ( ' IMPROVE \\n ' + str ( ans + 1 ) + \" \u2581 \" + str ( fi + 1 ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1532_A", "sol": 0, "python_code": "import sys\ndef checkIfSortRotated ( arr , n ) :\n    minEle = sys.maxsize\n    maxEle = - sys.maxsize - 1\n    minIndex = - 1\n    for i in range ( n ) :\n        if arr [ i ] < minEle :\n            minEle = arr [ i ]\n            minIndex = i\n    flag1 = 1\n    for i in range ( 1 , minIndex ) :\n        if arr [ i ] < arr [ i - 1 ] :\n            flag1 = 0\n            break\n    flag2 = 2\n    for i in range ( minIndex + 1 , n ) :\n        if arr [ i ] < arr [ i - 1 ] :\n            flag2 = 0\n            break\n    if ( flag1 and flag2 and arr [ n - 1 ] < arr [ minIndex - 1 ] ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\narr = [ 3 , 4 , 5 , 1 , 2 ]\nn = len ( arr )\ncheckIfSortRotated ( arr , n )\n", "python_code_tokenized": "import sys NEW_LINE def checkIfSortRotated ( arr , n ) : NEW_LINE INDENT minEle = sys . maxsize NEW_LINE maxEle = - sys . maxsize - 1 NEW_LINE minIndex = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < minEle : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minIndex = i NEW_LINE DEDENT DEDENT flag1 = 1 NEW_LINE for i in range ( 1 , minIndex ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag1 = 0 NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = 2 NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag2 = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag1 and flag2 and arr [ n - 1 ] < arr [ minIndex - 1 ] ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 5 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE checkIfSortRotated ( arr , n ) NEW_LINE"}
{"id": "codeforces_965_A", "sol": 0, "python_code": "k , n , s , p = map ( int , input ( ).split ( ) )\nsheets_per_person = ( n + s - 1 ) // s\nsheets = k * sheets_per_person\nprint ( ( sheets + p - 1 ) // p )\n", "python_code_tokenized": "k , n , s , p = map ( int , input ( ) . split ( ) ) NEW_LINE sheets_per_person = ( n + s - 1 ) // s NEW_LINE sheets = k * sheets_per_person NEW_LINE print ( ( sheets + p - 1 ) // p ) NEW_LINE"}
{"id": "codeforces_1635_A", "sol": 0, "python_code": "import functools\nfor i in range ( int ( input ( ) ) ) :\n    input ( )\n    print ( functools.reduce ( lambda x , y : x | y , map ( int , input ( ).split ( ) ) ) )\n", "python_code_tokenized": "import functools NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT input ( ) NEW_LINE print ( functools . reduce ( lambda x , y : x | y , map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5234_A", "sol": 0, "python_code": "import math as mt\ndef gcd ( a , b ) :\n    while ( b != 0 ) :\n        t = b\n        b = a % b\n        a = t\n    return a\ndef findMinDiff ( a , b , x , y ) :\n    g = gcd ( a , b )\n    diff = abs ( x - y ) % g\n    return min ( diff , g - diff )\na , b , x , y = 20 , 52 , 5 , 7\nprint ( findMinDiff ( a , b , x , y ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT while ( b != 0 ) : NEW_LINE INDENT t = b NEW_LINE b = a % b NEW_LINE a = t NEW_LINE DEDENT return a NEW_LINE DEDENT def findMinDiff ( a , b , x , y ) : NEW_LINE INDENT g = gcd ( a , b ) NEW_LINE diff = abs ( x - y ) % g NEW_LINE return min ( diff , g - diff ) NEW_LINE DEDENT a , b , x , y = 20 , 52 , 5 , 7 NEW_LINE print ( findMinDiff ( a , b , x , y ) ) NEW_LINE"}
{"id": "codeforces_785_B", "sol": 0, "python_code": "def solve ( n , m , seq1 , seq2 ) :\n    op1 = 0\n    op2 = 0\n    seq1.sort ( key = lambda x : x [ 1 ] )\n    seq2.sort ( key = lambda x : x [ 0 ] , reverse = True )\n    if seq2 [ 0 ] [ 0 ] - seq1 [ 0 ] [ 1 ] <= 0 :\n        pass\n    else :\n        op1 = seq2 [ 0 ] [ 0 ] - seq1 [ 0 ] [ 1 ]\n    seq2.sort ( key = lambda x : x [ 1 ] )\n    seq1.sort ( key = lambda x : x [ 0 ] , reverse = True )\n    if seq1 [ 0 ] [ 0 ] - seq2 [ 0 ] [ 1 ] <= 0 :\n        pass\n    else :\n        op2 = seq1 [ 0 ] [ 0 ] - seq2 [ 0 ] [ 1 ]\n    return max ( op1 , op2 )\nn = int ( input ( ) )\ns1 = [ ]\ns2 = [ ]\nfor x in range ( n ) :\n    s1.append ( list ( map ( int , input ( ).split ( ) ) ) )\nm = int ( input ( ) )\nfor y in range ( m ) :\n    s2.append ( list ( map ( int , input ( ).split ( ) ) ) )\nprint ( solve ( n , m , s1 , s2 ) )\n", "python_code_tokenized": "def solve ( n , m , seq1 , seq2 ) : NEW_LINE INDENT op1 = 0 NEW_LINE op2 = 0 NEW_LINE seq1 . sort ( key = lambda x : x [ 1 ] ) NEW_LINE seq2 . sort ( key = lambda x : x [ 0 ] , reverse = True ) NEW_LINE if seq2 [ 0 ] [ 0 ] - seq1 [ 0 ] [ 1 ] <= 0 : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT op1 = seq2 [ 0 ] [ 0 ] - seq1 [ 0 ] [ 1 ] NEW_LINE DEDENT seq2 . sort ( key = lambda x : x [ 1 ] ) NEW_LINE seq1 . sort ( key = lambda x : x [ 0 ] , reverse = True ) NEW_LINE if seq1 [ 0 ] [ 0 ] - seq2 [ 0 ] [ 1 ] <= 0 : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT op2 = seq1 [ 0 ] [ 0 ] - seq2 [ 0 ] [ 1 ] NEW_LINE DEDENT return max ( op1 , op2 ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE s1 = [ ] NEW_LINE s2 = [ ] NEW_LINE for x in range ( n ) : NEW_LINE INDENT s1 . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT m = int ( input ( ) ) NEW_LINE for y in range ( m ) : NEW_LINE INDENT s2 . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT print ( solve ( n , m , s1 , s2 ) ) NEW_LINE"}
{"id": "geeksforgeeks_3752_A", "sol": 0, "python_code": "def leftRotate ( arr , d , n ) :\n    for i in range ( d ) :\n        leftRotatebyOne ( arr , n )\ndef leftRotatebyOne ( arr , n ) :\n    temp = arr [ 0 ]\n    for i in range ( n - 1 ) :\n        arr [ i ] = arr [ i + 1 ]\n    arr [ n - 1 ] = temp\ndef printArray ( arr , size ) :\n    for i in range ( size ) :\n        print ( \"% d\" % arr [ i ] , end = \" \" )\narr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ]\nleftRotate ( arr , 2 , 7 )\nprintArray ( arr , 7 )\n", "python_code_tokenized": "def leftRotate ( arr , d , n ) : NEW_LINE INDENT for i in range ( d ) : NEW_LINE INDENT leftRotatebyOne ( arr , n ) NEW_LINE DEDENT DEDENT def leftRotatebyOne ( arr , n ) : NEW_LINE INDENT temp = arr [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = temp NEW_LINE DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( \" % \u2581 d \" % arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE leftRotate ( arr , 2 , 7 ) NEW_LINE printArray ( arr , 7 ) NEW_LINE"}
{"id": "geeksforgeeks_2685_A", "sol": 0, "python_code": "def isNumber ( s ) :\n    for i in range ( len ( s ) ) :\n        if s [ i ].isdigit ( ) != True :\n            return False\n    return True\nif __name__ == \"__main__\" :\n    str = \"6790\"\n    if isNumber ( str ) :\n        print ( \"Integer\" )\n    else :\n        print ( \"String\" )\n", "python_code_tokenized": "def isNumber ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] . isdigit ( ) != True : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"6790\" NEW_LINE if isNumber ( str ) : NEW_LINE INDENT print ( \" Integer \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" String \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codejam_15_04", "sol": 0, "python_code": "def winner ( X , S , L ) :\n    if S * L % X : return 'RICHARD'\n    if X <= 2 : return 'GABRIEL'\n    if X >= 7 : return 'RICHARD'\n    if L < X : return 'RICHARD'\n    if 2 * S <= X : return 'RICHARD'\n    if ( X , S , L ) == ( 5 , 3 , 5 ) :\n        return 'RICHARD'\n    return 'GABRIEL'\nT = int ( input ( ) )\nfor case in range ( 1 , T + 1 ) :\n    X , R , C = map ( int , input ( ).split ( ) )\n    print ( \"Case #{}: {}\".format ( case , winner ( X , min ( R , C ) , max ( R , C ) ) ) )\n", "python_code_tokenized": "def winner ( X , S , L ) : NEW_LINE INDENT if S * L % X : return ' RICHARD ' NEW_LINE if X <= 2 : return ' GABRIEL ' NEW_LINE if X >= 7 : return ' RICHARD ' NEW_LINE if L < X : return ' RICHARD ' NEW_LINE if 2 * S <= X : return ' RICHARD ' NEW_LINE if ( X , S , L ) == ( 5 , 3 , 5 ) : NEW_LINE INDENT return ' RICHARD ' NEW_LINE DEDENT return ' GABRIEL ' NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT X , R , C = map ( int , input ( ) . split ( ) ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case , winner ( X , min ( R , C ) , max ( R , C ) ) ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1450_B", "sol": 0, "python_code": "import sys\ninput = lambda : sys.stdin.readline ( ).rstrip ( )\nT = int ( input ( ) )\nfor _ in range ( T ) :\n    N , K = map ( int , input ( ).split ( ) )\n    X = [ ]\n    for _ in range ( N ) :\n        x , y = map ( int , input ( ).split ( ) )\n        X.append ( ( x , y ) )\n    for i , ( x , y ) in enumerate ( X ) :\n        for j , ( x2 , y2 ) in enumerate ( X ) :\n            if abs ( x - x2 ) + abs ( y - y2 ) > K :\n                break\n        else :\n            print ( 1 )\n            break\n    else :\n        print ( - 1 )\n", "python_code_tokenized": "import sys NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE T = int ( input ( ) ) NEW_LINE for _ in range ( T ) : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE X . append ( ( x , y ) ) NEW_LINE DEDENT for i , ( x , y ) in enumerate ( X ) : NEW_LINE INDENT for j , ( x2 , y2 ) in enumerate ( X ) : NEW_LINE INDENT if abs ( x - x2 ) + abs ( y - y2 ) > K : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1619_A", "sol": 0, "python_code": "class newnode :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.left = self.right = None\ndef ancestorMatrixRec ( root , anc ) :\n    global mat , MAX\n    if root == None :\n        return 0\n    data = root.data\n    for i in range ( len ( anc ) ) :\n        mat [ anc [ i ] ] [ data ] = 1\n    anc.append ( data )\n    l = ancestorMatrixRec ( root.left , anc )\n    r = ancestorMatrixRec ( root.right , anc )\n    anc.pop ( - 1 )\n    return l + r + 1\ndef ancestorMatrix ( root ) :\n    anc = [ ]\n    n = ancestorMatrixRec ( root , anc )\n    for i in range ( n ) :\n        for j in range ( n ) :\n            print ( mat [ i ] [ j ] , end = \" \" )\n        print ( )\nMAX = 100\nmat = [ [ 0 ] * MAX for i in range ( MAX ) ]\nroot = newnode ( 5 )\nroot.left = newnode ( 1 )\nroot.right = newnode ( 2 )\nroot.left.left = newnode ( 0 )\nroot.left.right = newnode ( 4 )\nroot.right.left = newnode ( 3 )\nancestorMatrix ( root )\n", "python_code_tokenized": "class newnode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def ancestorMatrixRec ( root , anc ) : NEW_LINE INDENT global mat , MAX NEW_LINE if root == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT data = root . data NEW_LINE for i in range ( len ( anc ) ) : NEW_LINE INDENT mat [ anc [ i ] ] [ data ] = 1 NEW_LINE DEDENT anc . append ( data ) NEW_LINE l = ancestorMatrixRec ( root . left , anc ) NEW_LINE r = ancestorMatrixRec ( root . right , anc ) NEW_LINE anc . pop ( - 1 ) NEW_LINE return l + r + 1 NEW_LINE DEDENT def ancestorMatrix ( root ) : NEW_LINE INDENT anc = [ ] NEW_LINE n = ancestorMatrixRec ( root , anc ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT MAX = 100 NEW_LINE mat = [ [ 0 ] * MAX for i in range ( MAX ) ] NEW_LINE root = newnode ( 5 ) NEW_LINE root . left = newnode ( 1 ) NEW_LINE root . right = newnode ( 2 ) NEW_LINE root . left . left = newnode ( 0 ) NEW_LINE root . left . right = newnode ( 4 ) NEW_LINE root . right . left = newnode ( 3 ) NEW_LINE ancestorMatrix ( root ) NEW_LINE"}
{"id": "atcoder_ABC042_C", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nd = set ( input ( ).split ( ) )\nnum = n\nwhile True :\n    if len ( set ( list ( str ( num ) ) ) & d ) == 0 :\n        print ( num )\n        break\n    num += 1\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE d = set ( input ( ) . split ( ) ) NEW_LINE num = n NEW_LINE while True : NEW_LINE INDENT if len ( set ( list ( str ( num ) ) ) & d ) == 0 : NEW_LINE INDENT print ( num ) NEW_LINE break NEW_LINE DEDENT num += 1 NEW_LINE DEDENT"}
{"id": "geeksforgeeks_282_A", "sol": 0, "python_code": "def GCD ( a , b ) :\n    if ( b == 0 ) :\n        return a ;\n    return GCD ( b , a % b ) ;\ndef findReachable ( arr , D , A , B , n ) :\n    gcd_AB = GCD ( A , B ) ;\n    count = 0 ;\n    for i in range ( n ) :\n        if ( ( arr [ i ] - D ) % gcd_AB == 0 ) :\n            count += 1 ;\n    return count ;\narr = [ 4 , 5 , 6 , 7 , 8 , 9 ] ;\nn = len ( arr ) ;\nD = 4 ; A = 4 ; B = 6 ;\nprint ( findReachable ( arr , D , A , B , n ) ) ;\n", "python_code_tokenized": "def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return GCD ( b , a % b ) ; NEW_LINE DEDENT def findReachable ( arr , D , A , B , n ) : NEW_LINE INDENT gcd_AB = GCD ( A , B ) ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] - D ) % gcd_AB == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 7 , 8 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE D = 4 ; A = 4 ; B = 6 ; NEW_LINE print ( findReachable ( arr , D , A , B , n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_2857_A", "sol": 0, "python_code": "def nextWord ( s ) :\n    if ( s == \" \" ) :\n        return \"a\"\n    i = len ( s ) - 1\n    while ( s [ i ] == 'z' and i >= 0 ) :\n        i -= 1\n    if ( i == - 1 ) :\n        s = s + 'a'\n    else :\n        s = s.replace ( s [ i ] , chr ( ord ( s [ i ] ) + 1 ) , 1 )\n    return s\nif __name__ == '__main__' :\n    str = \"samez\"\n    print ( nextWord ( str ) )\n", "python_code_tokenized": "def nextWord ( s ) : NEW_LINE INDENT if ( s == \" \u2581 \" ) : NEW_LINE INDENT return \" a \" NEW_LINE DEDENT i = len ( s ) - 1 NEW_LINE while ( s [ i ] == ' z ' and i >= 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT s = s + ' a ' NEW_LINE DEDENT else : NEW_LINE INDENT s = s . replace ( s [ i ] , chr ( ord ( s [ i ] ) + 1 ) , 1 ) NEW_LINE DEDENT return s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" samez \" NEW_LINE print ( nextWord ( str ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1598_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    n = int ( input ( ) )\n    a = [ [ ] for i in range ( n ) ]\n    for j in range ( n ) :\n        a [ j ] = list ( map ( int , input ( ).split ( ) ) )\n    ans = False\n    for j in range ( 5 ) :\n        for k in range ( 5 ) :\n            if k != j :\n                cnt1 = 0\n                cnt2 = 0\n                cntno = 0\n                for z in range ( n ) :\n                    if a [ z ] [ j ] == 1 :\n                        cnt1 += 1\n                    if a [ z ] [ k ] == 1 :\n                        cnt2 += 1\n                    if a [ z ] [ j ] == 0 and a [ z ] [ k ] == 0 :\n                        cntno += 1\n                if cnt1 >= n // 2 and cnt2 >= n // 2 and cntno == 0 :\n                    ans = True\n    if ans :\n        print ( 'YES' )\n    else :\n        print ( 'NO' )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ [ ] for i in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT a [ j ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT ans = False NEW_LINE for j in range ( 5 ) : NEW_LINE INDENT for k in range ( 5 ) : NEW_LINE INDENT if k != j : NEW_LINE INDENT cnt1 = 0 NEW_LINE cnt2 = 0 NEW_LINE cntno = 0 NEW_LINE for z in range ( n ) : NEW_LINE INDENT if a [ z ] [ j ] == 1 : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT if a [ z ] [ k ] == 1 : NEW_LINE INDENT cnt2 += 1 NEW_LINE DEDENT if a [ z ] [ j ] == 0 and a [ z ] [ k ] == 0 : NEW_LINE INDENT cntno += 1 NEW_LINE DEDENT DEDENT if cnt1 >= n // 2 and cnt2 >= n // 2 and cntno == 0 : NEW_LINE INDENT ans = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if ans : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT"}
{"id": "codejam_14_52", "sol": 0, "python_code": "def claim_differ ( hp , mydmg , twrdmg ) :\n    towShots = hp / twrdmg\n    hp %= twrdmg\n    if hp == 0 :\n        towShots -= 1\n        hp += twrdmg\n    myShots = hp / mydmg\n    hp %= mydmg\n    if hp > 0 :\n        myShots += 1\n        hp = 0\n    return towShots - myShots\ndef leave_differ ( hp , twrdmg ) :\n    towShots = hp / twrdmg\n    hp %= twrdmg\n    if hp > 0 :\n        towShots += 1\n        hp = 0\n    return towShots\nINF = 10 ** 12\ndef max_gain ( mem , hps , glds , mydmg , twrdmg , mstr , extra_shots ) :\n    if extra_shots < 0 :\n        return - INF\n    if len ( hps ) == mstr :\n        return 0\n    key = ( mstr , extra_shots )\n    if key in mem :\n        return mem [ key ]\n    cd = claim_differ ( hps [ mstr ] , mydmg , twrdmg )\n    res1 = glds [ mstr ] + max_gain ( mem , hps , glds , mydmg , twrdmg , mstr + 1 , extra_shots + cd )\n    ld = leave_differ ( hps [ mstr ] , twrdmg )\n    res2 = max_gain ( mem , hps , glds , mydmg , twrdmg , mstr + 1 , extra_shots + ld )\n    best = max ( res1 , res2 )\n    mem [ key ] = best\n    return best\nimport sys\ninfname = sys.argv [ 1 ]\nwith open ( infname ) as inf :\n    with open ( infname.replace ( '.in' , '.out' ) , 'w' ) as outf :\n        T = int ( inf.readline ( ) )\n        for t in range ( 1 , T + 1 ) :\n            mydmg , twrdmg , N = map ( int , inf.readline ( ).split ( ) )\n            hps , glds = [ ] , [ ]\n            for _ in range ( N ) :\n                hp , gld = map ( int , inf.readline ( ).split ( ) )\n                hps.append ( hp )\n                glds.append ( gld )\n            outf.write ( 'Case #{}: {}\\n'.format ( t , max_gain ( { } , hps , glds , mydmg , twrdmg , 0 , 1 ) ) )\n", "python_code_tokenized": "def claim_differ ( hp , mydmg , twrdmg ) : NEW_LINE INDENT towShots = hp / twrdmg NEW_LINE hp %= twrdmg NEW_LINE if hp == 0 : NEW_LINE INDENT towShots -= 1 NEW_LINE hp += twrdmg NEW_LINE DEDENT myShots = hp / mydmg NEW_LINE hp %= mydmg NEW_LINE if hp > 0 : NEW_LINE INDENT myShots += 1 NEW_LINE hp = 0 NEW_LINE DEDENT return towShots - myShots NEW_LINE DEDENT def leave_differ ( hp , twrdmg ) : NEW_LINE INDENT towShots = hp / twrdmg NEW_LINE hp %= twrdmg NEW_LINE if hp > 0 : NEW_LINE INDENT towShots += 1 NEW_LINE hp = 0 NEW_LINE DEDENT return towShots NEW_LINE DEDENT INF = 10 ** 12 NEW_LINE def max_gain ( mem , hps , glds , mydmg , twrdmg , mstr , extra_shots ) : NEW_LINE INDENT if extra_shots < 0 : NEW_LINE INDENT return - INF NEW_LINE DEDENT if len ( hps ) == mstr : NEW_LINE INDENT return 0 NEW_LINE DEDENT key = ( mstr , extra_shots ) NEW_LINE if key in mem : NEW_LINE INDENT return mem [ key ] NEW_LINE DEDENT cd = claim_differ ( hps [ mstr ] , mydmg , twrdmg ) NEW_LINE res1 = glds [ mstr ] + max_gain ( mem , hps , glds , mydmg , twrdmg , mstr + 1 , extra_shots + cd ) NEW_LINE ld = leave_differ ( hps [ mstr ] , twrdmg ) NEW_LINE res2 = max_gain ( mem , hps , glds , mydmg , twrdmg , mstr + 1 , extra_shots + ld ) NEW_LINE best = max ( res1 , res2 ) NEW_LINE mem [ key ] = best NEW_LINE return best NEW_LINE DEDENT import sys NEW_LINE infname = sys . argv [ 1 ] NEW_LINE with open ( infname ) as inf : NEW_LINE INDENT with open ( infname . replace ( ' . in ' , ' . out ' ) , ' w ' ) as outf : NEW_LINE INDENT T = int ( inf . readline ( ) ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT mydmg , twrdmg , N = map ( int , inf . readline ( ) . split ( ) ) NEW_LINE hps , glds = [ ] , [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT hp , gld = map ( int , inf . readline ( ) . split ( ) ) NEW_LINE hps . append ( hp ) NEW_LINE glds . append ( gld ) NEW_LINE DEDENT outf . write ( ' Case \u2581 # { } : \u2581 { } \\n ' . format ( t , max_gain ( { } , hps , glds , mydmg , twrdmg , 0 , 1 ) ) ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "aizu_p02498_A", "sol": 0, "python_code": "sentence = input ( )\nsentence = sentence.swapcase ( )\nprint ( sentence )\n", "python_code_tokenized": "sentence = input ( ) NEW_LINE sentence = sentence . swapcase ( ) NEW_LINE print ( sentence ) NEW_LINE"}
{"id": "atcoder_ARC064_D", "sol": 0, "python_code": "import sys\ninput = lambda : sys.stdin.readline ( ).rstrip ( )\nsys.setrecursionlimit ( max ( 1000 , 10 ** 9 ) )\nwrite = lambda x : sys.stdout.write ( x + \"\\n\" )\nn , k = list ( map ( int , input ( ).split ( ) ) )\nM = 10 ** 9 + 7\ndef fs ( n ) :\n    s = set ( )\n    for i in range ( 1 , int ( n ** 0.5 ) + 2 ) :\n        if n % i == 0 :\n            s.add ( i )\n            s.add ( n // i )\n    l = sorted ( list ( s ) )\n    return l\nds = fs ( n )\nm = len ( ds )\nnums = [ None ] * m\nfor i in range ( m ) :\n    val = pow ( k , ( ds [ i ] + 1 ) // 2 , M )\n    for j in range ( i ) :\n        if ds [ i ] % ds [ j ] == 0 :\n            val -= nums [ j ]\n            val %= M\n    nums [ i ] = val % M\nans = 0\ninv2 = pow ( 2 , M - 2 , M )\nfor i in range ( m ) :\n    if ds [ i ] % 2 == 0 :\n        ans += ds [ i ] * nums [ i ] * inv2\n    else :\n        ans += ds [ i ] * nums [ i ]\n    ans %= M\nprint ( ans % M )\n", "python_code_tokenized": "import sys NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE sys . setrecursionlimit ( max ( 1000 , 10 ** 9 ) ) NEW_LINE write = lambda x : sys . stdout . write ( x + \" \\n \" ) NEW_LINE n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE M = 10 ** 9 + 7 NEW_LINE def fs ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 1 , int ( n ** 0.5 ) + 2 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT s . add ( i ) NEW_LINE s . add ( n // i ) NEW_LINE DEDENT DEDENT l = sorted ( list ( s ) ) NEW_LINE return l NEW_LINE DEDENT ds = fs ( n ) NEW_LINE m = len ( ds ) NEW_LINE nums = [ None ] * m NEW_LINE for i in range ( m ) : NEW_LINE INDENT val = pow ( k , ( ds [ i ] + 1 ) // 2 , M ) NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ds [ i ] % ds [ j ] == 0 : NEW_LINE INDENT val -= nums [ j ] NEW_LINE val %= M NEW_LINE DEDENT DEDENT nums [ i ] = val % M NEW_LINE DEDENT ans = 0 NEW_LINE inv2 = pow ( 2 , M - 2 , M ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ds [ i ] % 2 == 0 : NEW_LINE INDENT ans += ds [ i ] * nums [ i ] * inv2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ds [ i ] * nums [ i ] NEW_LINE DEDENT ans %= M NEW_LINE DEDENT print ( ans % M ) NEW_LINE"}
{"id": "geeksforgeeks_4846_A", "sol": 0, "python_code": "class Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.prev = None\n        self.next = None\ndef push ( head_ref , new_data ) :\n    new_node = Node ( new_data )\n    new_node.next = head_ref\n    if head_ref != None :\n        head_ref.prev = new_node\n    head_ref = new_node\n    return head_ref\ndef makeOddNode ( head_ref , A , n ) :\n    ptr = head_ref\n    i = 0\n    while ptr != None :\n        next = ptr.next\n        if ptr.data % 2 == 0 :\n            ptr.data = A [ i ]\n            i += 1\n        ptr = next\ndef printList ( head ) :\n    while head != None :\n        print ( head.data , end = \" \" )\n        head = head.next\nif __name__ == \"__main__\" :\n    head = None\n    Arr = [ 3 , 5 , 23 , 17 , 1 ]\n    head = push ( head , 4 )\n    head = push ( head , 7 )\n    head = push ( head , 8 )\n    head = push ( head , 9 )\n    head = push ( head , 6 )\n    n = len ( Arr )\n    print ( \"Original List:\" , end = \" \" )\n    printList ( head )\n    print ( )\n    makeOddNode ( head , Arr , n )\n    print ( \"New odd List:\" , end = \" \" )\n    printList ( head )\n", "python_code_tokenized": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = head_ref NEW_LINE if head_ref != None : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def makeOddNode ( head_ref , A , n ) : NEW_LINE INDENT ptr = head_ref NEW_LINE i = 0 NEW_LINE while ptr != None : NEW_LINE INDENT next = ptr . next NEW_LINE if ptr . data % 2 == 0 : NEW_LINE INDENT ptr . data = A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ptr = next NEW_LINE DEDENT DEDENT def printList ( head ) : NEW_LINE INDENT while head != None : NEW_LINE INDENT print ( head . data , end = \" \u2581 \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT head = None NEW_LINE Arr = [ 3 , 5 , 23 , 17 , 1 ] NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 9 ) NEW_LINE head = push ( head , 6 ) NEW_LINE n = len ( Arr ) NEW_LINE print ( \" Original \u2581 List : \" , end = \" \u2581 \" ) NEW_LINE printList ( head ) NEW_LINE print ( ) NEW_LINE makeOddNode ( head , Arr , n ) NEW_LINE print ( \" New \u2581 odd \u2581 List : \" , end = \" \u2581 \" ) NEW_LINE printList ( head ) NEW_LINE DEDENT"}
{"id": "codeforces_808_B", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\ns = 0\nz = n - k + 1\nfor i in range ( n ) :\n    s += a [ i ] * min ( z , k , i + 1 , n - i )\nprint ( s / ( z ) )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = 0 NEW_LINE z = n - k + 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += a [ i ] * min ( z , k , i + 1 , n - i ) NEW_LINE DEDENT print ( s / ( z ) ) NEW_LINE"}
{"id": "geeksforgeeks_4925_A", "sol": 0, "python_code": "def countSubstrs ( str , i , j , n ) :\n    if ( n == 1 ) :\n        return 1\n    if ( n <= 0 ) :\n        return 0\n    res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) )\n    if ( str [ i ] == str [ j ] ) :\n        res += 1\n    return res\nstr = \"abcab\"\nn = len ( str )\nprint ( countSubstrs ( str , 0 , n - 1 , n ) )\n", "python_code_tokenized": "def countSubstrs ( str , i , j , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ) NEW_LINE if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT str = \" abcab \" NEW_LINE n = len ( str ) NEW_LINE print ( countSubstrs ( str , 0 , n - 1 , n ) ) NEW_LINE"}
{"id": "codeforces_621_A", "sol": 0, "python_code": "t = int ( input ( ) )\nl = sorted ( list ( map ( int , input ( ).split ( ) ) ) )\ns = sum ( l )\nif s % 2 == 0 :\n    print ( s )\nelse :\n    for i in l :\n        if i % 2 != 0 :\n            print ( s - i )\n            break\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE s = sum ( l ) NEW_LINE if s % 2 == 0 : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in l : NEW_LINE INDENT if i % 2 != 0 : NEW_LINE INDENT print ( s - i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_4380_A", "sol": 0, "python_code": "def solve ( A , B ) :\n    p = B / 2\n    M = int ( 4 * p )\n    N = 1\n    O = - 2 * A\n    Q = int ( A * A + 4 * p * p )\n    return [ M , N , O , Q ]\na = 1\nb = 1\nprint ( * solve ( a , b ) )\n", "python_code_tokenized": "def solve ( A , B ) : NEW_LINE INDENT p = B / 2 NEW_LINE M = int ( 4 * p ) NEW_LINE N = 1 NEW_LINE O = - 2 * A NEW_LINE Q = int ( A * A + 4 * p * p ) NEW_LINE return [ M , N , O , Q ] NEW_LINE DEDENT a = 1 NEW_LINE b = 1 NEW_LINE print ( * solve ( a , b ) ) NEW_LINE"}
{"id": "geeksforgeeks_1543_A", "sol": 0, "python_code": "def binarySearch ( arr , low , high , key ) :\n    if ( high < low ) :\n        return - 1\n    mid = ( low + high ) / 2\n    if ( key == arr [ int ( mid ) ] ) :\n        return mid\n    if ( key > arr [ int ( mid ) ] ) :\n        return binarySearch ( arr , ( mid + 1 ) , high , key )\n    return ( binarySearch ( arr , low , ( mid - 1 ) , key ) )\narr = [ 5 , 6 , 7 , 8 , 9 , 10 ]\nn = len ( arr )\nkey = 10\nprint ( \"Index:\" , int ( binarySearch ( arr , 0 , n , key ) ) )\n", "python_code_tokenized": "def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if ( key == arr [ int ( mid ) ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ int ( mid ) ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return ( binarySearch ( arr , low , ( mid - 1 ) , key ) ) NEW_LINE DEDENT arr = [ 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE key = 10 NEW_LINE print ( \" Index : \" , int ( binarySearch ( arr , 0 , n , key ) ) ) NEW_LINE"}
{"id": "codeforces_1111_B", "sol": 0, "python_code": "from sys import stdin , stdout\nint_in = lambda : int ( stdin.readline ( ) )\narr_in = lambda : [ int ( x ) for x in stdin.readline ( ).split ( ) ]\nmat_in = lambda rows : [ arr_in ( ) for _ in range ( rows ) ]\nstr_in = lambda : stdin.readline ( ).strip ( )\nout = lambda o : stdout.write ( \"{}\\n\".format ( o ) )\narr_out = lambda o : out ( \" \".join ( map ( str , o ) ) )\nbool_out = lambda o : out ( \"YES\" if o else \"NO\" )\ntests = lambda : range ( 1 , int_in ( ) + 1 )\ncase_out = lambda i , o : out ( \"Case #{}: {}\".format ( i , o ) )\ndef solve ( n , k , m , a ) :\n    sa = sorted ( a )\n    prefix_sum = [ 0 ]\n    for i in range ( n ) :\n        prefix_sum.append ( sa [ i ] + prefix_sum [ - 1 ] )\n    best = 0\n    for i in range ( min ( n , m + 1 ) ) :\n        total_power = prefix_sum [ n ] - prefix_sum [ i ]\n        remaining_heros = len ( sa ) - i\n        max_that_can_be_added = min ( m - i , remaining_heros * k )\n        best = max ( best , ( total_power + max_that_can_be_added ) / remaining_heros )\n    return best\nif __name__ == \"__main__\" :\n    n , k , m = arr_in ( )\n    a = arr_in ( )\n    out ( solve ( n , k , m , a ) )\n", "python_code_tokenized": "from sys import stdin , stdout NEW_LINE int_in = lambda : int ( stdin . readline ( ) ) NEW_LINE arr_in = lambda : [ int ( x ) for x in stdin . readline ( ) . split ( ) ] NEW_LINE mat_in = lambda rows : [ arr_in ( ) for _ in range ( rows ) ] NEW_LINE str_in = lambda : stdin . readline ( ) . strip ( ) NEW_LINE out = lambda o : stdout . write ( \" { } \\n \" . format ( o ) ) NEW_LINE arr_out = lambda o : out ( \" \u2581 \" . join ( map ( str , o ) ) ) NEW_LINE bool_out = lambda o : out ( \" YES \" if o else \" NO \" ) NEW_LINE tests = lambda : range ( 1 , int_in ( ) + 1 ) NEW_LINE case_out = lambda i , o : out ( \" Case \u2581 # { } : \u2581 { } \" . format ( i , o ) ) NEW_LINE def solve ( n , k , m , a ) : NEW_LINE INDENT sa = sorted ( a ) NEW_LINE prefix_sum = [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix_sum . append ( sa [ i ] + prefix_sum [ - 1 ] ) NEW_LINE DEDENT best = 0 NEW_LINE for i in range ( min ( n , m + 1 ) ) : NEW_LINE INDENT total_power = prefix_sum [ n ] - prefix_sum [ i ] NEW_LINE remaining_heros = len ( sa ) - i NEW_LINE max_that_can_be_added = min ( m - i , remaining_heros * k ) NEW_LINE best = max ( best , ( total_power + max_that_can_be_added ) / remaining_heros ) NEW_LINE DEDENT return best NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k , m = arr_in ( ) NEW_LINE a = arr_in ( ) NEW_LINE out ( solve ( n , k , m , a ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1729_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    n = int ( input ( ) )\n    s = input ( )\n    i = len ( s ) - 1\n    s1 = \"\"\n    while i != - 1 :\n        if s [ i ] == \"0\" :\n            s1 += chr ( 96 + int ( s [ i - 2 ] + s [ i - 1 ] ) )\n            i -= 3\n        else :\n            s1 += chr ( 96 + int ( s [ i ] ) )\n            i -= 1\n    print ( s1 [ : : - 1 ] )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = len ( s ) - 1 NEW_LINE s1 = \" \" NEW_LINE while i != - 1 : NEW_LINE INDENT if s [ i ] == \"0\" : NEW_LINE INDENT s1 += chr ( 96 + int ( s [ i - 2 ] + s [ i - 1 ] ) ) NEW_LINE i -= 3 NEW_LINE DEDENT else : NEW_LINE INDENT s1 += chr ( 96 + int ( s [ i ] ) ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT print ( s1 [ : : - 1 ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3579_A", "sol": 0, "python_code": "def maxOperations ( X , Y ) :\n    if ( X > Y ) :\n        return - 1 ;\n    diff = Y - X ;\n    if ( diff == 1 ) :\n        return - 1 ;\n    if ( diff % 2 == 0 ) :\n        return ( diff // 2 ) ;\n    return ( 1 + ( ( diff - 3 ) // 2 ) ) ;\nif __name__ == \"__main__\" :\n    X = 5 ; Y = 16 ;\n    print ( maxOperations ( X , Y ) ) ;\n", "python_code_tokenized": "def maxOperations ( X , Y ) : NEW_LINE INDENT if ( X > Y ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT diff = Y - X ; NEW_LINE if ( diff == 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( diff % 2 == 0 ) : NEW_LINE INDENT return ( diff // 2 ) ; NEW_LINE DEDENT return ( 1 + ( ( diff - 3 ) // 2 ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 5 ; Y = 16 ; NEW_LINE print ( maxOperations ( X , Y ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2540_A", "sol": 0, "python_code": "import math\ndef sumOfRange ( a , b ) :\n    i = ( a * ( a + 1 ) ) >> 1 ;\n    j = ( b * ( b + 1 ) ) >> 1 ;\n    return ( i - j ) ;\ndef sumofproduct ( n ) :\n    sum = 0 ;\n    root = int ( math.sqrt ( n ) ) ;\n    for i in range ( 1 , root + 1 ) :\n        up = int ( n / i ) ;\n        low = max ( int ( n / ( i + 1 ) ) , root ) ;\n        sum += ( i * sumOfRange ( up , low ) ) ;\n        sum += ( i * int ( n / i ) ) ;\n    return sum ;\nn = 10 ;\nprint ( sumofproduct ( n ) ) ;\n", "python_code_tokenized": "import math NEW_LINE def sumOfRange ( a , b ) : NEW_LINE INDENT i = ( a * ( a + 1 ) ) >> 1 ; NEW_LINE j = ( b * ( b + 1 ) ) >> 1 ; NEW_LINE return ( i - j ) ; NEW_LINE DEDENT def sumofproduct ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE root = int ( math . sqrt ( n ) ) ; NEW_LINE for i in range ( 1 , root + 1 ) : NEW_LINE INDENT up = int ( n / i ) ; NEW_LINE low = max ( int ( n / ( i + 1 ) ) , root ) ; NEW_LINE sum += ( i * sumOfRange ( up , low ) ) ; NEW_LINE sum += ( i * int ( n / i ) ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 10 ; NEW_LINE print ( sumofproduct ( n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_3207_A", "sol": 0, "python_code": "import numpy as np\ndef minimalLength ( a , n ) :\n    dp = np.ones ( ( n + 1 , n + 1 ) ) * - 1 ;\n    dp1 = [ 0 ] * n ;\n    for size in range ( 1 , n + 1 ) :\n        for i in range ( n - size + 1 ) :\n            j = i + size - 1 ;\n            if ( i == j ) :\n                dp [ i ] [ j ] = a [ i ] ;\n            else :\n                for k in range ( i , j ) :\n                    if ( dp [ i ] [ k ] != - 1 and dp [ i ] [ k ] == dp [ k + 1 ] [ j ] ) :\n                        dp [ i ] [ j ] = dp [ i ] [ k ] + 1 ;\n    for i in range ( n ) :\n        dp1 [ i ] = int ( 1e7 ) ;\n    for i in range ( n ) :\n        for j in range ( i + 1 ) :\n            if ( dp [ j ] [ i ] != - 1 ) :\n                if ( j == 0 ) :\n                    dp1 [ i ] = 1 ;\n                else :\n                    dp1 [ i ] = min ( dp1 [ i ] , dp1 [ j - 1 ] + 1 ) ;\n    return dp1 [ n - 1 ] ;\nif __name__ == \"__main__\" :\n    n = 7 ;\n    a = [ 3 , 3 , 4 , 4 , 4 , 3 , 3 ] ;\n    print ( minimalLength ( a , n ) ) ;\n", "python_code_tokenized": "import numpy as np NEW_LINE def minimalLength ( a , n ) : NEW_LINE INDENT dp = np . ones ( ( n + 1 , n + 1 ) ) * - 1 ; NEW_LINE dp1 = [ 0 ] * n ; NEW_LINE for size in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - size + 1 ) : NEW_LINE INDENT j = i + size - 1 ; NEW_LINE if ( i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = a [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT for k in range ( i , j ) : NEW_LINE INDENT if ( dp [ i ] [ k ] != - 1 and dp [ i ] [ k ] == dp [ k + 1 ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ k ] + 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT dp1 [ i ] = int ( 1e7 ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( dp [ j ] [ i ] != - 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp1 [ i ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT dp1 [ i ] = min ( dp1 [ i ] , dp1 [ j - 1 ] + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp1 [ n - 1 ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 7 ; NEW_LINE a = [ 3 , 3 , 4 , 4 , 4 , 3 , 3 ] ; NEW_LINE print ( minimalLength ( a , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3464_A", "sol": 0, "python_code": "def minLettersNeeded ( n ) :\n    if n % 26 == 0 :\n        return ( n // 26 )\n    else :\n        return ( ( n // 26 ) + 1 )\nn = 52\nprint ( minLettersNeeded ( n ) )\n", "python_code_tokenized": "def minLettersNeeded ( n ) : NEW_LINE INDENT if n % 26 == 0 : NEW_LINE INDENT return ( n // 26 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n // 26 ) + 1 ) NEW_LINE DEDENT DEDENT n = 52 NEW_LINE print ( minLettersNeeded ( n ) ) NEW_LINE"}
{"id": "atcoder_ABC137_C", "sol": 0, "python_code": "n = int ( input ( ) )\nwordlist = [ input ( ) for i in range ( n ) ]\nsortlist = [ ]\nfor i in range ( n ) :\n    a = list ( wordlist [ i ] )\n    a.sort ( )\n    sortlist.append ( a )\ncount = 0\nsortlist.sort ( )\ncheckword = \"\"\ncheck = 0\nfor i in range ( n ) :\n    a = sortlist.pop ( )\n    if checkword == a :\n        check += 1\n        count += check\n    else :\n        check = 0\n        checkword = a\nprint ( int ( count ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE wordlist = [ input ( ) for i in range ( n ) ] NEW_LINE sortlist = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = list ( wordlist [ i ] ) NEW_LINE a . sort ( ) NEW_LINE sortlist . append ( a ) NEW_LINE DEDENT count = 0 NEW_LINE sortlist . sort ( ) NEW_LINE checkword = \" \" NEW_LINE check = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = sortlist . pop ( ) NEW_LINE if checkword == a : NEW_LINE INDENT check += 1 NEW_LINE count += check NEW_LINE DEDENT else : NEW_LINE INDENT check = 0 NEW_LINE checkword = a NEW_LINE DEDENT DEDENT print ( int ( count ) ) NEW_LINE"}
{"id": "aizu_p02447_A", "sol": 0, "python_code": "ps = [ ]\nn = int ( input ( ) )\nfor i in range ( n ) :\n    x , y = map ( int , input ( ).split ( ) )\n    ps.append ( ( x , y ) )\nps.sort ( )\nfor i in ps : print ( * i )\n", "python_code_tokenized": "ps = [ ] NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ps . append ( ( x , y ) ) NEW_LINE DEDENT ps . sort ( ) NEW_LINE for i in ps : print ( * i ) NEW_LINE"}
{"id": "codeforces_238_A", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nn , m = map ( int , input ( ).split ( ) )\nM = 1000000009\nc = 1\nx = ( 2 ** m - 1 ) % M\nfor i in range ( n ) :\n    c = c * x % M\n    x -= 1\nprint ( c )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE M = 1000000009 NEW_LINE c = 1 NEW_LINE x = ( 2 ** m - 1 ) % M NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = c * x % M NEW_LINE x -= 1 NEW_LINE DEDENT print ( c ) NEW_LINE"}
{"id": "geeksforgeeks_4633_A", "sol": 0, "python_code": "def findSDSFunc ( n ) :\n    DP = [ 0 ] * ( n + 1 )\n    DP [ 0 ] = 0\n    DP [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        if ( int ( i % 2 ) == 0 ) :\n            DP [ i ] = DP [ int ( i / 2 ) ]\n        else :\n            DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [ int ( ( i + 1 ) / 2 ) ] )\n    return DP [ n ]\nn = 15\nprint ( findSDSFunc ( n ) )\n", "python_code_tokenized": "def findSDSFunc ( n ) : NEW_LINE INDENT DP = [ 0 ] * ( n + 1 ) NEW_LINE DP [ 0 ] = 0 NEW_LINE DP [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( int ( i % 2 ) == 0 ) : NEW_LINE INDENT DP [ i ] = DP [ int ( i / 2 ) ] NEW_LINE DEDENT else : NEW_LINE INDENT DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [ int ( ( i + 1 ) / 2 ) ] ) NEW_LINE DEDENT DEDENT return DP [ n ] NEW_LINE DEDENT n = 15 NEW_LINE print ( findSDSFunc ( n ) ) NEW_LINE"}
{"id": "projecteuler_p065_A", "sol": 0, "python_code": "def compute ( ) :\n    numer = 1\n    denom = 0\n    for i in reversed ( range ( 100 ) ) :\n        numer , denom = e_contfrac_term ( i ) * numer + denom , numer\n    ans = sum ( int ( c ) for c in str ( numer ) )\n    return str ( ans )\ndef e_contfrac_term ( i ) :\n    if i == 0 :\n        return 2\n    elif i % 3 == 2 :\n        return i // 3 * 2 + 2\n    else :\n        return 1\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT numer = 1 NEW_LINE denom = 0 NEW_LINE for i in reversed ( range ( 100 ) ) : NEW_LINE INDENT numer , denom = e_contfrac_term ( i ) * numer + denom , numer NEW_LINE DEDENT ans = sum ( int ( c ) for c in str ( numer ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def e_contfrac_term ( i ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif i % 3 == 2 : NEW_LINE INDENT return i // 3 * 2 + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_494_A", "sol": 0, "python_code": "def treasure ( ) :\n    s = input ( )\n    n = len ( s )\n    pos = [ ]\n    cur = 0\n    left = [ ]\n    for i in range ( n ) :\n        if s [ i ] == '(' :\n            cur += 1\n        elif s [ i ] == ')' :\n            cur -= 1\n        else :\n            cur -= 1\n            pos.append ( i )\n        left.append ( cur )\n        if cur < 0 :\n            print ( - 1 )\n            return\n    ans = [ 1 ] * len ( pos )\n    leftNum , rightNum = s.count ( '(' ) , s.count ( ')' )\n    need = leftNum - rightNum\n    ans [ - 1 ] = need - ( len ( pos ) - 1 )\n    if ans [ - 1 ] > left [ pos [ - 1 ] ] + 1 :\n        print ( - 1 )\n        return\n    for i in range ( pos [ - 1 ] + 1 , n ) :\n        if left [ i ] < ans [ - 1 ] - 1 :\n            print ( - 1 )\n            return\n    for e in ans :\n        print ( e )\nif __name__ == '__main__' :\n    treasure ( )\n", "python_code_tokenized": "def treasure ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE n = len ( s ) NEW_LINE pos = [ ] NEW_LINE cur = 0 NEW_LINE left = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' ( ' : NEW_LINE INDENT cur += 1 NEW_LINE DEDENT elif s [ i ] == ' ) ' : NEW_LINE INDENT cur -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cur -= 1 NEW_LINE pos . append ( i ) NEW_LINE DEDENT left . append ( cur ) NEW_LINE if cur < 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT ans = [ 1 ] * len ( pos ) NEW_LINE leftNum , rightNum = s . count ( ' ( ' ) , s . count ( ' ) ' ) NEW_LINE need = leftNum - rightNum NEW_LINE ans [ - 1 ] = need - ( len ( pos ) - 1 ) NEW_LINE if ans [ - 1 ] > left [ pos [ - 1 ] ] + 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( pos [ - 1 ] + 1 , n ) : NEW_LINE INDENT if left [ i ] < ans [ - 1 ] - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT for e in ans : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT treasure ( ) NEW_LINE DEDENT"}
{"id": "leetcode_448_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def findDisappearedNumbers ( self , nums ) :\n        res = [ ]\n        if nums :\n            n = len ( nums )\n            for i in range ( n ) :\n                val = abs ( nums [ i ] ) - 1\n                if nums [ val ] > 0 :\n                    nums [ val ] = - nums [ val ]\n            for i in range ( n ) :\n                if nums [ i ] > 0 :\n                    res.append ( i + 1 )\n        return res\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def findDisappearedNumbers ( self , nums ) : NEW_LINE INDENT res = [ ] NEW_LINE if nums : NEW_LINE INDENT n = len ( nums ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = abs ( nums [ i ] ) - 1 NEW_LINE if nums [ val ] > 0 : NEW_LINE INDENT nums [ val ] = - nums [ val ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if nums [ i ] > 0 : NEW_LINE INDENT res . append ( i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3891_A", "sol": 0, "python_code": "class Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.prev = None\n        self.next = None\ndef sort ( head ) :\n    if head == None or head.next == None :\n        return head\n    front = head\n    last = head\n    res = Node ( None )\n    resEnd = res\n    while last.next != None :\n        last = last.next\n    while front != last :\n        if last.data <= front.data :\n            resEnd.next = last\n            next = last.prev\n            last.prev.next = None\n            last.prev = resEnd\n            last = next\n            resEnd = resEnd.next\n        else :\n            resEnd.next = front\n            next = front.next\n            front.next = None\n            front.prev = resEnd\n            front = next\n            resEnd = resEnd.next\n    resEnd.next = front\n    front.prev = resEnd\n    return res.next\ndef push ( head_ref , new_data ) :\n    new_node = Node ( new_data )\n    new_node.prev = None\n    new_node.next = head_ref\n    if head_ref != None :\n        head_ref.prev = new_node\n    head_ref = new_node\n    return head_ref\ndef printList ( head ) :\n    if head == None :\n        print ( \"Doubly Linked list empty\" )\n    while head != None :\n        print ( head.data , end = \" \" )\n        head = head.next\nif __name__ == '__main__' :\n    head = None\n    head = push ( head , 1 )\n    head = push ( head , 4 )\n    head = push ( head , 6 )\n    head = push ( head , 10 )\n    head = push ( head , 12 )\n    head = push ( head , 7 )\n    head = push ( head , 5 )\n    head = push ( head , 2 )\n    print ( \"Original Doubly linked list:\" )\n    printList ( head )\n    head = sort ( head )\n    print ( \"\\nDoubly linked list after sorting:\" )\n    printList ( head )\n", "python_code_tokenized": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def sort ( head ) : NEW_LINE INDENT if head == None or head . next == None : NEW_LINE INDENT return head NEW_LINE DEDENT front = head NEW_LINE last = head NEW_LINE res = Node ( None ) NEW_LINE resEnd = res NEW_LINE while last . next != None : NEW_LINE INDENT last = last . next NEW_LINE DEDENT while front != last : NEW_LINE INDENT if last . data <= front . data : NEW_LINE INDENT resEnd . next = last NEW_LINE next = last . prev NEW_LINE last . prev . next = None NEW_LINE last . prev = resEnd NEW_LINE last = next NEW_LINE resEnd = resEnd . next NEW_LINE DEDENT else : NEW_LINE INDENT resEnd . next = front NEW_LINE next = front . next NEW_LINE front . next = None NEW_LINE front . prev = resEnd NEW_LINE front = next NEW_LINE resEnd = resEnd . next NEW_LINE DEDENT DEDENT resEnd . next = front NEW_LINE front . prev = resEnd NEW_LINE return res . next NEW_LINE DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . prev = None NEW_LINE new_node . next = head_ref NEW_LINE if head_ref != None : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT if head == None : NEW_LINE INDENT print ( \" Doubly \u2581 Linked \u2581 list \u2581 empty \" ) NEW_LINE DEDENT while head != None : NEW_LINE INDENT print ( head . data , end = \" \u2581 \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 1 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 10 ) NEW_LINE head = push ( head , 12 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 2 ) NEW_LINE print ( \" Original \u2581 Doubly \u2581 linked \u2581 list : \" ) NEW_LINE printList ( head ) NEW_LINE head = sort ( head ) NEW_LINE print ( \" \\n Doubly \u2581 linked \u2581 list \u2581 after \u2581 sorting : \" ) NEW_LINE printList ( head ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_689_A", "sol": 0, "python_code": "def maxProduct ( arr , n ) :\n    ans = - 1\n    for i in range ( n - 2 ) :\n        for j in range ( i + 1 , n - 1 ) :\n            for k in range ( j + 1 , n ) :\n                if ( arr [ i ] < arr [ j ] and arr [ j ] > arr [ k ] ) :\n                    ans = max ( ans , arr [ i ] * arr [ j ] * arr [ k ] )\n    return ans\nif __name__ == '__main__' :\n    arr = [ 1 , 8 , 3 , 7 ]\n    n = len ( arr )\n    print ( maxProduct ( arr , n ) )\n", "python_code_tokenized": "def maxProduct ( arr , n ) : NEW_LINE INDENT ans = - 1 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] and arr [ j ] > arr [ k ] ) : NEW_LINE INDENT ans = max ( ans , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 8 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxProduct ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5199_A", "sol": 0, "python_code": "def XorSum ( arr , n ) :\n    result = 0\n    for i in range ( n ) :\n        if ( arr [ i ] % 2 != 0 ) :\n            result += arr [ i ]\n    return result\narr = [ 1 , 2 , 6 , 3 , 4 , 5 ]\nn = len ( arr )\nprint ( XorSum ( arr , n ) )\n", "python_code_tokenized": "def XorSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( XorSum ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3231_A", "sol": 0, "python_code": "def maxProduct ( arr , n ) :\n    minVal = arr [ 0 ]\n    maxVal = arr [ 0 ]\n    maxProduct = arr [ 0 ]\n    for i in range ( 1 , n , 1 ) :\n        if ( arr [ i ] < 0 ) :\n            temp = maxVal\n            maxVal = minVal\n            minVal = temp\n        maxVal = max ( arr [ i ] , maxVal * arr [ i ] )\n        minVal = min ( arr [ i ] , minVal * arr [ i ] )\n        maxProduct = max ( maxProduct , maxVal )\n    return maxProduct\nif __name__ == '__main__' :\n    arr = [ - 1 , - 3 , - 10 , 0 , 60 ]\n    n = len ( arr )\n    print ( \"Maximum Subarray product is\" , maxProduct ( arr , n ) )\n", "python_code_tokenized": "def maxProduct ( arr , n ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE maxVal = arr [ 0 ] NEW_LINE maxProduct = arr [ 0 ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT temp = maxVal NEW_LINE maxVal = minVal NEW_LINE minVal = temp NEW_LINE DEDENT maxVal = max ( arr [ i ] , maxVal * arr [ i ] ) NEW_LINE minVal = min ( arr [ i ] , minVal * arr [ i ] ) NEW_LINE maxProduct = max ( maxProduct , maxVal ) NEW_LINE DEDENT return maxProduct NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ - 1 , - 3 , - 10 , 0 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum \u2581 Subarray \u2581 product \u2581 is \" , maxProduct ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3196_A", "sol": 0, "python_code": "def isHeap ( arr , i , n ) :\n    if i > int ( ( n - 2 ) / 2 ) :\n        return True\n    if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) :\n        return True\n    return False\nif __name__ == '__main__' :\n    arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ]\n    n = len ( arr ) - 1\n    if isHeap ( arr , 0 , n ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def isHeap ( arr , i , n ) : NEW_LINE INDENT if i > int ( ( n - 2 ) / 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] NEW_LINE n = len ( arr ) - 1 NEW_LINE if isHeap ( arr , 0 , n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3197_A", "sol": 0, "python_code": "def isHeap ( arr , n ) :\n    for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) :\n        if arr [ 2 * i + 1 ] > arr [ i ] :\n            return False\n        if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) :\n            return False\n    return True\nif __name__ == '__main__' :\n    arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ]\n    n = len ( arr )\n    if isHeap ( arr , n ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def isHeap ( arr , n ) : NEW_LINE INDENT for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) : NEW_LINE INDENT if arr [ 2 * i + 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE if isHeap ( arr , n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p02449_A", "sol": 0, "python_code": "import itertools\nn = input ( ) ;\na = tuple ( map ( int , input ( ).split ( ) ) )\np = sorted ( list ( itertools.permutations ( a ) ) )\ni = p.index ( a )\nif i > 0 :\n    print ( * p [ i - 1 ] )\nprint ( * p [ i ] )\nif i < len ( p ) - 1 :\n    print ( * p [ i + 1 ] )\n", "python_code_tokenized": "import itertools NEW_LINE n = input ( ) ; NEW_LINE a = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p = sorted ( list ( itertools . permutations ( a ) ) ) NEW_LINE i = p . index ( a ) NEW_LINE if i > 0 : NEW_LINE INDENT print ( * p [ i - 1 ] ) NEW_LINE DEDENT print ( * p [ i ] ) NEW_LINE if i < len ( p ) - 1 : NEW_LINE INDENT print ( * p [ i + 1 ] ) NEW_LINE DEDENT"}
{"id": "aizu_p02499_A", "sol": 0, "python_code": "s = \"\"\nwhile ( True ) :\n    try :\n        a = raw_input ( )\n        s += a\n    except EOFError :\n        break\ncount = [ 0 ] * 26\nfor i in range ( len ( s ) ) :\n    if ( 'a' <= s [ i ] <= 'z' ) :\n        count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1\n    elif ( 'A' <= s [ i ] <= 'Z' ) :\n        count [ ord ( s [ i ] ) - ord ( 'A' ) ] += 1\nfor i in range ( len ( count ) ) :\n    print ( \"%c : %d\" % ( chr ( i + ord ( 'a' ) ) , count [ i ] ) )\n", "python_code_tokenized": "s = \" \" NEW_LINE while ( True ) : NEW_LINE INDENT try : NEW_LINE INDENT a = raw_input ( ) NEW_LINE s += a NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT count = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ' a ' <= s [ i ] <= ' z ' ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT elif ( ' A ' <= s [ i ] <= ' Z ' ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' A ' ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( count ) ) : NEW_LINE INDENT print ( \" % c \u2581 : \u2581 % d \" % ( chr ( i + ord ( ' a ' ) ) , count [ i ] ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00002_A", "sol": 0, "python_code": "while True :\n    try : print ( len ( str ( sum ( map ( int , input ( ).split ( ) ) ) ) ) )\n    except : break\n", "python_code_tokenized": "while True : NEW_LINE INDENT try : print ( len ( str ( sum ( map ( int , input ( ) . split ( ) ) ) ) ) ) NEW_LINE except : break NEW_LINE DEDENT"}
{"id": "codeforces_8_A", "sol": 0, "python_code": "s , a , b = input ( ) , input ( ) , input ( )\nrs = s [ : : - 1 ]\na1 = s.find ( a ) ; a2 = rs.find ( a )\nif a1 < 0 :\n    if a2 < 0 : print ( 'fantasy' ) ; exit ( )\n    b2 = rs [ a2 + len ( a ) : ].find ( b )\n    print ( 'fantasy' if b2 < 0 else 'backward' )\nelse :\n    b1 = s [ a1 + len ( a ) : ].find ( b )\n    if a2 < 0 : print ( 'fantasy' if b1 < 0 else 'forward' ) ; exit ( )\n    b2 = rs [ a2 + len ( a ) : ].find ( b )\n    if b1 < 0 : print ( 'fantasy' if b2 < 0 else 'backward' )\n    else : print ( 'forward' if b2 < 0 else 'both' )\n", "python_code_tokenized": "s , a , b = input ( ) , input ( ) , input ( ) NEW_LINE rs = s [ : : - 1 ] NEW_LINE a1 = s . find ( a ) ; a2 = rs . find ( a ) NEW_LINE if a1 < 0 : NEW_LINE INDENT if a2 < 0 : print ( ' fantasy ' ) ; exit ( ) NEW_LINE b2 = rs [ a2 + len ( a ) : ] . find ( b ) NEW_LINE print ( ' fantasy ' if b2 < 0 else ' backward ' ) NEW_LINE DEDENT else : NEW_LINE INDENT b1 = s [ a1 + len ( a ) : ] . find ( b ) NEW_LINE if a2 < 0 : print ( ' fantasy ' if b1 < 0 else ' forward ' ) ; exit ( ) NEW_LINE b2 = rs [ a2 + len ( a ) : ] . find ( b ) NEW_LINE if b1 < 0 : print ( ' fantasy ' if b2 < 0 else ' backward ' ) NEW_LINE else : print ( ' forward ' if b2 < 0 else ' both ' ) NEW_LINE DEDENT"}
{"id": "aizu_p00225_A", "sol": 0, "python_code": "def searchnode ( i , u , path ) :\n    r = 1\n    u [ i ] = 1\n    for j in range ( 26 ) :\n        if path [ i ] [ j ] and ( not u [ j ] ) :\n            r += searchnode ( j , u , path )\n    return r\nwhile ( True ) :\n    n = int ( input ( ) )\n    if not n : break\n    strs = list ( map ( lambda x : [ x [ 0 ] , x [ - 1 ] ] , [ input ( ) for i in range ( n ) ] ) )\n    ss , ee = [ 0 ] * 26 , [ 0 ] * 26\n    path = [ [ 0 ] * 26 for _ in range ( 27 ) ]\n    u = [ 0 ] * 26\n    for s , e in strs :\n        ss [ ord ( s ) - ord ( 'a' ) ] += 1\n        ee [ ord ( e ) - ord ( 'a' ) ] += 1\n        path [ ord ( s ) - ord ( 'a' ) ] [ ord ( e ) - ord ( 'a' ) ] += 1\n    if [ 1 for s1 , e1 in zip ( ss , ee ) if s1 - e1 ] :\n        print ( \"NG\" )\n        continue\n    print ( \"OK\" if len ( [ 1 for s in ss if s ] ) == searchnode ( ord ( s ) - ord ( 'a' ) , u , path ) else \"NG\" )\n", "python_code_tokenized": "def searchnode ( i , u , path ) : NEW_LINE INDENT r = 1 NEW_LINE u [ i ] = 1 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT if path [ i ] [ j ] and ( not u [ j ] ) : NEW_LINE INDENT r += searchnode ( j , u , path ) NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT while ( True ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if not n : break NEW_LINE strs = list ( map ( lambda x : [ x [ 0 ] , x [ - 1 ] ] , [ input ( ) for i in range ( n ) ] ) ) NEW_LINE ss , ee = [ 0 ] * 26 , [ 0 ] * 26 NEW_LINE path = [ [ 0 ] * 26 for _ in range ( 27 ) ] NEW_LINE u = [ 0 ] * 26 NEW_LINE for s , e in strs : NEW_LINE INDENT ss [ ord ( s ) - ord ( ' a ' ) ] += 1 NEW_LINE ee [ ord ( e ) - ord ( ' a ' ) ] += 1 NEW_LINE path [ ord ( s ) - ord ( ' a ' ) ] [ ord ( e ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if [ 1 for s1 , e1 in zip ( ss , ee ) if s1 - e1 ] : NEW_LINE INDENT print ( \" NG \" ) NEW_LINE continue NEW_LINE DEDENT print ( \" OK \" if len ( [ 1 for s in ss if s ] ) == searchnode ( ord ( s ) - ord ( ' a ' ) , u , path ) else \" NG \" ) NEW_LINE DEDENT"}
{"id": "codeforces_218_B", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nmaxa = [ ]\nmini = [ ]\nma = 0\nmi = 0\na = list ( map ( int , input ( ).split ( ) ) )\nfor i in a :\n    maxa.append ( i )\n    mini.append ( i )\nfor x in range ( n ) :\n    ind = maxa.index ( max ( maxa ) )\n    ma += maxa [ ind ]\n    maxa [ ind ] -= 1\nfor y in range ( n ) :\n    imd = mini.index ( min ( mini ) )\n    if mini [ imd ] == 0 :\n        mini.pop ( imd )\n    imd = mini.index ( min ( mini ) )\n    if mini [ imd ] > 0 :\n        mi += mini [ imd ]\n        mini [ imd ] -= 1\nprint ( ma , mi )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE maxa = [ ] NEW_LINE mini = [ ] NEW_LINE ma = 0 NEW_LINE mi = 0 NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in a : NEW_LINE INDENT maxa . append ( i ) NEW_LINE mini . append ( i ) NEW_LINE DEDENT for x in range ( n ) : NEW_LINE INDENT ind = maxa . index ( max ( maxa ) ) NEW_LINE ma += maxa [ ind ] NEW_LINE maxa [ ind ] -= 1 NEW_LINE DEDENT for y in range ( n ) : NEW_LINE INDENT imd = mini . index ( min ( mini ) ) NEW_LINE if mini [ imd ] == 0 : NEW_LINE INDENT mini . pop ( imd ) NEW_LINE DEDENT imd = mini . index ( min ( mini ) ) NEW_LINE if mini [ imd ] > 0 : NEW_LINE INDENT mi += mini [ imd ] NEW_LINE mini [ imd ] -= 1 NEW_LINE DEDENT DEDENT print ( ma , mi ) NEW_LINE"}
{"id": "geeksforgeeks_2707_A", "sol": 0, "python_code": "def removeSpecialCharacter ( s ) :\n    t = \"\"\n    for i in s :\n        if ( i >= 'A' and i <= 'Z' ) or ( i >= 'a' and i <= 'z' ) :\n            t += i\n    print ( t )\ns = \"$Gee*k;s..fo, r'Ge^eks?\"\nremoveSpecialCharacter ( s )\n", "python_code_tokenized": "def removeSpecialCharacter ( s ) : NEW_LINE INDENT t = \" \" NEW_LINE for i in s : NEW_LINE INDENT if ( i >= ' A ' and i <= ' Z ' ) or ( i >= ' a ' and i <= ' z ' ) : NEW_LINE INDENT t += i NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE DEDENT s = \" $ Gee * k ; s . . fo , \u2581 r ' Ge ^ eks ? \" NEW_LINE removeSpecialCharacter ( s ) NEW_LINE"}
{"id": "codeforces_825_B", "sol": 0, "python_code": "s = [ ]\ndef check ( ) :\n    for i in range ( 10 ) :\n        for j in range ( 10 ) :\n            if j + 4 < 10 :\n                th = ''\n                for k in range ( 5 ) :\n                    th += s [ i ] [ j + k ]\n                if th == 'XXXXX' :\n                    return True\n    for i in range ( 10 ) :\n        for j in range ( 10 ) :\n            if i + 4 < 10 :\n                th = ''\n                for k in range ( 5 ) :\n                    th += s [ i + k ] [ j ]\n                if th == 'XXXXX' :\n                    return True\n    for i in range ( 10 ) :\n        for j in range ( 10 ) :\n            if i + 4 < 10 and j + 4 < 10 :\n                th = ''\n                for k in range ( 5 ) :\n                    th += s [ i + k ] [ j + k ]\n                if th == 'XXXXX' :\n                    return True\n    for i in range ( 10 ) :\n        for j in range ( 10 ) :\n            if i + 4 < 10 and j - 4 >= 0 :\n                th = ''\n                for k in range ( 5 ) :\n                    th += s [ i + k ] [ j - k ]\n                if th == 'XXXXX' :\n                    return True\n    return False\nfor i in range ( 10 ) :\n    s.append ( list ( input ( ) ) )\nflag = False\nif check ( ) :\n    flag = True\nfor i in range ( 10 ) :\n    for j in range ( 10 ) :\n        if s [ i ] [ j ] == '.' :\n            s [ i ] [ j ] = 'X'\n            if check ( ) :\n                flag = True\n            s [ i ] [ j ] = '.'\nif flag :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "s = [ ] NEW_LINE def check ( ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if j + 4 < 10 : NEW_LINE INDENT th = ' ' NEW_LINE for k in range ( 5 ) : NEW_LINE INDENT th += s [ i ] [ j + k ] NEW_LINE DEDENT if th == ' XXXXX ' : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if i + 4 < 10 : NEW_LINE INDENT th = ' ' NEW_LINE for k in range ( 5 ) : NEW_LINE INDENT th += s [ i + k ] [ j ] NEW_LINE DEDENT if th == ' XXXXX ' : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if i + 4 < 10 and j + 4 < 10 : NEW_LINE INDENT th = ' ' NEW_LINE for k in range ( 5 ) : NEW_LINE INDENT th += s [ i + k ] [ j + k ] NEW_LINE DEDENT if th == ' XXXXX ' : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if i + 4 < 10 and j - 4 >= 0 : NEW_LINE INDENT th = ' ' NEW_LINE for k in range ( 5 ) : NEW_LINE INDENT th += s [ i + k ] [ j - k ] NEW_LINE DEDENT if th == ' XXXXX ' : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT s . append ( list ( input ( ) ) ) NEW_LINE DEDENT flag = False NEW_LINE if check ( ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if s [ i ] [ j ] == ' . ' : NEW_LINE INDENT s [ i ] [ j ] = ' X ' NEW_LINE if check ( ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT s [ i ] [ j ] = ' . ' NEW_LINE DEDENT DEDENT DEDENT if flag : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1726_B", "sol": 0, "python_code": "import io , os\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\ndef main ( t ) :\n    n , k = map ( int , input ( ).split ( ) )\n    if k < n :\n        print ( \"No\" )\n        return\n    if n % 2 == 1 :\n        arr = [ 1 ] * ( n - 1 ) + [ k - n + 1 ]\n    else :\n        if k % 2 == 0 :\n            arr = [ 1 ] * ( n - 2 ) + [ ( k - n + 2 ) // 2 ] * 2\n        else :\n            arr = [ - 1 ]\n    if arr [ 0 ] == - 1 :\n        print ( \"No\" )\n    else :\n        print ( \"Yes\" )\n        print ( * arr )\nT = int ( input ( ) )\nt = 1\nwhile t <= T :\n    main ( t )\n    t += 1\n", "python_code_tokenized": "import io , os NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE def main ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k < n : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT if n % 2 == 1 : NEW_LINE INDENT arr = [ 1 ] * ( n - 1 ) + [ k - n + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT arr = [ 1 ] * ( n - 2 ) + [ ( k - n + 2 ) // 2 ] * 2 NEW_LINE DEDENT else : NEW_LINE INDENT arr = [ - 1 ] NEW_LINE DEDENT DEDENT if arr [ 0 ] == - 1 : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE print ( * arr ) NEW_LINE DEDENT DEDENT T = int ( input ( ) ) NEW_LINE t = 1 NEW_LINE while t <= T : NEW_LINE INDENT main ( t ) NEW_LINE t += 1 NEW_LINE DEDENT"}
{"id": "atcoder_AGC041_C", "sol": 0, "python_code": "a3 = \"\"\"\naab\nb.b\nbaa\n\"\"\"\na6 = \"\"\"\naabccd\nb.bd.d\nbaadcc\nccdaab\nd.db.b\ndccbaa\n\"\"\"\ng4 = \"\"\"\naaca\nbbca\ncabb\ncacc\n\"\"\"\ng4 = list ( map ( list , g4.split ( ) ) )\ng5 = \"\"\"\naabba\nbcc.a\nb..cb\na..cb\nabbaa\n\"\"\"\ng5 = list ( map ( list , g5.split ( ) ) )\ng7 = \"\"\"\ncaabb..\ncb..cc.\naba....\na.a..aa\nc..a..b\nc..a..b\n.aaccaa\n\"\"\"\ng7 = list ( map ( list , g7.split ( ) ) )\ndef main ( ) :\n    N = int ( input ( ) )\n    if N == 2 : print ( - 1 )\n    elif N == 3 : print ( \"\\n\".join ( a3.split ( ) ) )\n    elif N == 6 : print ( \"\\n\".join ( a6.split ( ) ) )\n    else :\n        x = [ [ '.' ] * N for i in range ( N ) ]\n        for v4 in range ( N // 4 + 1 ) :\n            for v5 in range ( ( N - v4 * 4 ) // 5 + 1 ) :\n                v7 = ( N - v4 * 4 - v5 * 5 ) // 7\n                if v4 * 4 + v5 * 5 + v7 * 7 != N : continue\n                idx = 0\n                for i in range ( v4 ) :\n                    for j in range ( 4 ) :\n                        x [ idx + j ] [ idx : idx + 4 ] = g4 [ j ]\n                    idx += 4\n                for i in range ( v5 ) :\n                    for j in range ( 5 ) :\n                        x [ idx + j ] [ idx : idx + 5 ] = g5 [ j ]\n                    idx += 5\n                for i in range ( v7 ) :\n                    for j in range ( 7 ) :\n                        x [ idx + j ] [ idx : idx + 7 ] = g7 [ j ]\n                    idx += 7\n                for q in x :\n                    print ( ''.join ( q ) )\n                return\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "a3 = \"\"\" STRNEWLINE aab STRNEWLINE b . b STRNEWLINE baa STRNEWLINE \"\"\" NEW_LINE a6 = \"\"\" STRNEWLINE aabccd STRNEWLINE b . bd . d STRNEWLINE baadcc STRNEWLINE ccdaab STRNEWLINE d . db . b STRNEWLINE dccbaa STRNEWLINE \"\"\" NEW_LINE g4 = \"\"\" STRNEWLINE aaca STRNEWLINE bbca STRNEWLINE cabb STRNEWLINE cacc STRNEWLINE \"\"\" NEW_LINE g4 = list ( map ( list , g4 . split ( ) ) ) NEW_LINE g5 = \"\"\" STRNEWLINE aabba STRNEWLINE bcc . a STRNEWLINE b . . cb STRNEWLINE a . . cb STRNEWLINE abbaa STRNEWLINE \"\"\" NEW_LINE g5 = list ( map ( list , g5 . split ( ) ) ) NEW_LINE g7 = \"\"\" STRNEWLINE caabb . . STRNEWLINE cb . . cc . STRNEWLINE aba . . . . STRNEWLINE a . a . . aa STRNEWLINE c . . a . . b STRNEWLINE c . . a . . b STRNEWLINE . aaccaa STRNEWLINE \"\"\" NEW_LINE g7 = list ( map ( list , g7 . split ( ) ) ) NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 2 : print ( - 1 ) NEW_LINE elif N == 3 : print ( \" \\n \" . join ( a3 . split ( ) ) ) NEW_LINE elif N == 6 : print ( \" \\n \" . join ( a6 . split ( ) ) ) NEW_LINE else : NEW_LINE INDENT x = [ [ ' . ' ] * N for i in range ( N ) ] NEW_LINE for v4 in range ( N // 4 + 1 ) : NEW_LINE INDENT for v5 in range ( ( N - v4 * 4 ) // 5 + 1 ) : NEW_LINE INDENT v7 = ( N - v4 * 4 - v5 * 5 ) // 7 NEW_LINE if v4 * 4 + v5 * 5 + v7 * 7 != N : continue NEW_LINE idx = 0 NEW_LINE for i in range ( v4 ) : NEW_LINE INDENT for j in range ( 4 ) : NEW_LINE INDENT x [ idx + j ] [ idx : idx + 4 ] = g4 [ j ] NEW_LINE DEDENT idx += 4 NEW_LINE DEDENT for i in range ( v5 ) : NEW_LINE INDENT for j in range ( 5 ) : NEW_LINE INDENT x [ idx + j ] [ idx : idx + 5 ] = g5 [ j ] NEW_LINE DEDENT idx += 5 NEW_LINE DEDENT for i in range ( v7 ) : NEW_LINE INDENT for j in range ( 7 ) : NEW_LINE INDENT x [ idx + j ] [ idx : idx + 7 ] = g7 [ j ] NEW_LINE DEDENT idx += 7 NEW_LINE DEDENT for q in x : NEW_LINE INDENT print ( ' ' . join ( q ) ) NEW_LINE DEDENT return NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_612_A", "sol": 0, "python_code": "from sys import exit\nn , p , q = map ( int , input ( ).split ( ) )\ns = input ( )\nnum1 = n // p + 1\nnum2 = n // q + 1\nfor i in range ( num1 ) :\n    for j in range ( num2 ) :\n        if i * p + j * q == n :\n            print ( i + j )\n            for c in range ( 0 , i * p , p ) :\n                print ( s [ c : c + p ] )\n            for c in range ( i * p , n , q ) :\n                print ( s [ c : c + q ] )\n            exit ( )\nprint ( - 1 )\n", "python_code_tokenized": "from sys import exit NEW_LINE n , p , q = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE num1 = n // p + 1 NEW_LINE num2 = n // q + 1 NEW_LINE for i in range ( num1 ) : NEW_LINE INDENT for j in range ( num2 ) : NEW_LINE INDENT if i * p + j * q == n : NEW_LINE INDENT print ( i + j ) NEW_LINE for c in range ( 0 , i * p , p ) : NEW_LINE INDENT print ( s [ c : c + p ] ) NEW_LINE DEDENT for c in range ( i * p , n , q ) : NEW_LINE INDENT print ( s [ c : c + q ] ) NEW_LINE DEDENT exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE"}
{"id": "codeforces_1554_A", "sol": 0, "python_code": "bigres = [ ]\nt = int ( input ( ) )\nfor m in range ( t ) :\n    n = int ( input ( ) )\n    a = list ( map ( int , input ( ).strip ( ).split ( ) ) )\n    res = a [ 0 ] * a [ 1 ]\n    for q in range ( len ( a ) - 1 ) :\n        res = max ( res , ( a [ q ] * a [ q + 1 ] ) )\n    bigres += [ res ]\nfor i in range ( len ( bigres ) ) :\n    print ( bigres [ i ] )\n", "python_code_tokenized": "bigres = [ ] NEW_LINE t = int ( input ( ) ) NEW_LINE for m in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) NEW_LINE res = a [ 0 ] * a [ 1 ] NEW_LINE for q in range ( len ( a ) - 1 ) : NEW_LINE INDENT res = max ( res , ( a [ q ] * a [ q + 1 ] ) ) NEW_LINE DEDENT bigres += [ res ] NEW_LINE DEDENT for i in range ( len ( bigres ) ) : NEW_LINE INDENT print ( bigres [ i ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2762_A", "sol": 0, "python_code": "MAX = 64\ndef getBitmask ( s ) :\n    temp = 0\n    for j in range ( len ( s ) ) :\n        if ( s [ j ] == 's' ) :\n            temp = temp | 1\n        elif ( s [ j ] == 't' ) :\n            temp = temp | 2\n        elif ( s [ j ] == 'r' ) :\n            temp = temp | 4\n        elif ( s [ j ] == 'i' ) :\n            temp = temp | 8\n        elif ( s [ j ] == 'n' ) :\n            temp = temp | 16\n        elif ( s [ j ] == 'g' ) :\n            temp = temp | 32\n    return temp\ndef countPairs ( arr , n ) :\n    bitMask = [ 0 for i in range ( MAX ) ]\n    for i in range ( n ) :\n        bitMask [ getBitmask ( arr [ i ] ) ] += 1\n    cnt = 0\n    for i in range ( MAX ) :\n        for j in range ( i , MAX ) :\n            if ( ( i | j ) == ( MAX - 1 ) ) :\n                if ( i == j ) :\n                    cnt += ( ( bitMask [ i ] * bitMask [ i ] - 1 ) // 2 )\n                else :\n                    cnt += ( bitMask [ i ] * bitMask [ j ] )\n    return cnt\narr = [ \"strrr\" , \"strring\" , \"gstrin\" ]\nn = len ( arr )\nprint ( countPairs ( arr , n ) )\n", "python_code_tokenized": "MAX = 64 NEW_LINE def getBitmask ( s ) : NEW_LINE INDENT temp = 0 NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ j ] == ' s ' ) : NEW_LINE INDENT temp = temp | 1 NEW_LINE DEDENT elif ( s [ j ] == ' t ' ) : NEW_LINE INDENT temp = temp | 2 NEW_LINE DEDENT elif ( s [ j ] == ' r ' ) : NEW_LINE INDENT temp = temp | 4 NEW_LINE DEDENT elif ( s [ j ] == ' i ' ) : NEW_LINE INDENT temp = temp | 8 NEW_LINE DEDENT elif ( s [ j ] == ' n ' ) : NEW_LINE INDENT temp = temp | 16 NEW_LINE DEDENT elif ( s [ j ] == ' g ' ) : NEW_LINE INDENT temp = temp | 32 NEW_LINE DEDENT DEDENT return temp NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT bitMask = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT bitMask [ getBitmask ( arr [ i ] ) ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i , MAX ) : NEW_LINE INDENT if ( ( i | j ) == ( MAX - 1 ) ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT cnt += ( ( bitMask [ i ] * bitMask [ i ] - 1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( bitMask [ i ] * bitMask [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT arr = [ \" strrr \" , \" strring \" , \" gstrin \" ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3776_A", "sol": 0, "python_code": "def minSteps ( arr , n ) :\n    v = [ 0 for i in range ( n ) ]\n    q = [ ]\n    q.append ( 0 )\n    depth = 0\n    while ( len ( q ) != 0 ) :\n        x = len ( q )\n        while ( x >= 1 ) :\n            i = q [ 0 ]\n            q.remove ( i )\n            x -= 1\n            if ( v [ i ] ) :\n                continue ;\n            if ( i == n - 1 ) :\n                return depth\n            v [ i ] = 1\n            if ( i + arr [ i ] < n ) :\n                q.append ( i + arr [ i ] )\n            if ( i - arr [ i ] >= 0 ) :\n                q.append ( i - arr [ i ] )\n        depth += 1\n    return - 1\nif __name__ == '__main__' :\n    arr = [ 1 , 1 , 1 , 1 , 1 , 1 ]\n    n = len ( arr )\n    print ( minSteps ( arr , n ) )\n", "python_code_tokenized": "def minSteps ( arr , n ) : NEW_LINE INDENT v = [ 0 for i in range ( n ) ] NEW_LINE q = [ ] NEW_LINE q . append ( 0 ) NEW_LINE depth = 0 NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT x = len ( q ) NEW_LINE while ( x >= 1 ) : NEW_LINE INDENT i = q [ 0 ] NEW_LINE q . remove ( i ) NEW_LINE x -= 1 NEW_LINE if ( v [ i ] ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( i == n - 1 ) : NEW_LINE INDENT return depth NEW_LINE DEDENT v [ i ] = 1 NEW_LINE if ( i + arr [ i ] < n ) : NEW_LINE INDENT q . append ( i + arr [ i ] ) NEW_LINE DEDENT if ( i - arr [ i ] >= 0 ) : NEW_LINE INDENT q . append ( i - arr [ i ] ) NEW_LINE DEDENT DEDENT depth += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minSteps ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1166_A", "sol": 0, "python_code": "MAX_CHAR = 26\ndef checkCorrectOrNot ( s ) :\n    global MAX_CHAR\n    count = [ 0 ] * MAX_CHAR\n    n = len ( s )\n    if n == 1 :\n        return true\n    i = 0 ; j = n - 1\n    while i < j :\n        count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1\n        count [ ord ( s [ j ] ) - ord ( 'a' ) ] -= 1\n        i += 1 ; j -= 1\n    for i in range ( MAX_CHAR ) :\n        if count [ i ] != 0 :\n            return False\n    return True\ns = \"abab\"\nprint ( \"Yes\" if checkCorrectOrNot ( s ) else \"No\" )\n", "python_code_tokenized": "MAX_CHAR = 26 NEW_LINE def checkCorrectOrNot ( s ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE n = len ( s ) NEW_LINE if n == 1 : NEW_LINE INDENT return true NEW_LINE DEDENT i = 0 ; j = n - 1 NEW_LINE while i < j : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count [ ord ( s [ j ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE i += 1 ; j -= 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if count [ i ] != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" abab \" NEW_LINE print ( \" Yes \" if checkCorrectOrNot ( s ) else \" No \" ) NEW_LINE"}
{"id": "geeksforgeeks_1165_A", "sol": 0, "python_code": "MAX_CHAR = 26\ndef checkCorrectOrNot ( s ) :\n    global MAX_CHAR\n    count1 = [ 0 ] * MAX_CHAR\n    count2 = [ 0 ] * MAX_CHAR\n    n = len ( s )\n    if n == 1 :\n        return true\n    i = 0 ; j = n - 1\n    while ( i < j ) :\n        count1 [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1\n        count2 [ ord ( s [ j ] ) - ord ( 'a' ) ] += 1\n        i += 1 ; j -= 1\n    for i in range ( MAX_CHAR ) :\n        if count1 [ i ] != count2 [ i ] :\n            return False\n    return True\ns = \"ababc\"\nprint ( \"Yes\" if checkCorrectOrNot ( s ) else \"No\" )\n", "python_code_tokenized": "MAX_CHAR = 26 NEW_LINE def checkCorrectOrNot ( s ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE n = len ( s ) NEW_LINE if n == 1 : NEW_LINE INDENT return true NEW_LINE DEDENT i = 0 ; j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT count1 [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count2 [ ord ( s [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 ; j -= 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if count1 [ i ] != count2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" ababc \" NEW_LINE print ( \" Yes \" if checkCorrectOrNot ( s ) else \" No \" ) NEW_LINE"}
{"id": "aizu_p02031_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\ncnt = 0\nans = ''\nst = list ( )\nfor x in a :\n    while cnt < x :\n        ans += '('\n        cnt += 1\n        st.append ( cnt )\n    if st [ - 1 ] == x :\n        st.pop ( )\n        ans += ')'\n    else :\n        ans = ':('\n        break\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cnt = 0 NEW_LINE ans = ' ' NEW_LINE st = list ( ) NEW_LINE for x in a : NEW_LINE INDENT while cnt < x : NEW_LINE INDENT ans += ' ( ' NEW_LINE cnt += 1 NEW_LINE st . append ( cnt ) NEW_LINE DEDENT if st [ - 1 ] == x : NEW_LINE INDENT st . pop ( ) NEW_LINE ans += ' ) ' NEW_LINE DEDENT else : NEW_LINE INDENT ans = ' : ( ' NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_2216_A", "sol": 0, "python_code": "def twoParts ( string ) :\n    flag = 0 ;\n    a = \"\" ;\n    for i in range ( len ( string ) ) :\n        if ( string [ i ] == '4' ) :\n            string [ i ] = '3' ;\n            a += '1' ;\n            flag = 1 ;\n        elif ( flag ) :\n            a += '0' ;\n    string = \"\".join ( string ) ;\n    print ( string , a ) ;\nif __name__ == \"__main__\" :\n    string = \"9441\" ;\n    twoParts ( list ( string ) ) ;\n", "python_code_tokenized": "def twoParts ( string ) : NEW_LINE INDENT flag = 0 ; NEW_LINE a = \" \" ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == '4' ) : NEW_LINE INDENT string [ i ] = '3' ; NEW_LINE a += '1' ; NEW_LINE flag = 1 ; NEW_LINE DEDENT elif ( flag ) : NEW_LINE INDENT a += '0' ; NEW_LINE DEDENT DEDENT string = \" \" . join ( string ) ; NEW_LINE print ( string , a ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"9441\" ; NEW_LINE twoParts ( list ( string ) ) ; NEW_LINE DEDENT"}
{"id": "aizu_p00184_A", "sol": 0, "python_code": "while True :\n    n = int ( input ( ) )\n    if n == 0 : break\n    ans = [ 0 for _ in range ( 7 ) ]\n    for _ in range ( n ) :\n        age = int ( input ( ) )\n        if age < 10 :\n            ans [ 0 ] += 1\n        elif age < 20 :\n            ans [ 1 ] += 1\n        elif age < 30 :\n            ans [ 2 ] += 1\n        elif age < 40 :\n            ans [ 3 ] += 1\n        elif age < 50 :\n            ans [ 4 ] += 1\n        elif age < 60 :\n            ans [ 5 ] += 1\n        else :\n            ans [ 6 ] += 1\n    for a in ans :\n        print ( a )\n", "python_code_tokenized": "while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE ans = [ 0 for _ in range ( 7 ) ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT age = int ( input ( ) ) NEW_LINE if age < 10 : NEW_LINE INDENT ans [ 0 ] += 1 NEW_LINE DEDENT elif age < 20 : NEW_LINE INDENT ans [ 1 ] += 1 NEW_LINE DEDENT elif age < 30 : NEW_LINE INDENT ans [ 2 ] += 1 NEW_LINE DEDENT elif age < 40 : NEW_LINE INDENT ans [ 3 ] += 1 NEW_LINE DEDENT elif age < 50 : NEW_LINE INDENT ans [ 4 ] += 1 NEW_LINE DEDENT elif age < 60 : NEW_LINE INDENT ans [ 5 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ 6 ] += 1 NEW_LINE DEDENT DEDENT for a in ans : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3_A", "sol": 0, "python_code": "import math as mt\ndef KPrimeDivisors ( n , k ) :\n    maximum_split = 0\n    while n % 2 == 0 :\n        maximum_split += 1\n        n = n // 2\n    for i in range ( 3 , mt.ceil ( mt.sqrt ( n ) ) , 2 ) :\n        while n % i == 0 :\n            n = n / i ;\n            maximum_split += 1\n    if n > 2 :\n        maximum_split += 1\n    if maximum_split < k :\n        print ( \"No\" )\n        return\n    print ( \"Yes\" )\nN = 12\nK = 3\nKPrimeDivisors ( N , K )\n", "python_code_tokenized": "import math as mt NEW_LINE def KPrimeDivisors ( n , k ) : NEW_LINE INDENT maximum_split = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT maximum_split += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT for i in range ( 3 , mt . ceil ( mt . sqrt ( n ) ) , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT n = n / i ; NEW_LINE maximum_split += 1 NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT maximum_split += 1 NEW_LINE DEDENT if maximum_split < k : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT print ( \" Yes \" ) NEW_LINE DEDENT N = 12 NEW_LINE K = 3 NEW_LINE KPrimeDivisors ( N , K ) NEW_LINE"}
{"id": "geeksforgeeks_3213_A", "sol": 0, "python_code": "def print_sequence ( n , k ) :\n    b = int ( n / ( k * ( k + 1 ) / 2 ) ) ;\n    if b == 0 :\n        print ( \"-1\" )\n    else :\n        r = 1 ;\n        x = 1\n        while x ** 2 <= n :\n            if n % x != 0 :\n                continue ;\n            elif x <= b and x > r :\n                r = x\n            elif n / x <= b and n / x > r :\n                r = n / x\n            x = x + 1\n        i = 1\n        while i < k :\n            print ( r * i , end = \" \" )\n            i = i + 1\n        last_term = n - ( r * ( k * ( k - 1 ) / 2 ) )\n        print ( last_term )\nprint_sequence ( 24 , 4 )\nprint_sequence ( 24 , 5 )\nprint_sequence ( 6 , 4 )\n", "python_code_tokenized": "def print_sequence ( n , k ) : NEW_LINE INDENT b = int ( n / ( k * ( k + 1 ) / 2 ) ) ; NEW_LINE if b == 0 : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT r = 1 ; NEW_LINE x = 1 NEW_LINE while x ** 2 <= n : NEW_LINE INDENT if n % x != 0 : NEW_LINE INDENT continue ; NEW_LINE DEDENT elif x <= b and x > r : NEW_LINE INDENT r = x NEW_LINE DEDENT elif n / x <= b and n / x > r : NEW_LINE INDENT r = n / x NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < k : NEW_LINE INDENT print ( r * i , end = \" \u2581 \" ) NEW_LINE i = i + 1 NEW_LINE DEDENT last_term = n - ( r * ( k * ( k - 1 ) / 2 ) ) NEW_LINE print ( last_term ) NEW_LINE DEDENT DEDENT print_sequence ( 24 , 4 ) NEW_LINE print_sequence ( 24 , 5 ) NEW_LINE print_sequence ( 6 , 4 ) NEW_LINE"}
{"id": "geeksforgeeks_4124_A", "sol": 0, "python_code": "def solve ( X , Y , N , K ) :\n    count = [ 0 ] * ( N + 1 ) ;\n    sol = 0 ;\n    count [ 0 ] = 0 ;\n    for i in range ( 1 , N + 1 ) :\n        count [ i ] = ( count [ i - 1 ] + abs ( ord ( X [ i - 1 ] ) - ord ( Y [ i - 1 ] ) ) ) ;\n    j = 0 ;\n    for i in range ( 1 , N + 1 ) :\n        while ( ( count [ i ] - count [ j ] ) > K ) :\n            j += 1 ;\n        sol = max ( sol , i - j ) ;\n    return sol ;\nif __name__ == '__main__' :\n    N = 4 ;\n    X = \"abcd\" ;\n    Y = \"bcde\" ;\n    K = 3 ;\n    print ( solve ( X , Y , N , K ) ) ;\n", "python_code_tokenized": "def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) ; NEW_LINE sol = 0 ; NEW_LINE count [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = ( count [ i - 1 ] + abs ( ord ( X [ i - 1 ] ) - ord ( Y [ i - 1 ] ) ) ) ; NEW_LINE DEDENT j = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( ( count [ i ] - count [ j ] ) > K ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT sol = max ( sol , i - j ) ; NEW_LINE DEDENT return sol ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE X = \" abcd \" ; NEW_LINE Y = \" bcde \" ; NEW_LINE K = 3 ; NEW_LINE print ( solve ( X , Y , N , K ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4049_A", "sol": 0, "python_code": "def sum_series ( n ) :\n    nSquare = n * n\n    return int ( nSquare * ( nSquare - 1 ) / 4 )\nn = 2\nprint ( sum_series ( n ) )\n", "python_code_tokenized": "def sum_series ( n ) : NEW_LINE INDENT nSquare = n * n NEW_LINE return int ( nSquare * ( nSquare - 1 ) / 4 ) NEW_LINE DEDENT n = 2 NEW_LINE print ( sum_series ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4081_A", "sol": 0, "python_code": "def numberOfSolutions ( n ) :\n    c = 0\n    for x in range ( n + 1 ) :\n        if ( n == ( x + ( n ^ x ) ) ) :\n            c += 1\n    return c\nif __name__ == \"__main__\" :\n    n = 3\n    print ( numberOfSolutions ( n ) )\n", "python_code_tokenized": "def numberOfSolutions ( n ) : NEW_LINE INDENT c = 0 NEW_LINE for x in range ( n + 1 ) : NEW_LINE INDENT if ( n == ( x + ( n ^ x ) ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( numberOfSolutions ( n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_420_A", "sol": 0, "python_code": "a = input ( )\nx = 'AHIMOTUVWXY'\nif len ( a ) == 1 :\n    if a in x : print ( 'YES' )\n    else : print ( 'NO' )\nelse :\n    count = 0\n    if a [ : : - 1 ] == a :\n        for i in a :\n            if i in x : count += 1\n    if count == len ( a ) and a [ : : - 1 ] == a : print ( 'YES' )\n    else : print ( 'NO' )\n", "python_code_tokenized": "a = input ( ) NEW_LINE x = ' AHIMOTUVWXY ' NEW_LINE if len ( a ) == 1 : NEW_LINE INDENT if a in x : print ( ' YES ' ) NEW_LINE else : print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE if a [ : : - 1 ] == a : NEW_LINE INDENT for i in a : NEW_LINE INDENT if i in x : count += 1 NEW_LINE DEDENT DEDENT if count == len ( a ) and a [ : : - 1 ] == a : print ( ' YES ' ) NEW_LINE else : print ( ' NO ' ) NEW_LINE DEDENT"}
{"id": "codeforces_1529_B", "sol": 0, "python_code": "for j in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    a = list ( map ( int , input ( ).split ( ) ) )\n    a.sort ( )\n    pos = 0\n    var = 0\n    neg = [ ]\n    for k in range ( n ) :\n        if a [ k ] < 1 :\n            neg.append ( a [ k ] )\n        else :\n            var = k\n            break\n    pos = a [ k ]\n    flag = True\n    for j in range ( len ( neg ) - 1 ) :\n        if abs ( a [ j + 1 ] - a [ j ] ) < pos :\n            flag = False\n            break\n    if len ( neg ) == n :\n        print ( n )\n    elif flag :\n        print ( len ( neg ) + 1 )\n    else :\n        print ( len ( neg ) )\n", "python_code_tokenized": "for j in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE pos = 0 NEW_LINE var = 0 NEW_LINE neg = [ ] NEW_LINE for k in range ( n ) : NEW_LINE INDENT if a [ k ] < 1 : NEW_LINE INDENT neg . append ( a [ k ] ) NEW_LINE DEDENT else : NEW_LINE INDENT var = k NEW_LINE break NEW_LINE DEDENT DEDENT pos = a [ k ] NEW_LINE flag = True NEW_LINE for j in range ( len ( neg ) - 1 ) : NEW_LINE INDENT if abs ( a [ j + 1 ] - a [ j ] ) < pos : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if len ( neg ) == n : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT elif flag : NEW_LINE INDENT print ( len ( neg ) + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( len ( neg ) ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00494_A", "sol": 0, "python_code": "s = input ( )\ni = 0\nmaxlv = 0\nwhile i < len ( s ) :\n    lbuf = 0\n    if s [ i ] == 'J' :\n        j = 1\n        while i + j < len ( s ) and s [ i + j ] == \"J\" : j += 1\n        lbuf = j\n        i = i + j\n        j = 0\n        while i + j < len ( s ) and j < lbuf and s [ i + j ] == \"O\" : j += 1\n        lbuf = min ( ( lbuf , j ) )\n        if lbuf == 0 : continue\n        i = i + j\n        j = 0\n        while i + j < len ( s ) and j < lbuf and s [ i + j ] == \"I\" : j += 1\n        i = i + j\n        if j != lbuf : continue\n        elif lbuf > maxlv :\n            maxlv = lbuf\n    else : i += 1\nprint ( maxlv )\n", "python_code_tokenized": "s = input ( ) NEW_LINE i = 0 NEW_LINE maxlv = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT lbuf = 0 NEW_LINE if s [ i ] == ' J ' : NEW_LINE INDENT j = 1 NEW_LINE while i + j < len ( s ) and s [ i + j ] == \" J \" : j += 1 NEW_LINE lbuf = j NEW_LINE i = i + j NEW_LINE j = 0 NEW_LINE while i + j < len ( s ) and j < lbuf and s [ i + j ] == \" O \" : j += 1 NEW_LINE lbuf = min ( ( lbuf , j ) ) NEW_LINE if lbuf == 0 : continue NEW_LINE i = i + j NEW_LINE j = 0 NEW_LINE while i + j < len ( s ) and j < lbuf and s [ i + j ] == \" I \" : j += 1 NEW_LINE i = i + j NEW_LINE if j != lbuf : continue NEW_LINE elif lbuf > maxlv : NEW_LINE INDENT maxlv = lbuf NEW_LINE DEDENT DEDENT else : i += 1 NEW_LINE DEDENT print ( maxlv ) NEW_LINE"}
{"id": "geeksforgeeks_1538_A", "sol": 0, "python_code": "def pairsInSortedRotated ( arr , n , x ) :\n    for i in range ( n ) :\n        if arr [ i ] > arr [ i + 1 ] :\n            break\n    l = ( i + 1 ) % n\n    r = i\n    cnt = 0\n    while ( l != r ) :\n        if arr [ l ] + arr [ r ] == x :\n            cnt += 1\n            if l == ( r - 1 + n ) % n :\n                return cnt\n            l = ( l + 1 ) % n\n            r = ( r - 1 + n ) % n\n        elif arr [ l ] + arr [ r ] < x :\n            l = ( l + 1 ) % n\n        else :\n            r = ( n + r - 1 ) % n\n    return cnt\narr = [ 11 , 15 , 6 , 7 , 9 , 10 ]\ns = 16\nprint ( pairsInSortedRotated ( arr , 6 , s ) )\n", "python_code_tokenized": "def pairsInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE cnt = 0 NEW_LINE while ( l != r ) : NEW_LINE INDENT if arr [ l ] + arr [ r ] == x : NEW_LINE INDENT cnt += 1 NEW_LINE if l == ( r - 1 + n ) % n : NEW_LINE INDENT return cnt NEW_LINE DEDENT l = ( l + 1 ) % n NEW_LINE r = ( r - 1 + n ) % n NEW_LINE DEDENT elif arr [ l ] + arr [ r ] < x : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT arr = [ 11 , 15 , 6 , 7 , 9 , 10 ] NEW_LINE s = 16 NEW_LINE print ( pairsInSortedRotated ( arr , 6 , s ) ) NEW_LINE"}
{"id": "geeksforgeeks_1468_A", "sol": 0, "python_code": "def nextGap ( gap ) :\n    if ( gap <= 1 ) :\n        return 0\n    return ( gap // 2 ) + ( gap % 2 )\ndef merge ( arr1 , arr2 , n , m ) :\n    gap = n + m\n    gap = nextGap ( gap )\n    while gap > 0 :\n        i = 0\n        while i + gap < n :\n            if ( arr1 [ i ] > arr1 [ i + gap ] ) :\n                arr1 [ i ] , arr1 [ i + gap ] = arr1 [ i + gap ] , arr1 [ i ]\n            i += 1\n        j = gap - n if gap > n else 0\n        while i < n and j < m :\n            if ( arr1 [ i ] > arr2 [ j ] ) :\n                arr1 [ i ] , arr2 [ j ] = arr2 [ j ] , arr1 [ i ]\n            i += 1\n            j += 1\n        if ( j < m ) :\n            j = 0\n            while j + gap < m :\n                if ( arr2 [ j ] > arr2 [ j + gap ] ) :\n                    arr2 [ j ] , arr2 [ j + gap ] = arr2 [ j + gap ] , arr2 [ j ]\n                j += 1\n        gap = nextGap ( gap )\nif __name__ == \"__main__\" :\n    a1 = [ 10 , 27 , 38 , 43 , 82 ]\n    a2 = [ 3 , 9 ]\n    n = len ( a1 )\n    m = len ( a2 )\n    merge ( a1 , a2 , n , m )\n    print ( \"First Array: \" , end = \"\" )\n    for i in range ( n ) :\n        print ( a1 [ i ] , end = \"\" )\n    print ( )\n    print ( \"Second Array: \" , end = \"\" )\n    for i in range ( m ) :\n        print ( a2 [ i ] , end = \"\" )\n    print ( )\n", "python_code_tokenized": "def nextGap ( gap ) : NEW_LINE INDENT if ( gap <= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( gap // 2 ) + ( gap % 2 ) NEW_LINE DEDENT def merge ( arr1 , arr2 , n , m ) : NEW_LINE INDENT gap = n + m NEW_LINE gap = nextGap ( gap ) NEW_LINE while gap > 0 : NEW_LINE INDENT i = 0 NEW_LINE while i + gap < n : NEW_LINE INDENT if ( arr1 [ i ] > arr1 [ i + gap ] ) : NEW_LINE INDENT arr1 [ i ] , arr1 [ i + gap ] = arr1 [ i + gap ] , arr1 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT j = gap - n if gap > n else 0 NEW_LINE while i < n and j < m : NEW_LINE INDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT arr1 [ i ] , arr2 [ j ] = arr2 [ j ] , arr1 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( j < m ) : NEW_LINE INDENT j = 0 NEW_LINE while j + gap < m : NEW_LINE INDENT if ( arr2 [ j ] > arr2 [ j + gap ] ) : NEW_LINE INDENT arr2 [ j ] , arr2 [ j + gap ] = arr2 [ j + gap ] , arr2 [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT gap = nextGap ( gap ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a1 = [ 10 , 27 , 38 , 43 , 82 ] NEW_LINE a2 = [ 3 , 9 ] NEW_LINE n = len ( a1 ) NEW_LINE m = len ( a2 ) NEW_LINE merge ( a1 , a2 , n , m ) NEW_LINE print ( \" First \u2581 Array : \u2581 \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a1 [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE print ( \" Second \u2581 Array : \u2581 \" , end = \" \" ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT print ( a2 [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_114_A", "sol": 0, "python_code": "def prime ( n ) :\n    flag = 0 ;\n    if ( ( n + 1 ) % 6 != 0 and ( n - 1 ) % 6 != 0 ) :\n        print ( \"Not Prime\" ) ;\n    else :\n        s = pow ( n , 1 / 2 ) ;\n        if ( ( s * s ) == n ) :\n            print ( \"Semi-Prime\" ) ;\n        else :\n            f = int ( s ) ;\n            l = int ( f * f ) ;\n            for i in range ( f + 1 , l ) :\n                p = i - ( pow ( ( ( i * i ) - ( n ) ) , 1 / 2 ) ) ;\n                q = n // p ;\n                if ( p < 2 or q < 2 ) :\n                    break ;\n                if ( ( p * q ) == n ) :\n                    flag = 1 ;\n                    break ;\n                else :\n                    flag = 2 ;\n            if ( flag == 1 ) :\n                print ( \"Semi-Prime\" ) ;\n            elif ( flag == 2 ) :\n                print ( \"Prime\" ) ;\nif __name__ == '__main__' :\n    prime ( 8179 ) ;\n    prime ( 7894561 ) ;\n    prime ( 90000000 ) ;\n    prime ( 841 ) ;\n    prime ( 22553 ) ;\n    prime ( 1187 ) ;\n", "python_code_tokenized": "def prime ( n ) : NEW_LINE INDENT flag = 0 ; NEW_LINE if ( ( n + 1 ) % 6 != 0 and ( n - 1 ) % 6 != 0 ) : NEW_LINE INDENT print ( \" Not \u2581 Prime \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT s = pow ( n , 1 / 2 ) ; NEW_LINE if ( ( s * s ) == n ) : NEW_LINE INDENT print ( \" Semi - Prime \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT f = int ( s ) ; NEW_LINE l = int ( f * f ) ; NEW_LINE for i in range ( f + 1 , l ) : NEW_LINE INDENT p = i - ( pow ( ( ( i * i ) - ( n ) ) , 1 / 2 ) ) ; NEW_LINE q = n // p ; NEW_LINE if ( p < 2 or q < 2 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT if ( ( p * q ) == n ) : NEW_LINE INDENT flag = 1 ; NEW_LINE break ; NEW_LINE DEDENT else : NEW_LINE INDENT flag = 2 ; NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( \" Semi - Prime \" ) ; NEW_LINE DEDENT elif ( flag == 2 ) : NEW_LINE INDENT print ( \" Prime \" ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT prime ( 8179 ) ; NEW_LINE prime ( 7894561 ) ; NEW_LINE prime ( 90000000 ) ; NEW_LINE prime ( 841 ) ; NEW_LINE prime ( 22553 ) ; NEW_LINE prime ( 1187 ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1172_B", "sol": 0, "python_code": "import sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\ndef bfs ( s ) :\n    q , k = [ s ] , 0\n    visit = [ 0 ] * ( n + 1 )\n    visit [ s ] = 1\n    child = [ [ ] for _ in range ( n + 1 ) ]\n    while len ( q ) ^ k :\n        i = q [ k ]\n        for j in G [ i ] :\n            if not visit [ j ] :\n                q.append ( j )\n                visit [ j ] = 1\n                child [ i ].append ( j )\n        k += 1\n    return q , child\nn = int ( input ( ) )\nmod = 998244353\nl = n + 5\nfact = [ 1 ] * ( l + 1 )\nfor i in range ( 1 , l + 1 ) :\n    fact [ i ] = i * fact [ i - 1 ] % mod\nG = [ [ ] for _ in range ( n + 1 ) ]\nfor _ in range ( n - 1 ) :\n    u , v = map ( int , input ( ).split ( ) )\n    G [ u ].append ( v )\n    G [ v ].append ( u )\np , child = bfs ( 1 )\ndp = [ 1 ] * ( n + 1 )\nfor i in reversed ( p ) :\n    c = fact [ len ( child [ i ] ) + 1 ]\n    for j in child [ i ] :\n        c *= dp [ j ]\n        c %= mod\n    dp [ i ] = c\nans = dp [ 1 ] * pow ( len ( child [ 1 ] ) + 1 , mod - 2 , mod ) % mod * n % mod\nprint ( ans )\n", "python_code_tokenized": "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE def bfs ( s ) : NEW_LINE INDENT q , k = [ s ] , 0 NEW_LINE visit = [ 0 ] * ( n + 1 ) NEW_LINE visit [ s ] = 1 NEW_LINE child = [ [ ] for _ in range ( n + 1 ) ] NEW_LINE while len ( q ) ^ k : NEW_LINE INDENT i = q [ k ] NEW_LINE for j in G [ i ] : NEW_LINE INDENT if not visit [ j ] : NEW_LINE INDENT q . append ( j ) NEW_LINE visit [ j ] = 1 NEW_LINE child [ i ] . append ( j ) NEW_LINE DEDENT DEDENT k += 1 NEW_LINE DEDENT return q , child NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE mod = 998244353 NEW_LINE l = n + 5 NEW_LINE fact = [ 1 ] * ( l + 1 ) NEW_LINE for i in range ( 1 , l + 1 ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] % mod NEW_LINE DEDENT G = [ [ ] for _ in range ( n + 1 ) ] NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT u , v = map ( int , input ( ) . split ( ) ) NEW_LINE G [ u ] . append ( v ) NEW_LINE G [ v ] . append ( u ) NEW_LINE DEDENT p , child = bfs ( 1 ) NEW_LINE dp = [ 1 ] * ( n + 1 ) NEW_LINE for i in reversed ( p ) : NEW_LINE INDENT c = fact [ len ( child [ i ] ) + 1 ] NEW_LINE for j in child [ i ] : NEW_LINE INDENT c *= dp [ j ] NEW_LINE c %= mod NEW_LINE DEDENT dp [ i ] = c NEW_LINE DEDENT ans = dp [ 1 ] * pow ( len ( child [ 1 ] ) + 1 , mod - 2 , mod ) % mod * n % mod NEW_LINE print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_2024_A", "sol": 0, "python_code": "def unitDigitXRaisedY ( x , y ) :\n    res = 1\n    for i in range ( y ) :\n        res = ( res * x ) % 10\n    return res\nprint ( unitDigitXRaisedY ( 4 , 2 ) )\n", "python_code_tokenized": "def unitDigitXRaisedY ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( y ) : NEW_LINE INDENT res = ( res * x ) % 10 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( unitDigitXRaisedY ( 4 , 2 ) ) NEW_LINE"}
{"id": "geeksforgeeks_5175_A", "sol": 0, "python_code": "import math\nMAX = 1000000 ;\nprimes = [ ] ;\ndef sieveSundaram ( ) :\n    marked = [ False ] * ( int ( MAX / 2 ) + 1 ) ;\n    for i in range ( 1 , int ( ( math.sqrt ( MAX ) - 1 ) / 2 ) + 1 ) :\n        for j in range ( ( ( i * ( i + 1 ) ) << 1 ) , ( int ( MAX / 2 ) + 1 ) , ( 2 * i + 1 ) ) :\n            marked [ j ] = True ;\n    primes.append ( 2 ) ;\n    for i in range ( 1 , int ( MAX / 2 ) ) :\n        if ( marked [ i ] == False ) :\n            primes.append ( 2 * i + 1 ) ;\ndef calculatePrimorial ( n ) :\n    result = 1 ;\n    for i in range ( n ) :\n        result = result * primes [ i ] ;\n    return result ;\nn = 5 ;\nsieveSundaram ( ) ;\nfor i in range ( 1 , n + 1 ) :\n    print ( \"Primorial(P#) of\" , i , \"is\" , calculatePrimorial ( i ) ) ;\n", "python_code_tokenized": "import math NEW_LINE MAX = 1000000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieveSundaram ( ) : NEW_LINE INDENT marked = [ False ] * ( int ( MAX / 2 ) + 1 ) ; NEW_LINE for i in range ( 1 , int ( ( math . sqrt ( MAX ) - 1 ) / 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( ( i * ( i + 1 ) ) << 1 ) , ( int ( MAX / 2 ) + 1 ) , ( 2 * i + 1 ) ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , int ( MAX / 2 ) ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def calculatePrimorial ( n ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = result * primes [ i ] ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT n = 5 ; NEW_LINE sieveSundaram ( ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( \" Primorial ( P # ) \u2581 of \" , i , \" is \" , calculatePrimorial ( i ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2152_A", "sol": 0, "python_code": "def precisionCompute ( x , y , n ) :\n    if y == 0 :\n        print ( \"Infinite\" ) ;\n        return ;\n    if x == 0 :\n        print ( 0 ) ;\n        return ;\n    if n <= 0 :\n        print ( x / y ) ;\n        return ;\n    if ( ( ( x > 0 ) and ( y < 0 ) ) or ( ( x < 0 ) and ( y > 0 ) ) ) :\n        print ( \"-\" , end = \"\" ) ;\n        if x < 0 :\n            x = - x ;\n        if y < 0 :\n            y = - y ;\n    d = x / y ;\n    for i in range ( 0 , n + 1 ) :\n        print ( d ) ;\n        x = x - ( y * d ) ;\n        if x == 0 :\n            break ;\n        x = x * 10 ;\n        d = x / y ;\n        if ( i == 0 ) :\n            print ( \".\" , end = \"\" ) ;\nx = 22 ;\ny = 7 ;\nn = 15 ;\nprecisionCompute ( x , y , n ) ;\n", "python_code_tokenized": "def precisionCompute ( x , y , n ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT print ( \" Infinite \" ) ; NEW_LINE return ; NEW_LINE DEDENT if x == 0 : NEW_LINE INDENT print ( 0 ) ; NEW_LINE return ; NEW_LINE DEDENT if n <= 0 : NEW_LINE INDENT print ( x / y ) ; NEW_LINE return ; NEW_LINE DEDENT if ( ( ( x > 0 ) and ( y < 0 ) ) or ( ( x < 0 ) and ( y > 0 ) ) ) : NEW_LINE INDENT print ( \" - \" , end = \" \" ) ; NEW_LINE if x < 0 : NEW_LINE INDENT x = - x ; NEW_LINE DEDENT if y < 0 : NEW_LINE INDENT y = - y ; NEW_LINE DEDENT DEDENT d = x / y ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT print ( d ) ; NEW_LINE x = x - ( y * d ) ; NEW_LINE if x == 0 : NEW_LINE INDENT break ; NEW_LINE DEDENT x = x * 10 ; NEW_LINE d = x / y ; NEW_LINE if ( i == 0 ) : NEW_LINE INDENT print ( \" . \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT DEDENT x = 22 ; NEW_LINE y = 7 ; NEW_LINE n = 15 ; NEW_LINE precisionCompute ( x , y , n ) ; NEW_LINE"}
{"id": "codeforces_799_A", "sol": 0, "python_code": "import math\nn , t , k , d = list ( map ( int , input ( ).split ( ) ) )\ntime_without_second_oven = math.ceil ( n / k ) * t\nspent_time = 1\ndouble_oven_spent_time = 0\ndouble_oven = False\nwhile n > 0 :\n    if spent_time == d :\n        double_oven = True\n        double_oven_spent_time = 0\n    if spent_time % t == 0 :\n        n -= k\n    if double_oven and double_oven_spent_time != 0 and double_oven_spent_time % t == 0 :\n        n -= k\n    if n <= 0 :\n        break\n    if double_oven == True :\n        spent_time += 1\n        double_oven_spent_time += 1\n    else :\n        spent_time += 1\nif time_without_second_oven > spent_time :\n    print ( 'YES' )\nelse :\n    print ( 'NO' )\n", "python_code_tokenized": "import math NEW_LINE n , t , k , d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE time_without_second_oven = math . ceil ( n / k ) * t NEW_LINE spent_time = 1 NEW_LINE double_oven_spent_time = 0 NEW_LINE double_oven = False NEW_LINE while n > 0 : NEW_LINE INDENT if spent_time == d : NEW_LINE INDENT double_oven = True NEW_LINE double_oven_spent_time = 0 NEW_LINE DEDENT if spent_time % t == 0 : NEW_LINE INDENT n -= k NEW_LINE DEDENT if double_oven and double_oven_spent_time != 0 and double_oven_spent_time % t == 0 : NEW_LINE INDENT n -= k NEW_LINE DEDENT if n <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT if double_oven == True : NEW_LINE INDENT spent_time += 1 NEW_LINE double_oven_spent_time += 1 NEW_LINE DEDENT else : NEW_LINE INDENT spent_time += 1 NEW_LINE DEDENT DEDENT if time_without_second_oven > spent_time : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_176_A", "sol": 0, "python_code": "def area_of_circle ( m , n ) :\n    square_of_radius = ( m * n ) / 4\n    area = ( 3.141 * square_of_radius )\n    return area\nif __name__ == '__main__' :\n    n = 10\n    m = 30\n    print ( area_of_circle ( m , n ) )\n", "python_code_tokenized": "def area_of_circle ( m , n ) : NEW_LINE INDENT square_of_radius = ( m * n ) / 4 NEW_LINE area = ( 3.141 * square_of_radius ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE m = 30 NEW_LINE print ( area_of_circle ( m , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2897_A", "sol": 0, "python_code": "def dig ( a ) :\n    count = 0 ;\n    while ( a > 0 ) :\n        a /= 10\n        count += 1\n    return count\ndef required_number ( num , n , d ) :\n    flag = 0\n    power = 0\n    a = 0\n    for i in range ( num , 0 , - 1 ) :\n        power = pow ( 10 , i )\n        a = n % power\n        if ( d > a ) :\n            flag = 1\n            break\n    if ( flag ) :\n        t = 0\n        for j in range ( 0 , i ) :\n            t += 9 * pow ( 10 , j )\n        if ( n % power == t ) :\n            print ( n , end = \"\" )\n        else :\n            print ( ( n - ( n % power ) - 1 ) , end = \"\" )\n    else :\n        print ( n , end = \"\" )\nif __name__ == \"__main__\" :\n    n = 1029\n    d = 102\n    num = dig ( n )\n    required_number ( num , n , d )\n", "python_code_tokenized": "def dig ( a ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( a > 0 ) : NEW_LINE INDENT a /= 10 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def required_number ( num , n , d ) : NEW_LINE INDENT flag = 0 NEW_LINE power = 0 NEW_LINE a = 0 NEW_LINE for i in range ( num , 0 , - 1 ) : NEW_LINE INDENT power = pow ( 10 , i ) NEW_LINE a = n % power NEW_LINE if ( d > a ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT t = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT t += 9 * pow ( 10 , j ) NEW_LINE DEDENT if ( n % power == t ) : NEW_LINE INDENT print ( n , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n - ( n % power ) - 1 ) , end = \" \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( n , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1029 NEW_LINE d = 102 NEW_LINE num = dig ( n ) NEW_LINE required_number ( num , n , d ) NEW_LINE DEDENT"}
{"id": "codeforces_151_A", "sol": 0, "python_code": "def softDrinking ( ) :\n    ( n , k , l , c , d , p , nl , np ) = map ( int , input ( ).split ( ) )\n    toastOfdrinkings = int ( ( k * l ) / nl )\n    toastOfLimes = int ( c * d )\n    toastOfSalts = int ( p / np )\n    print ( int ( min ( toastOfdrinkings , min ( toastOfLimes , toastOfSalts ) ) / n ) )\n    return\nsoftDrinking ( )\n", "python_code_tokenized": "def softDrinking ( ) : NEW_LINE INDENT ( n , k , l , c , d , p , nl , np ) = map ( int , input ( ) . split ( ) ) NEW_LINE toastOfdrinkings = int ( ( k * l ) / nl ) NEW_LINE toastOfLimes = int ( c * d ) NEW_LINE toastOfSalts = int ( p / np ) NEW_LINE print ( int ( min ( toastOfdrinkings , min ( toastOfLimes , toastOfSalts ) ) / n ) ) NEW_LINE return NEW_LINE DEDENT softDrinking ( ) NEW_LINE"}
{"id": "geeksforgeeks_4946_A", "sol": 0, "python_code": "def countDe ( arr , n ) :\n    i = 0\n    v = arr.copy ( )\n    arr.sort ( )\n    count1 = 0\n    i = 0\n    while ( i < n ) :\n        if ( arr [ i ] != v [ i ] ) :\n            count1 = count1 + 1\n        i = i + 1\n    arr.sort ( reverse = True )\n    count2 = 0\n    i = 0\n    while ( i < n ) :\n        if ( arr [ i ] != v [ i ] ) :\n            count2 = count2 + 1\n        i = i + 1\n    return ( min ( count1 , count2 ) )\narr = [ 5 , 9 , 21 , 17 , 13 ]\nn = 5\nprint ( \"Minimum Dearrangement =\" , countDe ( arr , n ) )\n", "python_code_tokenized": "def countDe ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE v = arr . copy ( ) NEW_LINE arr . sort ( ) NEW_LINE count1 = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] != v [ i ] ) : NEW_LINE INDENT count1 = count1 + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT arr . sort ( reverse = True ) NEW_LINE count2 = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] != v [ i ] ) : NEW_LINE INDENT count2 = count2 + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return ( min ( count1 , count2 ) ) NEW_LINE DEDENT arr = [ 5 , 9 , 21 , 17 , 13 ] NEW_LINE n = 5 NEW_LINE print ( \" Minimum \u2581 Dearrangement \u2581 = \" , countDe ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_195_A", "sol": 0, "python_code": "a , b , c = map ( int , input ( ).split ( ) )\nd = ( ( a - b ) * c + b - 1 ) // b\nprint ( d )\n", "python_code_tokenized": "a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE d = ( ( a - b ) * c + b - 1 ) // b NEW_LINE print ( d ) NEW_LINE"}
{"id": "geeksforgeeks_4079_A", "sol": 0, "python_code": "def Vertices ( x , y ) :\n    val = abs ( x ) + abs ( y ) ;\n    if x < 0 :\n        x = - 1\n    else :\n        x = 1\n    print ( val * x , \"0\" , end = \" \" ) ;\n    if y < 0 :\n        y = - 1\n    else :\n        y = 1\n    print ( \"0\" , val * y ) ;\nif __name__ == \"__main__\" :\n    x = 3 ; y = 3 ;\n    Vertices ( x , y ) ;\n", "python_code_tokenized": "def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) ; NEW_LINE if x < 0 : NEW_LINE INDENT x = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = 1 NEW_LINE DEDENT print ( val * x , \"0\" , end = \" \u2581 \" ) ; NEW_LINE if y < 0 : NEW_LINE INDENT y = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT y = 1 NEW_LINE DEDENT print ( \"0\" , val * y ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 3 ; y = 3 ; NEW_LINE Vertices ( x , y ) ; NEW_LINE DEDENT"}
{"id": "codeforces_41_A", "sol": 0, "python_code": "s = input ( )\nt = input ( )\nt = \"\".join ( reversed ( t ) )\nif s == t :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "s = input ( ) NEW_LINE t = input ( ) NEW_LINE t = \" \" . join ( reversed ( t ) ) NEW_LINE if s == t : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC143_D", "sol": 0, "python_code": "import bisect\nn = int ( input ( ) )\nl = list ( map ( int , input ( ).split ( ) ) )\nl.sort ( )\nres = 0\nfor i in range ( 2 , n ) :\n    cnt = 0\n    for j in range ( i ) :\n        p = l [ i ] - l [ j ]\n        k = bisect.bisect_right ( l , p )\n        cnt += i - k\n        if k <= j :\n            cnt -= 1\n    res += cnt\nprint ( res // 2 )\n", "python_code_tokenized": "import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE res = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT p = l [ i ] - l [ j ] NEW_LINE k = bisect . bisect_right ( l , p ) NEW_LINE cnt += i - k NEW_LINE if k <= j : NEW_LINE INDENT cnt -= 1 NEW_LINE DEDENT DEDENT res += cnt NEW_LINE DEDENT print ( res // 2 ) NEW_LINE"}
{"id": "geeksforgeeks_251_A", "sol": 0, "python_code": "import numpy as np\nLAS = np.zeros ( ( 1000 , 2 ) )\nfor i in range ( 1000 ) :\n    for j in range ( 2 ) :\n        LAS [ i ] [ j ] = False\ndef solve ( arr , n , i , pos ) :\n    if ( i == n ) :\n        return 0 ;\n    if ( LAS [ i ] [ pos ] ) :\n        return LAS [ i ] [ pos ] ;\n    inc = 0 ; exc = 0 ;\n    if ( arr [ i ] > 0 and pos == True ) :\n        pos = False ;\n        inc = 1 + solve ( arr , n , i + 1 , pos ) ;\n    elif ( arr [ i ] < 0 and pos == False ) :\n        pos = True ;\n        inc = 1 + solve ( arr , n , i + 1 , pos ) ;\n    exc = solve ( arr , n , i + 1 , pos ) ;\n    LAS [ i ] [ pos ] = max ( inc , exc ) ;\n    return LAS [ i ] [ pos ] ;\nif __name__ == \"__main__\" :\n    arr = [ - 1 , 2 , 3 , 4 , 5 , - 6 , 8 , - 99 ] ;\n    n = len ( arr ) ;\n    print ( max ( solve ( arr , n , 0 , 0 ) , solve ( arr , n , 0 , 1 ) ) ) ;\n", "python_code_tokenized": "import numpy as np NEW_LINE LAS = np . zeros ( ( 1000 , 2 ) ) NEW_LINE for i in range ( 1000 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT LAS [ i ] [ j ] = False NEW_LINE DEDENT DEDENT def solve ( arr , n , i , pos ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( LAS [ i ] [ pos ] ) : NEW_LINE INDENT return LAS [ i ] [ pos ] ; NEW_LINE DEDENT inc = 0 ; exc = 0 ; NEW_LINE if ( arr [ i ] > 0 and pos == True ) : NEW_LINE INDENT pos = False ; NEW_LINE inc = 1 + solve ( arr , n , i + 1 , pos ) ; NEW_LINE DEDENT elif ( arr [ i ] < 0 and pos == False ) : NEW_LINE INDENT pos = True ; NEW_LINE inc = 1 + solve ( arr , n , i + 1 , pos ) ; NEW_LINE DEDENT exc = solve ( arr , n , i + 1 , pos ) ; NEW_LINE LAS [ i ] [ pos ] = max ( inc , exc ) ; NEW_LINE return LAS [ i ] [ pos ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 1 , 2 , 3 , 4 , 5 , - 6 , 8 , - 99 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( max ( solve ( arr , n , 0 , 0 ) , solve ( arr , n , 0 , 1 ) ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_317_A", "sol": 0, "python_code": "def maxEvenSubarray ( array , N ) :\n    ans = 0\n    count = 0\n    for i in range ( 0 , N ) :\n        if array [ i ] % 2 == 0 :\n            count += 1\n            ans = max ( ans , count )\n        else :\n            count = 0\n    ans = max ( ans , count )\n    return ans\nif __name__ == '__main__' :\n    arr = [ 9 , 8 , 5 , 4 , 4 , 4 , 2 , 4 , 1 ]\n    N = len ( arr )\n    print ( maxEvenSubarray ( arr , N ) )\n", "python_code_tokenized": "def maxEvenSubarray ( array , N ) : NEW_LINE INDENT ans = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if array [ i ] % 2 == 0 : NEW_LINE INDENT count += 1 NEW_LINE ans = max ( ans , count ) NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 8 , 5 , 4 , 4 , 4 , 2 , 4 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE print ( maxEvenSubarray ( arr , N ) ) NEW_LINE DEDENT"}
{"id": "codeforces_205_A", "sol": 0, "python_code": "n = int ( input ( ) )\ntime = list ( map ( int , input ( ).split ( \" \" ) ) )\nif time.count ( min ( time ) ) >= 2 :\n    print ( \"Still Rozdil\" )\nelse :\n    print ( time.index ( min ( time ) ) + 1 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE time = list ( map ( int , input ( ) . split ( \" \u2581 \" ) ) ) NEW_LINE if time . count ( min ( time ) ) >= 2 : NEW_LINE INDENT print ( \" Still \u2581 Rozdil \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( time . index ( min ( time ) ) + 1 ) NEW_LINE DEDENT"}
{"id": "codeforces_637_B", "sol": 0, "python_code": "n = int ( input ( ) )\nstack = [ ]\nfor _ in range ( n ) :\n    stack.append ( input ( ) )\nused = set ( )\nfor i in range ( n - 1 , - 1 , - 1 ) :\n    if stack [ i ] not in used :\n        print ( stack [ i ] )\n        used.add ( stack [ i ] )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE stack = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT stack . append ( input ( ) ) NEW_LINE DEDENT used = set ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if stack [ i ] not in used : NEW_LINE INDENT print ( stack [ i ] ) NEW_LINE used . add ( stack [ i ] ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2425_A", "sol": 0, "python_code": "primes = [ ] ;\ndef SieveofEratosthenes ( n ) :\n    visited = [ False ] * ( n + 2 ) ;\n    for i in range ( 2 , n + 2 ) :\n        if ( visited [ i ] == False ) :\n            for j in range ( i * i , n + 2 , i ) :\n                visited [ j ] = True ;\n            primes.append ( i ) ;\ndef specialPrimeNumbers ( n , k ) :\n    SieveofEratosthenes ( n ) ;\n    count = 0 ;\n    for i in range ( len ( primes ) ) :\n        for j in range ( i - 1 ) :\n            if ( primes [ j ] + primes [ j + 1 ] + 1 == primes [ i ] ) :\n                count += 1 ;\n                break ;\n        if ( count == k ) :\n            return True ;\n    return False ;\nn = 27 ;\nk = 2 ;\nif ( specialPrimeNumbers ( n , k ) ) :\n    print ( \"YES\" ) ;\nelse :\n    print ( \"NO\" ) ;\n", "python_code_tokenized": "primes = [ ] ; NEW_LINE def SieveofEratosthenes ( n ) : NEW_LINE INDENT visited = [ False ] * ( n + 2 ) ; NEW_LINE for i in range ( 2 , n + 2 ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT for j in range ( i * i , n + 2 , i ) : NEW_LINE INDENT visited [ j ] = True ; NEW_LINE DEDENT primes . append ( i ) ; NEW_LINE DEDENT DEDENT DEDENT def specialPrimeNumbers ( n , k ) : NEW_LINE INDENT SieveofEratosthenes ( n ) ; NEW_LINE count = 0 ; NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT for j in range ( i - 1 ) : NEW_LINE INDENT if ( primes [ j ] + primes [ j + 1 ] + 1 == primes [ i ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( count == k ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT n = 27 ; NEW_LINE k = 2 ; NEW_LINE if ( specialPrimeNumbers ( n , k ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_842_A", "sol": 0, "python_code": "def Time ( arr , n , Emptypipe ) :\n    fill = 0\n    for i in range ( 0 , n ) :\n        fill += ( 1 / arr [ i ] )\n    fill = fill - ( 1 / float ( Emptypipe ) )\n    return int ( 1 / fill )\nif __name__ == '__main__' :\n    arr = [ 12 , 14 ]\n    Emptypipe = 30\n    n = len ( arr )\n    print ( ( Time ( arr , n , Emptypipe ) ) , \"Hours\" )\n", "python_code_tokenized": "def Time ( arr , n , Emptypipe ) : NEW_LINE INDENT fill = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT fill += ( 1 / arr [ i ] ) NEW_LINE DEDENT fill = fill - ( 1 / float ( Emptypipe ) ) NEW_LINE return int ( 1 / fill ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 14 ] NEW_LINE Emptypipe = 30 NEW_LINE n = len ( arr ) NEW_LINE print ( ( Time ( arr , n , Emptypipe ) ) , \" Hours \" ) NEW_LINE DEDENT"}
{"id": "projecteuler_p114_A", "sol": 0, "python_code": "def compute ( ) :\n    LENGTH = 50\n    ways = [ 0 ] * ( LENGTH + 1 )\n    for n in range ( len ( ways ) ) :\n        if n < 3 :\n            ways [ n ] = 1\n        else :\n            ways [ n ] = ways [ n - 1 ] + sum ( ways [ : n - 3 ] ) + 1\n    return str ( ways [ - 1 ] )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE ways = [ 0 ] * ( LENGTH + 1 ) NEW_LINE for n in range ( len ( ways ) ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT ways [ n ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT ways [ n ] = ways [ n - 1 ] + sum ( ways [ : n - 3 ] ) + 1 NEW_LINE DEDENT DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "projecteuler_p117_A", "sol": 0, "python_code": "def compute ( ) :\n    LENGTH = 50\n    ways = [ 1 ] + [ 0 ] * LENGTH\n    for n in range ( 1 , len ( ways ) ) :\n        ways [ n ] += sum ( ways [ max ( n - 4 , 0 ) : n ] )\n    return str ( ways [ - 1 ] )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE ways = [ 1 ] + [ 0 ] * LENGTH NEW_LINE for n in range ( 1 , len ( ways ) ) : NEW_LINE INDENT ways [ n ] += sum ( ways [ max ( n - 4 , 0 ) : n ] ) NEW_LINE DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC179_B", "sol": 0, "python_code": "N = int ( input ( ) )\ncount = 0\nok = False\nfor _ in range ( N ) :\n    d1 , d2 = [ int ( s ) for s in input ( ).split ( ) ]\n    if d1 == d2 :\n        count += 1\n    else :\n        count = 0\n    if count == 3 :\n        ok = True\nif ok :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE ok = False NEW_LINE for _ in range ( N ) : NEW_LINE INDENT d1 , d2 = [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE if d1 == d2 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT if count == 3 : NEW_LINE INDENT ok = True NEW_LINE DEDENT DEDENT if ok : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1056_B", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\ncount = [ 0 ] * m\nd = n // m\nr = n % m\nfor i in range ( m ) :\n    if i > 0 and i <= r :\n        count [ ( i * i ) % m ] += d + 1\n    else :\n        count [ ( i * i ) % m ] += d\nans = count [ 0 ] * count [ 0 ]\nfor i in range ( 1 , m ) :\n    if i > m - i :\n        break\n    if m - i == i :\n        ans += count [ i ] * count [ i ]\n    else :\n        ans += 2 * count [ i ] * count [ m - i ]\nprint ( ans )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE count = [ 0 ] * m NEW_LINE d = n // m NEW_LINE r = n % m NEW_LINE for i in range ( m ) : NEW_LINE INDENT if i > 0 and i <= r : NEW_LINE INDENT count [ ( i * i ) % m ] += d + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ ( i * i ) % m ] += d NEW_LINE DEDENT DEDENT ans = count [ 0 ] * count [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT if i > m - i : NEW_LINE INDENT break NEW_LINE DEDENT if m - i == i : NEW_LINE INDENT ans += count [ i ] * count [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 * count [ i ] * count [ m - i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_1499_A", "sol": 0, "python_code": "def splitString ( str ) :\n    alpha = \"\"\n    num = \"\"\n    special = \"\"\n    for i in range ( len ( str ) ) :\n        if ( str [ i ].isdigit ( ) ) :\n            num = num + str [ i ]\n        elif ( ( str [ i ] >= 'A' and str [ i ] <= 'Z' ) or ( str [ i ] >= 'a' and str [ i ] <= 'z' ) ) :\n            alpha += str [ i ]\n        else :\n            special += str [ i ]\n    print ( alpha )\n    print ( num )\n    print ( special )\nif __name__ == \"__main__\" :\n    str = \"geeks01$$for02geeks03!@!!\"\n    splitString ( str )\n", "python_code_tokenized": "def splitString ( str ) : NEW_LINE INDENT alpha = \" \" NEW_LINE num = \" \" NEW_LINE special = \" \" NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isdigit ( ) ) : NEW_LINE INDENT num = num + str [ i ] NEW_LINE DEDENT elif ( ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) or ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) ) : NEW_LINE INDENT alpha += str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT special += str [ i ] NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE print ( num ) NEW_LINE print ( special ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks01 $ $ for02geeks03 ! @ ! ! \" NEW_LINE splitString ( str ) NEW_LINE DEDENT"}
{"id": "codeforces_1496_B", "sol": 0, "python_code": "def PROBLEM ( ) :\n    T = [ ]\n    for _ in range ( int ( input ( ) ) ) :\n        n , k = map ( int , input ( ).split ( ) )\n        a = set ( map ( int , input ( ).split ( ) ) )\n        mex = 0\n        while mex in a :\n            mex += 1\n        if mex > max ( a ) or k == 0 :\n            print ( n + k )\n        elif ( ( max ( a ) + mex + 1 ) // 2 ) in a :\n            print ( n )\n        else :\n            print ( n + 1 )\nPROBLEM ( )\n", "python_code_tokenized": "def PROBLEM ( ) : NEW_LINE INDENT T = [ ] NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mex = 0 NEW_LINE while mex in a : NEW_LINE INDENT mex += 1 NEW_LINE DEDENT if mex > max ( a ) or k == 0 : NEW_LINE INDENT print ( n + k ) NEW_LINE DEDENT elif ( ( max ( a ) + mex + 1 ) // 2 ) in a : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n + 1 ) NEW_LINE DEDENT DEDENT DEDENT PROBLEM ( ) NEW_LINE"}
{"id": "geeksforgeeks_335_A", "sol": 0, "python_code": "mod = 1000000007\ndef fact ( n ) :\n    res = 1\n    for i in range ( 2 , n + 1 ) :\n        res = res * i\n    return res\ndef nCr ( n , r ) :\n    return int ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) )\ndef powmod ( a , n ) :\n    if ( n == 0 ) :\n        return 1\n    pt = powmod ( a , int ( n / 2 ) )\n    pt = ( pt * pt ) % mod\n    if ( n % 2 ) :\n        return ( pt * a ) % mod\n    else :\n        return pt\ndef CountSubset ( arr , n ) :\n    ans = powmod ( 2 , n - 1 )\n    arr.sort ( reverse = False )\n    for i in range ( n ) :\n        j = i + 1\n        while ( j < n and arr [ j ] == arr [ i ] ) :\n            r = n - 1 - j\n            l = i\n            ans = ( ans + nCr ( l + r , l ) ) % mod\n            j += 1\n    return ans\nif __name__ == '__main__' :\n    arr = [ 2 , 3 , 2 ]\n    n = len ( arr )\n    print ( CountSubset ( arr , n ) )\n", "python_code_tokenized": "mod = 1000000007 NEW_LINE def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return int ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) NEW_LINE DEDENT def powmod ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT pt = powmod ( a , int ( n / 2 ) ) NEW_LINE pt = ( pt * pt ) % mod NEW_LINE if ( n % 2 ) : NEW_LINE INDENT return ( pt * a ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return pt NEW_LINE DEDENT DEDENT def CountSubset ( arr , n ) : NEW_LINE INDENT ans = powmod ( 2 , n - 1 ) NEW_LINE arr . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT r = n - 1 - j NEW_LINE l = i NEW_LINE ans = ( ans + nCr ( l + r , l ) ) % mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountSubset ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ARC058_A", "sol": 0, "python_code": "import itertools\ndef solve ( money , dislike_numbers ) :\n    for dm in itertools.count ( ) :\n        pay = money + dm\n        if set ( map ( int , str ( pay ) ) ).isdisjoint ( dislike_numbers ) :\n            return pay\ndef main ( ) :\n    money , _ = map ( int , input ( ).split ( ) )\n    dislike_numbers = set ( map ( int , input ( ).split ( ) ) )\n    print ( solve ( money , dislike_numbers ) )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "import itertools NEW_LINE def solve ( money , dislike_numbers ) : NEW_LINE INDENT for dm in itertools . count ( ) : NEW_LINE INDENT pay = money + dm NEW_LINE if set ( map ( int , str ( pay ) ) ) . isdisjoint ( dislike_numbers ) : NEW_LINE INDENT return pay NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT money , _ = map ( int , input ( ) . split ( ) ) NEW_LINE dislike_numbers = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( solve ( money , dislike_numbers ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_1397_B", "sol": 0, "python_code": "n , s = open ( 0 ) ; print ( min ( sum ( abs ( x - c ** i ) for i , x in enumerate ( sorted ( map ( int , s.split ( ) ) ) ) ) for c in range ( 2 + 9 ** 6 // int ( n ) ** 2 ) ) )\n", "python_code_tokenized": "n , s = open ( 0 ) ; print ( min ( sum ( abs ( x - c ** i ) for i , x in enumerate ( sorted ( map ( int , s . split ( ) ) ) ) ) for c in range ( 2 + 9 ** 6 // int ( n ) ** 2 ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_4364_A", "sol": 0, "python_code": "def isReverseEqual ( s1 , s2 ) :\n    if len ( s1 ) != len ( s2 ) :\n        return False\n    l = len ( s1 )\n    for i in range ( l ) :\n        if s1 [ i ] != s2 [ l - i - 1 ] :\n            return False\n    return True\ndef getWord ( str , n ) :\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            if ( isReverseEqual ( str [ i ] , str [ j ] ) ) :\n                return str [ i ]\n    return \"-1\"\nif __name__ == \"__main__\" :\n    str = [ \"geeks\" , \"for\" , \"skeeg\" ]\n    print ( getWord ( str , 3 ) )\n", "python_code_tokenized": "def isReverseEqual ( s1 , s2 ) : NEW_LINE INDENT if len ( s1 ) != len ( s2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT l = len ( s1 ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if s1 [ i ] != s2 [ l - i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def getWord ( str , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( isReverseEqual ( str [ i ] , str [ j ] ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT DEDENT return \" - 1\" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = [ \" geeks \" , \" for \" , \" skeeg \" ] NEW_LINE print ( getWord ( str , 3 ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC122_D", "sol": 0, "python_code": "def ok ( last4 ) :\n    for i in range ( 4 ) :\n        t = list ( last4 )\n        if i >= 1 :\n            t [ i ] , t [ i - 1 ] = t [ i - 1 ] , t [ i ]\n        if ''.join ( t ).count ( 'AGC' ) >= 1 :\n            return False\n    return True\ndef dfs ( cur , last3 ) :\n    if last3 in memo [ cur ] :\n        return memo [ cur ] [ last3 ]\n    if cur == n :\n        return 1\n    ret = 0\n    for c in \"ACGT\" :\n        if ok ( last3 + c ) :\n            ret = ( ret + dfs ( cur + 1 , last3 [ 1 : ] + c ) ) % mod\n    memo [ cur ] [ last3 ] = ret\n    return ret\nn = int ( input ( ) )\nmod = 10 ** 9 + 7\nmemo = [ { } for i in range ( n + 1 ) ]\nprint ( dfs ( 0 , 'TTT' ) )\n", "python_code_tokenized": "def ok ( last4 ) : NEW_LINE INDENT for i in range ( 4 ) : NEW_LINE INDENT t = list ( last4 ) NEW_LINE if i >= 1 : NEW_LINE INDENT t [ i ] , t [ i - 1 ] = t [ i - 1 ] , t [ i ] NEW_LINE DEDENT if ' ' . join ( t ) . count ( ' AGC ' ) >= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def dfs ( cur , last3 ) : NEW_LINE INDENT if last3 in memo [ cur ] : NEW_LINE INDENT return memo [ cur ] [ last3 ] NEW_LINE DEDENT if cur == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT ret = 0 NEW_LINE for c in \" ACGT \" : NEW_LINE INDENT if ok ( last3 + c ) : NEW_LINE INDENT ret = ( ret + dfs ( cur + 1 , last3 [ 1 : ] + c ) ) % mod NEW_LINE DEDENT DEDENT memo [ cur ] [ last3 ] = ret NEW_LINE return ret NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE memo = [ { } for i in range ( n + 1 ) ] NEW_LINE print ( dfs ( 0 , ' TTT ' ) ) NEW_LINE"}
{"id": "geeksforgeeks_626_A", "sol": 0, "python_code": "N = 100\ndef ansQueries ( prefeven , prefodd , l , r ) :\n    if ( ( r - l + 1 ) % 2 == 0 ) :\n        print ( \"0\" )\n    else :\n        if ( l % 2 == 0 ) :\n            print ( prefeven [ r ] ^ prefeven [ l - 1 ] )\n        else :\n            print ( prefodd [ r ] ^ prefodd [ l - 1 ] )\ndef wrapper ( arr , n , l , r , q ) :\n    prefodd = [ 0 ] * N\n    prefeven = [ 0 ] * N\n    for i in range ( 1 , n + 1 ) :\n        if ( ( i ) % 2 == 0 ) :\n            prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ]\n            prefodd [ i ] = prefodd [ i - 1 ]\n        else :\n            prefeven [ i ] = prefeven [ i - 1 ]\n            prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ]\n    i = 0\n    while ( i != q ) :\n        ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] )\n        i += 1\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 3 , 4 , 5 ]\n    n = len ( arr )\n    l = [ 1 , 1 , 2 ]\n    r = [ 2 , 3 , 4 ]\n    q = len ( l )\n    wrapper ( arr , n , l , r , q )\n", "python_code_tokenized": "N = 100 NEW_LINE def ansQueries ( prefeven , prefodd , l , r ) : NEW_LINE INDENT if ( ( r - l + 1 ) % 2 == 0 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( l % 2 == 0 ) : NEW_LINE INDENT print ( prefeven [ r ] ^ prefeven [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prefodd [ r ] ^ prefodd [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefodd = [ 0 ] * N NEW_LINE prefeven = [ 0 ] * N NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( i ) % 2 == 0 ) : NEW_LINE INDENT prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT prefeven [ i ] = prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i != q ) : NEW_LINE INDENT ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE l = [ 1 , 1 , 2 ] NEW_LINE r = [ 2 , 3 , 4 ] NEW_LINE q = len ( l ) NEW_LINE wrapper ( arr , n , l , r , q ) NEW_LINE DEDENT"}
{"id": "codeforces_16_A", "sol": 0, "python_code": "result = \"YES\"\nn , m = map ( int , input ( ).split ( ) )\nbefore = \"\"\nfor i in range ( n ) :\n    s = input ( )\n    c = s [ 0 : 1 ]\n    if m != s.count ( c ) :\n        result = \"No\"\n        break\n    if i == 0 :\n        before = c\n        continue\n    if c == before :\n        result = \"No\"\n        break\n    before = c\nprint ( result )\n", "python_code_tokenized": "result = \" YES \" NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE before = \" \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE c = s [ 0 : 1 ] NEW_LINE if m != s . count ( c ) : NEW_LINE INDENT result = \" No \" NEW_LINE break NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT before = c NEW_LINE continue NEW_LINE DEDENT if c == before : NEW_LINE INDENT result = \" No \" NEW_LINE break NEW_LINE DEDENT before = c NEW_LINE DEDENT print ( result ) NEW_LINE"}
{"id": "geeksforgeeks_4502_A", "sol": 0, "python_code": "def frequencyDigits ( n , d ) :\n    c = 0 ;\n    while ( n > 0 ) :\n        if ( n % 10 == d ) :\n            c += 1 ;\n        n = int ( n / 10 ) ;\n    return c ;\nN = 1122322 ;\nD = 2 ;\nprint ( frequencyDigits ( N , D ) ) ;\n", "python_code_tokenized": "def frequencyDigits ( n , d ) : NEW_LINE INDENT c = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == d ) : NEW_LINE INDENT c += 1 ; NEW_LINE DEDENT n = int ( n / 10 ) ; NEW_LINE DEDENT return c ; NEW_LINE DEDENT N = 1122322 ; NEW_LINE D = 2 ; NEW_LINE print ( frequencyDigits ( N , D ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_2221_A", "sol": 0, "python_code": "from math import *\ndef countPairs ( N ) :\n    count = 0\n    for i in range ( 1 , int ( sqrt ( N ) ) + 1 ) :\n        sq = i * i\n        diff = N - sq\n        sqrtDiff = int ( sqrt ( diff ) )\n        if sqrtDiff * sqrtDiff == diff :\n            count += 1\n    return count\nif __name__ == \"__main__\" :\n    for i in range ( 1 , 11 ) :\n        print ( \"For n =\" , i , \", \" , countPairs ( i ) , \"pair exists\" )\n", "python_code_tokenized": "from math import * NEW_LINE def countPairs ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( N ) ) + 1 ) : NEW_LINE INDENT sq = i * i NEW_LINE diff = N - sq NEW_LINE sqrtDiff = int ( sqrt ( diff ) ) NEW_LINE if sqrtDiff * sqrtDiff == diff : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT for i in range ( 1 , 11 ) : NEW_LINE INDENT print ( \" For \u2581 n \u2581 = \" , i , \" , \u2581 \" , countPairs ( i ) , \" pair \u2581 exists \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_632_B", "sol": 0, "python_code": "import sys\nimport itertools\nf = sys.stdin\ng = itertools.accumulate\nn = int ( f.readline ( ) )\np = list ( map ( int , f.readline ( ).split ( ) ) )\nc = f.readline ( )\nv = [ - x if y == 'B' else x for x , y in zip ( p , c ) ]\ns = sum ( p [ i ] if c [ i ] == 'B' else 0 for i in range ( n ) )\nprint ( s + max ( 0 , max ( g ( v ) ) , max ( g ( v [ : : - 1 ] ) ) ) )\n", "python_code_tokenized": "import sys NEW_LINE import itertools NEW_LINE f = sys . stdin NEW_LINE g = itertools . accumulate NEW_LINE n = int ( f . readline ( ) ) NEW_LINE p = list ( map ( int , f . readline ( ) . split ( ) ) ) NEW_LINE c = f . readline ( ) NEW_LINE v = [ - x if y == ' B ' else x for x , y in zip ( p , c ) ] NEW_LINE s = sum ( p [ i ] if c [ i ] == ' B ' else 0 for i in range ( n ) ) NEW_LINE print ( s + max ( 0 , max ( g ( v ) ) , max ( g ( v [ : : - 1 ] ) ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_4071_A", "sol": 0, "python_code": "def otherEndPoint ( x1 , y1 , m1 , m2 ) :\n    x2 = ( 2 * m1 - x1 )\n    y2 = ( 2 * m2 - y1 )\n    print ( \"x2 = {}, y2 = {}\".format ( x2 , y2 ) )\nx1 = - 4\ny1 = - 1\nm1 = 3\nm2 = 5\notherEndPoint ( x1 , y1 , m1 , m2 )\n", "python_code_tokenized": "def otherEndPoint ( x1 , y1 , m1 , m2 ) : NEW_LINE INDENT x2 = ( 2 * m1 - x1 ) NEW_LINE y2 = ( 2 * m2 - y1 ) NEW_LINE print ( \" x2 \u2581 = \u2581 { } , \u2581 y2 \u2581 = \u2581 { } \" . format ( x2 , y2 ) ) NEW_LINE DEDENT x1 = - 4 NEW_LINE y1 = - 1 NEW_LINE m1 = 3 NEW_LINE m2 = 5 NEW_LINE otherEndPoint ( x1 , y1 , m1 , m2 ) NEW_LINE"}
{"id": "geeksforgeeks_5186_A", "sol": 0, "python_code": "def findMajority ( arr , size ) :\n    m = { }\n    for i in range ( size ) :\n        if arr [ i ] in m :\n            m [ arr [ i ] ] += 1\n        else :\n            m [ arr [ i ] ] = 1\n    count = 0\n    for key in m :\n        if m [ key ] > size / 2 :\n            count = 1\n            print ( \"Majority found :-\" , key )\n            break\n    if ( count == 0 ) :\n        print ( \"No Majority element\" )\narr = [ 2 , 2 , 2 , 2 , 5 , 5 , 2 , 3 , 3 ]\nn = len ( arr )\nfindMajority ( arr , n )\n", "python_code_tokenized": "def findMajority ( arr , size ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] in m : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for key in m : NEW_LINE INDENT if m [ key ] > size / 2 : NEW_LINE INDENT count = 1 NEW_LINE print ( \" Majority \u2581 found \u2581 : - \" , key ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( \" No \u2581 Majority \u2581 element \" ) NEW_LINE DEDENT DEDENT arr = [ 2 , 2 , 2 , 2 , 5 , 5 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE findMajority ( arr , n ) NEW_LINE"}
{"id": "codeforces_110_A", "sol": 0, "python_code": "a = input ( )\nk = 0\nfor i in range ( len ( a ) ) :\n    if ( a [ i ] == \"4\" or a [ i ] == \"7\" ) :\n        k += 1\nif ( k == 4 or k == 7 ) :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "a = input ( ) NEW_LINE k = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if ( a [ i ] == \"4\" or a [ i ] == \"7\" ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT if ( k == 4 or k == 7 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "codeforces_709_A", "sol": 0, "python_code": "n , b , d = list ( map ( int , input ( ).split ( ) ) )\na = list ( map ( int , input ( ).split ( ) ) )\nwaste = 0\nnum = 0\nfor i in a :\n    if i <= b :\n        waste += i\n    if waste > d :\n        num += 1\n        waste = 0\nprint ( num )\n", "python_code_tokenized": "n , b , d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE waste = 0 NEW_LINE num = 0 NEW_LINE for i in a : NEW_LINE INDENT if i <= b : NEW_LINE INDENT waste += i NEW_LINE DEDENT if waste > d : NEW_LINE INDENT num += 1 NEW_LINE waste = 0 NEW_LINE DEDENT DEDENT print ( num ) NEW_LINE"}
{"id": "codeforces_1073_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = [ int ( i ) for i in input ( ).split ( ) ]\nd = dict ( )\nb = [ i for i in input ( ).split ( ) ]\nfor item in b :\n    d [ item ] = - 1\ni = 0\nfor item in b :\n    if d [ item ] == 0 :\n        print ( 0 , end = ' ' )\n    elif d [ item ] == - 1 :\n        cnt = 1\n        while a [ i ] != int ( item ) and i != n :\n            d [ str ( a [ i ] ) ] = 0\n            cnt += 1\n            i += 1\n        i += 1\n        print ( cnt , end = ' ' )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE d = dict ( ) NEW_LINE b = [ i for i in input ( ) . split ( ) ] NEW_LINE for item in b : NEW_LINE INDENT d [ item ] = - 1 NEW_LINE DEDENT i = 0 NEW_LINE for item in b : NEW_LINE INDENT if d [ item ] == 0 : NEW_LINE INDENT print ( 0 , end = ' \u2581 ' ) NEW_LINE DEDENT elif d [ item ] == - 1 : NEW_LINE INDENT cnt = 1 NEW_LINE while a [ i ] != int ( item ) and i != n : NEW_LINE INDENT d [ str ( a [ i ] ) ] = 0 NEW_LINE cnt += 1 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE print ( cnt , end = ' \u2581 ' ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1512_B", "sol": 0, "python_code": "I = input\ne = enumerate\nfor _ in [ 0 ] * int ( I ( ) ) :\n    n = int ( I ( ) ) ; r = [ [ * I ( ) ] for _ in [ 0 ] * n ] ; ( i , j ) , ( k , l ) = [ ( i , j ) for i , s in e ( r ) for j , x in e ( s ) if '.' > x ] ; k = ( k + ( k == i ) ) % n ; l = ( l + ( l == j ) ) % n ; r [ k ] [ l ] = r [ i ] [ l ] = r [ k ] [ j ] = '*'\n    for s in r : print ( * s , sep = '' )\n", "python_code_tokenized": "I = input NEW_LINE e = enumerate NEW_LINE for _ in [ 0 ] * int ( I ( ) ) : NEW_LINE INDENT n = int ( I ( ) ) ; r = [ [ * I ( ) ] for _ in [ 0 ] * n ] ; ( i , j ) , ( k , l ) = [ ( i , j ) for i , s in e ( r ) for j , x in e ( s ) if ' . ' > x ] ; k = ( k + ( k == i ) ) % n ; l = ( l + ( l == j ) ) % n ; r [ k ] [ l ] = r [ i ] [ l ] = r [ k ] [ j ] = ' * ' NEW_LINE for s in r : print ( * s , sep = ' ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_936_A", "sol": 0, "python_code": "import math\nclass Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.next = None\ndef push ( head , data ) :\n    if not head :\n        return Node ( data )\n    new_node = Node ( data )\n    new_node.next = head\n    head = new_node\n    return head\ndef productOfNodes ( head ) :\n    ptr = head\n    product = 1\n    while ( ptr ) :\n        product *= ptr.data\n        ptr = ptr.next\n    return product\nif __name__ == '__main__' :\n    head = None\n    head = push ( head , 7 )\n    head = push ( head , 6 )\n    head = push ( head , 8 )\n    head = push ( head , 4 )\n    head = push ( head , 1 )\n    print ( \"Product = {}\".format ( productOfNodes ( head ) ) )\n", "python_code_tokenized": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head , data ) : NEW_LINE INDENT if not head : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT new_node = Node ( data ) NEW_LINE new_node . next = head NEW_LINE head = new_node NEW_LINE return head NEW_LINE DEDENT def productOfNodes ( head ) : NEW_LINE INDENT ptr = head NEW_LINE product = 1 NEW_LINE while ( ptr ) : NEW_LINE INDENT product *= ptr . data NEW_LINE ptr = ptr . next NEW_LINE DEDENT return product NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 1 ) NEW_LINE print ( \" Product \u2581 = \u2581 { } \" . format ( productOfNodes ( head ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2148_A", "sol": 0, "python_code": "n = input ( )\ns = int ( n , 2 )\nprint ( s )\n", "python_code_tokenized": "n = input ( ) NEW_LINE s = int ( n , 2 ) NEW_LINE print ( s ) NEW_LINE"}
{"id": "geeksforgeeks_1853_A", "sol": 0, "python_code": "N = 3\nM = 3\ndef check ( a , b ) :\n    for i in range ( 1 , N , 1 ) :\n        for j in range ( 1 , M , 1 ) :\n            if ( a [ i ] [ j ] != b [ i ] [ j ] ) :\n                a [ i ] [ j ] ^= 1\n                a [ 0 ] [ 0 ] ^= 1\n                a [ 0 ] [ j ] ^= 1\n                a [ i ] [ 0 ] ^= 1\n    for i in range ( N ) :\n        for j in range ( M ) :\n            if ( a [ i ] [ j ] != b [ i ] [ j ] ) :\n                return False\n    return True\nif __name__ == '__main__' :\n    a = [ [ 0 , 1 , 0 ] , [ 0 , 1 , 0 ] , [ 1 , 0 , 0 ] ]\n    b = [ [ 1 , 0 , 0 ] , [ 1 , 0 , 0 ] , [ 1 , 0 , 0 ] ]\n    if ( check ( a , b ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "N = 3 NEW_LINE M = 3 NEW_LINE def check ( a , b ) : NEW_LINE INDENT for i in range ( 1 , N , 1 ) : NEW_LINE INDENT for j in range ( 1 , M , 1 ) : NEW_LINE INDENT if ( a [ i ] [ j ] != b [ i ] [ j ] ) : NEW_LINE INDENT a [ i ] [ j ] ^= 1 NEW_LINE a [ 0 ] [ 0 ] ^= 1 NEW_LINE a [ 0 ] [ j ] ^= 1 NEW_LINE a [ i ] [ 0 ] ^= 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( a [ i ] [ j ] != b [ i ] [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ [ 0 , 1 , 0 ] , [ 0 , 1 , 0 ] , [ 1 , 0 , 0 ] ] NEW_LINE b = [ [ 1 , 0 , 0 ] , [ 1 , 0 , 0 ] , [ 1 , 0 , 0 ] ] NEW_LINE if ( check ( a , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1406_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    n = int ( input ( ) )\n    l = list ( map ( int , input ( ).split ( ) ) )\n    c = [ 0 ] * 101\n    for i in l :\n        c [ i ] += 1\n    n1 , n2 = 0 , 0\n    i = 0\n    while i < len ( l ) and c [ i ] >= 2 :\n        i += 1\n    n1 = i\n    while i < len ( l ) and c [ i ] >= 1 :\n        i += 1\n    n2 = i\n    print ( n1 + n2 )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = [ 0 ] * 101 NEW_LINE for i in l : NEW_LINE INDENT c [ i ] += 1 NEW_LINE DEDENT n1 , n2 = 0 , 0 NEW_LINE i = 0 NEW_LINE while i < len ( l ) and c [ i ] >= 2 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT n1 = i NEW_LINE while i < len ( l ) and c [ i ] >= 1 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT n2 = i NEW_LINE print ( n1 + n2 ) NEW_LINE DEDENT"}
{"id": "codejam_11_01", "sol": 0, "python_code": "import sys , re\nfrom pprint import pprint\nfi = open ( 'A-large.in' , 'r' )\nfo = open ( 'A-large.out' , 'w' )\nt = int ( fi.readline ( ) )\nfor _ in range ( 1 , t + 1 ) :\n    inp = fi.readline ( ).split ( )\n    n = int ( inp [ 0 ] )\n    btn = zip ( inp [ 1 : : 2 ] , map ( int , inp [ 2 : : 2 ] ) )\n    o = b = 1\n    to = tb = 0\n    for c , x in btn :\n        if c == 'O' :\n            to , o = to + abs ( x - o ) + 1 , x\n            to = max ( to , tb + 1 )\n        else :\n            tb , b = tb + abs ( x - b ) + 1 , x\n            tb = max ( tb , to + 1 )\n    fo.write ( 'Case #%d: %d\\n' % ( _ , max ( to , tb ) ) )\nfi.close ( )\nfo.close ( )\n", "python_code_tokenized": "import sys , re NEW_LINE from pprint import pprint NEW_LINE fi = open ( ' A - large . in ' , ' r ' ) NEW_LINE fo = open ( ' A - large . out ' , ' w ' ) NEW_LINE t = int ( fi . readline ( ) ) NEW_LINE for _ in range ( 1 , t + 1 ) : NEW_LINE INDENT inp = fi . readline ( ) . split ( ) NEW_LINE n = int ( inp [ 0 ] ) NEW_LINE btn = zip ( inp [ 1 : : 2 ] , map ( int , inp [ 2 : : 2 ] ) ) NEW_LINE o = b = 1 NEW_LINE to = tb = 0 NEW_LINE for c , x in btn : NEW_LINE INDENT if c == ' O ' : NEW_LINE INDENT to , o = to + abs ( x - o ) + 1 , x NEW_LINE to = max ( to , tb + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT tb , b = tb + abs ( x - b ) + 1 , x NEW_LINE tb = max ( tb , to + 1 ) NEW_LINE DEDENT DEDENT fo . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( _ , max ( to , tb ) ) ) NEW_LINE DEDENT fi . close ( ) NEW_LINE fo . close ( ) NEW_LINE"}
{"id": "codeforces_602_B", "sol": 0, "python_code": "n = int ( input ( ) )\nA = list ( map ( int , input ( ).split ( ) ) )\ndef constRange ( A ) :\n    l , r = 0 , 1\n    d = { }\n    d [ A [ l ] ] = l\n    d [ A [ r ] ] = r\n    mx = max ( A [ l ] , A [ r ] )\n    mi = min ( A [ l ] , A [ r ] )\n    ans = 0\n    while r < len ( A ) :\n        while mx - mi <= 1 :\n            r += 1\n            if r >= len ( A ) : break\n            d [ A [ r ] ] = r\n            if A [ r ] >= mx :\n                mx = A [ r ]\n            if A [ r ] <= mi :\n                mi = A [ r ]\n        ans = max ( ans , r - l )\n        if r >= len ( A ) : break\n        if A [ r ] > mi :\n            l = d [ mi ] + 1\n            mi += 1\n        else :\n            l = d [ mx ] + 1\n            mx -= 1\n    return ans\nprint ( constRange ( A ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def constRange ( A ) : NEW_LINE INDENT l , r = 0 , 1 NEW_LINE d = { } NEW_LINE d [ A [ l ] ] = l NEW_LINE d [ A [ r ] ] = r NEW_LINE mx = max ( A [ l ] , A [ r ] ) NEW_LINE mi = min ( A [ l ] , A [ r ] ) NEW_LINE ans = 0 NEW_LINE while r < len ( A ) : NEW_LINE INDENT while mx - mi <= 1 : NEW_LINE INDENT r += 1 NEW_LINE if r >= len ( A ) : break NEW_LINE d [ A [ r ] ] = r NEW_LINE if A [ r ] >= mx : NEW_LINE INDENT mx = A [ r ] NEW_LINE DEDENT if A [ r ] <= mi : NEW_LINE INDENT mi = A [ r ] NEW_LINE DEDENT DEDENT ans = max ( ans , r - l ) NEW_LINE if r >= len ( A ) : break NEW_LINE if A [ r ] > mi : NEW_LINE INDENT l = d [ mi ] + 1 NEW_LINE mi += 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = d [ mx ] + 1 NEW_LINE mx -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT print ( constRange ( A ) ) NEW_LINE"}
{"id": "atcoder_ABC154_D", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nP = list ( map ( int , input ( ).split ( ) ) )\nme = [ 0 ]\nfor i in range ( n ) :\n    p = ( P [ i ] * ( P [ i ] + 1 ) / 2 ) / P [ i ]\n    me.append ( me [ ( i + 1 ) - 1 ] + p )\nans = 0\nfor i in range ( k , n + 1 ) :\n    ans = max ( ans , me [ i ] - me [ i - k ] )\nprint ( ans )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE P = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE me = [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = ( P [ i ] * ( P [ i ] + 1 ) / 2 ) / P [ i ] NEW_LINE me . append ( me [ ( i + 1 ) - 1 ] + p ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( k , n + 1 ) : NEW_LINE INDENT ans = max ( ans , me [ i ] - me [ i - k ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "atcoder_ABC166_C", "sol": 0, "python_code": "import sys\ndef _i ( ) : return int ( sys.stdin.readline ( ).strip ( ) )\ndef _ia ( ) : return map ( int , sys.stdin.readline ( ).strip ( ).split ( ) )\ndef main ( ) :\n    n , m = _ia ( )\n    h = list ( _ia ( ) )\n    adj = [ [ ] for _ in range ( n ) ]\n    for _ in range ( m ) :\n        a , b = _ia ( )\n        adj [ a - 1 ].append ( b - 1 )\n        adj [ b - 1 ].append ( a - 1 )\n    ans = 0\n    for i in range ( n ) :\n        hi = h [ i ]\n        f = True\n        for j in adj [ i ] :\n            hj = h [ j ]\n            if hi <= hj :\n                f = False\n                break\n        if f :\n            ans += 1\n    return ans\nif __name__ == \"__main__\" :\n    print ( main ( ) )\n", "python_code_tokenized": "import sys NEW_LINE def _i ( ) : return int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE def _ia ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE def main ( ) : NEW_LINE INDENT n , m = _ia ( ) NEW_LINE h = list ( _ia ( ) ) NEW_LINE adj = [ [ ] for _ in range ( n ) ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b = _ia ( ) NEW_LINE adj [ a - 1 ] . append ( b - 1 ) NEW_LINE adj [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT hi = h [ i ] NEW_LINE f = True NEW_LINE for j in adj [ i ] : NEW_LINE INDENT hj = h [ j ] NEW_LINE if hi <= hj : NEW_LINE INDENT f = False NEW_LINE break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( main ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_118_B", "sol": 0, "python_code": "n = int ( input ( ) )\nn1 = n\ns = [ '' ] * ( n * 2 + 1 )\nfor i in range ( n + 1 ) :\n    stro = ' ' * ( n * 2 - i * 2 ) + '0'\n    for j in range ( 1 , i + 1 ) :\n        stro = stro + ' ' + str ( j )\n    stro2 = stro [ : : - 1 ]\n    stro2 = stro2.rstrip ( )\n    s [ i ] = stro + stro2 [ 1 : : ]\n    if n != i :\n        s [ n * 2 - i ] = s [ i ]\nfor i in range ( n * 2 + 1 ) :\n    print ( s [ i ] )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE n1 = n NEW_LINE s = [ ' ' ] * ( n * 2 + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT stro = ' \u2581 ' * ( n * 2 - i * 2 ) + '0' NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT stro = stro + ' \u2581 ' + str ( j ) NEW_LINE DEDENT stro2 = stro [ : : - 1 ] NEW_LINE stro2 = stro2 . rstrip ( ) NEW_LINE s [ i ] = stro + stro2 [ 1 : : ] NEW_LINE if n != i : NEW_LINE INDENT s [ n * 2 - i ] = s [ i ] NEW_LINE DEDENT DEDENT for i in range ( n * 2 + 1 ) : NEW_LINE INDENT print ( s [ i ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3082_A", "sol": 0, "python_code": "def sumOfDigitsFrom1ToN ( n ) :\n    result = 0\n    for x in range ( 1 , n + 1 ) :\n        result = result + sumOfDigits ( x )\n    return result\ndef sumOfDigits ( x ) :\n    sum = 0\n    while ( x != 0 ) :\n        sum = sum + x % 10\n        x = x // 10\n    return sum\nn = 328\nprint ( \"Sum of digits in numbers from 1 to\" , n , \"is\" , sumOfDigitsFrom1ToN ( n ) )\n", "python_code_tokenized": "def sumOfDigitsFrom1ToN ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT result = result + sumOfDigits ( x ) NEW_LINE DEDENT return result NEW_LINE DEDENT def sumOfDigits ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 328 NEW_LINE print ( \" Sum \u2581 of \u2581 digits \u2581 in \u2581 numbers \u2581 from \u2581 1 \u2581 to \" , n , \" is \" , sumOfDigitsFrom1ToN ( n ) ) NEW_LINE"}
{"id": "atcoder_ABC142_E", "sol": 0, "python_code": "INF = 2 * 10 ** 7\ndef main ( ) :\n    N , M = ( int ( i ) for i in input ( ).split ( ) )\n    A = [ ]\n    B = [ ]\n    C = [ ]\n    for _ in range ( M ) :\n        a , b = ( int ( i ) for i in input ( ).split ( ) )\n        A.append ( a )\n        B.append ( b )\n        C.append ( { int ( i ) for i in input ( ).split ( ) } )\n    dp = [ [ INF ] * ( 1 << N ) for _ in range ( M + 1 ) ]\n    dp [ 0 ] [ 0 ] = 0\n    for i in range ( M ) :\n        for j in range ( 1 << N ) :\n            dp [ i + 1 ] [ j ] = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] )\n            if dp [ i ] [ j ] != INF :\n                next_bit = j\n                for bit in C [ i ] :\n                    next_bit |= ( 1 << ( bit - 1 ) )\n                dp [ i + 1 ] [ next_bit ] = min ( dp [ i + 1 ] [ next_bit ] , dp [ i ] [ j ] + A [ i ] )\n    ans = dp [ - 1 ] [ - 1 ]\n    if ans == INF :\n        print ( - 1 )\n    else :\n        print ( ans )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "INF = 2 * 10 ** 7 NEW_LINE def main ( ) : NEW_LINE INDENT N , M = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE A = [ ] NEW_LINE B = [ ] NEW_LINE C = [ ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT a , b = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE A . append ( a ) NEW_LINE B . append ( b ) NEW_LINE C . append ( { int ( i ) for i in input ( ) . split ( ) } ) NEW_LINE DEDENT dp = [ [ INF ] * ( 1 << N ) for _ in range ( M + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( 1 << N ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE if dp [ i ] [ j ] != INF : NEW_LINE INDENT next_bit = j NEW_LINE for bit in C [ i ] : NEW_LINE INDENT next_bit |= ( 1 << ( bit - 1 ) ) NEW_LINE DEDENT dp [ i + 1 ] [ next_bit ] = min ( dp [ i + 1 ] [ next_bit ] , dp [ i ] [ j ] + A [ i ] ) NEW_LINE DEDENT DEDENT DEDENT ans = dp [ - 1 ] [ - 1 ] NEW_LINE if ans == INF : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4241_A", "sol": 0, "python_code": "def countTriplets ( arr , n , a , b ) :\n    ans = 0\n    for i in range ( 0 , n - 2 ) :\n        for j in range ( i + 1 , n - 1 ) :\n            for k in range ( j + 1 , n ) :\n                if ( ( arr [ i ] + arr [ j ] + arr [ k ] >= a ) and ( arr [ i ] + arr [ j ] + arr [ k ] <= b ) ) :\n                    ans += 1\n    return ans\nif __name__ == \"__main__\" :\n    arr = [ 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 ]\n    n = len ( arr )\n    a = 8 ; b = 16\n    print ( countTriplets ( arr , n , a , b ) )\n", "python_code_tokenized": "def countTriplets ( arr , n , a , b ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] + arr [ j ] + arr [ k ] >= a ) and ( arr [ i ] + arr [ j ] + arr [ k ] <= b ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE a = 8 ; b = 16 NEW_LINE print ( countTriplets ( arr , n , a , b ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1987_A", "sol": 0, "python_code": "def countBits ( n ) :\n    count = 0 ;\n    while ( n ) :\n        count += 1 ;\n        n >>= 1 ;\n    return count ;\nn = 32 ;\nprint ( \"Minimum value of K is =\" , countBits ( n ) ) ;\n", "python_code_tokenized": "def countBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT n = 32 ; NEW_LINE print ( \" Minimum \u2581 value \u2581 of \u2581 K \u2581 is \u2581 = \" , countBits ( n ) ) ; NEW_LINE"}
{"id": "atcoder_ARC098_A", "sol": 0, "python_code": "n = int ( input ( ) )\ns = input ( )\na = [ 0 ] * n\nif ( s [ 0 ] == 'W' ) :\n    a [ 0 ] = 1\nfor i in range ( 1 , n ) :\n    if ( s [ i ] == 'W' ) :\n        a [ i ] = a [ i - 1 ] + 1\n    else :\n        a [ i ] = a [ i - 1 ]\nans = min ( n - a [ n - 1 ] + a [ 0 ] - 1 , a [ n - 2 ] )\nfor j in range ( 1 , n - 1 ) :\n    x = a [ j - 1 ] + ( n - j - 1 ) - ( a [ n - 1 ] - a [ j ] )\n    if ( x < ans ) :\n        ans = x\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ 0 ] * n NEW_LINE if ( s [ 0 ] == ' W ' ) : NEW_LINE INDENT a [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == ' W ' ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = a [ i - 1 ] NEW_LINE DEDENT DEDENT ans = min ( n - a [ n - 1 ] + a [ 0 ] - 1 , a [ n - 2 ] ) NEW_LINE for j in range ( 1 , n - 1 ) : NEW_LINE INDENT x = a [ j - 1 ] + ( n - j - 1 ) - ( a [ n - 1 ] - a [ j ] ) NEW_LINE if ( x < ans ) : NEW_LINE INDENT ans = x NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_282_A", "sol": 0, "python_code": "n = int ( input ( ) )\nres = 0\nfor _ in range ( n ) :\n    li = list ( input ( ) )\n    for i in li :\n        if i == '+' :\n            res += 1\n            break\n        elif i == '-' :\n            res -= 1\n            break\nprint ( res )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE res = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT li = list ( input ( ) ) NEW_LINE for i in li : NEW_LINE INDENT if i == ' + ' : NEW_LINE INDENT res += 1 NEW_LINE break NEW_LINE DEDENT elif i == ' - ' : NEW_LINE INDENT res -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE"}
{"id": "geeksforgeeks_1162_A", "sol": 0, "python_code": "def isVowel ( c ) :\n    return ( c == 'a' or c == 'A' or c == 'e' or c == 'E' or c == 'i' or c == 'I' or c == 'o' or c == 'O' or c == 'u' or c == 'U' )\ndef reverseVowel ( str ) :\n    i = 0\n    j = len ( str ) - 1\n    while ( i < j ) :\n        if not isVowel ( str [ i ] ) :\n            i += 1\n            continue\n        if ( not isVowel ( str [ j ] ) ) :\n            j -= 1\n            continue\n        str [ i ] , str [ j ] = str [ j ] , str [ i ]\n        i += 1\n        j -= 1\n    return str\nif __name__ == \"__main__\" :\n    str = \"hello world\"\n    print ( * reverseVowel ( list ( str ) ) , sep = \"\" )\n", "python_code_tokenized": "def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) NEW_LINE DEDENT def reverseVowel ( str ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( str ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if not isVowel ( str [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT if ( not isVowel ( str [ j ] ) ) : NEW_LINE INDENT j -= 1 NEW_LINE continue NEW_LINE DEDENT str [ i ] , str [ j ] = str [ j ] , str [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" hello \u2581 world \" NEW_LINE print ( * reverseVowel ( list ( str ) ) , sep = \" \" ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC016_B", "sol": 0, "python_code": "from collections import Counter\ndef cat ( ) :\n    N = int ( input ( ) )\n    A = list ( map ( int , input ( ).split ( ) ) )\n    if A == [ 1 ] * N :\n        return True\n    if A == [ N - 1 ] * N :\n        return True\n    Aset = set ( A )\n    if len ( Aset ) == 1 :\n        Amax = A [ 0 ]\n        cnt = N - Amax + 1\n        if N <= 2 * cnt - 2 :\n            return True\n        else :\n            return False\n    elif len ( Aset ) == 2 :\n        A.sort ( )\n        Amax = A [ - 1 ]\n        Amin = A [ 0 ]\n        if Amin + 1 != Amax :\n            return False\n        lower = N - Amax + 1\n        upper = 2 * lower - 2\n        c = Counter ( A )\n        if lower <= c [ Amax ] <= upper :\n            return True\n        else :\n            return False\n    else :\n        return False\nif __name__ == \"__main__\" :\n    if cat ( ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "from collections import Counter NEW_LINE def cat ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if A == [ 1 ] * N : NEW_LINE INDENT return True NEW_LINE DEDENT if A == [ N - 1 ] * N : NEW_LINE INDENT return True NEW_LINE DEDENT Aset = set ( A ) NEW_LINE if len ( Aset ) == 1 : NEW_LINE INDENT Amax = A [ 0 ] NEW_LINE cnt = N - Amax + 1 NEW_LINE if N <= 2 * cnt - 2 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif len ( Aset ) == 2 : NEW_LINE INDENT A . sort ( ) NEW_LINE Amax = A [ - 1 ] NEW_LINE Amin = A [ 0 ] NEW_LINE if Amin + 1 != Amax : NEW_LINE INDENT return False NEW_LINE DEDENT lower = N - Amax + 1 NEW_LINE upper = 2 * lower - 2 NEW_LINE c = Counter ( A ) NEW_LINE if lower <= c [ Amax ] <= upper : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT if cat ( ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2926_A", "sol": 0, "python_code": "NA = - 1\ndef moveToEnd ( mPlusN , size ) :\n    i = 0\n    j = size - 1\n    for i in range ( size - 1 , - 1 , - 1 ) :\n        if ( mPlusN [ i ] != NA ) :\n            mPlusN [ j ] = mPlusN [ i ]\n            j -= 1\ndef merge ( mPlusN , N , m , n ) :\n    i = n\n    j = 0\n    k = 0\n    while ( k < ( m + n ) ) :\n        if ( ( i < ( m + n ) and mPlusN [ i ] <= N [ j ] ) or ( j == n ) ) :\n            mPlusN [ k ] = mPlusN [ i ]\n            k += 1\n            i += 1\n        else :\n            mPlusN [ k ] = N [ j ]\n            k += 1\n            j += 1\ndef printArray ( arr , size ) :\n    for i in range ( size ) :\n        print ( arr [ i ] , \"\" , end = \"\" )\n    print ( )\nmPlusN = [ 2 , 8 , NA , NA , NA , 13 , NA , 15 , 20 ]\nN = [ 5 , 7 , 9 , 25 ]\nn = len ( N )\nm = len ( mPlusN ) - n\nmoveToEnd ( mPlusN , m + n )\nmerge ( mPlusN , N , m , n )\nprintArray ( mPlusN , m + n )\n", "python_code_tokenized": "NA = - 1 NEW_LINE def moveToEnd ( mPlusN , size ) : NEW_LINE INDENT i = 0 NEW_LINE j = size - 1 NEW_LINE for i in range ( size - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mPlusN [ i ] != NA ) : NEW_LINE INDENT mPlusN [ j ] = mPlusN [ i ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT def merge ( mPlusN , N , m , n ) : NEW_LINE INDENT i = n NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( k < ( m + n ) ) : NEW_LINE INDENT if ( ( i < ( m + n ) and mPlusN [ i ] <= N [ j ] ) or ( j == n ) ) : NEW_LINE INDENT mPlusN [ k ] = mPlusN [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mPlusN [ k ] = N [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT mPlusN = [ 2 , 8 , NA , NA , NA , 13 , NA , 15 , 20 ] NEW_LINE N = [ 5 , 7 , 9 , 25 ] NEW_LINE n = len ( N ) NEW_LINE m = len ( mPlusN ) - n NEW_LINE moveToEnd ( mPlusN , m + n ) NEW_LINE merge ( mPlusN , N , m , n ) NEW_LINE printArray ( mPlusN , m + n ) NEW_LINE"}
{"id": "projecteuler_p035_A", "sol": 0, "python_code": "import eulerlib\ndef compute ( ) :\n    isprime = eulerlib.list_primality ( 999999 )\n    def is_circular_prime ( n ) :\n        s = str ( n )\n        return all ( isprime [ int ( s [ i : ] + s [ : i ] ) ] for i in range ( len ( s ) ) )\n    ans = sum ( 1 for i in range ( len ( isprime ) ) if is_circular_prime ( i ) )\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT isprime = eulerlib . list_primality ( 999999 ) NEW_LINE def is_circular_prime ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE return all ( isprime [ int ( s [ i : ] + s [ : i ] ) ] for i in range ( len ( s ) ) ) NEW_LINE DEDENT ans = sum ( 1 for i in range ( len ( isprime ) ) if is_circular_prime ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1680_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    a , b , c , d = map ( int , input ( ).split ( ) )\n    print ( max ( a , c ) if max ( a , c ) <= min ( b , d ) else a + c )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( a , c ) if max ( a , c ) <= min ( b , d ) else a + c ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1849_A", "sol": 0, "python_code": "import math\ndef invertBits ( n ) :\n    x = int ( math.log ( n , 2 ) )\n    m = 1 << x\n    m = m | m - 1\n    n = n ^ m\n    return n\nn = 20\nprint ( invertBits ( n ) )\n", "python_code_tokenized": "import math NEW_LINE def invertBits ( n ) : NEW_LINE INDENT x = int ( math . log ( n , 2 ) ) NEW_LINE m = 1 << x NEW_LINE m = m | m - 1 NEW_LINE n = n ^ m NEW_LINE return n NEW_LINE DEDENT n = 20 NEW_LINE print ( invertBits ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_443_A", "sol": 0, "python_code": "def checkTypeOfTriangle ( a , b , c ) :\n    sqa = pow ( a , 2 )\n    sqb = pow ( b , 2 )\n    sqc = pow ( c , 2 )\n    if ( sqa == sqa + sqb or sqb == sqa + sqc or sqc == sqa + sqb ) :\n        print ( \"Right-angled Triangle\" )\n    elif ( sqa > sqc + sqb or sqb > sqa + sqc or sqc > sqa + sqb ) :\n        print ( \"Obtuse-angled Triangle\" )\n    else :\n        print ( \"Acute-angled Triangle\" )\nif __name__ == '__main__' :\n    a = 2\n    b = 2\n    c = 2\n    checkTypeOfTriangle ( a , b , c )\n", "python_code_tokenized": "def checkTypeOfTriangle ( a , b , c ) : NEW_LINE INDENT sqa = pow ( a , 2 ) NEW_LINE sqb = pow ( b , 2 ) NEW_LINE sqc = pow ( c , 2 ) NEW_LINE if ( sqa == sqa + sqb or sqb == sqa + sqc or sqc == sqa + sqb ) : NEW_LINE INDENT print ( \" Right - angled \u2581 Triangle \" ) NEW_LINE DEDENT elif ( sqa > sqc + sqb or sqb > sqa + sqc or sqc > sqa + sqb ) : NEW_LINE INDENT print ( \" Obtuse - angled \u2581 Triangle \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Acute - angled \u2581 Triangle \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 2 NEW_LINE b = 2 NEW_LINE c = 2 NEW_LINE checkTypeOfTriangle ( a , b , c ) NEW_LINE DEDENT"}
{"id": "atcoder_ARC098_B", "sol": 0, "python_code": "N = int ( input ( ) )\n* A , = map ( int , input ( ).split ( ) )\nl = 0\nr = 0\nans = 0\nx = 0\nfor l in range ( N ) :\n    while r < N and x & A [ r ] == 0 :\n        x ^= A [ r ]\n        r += 1\n    ans += r - l\n    if l == r :\n        r += 1\n        x = 0\n    else :\n        x ^= A [ l ]\nprint ( ans )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE * A , = map ( int , input ( ) . split ( ) ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE ans = 0 NEW_LINE x = 0 NEW_LINE for l in range ( N ) : NEW_LINE INDENT while r < N and x & A [ r ] == 0 : NEW_LINE INDENT x ^= A [ r ] NEW_LINE r += 1 NEW_LINE DEDENT ans += r - l NEW_LINE if l == r : NEW_LINE INDENT r += 1 NEW_LINE x = 0 NEW_LINE DEDENT else : NEW_LINE INDENT x ^= A [ l ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_4875_A", "sol": 0, "python_code": "def minimumDeletions ( a , n ) :\n    if ( n <= 2 ) :\n        return 0\n    count = 0\n    for i in range ( n - 2 ) :\n        if ( ( a [ i ] < a [ i + 1 ] and a [ i + 1 ] < a [ i + 2 ] ) or ( a [ i ] > a [ i + 1 ] and a [ i + 1 ] > a [ i + 2 ] ) ) :\n            count += 1\n    return count\na = [ 5 , 2 , 3 , 6 , 1 ]\nn = len ( a )\nprint ( minimumDeletions ( a , n ) )\n", "python_code_tokenized": "def minimumDeletions ( a , n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( ( a [ i ] < a [ i + 1 ] and a [ i + 1 ] < a [ i + 2 ] ) or ( a [ i ] > a [ i + 1 ] and a [ i + 1 ] > a [ i + 2 ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT a = [ 5 , 2 , 3 , 6 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumDeletions ( a , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_307_A", "sol": 0, "python_code": "def maxSubArraySum ( arr , size ) :\n    max_so_far = arr [ 0 ]\n    curr_max = arr [ 0 ]\n    for i in range ( 1 , size ) :\n        curr_max = max ( arr [ i ] , curr_max + arr [ i ] )\n        max_so_far = max ( max_so_far , curr_max )\n    return max_so_far\ndef lenOfLongSubarrWithGivenSum ( arr , n , k ) :\n    um = dict ( )\n    Sum , maxLen = 0 , 0\n    for i in range ( n ) :\n        Sum += arr [ i ]\n        if ( Sum == k ) :\n            maxLen = i + 1\n        if ( Sum not in um.keys ( ) ) :\n            um [ Sum ] = i\n        if ( Sum in um.keys ( ) ) :\n            if ( ( Sum - k ) in um.keys ( ) and maxLen < ( i - um [ Sum - k ] ) ) :\n                maxLen = i - um [ Sum - k ]\n    return maxLen\ndef lenLongSubarrWithMaxSum ( arr , n ) :\n    maxSum = maxSubArraySum ( arr , n )\n    return lenOfLongSubarrWithGivenSum ( arr , n , maxSum )\narr = [ 5 , - 2 , - 1 , 3 , - 4 ]\nn = len ( arr )\nprint ( \"Length of longest subarray having maximum sum = \" , lenLongSubarrWithMaxSum ( arr , n ) )\n", "python_code_tokenized": "def maxSubArraySum ( arr , size ) : NEW_LINE INDENT max_so_far = arr [ 0 ] NEW_LINE curr_max = arr [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( arr [ i ] , curr_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT def lenOfLongSubarrWithGivenSum ( arr , n , k ) : NEW_LINE INDENT um = dict ( ) NEW_LINE Sum , maxLen = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( Sum == k ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT if ( Sum not in um . keys ( ) ) : NEW_LINE INDENT um [ Sum ] = i NEW_LINE DEDENT if ( Sum in um . keys ( ) ) : NEW_LINE INDENT if ( ( Sum - k ) in um . keys ( ) and maxLen < ( i - um [ Sum - k ] ) ) : NEW_LINE INDENT maxLen = i - um [ Sum - k ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT def lenLongSubarrWithMaxSum ( arr , n ) : NEW_LINE INDENT maxSum = maxSubArraySum ( arr , n ) NEW_LINE return lenOfLongSubarrWithGivenSum ( arr , n , maxSum ) NEW_LINE DEDENT arr = [ 5 , - 2 , - 1 , 3 , - 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length \u2581 of \u2581 longest \u2581 subarray \u2581 having \u2581 maximum \u2581 sum \u2581 = \u2581 \" , lenLongSubarrWithMaxSum ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_1305_B", "sol": 0, "python_code": "s = input ( )\nl = [ ]\nfor j in range ( len ( s ) ) :\n    l.append ( s [ j ] )\nans = [ ]\nf = 0\nr = len ( s ) - 1\nwhile f < r :\n    if l [ f ] == \"(\" and l [ r ] == \")\" :\n        ans.append ( f + 1 )\n        ans.append ( r + 1 )\n        f += 1\n        r -= 1\n    elif l [ f ] == \"(\" and l [ r ] != \")\" :\n        r -= 1\n    elif l [ f ] != \"(\" and l [ r ] == \")\" :\n        f += 1\n    else :\n        f += 1\n        r -= 1\nif len ( ans ) == 0 :\n    print ( 0 )\nelse :\n    print ( 1 )\n    print ( len ( ans ) )\n    ans.sort ( )\n    print ( * ans )\n", "python_code_tokenized": "s = input ( ) NEW_LINE l = [ ] NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT l . append ( s [ j ] ) NEW_LINE DEDENT ans = [ ] NEW_LINE f = 0 NEW_LINE r = len ( s ) - 1 NEW_LINE while f < r : NEW_LINE INDENT if l [ f ] == \" ( \" and l [ r ] == \" ) \" : NEW_LINE INDENT ans . append ( f + 1 ) NEW_LINE ans . append ( r + 1 ) NEW_LINE f += 1 NEW_LINE r -= 1 NEW_LINE DEDENT elif l [ f ] == \" ( \" and l [ r ] != \" ) \" : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT elif l [ f ] != \" ( \" and l [ r ] == \" ) \" : NEW_LINE INDENT f += 1 NEW_LINE DEDENT else : NEW_LINE INDENT f += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT if len ( ans ) == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( len ( ans ) ) NEW_LINE ans . sort ( ) NEW_LINE print ( * ans ) NEW_LINE DEDENT"}
{"id": "codeforces_937_A", "sol": 0, "python_code": "y = int ( input ( ) )\ne2 = list ( map ( int , input ( ).split ( ) ) )\nwhile ( 0 in e2 ) :\n    e2.remove ( 0 )\ne2 = set ( e2 )\nprint ( len ( e2 ) )\n", "python_code_tokenized": "y = int ( input ( ) ) NEW_LINE e2 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE while ( 0 in e2 ) : NEW_LINE INDENT e2 . remove ( 0 ) NEW_LINE DEDENT e2 = set ( e2 ) NEW_LINE print ( len ( e2 ) ) NEW_LINE"}
{"id": "aizu_p02190_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nprint ( len ( set ( a ) ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( len ( set ( a ) ) ) NEW_LINE"}
{"id": "codeforces_1540_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    a = sorted ( [ int ( i ) for i in input ( ).split ( ) ] )\n    sum = a [ - 1 ]\n    neg = 0\n    for i in range ( 1 , n ) :\n        val = neg + i * ( a [ i ] - a [ i - 1 ] )\n        sum -= val\n        neg = val\n    print ( sum )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE sum = a [ - 1 ] NEW_LINE neg = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT val = neg + i * ( a [ i ] - a [ i - 1 ] ) NEW_LINE sum -= val NEW_LINE neg = val NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1537_A", "sol": 0, "python_code": "def pairInSortedRotated ( arr , n , x ) :\n    for i in range ( 0 , n - 1 ) :\n        if ( arr [ i ] > arr [ i + 1 ] ) :\n            break ;\n    l = ( i + 1 ) % n\n    r = i\n    while ( l != r ) :\n        if ( arr [ l ] + arr [ r ] == x ) :\n            return True ;\n        if ( arr [ l ] + arr [ r ] < x ) :\n            l = ( l + 1 ) % n ;\n        else :\n            r = ( n + r - 1 ) % n ;\n    return False ;\narr = [ 11 , 15 , 26 , 38 , 9 , 10 ]\nsum = 16\nn = len ( arr )\nif ( pairInSortedRotated ( arr , n , sum ) ) :\n    print ( \"Array has two elements with sum 16\" )\nelse :\n    print ( \"Array doesn't have two elements with sum 16 \" )\n", "python_code_tokenized": "def pairInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE while ( l != r ) : NEW_LINE INDENT if ( arr [ l ] + arr [ r ] == x ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( arr [ l ] + arr [ r ] < x ) : NEW_LINE INDENT l = ( l + 1 ) % n ; NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT arr = [ 11 , 15 , 26 , 38 , 9 , 10 ] NEW_LINE sum = 16 NEW_LINE n = len ( arr ) NEW_LINE if ( pairInSortedRotated ( arr , n , sum ) ) : NEW_LINE INDENT print ( \" Array \u2581 has \u2581 two \u2581 elements \u2581 with \u2581 sum \u2581 16\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Array \u2581 doesn ' t \u2581 have \u2581 two \u2581 elements \u2581 with \u2581 sum \u2581 16 \u2581 \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_868_A", "sol": 0, "python_code": "MAX = 10000\narr = [ ]\nsprime = [ False ] * ( MAX )\ndef computeSemiPrime ( ) :\n    for i in range ( 2 , MAX ) :\n        cnt , num , j = 0 , i , 2\n        while cnt < 2 and j * j <= num :\n            while num % j == 0 :\n                num /= j\n                cnt += 1\n            j += 1\n        if num > 1 :\n            cnt += 1\n        if cnt == 2 :\n            sprime [ i ] = True\n            arr.append ( i )\ndef checkSemiPrime ( n ) :\n    i = 0\n    while arr [ i ] <= n // 2 :\n        if sprime [ n - arr [ i ] ] == True :\n            return True\n        i += 1\n    return False\nif __name__ == \"__main__\" :\n    computeSemiPrime ( )\n    n = 30\n    if checkSemiPrime ( n ) == True :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "MAX = 10000 NEW_LINE arr = [ ] NEW_LINE sprime = [ False ] * ( MAX ) NEW_LINE def computeSemiPrime ( ) : NEW_LINE INDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT cnt , num , j = 0 , i , 2 NEW_LINE while cnt < 2 and j * j <= num : NEW_LINE INDENT while num % j == 0 : NEW_LINE INDENT num /= j NEW_LINE cnt += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if num > 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if cnt == 2 : NEW_LINE INDENT sprime [ i ] = True NEW_LINE arr . append ( i ) NEW_LINE DEDENT DEDENT DEDENT def checkSemiPrime ( n ) : NEW_LINE INDENT i = 0 NEW_LINE while arr [ i ] <= n // 2 : NEW_LINE INDENT if sprime [ n - arr [ i ] ] == True : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT computeSemiPrime ( ) NEW_LINE n = 30 NEW_LINE if checkSemiPrime ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC063_B", "sol": 0, "python_code": "s = list ( input ( ) )\nif len ( set ( s ) ) == len ( s ) :\n    print ( \"yes\" )\nelse : print ( \"no\" )\n", "python_code_tokenized": "s = list ( input ( ) ) NEW_LINE if len ( set ( s ) ) == len ( s ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : print ( \" no \" ) NEW_LINE"}
{"id": "geeksforgeeks_4504_A", "sol": 0, "python_code": "def countSetBits ( n ) :\n    count = 0\n    while n :\n        count += 1\n        n &= ( n - 1 )\n    return count\ndef FlippedCount ( a , b ) :\n    return countSetBits ( a ^ b )\na = 10\nb = 20\nprint ( FlippedCount ( a , b ) )\n", "python_code_tokenized": "def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += 1 NEW_LINE n &= ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def FlippedCount ( a , b ) : NEW_LINE INDENT return countSetBits ( a ^ b ) NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE print ( FlippedCount ( a , b ) ) NEW_LINE"}
{"id": "geeksforgeeks_1391_A", "sol": 0, "python_code": "import math\ndef CheckIfstartsWithOne ( n , b ) :\n    m = ( int ) ( math.log2 ( n ) ) ;\n    for i in range ( 1 , m + 1 ) :\n        x = ( int ) ( math.pow ( b , i ) ) ;\n        if n >= x and n <= 2 * x - 1 :\n            return 1 ;\n    return 0 ;\ndef printYesORno ( n , b ) :\n    if CheckIfstartsWithOne ( n , b ) == 1 :\n        print ( \"Yes\" ) ;\n    if CheckIfstartsWithOne ( n , b ) == 0 :\n        print ( \"No\" ) ;\nprintYesORno ( 6 , 4 ) ;\nprintYesORno ( 24 , 2 ) ;\nprintYesORno ( 24 , 7 ) ;\nprintYesORno ( 24 , 15 ) ;\n", "python_code_tokenized": "import math NEW_LINE def CheckIfstartsWithOne ( n , b ) : NEW_LINE INDENT m = ( int ) ( math . log2 ( n ) ) ; NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT x = ( int ) ( math . pow ( b , i ) ) ; NEW_LINE if n >= x and n <= 2 * x - 1 : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT def printYesORno ( n , b ) : NEW_LINE INDENT if CheckIfstartsWithOne ( n , b ) == 1 : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT if CheckIfstartsWithOne ( n , b ) == 0 : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT printYesORno ( 6 , 4 ) ; NEW_LINE printYesORno ( 24 , 2 ) ; NEW_LINE printYesORno ( 24 , 7 ) ; NEW_LINE printYesORno ( 24 , 15 ) ; NEW_LINE"}
{"id": "geeksforgeeks_4488_A", "sol": 0, "python_code": "def pairwiseProduct ( arr , n ) :\n    prod = 1\n    for i in range ( n - 1 ) :\n        prod = arr [ i ] * arr [ i + 1 ]\n        print ( prod , end = \" \" )\nif __name__ == \"__main__\" :\n    arr = [ 4 , 10 , 15 , 5 , 6 ]\n    n = len ( arr )\n    pairwiseProduct ( arr , n )\n", "python_code_tokenized": "def pairwiseProduct ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT prod = arr [ i ] * arr [ i + 1 ] NEW_LINE print ( prod , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 10 , 15 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE pairwiseProduct ( arr , n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3821_A", "sol": 0, "python_code": "def findNums ( arr , n ) :\n    S = 0 ; X = 0 ;\n    for i in range ( n ) :\n        S += arr [ i ] ;\n        X ^= arr [ i ] ;\n    print ( X , X + S ) ;\nif __name__ == \"__main__\" :\n    arr = [ 1 , 7 ] ;\n    n = len ( arr ) ;\n    findNums ( arr , n ) ;\n", "python_code_tokenized": "def findNums ( arr , n ) : NEW_LINE INDENT S = 0 ; X = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += arr [ i ] ; NEW_LINE X ^= arr [ i ] ; NEW_LINE DEDENT print ( X , X + S ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findNums ( arr , n ) ; NEW_LINE DEDENT"}
{"id": "aizu_p02356_A", "sol": 0, "python_code": "def count_two_idx ( A , q ) :\n    ans = 0\n    left = 0\n    csum = 0\n    for right in range ( N ) :\n        csum += A [ right ]\n        while csum > q :\n            csum -= A [ left ]\n            left += 1\n        ans += right - left + 1\n    return ans\nN , M = [ int ( x ) for x in input ( ).split ( ) ]\nA = list ( map ( int , input ( ).split ( ) ) )\nX = list ( map ( int , input ( ).split ( ) ) )\nfor q in X :\n    print ( count_two_idx ( A , q ) )\n", "python_code_tokenized": "def count_two_idx ( A , q ) : NEW_LINE INDENT ans = 0 NEW_LINE left = 0 NEW_LINE csum = 0 NEW_LINE for right in range ( N ) : NEW_LINE INDENT csum += A [ right ] NEW_LINE while csum > q : NEW_LINE INDENT csum -= A [ left ] NEW_LINE left += 1 NEW_LINE DEDENT ans += right - left + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT N , M = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for q in X : NEW_LINE INDENT print ( count_two_idx ( A , q ) ) NEW_LINE DEDENT"}
{"id": "projecteuler_p024_A", "sol": 0, "python_code": "import itertools\ndef compute ( ) :\n    arr = list ( range ( 10 ) )\n    temp = itertools.islice ( itertools.permutations ( arr ) , 999999 , None )\n    return \"\".join ( str ( x ) for x in next ( temp ) )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT arr = list ( range ( 10 ) ) NEW_LINE temp = itertools . islice ( itertools . permutations ( arr ) , 999999 , None ) NEW_LINE return \" \" . join ( str ( x ) for x in next ( temp ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2720_A", "sol": 0, "python_code": "def sortByFreq ( arr , n ) :\n    maxE = - 1 ;\n    for i in range ( n ) :\n        maxE = max ( maxE , arr [ i ] )\n    freq = [ 0 ] * ( maxE + 1 ) ;\n    for i in range ( n ) :\n        freq [ arr [ i ] ] += 1 ;\n    cnt = 0 ;\n    for i in range ( maxE + 1 ) :\n        if ( freq [ i ] > 0 ) :\n            value = 100000 - i ;\n            arr [ cnt ] = 100000 * freq [ i ] + value ;\n            cnt += 1 ;\n    return cnt ;\ndef printSortedArray ( arr , cnt ) :\n    for i in range ( cnt ) :\n        frequency = arr [ i ] / 100000 ;\n        value = 100000 - ( arr [ i ] % 100000 ) ;\n        for j in range ( int ( frequency ) ) :\n            print ( value , end = \" \" )\nif __name__ == '__main__' :\n    arr = [ 4 , 4 , 5 , 6 , 4 , 2 , 2 , 8 , 5 ]\n    n = len ( arr )\n    cnt = sortByFreq ( arr , n ) ;\n    arr.sort ( reverse = True )\n    printSortedArray ( arr , cnt ) ;\n", "python_code_tokenized": "def sortByFreq ( arr , n ) : NEW_LINE INDENT maxE = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxE = max ( maxE , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 ] * ( maxE + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 ; NEW_LINE DEDENT cnt = 0 ; NEW_LINE for i in range ( maxE + 1 ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT value = 100000 - i ; NEW_LINE arr [ cnt ] = 100000 * freq [ i ] + value ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT def printSortedArray ( arr , cnt ) : NEW_LINE INDENT for i in range ( cnt ) : NEW_LINE INDENT frequency = arr [ i ] / 100000 ; NEW_LINE value = 100000 - ( arr [ i ] % 100000 ) ; NEW_LINE for j in range ( int ( frequency ) ) : NEW_LINE INDENT print ( value , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 4 , 5 , 6 , 4 , 2 , 2 , 8 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE cnt = sortByFreq ( arr , n ) ; NEW_LINE arr . sort ( reverse = True ) NEW_LINE printSortedArray ( arr , cnt ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2910_A", "sol": 0, "python_code": "def Count_subarray ( arr , n ) :\n    subarray_sum , remaining_sum , count = 0 , 0 , 0 ;\n    for i in range ( n ) :\n        for j in range ( i , n ) :\n            subarray_sum = 0 ;\n            remaining_sum = 0 ;\n            for k in range ( i , j + 1 ) :\n                subarray_sum += arr [ k ] ;\n            for l in range ( i ) :\n                remaining_sum += arr [ l ] ;\n            for l in range ( j + 1 , n ) :\n                remaining_sum += arr [ l ] ;\n            if ( subarray_sum > remaining_sum ) :\n                count += 1 ;\n    return count ;\nif __name__ == '__main__' :\n    arr = [ 10 , 9 , 12 , 6 ] ;\n    n = len ( arr ) ;\n    print ( Count_subarray ( arr , n ) ) ;\n", "python_code_tokenized": "def Count_subarray ( arr , n ) : NEW_LINE INDENT subarray_sum , remaining_sum , count = 0 , 0 , 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT subarray_sum = 0 ; NEW_LINE remaining_sum = 0 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT subarray_sum += arr [ k ] ; NEW_LINE DEDENT for l in range ( i ) : NEW_LINE INDENT remaining_sum += arr [ l ] ; NEW_LINE DEDENT for l in range ( j + 1 , n ) : NEW_LINE INDENT remaining_sum += arr [ l ] ; NEW_LINE DEDENT if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 9 , 12 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( Count_subarray ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_386_B", "sol": 0, "python_code": "n = int ( input ( ) )\nl = sorted ( list ( map ( int , input ( ).split ( ) ) ) )\nt = int ( input ( ) )\nresult = 0\nfor x in range ( n ) :\n    for y in range ( n ) :\n        if abs ( l [ x ] - l [ y ] ) <= t :\n            result = max ( result , ( y - x ) + 1 )\nprint ( result )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE t = int ( input ( ) ) NEW_LINE result = 0 NEW_LINE for x in range ( n ) : NEW_LINE INDENT for y in range ( n ) : NEW_LINE INDENT if abs ( l [ x ] - l [ y ] ) <= t : NEW_LINE INDENT result = max ( result , ( y - x ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( result ) NEW_LINE"}
{"id": "leetcode_937_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def reorderLogFiles ( self , logs ) :\n        letter_logs = [ ]\n        digit_logs = [ ]\n        for log in logs :\n            if log.split ( ' ' ) [ 1 ].isnumeric ( ) :\n                digit_logs.append ( log )\n            else :\n                letter_logs.append ( log )\n        return sorted ( letter_logs , key = lambda x : x.split ( ' ' ) [ 1 : ] + x.split ( ' ' ) [ 0 ] ) + digit_logs\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def reorderLogFiles ( self , logs ) : NEW_LINE INDENT letter_logs = [ ] NEW_LINE digit_logs = [ ] NEW_LINE for log in logs : NEW_LINE INDENT if log . split ( ' \u2581 ' ) [ 1 ] . isnumeric ( ) : NEW_LINE INDENT digit_logs . append ( log ) NEW_LINE DEDENT else : NEW_LINE INDENT letter_logs . append ( log ) NEW_LINE DEDENT DEDENT return sorted ( letter_logs , key = lambda x : x . split ( ' \u2581 ' ) [ 1 : ] + x . split ( ' \u2581 ' ) [ 0 ] ) + digit_logs NEW_LINE DEDENT DEDENT"}
{"id": "codejam_08_11", "sol": 0, "python_code": "import sys\nif ( __name__ == '__main__' ) :\n    tc_count = int ( sys.stdin.readline ( ).strip ( ) )\n    for i in range ( tc_count ) :\n        sys.stdin.readline ( )\n        v1 = [ int ( x ) for x in sys.stdin.readline ( ).strip ( ).split ( ) ]\n        v2 = [ int ( x ) for x in sys.stdin.readline ( ).strip ( ).split ( ) ]\n        v1.sort ( )\n        v2.sort ( )\n        v2.reverse ( )\n        msp = 0\n        assert ( len ( v1 ) == len ( v2 ) )\n        for j in range ( len ( v1 ) ) :\n            msp += v1 [ j ] * v2 [ j ]\n        sys.stdout.write ( 'Case #%d: %d\\n' % ( i + 1 , msp ) )\n", "python_code_tokenized": "import sys NEW_LINE if ( __name__ == ' _ _ main _ _ ' ) : NEW_LINE INDENT tc_count = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE for i in range ( tc_count ) : NEW_LINE INDENT sys . stdin . readline ( ) NEW_LINE v1 = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE v2 = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE v1 . sort ( ) NEW_LINE v2 . sort ( ) NEW_LINE v2 . reverse ( ) NEW_LINE msp = 0 NEW_LINE assert ( len ( v1 ) == len ( v2 ) ) NEW_LINE for j in range ( len ( v1 ) ) : NEW_LINE INDENT msp += v1 [ j ] * v2 [ j ] NEW_LINE DEDENT sys . stdout . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( i + 1 , msp ) ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC062_A", "sol": 0, "python_code": "x , y = map ( int , input ( ).split ( ) )\ngr1 = [ 2 ]\ngr2 = [ 4 , 6 , 9 , 11 ]\nif x in gr1 :\n    x_gr = 1\nelif x in gr2 :\n    x_gr = 2\nelse :\n    x_gr = 3\nif y in gr1 :\n    y_gr = 1\nelif y in gr2 :\n    y_gr = 2\nelse :\n    y_gr = 3\nif x_gr == y_gr :\n    print ( 'Yes' )\nelse :\n    print ( 'No' )\n", "python_code_tokenized": "x , y = map ( int , input ( ) . split ( ) ) NEW_LINE gr1 = [ 2 ] NEW_LINE gr2 = [ 4 , 6 , 9 , 11 ] NEW_LINE if x in gr1 : NEW_LINE INDENT x_gr = 1 NEW_LINE DEDENT elif x in gr2 : NEW_LINE INDENT x_gr = 2 NEW_LINE DEDENT else : NEW_LINE INDENT x_gr = 3 NEW_LINE DEDENT if y in gr1 : NEW_LINE INDENT y_gr = 1 NEW_LINE DEDENT elif y in gr2 : NEW_LINE INDENT y_gr = 2 NEW_LINE DEDENT else : NEW_LINE INDENT y_gr = 3 NEW_LINE DEDENT if x_gr == y_gr : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3918_A", "sol": 0, "python_code": "def init ( degree , edges , n ) :\n    for i in range ( n ) :\n        degree [ i ] = 0 ;\n    for i in range ( len ( edges ) ) :\n        degree [ edges [ i ] [ 0 ] ] += 1 ;\n        degree [ edges [ i ] [ 1 ] ] += 1 ;\ndef performQueries ( edges , q , n ) :\n    degree = [ 0 ] * n ;\n    init ( degree , edges , n ) ;\n    for i in range ( len ( q ) ) :\n        node = q [ i ] ;\n        if ( node == 0 ) :\n            print ( \"No\" ) ;\n            continue ;\n        if ( degree [ node ] == 1 ) :\n            print ( \"Yes\" ) ;\n        else :\n            print ( \"No\" ) ;\nif __name__ == \"__main__\" :\n    n = 6 ;\n    edges = [ [ 0 , 1 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 4 , 5 ] ] ;\n    q = [ 0 , 3 , 4 , 5 ] ;\n    performQueries ( edges , q , n ) ;\n", "python_code_tokenized": "def init ( degree , edges , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT degree [ i ] = 0 ; NEW_LINE DEDENT for i in range ( len ( edges ) ) : NEW_LINE INDENT degree [ edges [ i ] [ 0 ] ] += 1 ; NEW_LINE degree [ edges [ i ] [ 1 ] ] += 1 ; NEW_LINE DEDENT DEDENT def performQueries ( edges , q , n ) : NEW_LINE INDENT degree = [ 0 ] * n ; NEW_LINE init ( degree , edges , n ) ; NEW_LINE for i in range ( len ( q ) ) : NEW_LINE INDENT node = q [ i ] ; NEW_LINE if ( node == 0 ) : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE continue ; NEW_LINE DEDENT if ( degree [ node ] == 1 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINE edges = [ [ 0 , 1 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 4 , 5 ] ] ; NEW_LINE q = [ 0 , 3 , 4 , 5 ] ; NEW_LINE performQueries ( edges , q , n ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1668_B", "sol": 0, "python_code": "for i in range ( int ( input ( ) ) ) :\n    nm = input ( )\n    nm = nm.split ( )\n    inp = input ( )\n    inp = inp.split ( )\n    for i in range ( int ( nm [ 0 ] ) ) :\n        inp.append ( int ( inp [ 0 ] ) )\n        inp.pop ( 0 )\n    inp.sort ( )\n    sum1 = 0\n    for i in range ( int ( nm [ 0 ] ) ) :\n        sum1 += max ( inp [ i - 1 ] , inp [ i ] )\n    if ( sum1 + int ( nm [ 0 ] ) ) <= int ( nm [ 1 ] ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT nm = input ( ) NEW_LINE nm = nm . split ( ) NEW_LINE inp = input ( ) NEW_LINE inp = inp . split ( ) NEW_LINE for i in range ( int ( nm [ 0 ] ) ) : NEW_LINE INDENT inp . append ( int ( inp [ 0 ] ) ) NEW_LINE inp . pop ( 0 ) NEW_LINE DEDENT inp . sort ( ) NEW_LINE sum1 = 0 NEW_LINE for i in range ( int ( nm [ 0 ] ) ) : NEW_LINE INDENT sum1 += max ( inp [ i - 1 ] , inp [ i ] ) NEW_LINE DEDENT if ( sum1 + int ( nm [ 0 ] ) ) <= int ( nm [ 1 ] ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_AGC035_D", "sol": 0, "python_code": "from sys import stdin\ndef want ( l , r , lb , rb ) :\n    if l > r :\n        return 0\n    elif l == r :\n        return A [ l ] * ( lb + rb )\n    nmin = float ( \"inf\" )\n    for i in range ( l , r + 1 ) :\n        nmin = min ( nmin , A [ i ] * ( lb + rb ) + want ( l , i - 1 , lb , lb + rb ) + want ( i + 1 , r , lb + rb , rb ) )\n    return nmin\nN = int ( stdin.readline ( ) )\nA = list ( map ( int , stdin.readline ( ).split ( ) ) )\nprint ( A [ 0 ] + A [ - 1 ] + want ( 1 , N - 2 , 1 , 1 ) )\n", "python_code_tokenized": "from sys import stdin NEW_LINE def want ( l , r , lb , rb ) : NEW_LINE INDENT if l > r : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif l == r : NEW_LINE INDENT return A [ l ] * ( lb + rb ) NEW_LINE DEDENT nmin = float ( \" inf \" ) NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT nmin = min ( nmin , A [ i ] * ( lb + rb ) + want ( l , i - 1 , lb , lb + rb ) + want ( i + 1 , r , lb + rb , rb ) ) NEW_LINE DEDENT return nmin NEW_LINE DEDENT N = int ( stdin . readline ( ) ) NEW_LINE A = list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE print ( A [ 0 ] + A [ - 1 ] + want ( 1 , N - 2 , 1 , 1 ) ) NEW_LINE"}
{"id": "geeksforgeeks_1893_A", "sol": 0, "python_code": "def printIndex ( str , s ) :\n    flag = False ;\n    for i in range ( len ( str ) ) :\n        if ( str [ i : i + len ( s ) ] == s ) :\n            print ( i , end = \" \" ) ;\n            flag = True ;\n    if ( flag == False ) :\n        print ( \"NONE\" ) ;\nstr1 = \"GeeksforGeeks\" ;\nstr2 = \"Geeks\" ;\nprintIndex ( str1 , str2 ) ;\n", "python_code_tokenized": "def printIndex ( str , s ) : NEW_LINE INDENT flag = False ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i : i + len ( s ) ] == s ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) ; NEW_LINE flag = True ; NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT print ( \" NONE \" ) ; NEW_LINE DEDENT DEDENT str1 = \" GeeksforGeeks \" ; NEW_LINE str2 = \" Geeks \" ; NEW_LINE printIndex ( str1 , str2 ) ; NEW_LINE"}
{"id": "geeksforgeeks_4520_A", "sol": 0, "python_code": "def toggleBitsFromLToR ( n , l , r ) :\n    num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 )\n    return ( n ^ num )\nn = 50\nl = 2\nr = 5\nprint ( toggleBitsFromLToR ( n , l , r ) )\n", "python_code_tokenized": "def toggleBitsFromLToR ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 50 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE print ( toggleBitsFromLToR ( n , l , r ) ) NEW_LINE"}
{"id": "codeforces_1159_B", "sol": 0, "python_code": "import heapq\nimport sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\nn = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nh = [ ]\nfor i in range ( n ) :\n    heapq.heappush ( h , ( a [ i ] , i ) )\nok = [ 0 ] * n\nl , r = 0 , n - 1\ninf = pow ( 10 , 9 ) + 1\nans = inf\nfor _ in range ( n - 1 ) :\n    ai , i = heapq.heappop ( h )\n    d = max ( abs ( i - l ) , abs ( i - r ) )\n    ans = min ( ans , ai // d )\n    ok [ i ] = 1\n    while l < n and ok [ l ] :\n        l += 1\n    while r >= 0 and ok [ r ] :\n        r -= 1\nprint ( ans )\n", "python_code_tokenized": "import heapq NEW_LINE import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE h = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT heapq . heappush ( h , ( a [ i ] , i ) ) NEW_LINE DEDENT ok = [ 0 ] * n NEW_LINE l , r = 0 , n - 1 NEW_LINE inf = pow ( 10 , 9 ) + 1 NEW_LINE ans = inf NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT ai , i = heapq . heappop ( h ) NEW_LINE d = max ( abs ( i - l ) , abs ( i - r ) ) NEW_LINE ans = min ( ans , ai // d ) NEW_LINE ok [ i ] = 1 NEW_LINE while l < n and ok [ l ] : NEW_LINE INDENT l += 1 NEW_LINE DEDENT while r >= 0 and ok [ r ] : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "atcoder_ABC138_F", "sol": 0, "python_code": "L , R = map ( int , input ( ).split ( ) )\nmod = 10 ** 9 + 7\ndef f ( L , R ) :\n    if L > R : return 0\n    R = bin ( R ) [ 2 : ]\n    N = len ( R )\n    ret = f ( L , int ( \"0\" + \"1\" * ( N - 1 ) , 2 ) )\n    L = bin ( L ) [ 2 : ]\n    if len ( L ) != N : L = \"1\" + \"0\" * ( N - 1 )\n    for i in range ( N ) :\n        if R [ i ] == \"0\" : continue\n        R2 = R [ : i ] + \"0\" + \"?\" * ( N - i - 1 )\n        if i == 0 : R2 = R\n        for j in range ( N ) :\n            if L [ j ] == \"1\" and j != 0 : continue\n            L2 = L [ : j ] + \"1\" + \"?\" * ( N - j - 1 )\n            if j == 0 : L2 = L\n            if L2 [ 0 ] == \"0\" : break\n            tmp = 1\n            for r , l in zip ( R2 [ 1 : ] , L2 [ 1 : ] ) :\n                if r == \"0\" and l == \"1\" : tmp *= 0 ; break\n                if r == \"?\" and l == \"?\" : tmp = tmp * 3 % mod\n                if r == \"?\" and l == \"0\" : tmp = tmp * 2 % mod\n                if r == \"1\" and l == \"?\" : tmp = tmp * 2 % mod\n            ret += tmp\n            ret %= mod\n    return ret\nprint ( f ( L , R ) )\n", "python_code_tokenized": "L , R = map ( int , input ( ) . split ( ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def f ( L , R ) : NEW_LINE INDENT if L > R : return 0 NEW_LINE R = bin ( R ) [ 2 : ] NEW_LINE N = len ( R ) NEW_LINE ret = f ( L , int ( \"0\" + \"1\" * ( N - 1 ) , 2 ) ) NEW_LINE L = bin ( L ) [ 2 : ] NEW_LINE if len ( L ) != N : L = \"1\" + \"0\" * ( N - 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if R [ i ] == \"0\" : continue NEW_LINE R2 = R [ : i ] + \"0\" + \" ? \" * ( N - i - 1 ) NEW_LINE if i == 0 : R2 = R NEW_LINE for j in range ( N ) : NEW_LINE INDENT if L [ j ] == \"1\" and j != 0 : continue NEW_LINE L2 = L [ : j ] + \"1\" + \" ? \" * ( N - j - 1 ) NEW_LINE if j == 0 : L2 = L NEW_LINE if L2 [ 0 ] == \"0\" : break NEW_LINE tmp = 1 NEW_LINE for r , l in zip ( R2 [ 1 : ] , L2 [ 1 : ] ) : NEW_LINE INDENT if r == \"0\" and l == \"1\" : tmp *= 0 ; break NEW_LINE if r == \" ? \" and l == \" ? \" : tmp = tmp * 3 % mod NEW_LINE if r == \" ? \" and l == \"0\" : tmp = tmp * 2 % mod NEW_LINE if r == \"1\" and l == \" ? \" : tmp = tmp * 2 % mod NEW_LINE DEDENT ret += tmp NEW_LINE ret %= mod NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT print ( f ( L , R ) ) NEW_LINE"}
{"id": "atcoder_ARC079_B", "sol": 0, "python_code": "K = int ( input ( ) )\nN = 50\na = K // N\nb = K % N\nl = a - b + N * 2\nm = a - b + N - 1\nL = [ l for _ in range ( b ) ]\nM = [ m for _ in range ( N - b ) ]\nprint ( N )\nprint ( \" \".join ( map ( str , L + M ) ) )\n", "python_code_tokenized": "K = int ( input ( ) ) NEW_LINE N = 50 NEW_LINE a = K // N NEW_LINE b = K % N NEW_LINE l = a - b + N * 2 NEW_LINE m = a - b + N - 1 NEW_LINE L = [ l for _ in range ( b ) ] NEW_LINE M = [ m for _ in range ( N - b ) ] NEW_LINE print ( N ) NEW_LINE print ( \" \u2581 \" . join ( map ( str , L + M ) ) ) NEW_LINE"}
{"id": "atcoder_ABC128_C", "sol": 0, "python_code": "def can ( state , m , bulb , p ) :\n    for i in range ( m ) :\n        cnt = 0\n        for j in bulb [ i ] :\n            if ( state & ( 1 << ( j - 1 ) ) ) :\n                cnt += 1\n        if cnt % 2 != p [ i ] :\n            return False\n    return True\nn , m = map ( int , input ( ).split ( ) )\nbulb = [ ]\nfor i in range ( m ) :\n    l = list ( map ( int , input ( ).split ( ) ) )\n    l = l [ 1 : ]\n    bulb.append ( l )\np = list ( map ( int , input ( ).split ( ) ) )\nans = 0\nfor i in range ( 1 << n ) :\n    if can ( i , m , bulb , p ) :\n        ans += 1\nprint ( ans )\n", "python_code_tokenized": "def can ( state , m , bulb , p ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in bulb [ i ] : NEW_LINE INDENT if ( state & ( 1 << ( j - 1 ) ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt % 2 != p [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE bulb = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = l [ 1 : ] NEW_LINE bulb . append ( l ) NEW_LINE DEDENT p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 << n ) : NEW_LINE INDENT if can ( i , m , bulb , p ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "aizu_p00220_A", "sol": 0, "python_code": "while ( True ) :\n    n = float ( input ( ) )\n    if n < 0 : break\n    if int ( n * 16 ) - n * 16 : print ( \"NA\" ) ; continue\n    else :\n        s = bin ( int ( n * 16 ) ) [ 2 : ].zfill ( 12 )\n        print ( s [ : - 4 ] + \".\" + s [ - 4 : ] )\n", "python_code_tokenized": "while ( True ) : NEW_LINE INDENT n = float ( input ( ) ) NEW_LINE if n < 0 : break NEW_LINE if int ( n * 16 ) - n * 16 : print ( \" NA \" ) ; continue NEW_LINE else : NEW_LINE INDENT s = bin ( int ( n * 16 ) ) [ 2 : ] . zfill ( 12 ) NEW_LINE print ( s [ : - 4 ] + \" . \" + s [ - 4 : ] ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_5225_A", "sol": 0, "python_code": "class newNode :\n    def __init__ ( self , data ) :\n        self.val = data\n        self.left = self.right = None\ndef length ( node , ans ) :\n    if ( not node ) :\n        return 0\n    left = length ( node.left , ans )\n    right = length ( node.right , ans )\n    Leftmax = 0\n    Rightmax = 0\n    if ( node.left and node.left.val == node.val ) :\n        Leftmax += left + 1\n    if ( node.right and node.right.val == node.val ) :\n        Rightmax += right + 1\n    ans [ 0 ] = max ( ans [ 0 ] , Leftmax + Rightmax )\n    return max ( Leftmax , Rightmax )\ndef longestSameValuePath ( root ) :\n    ans = [ 0 ]\n    length ( root , ans )\n    return ans [ 0 ]\nif __name__ == '__main__' :\n    root = None\n    root = newNode ( 4 )\n    root.left = newNode ( 4 )\n    root.right = newNode ( 4 )\n    root.left.left = newNode ( 4 )\n    root.left.right = newNode ( 9 )\n    root.right.right = newNode ( 5 )\n    print ( longestSameValuePath ( root ) )\n", "python_code_tokenized": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . val = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def length ( node , ans ) : NEW_LINE INDENT if ( not node ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT left = length ( node . left , ans ) NEW_LINE right = length ( node . right , ans ) NEW_LINE Leftmax = 0 NEW_LINE Rightmax = 0 NEW_LINE if ( node . left and node . left . val == node . val ) : NEW_LINE INDENT Leftmax += left + 1 NEW_LINE DEDENT if ( node . right and node . right . val == node . val ) : NEW_LINE INDENT Rightmax += right + 1 NEW_LINE DEDENT ans [ 0 ] = max ( ans [ 0 ] , Leftmax + Rightmax ) NEW_LINE return max ( Leftmax , Rightmax ) NEW_LINE DEDENT def longestSameValuePath ( root ) : NEW_LINE INDENT ans = [ 0 ] NEW_LINE length ( root , ans ) NEW_LINE return ans [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE root = newNode ( 4 ) NEW_LINE root . left = newNode ( 4 ) NEW_LINE root . right = newNode ( 4 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 9 ) NEW_LINE root . right . right = newNode ( 5 ) NEW_LINE print ( longestSameValuePath ( root ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3762_A", "sol": 0, "python_code": "def printBinStr ( string , length ) :\n    for i in range ( 0 , length ) :\n        print ( string [ i ] , end = \"\" )\n    print ( )\ndef generateBinStr ( string , length , currlen , occur , nextbit ) :\n    if currlen == length :\n        if occur == 2 and nextbit == 0 :\n            printBinStr ( string , length )\n        return\n    if currlen == 0 :\n        string [ 0 ] = nextbit\n        generateBinStr ( string , length , currlen + 1 , occur , 0 )\n        generateBinStr ( string , length , currlen + 1 , occur , 1 )\n    else :\n        if occur < 2 :\n            string [ currlen ] = nextbit\n            if string [ currlen - 1 ] == 0 and nextbit == 1 :\n                occur += 1\n            generateBinStr ( string , length , currlen + 1 , occur , 0 )\n            generateBinStr ( string , length , currlen + 1 , occur , 1 )\n        else :\n            if string [ currlen - 1 ] == 0 and nextbit == 1 :\n                return\n            else :\n                string [ currlen ] = nextbit\n                generateBinStr ( string , length , currlen + 1 , occur , 0 )\n                generateBinStr ( string , length , currlen + 1 , occur , 1 )\nif __name__ == \"__main__\" :\n    n = 5\n    if n < 4 :\n        print ( - 1 )\n    else :\n        string = [ None ] * n\n        generateBinStr ( string , n , 0 , 0 , 0 )\n        generateBinStr ( string , n , 0 , 0 , 1 )\n", "python_code_tokenized": "def printBinStr ( string , length ) : NEW_LINE INDENT for i in range ( 0 , length ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def generateBinStr ( string , length , currlen , occur , nextbit ) : NEW_LINE INDENT if currlen == length : NEW_LINE INDENT if occur == 2 and nextbit == 0 : NEW_LINE INDENT printBinStr ( string , length ) NEW_LINE DEDENT return NEW_LINE DEDENT if currlen == 0 : NEW_LINE INDENT string [ 0 ] = nextbit NEW_LINE generateBinStr ( string , length , currlen + 1 , occur , 0 ) NEW_LINE generateBinStr ( string , length , currlen + 1 , occur , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if occur < 2 : NEW_LINE INDENT string [ currlen ] = nextbit NEW_LINE if string [ currlen - 1 ] == 0 and nextbit == 1 : NEW_LINE INDENT occur += 1 NEW_LINE DEDENT generateBinStr ( string , length , currlen + 1 , occur , 0 ) NEW_LINE generateBinStr ( string , length , currlen + 1 , occur , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if string [ currlen - 1 ] == 0 and nextbit == 1 : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT string [ currlen ] = nextbit NEW_LINE generateBinStr ( string , length , currlen + 1 , occur , 0 ) NEW_LINE generateBinStr ( string , length , currlen + 1 , occur , 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE if n < 4 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT string = [ None ] * n NEW_LINE generateBinStr ( string , n , 0 , 0 , 0 ) NEW_LINE generateBinStr ( string , n , 0 , 0 , 1 ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4088_A", "sol": 0, "python_code": "import math\ndef findCount ( n ) :\n    a , b , c = 1 , 0 , 0 ;\n    x = ( int ) ( n / 60 ) ;\n    a = int ( math.pow ( 32 , x ) ) ;\n    x = 60 * x ;\n    for i in range ( x + 1 , n + 1 ) :\n        if ( i % 2 == 0 ) :\n            b += a ;\n            a = 0 ;\n        if ( i % 5 == 0 ) :\n            c += b ;\n            b = 0 ;\n        if ( i % 12 == 0 ) :\n            a += ( 2 * c ) ;\n            c = 0 ;\n    print ( \"a =\" , a , end = \", \" ) ;\n    print ( \"b =\" , b , end = \", \" ) ;\n    print ( \"c =\" , c ) ;\nif __name__ == '__main__' :\n    n = 72 ;\n    findCount ( n ) ;\n", "python_code_tokenized": "import math NEW_LINE def findCount ( n ) : NEW_LINE INDENT a , b , c = 1 , 0 , 0 ; NEW_LINE x = ( int ) ( n / 60 ) ; NEW_LINE a = int ( math . pow ( 32 , x ) ) ; NEW_LINE x = 60 * x ; NEW_LINE for i in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT b += a ; NEW_LINE a = 0 ; NEW_LINE DEDENT if ( i % 5 == 0 ) : NEW_LINE INDENT c += b ; NEW_LINE b = 0 ; NEW_LINE DEDENT if ( i % 12 == 0 ) : NEW_LINE INDENT a += ( 2 * c ) ; NEW_LINE c = 0 ; NEW_LINE DEDENT DEDENT print ( \" a \u2581 = \" , a , end = \" , \u2581 \" ) ; NEW_LINE print ( \" b \u2581 = \" , b , end = \" , \u2581 \" ) ; NEW_LINE print ( \" c \u2581 = \" , c ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 72 ; NEW_LINE findCount ( n ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3982_A", "sol": 0, "python_code": "def deleteElements ( arr , n , k ) :\n    st = [ ]\n    st.append ( arr [ 0 ] )\n    top = 0\n    count = 0\n    for i in range ( 1 , n ) :\n        while ( len ( st ) != 0 and count < k and st [ top ] < arr [ i ] ) :\n            st.pop ( )\n            count += 1\n            top -= 1\n        st.append ( arr [ i ] )\n        top += 1\n    for i in range ( 0 , len ( st ) ) :\n        print ( st [ i ] , \"\" , end = \"\" )\nk = 2\narr = [ 20 , 10 , 25 , 30 , 40 ]\ndeleteElements ( arr , len ( arr ) , k )\n", "python_code_tokenized": "def deleteElements ( arr , n , k ) : NEW_LINE INDENT st = [ ] NEW_LINE st . append ( arr [ 0 ] ) NEW_LINE top = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( st ) != 0 and count < k and st [ top ] < arr [ i ] ) : NEW_LINE INDENT st . pop ( ) NEW_LINE count += 1 NEW_LINE top -= 1 NEW_LINE DEDENT st . append ( arr [ i ] ) NEW_LINE top += 1 NEW_LINE DEDENT for i in range ( 0 , len ( st ) ) : NEW_LINE INDENT print ( st [ i ] , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT DEDENT k = 2 NEW_LINE arr = [ 20 , 10 , 25 , 30 , 40 ] NEW_LINE deleteElements ( arr , len ( arr ) , k ) NEW_LINE"}
{"id": "aizu_p02258_A", "sol": 0, "python_code": "import math\nn = int ( input ( ) )\nR = [ int ( input ( ) ) for _ in range ( n ) ]\nmaxv = - math.inf\nminv = R [ 0 ]\nfor i in range ( 1 , n ) :\n    diff = R [ i ] - minv\n    maxv = diff if diff > maxv else maxv\n    minv = R [ i ] if R [ i ] < minv else minv\nprint ( maxv )\n", "python_code_tokenized": "import math NEW_LINE n = int ( input ( ) ) NEW_LINE R = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE maxv = - math . inf NEW_LINE minv = R [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = R [ i ] - minv NEW_LINE maxv = diff if diff > maxv else maxv NEW_LINE minv = R [ i ] if R [ i ] < minv else minv NEW_LINE DEDENT print ( maxv ) NEW_LINE"}
{"id": "geeksforgeeks_4427_A", "sol": 0, "python_code": "from math import sqrt\ndef Prime ( n ) :\n    for j in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) :\n        if ( n % j == 0 ) :\n            return False\n    return True\ndef find_prime ( x , xsqmodp , y , ysqmodp ) :\n    n = x * x - xsqmodp\n    n1 = y * y - ysqmodp\n    for j in range ( 2 , max ( int ( sqrt ( n ) ) , int ( sqrt ( n1 ) ) ) , 1 ) :\n        if ( n % j == 0 and ( x * x ) % j == xsqmodp and n1 % j == 0 and ( y * y ) % j == ysqmodp ) :\n            if ( Prime ( j ) ) :\n                return j\n        j1 = n // j\n        if ( n % j1 == 0 and ( x * x ) % j1 == xsqmodp and n1 % j1 == 0 and ( y * y ) % j1 == ysqmodp ) :\n            if ( Prime ( j1 ) ) :\n                return j1\n        j1 = n1 // j\n        if ( n % j1 == 0 and ( x * x ) % j1 == xsqmodp and n1 % j1 == 0 and ( y * y ) % j1 == ysqmodp ) :\n            if ( Prime ( j1 ) ) :\n                return j1\n    if ( n == n1 ) :\n        return n\nif __name__ == '__main__' :\n    x = 3\n    xsqmodp = 0\n    y = 5\n    ysqmodp = 1\n    print ( find_prime ( x , xsqmodp , y , ysqmodp ) )\n", "python_code_tokenized": "from math import sqrt NEW_LINE def Prime ( n ) : NEW_LINE INDENT for j in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( n % j == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def find_prime ( x , xsqmodp , y , ysqmodp ) : NEW_LINE INDENT n = x * x - xsqmodp NEW_LINE n1 = y * y - ysqmodp NEW_LINE for j in range ( 2 , max ( int ( sqrt ( n ) ) , int ( sqrt ( n1 ) ) ) , 1 ) : NEW_LINE INDENT if ( n % j == 0 and ( x * x ) % j == xsqmodp and n1 % j == 0 and ( y * y ) % j == ysqmodp ) : NEW_LINE INDENT if ( Prime ( j ) ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT j1 = n // j NEW_LINE if ( n % j1 == 0 and ( x * x ) % j1 == xsqmodp and n1 % j1 == 0 and ( y * y ) % j1 == ysqmodp ) : NEW_LINE INDENT if ( Prime ( j1 ) ) : NEW_LINE INDENT return j1 NEW_LINE DEDENT DEDENT j1 = n1 // j NEW_LINE if ( n % j1 == 0 and ( x * x ) % j1 == xsqmodp and n1 % j1 == 0 and ( y * y ) % j1 == ysqmodp ) : NEW_LINE INDENT if ( Prime ( j1 ) ) : NEW_LINE INDENT return j1 NEW_LINE DEDENT DEDENT DEDENT if ( n == n1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 3 NEW_LINE xsqmodp = 0 NEW_LINE y = 5 NEW_LINE ysqmodp = 1 NEW_LINE print ( find_prime ( x , xsqmodp , y , ysqmodp ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1881_A", "sol": 0, "python_code": "import sys ;\ndef strBitwiseAND ( arr , n ) :\n    res = \"\"\n    smallest_size = sys.maxsize ;\n    largest_size = - ( sys.maxsize - 1 ) ;\n    for i in range ( n ) :\n        arr [ i ] = arr [ i ] [ : : - 1 ] ;\n        smallest_size = min ( smallest_size , len ( arr [ i ] ) ) ;\n        largest_size = max ( largest_size , len ( arr [ i ] ) ) ;\n    for i in range ( smallest_size ) :\n        all_ones = True ;\n        for j in range ( n ) :\n            if ( arr [ j ] [ i ] == '0' ) :\n                all_ones = False ;\n                break ;\n        if all_ones :\n            res += '1' ;\n        else :\n            res += '0' ;\n    for i in range ( largest_size - smallest_size ) :\n        res += '0' ;\n    res = res [ : : - 1 ] ;\n    return res ;\nif __name__ == \"__main__\" :\n    arr = [ \"101\" , \"110110\" , \"111\" ] ;\n    n = len ( arr ) ;\n    print ( strBitwiseAND ( arr , n ) ) ;\n", "python_code_tokenized": "import sys ; NEW_LINE def strBitwiseAND ( arr , n ) : NEW_LINE INDENT res = \" \" NEW_LINE smallest_size = sys . maxsize ; NEW_LINE largest_size = - ( sys . maxsize - 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] [ : : - 1 ] ; NEW_LINE smallest_size = min ( smallest_size , len ( arr [ i ] ) ) ; NEW_LINE largest_size = max ( largest_size , len ( arr [ i ] ) ) ; NEW_LINE DEDENT for i in range ( smallest_size ) : NEW_LINE INDENT all_ones = True ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] [ i ] == '0' ) : NEW_LINE INDENT all_ones = False ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if all_ones : NEW_LINE INDENT res += '1' ; NEW_LINE DEDENT else : NEW_LINE INDENT res += '0' ; NEW_LINE DEDENT DEDENT for i in range ( largest_size - smallest_size ) : NEW_LINE INDENT res += '0' ; NEW_LINE DEDENT res = res [ : : - 1 ] ; NEW_LINE return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \"101\" , \"110110\" , \"111\" ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( strBitwiseAND ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "atcoder_ABC133_A", "sol": 0, "python_code": "n , a , b = map ( int , input ( ).split ( ) )\nprint ( min ( n * a , b ) )\n", "python_code_tokenized": "n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( n * a , b ) ) NEW_LINE"}
{"id": "geeksforgeeks_1667_A", "sol": 0, "python_code": "def properDivisorSum ( n ) :\n    sum = 0\n    for i in range ( 1 , n + 1 ) :\n        sum += ( n // i ) * i\n    return sum - n * ( n + 1 ) // 2\nn = 4\nprint ( properDivisorSum ( n ) )\nn = 5\nprint ( properDivisorSum ( n ) )\n", "python_code_tokenized": "def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( n // i ) * i NEW_LINE DEDENT return sum - n * ( n + 1 ) // 2 NEW_LINE DEDENT n = 4 NEW_LINE print ( properDivisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( properDivisorSum ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_280_A", "sol": 0, "python_code": "def EqualNumbers ( a , n ) :\n    sum = 0 ;\n    for i in range ( n ) :\n        sum += a [ i ] ;\n    if ( sum % n ) :\n        return n - 1 ;\n    return n ;\na = [ 1 , 4 , 1 ] ;\nn = len ( a ) ;\nprint ( EqualNumbers ( a , n ) ) ;\n", "python_code_tokenized": "def EqualNumbers ( a , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT if ( sum % n ) : NEW_LINE INDENT return n - 1 ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT a = [ 1 , 4 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( EqualNumbers ( a , n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_1348_A", "sol": 0, "python_code": "from math import sqrt\ndef getNumbers ( a , n ) :\n    freq = { } ;\n    for i in range ( n ) :\n        if a [ i ] not in freq.keys ( ) :\n            freq [ a [ i ] ] = 0\n        freq [ a [ i ] ] += 1\n    maxi1 = max ( a )\n    for i in range ( 1 , int ( sqrt ( maxi1 ) ) + 1 ) :\n        if ( maxi1 % i == 0 and freq [ i ] in freq.keys ( ) and freq [ i ] != 0 ) :\n            freq [ i ] -= 1\n            if ( i != ( maxi1 // i ) and freq [ maxi1 // i ] in freq.keys ( ) and freq [ maxi1 // i ] != 0 ) :\n                freq [ maxi1 // i ] -= 1\n    maxi2 = - 1\n    for i in range ( n ) :\n        if ( freq [ a [ i ] ] != 0 ) :\n            maxi2 = max ( maxi2 , a [ i ] )\n    print ( maxi1 , maxi2 )\nif __name__ == \"__main__\" :\n    a = [ 10 , 2 , 8 , 1 , 2 , 4 , 1 , 20 , 4 , 5 ]\n    n = len ( a )\n    getNumbers ( a , n )\n", "python_code_tokenized": "from math import sqrt NEW_LINE def getNumbers ( a , n ) : NEW_LINE INDENT freq = { } ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in freq . keys ( ) : NEW_LINE INDENT freq [ a [ i ] ] = 0 NEW_LINE DEDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT maxi1 = max ( a ) NEW_LINE for i in range ( 1 , int ( sqrt ( maxi1 ) ) + 1 ) : NEW_LINE INDENT if ( maxi1 % i == 0 and freq [ i ] in freq . keys ( ) and freq [ i ] != 0 ) : NEW_LINE INDENT freq [ i ] -= 1 NEW_LINE if ( i != ( maxi1 // i ) and freq [ maxi1 // i ] in freq . keys ( ) and freq [ maxi1 // i ] != 0 ) : NEW_LINE INDENT freq [ maxi1 // i ] -= 1 NEW_LINE DEDENT DEDENT DEDENT maxi2 = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( freq [ a [ i ] ] != 0 ) : NEW_LINE INDENT maxi2 = max ( maxi2 , a [ i ] ) NEW_LINE DEDENT DEDENT print ( maxi1 , maxi2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 10 , 2 , 8 , 1 , 2 , 4 , 1 , 20 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE getNumbers ( a , n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5107_A", "sol": 0, "python_code": "def solve ( interval , N , Q ) :\n    Mark = [ 0 for i in range ( Q ) ]\n    for i in range ( N ) :\n        l = interval [ i ] [ 0 ] - 1\n        r = interval [ i ] [ 1 ] - 1\n        for j in range ( l , r + 1 ) :\n            Mark [ j ] += 1\n    count = 0\n    for i in range ( Q ) :\n        if ( Mark [ i ] ) :\n            count += 1\n    count1 = [ 0 for i in range ( Q ) ]\n    if ( Mark [ 0 ] == 1 ) :\n        count1 [ 0 ] = 1\n    for i in range ( 1 , Q ) :\n        if ( Mark [ i ] == 1 ) :\n            count1 [ i ] = count1 [ i - 1 ] + 1\n        else :\n            count1 [ i ] = count1 [ i - 1 ]\n    maxindex = 0\n    maxcoverage = 0\n    for i in range ( N ) :\n        l = interval [ i ] [ 0 ] - 1\n        r = interval [ i ] [ 1 ] - 1\n        elem1 = 0\n        if ( l != 0 ) :\n            elem1 = count1 [ r ] - count1 [ l - 1 ]\n        else :\n            elem1 = count1 [ r ]\n        if ( count - elem1 >= maxcoverage ) :\n            maxcoverage = count - elem1\n            maxindex = i\n    print ( \"Maximum Coverage is\" , maxcoverage , \"after removing interval at index\" , maxindex )\ninterval = [ [ 1 , 4 ] , [ 4 , 5 ] , [ 5 , 6 ] , [ 6 , 7 ] , [ 3 , 5 ] ]\nN = len ( interval )\nQ = 7\nsolve ( interval , N , Q )\n", "python_code_tokenized": "def solve ( interval , N , Q ) : NEW_LINE INDENT Mark = [ 0 for i in range ( Q ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT l = interval [ i ] [ 0 ] - 1 NEW_LINE r = interval [ i ] [ 1 ] - 1 NEW_LINE for j in range ( l , r + 1 ) : NEW_LINE INDENT Mark [ j ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( Q ) : NEW_LINE INDENT if ( Mark [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT count1 = [ 0 for i in range ( Q ) ] NEW_LINE if ( Mark [ 0 ] == 1 ) : NEW_LINE INDENT count1 [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , Q ) : NEW_LINE INDENT if ( Mark [ i ] == 1 ) : NEW_LINE INDENT count1 [ i ] = count1 [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 [ i ] = count1 [ i - 1 ] NEW_LINE DEDENT DEDENT maxindex = 0 NEW_LINE maxcoverage = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT l = interval [ i ] [ 0 ] - 1 NEW_LINE r = interval [ i ] [ 1 ] - 1 NEW_LINE elem1 = 0 NEW_LINE if ( l != 0 ) : NEW_LINE INDENT elem1 = count1 [ r ] - count1 [ l - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT elem1 = count1 [ r ] NEW_LINE DEDENT if ( count - elem1 >= maxcoverage ) : NEW_LINE INDENT maxcoverage = count - elem1 NEW_LINE maxindex = i NEW_LINE DEDENT DEDENT print ( \" Maximum \u2581 Coverage \u2581 is \" , maxcoverage , \" after \u2581 removing \u2581 interval \u2581 at \u2581 index \" , maxindex ) NEW_LINE DEDENT interval = [ [ 1 , 4 ] , [ 4 , 5 ] , [ 5 , 6 ] , [ 6 , 7 ] , [ 3 , 5 ] ] NEW_LINE N = len ( interval ) NEW_LINE Q = 7 NEW_LINE solve ( interval , N , Q ) NEW_LINE"}
{"id": "aizu_p00726_A", "sol": 0, "python_code": "from string import digits , ascii_uppercase\ndef parse ( S ) :\n    S += \"$\"\n    cur = 0\n    res = [ ]\n    def expr ( ) :\n        nonlocal cur\n        R = [ ] ; l = 0\n        while 1 :\n            c = S [ cur ]\n            if c in digits :\n                v = number ( )\n                if S [ cur ] == '(' :\n                    cur += 1\n                    R0 , l0 = expr ( )\n                    cur += 1\n                    l += v * l0\n                    R.append ( ( v , l0 , R0 ) )\n                else :\n                    c = S [ cur ]\n                    cur += 1\n                    l += v\n                    R.append ( ( v , 1 , [ c ] ) )\n            elif c in ascii_uppercase :\n                cur += 1\n                l += 1\n                R.append ( c )\n            else :\n                break\n        return R , l\n    def number ( ) :\n        nonlocal cur\n        v = 0\n        while 1 :\n            c = S [ cur ]\n            if c not in digits :\n                break\n            v = 10 * v + int ( c )\n            cur += 1\n        return v\n    R , l = expr ( )\n    return R , l\ndef solve ( res , x ) :\n    R , l = res\n    if l <= x :\n        return \"0\"\n    cur = R\n    while 1 :\n        for data in cur :\n            if isinstance ( data , str ) :\n                if x == 0 :\n                    return data\n                x -= 1\n            else :\n                v , l , R = data\n                if x < v * l :\n                    cur = R\n                    x %= l\n                    break\n                x -= v * l\nwhile 1 :\n    S , x = input ( ).split ( )\n    if S == \"0\" :\n        break\n    x = int ( x )\n    R , l = res = parse ( S )\n    if l <= x :\n        print ( \"0\" )\n        continue\n    print ( solve ( res , x ) )\n", "python_code_tokenized": "from string import digits , ascii_uppercase NEW_LINE def parse ( S ) : NEW_LINE INDENT S += \" $ \" NEW_LINE cur = 0 NEW_LINE res = [ ] NEW_LINE def expr ( ) : NEW_LINE INDENT nonlocal cur NEW_LINE R = [ ] ; l = 0 NEW_LINE while 1 : NEW_LINE INDENT c = S [ cur ] NEW_LINE if c in digits : NEW_LINE INDENT v = number ( ) NEW_LINE if S [ cur ] == ' ( ' : NEW_LINE INDENT cur += 1 NEW_LINE R0 , l0 = expr ( ) NEW_LINE cur += 1 NEW_LINE l += v * l0 NEW_LINE R . append ( ( v , l0 , R0 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT c = S [ cur ] NEW_LINE cur += 1 NEW_LINE l += v NEW_LINE R . append ( ( v , 1 , [ c ] ) ) NEW_LINE DEDENT DEDENT elif c in ascii_uppercase : NEW_LINE INDENT cur += 1 NEW_LINE l += 1 NEW_LINE R . append ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return R , l NEW_LINE DEDENT def number ( ) : NEW_LINE INDENT nonlocal cur NEW_LINE v = 0 NEW_LINE while 1 : NEW_LINE INDENT c = S [ cur ] NEW_LINE if c not in digits : NEW_LINE INDENT break NEW_LINE DEDENT v = 10 * v + int ( c ) NEW_LINE cur += 1 NEW_LINE DEDENT return v NEW_LINE DEDENT R , l = expr ( ) NEW_LINE return R , l NEW_LINE DEDENT def solve ( res , x ) : NEW_LINE INDENT R , l = res NEW_LINE if l <= x : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT cur = R NEW_LINE while 1 : NEW_LINE INDENT for data in cur : NEW_LINE INDENT if isinstance ( data , str ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return data NEW_LINE DEDENT x -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT v , l , R = data NEW_LINE if x < v * l : NEW_LINE INDENT cur = R NEW_LINE x %= l NEW_LINE break NEW_LINE DEDENT x -= v * l NEW_LINE DEDENT DEDENT DEDENT DEDENT while 1 : NEW_LINE INDENT S , x = input ( ) . split ( ) NEW_LINE if S == \"0\" : NEW_LINE INDENT break NEW_LINE DEDENT x = int ( x ) NEW_LINE R , l = res = parse ( S ) NEW_LINE if l <= x : NEW_LINE INDENT print ( \"0\" ) NEW_LINE continue NEW_LINE DEDENT print ( solve ( res , x ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2654_A", "sol": 0, "python_code": "def CountSwap ( s , n ) :\n    s = list ( s )\n    count = 0\n    ans = True\n    for i in range ( n // 2 ) :\n        left = i\n        right = n - left - 1\n        while left < right :\n            if s [ left ] == s [ right ] :\n                break\n            else :\n                right -= 1\n        if left == right :\n            ans = False\n            break\n        else :\n            for j in range ( right , n - left - 1 ) :\n                ( s [ j ] , s [ j + 1 ] ) = ( s [ j + 1 ] , s [ j ] )\n                count += 1\n    if ans :\n        print ( count )\n    else :\n        print ( '-1' )\ns = 'geeksfgeeks'\nn = len ( s )\nCountSwap ( s , n )\n", "python_code_tokenized": "def CountSwap ( s , n ) : NEW_LINE INDENT s = list ( s ) NEW_LINE count = 0 NEW_LINE ans = True NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT left = i NEW_LINE right = n - left - 1 NEW_LINE while left < right : NEW_LINE INDENT if s [ left ] == s [ right ] : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT DEDENT if left == right : NEW_LINE INDENT ans = False NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( right , n - left - 1 ) : NEW_LINE INDENT ( s [ j ] , s [ j + 1 ] ) = ( s [ j + 1 ] , s [ j ] ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT DEDENT if ans : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT DEDENT s = ' geeksfgeeks ' NEW_LINE n = len ( s ) NEW_LINE CountSwap ( s , n ) NEW_LINE"}
{"id": "atcoder_ARC100_C", "sol": 0, "python_code": "from collections import deque\nimport itertools as it\nimport sys\nimport math\ndef func ( ) :\n    N = int ( input ( ) )\n    A = list ( map ( int , input ( ).split ( ) ) )\n    P = [ [ ( A [ 0 ] , 0 ) , ( 0 , 0 ) ] for i in range ( 2 ** N ) ]\n    for i in range ( 1 , 2 ** N ) :\n        if ( A [ i ] , i ) > P [ i ] [ 0 ] :\n            P [ i ] [ 1 ] = P [ i ] [ 0 ]\n            P [ i ] [ 0 ] = ( A [ i ] , i )\n        elif ( A [ i ] , i ) > P [ i ] [ 1 ] :\n            P [ i ] [ 1 ] = ( A [ i ] , i )\n        for j in range ( N ) :\n            if ( i & ( 1 << j ) ) == 0 :\n                index = i + ( 1 << j )\n                for k in range ( 2 ) :\n                    if P [ i ] [ k ] > P [ index ] [ 0 ] :\n                        P [ index ] [ 1 ] = P [ index ] [ 0 ]\n                        P [ index ] [ 0 ] = P [ i ] [ k ]\n                    elif P [ i ] [ k ] > P [ index ] [ 1 ] and P [ i ] [ k ] != P [ index ] [ 0 ] :\n                        P [ index ] [ 1 ] = P [ i ] [ k ]\n    ans = 0\n    for i in range ( 1 , 2 ** N ) :\n        ans = max ( ans , P [ i ] [ 0 ] [ 0 ] + P [ i ] [ 1 ] [ 0 ] )\n        print ( ans )\nfunc ( )\n", "python_code_tokenized": "from collections import deque NEW_LINE import itertools as it NEW_LINE import sys NEW_LINE import math NEW_LINE def func ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE P = [ [ ( A [ 0 ] , 0 ) , ( 0 , 0 ) ] for i in range ( 2 ** N ) ] NEW_LINE for i in range ( 1 , 2 ** N ) : NEW_LINE INDENT if ( A [ i ] , i ) > P [ i ] [ 0 ] : NEW_LINE INDENT P [ i ] [ 1 ] = P [ i ] [ 0 ] NEW_LINE P [ i ] [ 0 ] = ( A [ i ] , i ) NEW_LINE DEDENT elif ( A [ i ] , i ) > P [ i ] [ 1 ] : NEW_LINE INDENT P [ i ] [ 1 ] = ( A [ i ] , i ) NEW_LINE DEDENT for j in range ( N ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) == 0 : NEW_LINE INDENT index = i + ( 1 << j ) NEW_LINE for k in range ( 2 ) : NEW_LINE INDENT if P [ i ] [ k ] > P [ index ] [ 0 ] : NEW_LINE INDENT P [ index ] [ 1 ] = P [ index ] [ 0 ] NEW_LINE P [ index ] [ 0 ] = P [ i ] [ k ] NEW_LINE DEDENT elif P [ i ] [ k ] > P [ index ] [ 1 ] and P [ i ] [ k ] != P [ index ] [ 0 ] : NEW_LINE INDENT P [ index ] [ 1 ] = P [ i ] [ k ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , 2 ** N ) : NEW_LINE INDENT ans = max ( ans , P [ i ] [ 0 ] [ 0 ] + P [ i ] [ 1 ] [ 0 ] ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT func ( ) NEW_LINE"}
{"id": "geeksforgeeks_3284_A", "sol": 0, "python_code": "def count ( s , Len ) :\n    global MAX\n    cur = 0\n    dig = 0\n    Sum = [ 0 ] * MAX\n    dp = [ [ 0 , 0 , 0 ] for i in range ( MAX ) ]\n    dp [ 0 ] [ 0 ] = 1\n    for i in range ( 1 , Len + 1 ) :\n        dig = int ( s [ i - 1 ] ) - 48\n        cur += dig\n        cur %= 3\n        Sum [ i ] = cur\n        dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ]\n        dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ]\n        dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ]\n        dp [ i ] [ Sum [ i ] ] += 1\n    ans = 0\n    dprev = 0\n    value = 0\n    dprev2 = 0\n    for i in range ( 1 , Len + 1 ) :\n        dig = int ( s [ i - 1 ] ) - 48\n        if dig == 8 :\n            ans += 1\n        if i - 2 >= 0 :\n            dprev = int ( s [ i - 2 ] ) - 48\n            value = dprev * 10 + dig\n            if ( value % 8 == 0 ) and ( value % 3 != 0 ) :\n                ans += 1\n        if i - 3 >= 0 :\n            dprev2 = int ( s [ i - 3 ] ) - 48\n            dprev = int ( s [ i - 2 ] ) - 48\n            value = ( dprev2 * 100 + dprev * 10 + dig )\n            if value % 8 != 0 :\n                continue\n            ans += ( i - 2 )\n            ans -= ( dp [ i - 3 ] [ Sum [ i ] ] )\n    return ans\nMAX = 1000\nStr = \"6564525600\"\nLen = len ( Str )\nprint ( count ( Str , Len ) )\n", "python_code_tokenized": "def count ( s , Len ) : NEW_LINE INDENT global MAX NEW_LINE cur = 0 NEW_LINE dig = 0 NEW_LINE Sum = [ 0 ] * MAX NEW_LINE dp = [ [ 0 , 0 , 0 ] for i in range ( MAX ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , Len + 1 ) : NEW_LINE INDENT dig = int ( s [ i - 1 ] ) - 48 NEW_LINE cur += dig NEW_LINE cur %= 3 NEW_LINE Sum [ i ] = cur NEW_LINE dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] NEW_LINE dp [ i ] [ Sum [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE dprev = 0 NEW_LINE value = 0 NEW_LINE dprev2 = 0 NEW_LINE for i in range ( 1 , Len + 1 ) : NEW_LINE INDENT dig = int ( s [ i - 1 ] ) - 48 NEW_LINE if dig == 8 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if i - 2 >= 0 : NEW_LINE INDENT dprev = int ( s [ i - 2 ] ) - 48 NEW_LINE value = dprev * 10 + dig NEW_LINE if ( value % 8 == 0 ) and ( value % 3 != 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if i - 3 >= 0 : NEW_LINE INDENT dprev2 = int ( s [ i - 3 ] ) - 48 NEW_LINE dprev = int ( s [ i - 2 ] ) - 48 NEW_LINE value = ( dprev2 * 100 + dprev * 10 + dig ) NEW_LINE if value % 8 != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT ans += ( i - 2 ) NEW_LINE ans -= ( dp [ i - 3 ] [ Sum [ i ] ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT MAX = 1000 NEW_LINE Str = \"6564525600\" NEW_LINE Len = len ( Str ) NEW_LINE print ( count ( Str , Len ) ) NEW_LINE"}
{"id": "geeksforgeeks_2689_A", "sol": 0, "python_code": "def findExtraCharacter ( strA , strB ) :\n    m1 = { }\n    for i in strB :\n        if i in m1 :\n            m1 [ i ] += 1\n        else :\n            m1 [ i ] = 1\n    for i in strA :\n        m1 [ i ] -= 1\n    for h1 in m1 :\n        if m1 [ h1 ] == 1 :\n            return h1\nif __name__ == \"__main__\" :\n    strA = 'abcd'\n    strB = 'cbdad'\n    print ( findExtraCharacter ( strA , strB ) )\n", "python_code_tokenized": "def findExtraCharacter ( strA , strB ) : NEW_LINE INDENT m1 = { } NEW_LINE for i in strB : NEW_LINE INDENT if i in m1 : NEW_LINE INDENT m1 [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 [ i ] = 1 NEW_LINE DEDENT DEDENT for i in strA : NEW_LINE INDENT m1 [ i ] -= 1 NEW_LINE DEDENT for h1 in m1 : NEW_LINE INDENT if m1 [ h1 ] == 1 : NEW_LINE INDENT return h1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT strA = ' abcd ' NEW_LINE strB = ' cbdad ' NEW_LINE print ( findExtraCharacter ( strA , strB ) ) NEW_LINE DEDENT"}
{"id": "aizu_p01656_A", "sol": 0, "python_code": "a = 'kogakubu10gokan'\nn , m = map ( int , input ( ).split ( ) )\nfor _ in range ( n ) :\n    c , b = input ( ).split ( )\n    if int ( c ) <= m : a = b\nprint ( a )\n", "python_code_tokenized": "a = ' kogakubu10gokan ' NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT c , b = input ( ) . split ( ) NEW_LINE if int ( c ) <= m : a = b NEW_LINE DEDENT print ( a ) NEW_LINE"}
{"id": "codeforces_844_A", "sol": 0, "python_code": "s = input ( )\nk = int ( input ( ) )\nprint ( 'impossible' if k > len ( s ) else max ( 0 , k - len ( set ( s ) ) ) )\n", "python_code_tokenized": "s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE print ( ' impossible ' if k > len ( s ) else max ( 0 , k - len ( set ( s ) ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_519_A", "sol": 0, "python_code": "from math import sqrt\ndef maxPrimeFactors ( n ) :\n    num = n\n    maxPrime = - 1 ;\n    while ( n % 2 == 0 ) :\n        maxPrime = 2\n        n = n / 2\n    p = int ( sqrt ( n ) + 1 )\n    for i in range ( 3 , p , 2 ) :\n        while ( n % i == 0 ) :\n            maxPrime = i\n            n = n / i\n    if ( n > 2 ) :\n        maxPrime = n\n    sum = maxPrime + num\n    return sum\nif __name__ == '__main__' :\n    n = 19\n    print ( maxPrimeFactors ( n ) )\n", "python_code_tokenized": "from math import sqrt NEW_LINE def maxPrimeFactors ( n ) : NEW_LINE INDENT num = n NEW_LINE maxPrime = - 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT maxPrime = 2 NEW_LINE n = n / 2 NEW_LINE DEDENT p = int ( sqrt ( n ) + 1 ) NEW_LINE for i in range ( 3 , p , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT maxPrime = i NEW_LINE n = n / i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT maxPrime = n NEW_LINE DEDENT sum = maxPrime + num NEW_LINE return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 19 NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1453_B", "sol": 0, "python_code": "import sys\ndef input ( ) :\n    return sys.stdin.readline ( ).rstrip ( )\nt = int ( input ( ) )\nfor i in range ( t ) :\n    n = int ( input ( ) )\n    v = list ( map ( int , input ( ).split ( ) ) )\n    adv = min ( - 1 * abs ( v [ 0 ] - v [ 1 ] ) , - 1 * abs ( v [ n - 2 ] - v [ n - 1 ] ) )\n    ans = 0\n    for j in range ( 1 , n ) :\n        ans += abs ( v [ j - 1 ] - v [ j ] )\n    for j in range ( 1 , n - 1 ) :\n        adv = min ( adv , abs ( v [ j + 1 ] - v [ j - 1 ] ) - abs ( v [ j - 1 ] - v [ j ] ) - abs ( v [ j + 1 ] - v [ j ] ) )\n    print ( ans + adv )\n", "python_code_tokenized": "import sys NEW_LINE def input ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) . rstrip ( ) NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE v = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE adv = min ( - 1 * abs ( v [ 0 ] - v [ 1 ] ) , - 1 * abs ( v [ n - 2 ] - v [ n - 1 ] ) ) NEW_LINE ans = 0 NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT ans += abs ( v [ j - 1 ] - v [ j ] ) NEW_LINE DEDENT for j in range ( 1 , n - 1 ) : NEW_LINE INDENT adv = min ( adv , abs ( v [ j + 1 ] - v [ j - 1 ] ) - abs ( v [ j - 1 ] - v [ j ] ) - abs ( v [ j + 1 ] - v [ j ] ) ) NEW_LINE DEDENT print ( ans + adv ) NEW_LINE DEDENT"}
{"id": "codeforces_1257_A", "sol": 0, "python_code": "for i in range ( int ( input ( ) ) ) :\n    n , x , a , b = map ( int , input ( ).split ( ) )\n    p = abs ( a - b )\n    q = p + x\n    if q >= n - 1 :\n        print ( n - 1 )\n    else :\n        print ( q )\n", "python_code_tokenized": "for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE p = abs ( a - b ) NEW_LINE q = p + x NEW_LINE if q >= n - 1 : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( q ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4363_A", "sol": 0, "python_code": "MOD = 1000000007\ndef product ( ar , n ) :\n    result = 1\n    for i in range ( 0 , n ) :\n        result = ( result * ar [ i ] ) % MOD\n    return result\nar = [ 1 , 2 , 3 , 4 , 5 ]\nn = len ( ar )\nprint ( product ( ar , n ) )\n", "python_code_tokenized": "MOD = 1000000007 NEW_LINE def product ( ar , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result = ( result * ar [ i ] ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT ar = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( ar ) NEW_LINE print ( product ( ar , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4362_A", "sol": 0, "python_code": "def product ( ar , n ) :\n    result = 1\n    for i in range ( 0 , n ) :\n        result = result * ar [ i ]\n    return result\nar = [ 1 , 2 , 3 , 4 , 5 ]\nn = len ( ar )\nprint ( product ( ar , n ) )\n", "python_code_tokenized": "def product ( ar , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result = result * ar [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT ar = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( ar ) NEW_LINE print ( product ( ar , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3789_A", "sol": 0, "python_code": "def PrintMinNumberForPattern ( arr ) :\n    curr_max = 0\n    last_entry = 0\n    i = 0\n    while i < len ( arr ) :\n        noOfNextD = 0\n        if arr [ i ] == \"I\" :\n            j = i + 1\n            while j < len ( arr ) and arr [ j ] == \"D\" :\n                noOfNextD += 1\n                j += 1\n            if i == 0 :\n                curr_max = noOfNextD + 2\n                last_entry += 1\n                print ( \"\" , last_entry , end = \"\" )\n                print ( \"\" , curr_max , end = \"\" )\n                last_entry = curr_max\n            else :\n                curr_max += noOfNextD + 1\n                last_entry = curr_max\n                print ( \"\" , last_entry , end = \"\" )\n            for k in range ( noOfNextD ) :\n                last_entry -= 1\n                print ( \"\" , last_entry , end = \"\" )\n                i += 1\n        elif arr [ i ] == \"D\" :\n            if i == 0 :\n                j = i + 1\n                while j < len ( arr ) and arr [ j ] == \"D\" :\n                    noOfNextD += 1\n                    j += 1\n                curr_max = noOfNextD + 2\n                print ( \"\" , curr_max , curr_max - 1 , end = \"\" )\n                last_entry = curr_max - 1\n            else :\n                print ( \"\" , last_entry - 1 , end = \"\" )\n                last_entry -= 1\n        i += 1\n    print ( )\nif __name__ == \"__main__\" :\n    PrintMinNumberForPattern ( \"IDID\" )\n    PrintMinNumberForPattern ( \"I\" )\n    PrintMinNumberForPattern ( \"DD\" )\n    PrintMinNumberForPattern ( \"II\" )\n    PrintMinNumberForPattern ( \"DIDI\" )\n    PrintMinNumberForPattern ( \"IIDDD\" )\n    PrintMinNumberForPattern ( \"DDIDDIID\" )\n", "python_code_tokenized": "def PrintMinNumberForPattern ( arr ) : NEW_LINE INDENT curr_max = 0 NEW_LINE last_entry = 0 NEW_LINE i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if arr [ i ] == \" I \" : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == \" D \" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT curr_max = noOfNextD + 2 NEW_LINE last_entry += 1 NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE print ( \" \" , curr_max , end = \" \" ) NEW_LINE last_entry = curr_max NEW_LINE DEDENT else : NEW_LINE INDENT curr_max += noOfNextD + 1 NEW_LINE last_entry = curr_max NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE DEDENT for k in range ( noOfNextD ) : NEW_LINE INDENT last_entry -= 1 NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT elif arr [ i ] == \" D \" : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == \" D \" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT curr_max = noOfNextD + 2 NEW_LINE print ( \" \" , curr_max , curr_max - 1 , end = \" \" ) NEW_LINE last_entry = curr_max - 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \" , last_entry - 1 , end = \" \" ) NEW_LINE last_entry -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT PrintMinNumberForPattern ( \" IDID \" ) NEW_LINE PrintMinNumberForPattern ( \" I \" ) NEW_LINE PrintMinNumberForPattern ( \" DD \" ) NEW_LINE PrintMinNumberForPattern ( \" II \" ) NEW_LINE PrintMinNumberForPattern ( \" DIDI \" ) NEW_LINE PrintMinNumberForPattern ( \" IIDDD \" ) NEW_LINE PrintMinNumberForPattern ( \" DDIDDIID \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2718_A", "sol": 0, "python_code": "def get_permutation ( arr , n ) :\n    arr = sorted ( arr )\n    result = 0\n    for i in range ( n ) :\n        result += abs ( arr [ i ] - ( i + 1 ) )\n    return result\nif __name__ == '__main__' :\n    arr = [ 0 , 2 , 3 , 4 , 1 , 6 , 8 , 9 ]\n    n = len ( arr )\n    print ( get_permutation ( arr , n ) )\n", "python_code_tokenized": "def get_permutation ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += abs ( arr [ i ] - ( i + 1 ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 0 , 2 , 3 , 4 , 1 , 6 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( get_permutation ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_390_A", "sol": 0, "python_code": "def make_permutation ( arr , n ) :\n    arr.sort ( ) ;\n    ans = 0 ;\n    for i in range ( n ) :\n        ans += abs ( i + 1 - arr [ i ] ) ;\n    return ans ;\nif __name__ == \"__main__\" :\n    arr = [ 5 , 3 , 8 , 1 , 1 ] ;\n    n = len ( arr ) ;\n    print ( make_permutation ( arr , n ) ) ;\n", "python_code_tokenized": "def make_permutation ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += abs ( i + 1 - arr [ i ] ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 3 , 8 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( make_permutation ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1741_A", "sol": 0, "python_code": "import math\ndef Modulo ( a , b ) :\n    mod = 0\n    for i in range ( 0 , len ( b ) ) :\n        mod = ( mod * 10 + ( int ) ( b [ i ] ) ) % a\n    return mod\ndef LastDigit ( a , b ) :\n    len_a = len ( a )\n    len_b = len ( b )\n    if ( len_a == 1 and len_b == 1 and b [ 0 ] == '0' and a [ 0 ] == '0' ) :\n        return 1\n    if ( len_b == 1 and b [ 0 ] == '0' ) :\n        return 1\n    if ( len_a == 1 and a [ 0 ] == '0' ) :\n        return 0\n    if ( ( Modulo ( 4 , b ) == 0 ) ) :\n        exp = 4\n    else :\n        exp = Modulo ( 4 , b )\n    res = math.pow ( ( int ) ( a [ len_a - 1 ] ) , exp )\n    return res % 10\na = [ '1' , '1' , '7' ]\nb = [ '3' ]\nprint ( LastDigit ( a , b ) )\n", "python_code_tokenized": "import math NEW_LINE def Modulo ( a , b ) : NEW_LINE INDENT mod = 0 NEW_LINE for i in range ( 0 , len ( b ) ) : NEW_LINE INDENT mod = ( mod * 10 + ( int ) ( b [ i ] ) ) % a NEW_LINE DEDENT return mod NEW_LINE DEDENT def LastDigit ( a , b ) : NEW_LINE INDENT len_a = len ( a ) NEW_LINE len_b = len ( b ) NEW_LINE if ( len_a == 1 and len_b == 1 and b [ 0 ] == '0' and a [ 0 ] == '0' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( len_b == 1 and b [ 0 ] == '0' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( len_a == 1 and a [ 0 ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( Modulo ( 4 , b ) == 0 ) ) : NEW_LINE INDENT exp = 4 NEW_LINE DEDENT else : NEW_LINE INDENT exp = Modulo ( 4 , b ) NEW_LINE DEDENT res = math . pow ( ( int ) ( a [ len_a - 1 ] ) , exp ) NEW_LINE return res % 10 NEW_LINE DEDENT a = [ '1' , '1' , '7' ] NEW_LINE b = [ '3' ] NEW_LINE print ( LastDigit ( a , b ) ) NEW_LINE"}
{"id": "geeksforgeeks_1589_A", "sol": 0, "python_code": "def findSum ( N , K ) :\n    ans = 0 ;\n    y = N / K ;\n    x = N % K ;\n    ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) ;\n    return int ( ans ) ;\nN = 10 ;\nK = 2 ;\nprint ( findSum ( N , K ) ) ;\n", "python_code_tokenized": "def findSum ( N , K ) : NEW_LINE INDENT ans = 0 ; NEW_LINE y = N / K ; NEW_LINE x = N % K ; NEW_LINE ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT N = 10 ; NEW_LINE K = 2 ; NEW_LINE print ( findSum ( N , K ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_1933_A", "sol": 0, "python_code": "def winner ( moves ) :\n    data = dict ( )\n    data [ 'R' ] = 0\n    data [ 'P' ] = 1\n    data [ 'S' ] = 2\n    if ( moves [ 0 ] == moves [ 1 ] ) :\n        return \"Draw\"\n    if ( ( ( data [ moves [ 0 ] ] | 1 << ( 2 ) ) - ( data [ moves [ 1 ] ] | 0 << ( 2 ) ) ) % 3 ) :\n        return \"A\"\n    return \"B\"\ndef performQueries ( arr , n ) :\n    for i in range ( n ) :\n        print ( winner ( arr [ i ] ) )\narr = [ \"RS\" , \"SR\" , \"SP\" , \"PP\" ]\nn = len ( arr )\nperformQueries ( arr , n )\n", "python_code_tokenized": "def winner ( moves ) : NEW_LINE INDENT data = dict ( ) NEW_LINE data [ ' R ' ] = 0 NEW_LINE data [ ' P ' ] = 1 NEW_LINE data [ ' S ' ] = 2 NEW_LINE if ( moves [ 0 ] == moves [ 1 ] ) : NEW_LINE INDENT return \" Draw \" NEW_LINE DEDENT if ( ( ( data [ moves [ 0 ] ] | 1 << ( 2 ) ) - ( data [ moves [ 1 ] ] | 0 << ( 2 ) ) ) % 3 ) : NEW_LINE INDENT return \" A \" NEW_LINE DEDENT return \" B \" NEW_LINE DEDENT def performQueries ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( winner ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT arr = [ \" RS \" , \" SR \" , \" SP \" , \" PP \" ] NEW_LINE n = len ( arr ) NEW_LINE performQueries ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_2485_A", "sol": 0, "python_code": "class Node :\n    def __init__ ( self ) :\n        self.data = 0\n        self.next = None\nfirst = None\nlast = None\nlength = 0\ndef printList ( node ) :\n    while ( node != None ) :\n        print ( node.data , end = \" \" )\n        node = node.next\ndef moveToFront ( head , p , m ) :\n    global first\n    global last\n    global length\n    if ( head == None ) :\n        return head\n    p = head\n    head = head.next\n    m = m + 1\n    if ( length == m ) :\n        p.next = None\n        last.next = first\n        first = head\n    else :\n        moveToFront ( head , p , m )\ndef push ( head_ref , new_data ) :\n    global first\n    global last\n    global length\n    new_node = Node ( )\n    new_node.data = new_data\n    new_node.next = ( head_ref )\n    ( head_ref ) = new_node\n    if ( length == 0 ) :\n        last = head_ref\n    else :\n        first = head_ref\n    length = length + 1\n    return head_ref\nstart = None\nstart = push ( start , 5 )\nstart = push ( start , 4 )\nstart = push ( start , 3 )\nstart = push ( start , 2 )\nstart = push ( start , 1 )\nstart = push ( start , 0 )\nprint ( \"\\n Initial Linked list\" )\nprintList ( start )\nm = 4\ntemp = None\nmoveToFront ( start , temp , m )\nprint ( \"\\n Final Linked list\" )\nstart = first\nprintList ( start )\n", "python_code_tokenized": "class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT first = None NEW_LINE last = None NEW_LINE length = 0 NEW_LINE def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" \u2581 \" ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT def moveToFront ( head , p , m ) : NEW_LINE INDENT global first NEW_LINE global last NEW_LINE global length NEW_LINE if ( head == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT p = head NEW_LINE head = head . next NEW_LINE m = m + 1 NEW_LINE if ( length == m ) : NEW_LINE INDENT p . next = None NEW_LINE last . next = first NEW_LINE first = head NEW_LINE DEDENT else : NEW_LINE INDENT moveToFront ( head , p , m ) NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT global first NEW_LINE global last NEW_LINE global length NEW_LINE new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE if ( length == 0 ) : NEW_LINE INDENT last = head_ref NEW_LINE DEDENT else : NEW_LINE INDENT first = head_ref NEW_LINE DEDENT length = length + 1 NEW_LINE return head_ref NEW_LINE DEDENT start = None NEW_LINE start = push ( start , 5 ) NEW_LINE start = push ( start , 4 ) NEW_LINE start = push ( start , 3 ) NEW_LINE start = push ( start , 2 ) NEW_LINE start = push ( start , 1 ) NEW_LINE start = push ( start , 0 ) NEW_LINE print ( \" \\n \u2581 Initial \u2581 Linked \u2581 list \" ) NEW_LINE printList ( start ) NEW_LINE m = 4 NEW_LINE temp = None NEW_LINE moveToFront ( start , temp , m ) NEW_LINE print ( \" \\n \u2581 Final \u2581 Linked \u2581 list \" ) NEW_LINE start = first NEW_LINE printList ( start ) NEW_LINE"}
{"id": "geeksforgeeks_3370_A", "sol": 0, "python_code": "MAX_CHAR = 26\ndef countPairs ( str1 ) :\n    result = 0 ;\n    n = len ( str1 )\n    for i in range ( 0 , n ) :\n        for j in range ( 1 , MAX_CHAR + 1 ) :\n            if ( ( i + j ) < n ) :\n                if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( str1 [ i ] ) ) == j ) ) :\n                    result += 1 ;\n    return result\nif __name__ == \"__main__\" :\n    str1 = \"geeksforgeeks\" ;\n    print ( countPairs ( str1 ) )\n", "python_code_tokenized": "MAX_CHAR = 26 NEW_LINE def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 1 , MAX_CHAR + 1 ) : NEW_LINE INDENT if ( ( i + j ) < n ) : NEW_LINE INDENT if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( str1 [ i ] ) ) == j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( str1 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3369_A", "sol": 0, "python_code": "def countPairs ( str1 ) :\n    result = 0 ;\n    n = len ( str1 )\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n ) :\n            if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) :\n                result += 1 ;\n    return result ;\nif __name__ == \"__main__\" :\n    str1 = \"geeksforgeeks\" ;\n    print ( countPairs ( str1 ) ) ;\n", "python_code_tokenized": "def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" ; NEW_LINE print ( countPairs ( str1 ) ) ; NEW_LINE DEDENT"}
{"id": "aizu_p01763_A", "sol": 0, "python_code": "def extgcd ( a , b ) :\n    if b == 0 :\n        x = 1\n        y = 0\n        return a , x , y\n    g , s , t = extgcd ( b , a % b )\n    x , y = t , s - a // b * t\n    return g , x , y\ndef chineserem ( b , m ) :\n    r = 0\n    M = 1\n    for i in range ( len ( b ) ) :\n        g , p , q = extgcd ( M , m [ i ] )\n        if ( b [ i ] - r ) % g != 0 :\n            return 0 , - 1\n        tmp = ( b [ i ] - r ) // g * p % ( m [ i ] // g )\n        r += M * tmp\n        M *= m [ i ] // g\n    return r , M\nn , m , d = [ int ( x ) for x in input ( ).split ( ) ]\na = [ int ( x ) for x in input ( ).split ( ) ]\nr = [ [ int ( x ) for x in input ( ).split ( ) ] for i in range ( d ) ]\nfor d in range ( d ) :\n    mo = [ ]\n    b = [ ]\n    for i in range ( m ) :\n        if r [ d ] [ i ] > - 1 :\n            mo.append ( a [ i ] )\n            b.append ( r [ d ] [ i ] )\n    x , M = chineserem ( b , mo )\n    if M < 0 :\n        print ( - 1 )\n        quit ( )\n    i = ( n - x ) // M\n    if i < 0 :\n        print ( - 1 )\n        quit ( )\n    n = M * i + x\nprint ( n )\n", "python_code_tokenized": "def extgcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT x = 1 NEW_LINE y = 0 NEW_LINE return a , x , y NEW_LINE DEDENT g , s , t = extgcd ( b , a % b ) NEW_LINE x , y = t , s - a // b * t NEW_LINE return g , x , y NEW_LINE DEDENT def chineserem ( b , m ) : NEW_LINE INDENT r = 0 NEW_LINE M = 1 NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT g , p , q = extgcd ( M , m [ i ] ) NEW_LINE if ( b [ i ] - r ) % g != 0 : NEW_LINE INDENT return 0 , - 1 NEW_LINE DEDENT tmp = ( b [ i ] - r ) // g * p % ( m [ i ] // g ) NEW_LINE r += M * tmp NEW_LINE M *= m [ i ] // g NEW_LINE DEDENT return r , M NEW_LINE DEDENT n , m , d = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE r = [ [ int ( x ) for x in input ( ) . split ( ) ] for i in range ( d ) ] NEW_LINE for d in range ( d ) : NEW_LINE INDENT mo = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT if r [ d ] [ i ] > - 1 : NEW_LINE INDENT mo . append ( a [ i ] ) NEW_LINE b . append ( r [ d ] [ i ] ) NEW_LINE DEDENT DEDENT x , M = chineserem ( b , mo ) NEW_LINE if M < 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE quit ( ) NEW_LINE DEDENT i = ( n - x ) // M NEW_LINE if i < 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE quit ( ) NEW_LINE DEDENT n = M * i + x NEW_LINE DEDENT print ( n ) NEW_LINE"}
{"id": "codeforces_431_A", "sol": 0, "python_code": "l = list ( map ( int , input ( ).split ( ) ) )\ns = input ( )\np = 0\nfor i in s :\n    p += l [ int ( i ) - 1 ]\nprint ( p )\n", "python_code_tokenized": "l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = input ( ) NEW_LINE p = 0 NEW_LINE for i in s : NEW_LINE INDENT p += l [ int ( i ) - 1 ] NEW_LINE DEDENT print ( p ) NEW_LINE"}
{"id": "geeksforgeeks_1655_A", "sol": 0, "python_code": "def arraySum ( arr , n ) :\n    sm = 0\n    i = 0\n    while ( i < n ) :\n        sm = sm + arr [ i ]\n        i = i + 1\n    return sm\ndef smallest ( arr , n ) :\n    small = 1000000000\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] < small ) :\n            small = arr [ i ]\n    return small\ndef minOp ( arr , n ) :\n    sm = arraySum ( arr , n )\n    small = smallest ( arr , n )\n    minOperation = sm - ( n * small )\n    return minOperation\narr = [ 5 , 6 , 2 , 4 , 3 ]\nn = len ( arr )\nprint ( \"Minimum Operation = \" , minOp ( arr , n ) )\n", "python_code_tokenized": "def arraySum ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT sm = sm + arr [ i ] NEW_LINE i = i + 1 NEW_LINE DEDENT return sm NEW_LINE DEDENT def smallest ( arr , n ) : NEW_LINE INDENT small = 1000000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT DEDENT return small NEW_LINE DEDENT def minOp ( arr , n ) : NEW_LINE INDENT sm = arraySum ( arr , n ) NEW_LINE small = smallest ( arr , n ) NEW_LINE minOperation = sm - ( n * small ) NEW_LINE return minOperation NEW_LINE DEDENT arr = [ 5 , 6 , 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum \u2581 Operation \u2581 = \u2581 \" , minOp ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2423_A", "sol": 0, "python_code": "def printTaxicab2 ( N ) :\n    i , count = 1 , 0\n    while ( count < N ) :\n        int_count = 0\n        for j in range ( 1 , int ( pow ( i , 1.0 / 3 ) ) + 1 ) :\n            for k in range ( j + 1 , int ( pow ( i , 1.0 / 3 ) ) + 1 ) :\n                if ( j * j * j + k * k * k == i ) :\n                    int_count += 1\n        if ( int_count == 2 ) :\n            count += 1\n            print ( count , \" \" , i )\n        i += 1\nN = 5\nprintTaxicab2 ( N )\n", "python_code_tokenized": "def printTaxicab2 ( N ) : NEW_LINE INDENT i , count = 1 , 0 NEW_LINE while ( count < N ) : NEW_LINE INDENT int_count = 0 NEW_LINE for j in range ( 1 , int ( pow ( i , 1.0 / 3 ) ) + 1 ) : NEW_LINE INDENT for k in range ( j + 1 , int ( pow ( i , 1.0 / 3 ) ) + 1 ) : NEW_LINE INDENT if ( j * j * j + k * k * k == i ) : NEW_LINE INDENT int_count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( int_count == 2 ) : NEW_LINE INDENT count += 1 NEW_LINE print ( count , \" \u2581 \" , i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT N = 5 NEW_LINE printTaxicab2 ( N ) NEW_LINE"}
{"id": "geeksforgeeks_2669_A", "sol": 0, "python_code": "def findstem ( arr ) :\n    n = len ( arr )\n    s = arr [ 0 ]\n    l = len ( s )\n    res = \"\"\n    for i in range ( l ) :\n        for j in range ( i + 1 , l + 1 ) :\n            stem = s [ i : j ]\n            k = 1\n            for k in range ( 1 , n ) :\n                if stem not in arr [ k ] :\n                    break\n            if ( k + 1 == n and len ( res ) < len ( stem ) ) :\n                res = stem\n    return res\nif __name__ == \"__main__\" :\n    arr = [ \"grace\" , \"graceful\" , \"disgraceful\" , \"gracefully\" ]\n    stems = findstem ( arr )\n    print ( stems )\n", "python_code_tokenized": "def findstem ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE s = arr [ 0 ] NEW_LINE l = len ( s ) NEW_LINE res = \" \" NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( i + 1 , l + 1 ) : NEW_LINE INDENT stem = s [ i : j ] NEW_LINE k = 1 NEW_LINE for k in range ( 1 , n ) : NEW_LINE INDENT if stem not in arr [ k ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( k + 1 == n and len ( res ) < len ( stem ) ) : NEW_LINE INDENT res = stem NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" grace \" , \" graceful \" , \" disgraceful \" , \" gracefully \" ] NEW_LINE stems = findstem ( arr ) NEW_LINE print ( stems ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_941_A", "sol": 0, "python_code": "class Node :\n    def __init__ ( self , data = 0 ) :\n        self.data = data\n        self.next = None\nclass treeNode :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.left = None\n        self.right = None\ndef print_ ( head ) :\n    if ( head == None ) :\n        return\n    temp = head\n    while ( temp != None ) :\n        print ( temp.data , end = \" \" )\n        temp = temp.next\ndef sortedList ( head , root ) :\n    if ( root == None ) :\n        return head\n    head = sortedList ( head , root.left )\n    newNode = Node ( root.data )\n    temp = head\n    prev = None\n    if ( temp == None ) :\n        head = newNode\n    else :\n        while ( temp != None ) :\n            if ( temp.data > root.data ) :\n                break\n            else :\n                prev = temp\n                temp = temp.next\n        if ( temp == None ) :\n            prev.next = newNode\n        else :\n            if ( prev == None ) :\n                newNode.next = temp\n                head = newNode\n            else :\n                newNode.next = temp\n                prev.next = newNode\n    head = sortedList ( head , root.right )\n    return head\nroot = treeNode ( 10 )\nroot.left = treeNode ( 15 )\nroot.right = treeNode ( 2 )\nroot.left.left = treeNode ( 1 )\nroot.left.right = treeNode ( 5 )\nhead = sortedList ( None , root )\nprint_ ( head )\n", "python_code_tokenized": "class Node : NEW_LINE INDENT def __init__ ( self , data = 0 ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class treeNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def print_ ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT print ( temp . data , end = \" \u2581 \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT def sortedList ( head , root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT head = sortedList ( head , root . left ) NEW_LINE newNode = Node ( root . data ) NEW_LINE temp = head NEW_LINE prev = None NEW_LINE if ( temp == None ) : NEW_LINE INDENT head = newNode NEW_LINE DEDENT else : NEW_LINE INDENT while ( temp != None ) : NEW_LINE INDENT if ( temp . data > root . data ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT prev = temp NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT if ( temp == None ) : NEW_LINE INDENT prev . next = newNode NEW_LINE DEDENT else : NEW_LINE INDENT if ( prev == None ) : NEW_LINE INDENT newNode . next = temp NEW_LINE head = newNode NEW_LINE DEDENT else : NEW_LINE INDENT newNode . next = temp NEW_LINE prev . next = newNode NEW_LINE DEDENT DEDENT DEDENT head = sortedList ( head , root . right ) NEW_LINE return head NEW_LINE DEDENT root = treeNode ( 10 ) NEW_LINE root . left = treeNode ( 15 ) NEW_LINE root . right = treeNode ( 2 ) NEW_LINE root . left . left = treeNode ( 1 ) NEW_LINE root . left . right = treeNode ( 5 ) NEW_LINE head = sortedList ( None , root ) NEW_LINE print_ ( head ) NEW_LINE"}
{"id": "geeksforgeeks_2820_A", "sol": 0, "python_code": "import math\nimport sys\ndef changeTheArray ( arr , n ) :\n    minEle = min ( arr )\n    maxEle = max ( arr )\n    minOperations = sys.maxsize\n    for num in range ( minEle , maxEle + 1 ) :\n        operations = 0\n        for i in range ( n ) :\n            if arr [ i ] != num :\n                operations += ( abs ( num - arr [ i ] ) - 1 )\n        minOperations = min ( minOperations , operations )\n    return minOperations\nif __name__ == '__main__' :\n    arr = [ 10 , 1 , 4 ]\n    n = len ( arr )\n    print ( changeTheArray ( arr , n ) )\n", "python_code_tokenized": "import math NEW_LINE import sys NEW_LINE def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE maxEle = max ( arr ) NEW_LINE minOperations = sys . maxsize NEW_LINE for num in range ( minEle , maxEle + 1 ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != num : NEW_LINE INDENT operations += ( abs ( num - arr [ i ] ) - 1 ) NEW_LINE DEDENT DEDENT minOperations = min ( minOperations , operations ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 1 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( changeTheArray ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_485_B", "sol": 0, "python_code": "import sys\nfrom collections import Counter\ndef get_ints ( ) : return list ( map ( int , sys.stdin.readline ( ).strip ( ).split ( ) ) )\nsys.setrecursionlimit ( 20000 )\nn = int ( input ( ) )\nresources = [ ]\nfor _ in range ( n ) :\n    x , y = get_ints ( )\n    resources.append ( ( x , y ) )\nmin_x , min_y = resources [ 0 ] [ 0 ] , resources [ 0 ] [ 1 ]\nmax_x , max_y = resources [ 0 ] [ 0 ] , resources [ 0 ] [ 1 ]\nfor x , y in resources :\n    if x > max_x :\n        max_x = x\n    if x < min_x :\n        min_x = x\n    if y > max_y :\n        max_y = y\n    if y < min_y :\n        min_y = y\nprint ( max ( ( max_x - min_x ) , ( max_y - min_y ) ) ** 2 )\n", "python_code_tokenized": "import sys NEW_LINE from collections import Counter NEW_LINE def get_ints ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE sys . setrecursionlimit ( 20000 ) NEW_LINE n = int ( input ( ) ) NEW_LINE resources = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , y = get_ints ( ) NEW_LINE resources . append ( ( x , y ) ) NEW_LINE DEDENT min_x , min_y = resources [ 0 ] [ 0 ] , resources [ 0 ] [ 1 ] NEW_LINE max_x , max_y = resources [ 0 ] [ 0 ] , resources [ 0 ] [ 1 ] NEW_LINE for x , y in resources : NEW_LINE INDENT if x > max_x : NEW_LINE INDENT max_x = x NEW_LINE DEDENT if x < min_x : NEW_LINE INDENT min_x = x NEW_LINE DEDENT if y > max_y : NEW_LINE INDENT max_y = y NEW_LINE DEDENT if y < min_y : NEW_LINE INDENT min_y = y NEW_LINE DEDENT DEDENT print ( max ( ( max_x - min_x ) , ( max_y - min_y ) ) ** 2 ) NEW_LINE"}
{"id": "geeksforgeeks_4024_A", "sol": 0, "python_code": "def solve ( n , base ) :\n    result = 0\n    while ( n > 0 ) :\n        remainder = n % base\n        result = result + remainder\n        n = int ( n / base )\n    return result\ndef printSumsOfDigits ( n ) :\n    for base in range ( 2 , n ) :\n        print ( solve ( n , base ) , end = \" \" )\nn = 8\nprintSumsOfDigits ( n )\n", "python_code_tokenized": "def solve ( n , base ) : NEW_LINE INDENT result = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT remainder = n % base NEW_LINE result = result + remainder NEW_LINE n = int ( n / base ) NEW_LINE DEDENT return result NEW_LINE DEDENT def printSumsOfDigits ( n ) : NEW_LINE INDENT for base in range ( 2 , n ) : NEW_LINE INDENT print ( solve ( n , base ) , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT n = 8 NEW_LINE printSumsOfDigits ( n ) NEW_LINE"}
{"id": "aizu_p01865_A", "sol": 0, "python_code": "def solve ( l , n , jota_weights ) :\n    jota_torque = sum ( x * w for x , w in jota_weights )\n    if jota_torque == 0 :\n        return ( 0 , [ ] )\n    else :\n        max_w = 50000\n        sign = - 1 if jota_torque > 0 else 1\n        ritsuko_weights = [ ]\n        ritsuko_counter = 0\n        weight = 0\n        remainder = abs ( jota_torque )\n        for x in range ( l , 0 , - 1 ) :\n            if remainder <= 0 :\n                break\n            weight = min ( max_w , remainder // x )\n            remainder -= x * weight\n            if weight > 0 :\n                ritsuko_counter += 1\n                ritsuko_weights.append ( ( sign * x , weight ) )\n        return ( ritsuko_counter , ritsuko_weights )\ndef main ( ) :\n    l = int ( input ( ) )\n    n = int ( input ( ) )\n    jota_torque = [ tuple ( map ( int , input ( ).split ( ) ) ) for _ in range ( n ) ]\n    n_prime , ritsuko_weights = solve ( l , n , jota_torque )\n    print ( n_prime )\n    if n_prime :\n        for x_prime , w_prime in ritsuko_weights :\n            print ( \"{} {}\".format ( x_prime , w_prime ) )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "def solve ( l , n , jota_weights ) : NEW_LINE INDENT jota_torque = sum ( x * w for x , w in jota_weights ) NEW_LINE if jota_torque == 0 : NEW_LINE INDENT return ( 0 , [ ] ) NEW_LINE DEDENT else : NEW_LINE INDENT max_w = 50000 NEW_LINE sign = - 1 if jota_torque > 0 else 1 NEW_LINE ritsuko_weights = [ ] NEW_LINE ritsuko_counter = 0 NEW_LINE weight = 0 NEW_LINE remainder = abs ( jota_torque ) NEW_LINE for x in range ( l , 0 , - 1 ) : NEW_LINE INDENT if remainder <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT weight = min ( max_w , remainder // x ) NEW_LINE remainder -= x * weight NEW_LINE if weight > 0 : NEW_LINE INDENT ritsuko_counter += 1 NEW_LINE ritsuko_weights . append ( ( sign * x , weight ) ) NEW_LINE DEDENT DEDENT return ( ritsuko_counter , ritsuko_weights ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT l = int ( input ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE jota_torque = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE n_prime , ritsuko_weights = solve ( l , n , jota_torque ) NEW_LINE print ( n_prime ) NEW_LINE if n_prime : NEW_LINE INDENT for x_prime , w_prime in ritsuko_weights : NEW_LINE INDENT print ( \" { } \u2581 { } \" . format ( x_prime , w_prime ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_935_A", "sol": 0, "python_code": "n = int ( input ( ) )\ncount = 0\nfor x in range ( 1 , ( n // 2 ) + 1 ) :\n    if ( n - x ) % x == 0 :\n        count += 1\nprint ( count )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE for x in range ( 1 , ( n // 2 ) + 1 ) : NEW_LINE INDENT if ( n - x ) % x == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"}
{"id": "projecteuler_p029_A", "sol": 0, "python_code": "def compute ( ) :\n    seen = set ( a ** b for a in range ( 2 , 101 ) for b in range ( 2 , 101 ) )\n    return str ( len ( seen ) )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT seen = set ( a ** b for a in range ( 2 , 101 ) for b in range ( 2 , 101 ) ) NEW_LINE return str ( len ( seen ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_236_A", "sol": 0, "python_code": "def solve ( ) :\n    s = input ( )\n    x = [ ]\n    x = set ( x )\n    for i in range ( len ( s ) ) :\n        x.add ( s [ i ] )\n    if ( len ( x ) % 2 == 0 ) :\n        print ( \"CHAT WITH HER!\" )\n    else :\n        print ( \"IGNORE HIM!\" )\nif __name__ == \"__main__\" :\n    solve ( )\n", "python_code_tokenized": "def solve ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE x = [ ] NEW_LINE x = set ( x ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT x . add ( s [ i ] ) NEW_LINE DEDENT if ( len ( x ) % 2 == 0 ) : NEW_LINE INDENT print ( \" CHAT \u2581 WITH \u2581 HER ! \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" IGNORE \u2581 HIM ! \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3829_A", "sol": 0, "python_code": "def bitonic ( A , n ) :\n    if ( n == 0 ) :\n        return 0 ;\n    maxLen = 1 ;\n    start = 0 ;\n    nextStart = 0 ;\n    j = 0 ;\n    while ( j < n - 1 ) :\n        while ( j < n - 1 and A [ j ] <= A [ j + 1 ] ) :\n            j = j + 1 ;\n        while ( j < n - 1 and A [ j ] >= A [ j + 1 ] ) :\n            if ( j < n - 1 and A [ j ] > A [ j + 1 ] ) :\n                nextStart = j + 1 ;\n            j = j + 1 ;\n        maxLen = max ( maxLen , j - ( start - 1 ) ) ;\n        start = nextStart ;\n    return maxLen ;\nA = [ 12 , 4 , 78 , 90 , 45 , 23 ] ;\nn = len ( A ) ;\nprint ( \"Length of max length Bitonic Subarray is\" , bitonic ( A , n ) ) ;\n", "python_code_tokenized": "def bitonic ( A , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT maxLen = 1 ; NEW_LINE start = 0 ; NEW_LINE nextStart = 0 ; NEW_LINE j = 0 ; NEW_LINE while ( j < n - 1 ) : NEW_LINE INDENT while ( j < n - 1 and A [ j ] <= A [ j + 1 ] ) : NEW_LINE INDENT j = j + 1 ; NEW_LINE DEDENT while ( j < n - 1 and A [ j ] >= A [ j + 1 ] ) : NEW_LINE INDENT if ( j < n - 1 and A [ j ] > A [ j + 1 ] ) : NEW_LINE INDENT nextStart = j + 1 ; NEW_LINE DEDENT j = j + 1 ; NEW_LINE DEDENT maxLen = max ( maxLen , j - ( start - 1 ) ) ; NEW_LINE start = nextStart ; NEW_LINE DEDENT return maxLen ; NEW_LINE DEDENT A = [ 12 , 4 , 78 , 90 , 45 , 23 ] ; NEW_LINE n = len ( A ) ; NEW_LINE print ( \" Length \u2581 of \u2581 max \u2581 length \u2581 Bitonic \u2581 Subarray \u2581 is \" , bitonic ( A , n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_5137_A", "sol": 0, "python_code": "def LeibnizHarmonicTriangle ( n ) :\n    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] ;\n    for i in range ( 0 , n + 1 ) :\n        for j in range ( 0 , min ( i , n ) + 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1 ;\n            else :\n                C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ;\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , i + 1 ) :\n            print ( \"1/\" , end = \"\" ) ;\n            print ( i * C [ i - 1 ] [ j - 1 ] , end = \" \" ) ;\n        print ( ) ;\nLeibnizHarmonicTriangle ( 4 ) ;\n", "python_code_tokenized": "def LeibnizHarmonicTriangle ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( \"1 / \" , end = \" \" ) ; NEW_LINE print ( i * C [ i - 1 ] [ j - 1 ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT LeibnizHarmonicTriangle ( 4 ) ; NEW_LINE"}
{"id": "geeksforgeeks_2942_A", "sol": 0, "python_code": "def printpascalmatrix ( n ) :\n    C = [ [ 0 for x in range ( 2 * n + 1 ) ] for y in range ( 2 * n + 1 ) ]\n    for i in range ( 2 * n + 1 ) :\n        for j in range ( min ( i , 2 * n ) + 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1 ;\n            else :\n                C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ;\n    for i in range ( n ) :\n        for j in range ( n ) :\n            print ( C [ i + j ] [ i ] , end = \" \" ) ;\n        print ( ) ;\nn = 5 ;\nprintpascalmatrix ( n ) ;\n", "python_code_tokenized": "def printpascalmatrix ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( 2 * n + 1 ) ] for y in range ( 2 * n + 1 ) ] NEW_LINE for i in range ( 2 * n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , 2 * n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( C [ i + j ] [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE printpascalmatrix ( n ) ; NEW_LINE"}
{"id": "geeksforgeeks_223_A", "sol": 0, "python_code": "def findMin ( arr , n ) :\n    m = 0\n    for i in range ( n ) :\n        m = max ( m , arr [ i ] )\n    cnt = [ 0 ] * ( m + 2 )\n    for i in range ( n ) :\n        j = 1\n        while j * j <= arr [ i ] :\n            if ( arr [ i ] % j == 0 ) :\n                if ( j * j == arr [ i ] ) :\n                    cnt [ j ] += 1\n                else :\n                    cnt [ j ] += 1\n                    cnt [ arr [ i ] // j ] += 1\n            j += 1\n    for i in range ( 1 , m + 2 ) :\n        if ( cnt [ i ] == 0 ) :\n            return i\n    return - 1\narr = [ 2 , 12 , 6 ]\nn = len ( arr )\nprint ( findMin ( arr , n ) )\n", "python_code_tokenized": "def findMin ( arr , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT cnt = [ 0 ] * ( m + 2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 1 NEW_LINE while j * j <= arr [ i ] : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT if ( j * j == arr [ i ] ) : NEW_LINE INDENT cnt [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ j ] += 1 NEW_LINE cnt [ arr [ i ] // j ] += 1 NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , m + 2 ) : NEW_LINE INDENT if ( cnt [ i ] == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 12 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMin ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_224_A", "sol": 0, "python_code": "def findMin ( arr , n ) :\n    m = 0\n    for i in range ( n ) :\n        m = max ( m , arr [ i ] )\n    freq = [ 0 ] * ( m + 2 )\n    for i in range ( n ) :\n        freq [ arr [ i ] ] += 1\n    for i in range ( 1 , m + 2 ) :\n        j = i\n        cnt = 0\n        while ( j <= m ) :\n            cnt += freq [ j ]\n            j += i\n        if ( not cnt ) :\n            return i\n    return m + 1\narr = [ 2 , 12 , 6 ]\nn = len ( arr )\nprint ( findMin ( arr , n ) )\n", "python_code_tokenized": "def findMin ( arr , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 ] * ( m + 2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , m + 2 ) : NEW_LINE INDENT j = i NEW_LINE cnt = 0 NEW_LINE while ( j <= m ) : NEW_LINE INDENT cnt += freq [ j ] NEW_LINE j += i NEW_LINE DEDENT if ( not cnt ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return m + 1 NEW_LINE DEDENT arr = [ 2 , 12 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMin ( arr , n ) ) NEW_LINE"}
{"id": "aizu_p00235_A", "sol": 0, "python_code": "while 1 :\n    N = int ( input ( ) )\n    if N == 0 : break\n    R = [ [ 0 for i in range ( N + 1 ) ] for i in range ( N + 1 ) ]\n    def dfs_max ( cur , pre ) :\n        _max = - R [ cur ] [ pre ]\n        for i in range ( N + 1 ) :\n            if R [ cur ] [ i ] > 0 and i != pre :\n                _max = max ( _max , dfs_max ( i , cur ) + R [ cur ] [ i ] )\n        return _max\n    total = 0\n    for i in range ( N - 1 ) :\n        a , b , t = list ( map ( int , input ( ).split ( ) ) )\n        R [ a ] [ b ] = t\n        R [ b ] [ a ] = t\n        total += ( t * 2 )\n    for i in range ( 2 , N + 1 ) :\n        spam = [ x for x in R [ i ] if x > 0 ]\n        if ( len ( spam ) <= 1 ) :\n            total -= ( spam [ 0 ] * 2 )\n    print ( ( total - dfs_max ( 1 , 0 ) ) )\n", "python_code_tokenized": "while 1 : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : break NEW_LINE R = [ [ 0 for i in range ( N + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE def dfs_max ( cur , pre ) : NEW_LINE INDENT _max = - R [ cur ] [ pre ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if R [ cur ] [ i ] > 0 and i != pre : NEW_LINE INDENT _max = max ( _max , dfs_max ( i , cur ) + R [ cur ] [ i ] ) NEW_LINE DEDENT DEDENT return _max NEW_LINE DEDENT total = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT a , b , t = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE R [ a ] [ b ] = t NEW_LINE R [ b ] [ a ] = t NEW_LINE total += ( t * 2 ) NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT spam = [ x for x in R [ i ] if x > 0 ] NEW_LINE if ( len ( spam ) <= 1 ) : NEW_LINE INDENT total -= ( spam [ 0 ] * 2 ) NEW_LINE DEDENT DEDENT print ( ( total - dfs_max ( 1 , 0 ) ) ) NEW_LINE DEDENT"}
{"id": "leetcode_443_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def compress ( self , chars ) :\n        anchor = write = 0\n        for read , c in enumerate ( chars ) :\n            if read + 1 == len ( chars ) or chars [ read + 1 ] != c :\n                chars [ write ] = chars [ anchor ]\n                write += 1\n                if read > anchor :\n                    for digit in str ( read - anchor + 1 ) :\n                        chars [ write ] = digit\n                        write += 1\n                anchor = read + 1\n        return write\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def compress ( self , chars ) : NEW_LINE INDENT anchor = write = 0 NEW_LINE for read , c in enumerate ( chars ) : NEW_LINE INDENT if read + 1 == len ( chars ) or chars [ read + 1 ] != c : NEW_LINE INDENT chars [ write ] = chars [ anchor ] NEW_LINE write += 1 NEW_LINE if read > anchor : NEW_LINE INDENT for digit in str ( read - anchor + 1 ) : NEW_LINE INDENT chars [ write ] = digit NEW_LINE write += 1 NEW_LINE DEDENT DEDENT anchor = read + 1 NEW_LINE DEDENT DEDENT return write NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_5236_A", "sol": 0, "python_code": "def fillWithFreq ( arr , n ) :\n    temp = [ 0 for i in range ( n ) ]\n    for i in range ( n ) :\n        temp [ arr [ i ] ] += 1\n    for i in range ( n ) :\n        arr [ i ] = temp [ i ]\narr = [ 5 , 2 , 3 , 4 , 5 , 5 , 4 , 5 , 6 , 7 ]\nn = len ( arr )\nfillWithFreq ( arr , n )\nfor i in range ( n ) :\n    print ( arr [ i ] , end = \" \" )\n", "python_code_tokenized": "def fillWithFreq ( arr , n ) : NEW_LINE INDENT temp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT arr = [ 5 , 2 , 3 , 4 , 5 , 5 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE fillWithFreq ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_46_A", "sol": 0, "python_code": "def getCount ( l , r , p ) :\n    cnt = 0 ;\n    val = p ;\n    while ( True ) :\n        a = r // val ;\n        b = ( l - 1 ) // val ;\n        val *= p ;\n        if ( a - b ) :\n            cnt += ( a - b ) ;\n        else :\n            break ;\n    return int ( cnt ) ;\nl = 2 ;\nr = 8 ;\np = 2 ;\nprint ( getCount ( l , r , p ) ) ;\n", "python_code_tokenized": "def getCount ( l , r , p ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE val = p ; NEW_LINE while ( True ) : NEW_LINE INDENT a = r // val ; NEW_LINE b = ( l - 1 ) // val ; NEW_LINE val *= p ; NEW_LINE if ( a - b ) : NEW_LINE INDENT cnt += ( a - b ) ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return int ( cnt ) ; NEW_LINE DEDENT l = 2 ; NEW_LINE r = 8 ; NEW_LINE p = 2 ; NEW_LINE print ( getCount ( l , r , p ) ) ; NEW_LINE"}
{"id": "aizu_p00448_A", "sol": 0, "python_code": "def solve ( ) :\n    import sys\n    input_lines = sys.stdin.readlines ( )\n    while True :\n        R , C = map ( int , input_lines [ 0 ].split ( ) )\n        if R == 0 :\n            break\n        rows = map ( lambda x : x.rstrip ( ).replace ( '' , '' ) , input_lines [ 1 : R + 1 ] )\n        cols = [ int ( ''.join ( t_c ) , base = 2 ) for t_c in zip ( * rows ) ]\n        ans = [ ]\n        b = 2 ** R\n        flip_check = [ True ] * ( b )\n        for m in range ( b ) :\n            if flip_check [ m ] :\n                flip_check [ ~ m ] = False\n                shipment = 0\n                for s in cols :\n                    bit_cnt = bin ( m ^ s ).count ( '1' )\n                    shipment += max ( bit_cnt , R - bit_cnt )\n                ans.append ( shipment )\n        print ( max ( ans ) )\n        del input_lines [ : R + 1 ]\nsolve ( )\n", "python_code_tokenized": "def solve ( ) : NEW_LINE INDENT import sys NEW_LINE input_lines = sys . stdin . readlines ( ) NEW_LINE while True : NEW_LINE INDENT R , C = map ( int , input_lines [ 0 ] . split ( ) ) NEW_LINE if R == 0 : NEW_LINE INDENT break NEW_LINE DEDENT rows = map ( lambda x : x . rstrip ( ) . replace ( ' \u2581 ' , ' ' ) , input_lines [ 1 : R + 1 ] ) NEW_LINE cols = [ int ( ' ' . join ( t_c ) , base = 2 ) for t_c in zip ( * rows ) ] NEW_LINE ans = [ ] NEW_LINE b = 2 ** R NEW_LINE flip_check = [ True ] * ( b ) NEW_LINE for m in range ( b ) : NEW_LINE INDENT if flip_check [ m ] : NEW_LINE INDENT flip_check [ ~ m ] = False NEW_LINE shipment = 0 NEW_LINE for s in cols : NEW_LINE INDENT bit_cnt = bin ( m ^ s ) . count ( '1' ) NEW_LINE shipment += max ( bit_cnt , R - bit_cnt ) NEW_LINE DEDENT ans . append ( shipment ) NEW_LINE DEDENT DEDENT print ( max ( ans ) ) NEW_LINE del input_lines [ : R + 1 ] NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE"}
{"id": "geeksforgeeks_1729_A", "sol": 0, "python_code": "def centered_heptagonal_num ( n ) :\n    return ( 7 * n * n - 7 * n + 2 ) // 2\nn = 5\nprint ( \"%sth Centered heptagonal number : \" % n , centered_heptagonal_num ( n ) )\n", "python_code_tokenized": "def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) // 2 NEW_LINE DEDENT n = 5 NEW_LINE print ( \" % sth \u2581 Centered \u2581 heptagonal \u2581 number \u2581 : \u2581 \" % n , centered_heptagonal_num ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_175_A", "sol": 0, "python_code": "def difference ( M , N ) :\n    return M + N\nif __name__ == '__main__' :\n    M = 999999999\n    N = 1000000000\n    print ( difference ( M , N ) )\n", "python_code_tokenized": "def difference ( M , N ) : NEW_LINE INDENT return M + N NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = 999999999 NEW_LINE N = 1000000000 NEW_LINE print ( difference ( M , N ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1726_A", "sol": 0, "python_code": "import io , os\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\ndef main ( t ) :\n    n = int ( input ( ) )\n    arr = list ( map ( int , input ( ).split ( ) ) )\n    if n == 1 :\n        print ( 0 )\n        return\n    num1 = arr [ n - 1 ] - min ( arr [ : n - 1 ] )\n    num2 = max ( arr [ 1 : ] ) - arr [ 0 ]\n    num3 = max ( [ arr [ i ] - arr [ i + 1 ] for i in range ( n - 1 ) ] )\n    print ( max ( num1 , num2 , num3 ) )\nT = int ( input ( ) )\nt = 1\nwhile t <= T :\n    main ( t )\n    t += 1\n", "python_code_tokenized": "import io , os NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE def main ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT num1 = arr [ n - 1 ] - min ( arr [ : n - 1 ] ) NEW_LINE num2 = max ( arr [ 1 : ] ) - arr [ 0 ] NEW_LINE num3 = max ( [ arr [ i ] - arr [ i + 1 ] for i in range ( n - 1 ) ] ) NEW_LINE print ( max ( num1 , num2 , num3 ) ) NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE t = 1 NEW_LINE while t <= T : NEW_LINE INDENT main ( t ) NEW_LINE t += 1 NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2503_A", "sol": 0, "python_code": "def findMinSwaps ( s , k ) :\n    ans = 0 ;\n    c_one = 0 ; c_zero = 0 ;\n    for i in range ( len ( s ) - 1 , - 1 , - 1 ) :\n        if ( s [ i ] == '1' ) :\n            c_one += 1 ;\n        if ( s [ i ] == '0' ) :\n            c_zero += 1 ;\n            ans += c_one ;\n        if ( c_zero == k ) :\n            break ;\n    if ( c_zero < k ) :\n        return - 1 ;\n    return ans ;\nif __name__ == \"__main__\" :\n    s = \"100111\" ;\n    k = 2 ;\n    print ( findMinSwaps ( s , k ) ) ;\n", "python_code_tokenized": "def findMinSwaps ( s , k ) : NEW_LINE INDENT ans = 0 ; NEW_LINE c_one = 0 ; c_zero = 0 ; NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT c_one += 1 ; NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c_zero += 1 ; NEW_LINE ans += c_one ; NEW_LINE DEDENT if ( c_zero == k ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( c_zero < k ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"100111\" ; NEW_LINE k = 2 ; NEW_LINE print ( findMinSwaps ( s , k ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1699_A", "sol": 0, "python_code": "for tc in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    if ( n % 2 == 0 ) :\n        print ( n // 2 , 0 , 0 )\n    else :\n        print ( - 1 )\n", "python_code_tokenized": "for tc in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT print ( n // 2 , 0 , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1081_A", "sol": 0, "python_code": "akhi = int ( input ( ) )\nif ( akhi == 2 ) :\n    print ( akhi )\nelse :\n    print ( 1 )\n", "python_code_tokenized": "akhi = int ( input ( ) ) NEW_LINE if ( akhi == 2 ) : NEW_LINE INDENT print ( akhi ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2653_A", "sol": 0, "python_code": "MAX = 26 ;\ndef minOperation ( str , len ) :\n    first , last = [ 0 ] * MAX , [ 0 ] * MAX ;\n    for i in range ( MAX ) :\n        first [ i ] = - 1 ;\n        last [ i ] = - 1 ;\n    for i in range ( len ) :\n        index = ( ord ( str [ i ] ) - ord ( 'a' ) ) ;\n        if ( first [ index ] == - 1 ) :\n            first [ index ] = i ;\n        last [ index ] = i ;\n    minOp = - 1 ;\n    for i in range ( MAX ) :\n        if ( first [ i ] == - 1 or first [ i ] == last [ i ] ) :\n            continue ;\n        cnt = len - ( last [ i ] - first [ i ] + 1 ) ;\n        if ( minOp == - 1 or cnt < minOp ) :\n            minOp = cnt ;\n    return minOp ;\nstr = \"abcda\" ;\nlen = len ( str ) ;\nprint ( minOperation ( str , len ) ) ;\n", "python_code_tokenized": "MAX = 26 ; NEW_LINE def minOperation ( str , len ) : NEW_LINE INDENT first , last = [ 0 ] * MAX , [ 0 ] * MAX ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT first [ i ] = - 1 ; NEW_LINE last [ i ] = - 1 ; NEW_LINE DEDENT for i in range ( len ) : NEW_LINE INDENT index = ( ord ( str [ i ] ) - ord ( ' a ' ) ) ; NEW_LINE if ( first [ index ] == - 1 ) : NEW_LINE INDENT first [ index ] = i ; NEW_LINE DEDENT last [ index ] = i ; NEW_LINE DEDENT minOp = - 1 ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( first [ i ] == - 1 or first [ i ] == last [ i ] ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT cnt = len - ( last [ i ] - first [ i ] + 1 ) ; NEW_LINE if ( minOp == - 1 or cnt < minOp ) : NEW_LINE INDENT minOp = cnt ; NEW_LINE DEDENT DEDENT return minOp ; NEW_LINE DEDENT str = \" abcda \" ; NEW_LINE len = len ( str ) ; NEW_LINE print ( minOperation ( str , len ) ) ; NEW_LINE"}
{"id": "codeforces_1678_A", "sol": 0, "python_code": "t = int ( input ( ) )\nwhile ( t > 0 ) :\n    c = 0\n    n = int ( input ( ) )\n    li = list ( map ( int , input ( ).split ( ) ) )\n    l = li.count ( 0 )\n    if ( l > 0 ) :\n        print ( len ( li ) - l )\n    elif ( len ( li ) != len ( set ( li ) ) ) :\n        print ( len ( li ) )\n    else :\n        print ( len ( li ) + 1 )\n    t -= 1\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE while ( t > 0 ) : NEW_LINE INDENT c = 0 NEW_LINE n = int ( input ( ) ) NEW_LINE li = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = li . count ( 0 ) NEW_LINE if ( l > 0 ) : NEW_LINE INDENT print ( len ( li ) - l ) NEW_LINE DEDENT elif ( len ( li ) != len ( set ( li ) ) ) : NEW_LINE INDENT print ( len ( li ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( len ( li ) + 1 ) NEW_LINE DEDENT t -= 1 NEW_LINE DEDENT"}
{"id": "geeksforgeeks_961_A", "sol": 0, "python_code": "def minimumCostOfBreaking ( X , Y , m , n ) :\n    res = 0\n    X.sort ( reverse = True )\n    Y.sort ( reverse = True )\n    hzntl = 1 ; vert = 1\n    i = 0 ; j = 0\n    while ( i < m and j < n ) :\n        if ( X [ i ] > Y [ j ] ) :\n            res += X [ i ] * vert\n            hzntl += 1\n            i += 1\n        else :\n            res += Y [ j ] * hzntl\n            vert += 1\n            j += 1\n    total = 0\n    while ( i < m ) :\n        total += X [ i ]\n        i += 1\n    res += total * vert\n    total = 0\n    while ( j < n ) :\n        total += Y [ j ]\n        j += 1\n    res += total * hzntl\n    return res\nm = 6 ; n = 4\nX = [ 2 , 1 , 3 , 1 , 4 ]\nY = [ 4 , 1 , 2 ]\nprint ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) )\n", "python_code_tokenized": "def minimumCostOfBreaking ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE X . sort ( reverse = True ) NEW_LINE Y . sort ( reverse = True ) NEW_LINE hzntl = 1 ; vert = 1 NEW_LINE i = 0 ; j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( X [ i ] > Y [ j ] ) : NEW_LINE INDENT res += X [ i ] * vert NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += Y [ j ] * hzntl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while ( i < m ) : NEW_LINE INDENT total += X [ i ] NEW_LINE i += 1 NEW_LINE DEDENT res += total * vert NEW_LINE total = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT total += Y [ j ] NEW_LINE j += 1 NEW_LINE DEDENT res += total * hzntl NEW_LINE return res NEW_LINE DEDENT m = 6 ; n = 4 NEW_LINE X = [ 2 , 1 , 3 , 1 , 4 ] NEW_LINE Y = [ 4 , 1 , 2 ] NEW_LINE print ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ) NEW_LINE"}
{"id": "projecteuler_p160_A", "sol": 0, "python_code": "def compute ( ) :\n    ans = factorial_suffix ( 10 ** 12 )\n    return str ( ans )\ndef factorial_suffix ( n ) :\n    twos = count_factors ( n , 2 ) - count_factors ( n , 5 )\n    if twos >= 2505 :\n        twos = ( twos - 5 ) % 2500 + 5\n    return factorialish ( n ) * pow ( 2 , twos , 100000 ) % 100000\ndef factorialish ( n ) :\n    return even_factorialish ( n ) * odd_factorialish ( n ) % 100000\ndef even_factorialish ( n ) :\n    if n == 0 :\n        return 1\n    else :\n        return factorialish ( n // 2 )\ndef odd_factorialish ( n ) :\n    if n == 0 :\n        return 1\n    else :\n        return odd_factorialish ( n // 5 ) * factorial_coprime ( n ) % 100000\ndef factorial_coprime ( n ) :\n    n %= 100000\n    product = 1\n    for i in range ( 1 , n + 1 ) :\n        if i % 2 != 0 and i % 5 != 0 :\n            product = i * product % 100000\n    return product\ndef count_factors ( end , n ) :\n    if end == 0 :\n        return 0\n    else :\n        return end // n + count_factors ( end // n , n )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT ans = factorial_suffix ( 10 ** 12 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def factorial_suffix ( n ) : NEW_LINE INDENT twos = count_factors ( n , 2 ) - count_factors ( n , 5 ) NEW_LINE if twos >= 2505 : NEW_LINE INDENT twos = ( twos - 5 ) % 2500 + 5 NEW_LINE DEDENT return factorialish ( n ) * pow ( 2 , twos , 100000 ) % 100000 NEW_LINE DEDENT def factorialish ( n ) : NEW_LINE INDENT return even_factorialish ( n ) * odd_factorialish ( n ) % 100000 NEW_LINE DEDENT def even_factorialish ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return factorialish ( n // 2 ) NEW_LINE DEDENT DEDENT def odd_factorialish ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return odd_factorialish ( n // 5 ) * factorial_coprime ( n ) % 100000 NEW_LINE DEDENT DEDENT def factorial_coprime ( n ) : NEW_LINE INDENT n %= 100000 NEW_LINE product = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 != 0 and i % 5 != 0 : NEW_LINE INDENT product = i * product % 100000 NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT def count_factors ( end , n ) : NEW_LINE INDENT if end == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return end // n + count_factors ( end // n , n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ARC064_B", "sol": 0, "python_code": "s = input ( ).strip ( )\nc1 , c2 = s [ 0 ] , s [ - 1 ]\nif c1 == c2 :\n    if len ( s ) % 2 :\n        print ( 'Second' )\n    else :\n        print ( 'First' )\nelse :\n    if len ( s ) % 2 :\n        print ( 'First' )\n    else :\n        print ( 'Second' )\n", "python_code_tokenized": "s = input ( ) . strip ( ) NEW_LINE c1 , c2 = s [ 0 ] , s [ - 1 ] NEW_LINE if c1 == c2 : NEW_LINE INDENT if len ( s ) % 2 : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if len ( s ) % 2 : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1676_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    arr = list ( map ( int , input ( ).split ( ) ) )\n    k = min ( arr )\n    if n == 1 :\n        print ( 0 )\n    else :\n        res = 0\n        for i in arr :\n            res += ( i - k )\n        print ( res )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = min ( arr ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res = 0 NEW_LINE for i in arr : NEW_LINE INDENT res += ( i - k ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_95_A", "sol": 0, "python_code": "pya = int ( input ( ) )\narre = [ ]\nwhile pya :\n    pya -= 1\n    arre.append ( input ( ).lower ( ) )\noString = input ( )\nlowString = oString.lower ( )\nletter1 = input ( ) [ 0 ].lower ( )\nletter2 = 'a' if letter1.lower ( ) != 'a' else 'b'\nvalid = [ 0 for i in range ( len ( oString ) ) ]\nsetcito = set ( )\nfor x in arre :\n    if lowString.find ( x ) >= 0 :\n        wat = 0\n        while True :\n            index = lowString.find ( x , wat )\n            if index < 0 :\n                break\n            for i in range ( index , index + len ( x ) ) :\n                setcito.add ( i )\n            wat = index + 1\noString = list ( oString )\nfor i in setcito :\n    letter = letter1 if lowString [ i ] != letter1 else letter2\n    oString [ i ] = letter if oString [ i ].islower ( ) else letter.upper ( )\nfor x in oString :\n    print ( x , end = \"\" )\nprint ( )\n", "python_code_tokenized": "pya = int ( input ( ) ) NEW_LINE arre = [ ] NEW_LINE while pya : NEW_LINE INDENT pya -= 1 NEW_LINE arre . append ( input ( ) . lower ( ) ) NEW_LINE DEDENT oString = input ( ) NEW_LINE lowString = oString . lower ( ) NEW_LINE letter1 = input ( ) [ 0 ] . lower ( ) NEW_LINE letter2 = ' a ' if letter1 . lower ( ) != ' a ' else ' b ' NEW_LINE valid = [ 0 for i in range ( len ( oString ) ) ] NEW_LINE setcito = set ( ) NEW_LINE for x in arre : NEW_LINE INDENT if lowString . find ( x ) >= 0 : NEW_LINE INDENT wat = 0 NEW_LINE while True : NEW_LINE INDENT index = lowString . find ( x , wat ) NEW_LINE if index < 0 : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( index , index + len ( x ) ) : NEW_LINE INDENT setcito . add ( i ) NEW_LINE DEDENT wat = index + 1 NEW_LINE DEDENT DEDENT DEDENT oString = list ( oString ) NEW_LINE for i in setcito : NEW_LINE INDENT letter = letter1 if lowString [ i ] != letter1 else letter2 NEW_LINE oString [ i ] = letter if oString [ i ] . islower ( ) else letter . upper ( ) NEW_LINE DEDENT for x in oString : NEW_LINE INDENT print ( x , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE"}
{"id": "codeforces_610_A", "sol": 0, "python_code": "n = int ( input ( ) )\nif n % 2 == 1 or n <= 4 :\n    print ( 0 )\nelse :\n    if n % 4 == 0 :\n        n = n / 2\n        if n / 2 - 1 < 1 :\n            print ( 1 )\n        else :\n            h = int ( ( n / 2 - 1 ) )\n            print ( h )\n    else :\n        print ( int ( n / 4 ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE if n % 2 == 1 or n <= 4 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 4 == 0 : NEW_LINE INDENT n = n / 2 NEW_LINE if n / 2 - 1 < 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT h = int ( ( n / 2 - 1 ) ) NEW_LINE print ( h ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( int ( n / 4 ) ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00754_A", "sol": 0, "python_code": "while True :\n    s = input ( )\n    if s [ 0 ] == '.' : break\n    r = [ ]\n    f = False\n    for c in s :\n        if c == '(' or c == '[' :\n            r.append ( c )\n        elif c == ')' :\n            if not r or r.pop ( ) != '(' :\n                print ( \"no\" )\n                break\n        elif c == ']' :\n            if not r or r.pop ( ) != '[' :\n                print ( \"no\" )\n                break\n    else :\n        print ( \"yes\" if not r else \"no\" )\n", "python_code_tokenized": "while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ 0 ] == ' . ' : break NEW_LINE r = [ ] NEW_LINE f = False NEW_LINE for c in s : NEW_LINE INDENT if c == ' ( ' or c == ' [ ' : NEW_LINE INDENT r . append ( c ) NEW_LINE DEDENT elif c == ' ) ' : NEW_LINE INDENT if not r or r . pop ( ) != ' ( ' : NEW_LINE INDENT print ( \" no \" ) NEW_LINE break NEW_LINE DEDENT DEDENT elif c == ' ] ' : NEW_LINE INDENT if not r or r . pop ( ) != ' [ ' : NEW_LINE INDENT print ( \" no \" ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( \" yes \" if not r else \" no \" ) NEW_LINE DEDENT DEDENT"}
{"id": "projecteuler_p053_A", "sol": 0, "python_code": "import eulerlib\ndef compute ( ) :\n    ans = sum ( 1 for n in range ( 1 , 101 ) for k in range ( 0 , n + 1 ) if eulerlib.binomial ( n , k ) > 1000000 )\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for n in range ( 1 , 101 ) for k in range ( 0 , n + 1 ) if eulerlib . binomial ( n , k ) > 1000000 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_287_B", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\ndef f ( m ) :\n    global n\n    global k\n    total = m * k - ( m * ( m - 1 ) ) // 2\n    total -= ( m - 1 )\n    return total >= n\nif ( ( k * ( k + 1 ) ) // 2 - ( k - 1 ) < n ) :\n    print ( - 1 )\nelif n == 1 :\n    print ( 0 )\nelse :\n    r = k\n    l = 0\n    while ( r > ( l + 1 ) ) :\n        m = ( r + l ) // 2\n        if ( f ( m ) == 0 ) :\n            l = m\n        else :\n            r = m\n    print ( r )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE def f ( m ) : NEW_LINE INDENT global n NEW_LINE global k NEW_LINE total = m * k - ( m * ( m - 1 ) ) // 2 NEW_LINE total -= ( m - 1 ) NEW_LINE return total >= n NEW_LINE DEDENT if ( ( k * ( k + 1 ) ) // 2 - ( k - 1 ) < n ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT r = k NEW_LINE l = 0 NEW_LINE while ( r > ( l + 1 ) ) : NEW_LINE INDENT m = ( r + l ) // 2 NEW_LINE if ( f ( m ) == 0 ) : NEW_LINE INDENT l = m NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT print ( r ) NEW_LINE DEDENT"}
{"id": "aizu_p01932_A", "sol": 0, "python_code": "n , d = map ( int , input ( ).split ( ) )\nans = t0 = f0 = num = 0\nfor i in range ( n ) :\n    t , f = map ( int , input ( ).split ( ) )\n    f -= 1\n    df = f - f0\n    if df < 0 : df = - df\n    dt = t - t0\n    if dt < df : ans = - 1 ; break\n    if dt >= f0 + f :\n        ans += num * f0\n        num = 0\n    else :\n        if num + 1 > d : ans = - 1 ; break\n        ans += num * dt\n    f0 , t0 = f , t\n    num += 1\nprint ( - 1 if ans < 0 else ans + num * f0 )\n", "python_code_tokenized": "n , d = map ( int , input ( ) . split ( ) ) NEW_LINE ans = t0 = f0 = num = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT t , f = map ( int , input ( ) . split ( ) ) NEW_LINE f -= 1 NEW_LINE df = f - f0 NEW_LINE if df < 0 : df = - df NEW_LINE dt = t - t0 NEW_LINE if dt < df : ans = - 1 ; break NEW_LINE if dt >= f0 + f : NEW_LINE INDENT ans += num * f0 NEW_LINE num = 0 NEW_LINE DEDENT else : NEW_LINE INDENT if num + 1 > d : ans = - 1 ; break NEW_LINE ans += num * dt NEW_LINE DEDENT f0 , t0 = f , t NEW_LINE num += 1 NEW_LINE DEDENT print ( - 1 if ans < 0 else ans + num * f0 ) NEW_LINE"}
{"id": "codeforces_538_B", "sol": 0, "python_code": "N = int ( input ( ) )\narr = [ ]\nwhile N > 0 :\n    n = N\n    m = 0\n    p = 1\n    while int ( n ) != 0 :\n        if n % 10 : m += p\n        n = n // 10\n        p = p * 10\n    arr.append ( m )\n    N -= m\nprint ( len ( arr ) )\nfor i in arr :\n    print ( i , end = \" \" )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE arr = [ ] NEW_LINE while N > 0 : NEW_LINE INDENT n = N NEW_LINE m = 0 NEW_LINE p = 1 NEW_LINE while int ( n ) != 0 : NEW_LINE INDENT if n % 10 : m += p NEW_LINE n = n // 10 NEW_LINE p = p * 10 NEW_LINE DEDENT arr . append ( m ) NEW_LINE N -= m NEW_LINE DEDENT print ( len ( arr ) ) NEW_LINE for i in arr : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1428_A", "sol": 0, "python_code": "def evenFibSum ( limit ) :\n    if ( limit < 2 ) :\n        return 0\n    ef1 = 0\n    ef2 = 2\n    sm = ef1 + ef2\n    while ( ef2 <= limit ) :\n        ef3 = 4 * ef2 + ef1\n        if ( ef3 > limit ) :\n            break\n        ef1 = ef2\n        ef2 = ef3\n        sm = sm + ef2\n    return sm\nlimit = 400\nprint ( evenFibSum ( limit ) )\n", "python_code_tokenized": "def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef1 = 0 NEW_LINE ef2 = 2 NEW_LINE sm = ef1 + ef2 NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef3 NEW_LINE sm = sm + ef2 NEW_LINE DEDENT return sm NEW_LINE DEDENT limit = 400 NEW_LINE print ( evenFibSum ( limit ) ) NEW_LINE"}
{"id": "codeforces_902_A", "sol": 0, "python_code": "array = input ( ).split ( )\na_teleports = int ( array [ 0 ] )\nlocation = int ( array [ 1 ] )\npig = 0\nfor _ in range ( a_teleports ) :\n    information = input ( ).split ( )\n    teleport = int ( information [ 0 ] )\n    range = int ( information [ 1 ] )\n    if pig >= teleport and range > pig :\n        pig = range\n    elif pig >= teleport and range <= pig :\n        pig = pig\n    else : break\nif pig >= location :\n    print ( \"YES\" )\nelse : print ( \"NO\" )\n", "python_code_tokenized": "array = input ( ) . split ( ) NEW_LINE a_teleports = int ( array [ 0 ] ) NEW_LINE location = int ( array [ 1 ] ) NEW_LINE pig = 0 NEW_LINE for _ in range ( a_teleports ) : NEW_LINE INDENT information = input ( ) . split ( ) NEW_LINE teleport = int ( information [ 0 ] ) NEW_LINE range = int ( information [ 1 ] ) NEW_LINE if pig >= teleport and range > pig : NEW_LINE INDENT pig = range NEW_LINE DEDENT elif pig >= teleport and range <= pig : NEW_LINE INDENT pig = pig NEW_LINE DEDENT else : break NEW_LINE DEDENT if pig >= location : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : print ( \" NO \" ) NEW_LINE"}
{"id": "aizu_p00044_A", "sol": 0, "python_code": "from itertools import chain\nfrom bisect import bisect_left\nmax_n = 50022\nprimes = { 2 , 3 } | { m for n in ( 5 , 7 ) for m in range ( n , max_n , 6 ) }\ndu = primes.difference_update\nfor n in chain ( range ( 5 , max_n , 6 ) , range ( 7 , max_n , 6 ) ) :\n    if n in primes :\n        du ( range ( n * 3 , max_n , n * 2 ) )\nprimes = tuple ( primes )\ntry :\n    while True :\n        n = int ( input ( ) )\n        i = bisect_left ( primes , n )\n        print ( primes [ i - 1 ] , primes [ i + ( n == primes [ i ] ) ] )\nexcept EOFError :\n    exit ( )\n", "python_code_tokenized": "from itertools import chain NEW_LINE from bisect import bisect_left NEW_LINE max_n = 50022 NEW_LINE primes = { 2 , 3 } | { m for n in ( 5 , 7 ) for m in range ( n , max_n , 6 ) } NEW_LINE du = primes . difference_update NEW_LINE for n in chain ( range ( 5 , max_n , 6 ) , range ( 7 , max_n , 6 ) ) : NEW_LINE INDENT if n in primes : NEW_LINE INDENT du ( range ( n * 3 , max_n , n * 2 ) ) NEW_LINE DEDENT DEDENT primes = tuple ( primes ) NEW_LINE try : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE i = bisect_left ( primes , n ) NEW_LINE print ( primes [ i - 1 ] , primes [ i + ( n == primes [ i ] ) ] ) NEW_LINE DEDENT DEDENT except EOFError : NEW_LINE INDENT exit ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2088_A", "sol": 0, "python_code": "ans = [ ]\ndef countSieve ( arr , n ) :\n    MAX = max ( arr )\n    global ans\n    ans = [ 0 ] * ( MAX + 1 )\n    cnt = [ 0 ] * ( MAX + 1 )\n    for i in range ( n ) :\n        cnt [ arr [ i ] ] += 1\n    for i in range ( 1 , MAX + 1 ) :\n        for j in range ( i , MAX + 1 , i ) :\n            ans [ i ] += cnt [ j ]\ndef countMultiples ( k ) :\n    return ( ans [ k ] )\nif __name__ == \"__main__\" :\n    arr = [ 2 , 4 , 9 , 15 , 21 , 20 ]\n    n = len ( arr )\n    countSieve ( arr , n )\n    k = 2\n    print ( countMultiples ( 2 ) )\n    k = 3\n    print ( countMultiples ( 3 ) )\n    k = 5\n    print ( countMultiples ( 5 ) )\n", "python_code_tokenized": "ans = [ ] NEW_LINE def countSieve ( arr , n ) : NEW_LINE INDENT MAX = max ( arr ) NEW_LINE global ans NEW_LINE ans = [ 0 ] * ( MAX + 1 ) NEW_LINE cnt = [ 0 ] * ( MAX + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT for j in range ( i , MAX + 1 , i ) : NEW_LINE INDENT ans [ i ] += cnt [ j ] NEW_LINE DEDENT DEDENT DEDENT def countMultiples ( k ) : NEW_LINE INDENT return ( ans [ k ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 9 , 15 , 21 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE countSieve ( arr , n ) NEW_LINE k = 2 NEW_LINE print ( countMultiples ( 2 ) ) NEW_LINE k = 3 NEW_LINE print ( countMultiples ( 3 ) ) NEW_LINE k = 5 NEW_LINE print ( countMultiples ( 5 ) ) NEW_LINE DEDENT"}
{"id": "aizu_p01545_A", "sol": 0, "python_code": "class SegmentTree :\n    def _max ( self , a , b ) :\n        if a < b :\n            return b\n        else :\n            return a\n    def __init__ ( self , n ) :\n        self.N = 1\n        while ( self.N < n ) :\n            self.N *= 2\n        self.seg = [ 0 ] * ( self.N * 2 - 1 )\n    def max_update ( self , k , a ) :\n        k += self.N - 1\n        self.seg [ k ] = a\n        while ( 0 < k ) :\n            k = ( k - 1 ) // 2 ;\n            self.seg [ k ] = self._max ( self.seg [ 2 * k + 1 ] , self.seg [ 2 * k + 2 ] )\n    def _max_query ( self , a , b , k , l , r ) :\n        if r <= a or b <= l :\n            return 0\n        if a <= l and r <= b :\n            return self.seg [ k ]\n        else :\n            vl = self._max_query ( a , b , k * 2 + 1 , l , ( l + r ) // 2 )\n            vr = self._max_query ( a , b , k * 2 + 2 , ( l + r ) // 2 , r )\n            return self._max ( vl , vr )\n    def max_query ( self , a , b ) :\n        return self._max_query ( a , b , 0 , 0 , self.N )\nn = int ( input ( ) )\nX = list ( map ( int , input ( ).split ( ) ) )\nst = SegmentTree ( n + 1 )\nfor x in X :\n    st.max_update ( x , st.max_query ( 0 , x ) + x )\nprint ( ( n * ( n + 1 ) ) // 2 - st.max_query ( 0 , n + 1 ) )\n", "python_code_tokenized": "class SegmentTree : NEW_LINE INDENT def _max ( self , a , b ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT def __init__ ( self , n ) : NEW_LINE INDENT self . N = 1 NEW_LINE while ( self . N < n ) : NEW_LINE INDENT self . N *= 2 NEW_LINE DEDENT self . seg = [ 0 ] * ( self . N * 2 - 1 ) NEW_LINE DEDENT def max_update ( self , k , a ) : NEW_LINE INDENT k += self . N - 1 NEW_LINE self . seg [ k ] = a NEW_LINE while ( 0 < k ) : NEW_LINE INDENT k = ( k - 1 ) // 2 ; NEW_LINE self . seg [ k ] = self . _max ( self . seg [ 2 * k + 1 ] , self . seg [ 2 * k + 2 ] ) NEW_LINE DEDENT DEDENT def _max_query ( self , a , b , k , l , r ) : NEW_LINE INDENT if r <= a or b <= l : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a <= l and r <= b : NEW_LINE INDENT return self . seg [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT vl = self . _max_query ( a , b , k * 2 + 1 , l , ( l + r ) // 2 ) NEW_LINE vr = self . _max_query ( a , b , k * 2 + 2 , ( l + r ) // 2 , r ) NEW_LINE return self . _max ( vl , vr ) NEW_LINE DEDENT DEDENT def max_query ( self , a , b ) : NEW_LINE INDENT return self . _max_query ( a , b , 0 , 0 , self . N ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE st = SegmentTree ( n + 1 ) NEW_LINE for x in X : NEW_LINE INDENT st . max_update ( x , st . max_query ( 0 , x ) + x ) NEW_LINE DEDENT print ( ( n * ( n + 1 ) ) // 2 - st . max_query ( 0 , n + 1 ) ) NEW_LINE"}
{"id": "codeforces_1612_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n , a , b = list ( map ( int , input ( ).split ( ) ) )\n    k = n // 2\n    if b < k :\n        print ( \"-1\" )\n    elif b == k and a != ( k + 1 ) :\n        print ( \"-1\" )\n    elif b == k and a == ( k + 1 ) :\n        for i in range ( n - 1 , - 1 , - 1 ) :\n            print ( str ( i + 1 ) , end = ' ' )\n        print ( )\n    elif b > k and ( a > k ) :\n        print ( \"-1\" )\n    else :\n        for i in range ( n - b ) :\n            print ( str ( i + b + 1 ) , end = ' ' )\n        for i in range ( k + b - n ) :\n            print ( str ( i + a ) , end = ' ' )\n        for i in range ( a - 1 ) :\n            print ( str ( i + 1 ) , end = ' ' )\n        for i in range ( k + 1 - a ) :\n            print ( str ( b - i ) , end = ' ' )\n        print ( )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = n // 2 NEW_LINE if b < k : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT elif b == k and a != ( k + 1 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT elif b == k and a == ( k + 1 ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( str ( i + 1 ) , end = ' \u2581 ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT elif b > k and ( a > k ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n - b ) : NEW_LINE INDENT print ( str ( i + b + 1 ) , end = ' \u2581 ' ) NEW_LINE DEDENT for i in range ( k + b - n ) : NEW_LINE INDENT print ( str ( i + a ) , end = ' \u2581 ' ) NEW_LINE DEDENT for i in range ( a - 1 ) : NEW_LINE INDENT print ( str ( i + 1 ) , end = ' \u2581 ' ) NEW_LINE DEDENT for i in range ( k + 1 - a ) : NEW_LINE INDENT print ( str ( b - i ) , end = ' \u2581 ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC087_A", "sol": 0, "python_code": "from time import sleep\nx = int ( input ( ) )\na = int ( input ( ) )\nb = int ( input ( ) )\nans = ( x - a ) % b\nsleep ( a * 0.001 )\nprint ( ans )\n", "python_code_tokenized": "from time import sleep NEW_LINE x = int ( input ( ) ) NEW_LINE a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE ans = ( x - a ) % b NEW_LINE sleep ( a * 0.001 ) NEW_LINE print ( ans ) NEW_LINE"}
{"id": "codeforces_718_A", "sol": 0, "python_code": "n , t = map ( int , input ( ).split ( ) )\ns = input ( )\npp , ap = s.split ( '.' )\npp = list ( map ( int , pp ) )\nfor i , c in enumerate ( map ( int , ap ) ) :\n    if c >= 5 :\n        break\nt -= 1\nrnd = len ( ap )\nif c >= 5 :\n    rnd = i - 1\n    while t > 0 and rnd >= 0 and int ( ap [ rnd ] ) + 1 >= 5 :\n        rnd -= 1\n        t -= 1\nif rnd == - 1 :\n    i = len ( pp ) - 1\n    while i >= 0 :\n        pp [ i ] += 1\n        if pp [ i ] > 9 :\n            pp [ i ] -= 10\n            i -= 1\n        else :\n            break\n    if i < 0 :\n        pp.insert ( 0 , 1 )\nap = list ( map ( int , ap ) )\nif 0 <= rnd < len ( ap ) :\n    ap [ rnd ] += 1\nif rnd >= 0 :\n    print ( \"\".join ( map ( str , pp ) ) , \".\" , \"\".join ( map ( str , ap [ : rnd + 1 ] ) ) , sep = \"\" )\nelse :\n    print ( \"\".join ( map ( str , pp ) ) )\n", "python_code_tokenized": "n , t = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE pp , ap = s . split ( ' . ' ) NEW_LINE pp = list ( map ( int , pp ) ) NEW_LINE for i , c in enumerate ( map ( int , ap ) ) : NEW_LINE INDENT if c >= 5 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT t -= 1 NEW_LINE rnd = len ( ap ) NEW_LINE if c >= 5 : NEW_LINE INDENT rnd = i - 1 NEW_LINE while t > 0 and rnd >= 0 and int ( ap [ rnd ] ) + 1 >= 5 : NEW_LINE INDENT rnd -= 1 NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT if rnd == - 1 : NEW_LINE INDENT i = len ( pp ) - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT pp [ i ] += 1 NEW_LINE if pp [ i ] > 9 : NEW_LINE INDENT pp [ i ] -= 10 NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i < 0 : NEW_LINE INDENT pp . insert ( 0 , 1 ) NEW_LINE DEDENT DEDENT ap = list ( map ( int , ap ) ) NEW_LINE if 0 <= rnd < len ( ap ) : NEW_LINE INDENT ap [ rnd ] += 1 NEW_LINE DEDENT if rnd >= 0 : NEW_LINE INDENT print ( \" \" . join ( map ( str , pp ) ) , \" . \" , \" \" . join ( map ( str , ap [ : rnd + 1 ] ) ) , sep = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \" . join ( map ( str , pp ) ) ) NEW_LINE DEDENT"}
{"id": "codeforces_509_B", "sol": 0, "python_code": "from collections import defaultdict , deque\nfrom functools import lru_cache\nfrom heapq import heappush , heappop\nfrom typing import Counter\nfrom bisect import bisect_right , bisect_left\nimport math\nhpop = heappop\nhpush = heappush\ndef solution ( ) :\n    n , k = map ( int , input ( ).split ( ) )\n    arr = list ( map ( int , input ( ).split ( ) ) )\n    if ( max ( arr ) - min ( arr ) ) > k :\n        return print ( \"NO\" )\n    print ( \"YES\" )\n    mx = max ( arr )\n    model = [ i for i in range ( 1 , k + 1 ) ] * ( mx // k + 1 )\n    for val in arr :\n        print ( \" \".join ( map ( str , model [ : val ] ) ) )\ndef main ( ) :\n    t = 1\n    for _ in range ( t ) :\n        solution ( )\nmain ( )\n", "python_code_tokenized": "from collections import defaultdict , deque NEW_LINE from functools import lru_cache NEW_LINE from heapq import heappush , heappop NEW_LINE from typing import Counter NEW_LINE from bisect import bisect_right , bisect_left NEW_LINE import math NEW_LINE hpop = heappop NEW_LINE hpush = heappush NEW_LINE def solution ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ( max ( arr ) - min ( arr ) ) > k : NEW_LINE INDENT return print ( \" NO \" ) NEW_LINE DEDENT print ( \" YES \" ) NEW_LINE mx = max ( arr ) NEW_LINE model = [ i for i in range ( 1 , k + 1 ) ] * ( mx // k + 1 ) NEW_LINE for val in arr : NEW_LINE INDENT print ( \" \u2581 \" . join ( map ( str , model [ : val ] ) ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT t = 1 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT solution ( ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_4699_A", "sol": 0, "python_code": "def checkBisymmetric ( m , n ) :\n    for i in range ( 0 , n ) :\n        for j in range ( 0 , i ) :\n            if ( m [ i ] [ j ] != m [ j ] [ i ] ) :\n                return false\n    for i in range ( 0 , n ) :\n        for j in range ( 0 , n - i ) :\n            if ( m [ i ] [ j ] != m [ n - j - 1 ] [ n - i - 1 ] ) :\n                return False\n    return True ;\nn = 3 ;\nm = [ [ 1 , 2 , 3 ] , [ 2 , 5 , 2 ] , [ 3 , 2 , 1 ] ]\nif ( checkBisymmetric ( m , n ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def checkBisymmetric ( m , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ j ] [ i ] ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n - i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - j - 1 ] [ n - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT n = 3 ; NEW_LINE m = [ [ 1 , 2 , 3 ] , [ 2 , 5 , 2 ] , [ 3 , 2 , 1 ] ] NEW_LINE if ( checkBisymmetric ( m , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3689_A", "sol": 0, "python_code": "def cntSquares ( n ) :\n    squares = 0 ;\n    for i in range ( 1 , n + 1 ) :\n        squares += i ** 2 ;\n    return squares ;\nif __name__ == \"__main__\" :\n    n = 4 ;\n    print ( cntSquares ( 4 ) ) ;\n", "python_code_tokenized": "def cntSquares ( n ) : NEW_LINE INDENT squares = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT squares += i ** 2 ; NEW_LINE DEDENT return squares ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE print ( cntSquares ( 4 ) ) ; NEW_LINE DEDENT"}
{"id": "aizu_p00631_A", "sol": 0, "python_code": "while True :\n    n = int ( input ( ) )\n    if n == 0 : break\n    t = list ( map ( int , input ( ).split ( ) ) )\n    s = sum ( t )\n    ans = s >> 1\n    if ans in t :\n        print ( s - 2 * ans )\n        continue\n    a = [ v for v in t if v < ans ]\n    S , f , Q , qlen = set ( ) , True , [ 0 ] , 1\n    for v in a :\n        i , k = 0 , qlen\n        while k :\n            v2 = v + Q [ i ]\n            k , i = k - 1 , i + 1\n            if v2 == ans :\n                f = False\n                break\n            if v2 < ans and v2 not in S :\n                S.add ( v2 )\n                Q.append ( v2 )\n                qlen += 1\n    if f :\n        while True :\n            ans -= 1\n            if ans == 0 : break\n            if ans in S : break ;\n    print ( s - 2 * ans )\n", "python_code_tokenized": "while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE t = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( t ) NEW_LINE ans = s >> 1 NEW_LINE if ans in t : NEW_LINE INDENT print ( s - 2 * ans ) NEW_LINE continue NEW_LINE DEDENT a = [ v for v in t if v < ans ] NEW_LINE S , f , Q , qlen = set ( ) , True , [ 0 ] , 1 NEW_LINE for v in a : NEW_LINE INDENT i , k = 0 , qlen NEW_LINE while k : NEW_LINE INDENT v2 = v + Q [ i ] NEW_LINE k , i = k - 1 , i + 1 NEW_LINE if v2 == ans : NEW_LINE INDENT f = False NEW_LINE break NEW_LINE DEDENT if v2 < ans and v2 not in S : NEW_LINE INDENT S . add ( v2 ) NEW_LINE Q . append ( v2 ) NEW_LINE qlen += 1 NEW_LINE DEDENT DEDENT DEDENT if f : NEW_LINE INDENT while True : NEW_LINE INDENT ans -= 1 NEW_LINE if ans == 0 : break NEW_LINE if ans in S : break ; NEW_LINE DEDENT DEDENT print ( s - 2 * ans ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4199_A", "sol": 0, "python_code": "def xorPairCount ( arr , n , x ) :\n    result = 0\n    m = dict ( )\n    for i in range ( n ) :\n        curr_xor = x ^ arr [ i ]\n        if ( curr_xor in m.keys ( ) ) :\n            result += m [ curr_xor ]\n        if arr [ i ] in m.keys ( ) :\n            m [ arr [ i ] ] += 1\n        else :\n            m [ arr [ i ] ] = 1\n    return result\narr = [ 2 , 5 , 2 ]\nn = len ( arr )\nx = 0\nprint ( \"Count of pairs with given XOR = \" , xorPairCount ( arr , n , x ) )\n", "python_code_tokenized": "def xorPairCount ( arr , n , x ) : NEW_LINE INDENT result = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_xor = x ^ arr [ i ] NEW_LINE if ( curr_xor in m . keys ( ) ) : NEW_LINE INDENT result += m [ curr_xor ] NEW_LINE DEDENT if arr [ i ] in m . keys ( ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 2 , 5 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE x = 0 NEW_LINE print ( \" Count \u2581 of \u2581 pairs \u2581 with \u2581 given \u2581 XOR \u2581 = \u2581 \" , xorPairCount ( arr , n , x ) ) NEW_LINE"}
{"id": "codeforces_1454_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    n = int ( input ( ) )\n    print ( n , end = \" \" )\n    for i in range ( n - 1 ) :\n        print ( i + 1 , end = \" \" )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( n , end = \" \u2581 \" ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT print ( i + 1 , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1728_B", "sol": 0, "python_code": "for n in [ * map ( int , open ( 0 ) ) ] [ 1 : ] : * r , = range ( 1 , n + 1 ) ; r [ n % 2 : n - 2 ] = r [ n % 2 : n - 2 ] [ : : - 1 ] ; print ( * r )\n", "python_code_tokenized": "for n in [ * map ( int , open ( 0 ) ) ] [ 1 : ] : * r , = range ( 1 , n + 1 ) ; r [ n % 2 : n - 2 ] = r [ n % 2 : n - 2 ] [ : : - 1 ] ; print ( * r ) NEW_LINE"}
{"id": "codeforces_1326_A", "sol": 0, "python_code": "for _ in [ 0 ] * int ( input ( ) ) :\n    n = int ( input ( ) )\n    print ( [ - 1 , '4' + '7' * ( n - 1 ) ] [ n > 1 ] )\n", "python_code_tokenized": "for _ in [ 0 ] * int ( input ( ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( [ - 1 , '4' + '7' * ( n - 1 ) ] [ n > 1 ] ) NEW_LINE DEDENT"}
{"id": "codeforces_1467_A", "sol": 0, "python_code": "from math import ceil\nt = int ( input ( ) )\nfor i in range ( t ) :\n    n = int ( input ( ) )\n    result = \"989\" + ( \"0123456789\" * ceil ( n / 10 ) )\n    print ( result [ : n ] )\n", "python_code_tokenized": "from math import ceil NEW_LINE t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE result = \"989\" + ( \"0123456789\" * ceil ( n / 10 ) ) NEW_LINE print ( result [ : n ] ) NEW_LINE DEDENT"}
{"id": "aizu_p01762_A", "sol": 0, "python_code": "n = int ( input ( ) )\nc_lst = [ 0 ] + list ( map ( int , input ( ).split ( ) ) )\nedges = [ [ ] for _ in range ( n ) ]\nfor _ in range ( n - 1 ) :\n    u , v , p = map ( int , input ( ).split ( ) )\n    edges [ u ].append ( ( v , p ) )\n    edges [ v ].append ( ( u , p ) )\nINF = 10 ** 20\nused = [ False ] * n\ndef cost ( x ) :\n    used [ x ] = True\n    ret = 0\n    pre_cost = 0 if x != 0 else INF\n    for to , p in edges [ x ] :\n        if used [ to ] : pre_cost = p\n        else :\n            ret += cost ( to )\n    if c_lst [ x ] == 0 : return min ( ret , pre_cost )\n    else : return pre_cost\nprint ( cost ( 0 ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE c_lst = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE edges = [ [ ] for _ in range ( n ) ] NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT u , v , p = map ( int , input ( ) . split ( ) ) NEW_LINE edges [ u ] . append ( ( v , p ) ) NEW_LINE edges [ v ] . append ( ( u , p ) ) NEW_LINE DEDENT INF = 10 ** 20 NEW_LINE used = [ False ] * n NEW_LINE def cost ( x ) : NEW_LINE INDENT used [ x ] = True NEW_LINE ret = 0 NEW_LINE pre_cost = 0 if x != 0 else INF NEW_LINE for to , p in edges [ x ] : NEW_LINE INDENT if used [ to ] : pre_cost = p NEW_LINE else : NEW_LINE INDENT ret += cost ( to ) NEW_LINE DEDENT DEDENT if c_lst [ x ] == 0 : return min ( ret , pre_cost ) NEW_LINE else : return pre_cost NEW_LINE DEDENT print ( cost ( 0 ) ) NEW_LINE"}
{"id": "geeksforgeeks_4873_A", "sol": 0, "python_code": "def printElements ( a , n ) :\n    a.sort ( reverse = True )\n    cnt = 1\n    for i in range ( n - 1 ) :\n        if ( a [ i ] != a [ i + 1 ] ) :\n            print ( a [ i ] , \"occurs\" , cnt , \"times\" )\n            cnt = 1\n        else :\n            cnt += 1\n    print ( a [ n - 1 ] , \"occurs\" , cnt , \"times\" )\nif __name__ == \"__main__\" :\n    a = [ 1 , 1 , 1 , 2 , 3 , 4 , 9 , 9 , 10 ]\n    n = len ( a )\n    printElements ( a , n )\n", "python_code_tokenized": "def printElements ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE cnt = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] != a [ i + 1 ] ) : NEW_LINE INDENT print ( a [ i ] , \" \u2581 occurs \u2581 \" , cnt , \" times \" ) NEW_LINE cnt = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( a [ n - 1 ] , \" occurs \" , cnt , \" times \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 1 , 1 , 2 , 3 , 4 , 9 , 9 , 10 ] NEW_LINE n = len ( a ) NEW_LINE printElements ( a , n ) NEW_LINE DEDENT"}
{"id": "codeforces_696_B", "sol": 0, "python_code": "from sys import setrecursionlimit\nsetrecursionlimit ( 10 ** 6 )\nimport threading\ndef dfs ( node , g , size ) :\n    l = 0\n    for i in g [ node ] :\n        l += dfs ( i , g , size )\n    size [ node ] = l\n    return size [ node ] + 1\nfrom collections import defaultdict\ndef main ( ) :\n    g = defaultdict ( list )\n    n = int ( input ( ) )\n    if n == 1 :\n        print ( 1 )\n        exit ( 0 )\n    ar = list ( map ( int , input ( ).strip ( ).split ( ) ) )\n    for i in range ( n - 1 ) :\n        g [ ar [ i ] ].append ( i + 2 )\n    ar = [ 0 , 0 ] + ar\n    sz = [ 0 ] * ( n + 1 )\n    sz [ 1 ] = 1\n    dfs ( 1 , g , sz )\n    time = [ 0 ] * ( n + 1 )\n    time [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        parent = ar [ i ]\n        time [ i ] = time [ parent ] + ( sz [ parent ] - sz [ i ] - 1 ) / 2 + 1\n    print ( * time [ 1 : ] )\nthreading.stack_size ( 10 ** 8 )\nt = threading.Thread ( target = main )\nt.start ( )\nt.join ( )\n", "python_code_tokenized": "from sys import setrecursionlimit NEW_LINE setrecursionlimit ( 10 ** 6 ) NEW_LINE import threading NEW_LINE def dfs ( node , g , size ) : NEW_LINE INDENT l = 0 NEW_LINE for i in g [ node ] : NEW_LINE INDENT l += dfs ( i , g , size ) NEW_LINE DEDENT size [ node ] = l NEW_LINE return size [ node ] + 1 NEW_LINE DEDENT from collections import defaultdict NEW_LINE def main ( ) : NEW_LINE INDENT g = defaultdict ( list ) NEW_LINE n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT ar = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT g [ ar [ i ] ] . append ( i + 2 ) NEW_LINE DEDENT ar = [ 0 , 0 ] + ar NEW_LINE sz = [ 0 ] * ( n + 1 ) NEW_LINE sz [ 1 ] = 1 NEW_LINE dfs ( 1 , g , sz ) NEW_LINE time = [ 0 ] * ( n + 1 ) NEW_LINE time [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT parent = ar [ i ] NEW_LINE time [ i ] = time [ parent ] + ( sz [ parent ] - sz [ i ] - 1 ) / 2 + 1 NEW_LINE DEDENT print ( * time [ 1 : ] ) NEW_LINE DEDENT threading . stack_size ( 10 ** 8 ) NEW_LINE t = threading . Thread ( target = main ) NEW_LINE t . start ( ) NEW_LINE t . join ( ) NEW_LINE"}
{"id": "geeksforgeeks_4498_A", "sol": 0, "python_code": "def findPattern ( n ) :\n    prev = n % 2\n    n = n // 2\n    while ( n > 0 ) :\n        curr = n % 2\n        if ( curr == prev ) :\n            return False\n        prev = curr\n        n = n // 2\n    return True\nn = 10\nprint ( \"Yes\" ) if ( findPattern ( n ) ) else print ( \"No\" )\n", "python_code_tokenized": "def findPattern ( n ) : NEW_LINE INDENT prev = n % 2 NEW_LINE n = n // 2 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT curr = n % 2 NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 10 NEW_LINE print ( \" Yes \" ) if ( findPattern ( n ) ) else print ( \" No \" ) NEW_LINE"}
{"id": "codeforces_244_A", "sol": 0, "python_code": "def solve ( n , k , a ) :\n    b = sorted ( a )\n    a_idx = 0\n    k_idx = 0\n    for i in range ( 1 , n * k + 1 ) :\n        if i != b [ a_idx ] [ 0 ] :\n            if len ( a [ k_idx ] ) == n :\n                k_idx += 1\n            a [ k_idx ].append ( i )\n        elif a_idx < len ( a ) - 1 :\n            a_idx += 1\n    return a\ndef print_res ( a ) :\n    for e in a :\n        print ( ' '.join ( [ str ( x ) for x in e ] ) )\nn , k = [ int ( x ) for x in input ( ).split ( ) ]\na = [ [ int ( x ) ] for x in input ( ).split ( ) ]\nprint_res ( solve ( n , k , a ) )\n", "python_code_tokenized": "def solve ( n , k , a ) : NEW_LINE INDENT b = sorted ( a ) NEW_LINE a_idx = 0 NEW_LINE k_idx = 0 NEW_LINE for i in range ( 1 , n * k + 1 ) : NEW_LINE INDENT if i != b [ a_idx ] [ 0 ] : NEW_LINE INDENT if len ( a [ k_idx ] ) == n : NEW_LINE INDENT k_idx += 1 NEW_LINE DEDENT a [ k_idx ] . append ( i ) NEW_LINE DEDENT elif a_idx < len ( a ) - 1 : NEW_LINE INDENT a_idx += 1 NEW_LINE DEDENT DEDENT return a NEW_LINE DEDENT def print_res ( a ) : NEW_LINE INDENT for e in a : NEW_LINE INDENT print ( ' \u2581 ' . join ( [ str ( x ) for x in e ] ) ) NEW_LINE DEDENT DEDENT n , k = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE a = [ [ int ( x ) ] for x in input ( ) . split ( ) ] NEW_LINE print_res ( solve ( n , k , a ) ) NEW_LINE"}
{"id": "geeksforgeeks_410_A", "sol": 0, "python_code": "def findSubArr ( arr , n ) :\n    for i in range ( n - 1 ) :\n        if ( abs ( arr [ i ] - arr [ i + 1 ] ) >= 2 ) :\n            print ( arr [ i ] , arr [ i + 1 ] , end = \"\" ) ;\n            return ;\n    print ( - 1 ) ;\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 4 , 6 , 7 ] ;\n    n = len ( arr ) ;\n    findSubArr ( arr , n ) ;\n", "python_code_tokenized": "def findSubArr ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ i + 1 ] ) >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , arr [ i + 1 ] , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( - 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 6 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findSubArr ( arr , n ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1768_A", "sol": 0, "python_code": "def singleNumber ( nums ) :\n    return ( 3 * sum ( set ( nums ) ) - sum ( nums ) ) / 2\na = [ 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 ]\nprint ( \"The element with single occurrence is \" , int ( singleNumber ( a ) ) )\n", "python_code_tokenized": "def singleNumber ( nums ) : NEW_LINE INDENT return ( 3 * sum ( set ( nums ) ) - sum ( nums ) ) / 2 NEW_LINE DEDENT a = [ 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 ] NEW_LINE print ( \" The \u2581 element \u2581 with \u2581 single \u2581 occurrence \u2581 is \u2581 \" , int ( singleNumber ( a ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_264_A", "sol": 0, "python_code": "def perfectCube ( N ) :\n    cube_root = round ( N ** ( 1 / 3 ) ) ;\n    if cube_root * cube_root * cube_root == N :\n        print ( \"Yes\" ) ;\n        return ;\n    else :\n        print ( \"NO\" ) ;\n        return ;\nif __name__ == \"__main__\" :\n    N = 125 ;\n    perfectCube ( N ) ;\n", "python_code_tokenized": "def perfectCube ( N ) : NEW_LINE INDENT cube_root = round ( N ** ( 1 / 3 ) ) ; NEW_LINE if cube_root * cube_root * cube_root == N : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE return ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 125 ; NEW_LINE perfectCube ( N ) ; NEW_LINE DEDENT"}
{"id": "codeforces_679_B", "sol": 0, "python_code": "import math\ndef steps ( m , dct ) :\n    if m <= 7 :\n        return m\n    if dct.get ( m ) :\n        return dct [ m ]\n    x = math.floor ( m ** ( 1 / 3 ) )\n    dct [ m ] = 1 + steps ( max ( m - x ** 3 , ( x ** 3 - 1 ) - ( x - 1 ) ** 3 ) , dct )\n    return dct [ m ]\nif __name__ == \"__main__\" :\n    m = int ( input ( ) )\n    total_blocks_used = 0\n    total_vol = 0\n    steps_dct = { }\n    while ( m > 0 ) :\n        x = math.floor ( m ** ( 1 / 3 ) )\n        if steps ( m , steps_dct ) == 1 + steps ( m - x ** 3 , steps_dct ) :\n            m -= x ** 3\n            total_vol += x ** 3\n        else :\n            m = x ** 3 - 1 - ( x - 1 ) ** 3\n            total_vol += ( x - 1 ) ** 3\n        total_blocks_used += 1\n    print ( f\"{total_blocks_used} {total_vol}\" )\n", "python_code_tokenized": "import math NEW_LINE def steps ( m , dct ) : NEW_LINE INDENT if m <= 7 : NEW_LINE INDENT return m NEW_LINE DEDENT if dct . get ( m ) : NEW_LINE INDENT return dct [ m ] NEW_LINE DEDENT x = math . floor ( m ** ( 1 / 3 ) ) NEW_LINE dct [ m ] = 1 + steps ( max ( m - x ** 3 , ( x ** 3 - 1 ) - ( x - 1 ) ** 3 ) , dct ) NEW_LINE return dct [ m ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE total_blocks_used = 0 NEW_LINE total_vol = 0 NEW_LINE steps_dct = { } NEW_LINE while ( m > 0 ) : NEW_LINE INDENT x = math . floor ( m ** ( 1 / 3 ) ) NEW_LINE if steps ( m , steps_dct ) == 1 + steps ( m - x ** 3 , steps_dct ) : NEW_LINE INDENT m -= x ** 3 NEW_LINE total_vol += x ** 3 NEW_LINE DEDENT else : NEW_LINE INDENT m = x ** 3 - 1 - ( x - 1 ) ** 3 NEW_LINE total_vol += ( x - 1 ) ** 3 NEW_LINE DEDENT total_blocks_used += 1 NEW_LINE DEDENT print ( f \" { total _ blocks _ used } \u2581 { total _ vol } \" ) NEW_LINE DEDENT"}
{"id": "codeforces_12_B", "sol": 0, "python_code": "s = input ( )\nk = s.count ( '0' )\ns = ''.join ( sorted ( s ) ) [ k : ]\nprint ( [ 'WRONG_ANSWER' , 'OK' ] [ input ( ) == ( '0' if s == '' else s [ 0 ] + '0' * k + s [ 1 : ] ) ] )\n", "python_code_tokenized": "s = input ( ) NEW_LINE k = s . count ( '0' ) NEW_LINE s = ' ' . join ( sorted ( s ) ) [ k : ] NEW_LINE print ( [ ' WRONG _ ANSWER ' , ' OK ' ] [ input ( ) == ( '0' if s == ' ' else s [ 0 ] + '0' * k + s [ 1 : ] ) ] ) NEW_LINE"}
{"id": "geeksforgeeks_5011_A", "sol": 0, "python_code": "def sum ( n ) :\n    if n < 2 :\n        return 1\n    else :\n        return 1 / n + ( sum ( n - 1 ) )\nprint ( sum ( 8 ) )\nprint ( sum ( 10 ) )\n", "python_code_tokenized": "def sum ( n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 / n + ( sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT print ( sum ( 8 ) ) NEW_LINE print ( sum ( 10 ) ) NEW_LINE"}
{"id": "codeforces_1394_A", "sol": 0, "python_code": "from itertools import accumulate\nn , d , m = map ( int , input ( ).split ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nlo = [ ]\nhi = [ ]\nfor x in a :\n    if x <= m :\n        lo.append ( x )\n    else :\n        hi.append ( x )\nlo.sort ( reverse = True )\nlo_accum = list ( accumulate ( lo ) )\nhi.sort ( reverse = True )\nhi_accum = list ( accumulate ( hi ) )\nbest = 0\nif not hi :\n    print ( lo_accum [ - 1 ] )\n    exit ( )\nfor hi_chosen in range ( 1 , len ( hi ) + 1 ) :\n    rem_hi = len ( hi ) - hi_chosen\n    can_cover = hi_chosen * d\n    if can_cover < rem_hi :\n        continue\n    must_cover = max ( ( hi_chosen - 1 ) * d , rem_hi )\n    lo_covered = max ( 0 , must_cover - rem_hi )\n    if lo_covered > len ( lo ) :\n        continue\n    cur = 0\n    cur += hi_accum [ hi_chosen - 1 ]\n    if lo_covered < len ( lo ) :\n        cur += lo_accum [ len ( lo ) - lo_covered - 1 ]\n    best = max ( best , cur )\nprint ( best )\n", "python_code_tokenized": "from itertools import accumulate NEW_LINE n , d , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lo = [ ] NEW_LINE hi = [ ] NEW_LINE for x in a : NEW_LINE INDENT if x <= m : NEW_LINE INDENT lo . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT hi . append ( x ) NEW_LINE DEDENT DEDENT lo . sort ( reverse = True ) NEW_LINE lo_accum = list ( accumulate ( lo ) ) NEW_LINE hi . sort ( reverse = True ) NEW_LINE hi_accum = list ( accumulate ( hi ) ) NEW_LINE best = 0 NEW_LINE if not hi : NEW_LINE INDENT print ( lo_accum [ - 1 ] ) NEW_LINE exit ( ) NEW_LINE DEDENT for hi_chosen in range ( 1 , len ( hi ) + 1 ) : NEW_LINE INDENT rem_hi = len ( hi ) - hi_chosen NEW_LINE can_cover = hi_chosen * d NEW_LINE if can_cover < rem_hi : NEW_LINE INDENT continue NEW_LINE DEDENT must_cover = max ( ( hi_chosen - 1 ) * d , rem_hi ) NEW_LINE lo_covered = max ( 0 , must_cover - rem_hi ) NEW_LINE if lo_covered > len ( lo ) : NEW_LINE INDENT continue NEW_LINE DEDENT cur = 0 NEW_LINE cur += hi_accum [ hi_chosen - 1 ] NEW_LINE if lo_covered < len ( lo ) : NEW_LINE INDENT cur += lo_accum [ len ( lo ) - lo_covered - 1 ] NEW_LINE DEDENT best = max ( best , cur ) NEW_LINE DEDENT print ( best ) NEW_LINE"}
{"id": "atcoder_ABC169_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nans = 1\nif a.count ( 0 ) :\n    print ( 0 )\n    exit ( )\nfor i in a :\n    ans *= i\n    if ans > 10 ** 18 :\n        print ( - 1 )\n        exit ( )\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 1 NEW_LINE if a . count ( 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in a : NEW_LINE INDENT ans *= i NEW_LINE if ans > 10 ** 18 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_910_A", "sol": 0, "python_code": "def maximumXor ( arr : list , n : int ) -> int :\n    sForward , sBackward = [ ] , [ ]\n    ans = - 1\n    for i in range ( n ) :\n        while len ( sForward ) > 0 and arr [ i ] < arr [ sForward [ - 1 ] ] :\n            ans = max ( ans , arr [ i ] ^ arr [ sForward [ - 1 ] ] )\n            sForward.pop ( )\n        sForward.append ( i )\n        while len ( sBackward ) > 0 and arr [ n - i - 1 ] < arr [ sBackward [ - 1 ] ] :\n            ans = max ( ans , arr [ n - i - 1 ] ^ arr [ sBackward [ - 1 ] ] )\n            sBackward.pop ( )\n        sBackward.append ( n - i - 1 )\n    return ans\nif __name__ == \"__main__\" :\n    arr = [ 8 , 1 , 2 ]\n    n = len ( arr )\n    print ( maximumXor ( arr , n ) )\n", "python_code_tokenized": "def maximumXor ( arr : list , n : int ) -> int : NEW_LINE INDENT sForward , sBackward = [ ] , [ ] NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while len ( sForward ) > 0 and arr [ i ] < arr [ sForward [ - 1 ] ] : NEW_LINE INDENT ans = max ( ans , arr [ i ] ^ arr [ sForward [ - 1 ] ] ) NEW_LINE sForward . pop ( ) NEW_LINE DEDENT sForward . append ( i ) NEW_LINE while len ( sBackward ) > 0 and arr [ n - i - 1 ] < arr [ sBackward [ - 1 ] ] : NEW_LINE INDENT ans = max ( ans , arr [ n - i - 1 ] ^ arr [ sBackward [ - 1 ] ] ) NEW_LINE sBackward . pop ( ) NEW_LINE DEDENT sBackward . append ( n - i - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maximumXor ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1598_A", "sol": 0, "python_code": "t = int ( input ( ) )\nwhile t > 0 :\n    n = int ( input ( ) )\n    a = [ i for i in input ( ) ]\n    b = [ i for i in input ( ) ]\n    d = True\n    p = 0\n    for i in range ( len ( a ) - 1 ) :\n        if p == 0 :\n            if a [ i ] == '0' :\n                if a [ i + 1 ] == '1' :\n                    if b [ i + 1 ] == '0' : p = 1\n                    else : d = False ; break\n                else : p = 0\n        else :\n            if b [ i ] == '0' :\n                if b [ i + 1 ] == '1' :\n                    if a [ i + 1 ] == '0' : p = 0\n                    else : d = False ; break\n                else : p = 1\n    print ( 'YES' if d else 'NO' )\n    t -= 1\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ i for i in input ( ) ] NEW_LINE b = [ i for i in input ( ) ] NEW_LINE d = True NEW_LINE p = 0 NEW_LINE for i in range ( len ( a ) - 1 ) : NEW_LINE INDENT if p == 0 : NEW_LINE INDENT if a [ i ] == '0' : NEW_LINE INDENT if a [ i + 1 ] == '1' : NEW_LINE INDENT if b [ i + 1 ] == '0' : p = 1 NEW_LINE else : d = False ; break NEW_LINE DEDENT else : p = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if b [ i ] == '0' : NEW_LINE INDENT if b [ i + 1 ] == '1' : NEW_LINE INDENT if a [ i + 1 ] == '0' : p = 0 NEW_LINE else : d = False ; break NEW_LINE DEDENT else : p = 1 NEW_LINE DEDENT DEDENT DEDENT print ( ' YES ' if d else ' NO ' ) NEW_LINE t -= 1 NEW_LINE DEDENT"}
{"id": "aizu_p00593_A", "sol": 0, "python_code": "case = 1\nwhile True :\n    n = int ( input ( ) )\n    if not n :\n        break\n    jpeg = [ [ 0 ] * n for _ in range ( n ) ]\n    n1 = n - 1\n    px , cur = [ 0 , 0 ] , 1\n    while px [ 0 ] < n :\n        i , j = px\n        jpeg [ i ] [ j ] = cur\n        odd = ( i + j ) % 2\n        if px [ not odd ] == n1 :\n            px [ odd ] += 1\n        elif not px [ odd ] :\n            px [ not odd ] += 1\n        else :\n            px [ not odd ] += 1\n            px [ odd ] -= 1\n        cur += 1\n    print ( 'Case {}:'.format ( case ) )\n    for row in jpeg :\n        print ( ''.join ( '{:>3}'.format ( pixel ) for pixel in row ) )\n    case += 1\n", "python_code_tokenized": "case = 1 NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT jpeg = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE n1 = n - 1 NEW_LINE px , cur = [ 0 , 0 ] , 1 NEW_LINE while px [ 0 ] < n : NEW_LINE INDENT i , j = px NEW_LINE jpeg [ i ] [ j ] = cur NEW_LINE odd = ( i + j ) % 2 NEW_LINE if px [ not odd ] == n1 : NEW_LINE INDENT px [ odd ] += 1 NEW_LINE DEDENT elif not px [ odd ] : NEW_LINE INDENT px [ not odd ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT px [ not odd ] += 1 NEW_LINE px [ odd ] -= 1 NEW_LINE DEDENT cur += 1 NEW_LINE DEDENT print ( ' Case \u2581 { } : ' . format ( case ) ) NEW_LINE for row in jpeg : NEW_LINE INDENT print ( ' ' . join ( ' { : > 3 } ' . format ( pixel ) for pixel in row ) ) NEW_LINE DEDENT case += 1 NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2973_A", "sol": 0, "python_code": "def GCD ( a , b ) :\n    if ( b == 0 ) : return a\n    return GCD ( b , a % b )\ndef findMaxSumUtil ( arr , n ) :\n    finalGCD = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        finalGCD = GCD ( arr [ i ] , finalGCD )\n    return finalGCD\ndef findMaxSum ( arr , n ) :\n    maxElement = findMaxSumUtil ( arr , n )\n    return ( maxElement * n )\narr = [ 8 , 20 , 12 , 36 ]\nn = len ( arr )\nprint ( findMaxSum ( arr , n ) )\n", "python_code_tokenized": "def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : return a NEW_LINE return GCD ( b , a % b ) NEW_LINE DEDENT def findMaxSumUtil ( arr , n ) : NEW_LINE INDENT finalGCD = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT finalGCD = GCD ( arr [ i ] , finalGCD ) NEW_LINE DEDENT return finalGCD NEW_LINE DEDENT def findMaxSum ( arr , n ) : NEW_LINE INDENT maxElement = findMaxSumUtil ( arr , n ) NEW_LINE return ( maxElement * n ) NEW_LINE DEDENT arr = [ 8 , 20 , 12 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2501_A", "sol": 0, "python_code": "def result ( N ) :\n    for num in range ( N ) :\n        if num % 3 == 0 and num % 5 == 0 :\n            print ( str ( num ) + \"\" , end = \"\" )\n        else :\n            pass\nif __name__ == \"__main__\" :\n    N = 100\n    result ( N )\n", "python_code_tokenized": "def result ( N ) : NEW_LINE INDENT for num in range ( N ) : NEW_LINE INDENT if num % 3 == 0 and num % 5 == 0 : NEW_LINE INDENT print ( str ( num ) + \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 100 NEW_LINE result ( N ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4229_A", "sol": 0, "python_code": "def next_permutation ( arr ) :\n    arrCount = len ( arr ) ;\n    i = arrCount - 1 ;\n    while ( i > 0 and arr [ i ] <= arr [ i - 1 ] ) :\n        i -= 1 ;\n    if ( i <= 0 ) :\n        return [ False , arr ] ;\n    pivotIndex = i - 1 ;\n    j = arrCount - 1 ;\n    while ( arr [ j ] <= arr [ pivotIndex ] ) :\n        j -= 1 ;\n    temp = arr [ pivotIndex ] ;\n    arr [ pivotIndex ] = arr [ j ] ;\n    arr [ j ] = temp ;\n    j = arrCount - 1 ;\n    while ( i < j ) :\n        temp = arr [ i ] ;\n        arr [ i ] = arr [ j ] ;\n        arr [ j ] = temp ;\n        i += 1 ;\n        j -= 1 ;\n    return [ True , arr ] ;\ndef numberOfPermutations ( a , n ) :\n    sumEven = 0 ;\n    sumOdd = 0 ;\n    c = 0 ;\n    while ( True ) :\n        sumEven = 0 ;\n        sumOdd = 0 ;\n        for i in range ( n ) :\n            if ( i % 2 ) :\n                sumOdd += a [ i ] ;\n            else :\n                sumEven += a [ i ] ;\n        if ( sumOdd == sumEven ) :\n            c += 1 ;\n        xx = next_permutation ( a ) ;\n        if ( xx [ 0 ] == False ) :\n            break ;\n        a = xx [ 1 ] ;\n    return c ;\na = [ 1 , 2 , 3 ] ;\nn = len ( a ) ;\nprint ( numberOfPermutations ( a , n ) ) ;\n", "python_code_tokenized": "def next_permutation ( arr ) : NEW_LINE INDENT arrCount = len ( arr ) ; NEW_LINE i = arrCount - 1 ; NEW_LINE while ( i > 0 and arr [ i ] <= arr [ i - 1 ] ) : NEW_LINE INDENT i -= 1 ; NEW_LINE DEDENT if ( i <= 0 ) : NEW_LINE INDENT return [ False , arr ] ; NEW_LINE DEDENT pivotIndex = i - 1 ; NEW_LINE j = arrCount - 1 ; NEW_LINE while ( arr [ j ] <= arr [ pivotIndex ] ) : NEW_LINE INDENT j -= 1 ; NEW_LINE DEDENT temp = arr [ pivotIndex ] ; NEW_LINE arr [ pivotIndex ] = arr [ j ] ; NEW_LINE arr [ j ] = temp ; NEW_LINE j = arrCount - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT temp = arr [ i ] ; NEW_LINE arr [ i ] = arr [ j ] ; NEW_LINE arr [ j ] = temp ; NEW_LINE i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return [ True , arr ] ; NEW_LINE DEDENT def numberOfPermutations ( a , n ) : NEW_LINE INDENT sumEven = 0 ; NEW_LINE sumOdd = 0 ; NEW_LINE c = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT sumEven = 0 ; NEW_LINE sumOdd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 ) : NEW_LINE INDENT sumOdd += a [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT sumEven += a [ i ] ; NEW_LINE DEDENT DEDENT if ( sumOdd == sumEven ) : NEW_LINE INDENT c += 1 ; NEW_LINE DEDENT xx = next_permutation ( a ) ; NEW_LINE if ( xx [ 0 ] == False ) : NEW_LINE INDENT break ; NEW_LINE DEDENT a = xx [ 1 ] ; NEW_LINE DEDENT return c ; NEW_LINE DEDENT a = [ 1 , 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( numberOfPermutations ( a , n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_2051_A", "sol": 0, "python_code": "from math import sqrt\ndef countOrderedPairs ( N ) :\n    count_pairs = 0\n    p = int ( sqrt ( N - 1 ) ) + 1\n    q = int ( sqrt ( N ) ) + 2\n    for i in range ( 1 , p , 1 ) :\n        for j in range ( i , q , 1 ) :\n            count_pairs += 1\n    count_pairs *= 2\n    count_pairs -= int ( sqrt ( N - 1 ) )\n    return count_pairs\nif __name__ == '__main__' :\n    N = 5\n    print ( countOrderedPairs ( N ) )\n", "python_code_tokenized": "from math import sqrt NEW_LINE def countOrderedPairs ( N ) : NEW_LINE INDENT count_pairs = 0 NEW_LINE p = int ( sqrt ( N - 1 ) ) + 1 NEW_LINE q = int ( sqrt ( N ) ) + 2 NEW_LINE for i in range ( 1 , p , 1 ) : NEW_LINE INDENT for j in range ( i , q , 1 ) : NEW_LINE INDENT count_pairs += 1 NEW_LINE DEDENT DEDENT count_pairs *= 2 NEW_LINE count_pairs -= int ( sqrt ( N - 1 ) ) NEW_LINE return count_pairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE print ( countOrderedPairs ( N ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1215_B", "sol": 0, "python_code": "n = int ( input ( ) )\nw = [ int ( k ) for k in input ( ).split ( ) ]\nx , y = 0 , 0\nlast = [ 0 , 0 ]\nif w [ 0 ] > 0 :\n    x += 1\n    last [ 0 ] += 1\nelse :\n    y += 1\n    last [ 1 ] += 1\nfor j in range ( 1 , n ) :\n    if w [ j ] > 0 :\n        last [ 0 ] += 1\n        x += last [ 0 ]\n        y += last [ 1 ]\n    else :\n        y += 1\n        x += last [ 1 ]\n        y += last [ 0 ]\n        last = [ last [ 1 ] , last [ 0 ] + 1 ]\nprint ( y , x )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE w = [ int ( k ) for k in input ( ) . split ( ) ] NEW_LINE x , y = 0 , 0 NEW_LINE last = [ 0 , 0 ] NEW_LINE if w [ 0 ] > 0 : NEW_LINE INDENT x += 1 NEW_LINE last [ 0 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT y += 1 NEW_LINE last [ 1 ] += 1 NEW_LINE DEDENT for j in range ( 1 , n ) : NEW_LINE INDENT if w [ j ] > 0 : NEW_LINE INDENT last [ 0 ] += 1 NEW_LINE x += last [ 0 ] NEW_LINE y += last [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT y += 1 NEW_LINE x += last [ 1 ] NEW_LINE y += last [ 0 ] NEW_LINE last = [ last [ 1 ] , last [ 0 ] + 1 ] NEW_LINE DEDENT DEDENT print ( y , x ) NEW_LINE"}
{"id": "codeforces_320_B", "sol": 0, "python_code": "class Pair :\n    def __init__ ( self , x , y ) :\n        self.x = x\n        self.y = y\nqueries = int ( input ( ) )\nintervals = [ None ]\ndef dfs ( target , reachable ) :\n    reachable.add ( target )\n    t = intervals [ target ]\n    for i in range ( 1 , len ( intervals ) ) :\n        if i not in reachable :\n            r = intervals [ i ]\n            if ( t.x > r.x and t.x < r.y ) or ( t.y > r.x and t.y < r.y ) :\n                dfs ( i , reachable )\nfor i in range ( queries ) :\n    kind , x , y = map ( int , input ( ).split ( ) )\n    if kind == 1 :\n        intervals.append ( Pair ( x , y ) )\n    else :\n        reachable = set ( )\n        dfs ( x , reachable )\n        if y in reachable :\n            print ( 'YES' )\n        else :\n            print ( 'NO' )\n", "python_code_tokenized": "class Pair : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT queries = int ( input ( ) ) NEW_LINE intervals = [ None ] NEW_LINE def dfs ( target , reachable ) : NEW_LINE INDENT reachable . add ( target ) NEW_LINE t = intervals [ target ] NEW_LINE for i in range ( 1 , len ( intervals ) ) : NEW_LINE INDENT if i not in reachable : NEW_LINE INDENT r = intervals [ i ] NEW_LINE if ( t . x > r . x and t . x < r . y ) or ( t . y > r . x and t . y < r . y ) : NEW_LINE INDENT dfs ( i , reachable ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( queries ) : NEW_LINE INDENT kind , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if kind == 1 : NEW_LINE INDENT intervals . append ( Pair ( x , y ) ) NEW_LINE DEDENT else : NEW_LINE INDENT reachable = set ( ) NEW_LINE dfs ( x , reachable ) NEW_LINE if y in reachable : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "aizu_p00881_A", "sol": 0, "python_code": "from collections import Counter\nwhile True :\n    m , n = ( int ( s ) for s in input ( ).split ( ) )\n    if not m :\n        break\n    objs = [ int ( input ( ) , 2 ) for i in range ( n ) ]\n    dp = [ [ 0 ] * ( 1 << m ) for i in range ( 1 << m ) ]\n    bits = [ 1 << i for i in range ( m ) ]\n    for mask in reversed ( range ( 1 << m ) ) :\n        s = Counter ( obj & mask for obj in objs )\n        for masked , value in s.items ( ) :\n            if value > 1 :\n                dp [ mask ] [ masked ] = min ( max ( dp [ mask | b ] [ masked ] , dp [ mask | b ] [ masked | b ] ) + 1 for b in bits if not b & mask )\n    print ( dp [ 0 ] [ 0 ] )\n", "python_code_tokenized": "from collections import Counter NEW_LINE while True : NEW_LINE INDENT m , n = ( int ( s ) for s in input ( ) . split ( ) ) NEW_LINE if not m : NEW_LINE INDENT break NEW_LINE DEDENT objs = [ int ( input ( ) , 2 ) for i in range ( n ) ] NEW_LINE dp = [ [ 0 ] * ( 1 << m ) for i in range ( 1 << m ) ] NEW_LINE bits = [ 1 << i for i in range ( m ) ] NEW_LINE for mask in reversed ( range ( 1 << m ) ) : NEW_LINE INDENT s = Counter ( obj & mask for obj in objs ) NEW_LINE for masked , value in s . items ( ) : NEW_LINE INDENT if value > 1 : NEW_LINE INDENT dp [ mask ] [ masked ] = min ( max ( dp [ mask | b ] [ masked ] , dp [ mask | b ] [ masked | b ] ) + 1 for b in bits if not b & mask ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ 0 ] [ 0 ] ) NEW_LINE DEDENT"}
{"id": "codeforces_391_A", "sol": 0, "python_code": "code = list ( input ( ) )\neven = 1\ntotal = 0\nind = 1\nwhile ind <= len ( code ) - 1 :\n    if code [ ind ] == code [ ind - 1 ] or even == 0 :\n        even += 1\n    else :\n        if even % 2 == 0 :\n            total += 1\n        even = 1\n    ind += 1\nif even % 2 == 0 :\n    total += 1\nprint ( total )\n", "python_code_tokenized": "code = list ( input ( ) ) NEW_LINE even = 1 NEW_LINE total = 0 NEW_LINE ind = 1 NEW_LINE while ind <= len ( code ) - 1 : NEW_LINE INDENT if code [ ind ] == code [ ind - 1 ] or even == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if even % 2 == 0 : NEW_LINE INDENT total += 1 NEW_LINE DEDENT even = 1 NEW_LINE DEDENT ind += 1 NEW_LINE DEDENT if even % 2 == 0 : NEW_LINE INDENT total += 1 NEW_LINE DEDENT print ( total ) NEW_LINE"}
{"id": "geeksforgeeks_2469_A", "sol": 0, "python_code": "def NthTerm ( N ) :\n    x = ( 3 * N * N ) % 1000000009\n    return ( ( x - N + 1000000009 ) % 1000000009 )\nif __name__ == \"__main__\" :\n    N = 4\n    print ( NthTerm ( N ) )\n", "python_code_tokenized": "def NthTerm ( N ) : NEW_LINE INDENT x = ( 3 * N * N ) % 1000000009 NEW_LINE return ( ( x - N + 1000000009 ) % 1000000009 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE print ( NthTerm ( N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2550_A", "sol": 0, "python_code": "import math\ndef _log ( x , base ) :\n    return ( int ) ( math.log ( x ) / math.log ( base ) )\ndef recursiveLogStar ( n , b ) :\n    if ( n > 1.0 ) :\n        return 1.0 + recursiveLogStar ( _log ( n , b ) , b )\n    else :\n        return 0\nif __name__ == '__main__' :\n    n = 100\n    base = 5\n    print ( \"Log*(\" , n , \") = \" , recursiveLogStar ( n , base ) )\n", "python_code_tokenized": "import math NEW_LINE def _log ( x , base ) : NEW_LINE INDENT return ( int ) ( math . log ( x ) / math . log ( base ) ) NEW_LINE DEDENT def recursiveLogStar ( n , b ) : NEW_LINE INDENT if ( n > 1.0 ) : NEW_LINE INDENT return 1.0 + recursiveLogStar ( _log ( n , b ) , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 100 NEW_LINE base = 5 NEW_LINE print ( \" Log * ( \" , n , \" ) \u2581 = \u2581 \" , recursiveLogStar ( n , base ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4244_A", "sol": 0, "python_code": "def oddEquivalent ( s , n ) :\n    count = 0\n    for i in range ( 0 , n ) :\n        if ( s [ i ] == '1' ) :\n            count = count + 1\n    return count\nif __name__ == '__main__' :\n    s = \"1011011\"\n    n = len ( s )\n    print ( oddEquivalent ( s , n ) )\n", "python_code_tokenized": "def oddEquivalent ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"1011011\" NEW_LINE n = len ( s ) NEW_LINE print ( oddEquivalent ( s , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_25_A", "sol": 0, "python_code": "n = input ( )\nnum = input ( ).split ( )\neven = 0\nfor i in num :\n    if int ( i ) % 2 == 0 :\n        even += 1\nif even == 1 :\n    for i in num :\n        if int ( i ) % 2 == 0 :\n            print ( num.index ( i ) + 1 )\nelse :\n    for i in num :\n        if int ( i ) % 2 == 1 :\n            print ( num.index ( i ) + 1 )\n", "python_code_tokenized": "n = input ( ) NEW_LINE num = input ( ) . split ( ) NEW_LINE even = 0 NEW_LINE for i in num : NEW_LINE INDENT if int ( i ) % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if even == 1 : NEW_LINE INDENT for i in num : NEW_LINE INDENT if int ( i ) % 2 == 0 : NEW_LINE INDENT print ( num . index ( i ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in num : NEW_LINE INDENT if int ( i ) % 2 == 1 : NEW_LINE INDENT print ( num . index ( i ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "atcoder_ABC123_B", "sol": 0, "python_code": "import math\nl = [ int ( input ( ) ) for _ in range ( 5 ) ]\nm = [ math.ceil ( l [ i ] / 10 ) * 10 for i in range ( 5 ) ]\ns = sum ( m )\nans = [ s - m [ i ] + l [ i ] for i in range ( 5 ) ]\nprint ( min ( ans ) )\n", "python_code_tokenized": "import math NEW_LINE l = [ int ( input ( ) ) for _ in range ( 5 ) ] NEW_LINE m = [ math . ceil ( l [ i ] / 10 ) * 10 for i in range ( 5 ) ] NEW_LINE s = sum ( m ) NEW_LINE ans = [ s - m [ i ] + l [ i ] for i in range ( 5 ) ] NEW_LINE print ( min ( ans ) ) NEW_LINE"}
{"id": "codeforces_515_B", "sol": 0, "python_code": "def GCD ( a , b ) :\n    remain = 0\n    while b != 0 :\n        remain = a % b\n        a = b\n        b = remain\n    return a\nif __name__ == \"__main__\" :\n    nBoys , nGirls = map ( int , input ( ).split ( ) )\n    lstB = list ( map ( int , input ( ).split ( ) ) )\n    lstG = list ( map ( int , input ( ).split ( ) ) )\n    numUnhappy = nBoys + nGirls - lstB [ 0 ] - lstG [ 0 ]\n    happyBoys = [ False ] * ( nBoys )\n    happyGirls = [ False ] * ( nGirls )\n    for i in range ( 1 , len ( lstB ) ) :\n        happyBoys [ lstB [ i ] ] = True\n    for i in range ( 1 , len ( lstG ) ) :\n        happyGirls [ lstG [ i ] ] = True\n    lim = nBoys * nGirls // GCD ( nBoys , nGirls )\n    for i in range ( 2 * lim ) :\n        if happyBoys [ i % nBoys ] + happyGirls [ i % nGirls ] == 1 :\n            happyBoys [ i % nBoys ] = happyGirls [ i % nGirls ] = True\n            numUnhappy -= 1\n    print ( 'Yes' if numUnhappy == 0 else 'No' )\n", "python_code_tokenized": "def GCD ( a , b ) : NEW_LINE INDENT remain = 0 NEW_LINE while b != 0 : NEW_LINE INDENT remain = a % b NEW_LINE a = b NEW_LINE b = remain NEW_LINE DEDENT return a NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT nBoys , nGirls = map ( int , input ( ) . split ( ) ) NEW_LINE lstB = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lstG = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE numUnhappy = nBoys + nGirls - lstB [ 0 ] - lstG [ 0 ] NEW_LINE happyBoys = [ False ] * ( nBoys ) NEW_LINE happyGirls = [ False ] * ( nGirls ) NEW_LINE for i in range ( 1 , len ( lstB ) ) : NEW_LINE INDENT happyBoys [ lstB [ i ] ] = True NEW_LINE DEDENT for i in range ( 1 , len ( lstG ) ) : NEW_LINE INDENT happyGirls [ lstG [ i ] ] = True NEW_LINE DEDENT lim = nBoys * nGirls // GCD ( nBoys , nGirls ) NEW_LINE for i in range ( 2 * lim ) : NEW_LINE INDENT if happyBoys [ i % nBoys ] + happyGirls [ i % nGirls ] == 1 : NEW_LINE INDENT happyBoys [ i % nBoys ] = happyGirls [ i % nGirls ] = True NEW_LINE numUnhappy -= 1 NEW_LINE DEDENT DEDENT print ( ' Yes ' if numUnhappy == 0 else ' No ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4438_A", "sol": 0, "python_code": "def printDuplicates ( arr ) :\n    dict = { }\n    for ele in arr :\n        try :\n            dict [ ele ] += 1\n        except :\n            dict [ ele ] = 1\n    for item in dict :\n        if ( dict [ item ] > 1 ) :\n            print ( item , end = \" \" )\n    print ( \"\\n\" )\nif __name__ == \"__main__\" :\n    list = [ 12 , 11 , 40 , 12 , 5 , 6 , 5 , 12 , 11 ]\n    printDuplicates ( list )\n", "python_code_tokenized": "def printDuplicates ( arr ) : NEW_LINE INDENT dict = { } NEW_LINE for ele in arr : NEW_LINE INDENT try : NEW_LINE INDENT dict [ ele ] += 1 NEW_LINE DEDENT except : NEW_LINE INDENT dict [ ele ] = 1 NEW_LINE DEDENT DEDENT for item in dict : NEW_LINE INDENT if ( dict [ item ] > 1 ) : NEW_LINE INDENT print ( item , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT print ( \" \\n \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT list = [ 12 , 11 , 40 , 12 , 5 , 6 , 5 , 12 , 11 ] NEW_LINE printDuplicates ( list ) NEW_LINE DEDENT"}
{"id": "aizu_p02319_A", "sol": 0, "python_code": "import sys\nfrom collections import namedtuple\nMAX_V = 100\ndef solve ( ) :\n    dp = [ [ float ( 'inf' ) ] * ( c_items * MAX_V + 1 ) for _ in range ( c_items + 1 ) ]\n    dp [ 0 ] [ 0 ] = 0\n    for i , item in enumerate ( item_list ) :\n        v , w = item.value , item.weight\n        for j in range ( c_items * MAX_V + 1 ) :\n            if j < v :\n                dp [ i + 1 ] [ j ] = dp [ i ] [ j ]\n            else :\n                dp [ i + 1 ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ j - v ] + w )\n    ans = 0\n    for i in range ( c_items * MAX_V + 1 ) :\n        if dp [ c_items ] [ i ] <= knapsack_cp :\n            ans = i\n    return ans\nif __name__ == '__main__' :\n    _input = sys.stdin.readlines ( )\n    c_items , knapsack_cp = map ( int , _input [ 0 ].split ( ) )\n    items = map ( lambda x : x.split ( ) , _input [ 1 : ] )\n    Item = namedtuple ( 'Item' , ( 'value' , 'weight' ) )\n    item_list = [ Item ( int ( v ) , int ( w ) ) for v , w in items ]\n    print ( solve ( ) )\n", "python_code_tokenized": "import sys NEW_LINE from collections import namedtuple NEW_LINE MAX_V = 100 NEW_LINE def solve ( ) : NEW_LINE INDENT dp = [ [ float ( ' inf ' ) ] * ( c_items * MAX_V + 1 ) for _ in range ( c_items + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i , item in enumerate ( item_list ) : NEW_LINE INDENT v , w = item . value , item . weight NEW_LINE for j in range ( c_items * MAX_V + 1 ) : NEW_LINE INDENT if j < v : NEW_LINE INDENT dp [ i + 1 ] [ j ] = dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ j - v ] + w ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( c_items * MAX_V + 1 ) : NEW_LINE INDENT if dp [ c_items ] [ i ] <= knapsack_cp : NEW_LINE INDENT ans = i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT _input = sys . stdin . readlines ( ) NEW_LINE c_items , knapsack_cp = map ( int , _input [ 0 ] . split ( ) ) NEW_LINE items = map ( lambda x : x . split ( ) , _input [ 1 : ] ) NEW_LINE Item = namedtuple ( ' Item ' , ( ' value ' , ' weight ' ) ) NEW_LINE item_list = [ Item ( int ( v ) , int ( w ) ) for v , w in items ] NEW_LINE print ( solve ( ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00154_A", "sol": 0, "python_code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\nans = [ ]\nwhile 1 :\n    M = int ( readline ( ) )\n    if M == 0 :\n        break\n    P = [ list ( map ( int , input ( ).split ( ) ) ) for i in range ( M ) ]\n    memo = { }\n    def dfs ( i , rest ) :\n        if i == M :\n            return rest == 0\n        key = ( i , rest )\n        if key in memo :\n            return memo [ key ]\n        res = 0\n        a , b = P [ i ]\n        for j in range ( 0 , b + 1 ) :\n            if rest - j * a < 0 :\n                break\n            res += dfs ( i + 1 , rest - j * a )\n        memo [ key ] = res\n        return res\n    G = int ( input ( ) )\n    for i in range ( G ) :\n        ans.append ( str ( dfs ( 0 , int ( input ( ) ) ) ) )\nwrite ( \"\\n\".join ( ans ) )\nwrite ( \"\\n\" )\n", "python_code_tokenized": "import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE ans = [ ] NEW_LINE while 1 : NEW_LINE INDENT M = int ( readline ( ) ) NEW_LINE if M == 0 : NEW_LINE INDENT break NEW_LINE DEDENT P = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( M ) ] NEW_LINE memo = { } NEW_LINE def dfs ( i , rest ) : NEW_LINE INDENT if i == M : NEW_LINE INDENT return rest == 0 NEW_LINE DEDENT key = ( i , rest ) NEW_LINE if key in memo : NEW_LINE INDENT return memo [ key ] NEW_LINE DEDENT res = 0 NEW_LINE a , b = P [ i ] NEW_LINE for j in range ( 0 , b + 1 ) : NEW_LINE INDENT if rest - j * a < 0 : NEW_LINE INDENT break NEW_LINE DEDENT res += dfs ( i + 1 , rest - j * a ) NEW_LINE DEDENT memo [ key ] = res NEW_LINE return res NEW_LINE DEDENT G = int ( input ( ) ) NEW_LINE for i in range ( G ) : NEW_LINE INDENT ans . append ( str ( dfs ( 0 , int ( input ( ) ) ) ) ) NEW_LINE DEDENT DEDENT write ( \" \\n \" . join ( ans ) ) NEW_LINE write ( \" \\n \" ) NEW_LINE"}
{"id": "geeksforgeeks_104_A", "sol": 0, "python_code": "def MinimumSwapOperations ( s ) :\n    zero_exist = False\n    multiple_of_2 = False\n    sum = 0\n    index_of_zero = 0\n    more_zero = False\n    for i in range ( len ( s ) ) :\n        val = ord ( s [ i ] ) - ord ( '0' )\n        if ( zero_exist == True ) :\n            more_zero = True\n        if ( val == 0 ) :\n            zero_exist = True\n            index_of_zero = i\n        sum += val\n    if ( zero_exist == False or sum % 3 != 0 ) :\n        print ( \"-1\" )\n        return\n    for i in range ( len ( s ) ) :\n        val = ord ( s [ i ] ) - ord ( '0' )\n        if ( val % 2 == 0 and i != index_of_zero ) :\n            multiple_of_2 = True\n    if ( multiple_of_2 == False ) :\n        print ( \"-1\" )\n        return\n    last_val = ord ( s [ len ( s ) - 1 ] ) - ord ( '0' )\n    second_last_val = ord ( s [ len ( s ) - 2 ] ) - ord ( '0' )\n    if ( last_val == 0 and second_last_val % 2 == 0 ) :\n        print ( 0 )\n    elif ( ( last_val == 0 and second_last_val % 2 != 0 ) or ( last_val % 2 == 0 and second_last_val == 0 ) ) :\n        print ( 1 )\n    elif ( more_zero == True and ( last_val == 0 and second_last_val % 2 != 0 ) ) :\n        print ( 1 )\n    else :\n        print ( 2 )\nif __name__ == '__main__' :\n    N = \"20\"\n    MinimumSwapOperations ( N )\n", "python_code_tokenized": "def MinimumSwapOperations ( s ) : NEW_LINE INDENT zero_exist = False NEW_LINE multiple_of_2 = False NEW_LINE sum = 0 NEW_LINE index_of_zero = 0 NEW_LINE more_zero = False NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT val = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( zero_exist == True ) : NEW_LINE INDENT more_zero = True NEW_LINE DEDENT if ( val == 0 ) : NEW_LINE INDENT zero_exist = True NEW_LINE index_of_zero = i NEW_LINE DEDENT sum += val NEW_LINE DEDENT if ( zero_exist == False or sum % 3 != 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT val = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( val % 2 == 0 and i != index_of_zero ) : NEW_LINE INDENT multiple_of_2 = True NEW_LINE DEDENT DEDENT if ( multiple_of_2 == False ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT last_val = ord ( s [ len ( s ) - 1 ] ) - ord ( '0' ) NEW_LINE second_last_val = ord ( s [ len ( s ) - 2 ] ) - ord ( '0' ) NEW_LINE if ( last_val == 0 and second_last_val % 2 == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( ( last_val == 0 and second_last_val % 2 != 0 ) or ( last_val % 2 == 0 and second_last_val == 0 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif ( more_zero == True and ( last_val == 0 and second_last_val % 2 != 0 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = \"20\" NEW_LINE MinimumSwapOperations ( N ) NEW_LINE DEDENT"}
{"id": "aizu_p01094_A", "sol": 0, "python_code": "from collections import Counter\ndef Look_for_the_Winner ( n , lst ) :\n    dic = Counter ( )\n    loop_count = 0\n    flg = 0\n    for i in lst :\n        n -= 1\n        loop_count += 1\n        dic [ i ] += 1\n        if len ( dic ) == 1 :\n            if dic.most_common ( ) [ 0 ] [ 1 ] > n :\n                print ( dic.most_common ( ) [ 0 ] [ 0 ] + \" \" + str ( loop_count ) )\n                flg = 1\n                break\n        else :\n            if dic.most_common ( ) [ 0 ] [ 1 ] > dic.most_common ( ) [ 1 ] [ 1 ] + n :\n                print ( dic.most_common ( ) [ 0 ] [ 0 ] + \" \" + str ( loop_count ) )\n                flg = 1\n                break\n    if flg == 0 :\n        print ( \"TIE\" )\nwhile True :\n    n = int ( input ( ) )\n    if n == 0 :\n        break\n    c = list ( map ( str , input ( ).split ( ) ) )\n    Look_for_the_Winner ( n , c )\n", "python_code_tokenized": "from collections import Counter NEW_LINE def Look_for_the_Winner ( n , lst ) : NEW_LINE INDENT dic = Counter ( ) NEW_LINE loop_count = 0 NEW_LINE flg = 0 NEW_LINE for i in lst : NEW_LINE INDENT n -= 1 NEW_LINE loop_count += 1 NEW_LINE dic [ i ] += 1 NEW_LINE if len ( dic ) == 1 : NEW_LINE INDENT if dic . most_common ( ) [ 0 ] [ 1 ] > n : NEW_LINE INDENT print ( dic . most_common ( ) [ 0 ] [ 0 ] + \" \u2581 \" + str ( loop_count ) ) NEW_LINE flg = 1 NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if dic . most_common ( ) [ 0 ] [ 1 ] > dic . most_common ( ) [ 1 ] [ 1 ] + n : NEW_LINE INDENT print ( dic . most_common ( ) [ 0 ] [ 0 ] + \" \u2581 \" + str ( loop_count ) ) NEW_LINE flg = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if flg == 0 : NEW_LINE INDENT print ( \" TIE \" ) NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT c = list ( map ( str , input ( ) . split ( ) ) ) NEW_LINE Look_for_the_Winner ( n , c ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1860_A", "sol": 0, "python_code": "import sys\ndef closetAND ( arr , n , k ) :\n    ans = sys.maxsize ;\n    for i in range ( n ) :\n        X = arr [ i ] ;\n        for j in range ( i , n ) :\n            X &= arr [ j ] ;\n            ans = min ( ans , abs ( k - X ) ) ;\n            if ( X <= k ) :\n                break ;\n    return ans ;\narr = [ 4 , 7 , 10 ] ;\nn = len ( arr ) ;\nk = 2 ;\nprint ( closetAND ( arr , n , k ) ) ;\n", "python_code_tokenized": "import sys NEW_LINE def closetAND ( arr , n , k ) : NEW_LINE INDENT ans = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT X = arr [ i ] ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT X &= arr [ j ] ; NEW_LINE ans = min ( ans , abs ( k - X ) ) ; NEW_LINE if ( X <= k ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT arr = [ 4 , 7 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE print ( closetAND ( arr , n , k ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_4958_A", "sol": 0, "python_code": "def isPalindrome ( string : str , low : int , high : int ) :\n    while low < high :\n        if string [ low ] != string [ high ] :\n            return False\n        low += 1\n        high -= 1\n    return True\ndef allPalPartUtil ( allPart : list , currPart : list , start : int , n : int , string : str ) :\n    if start >= n :\n        x = currPart.copy ( )\n        allPart.append ( x )\n        return\n    for i in range ( start , n ) :\n        if isPalindrome ( string , start , i ) :\n            currPart.append ( string [ start : i + 1 ] )\n            allPalPartUtil ( allPart , currPart , i + 1 , n , string )\n            currPart.pop ( )\ndef allPalPartitions ( string : str ) :\n    n = len ( string )\n    allPart = [ ]\n    currPart = [ ]\n    allPalPartUtil ( allPart , currPart , 0 , n , string )\n    for i in range ( len ( allPart ) ) :\n        for j in range ( len ( allPart [ i ] ) ) :\n            print ( allPart [ i ] [ j ] , end = \" \" )\n        print ( )\nif __name__ == \"__main__\" :\n    string = \"nitin\"\n    allPalPartitions ( string )\n", "python_code_tokenized": "def isPalindrome ( string : str , low : int , high : int ) : NEW_LINE INDENT while low < high : NEW_LINE INDENT if string [ low ] != string [ high ] : NEW_LINE INDENT return False NEW_LINE DEDENT low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def allPalPartUtil ( allPart : list , currPart : list , start : int , n : int , string : str ) : NEW_LINE INDENT if start >= n : NEW_LINE INDENT x = currPart . copy ( ) NEW_LINE allPart . append ( x ) NEW_LINE return NEW_LINE DEDENT for i in range ( start , n ) : NEW_LINE INDENT if isPalindrome ( string , start , i ) : NEW_LINE INDENT currPart . append ( string [ start : i + 1 ] ) NEW_LINE allPalPartUtil ( allPart , currPart , i + 1 , n , string ) NEW_LINE currPart . pop ( ) NEW_LINE DEDENT DEDENT DEDENT def allPalPartitions ( string : str ) : NEW_LINE INDENT n = len ( string ) NEW_LINE allPart = [ ] NEW_LINE currPart = [ ] NEW_LINE allPalPartUtil ( allPart , currPart , 0 , n , string ) NEW_LINE for i in range ( len ( allPart ) ) : NEW_LINE INDENT for j in range ( len ( allPart [ i ] ) ) : NEW_LINE INDENT print ( allPart [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" nitin \" NEW_LINE allPalPartitions ( string ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC107_B", "sol": 0, "python_code": "h , w = map ( int , input ( ).split ( ) )\nlst = [ ]\nalldot = [ True ] * w\nfor i in range ( h ) :\n    s = input ( )\n    if s.count ( '#' ) >= 1 :\n        lst.append ( s )\n        for t in range ( w ) :\n            alldot [ t ] = alldot [ t ] and s [ t ] == '.'\n    else :\n        h -= 1\nres = [ '' ] * h\nfor i in range ( h ) :\n    for j in range ( w ) :\n        if alldot [ j ] :\n            pass\n        else :\n            res [ i ] += lst [ i ] [ j ]\nfor i in res :\n    print ( i )\n", "python_code_tokenized": "h , w = map ( int , input ( ) . split ( ) ) NEW_LINE lst = [ ] NEW_LINE alldot = [ True ] * w NEW_LINE for i in range ( h ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s . count ( ' # ' ) >= 1 : NEW_LINE INDENT lst . append ( s ) NEW_LINE for t in range ( w ) : NEW_LINE INDENT alldot [ t ] = alldot [ t ] and s [ t ] == ' . ' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT h -= 1 NEW_LINE DEDENT DEDENT res = [ ' ' ] * h NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if alldot [ j ] : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] += lst [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in res : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_468_A", "sol": 0, "python_code": "from math import sqrt\nsz = int ( 1e5 ) ;\nisPrime = [ True ] * ( sz + 1 ) ;\ndef sieve ( ) :\n    isPrime [ 0 ] = isPrime [ 1 ] = False ;\n    for i in range ( 2 , int ( sqrt ( sz ) ) + 1 ) :\n        if ( isPrime [ i ] ) :\n            for j in range ( i * i , sz , i ) :\n                isPrime [ j ] = False ;\ndef minDifference ( L , R ) :\n    fst = 0 ;\n    for i in range ( L , R + 1 ) :\n        if ( isPrime [ i ] ) :\n            fst = i ;\n            break ;\n    snd = 0 ;\n    for i in range ( fst + 1 , R + 1 ) :\n        if ( isPrime [ i ] ) :\n            snd = i ;\n            break ;\n    if ( snd == 0 ) :\n        return - 1 ;\n    diff = snd - fst ;\n    left = snd + 1 ;\n    right = R ;\n    for i in range ( left , right + 1 ) :\n        if ( isPrime [ i ] ) :\n            if ( i - snd <= diff ) :\n                fst = snd ;\n                snd = i ;\n                diff = snd - fst ;\n    return diff ;\nif __name__ == \"__main__\" :\n    sieve ( ) ;\n    L = 21 ; R = 50 ;\n    print ( minDifference ( L , R ) ) ;\n", "python_code_tokenized": "from math import sqrt NEW_LINE sz = int ( 1e5 ) ; NEW_LINE isPrime = [ True ] * ( sz + 1 ) ; NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False ; NEW_LINE for i in range ( 2 , int ( sqrt ( sz ) ) + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , sz , i ) : NEW_LINE INDENT isPrime [ j ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def minDifference ( L , R ) : NEW_LINE INDENT fst = 0 ; NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT fst = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT snd = 0 ; NEW_LINE for i in range ( fst + 1 , R + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT snd = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( snd == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT diff = snd - fst ; NEW_LINE left = snd + 1 ; NEW_LINE right = R ; NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT if ( i - snd <= diff ) : NEW_LINE INDENT fst = snd ; NEW_LINE snd = i ; NEW_LINE diff = snd - fst ; NEW_LINE DEDENT DEDENT DEDENT return diff ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sieve ( ) ; NEW_LINE L = 21 ; R = 50 ; NEW_LINE print ( minDifference ( L , R ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1715_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    a , b = map ( int , input ( ).split ( ) )\n    c = a + b + min ( a , b ) - 2\n    if c == 1 :\n        c = 0\n    print ( c )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = a + b + min ( a , b ) - 2 NEW_LINE if c == 1 : NEW_LINE INDENT c = 0 NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_757_A", "sol": 0, "python_code": "def findMaximum ( l , p , q , r ) :\n    dp = [ - 1 ] * ( l + 1 )\n    dp [ 0 ] = 0\n    for i in range ( l + 1 ) :\n        if ( dp [ i ] == - 1 ) :\n            continue\n        if ( i + p <= l ) :\n            dp [ i + p ] = ( max ( dp [ i + p ] , dp [ i ] + 1 ) )\n        if ( i + q <= l ) :\n            dp [ i + q ] = ( max ( dp [ i + q ] , dp [ i ] + 1 ) )\n        if ( i + r <= l ) :\n            dp [ i + r ] = ( max ( dp [ i + r ] , dp [ i ] + 1 ) )\n    return dp [ l ]\nif __name__ == \"__main__\" :\n    l = 11\n    p = 2\n    q = 3\n    r = 5\n    ans = findMaximum ( l , p , q , r )\n    print ( ans )\n", "python_code_tokenized": "def findMaximum ( l , p , q , r ) : NEW_LINE INDENT dp = [ - 1 ] * ( l + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( l + 1 ) : NEW_LINE INDENT if ( dp [ i ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i + p <= l ) : NEW_LINE INDENT dp [ i + p ] = ( max ( dp [ i + p ] , dp [ i ] + 1 ) ) NEW_LINE DEDENT if ( i + q <= l ) : NEW_LINE INDENT dp [ i + q ] = ( max ( dp [ i + q ] , dp [ i ] + 1 ) ) NEW_LINE DEDENT if ( i + r <= l ) : NEW_LINE INDENT dp [ i + r ] = ( max ( dp [ i + r ] , dp [ i ] + 1 ) ) NEW_LINE DEDENT DEDENT return dp [ l ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 11 NEW_LINE p = 2 NEW_LINE q = 3 NEW_LINE r = 5 NEW_LINE ans = findMaximum ( l , p , q , r ) NEW_LINE print ( ans ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC024_B", "sol": 0, "python_code": "def main ( ) :\n    N = int ( input ( ) )\n    P = [ int ( input ( ) ) for _ in range ( N ) ]\n    editorial ( N , P )\ndef editorial ( N , P ) :\n    if N == 1 :\n        print ( 0 )\n        return\n    a = [ 0 ] * ( N + 1 )\n    for i , p in enumerate ( P ) :\n        a [ p ] = i\n    tmp = 1\n    max_len = 1\n    for i in range ( 1 , N ) :\n        if a [ i ] < a [ i + 1 ] :\n            tmp += 1\n            max_len = max ( max_len , tmp )\n        else :\n            tmp = 1\n    ans = N - max_len\n    print ( ans )\ndef WA ( N , P ) :\n    tmp = 0\n    ans = 0\n    for i , p in enumerate ( P ) :\n        if i == 0 or P [ i - 1 ] + 1 == p :\n            tmp += 1\n        else :\n            ans = max ( ans , tmp )\n            tmp = 1\n    print ( N - ans )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE P = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE editorial ( N , P ) NEW_LINE DEDENT def editorial ( N , P ) : NEW_LINE INDENT if N == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT a = [ 0 ] * ( N + 1 ) NEW_LINE for i , p in enumerate ( P ) : NEW_LINE INDENT a [ p ] = i NEW_LINE DEDENT tmp = 1 NEW_LINE max_len = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if a [ i ] < a [ i + 1 ] : NEW_LINE INDENT tmp += 1 NEW_LINE max_len = max ( max_len , tmp ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp = 1 NEW_LINE DEDENT DEDENT ans = N - max_len NEW_LINE print ( ans ) NEW_LINE DEDENT def WA ( N , P ) : NEW_LINE INDENT tmp = 0 NEW_LINE ans = 0 NEW_LINE for i , p in enumerate ( P ) : NEW_LINE INDENT if i == 0 or P [ i - 1 ] + 1 == p : NEW_LINE INDENT tmp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , tmp ) NEW_LINE tmp = 1 NEW_LINE DEDENT DEDENT print ( N - ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4080_A", "sol": 0, "python_code": "def CalculateRatio ( m , n ) :\n    return ( 2 * m - 1 ) / ( 2 * n - 1 ) ;\nif __name__ == '__main__' :\n    m = 6 ;\n    n = 2 ;\n    print ( float ( CalculateRatio ( m , n ) ) ) ;\n", "python_code_tokenized": "def CalculateRatio ( m , n ) : NEW_LINE INDENT return ( 2 * m - 1 ) / ( 2 * n - 1 ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 6 ; NEW_LINE n = 2 ; NEW_LINE print ( float ( CalculateRatio ( m , n ) ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1259_A", "sol": 0, "python_code": "from math import *\ndef nextPerfectCube ( N ) :\n    nextN = floor ( N ** ( 1 / 3 ) ) + 1\n    return nextN ** 3\nif __name__ == \"__main__\" :\n    n = 35\n    print ( nextPerfectCube ( n ) )\n", "python_code_tokenized": "from math import * NEW_LINE def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = floor ( N ** ( 1 / 3 ) ) + 1 NEW_LINE return nextN ** 3 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 35 NEW_LINE print ( nextPerfectCube ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_760_A", "sol": 0, "python_code": "def modExp ( a , b ) :\n    result = 1\n    while ( b > 0 ) :\n        if ( int ( b ) & 1 ) :\n            result = result * a\n        a = a * a\n        b /= 2\n    return result\ndef check ( num ) :\n    if ( num & 1 or num < 3 ) :\n        return - 1\n    elif ( num % 4 == 0 ) :\n        return modExp ( num / 4 , 4 )\n    elif ( num % 6 == 0 ) :\n        return modExp ( num / 3 , 2 ) * modExp ( num / 6 , 2 )\n    elif ( num % 10 == 0 ) :\n        return modExp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 )\n    else :\n        return - 1\nif __name__ == '__main__' :\n    num = 10\n    print ( int ( check ( num ) ) )\n", "python_code_tokenized": "def modExp ( a , b ) : NEW_LINE INDENT result = 1 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( int ( b ) & 1 ) : NEW_LINE INDENT result = result * a NEW_LINE DEDENT a = a * a NEW_LINE b /= 2 NEW_LINE DEDENT return result NEW_LINE DEDENT def check ( num ) : NEW_LINE INDENT if ( num & 1 or num < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( num % 4 == 0 ) : NEW_LINE INDENT return modExp ( num / 4 , 4 ) NEW_LINE DEDENT elif ( num % 6 == 0 ) : NEW_LINE INDENT return modExp ( num / 3 , 2 ) * modExp ( num / 6 , 2 ) NEW_LINE DEDENT elif ( num % 10 == 0 ) : NEW_LINE INDENT return modExp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 10 NEW_LINE print ( int ( check ( num ) ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1195_A", "sol": 0, "python_code": "n , k = [ int ( i ) for i in input ( ).strip ( ).split ( ) ]\nans = 0\ns = set ( )\nfor i in range ( n ) :\n    drink = int ( input ( ) )\n    if drink in s :\n        ans += 2\n        s.remove ( drink )\n    else :\n        s.add ( drink )\nn = len ( s )\nprint ( ans + n // 2 + n % 2 )\n", "python_code_tokenized": "n , k = [ int ( i ) for i in input ( ) . strip ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT drink = int ( input ( ) ) NEW_LINE if drink in s : NEW_LINE INDENT ans += 2 NEW_LINE s . remove ( drink ) NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( drink ) NEW_LINE DEDENT DEDENT n = len ( s ) NEW_LINE print ( ans + n // 2 + n % 2 ) NEW_LINE"}
{"id": "geeksforgeeks_5143_A", "sol": 0, "python_code": "def Reverseorder ( n ) :\n    prime = [ True ] * ( n + 1 ) ;\n    p = 2 ;\n    while ( p * p <= n ) :\n        if ( prime [ p ] == True ) :\n            for i in range ( ( p * 2 ) , ( n + 1 ) , p ) :\n                prime [ i ] = False ;\n        p += 1 ;\n    for p in range ( n , 1 , - 1 ) :\n        if ( prime [ p ] ) :\n            print ( p , end = \" \" ) ;\nN = 25 ;\nprint ( \"Prime number in reverse order\" ) ;\nif ( N == 1 ) :\n    print ( \"No prime no exist in this range\" ) ;\nelse :\n    Reverseorder ( N ) ;\n", "python_code_tokenized": "def Reverseorder ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( ( p * 2 ) , ( n + 1 ) , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( n , 1 , - 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT print ( p , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT DEDENT N = 25 ; NEW_LINE print ( \" Prime \u2581 number \u2581 in \u2581 reverse \u2581 order \" ) ; NEW_LINE if ( N == 1 ) : NEW_LINE INDENT print ( \" No \u2581 prime \u2581 no \u2581 exist \u2581 in \u2581 this \u2581 range \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT Reverseorder ( N ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2145_A", "sol": 0, "python_code": "def printTwoDivisibleParts ( num , f , s ) :\n    N = len ( num ) ;\n    prefixReminder = [ 0 ] * ( N + 1 ) ;\n    suffixReminder = [ 0 ] * ( N + 1 ) ;\n    for i in range ( 1 , N ) :\n        suffixReminder [ i ] = ( suffixReminder [ i - 1 ] * 10 + ( ord ( num [ i - 1 ] ) - 48 ) ) % f ;\n    base = 1 ;\n    for i in range ( N - 1 , - 1 , - 1 ) :\n        prefixReminder [ i ] = ( prefixReminder [ i + 1 ] + ( ord ( num [ i ] ) - 48 ) * base ) % s ;\n        base = ( base * 10 ) % s ;\n    for i in range ( N ) :\n        if ( prefixReminder [ i ] == 0 and suffixReminder [ i ] == 0 and num [ i ] != '0' ) :\n            print ( num [ 0 : i ] , num [ i : N ] ) ;\n            return 0 ;\n    print ( \"Not Possible\" ) ;\nif __name__ == '__main__' :\n    num = \"246904096\" ;\n    f = 12345 ;\n    s = 1024 ;\n    printTwoDivisibleParts ( num , f , s ) ;\n", "python_code_tokenized": "def printTwoDivisibleParts ( num , f , s ) : NEW_LINE INDENT N = len ( num ) ; NEW_LINE prefixReminder = [ 0 ] * ( N + 1 ) ; NEW_LINE suffixReminder = [ 0 ] * ( N + 1 ) ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT suffixReminder [ i ] = ( suffixReminder [ i - 1 ] * 10 + ( ord ( num [ i - 1 ] ) - 48 ) ) % f ; NEW_LINE DEDENT base = 1 ; NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT prefixReminder [ i ] = ( prefixReminder [ i + 1 ] + ( ord ( num [ i ] ) - 48 ) * base ) % s ; NEW_LINE base = ( base * 10 ) % s ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( prefixReminder [ i ] == 0 and suffixReminder [ i ] == 0 and num [ i ] != '0' ) : NEW_LINE INDENT print ( num [ 0 : i ] , num [ i : N ] ) ; NEW_LINE return 0 ; NEW_LINE DEDENT DEDENT print ( \" Not \u2581 Possible \" ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = \"246904096\" ; NEW_LINE f = 12345 ; NEW_LINE s = 1024 ; NEW_LINE printTwoDivisibleParts ( num , f , s ) ; NEW_LINE DEDENT"}
{"id": "atcoder_ABC151_B", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nx = [ 0 ] * m\ny = [ 0 ] * m\nfor i in range ( m ) :\n    x [ i ] , y [ i ] = input ( ).split ( )\nx = [ int ( l ) for l in x ]\nac = 0\nwa = 0\naclist = [ 0 ] * n\nwalist = [ 0 ] * n\np = [ 0 ] * n\nfor i in range ( m ) :\n    if y [ i ] == 'AC' and p [ x [ i ] - 1 ] == 0 :\n        aclist [ x [ i ] - 1 ] += 1\n        p [ x [ i ] - 1 ] = 1\n    elif y [ i ] == 'WA' and p [ x [ i ] - 1 ] == 0 :\n        walist [ x [ i ] - 1 ] += 1\nfor j in range ( n ) :\n    if 1 == aclist [ j ] :\n        ac += 1\n        wa += walist [ j ]\nprint ( ac , wa )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE x = [ 0 ] * m NEW_LINE y = [ 0 ] * m NEW_LINE for i in range ( m ) : NEW_LINE INDENT x [ i ] , y [ i ] = input ( ) . split ( ) NEW_LINE DEDENT x = [ int ( l ) for l in x ] NEW_LINE ac = 0 NEW_LINE wa = 0 NEW_LINE aclist = [ 0 ] * n NEW_LINE walist = [ 0 ] * n NEW_LINE p = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT if y [ i ] == ' AC ' and p [ x [ i ] - 1 ] == 0 : NEW_LINE INDENT aclist [ x [ i ] - 1 ] += 1 NEW_LINE p [ x [ i ] - 1 ] = 1 NEW_LINE DEDENT elif y [ i ] == ' WA ' and p [ x [ i ] - 1 ] == 0 : NEW_LINE INDENT walist [ x [ i ] - 1 ] += 1 NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT if 1 == aclist [ j ] : NEW_LINE INDENT ac += 1 NEW_LINE wa += walist [ j ] NEW_LINE DEDENT DEDENT print ( ac , wa ) NEW_LINE"}
{"id": "atcoder_ABC178_D", "sol": 0, "python_code": "N = int ( input ( ) )\na = N // 3\nb = N % 3\nmod = 10 ** 9 + 7\nfrom operator import mul\nfrom functools import reduce\ndef cmb ( n , r ) :\n    r = min ( n - r , r )\n    if r == 0 : return 1\n    over = reduce ( mul , range ( n , n - r , - 1 ) )\n    under = reduce ( mul , range ( 1 , r + 1 ) )\n    return over // under\nans = 0\nwhile a >= 1 :\n    ans += cmb ( a - 1 + b , b )\n    a -= 1\n    b += 3\n    if a == 1 :\n        ans += 1\n        break\nprint ( ans % mod )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE a = N // 3 NEW_LINE b = N % 3 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE from operator import mul NEW_LINE from functools import reduce NEW_LINE def cmb ( n , r ) : NEW_LINE INDENT r = min ( n - r , r ) NEW_LINE if r == 0 : return 1 NEW_LINE over = reduce ( mul , range ( n , n - r , - 1 ) ) NEW_LINE under = reduce ( mul , range ( 1 , r + 1 ) ) NEW_LINE return over // under NEW_LINE DEDENT ans = 0 NEW_LINE while a >= 1 : NEW_LINE INDENT ans += cmb ( a - 1 + b , b ) NEW_LINE a -= 1 NEW_LINE b += 3 NEW_LINE if a == 1 : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans % mod ) NEW_LINE"}
{"id": "geeksforgeeks_3732_A", "sol": 0, "python_code": "N = 100005\nlazy = [ 0 ] * ( 4 * N ) ;\nse = set ( )\ndef update ( x , y , value , id , l , r ) :\n    if ( x >= r or l >= y ) :\n        return ;\n    if ( x <= l and r <= y ) :\n        lazy [ id ] = value ;\n        return ;\n    mid = ( l + r ) // 2 ;\n    if ( lazy [ id ] ) :\n        lazy [ 2 * id ] = lazy [ 2 * id + 1 ] = lazy [ id ] ;\n    lazy [ id ] = 0 ;\n    update ( x , y , value , 2 * id , l , mid ) ;\n    update ( x , y , value , 2 * id + 1 , mid , r ) ;\ndef query ( id , l , r ) :\n    if ( lazy [ id ] ) :\n        se.add ( lazy [ id ] ) ;\n        return ;\n    if ( r - l < 2 ) :\n        return ;\n    mid = ( l + r ) // 2 ;\n    query ( 2 * id , l , mid ) ;\n    query ( 2 * id + 1 , mid , r ) ;\nif __name__ == \"__main__\" :\n    n = 5 ; q = 3 ;\n    update ( 1 , 4 , 1 , 1 , 0 , n ) ;\n    update ( 0 , 2 , 2 , 1 , 0 , n ) ;\n    update ( 3 , 4 , 3 , 1 , 0 , n ) ;\n    query ( 1 , 0 , n ) ;\n    print ( len ( se ) ) ;\n", "python_code_tokenized": "N = 100005 NEW_LINE lazy = [ 0 ] * ( 4 * N ) ; NEW_LINE se = set ( ) NEW_LINE def update ( x , y , value , id , l , r ) : NEW_LINE INDENT if ( x >= r or l >= y ) : NEW_LINE INDENT return ; NEW_LINE DEDENT if ( x <= l and r <= y ) : NEW_LINE INDENT lazy [ id ] = value ; NEW_LINE return ; NEW_LINE DEDENT mid = ( l + r ) // 2 ; NEW_LINE if ( lazy [ id ] ) : NEW_LINE INDENT lazy [ 2 * id ] = lazy [ 2 * id + 1 ] = lazy [ id ] ; NEW_LINE DEDENT lazy [ id ] = 0 ; NEW_LINE update ( x , y , value , 2 * id , l , mid ) ; NEW_LINE update ( x , y , value , 2 * id + 1 , mid , r ) ; NEW_LINE DEDENT def query ( id , l , r ) : NEW_LINE INDENT if ( lazy [ id ] ) : NEW_LINE INDENT se . add ( lazy [ id ] ) ; NEW_LINE return ; NEW_LINE DEDENT if ( r - l < 2 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT mid = ( l + r ) // 2 ; NEW_LINE query ( 2 * id , l , mid ) ; NEW_LINE query ( 2 * id + 1 , mid , r ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; q = 3 ; NEW_LINE update ( 1 , 4 , 1 , 1 , 0 , n ) ; NEW_LINE update ( 0 , 2 , 2 , 1 , 0 , n ) ; NEW_LINE update ( 3 , 4 , 3 , 1 , 0 , n ) ; NEW_LINE query ( 1 , 0 , n ) ; NEW_LINE print ( len ( se ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1456_A", "sol": 0, "python_code": "INT_MAX = 32767\ndef eggDrop ( n , k ) :\n    eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ]\n    for i in range ( 1 , n + 1 ) :\n        eggFloor [ i ] [ 1 ] = 1\n        eggFloor [ i ] [ 0 ] = 0\n    for j in range ( 1 , k + 1 ) :\n        eggFloor [ 1 ] [ j ] = j\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( 2 , k + 1 ) :\n            eggFloor [ i ] [ j ] = INT_MAX\n            for x in range ( 1 , j + 1 ) :\n                res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] )\n                if res < eggFloor [ i ] [ j ] :\n                    eggFloor [ i ] [ j ] = res\n    return eggFloor [ n ] [ k ]\nn = 2\nk = 36\nprint ( \"Minimum number of trials in worst case with\" + str ( n ) + \"eggs and \" + str ( k ) + \" floors is \" + str ( eggDrop ( n , k ) ) )\n", "python_code_tokenized": "INT_MAX = 32767 NEW_LINE def eggDrop ( n , k ) : NEW_LINE INDENT eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ 1 ] = 1 NEW_LINE eggFloor [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT eggFloor [ 1 ] [ j ] = j NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 2 , k + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ j ] = INT_MAX NEW_LINE for x in range ( 1 , j + 1 ) : NEW_LINE INDENT res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) NEW_LINE if res < eggFloor [ i ] [ j ] : NEW_LINE INDENT eggFloor [ i ] [ j ] = res NEW_LINE DEDENT DEDENT DEDENT DEDENT return eggFloor [ n ] [ k ] NEW_LINE DEDENT n = 2 NEW_LINE k = 36 NEW_LINE print ( \" Minimum \u2581 number \u2581 of \u2581 trials \u2581 in \u2581 worst \u2581 case \u2581 with \" + str ( n ) + \" eggs \u2581 and \u2581 \" + str ( k ) + \" \u2581 floors \u2581 is \u2581 \" + str ( eggDrop ( n , k ) ) ) NEW_LINE"}
{"id": "aizu_p00263_A", "sol": 0, "python_code": "BIN = [ 0 ] * 32\nv = 1\nfor i in range ( 24 , 0 , - 1 ) :\n    BIN [ i ] = v\n    v *= 2\nv = float ( 1 ) / 2\nfor i in range ( 25 , 32 ) :\n    BIN [ i ] = v\n    v /= 2\nQ = int ( input ( ) )\nfor i in range ( Q ) :\n    inp = format ( int ( input ( ) , 16 ) , 'b' ).zfill ( 32 )\n    res = float ( 0 )\n    for j , v in enumerate ( list ( inp ) [ 1 : ] ) :\n        res += BIN [ j + 1 ] * int ( v )\n    print ( ( '-' if inp [ 0 ] == '1' else '' ) + str ( res ) )\n", "python_code_tokenized": "BIN = [ 0 ] * 32 NEW_LINE v = 1 NEW_LINE for i in range ( 24 , 0 , - 1 ) : NEW_LINE INDENT BIN [ i ] = v NEW_LINE v *= 2 NEW_LINE DEDENT v = float ( 1 ) / 2 NEW_LINE for i in range ( 25 , 32 ) : NEW_LINE INDENT BIN [ i ] = v NEW_LINE v /= 2 NEW_LINE DEDENT Q = int ( input ( ) ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT inp = format ( int ( input ( ) , 16 ) , ' b ' ) . zfill ( 32 ) NEW_LINE res = float ( 0 ) NEW_LINE for j , v in enumerate ( list ( inp ) [ 1 : ] ) : NEW_LINE INDENT res += BIN [ j + 1 ] * int ( v ) NEW_LINE DEDENT print ( ( ' - ' if inp [ 0 ] == '1' else ' ' ) + str ( res ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1579_B", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nfrom collections import deque\nfor _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    w = deque ( map ( int , input ( ).split ( ) ) )\n    d = [ ]\n    for i in range ( n - 1 ) :\n        c = min ( range ( n - i ) , key = lambda x : w [ x ] )\n        w.rotate ( - c )\n        w.popleft ( )\n        if c :\n            d.append ( [ i + 1 , n , c ] )\n    print ( len ( d ) )\n    for i in d :\n        print ( ' '.join ( map ( str , i ) ) )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE from collections import deque NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE w = deque ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT c = min ( range ( n - i ) , key = lambda x : w [ x ] ) NEW_LINE w . rotate ( - c ) NEW_LINE w . popleft ( ) NEW_LINE if c : NEW_LINE INDENT d . append ( [ i + 1 , n , c ] ) NEW_LINE DEDENT DEDENT print ( len ( d ) ) NEW_LINE for i in d : NEW_LINE INDENT print ( ' \u2581 ' . join ( map ( str , i ) ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_358_A", "sol": 0, "python_code": "def minimumChanges ( arr , n , d ) :\n    maxFreq = - 2147483648\n    freq = { }\n    for i in range ( n ) :\n        a0 = arr [ i ] - i * d\n        if a0 in freq :\n            freq [ a0 ] += 1\n        else :\n            freq [ a0 ] = 1\n        if freq [ a0 ] > maxFreq :\n            maxFreq = freq [ a0 ]\n    return ( n - maxFreq )\nn = 5\nd = 1\narr = [ 1 , 3 , 3 , 4 , 6 ]\nans = minimumChanges ( arr , n , d )\nprint ( ans )\n", "python_code_tokenized": "def minimumChanges ( arr , n , d ) : NEW_LINE INDENT maxFreq = - 2147483648 NEW_LINE freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT a0 = arr [ i ] - i * d NEW_LINE if a0 in freq : NEW_LINE INDENT freq [ a0 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a0 ] = 1 NEW_LINE DEDENT if freq [ a0 ] > maxFreq : NEW_LINE INDENT maxFreq = freq [ a0 ] NEW_LINE DEDENT DEDENT return ( n - maxFreq ) NEW_LINE DEDENT n = 5 NEW_LINE d = 1 NEW_LINE arr = [ 1 , 3 , 3 , 4 , 6 ] NEW_LINE ans = minimumChanges ( arr , n , d ) NEW_LINE print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_5038_A", "sol": 0, "python_code": "def findLength ( s , k ) :\n    ans = 10 ** 9\n    l = 0\n    r = 0\n    cnt_zero = 0\n    cnt_one = 0\n    while ( l < len ( s ) and r <= len ( s ) ) :\n        if ( cnt_zero >= k and cnt_one >= 1 ) :\n            ans = min ( ans , r - l )\n            l += 1\n            if ( s [ l - 1 ] == '0' ) :\n                cnt_zero -= 1\n            else :\n                cnt_one -= 1\n        else :\n            if ( r == len ( s ) ) :\n                break\n            if ( s [ r ] == '0' ) :\n                cnt_zero += 1\n            else :\n                cnt_one += 1\n            r += 1\n    if ( ans == 10 ** 9 ) :\n        return - 1\n    return ans\ns = \"100\"\nk = 2\nprint ( findLength ( s , k ) )\n", "python_code_tokenized": "def findLength ( s , k ) : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE cnt_zero = 0 NEW_LINE cnt_one = 0 NEW_LINE while ( l < len ( s ) and r <= len ( s ) ) : NEW_LINE INDENT if ( cnt_zero >= k and cnt_one >= 1 ) : NEW_LINE INDENT ans = min ( ans , r - l ) NEW_LINE l += 1 NEW_LINE if ( s [ l - 1 ] == '0' ) : NEW_LINE INDENT cnt_zero -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( r == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( s [ r ] == '0' ) : NEW_LINE INDENT cnt_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one += 1 NEW_LINE DEDENT r += 1 NEW_LINE DEDENT DEDENT if ( ans == 10 ** 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT s = \"100\" NEW_LINE k = 2 NEW_LINE print ( findLength ( s , k ) ) NEW_LINE"}
{"id": "projecteuler_p092_A", "sol": 0, "python_code": "def compute ( ) :\n    ans = sum ( 1 for i in range ( 1 , 10000000 ) if get_terminal ( i ) == 89 )\n    return str ( ans )\nTERMINALS = ( 1 , 89 )\ndef get_terminal ( n ) :\n    while n not in TERMINALS :\n        n = square_digit_sum ( n )\n    return n\ndef square_digit_sum ( n ) :\n    result = 0\n    while n > 0 :\n        result += SQUARE_DIGITS_SUM [ n % 1000 ]\n        n //= 1000\n    return result\nSQUARE_DIGITS_SUM = [ sum ( int ( c ) ** 2 for c in str ( i ) ) for i in range ( 1000 ) ]\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 , 10000000 ) if get_terminal ( i ) == 89 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT TERMINALS = ( 1 , 89 ) NEW_LINE def get_terminal ( n ) : NEW_LINE INDENT while n not in TERMINALS : NEW_LINE INDENT n = square_digit_sum ( n ) NEW_LINE DEDENT return n NEW_LINE DEDENT def square_digit_sum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE while n > 0 : NEW_LINE INDENT result += SQUARE_DIGITS_SUM [ n % 1000 ] NEW_LINE n //= 1000 NEW_LINE DEDENT return result NEW_LINE DEDENT SQUARE_DIGITS_SUM = [ sum ( int ( c ) ** 2 for c in str ( i ) ) for i in range ( 1000 ) ] NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4434_A", "sol": 0, "python_code": "import sys\nfrom math import sqrt\ndef min_moves ( n ) :\n    ans = sys.maxsize ;\n    for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) :\n        if ( n % i == 0 ) :\n            ans = min ( ans , i + n // i - 2 ) ;\n    return ans ;\nif __name__ == \"__main__\" :\n    n = 10 ;\n    print ( min_moves ( n ) ) ;\n", "python_code_tokenized": "import sys NEW_LINE from math import sqrt NEW_LINE def min_moves ( n ) : NEW_LINE INDENT ans = sys . maxsize ; NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT ans = min ( ans , i + n // i - 2 ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 ; NEW_LINE print ( min_moves ( n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4560_A", "sol": 0, "python_code": "def printArr ( arr , n ) :\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" )\ndef replaceMax ( arr , n ) :\n    max_element = max ( arr )\n    min_element = min ( arr )\n    ranges = max_element - min_element\n    coeffOfRange = ranges / ( max_element + min_element )\n    for i in range ( n ) :\n        if ( arr [ i ] == max_element ) :\n            arr [ i ] = coeffOfRange\n            break\n    printArr ( arr , n )\nif __name__ == \"__main__\" :\n    arr = [ 15 , 16 , 10 , 9 , 6 , 7 , 17 ]\n    n = len ( arr )\n    replaceMax ( arr , n )\n", "python_code_tokenized": "def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT def replaceMax ( arr , n ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE ranges = max_element - min_element NEW_LINE coeffOfRange = ranges / ( max_element + min_element ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == max_element ) : NEW_LINE INDENT arr [ i ] = coeffOfRange NEW_LINE break NEW_LINE DEDENT DEDENT printArr ( arr , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 15 , 16 , 10 , 9 , 6 , 7 , 17 ] NEW_LINE n = len ( arr ) NEW_LINE replaceMax ( arr , n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2045_A", "sol": 0, "python_code": "import numpy as np\nN = 101 ;\nmod = int ( 1e9 ) + 7 ;\nexactsum = np.zeros ( ( N , N , N ) ) ;\nexactnum = np.zeros ( ( N , N , N ) ) ;\ndef getSum ( x , y , z ) :\n    ans = 0 ;\n    exactnum [ 0 ] [ 0 ] [ 0 ] = 1 ;\n    for i in range ( x + 1 ) :\n        for j in range ( y + 1 ) :\n            for k in range ( z + 1 ) :\n                if ( i > 0 ) :\n                    exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod ;\n                    exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod ;\n                if ( j > 0 ) :\n                    exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ;\n                    exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod ;\n                if ( k > 0 ) :\n                    exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod ;\n                    exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod ;\n                ans += exactsum [ i ] [ j ] [ k ] % mod ;\n                ans %= mod ;\n    return ans ;\nif __name__ == \"__main__\" :\n    x = 1 ; y = 1 ; z = 1 ;\n    print ( ( getSum ( x , y , z ) % mod ) ) ;\n", "python_code_tokenized": "import numpy as np NEW_LINE N = 101 ; NEW_LINE mod = int ( 1e9 ) + 7 ; NEW_LINE exactsum = np . zeros ( ( N , N , N ) ) ; NEW_LINE exactnum = np . zeros ( ( N , N , N ) ) ; NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 ; NEW_LINE exactnum [ 0 ] [ 0 ] [ 0 ] = 1 ; NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT for k in range ( z + 1 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod ; NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod ; NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod ; NEW_LINE DEDENT ans += exactsum [ i ] [ j ] [ k ] % mod ; NEW_LINE ans %= mod ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 1 ; y = 1 ; z = 1 ; NEW_LINE print ( ( getSum ( x , y , z ) % mod ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_550_A", "sol": 0, "python_code": "import math\ndef factorize ( n ) :\n    count = 0 ;\n    while ( ( n % 2 > 0 ) == False ) :\n        n >>= 1 ;\n        count += 1 ;\n    if ( count > 0 ) :\n        print ( 2 , count ) ;\n    for i in range ( 3 , int ( math.sqrt ( n ) ) + 1 ) :\n        count = 0 ;\n        while ( n % i == 0 ) :\n            count += 1 ;\n            n = int ( n / i ) ;\n        if ( count > 0 ) :\n            print ( i , count ) ;\n        i += 2 ;\n    if ( n > 2 ) :\n        print ( n , 1 ) ;\nn = 1000000000000000000 ;\nfactorize ( n ) ;\n", "python_code_tokenized": "import math NEW_LINE def factorize ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( ( n % 2 > 0 ) == False ) : NEW_LINE INDENT n >>= 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT print ( 2 , count ) ; NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n = int ( n / i ) ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT print ( i , count ) ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( n , 1 ) ; NEW_LINE DEDENT DEDENT n = 1000000000000000000 ; NEW_LINE factorize ( n ) ; NEW_LINE"}
{"id": "codeforces_1474_B", "sol": 0, "python_code": "N = 8 ** 5\na = [ 1 ] * N\ni = 2\nwhile i * i < N : a [ i * i : : i ] = [ 0 ] * - ( - N // i + i ) ; i += 1\nfor s in [ * open ( 0 ) ] [ 1 : ] : d = int ( s ) ; i = a.index ( 1 , d + 1 ) ; print ( i * a.index ( 1 , i + d ) )\n", "python_code_tokenized": "N = 8 ** 5 NEW_LINE a = [ 1 ] * N NEW_LINE i = 2 NEW_LINE while i * i < N : a [ i * i : : i ] = [ 0 ] * - ( - N // i + i ) ; i += 1 NEW_LINE for s in [ * open ( 0 ) ] [ 1 : ] : d = int ( s ) ; i = a . index ( 1 , d + 1 ) ; print ( i * a . index ( 1 , i + d ) ) NEW_LINE"}
{"id": "codeforces_1033_A", "sol": 0, "python_code": "x = int ( input ( ) )\na , a1 = map ( int , input ( ).split ( ) )\nb , b1 = map ( int , input ( ).split ( ) )\nc , c1 = map ( int , input ( ).split ( ) )\nif ( c + c1 == a + a1 ) :\n    print ( 'NO' )\nelif ( c / c1 == a / a1 ) :\n    print ( 'NO' )\nelif ( ( c - a ) // abs ( c - a ) != ( b - a ) // abs ( b - a ) ) or ( ( c1 - a1 ) // abs ( c1 - a1 ) != ( b1 - a1 ) // abs ( b1 - a1 ) ) :\n    print ( 'NO' )\nelse :\n    print ( 'YES' )\n", "python_code_tokenized": "x = int ( input ( ) ) NEW_LINE a , a1 = map ( int , input ( ) . split ( ) ) NEW_LINE b , b1 = map ( int , input ( ) . split ( ) ) NEW_LINE c , c1 = map ( int , input ( ) . split ( ) ) NEW_LINE if ( c + c1 == a + a1 ) : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT elif ( c / c1 == a / a1 ) : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT elif ( ( c - a ) // abs ( c - a ) != ( b - a ) // abs ( b - a ) ) or ( ( c1 - a1 ) // abs ( c1 - a1 ) != ( b1 - a1 ) // abs ( b1 - a1 ) ) : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_577_A", "sol": 0, "python_code": "def rainDayProbability ( a , n ) :\n    count = a.count ( 1 )\n    m = count / n\n    return m\nif __name__ == \"__main__\" :\n    a = [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ]\n    n = len ( a )\n    print ( rainDayProbability ( a , n ) )\n", "python_code_tokenized": "def rainDayProbability ( a , n ) : NEW_LINE INDENT count = a . count ( 1 ) NEW_LINE m = count / n NEW_LINE return m NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( rainDayProbability ( a , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_324_A", "sol": 0, "python_code": "def possible ( n ) :\n    if ( n > 3 ) :\n        sum = ( n * ( n + 1 ) ) // 2 ;\n        if ( sum % 3 == 0 ) :\n            return True ;\n    return False ;\nif __name__ == \"__main__\" :\n    n = 5 ;\n    if ( possible ( n ) ) :\n        print ( \"Yes\" ) ;\n    else :\n        print ( \"No\" ) ;\n", "python_code_tokenized": "def possible ( n ) : NEW_LINE INDENT if ( n > 3 ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) ) // 2 ; NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE if ( possible ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "codejam_12_41", "sol": 0, "python_code": "from collections import deque\nimport sys\nfin = sys.stdin\nT = int ( fin.readline ( ) )\nfor case in range ( 1 , T + 1 ) :\n    N = int ( fin.readline ( ) )\n    vines = [ ]\n    for i in range ( N ) :\n        di , li = map ( int , fin.readline ( ).split ( ) )\n        vines.append ( ( di , li ) )\n    D = int ( fin.readline ( ) )\n    vines.append ( ( D , 0 ) )\n    queue = deque ( [ ( vines [ 0 ] [ 0 ] , vines [ 0 ] [ 0 ] * 2 ) ] )\n    for d , l in vines [ 1 : ] :\n        while queue and queue [ 0 ] [ 1 ] < d :\n            queue.popleft ( )\n        if not queue :\n            break\n        distance = min ( l , d - queue [ 0 ] [ 0 ] )\n        p = d + distance\n        if p > queue [ - 1 ] [ 1 ] :\n            queue.append ( ( d , p ) )\n    success = bool ( queue )\n    print ( \"Case #%d: %s\" % ( case , success and \"YES\" or \"NO\" ) )\n", "python_code_tokenized": "from collections import deque NEW_LINE import sys NEW_LINE fin = sys . stdin NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = int ( fin . readline ( ) ) NEW_LINE vines = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT di , li = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE vines . append ( ( di , li ) ) NEW_LINE DEDENT D = int ( fin . readline ( ) ) NEW_LINE vines . append ( ( D , 0 ) ) NEW_LINE queue = deque ( [ ( vines [ 0 ] [ 0 ] , vines [ 0 ] [ 0 ] * 2 ) ] ) NEW_LINE for d , l in vines [ 1 : ] : NEW_LINE INDENT while queue and queue [ 0 ] [ 1 ] < d : NEW_LINE INDENT queue . popleft ( ) NEW_LINE DEDENT if not queue : NEW_LINE INDENT break NEW_LINE DEDENT distance = min ( l , d - queue [ 0 ] [ 0 ] ) NEW_LINE p = d + distance NEW_LINE if p > queue [ - 1 ] [ 1 ] : NEW_LINE INDENT queue . append ( ( d , p ) ) NEW_LINE DEDENT DEDENT success = bool ( queue ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( case , success and \" YES \" or \" NO \" ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4543_A", "sol": 0, "python_code": "def display ( ) :\n    n = 5\n    space = n // 2\n    num = 1\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , space + 1 ) :\n            print ( \"\" , end = \"\" )\n        count = num // 2 + 1\n        for k in range ( 1 , num + 1 ) :\n            print ( count , end = \"\" )\n            if ( k <= num // 2 ) :\n                count = count - 1\n            else :\n                count = count + 1\n        print ( )\n        if ( i <= n // 2 ) :\n            space = space - 1\n            num = num + 2\n        else :\n            space = space + 1\n            num = num - 2\ndisplay ( )\n", "python_code_tokenized": "def display ( ) : NEW_LINE INDENT n = 5 NEW_LINE space = n // 2 NEW_LINE num = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , space + 1 ) : NEW_LINE INDENT print ( \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT count = num // 2 + 1 NEW_LINE for k in range ( 1 , num + 1 ) : NEW_LINE INDENT print ( count , end = \" \" ) NEW_LINE if ( k <= num // 2 ) : NEW_LINE INDENT count = count - 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT print ( ) NEW_LINE if ( i <= n // 2 ) : NEW_LINE INDENT space = space - 1 NEW_LINE num = num + 2 NEW_LINE DEDENT else : NEW_LINE INDENT space = space + 1 NEW_LINE num = num - 2 NEW_LINE DEDENT DEDENT DEDENT display ( ) NEW_LINE"}
{"id": "geeksforgeeks_4330_A", "sol": 0, "python_code": "def getMin ( arr , n ) :\n    return min ( arr )\ndef getMax ( arr , n ) :\n    return max ( arr )\nif __name__ == '__main__' :\n    arr = [ 12 , 1234 , 45 , 67 , 1 ]\n    n = len ( arr )\n    print ( \"Minimum element of array: \" , getMin ( arr , n ) )\n    print ( \"Maximum element of array: \" , getMax ( arr , n ) )\n", "python_code_tokenized": "def getMin ( arr , n ) : NEW_LINE INDENT return min ( arr ) NEW_LINE DEDENT def getMax ( arr , n ) : NEW_LINE INDENT return max ( arr ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 1234 , 45 , 67 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum \u2581 element \u2581 of \u2581 array : \u2581 \" , getMin ( arr , n ) ) NEW_LINE print ( \" Maximum \u2581 element \u2581 of \u2581 array : \u2581 \" , getMax ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00803_A", "sol": 0, "python_code": "while True :\n    balls = int ( input ( ) )\n    ans = 0\n    if balls == 0 :\n        break\n    for cs in range ( 54 ) :\n        for ts in range ( 96 ) :\n            if pow ( cs , 3 ) <= balls :\n                ans = max ( ans , pow ( cs , 3 ) )\n            if ts * ( ts + 1 ) * ( ts + 2 ) // 6 <= balls :\n                ans = max ( ans , ts * ( ts + 1 ) * ( ts + 2 ) // 6 )\n            if pow ( cs , 3 ) + ts * ( ts + 1 ) * ( ts + 2 ) // 6 <= balls :\n                ans = max ( ans , pow ( cs , 3 ) + ts * ( ts + 1 ) * ( ts + 2 ) // 6 )\n    print ( ans )\n", "python_code_tokenized": "while True : NEW_LINE INDENT balls = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE if balls == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for cs in range ( 54 ) : NEW_LINE INDENT for ts in range ( 96 ) : NEW_LINE INDENT if pow ( cs , 3 ) <= balls : NEW_LINE INDENT ans = max ( ans , pow ( cs , 3 ) ) NEW_LINE DEDENT if ts * ( ts + 1 ) * ( ts + 2 ) // 6 <= balls : NEW_LINE INDENT ans = max ( ans , ts * ( ts + 1 ) * ( ts + 2 ) // 6 ) NEW_LINE DEDENT if pow ( cs , 3 ) + ts * ( ts + 1 ) * ( ts + 2 ) // 6 <= balls : NEW_LINE INDENT ans = max ( ans , pow ( cs , 3 ) + ts * ( ts + 1 ) * ( ts + 2 ) // 6 ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1356_A", "sol": 0, "python_code": "from math import gcd\ndef MaxLCM ( n ) :\n    if ( n % 2 != 0 ) :\n        print ( n , ( n - 1 ) , ( n - 2 ) )\n    elif ( gcd ( n , ( n - 3 ) ) == 1 ) :\n        print ( n , ( n - 1 ) , ( n - 3 ) )\n    else :\n        print ( ( n - 1 ) , ( n - 2 ) , ( n - 3 ) )\nif __name__ == \"__main__\" :\n    n = 12\n    MaxLCM ( n )\n", "python_code_tokenized": "from math import gcd NEW_LINE def MaxLCM ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( n , ( n - 1 ) , ( n - 2 ) ) NEW_LINE DEDENT elif ( gcd ( n , ( n - 3 ) ) == 1 ) : NEW_LINE INDENT print ( n , ( n - 1 ) , ( n - 3 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n - 1 ) , ( n - 2 ) , ( n - 3 ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 12 NEW_LINE MaxLCM ( n ) NEW_LINE DEDENT"}
{"id": "codeforces_660_B", "sol": 0, "python_code": "from itertools import zip_longest as zl\nn , m = map ( int , input ( ).split ( ) )\nif m - n * 2 <= 0 :\n    wind = list ( range ( 1 , m + 1 ) )\n    prh = [ ]\nelse :\n    man = range ( 1 , m + 1 )\n    wind = list ( man [ : n * 2 ] )\n    prh = list ( man [ n * 2 : ] )\nfor a , b in zl ( prh , wind , fillvalue = '' ) :\n    print ( str ( a ) + ' ' + str ( b ) , end = ' ' )\n", "python_code_tokenized": "from itertools import zip_longest as zl NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m - n * 2 <= 0 : NEW_LINE INDENT wind = list ( range ( 1 , m + 1 ) ) NEW_LINE prh = [ ] NEW_LINE DEDENT else : NEW_LINE INDENT man = range ( 1 , m + 1 ) NEW_LINE wind = list ( man [ : n * 2 ] ) NEW_LINE prh = list ( man [ n * 2 : ] ) NEW_LINE DEDENT for a , b in zl ( prh , wind , fillvalue = ' ' ) : NEW_LINE INDENT print ( str ( a ) + ' \u2581 ' + str ( b ) , end = ' \u2581 ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1485_A", "sol": 0, "python_code": "import sys\ndef findElements ( arr , n ) :\n    first = - sys.maxsize\n    second = - sys.maxsize\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] > first ) :\n            second = first\n            first = arr [ i ]\n        elif ( arr [ i ] > second ) :\n            second = arr [ i ]\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] < second ) :\n            print ( arr [ i ] , end = \" \" )\narr = [ 2 , - 6 , 3 , 5 , 1 ]\nn = len ( arr )\nfindElements ( arr , n )\n", "python_code_tokenized": "import sys NEW_LINE def findElements ( arr , n ) : NEW_LINE INDENT first = - sys . maxsize NEW_LINE second = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < second ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_5092_A", "sol": 0, "python_code": "import math\nclass Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.next = None\ndef push ( head_ref , new_data ) :\n    new_node = Node ( new_data )\n    new_node.data = new_data\n    new_node.next = head_ref\n    head_ref = new_node\n    return head_ref\ndef isPrime ( n ) :\n    if ( n <= 1 ) :\n        return False\n    if ( n <= 3 ) :\n        return True\n    if ( n % 2 == 0 or n % 3 == 0 ) :\n        return False\n    for i in range ( 5 , n + 1 , 6 ) :\n        if ( i * i < n + 2 and ( n % i == 0 or n % ( i + 2 ) == 0 ) ) :\n            return False\n    return True\ndef deleteNonPrimeNodes ( head_ref ) :\n    ptr = head_ref\n    while ( ptr != None and isPrime ( ptr.data ) != True ) :\n        temp = ptr\n        ptr = ptr.next\n    head_ref = ptr\n    if ( ptr == None ) :\n        return None\n    curr = ptr.next\n    while ( curr != None ) :\n        if ( isPrime ( curr.data ) != True ) :\n            ptr.next = curr.next\n            curr = ptr.next\n        else :\n            ptr = curr\n            curr = curr.next\n        return head_ref\ndef printList ( head ) :\n    while ( head != None ) :\n        print ( head.data , end = \" \" )\n        head = head.next\nif __name__ == '__main__' :\n    head = None\n    head = push ( head , 17 )\n    head = push ( head , 7 )\n    head = push ( head , 6 )\n    head = push ( head , 16 )\n    head = push ( head , 15 )\n    print ( \"Original List: \" )\n    printList ( head )\n    head = deleteNonPrimeNodes ( head )\n    print ( \"\\nModified List: \" )\n    printList ( head )\n", "python_code_tokenized": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , n + 1 , 6 ) : NEW_LINE INDENT if ( i * i < n + 2 and ( n % i == 0 or n % ( i + 2 ) == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def deleteNonPrimeNodes ( head_ref ) : NEW_LINE INDENT ptr = head_ref NEW_LINE while ( ptr != None and isPrime ( ptr . data ) != True ) : NEW_LINE INDENT temp = ptr NEW_LINE ptr = ptr . next NEW_LINE DEDENT head_ref = ptr NEW_LINE if ( ptr == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT curr = ptr . next NEW_LINE while ( curr != None ) : NEW_LINE INDENT if ( isPrime ( curr . data ) != True ) : NEW_LINE INDENT ptr . next = curr . next NEW_LINE curr = ptr . next NEW_LINE DEDENT else : NEW_LINE INDENT ptr = curr NEW_LINE curr = curr . next NEW_LINE DEDENT return head_ref NEW_LINE DEDENT DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" \u2581 \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 17 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 16 ) NEW_LINE head = push ( head , 15 ) NEW_LINE print ( \" Original \u2581 List : \u2581 \" ) NEW_LINE printList ( head ) NEW_LINE head = deleteNonPrimeNodes ( head ) NEW_LINE print ( \" \\n Modified \u2581 List : \u2581 \" ) NEW_LINE printList ( head ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4950_A", "sol": 0, "python_code": "def lenghtOfLongestAP ( set , n ) :\n    if ( n <= 2 ) :\n        return n\n    L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    llap = 2\n    for i in range ( n ) :\n        L [ i ] [ n - 1 ] = 2\n    for j in range ( n - 2 , 0 , - 1 ) :\n        i = j - 1\n        k = j + 1\n        while ( i >= 0 and k <= n - 1 ) :\n            if ( set [ i ] + set [ k ] < 2 * set [ j ] ) :\n                k += 1\n            elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) :\n                L [ i ] [ j ] = 2\n                i -= 1\n            else :\n                L [ i ] [ j ] = L [ j ] [ k ] + 1\n                llap = max ( llap , L [ i ] [ j ] )\n                i -= 1\n                k += 1\n                while ( i >= 0 ) :\n                    L [ i ] [ j ] = 2\n                    i -= 1\n    return llap\nif __name__ == \"__main__\" :\n    set1 = [ 1 , 7 , 10 , 13 , 14 , 19 ]\n    n1 = len ( set1 )\n    print ( lenghtOfLongestAP ( set1 , n1 ) )\n    set2 = [ 1 , 7 , 10 , 15 , 27 , 29 ]\n    n2 = len ( set2 )\n    print ( lenghtOfLongestAP ( set2 , n2 ) )\n    set3 = [ 2 , 4 , 6 , 8 , 10 ]\n    n3 = len ( set3 )\n    print ( lenghtOfLongestAP ( set3 , n3 ) )\n", "python_code_tokenized": "def lenghtOfLongestAP ( set , n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE llap = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE DEDENT for j in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT if ( set [ i ] + set [ k ] < 2 * set [ j ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1 NEW_LINE llap = max ( llap , L [ i ] [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return llap NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT set1 = [ 1 , 7 , 10 , 13 , 14 , 19 ] NEW_LINE n1 = len ( set1 ) NEW_LINE print ( lenghtOfLongestAP ( set1 , n1 ) ) NEW_LINE set2 = [ 1 , 7 , 10 , 15 , 27 , 29 ] NEW_LINE n2 = len ( set2 ) NEW_LINE print ( lenghtOfLongestAP ( set2 , n2 ) ) NEW_LINE set3 = [ 2 , 4 , 6 , 8 , 10 ] NEW_LINE n3 = len ( set3 ) NEW_LINE print ( lenghtOfLongestAP ( set3 , n3 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1968_A", "sol": 0, "python_code": "def isPowerOfTwo ( x ) :\n    return ( x and ( not ( x & ( x - 1 ) ) ) )\ndef Count_pairs ( a , n ) :\n    count = 0\n    for i in range ( n ) :\n        if isPowerOfTwo ( a [ i ] ) :\n            count += 1\n    ans = ( count * ( count - 1 ) ) / 2\n    print ( ans )\nif __name__ == \"__main__\" :\n    a = [ 2 , 5 , 8 , 16 , 128 ]\n    n = len ( a )\n    Count_pairs ( a , n )\n", "python_code_tokenized": "def isPowerOfTwo ( x ) : NEW_LINE INDENT return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE DEDENT def Count_pairs ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if isPowerOfTwo ( a [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = ( count * ( count - 1 ) ) / 2 NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 5 , 8 , 16 , 128 ] NEW_LINE n = len ( a ) NEW_LINE Count_pairs ( a , n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4137_A", "sol": 0, "python_code": "def countSetBits ( n ) :\n    count = 0\n    while ( n ) :\n        count += n & 1\n        n >>= 1\n    return count\ndef totalPairs ( s1 , s2 ) :\n    count = 0 ;\n    arr1 = [ 0 ] * 7 ; arr2 = [ 0 ] * 7 ;\n    for i in range ( len ( s1 ) ) :\n        set_bits = countSetBits ( ord ( s1 [ i ] ) )\n        arr1 [ set_bits ] += 1 ;\n    for i in range ( len ( s2 ) ) :\n        set_bits = countSetBits ( ord ( s2 [ i ] ) ) ;\n        arr2 [ set_bits ] += 1 ;\n    for i in range ( 1 , 7 ) :\n        count += ( arr1 [ i ] * arr2 [ i ] ) ;\n    return count ;\nif __name__ == \"__main__\" :\n    s1 = \"geeks\" ;\n    s2 = \"forgeeks\" ;\n    print ( totalPairs ( s1 , s2 ) ) ;\n", "python_code_tokenized": "def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE arr1 = [ 0 ] * 7 ; arr2 = [ 0 ] * 7 ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s1 [ i ] ) ) NEW_LINE arr1 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s2 [ i ] ) ) ; NEW_LINE arr2 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( 1 , 7 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeks \" ; NEW_LINE s2 = \" forgeeks \" ; NEW_LINE print ( totalPairs ( s1 , s2 ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_750_B", "sol": 0, "python_code": "x = int ( input ( ) )\nN , S = 0 , 0\npo = 0\nc = \"YES\"\nfor i in range ( x ) :\n    p = list ( input ( ).split ( ) )\n    if N == 0 and S == 0 :\n        if p [ 1 ] != \"South\" :\n            c = \"NO\"\n            break\n    if S - N == 20000 :\n        if p [ 1 ] != \"North\" :\n            c = \"NO\"\n            break\n    if p [ 1 ] == \"North\" :\n        po = po - int ( p [ 0 ] )\n        N += int ( p [ 0 ] )\n        if po < 0 :\n            c = \"NO\"\n            break\n    elif p [ 1 ] == \"South\" :\n        S += int ( p [ 0 ] )\n        po = po + int ( p [ 0 ] )\n        if po > 20000 :\n            c = \"N0\"\n            break\n    if N == S : N , S = 0 , 0\nif N != S : c = \"NO\"\nprint ( c )\n", "python_code_tokenized": "x = int ( input ( ) ) NEW_LINE N , S = 0 , 0 NEW_LINE po = 0 NEW_LINE c = \" YES \" NEW_LINE for i in range ( x ) : NEW_LINE INDENT p = list ( input ( ) . split ( ) ) NEW_LINE if N == 0 and S == 0 : NEW_LINE INDENT if p [ 1 ] != \" South \" : NEW_LINE INDENT c = \" NO \" NEW_LINE break NEW_LINE DEDENT DEDENT if S - N == 20000 : NEW_LINE INDENT if p [ 1 ] != \" North \" : NEW_LINE INDENT c = \" NO \" NEW_LINE break NEW_LINE DEDENT DEDENT if p [ 1 ] == \" North \" : NEW_LINE INDENT po = po - int ( p [ 0 ] ) NEW_LINE N += int ( p [ 0 ] ) NEW_LINE if po < 0 : NEW_LINE INDENT c = \" NO \" NEW_LINE break NEW_LINE DEDENT DEDENT elif p [ 1 ] == \" South \" : NEW_LINE INDENT S += int ( p [ 0 ] ) NEW_LINE po = po + int ( p [ 0 ] ) NEW_LINE if po > 20000 : NEW_LINE INDENT c = \" N0\" NEW_LINE break NEW_LINE DEDENT DEDENT if N == S : N , S = 0 , 0 NEW_LINE DEDENT if N != S : c = \" NO \" NEW_LINE print ( c ) NEW_LINE"}
{"id": "codeforces_639_B", "sol": 0, "python_code": "n , d , h = map ( int , input ( ).split ( ) )\nif d > 2 * h or ( d == 1 and n > 2 ) :\n    print ( - 1 )\nelif d == h :\n    for i in range ( 1 , d + 1 ) :\n        print ( i , i + 1 )\n    for i in range ( d + 2 , n + 1 ) :\n        print ( 2 , i )\nelse :\n    for i in range ( 2 , h + 2 ) :\n        print ( i - 1 , i )\n    print ( 1 , h + 2 )\n    for i in range ( h + 3 , d + 2 ) :\n        print ( i - 1 , i )\n    for i in range ( d + 2 , n + 1 ) :\n        print ( 1 , i )\n", "python_code_tokenized": "n , d , h = map ( int , input ( ) . split ( ) ) NEW_LINE if d > 2 * h or ( d == 1 and n > 2 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif d == h : NEW_LINE INDENT for i in range ( 1 , d + 1 ) : NEW_LINE INDENT print ( i , i + 1 ) NEW_LINE DEDENT for i in range ( d + 2 , n + 1 ) : NEW_LINE INDENT print ( 2 , i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 2 , h + 2 ) : NEW_LINE INDENT print ( i - 1 , i ) NEW_LINE DEDENT print ( 1 , h + 2 ) NEW_LINE for i in range ( h + 3 , d + 2 ) : NEW_LINE INDENT print ( i - 1 , i ) NEW_LINE DEDENT for i in range ( d + 2 , n + 1 ) : NEW_LINE INDENT print ( 1 , i ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00149_A", "sol": 0, "python_code": "import sys\nBASE = [ 1.1 , 0.6 , 0.2 , 0.0 ]\nCOUNT = len ( BASE )\ndef eye_test ( num ) :\n    for index , parameter in enumerate ( BASE ) :\n        if parameter <= num :\n            return index\nleft_counter = [ 0 ] * COUNT\nright_counter = [ 0 ] * COUNT\nfor line in sys.stdin :\n    left , right = [ float ( item ) for item in line [ : - 1 ].split ( \" \" ) ]\n    left_eye , right_eye = eye_test ( left ) , eye_test ( right )\n    left_counter [ left_eye ] += 1\n    right_counter [ right_eye ] += 1\nfor item1 , item2 in zip ( left_counter , right_counter ) :\n    print ( item1 , item2 )\n", "python_code_tokenized": "import sys NEW_LINE BASE = [ 1.1 , 0.6 , 0.2 , 0.0 ] NEW_LINE COUNT = len ( BASE ) NEW_LINE def eye_test ( num ) : NEW_LINE INDENT for index , parameter in enumerate ( BASE ) : NEW_LINE INDENT if parameter <= num : NEW_LINE INDENT return index NEW_LINE DEDENT DEDENT DEDENT left_counter = [ 0 ] * COUNT NEW_LINE right_counter = [ 0 ] * COUNT NEW_LINE for line in sys . stdin : NEW_LINE INDENT left , right = [ float ( item ) for item in line [ : - 1 ] . split ( \" \u2581 \" ) ] NEW_LINE left_eye , right_eye = eye_test ( left ) , eye_test ( right ) NEW_LINE left_counter [ left_eye ] += 1 NEW_LINE right_counter [ right_eye ] += 1 NEW_LINE DEDENT for item1 , item2 in zip ( left_counter , right_counter ) : NEW_LINE INDENT print ( item1 , item2 ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC055_D", "sol": 0, "python_code": "import sys\nsys.setrecursionlimit ( 10 ** 9 )\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\ninput = lambda : sys.stdin.readline ( ).rstrip ( )\nYesNo = lambda b : bool ( [ print ( 'Yes' ) ] if b else print ( 'No' ) )\nYESNO = lambda b : bool ( [ print ( 'YES' ) ] if b else print ( 'NO' ) )\nint1 = lambda x : int ( x ) - 1\ndef main ( ) :\n    N = int ( input ( ) )\n    s = input ( )\n    s = s + s [ 0 ]\n    for j in range ( 4 ) :\n        l = [ - 1 ] * ( N + 2 )\n        for k in range ( 2 ) :\n            l [ k ] = ( j >> k ) & 1\n        for i in range ( 1 , N + 1 ) :\n            if l [ i ] == 0 :\n                if s [ i - 1 ] == 'o' :\n                    l [ i + 1 ] = l [ i - 1 ]\n                else :\n                    l [ i + 1 ] = int ( not l [ i - 1 ] )\n            else :\n                if s [ i - 1 ] == 'o' :\n                    l [ i + 1 ] = int ( not l [ i - 1 ] )\n                else :\n                    l [ i + 1 ] = l [ i - 1 ]\n        if l [ 0 ] == l [ - 2 ] and l [ 1 ] == l [ - 1 ] :\n            for x in l [ 1 : N + 1 ] :\n                if x == 0 :\n                    print ( 'S' , end = '' )\n                else :\n                    print ( 'W' , end = '' )\n            print ( '' )\n            exit ( )\n    print ( - 1 )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE YesNo = lambda b : bool ( [ print ( ' Yes ' ) ] if b else print ( ' No ' ) ) NEW_LINE YESNO = lambda b : bool ( [ print ( ' YES ' ) ] if b else print ( ' NO ' ) ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE s = s + s [ 0 ] NEW_LINE for j in range ( 4 ) : NEW_LINE INDENT l = [ - 1 ] * ( N + 2 ) NEW_LINE for k in range ( 2 ) : NEW_LINE INDENT l [ k ] = ( j >> k ) & 1 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if l [ i ] == 0 : NEW_LINE INDENT if s [ i - 1 ] == ' o ' : NEW_LINE INDENT l [ i + 1 ] = l [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT l [ i + 1 ] = int ( not l [ i - 1 ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if s [ i - 1 ] == ' o ' : NEW_LINE INDENT l [ i + 1 ] = int ( not l [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT l [ i + 1 ] = l [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT if l [ 0 ] == l [ - 2 ] and l [ 1 ] == l [ - 1 ] : NEW_LINE INDENT for x in l [ 1 : N + 1 ] : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT print ( ' S ' , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' W ' , end = ' ' ) NEW_LINE DEDENT DEDENT print ( ' ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_473_A", "sol": 0, "python_code": "from math import sqrt\nMAX = 10000\nprefix = [ 0 for i in range ( MAX + 1 ) ]\ndef buildPrefix ( ) :\n    prime = [ True for i in range ( MAX + 1 ) ]\n    for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) :\n        if ( prime [ p ] == True ) :\n            for i in range ( p * 2 , MAX + 1 , p ) :\n                prime [ i ] = False\n    prefix [ 0 ] = 0\n    prefix [ 1 ] = 0\n    for p in range ( 2 , MAX + 1 , 1 ) :\n        prefix [ p ] = prefix [ p - 1 ]\n        if ( prime [ p ] ) :\n            prefix [ p ] += p\ndef sumPrimeRange ( L , R ) :\n    buildPrefix ( )\n    return prefix [ R ] - prefix [ L - 1 ]\nif __name__ == '__main__' :\n    L = 10\n    R = 20\n    print ( sumPrimeRange ( L , R ) )\n", "python_code_tokenized": "from math import sqrt NEW_LINE MAX = 10000 NEW_LINE prefix = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def buildPrefix ( ) : NEW_LINE INDENT prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT prefix [ 0 ] = 0 NEW_LINE prefix [ 1 ] = 0 NEW_LINE for p in range ( 2 , MAX + 1 , 1 ) : NEW_LINE INDENT prefix [ p ] = prefix [ p - 1 ] NEW_LINE if ( prime [ p ] ) : NEW_LINE INDENT prefix [ p ] += p NEW_LINE DEDENT DEDENT DEDENT def sumPrimeRange ( L , R ) : NEW_LINE INDENT buildPrefix ( ) NEW_LINE return prefix [ R ] - prefix [ L - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 10 NEW_LINE R = 20 NEW_LINE print ( sumPrimeRange ( L , R ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1821_A", "sol": 0, "python_code": "def decToOctal ( n ) :\n    octalNum = [ 0 ] * 100 ;\n    i = 0 ;\n    while ( n != 0 ) :\n        octalNum [ i ] = n % 8 ;\n        n = int ( n / 8 ) ;\n        i += 1 ;\n    for j in range ( i - 1 , - 1 , - 1 ) :\n        print ( octalNum [ j ] , end = \"\" ) ;\nn = 33 ;\ndecToOctal ( n ) ;\n", "python_code_tokenized": "def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octalNum [ i ] = n % 8 ; NEW_LINE n = int ( n / 8 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT n = 33 ; NEW_LINE decToOctal ( n ) ; NEW_LINE"}
{"id": "geeksforgeeks_548_A", "sol": 0, "python_code": "def printPFsInPairs ( n ) :\n    for i in range ( 1 , int ( pow ( n , 1 / 2 ) ) + 1 ) :\n        if n % i == 0 :\n            print ( str ( i ) + \"*\" + str ( int ( n / i ) ) )\nn = 24\nprintPFsInPairs ( n )\n", "python_code_tokenized": "def printPFsInPairs ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( pow ( n , 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT print ( str ( i ) + \" * \" + str ( int ( n / i ) ) ) NEW_LINE DEDENT DEDENT DEDENT n = 24 NEW_LINE printPFsInPairs ( n ) NEW_LINE"}
{"id": "geeksforgeeks_4376_A", "sol": 0, "python_code": "def findBalance ( x , bal ) :\n    if ( x % 10 == 0 and ( x + 1.50 ) <= bal ) :\n        print ( round ( bal - x - 1.50 , 2 ) )\n    else :\n        print ( round ( bal , 2 ) )\nx = 50\nbal = 100.50\nfindBalance ( x , bal )\n", "python_code_tokenized": "def findBalance ( x , bal ) : NEW_LINE INDENT if ( x % 10 == 0 and ( x + 1.50 ) <= bal ) : NEW_LINE INDENT print ( round ( bal - x - 1.50 , 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( round ( bal , 2 ) ) NEW_LINE DEDENT DEDENT x = 50 NEW_LINE bal = 100.50 NEW_LINE findBalance ( x , bal ) NEW_LINE"}
{"id": "geeksforgeeks_53_A", "sol": 0, "python_code": "def isPrime ( n ) :\n    i = 2\n    while i * i <= n :\n        if ( n % i == 0 ) :\n            return False\n        i += 1\n    return True\ndef sum ( l , r ) :\n    sum = 0\n    for i in range ( l , r + 1 ) :\n        if ( isPrime ( i ) ) :\n            continue\n        for j in range ( 2 , i ) :\n            if ( i % j == 0 and isPrime ( j ) ) :\n                sum += j\n    return sum\nif __name__ == \"__main__\" :\n    l = 18\n    r = 25\n    print ( sum ( l , r ) )\n", "python_code_tokenized": "def isPrime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def sum ( l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( 2 , i ) : NEW_LINE INDENT if ( i % j == 0 and isPrime ( j ) ) : NEW_LINE INDENT sum += j NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 18 NEW_LINE r = 25 NEW_LINE print ( sum ( l , r ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02399_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\nprint ( a // b , a % b , \"%.9f\" % ( a / b ) )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a // b , a % b , \" % .9f \" % ( a / b ) ) NEW_LINE"}
{"id": "codeforces_1076_A", "sol": 0, "python_code": "n = int ( input ( ) )\ns = input ( )\ni = 0\nwhile i != n - 1 and s [ i ] <= s [ i + 1 ] :\n    i += 1\nif i == n - 1 :\n    print ( s [ : i ] )\nelse :\n    print ( s [ : i ] + s [ i + 1 : ] )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE while i != n - 1 and s [ i ] <= s [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == n - 1 : NEW_LINE INDENT print ( s [ : i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ : i ] + s [ i + 1 : ] ) NEW_LINE DEDENT"}
{"id": "aizu_p00290_A", "sol": 0, "python_code": "import sys\nf = sys.stdin\nd , c = map ( int , f.readline ( ).split ( ) )\nprint ( d * c )\n", "python_code_tokenized": "import sys NEW_LINE f = sys . stdin NEW_LINE d , c = map ( int , f . readline ( ) . split ( ) ) NEW_LINE print ( d * c ) NEW_LINE"}
{"id": "aizu_p00377_A", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nsm = sum ( list ( map ( int , input ( ).split ( ) ) ) )\nprint ( ( n + sm ) // ( n + 1 ) )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE sm = sum ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE print ( ( n + sm ) // ( n + 1 ) ) NEW_LINE"}
{"id": "aizu_p00376_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\nif a < b :\n    print ( b - a )\nelif a > b :\n    print ( a - b )\nelse :\n    print ( 0 )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a < b : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1197_A", "sol": 0, "python_code": "def fromStart ( inp , del11 ) :\n    inp1 = inp [ 0 : del1 - 1 ] ;\n    inp2 = inp [ del1 : len ( inp ) ] ;\n    return inp1 + inp2 ;\ndef fromEnd ( inp , del1 ) :\n    inp1 = inp [ 0 : len ( inp ) - del1 ] ;\n    inp2 = inp [ len ( inp ) - del1 + 1 : len ( inp ) ] ;\n    return inp1 + inp2 ;\nin1 = 1234 ;\ninp = str ( in1 ) ;\ndel1 = 3 ;\nprint ( \"num_after_deleting_from_starting\" , fromStart ( inp , del1 ) ) ;\nprint ( \"num_after_deleting_from_ending\" , fromEnd ( inp , del1 ) ) ;\n", "python_code_tokenized": "def fromStart ( inp , del11 ) : NEW_LINE INDENT inp1 = inp [ 0 : del1 - 1 ] ; NEW_LINE inp2 = inp [ del1 : len ( inp ) ] ; NEW_LINE return inp1 + inp2 ; NEW_LINE DEDENT def fromEnd ( inp , del1 ) : NEW_LINE INDENT inp1 = inp [ 0 : len ( inp ) - del1 ] ; NEW_LINE inp2 = inp [ len ( inp ) - del1 + 1 : len ( inp ) ] ; NEW_LINE return inp1 + inp2 ; NEW_LINE DEDENT in1 = 1234 ; NEW_LINE inp = str ( in1 ) ; NEW_LINE del1 = 3 ; NEW_LINE print ( \" num _ after _ deleting _ from _ starting \" , fromStart ( inp , del1 ) ) ; NEW_LINE print ( \" num _ after _ deleting _ from _ ending \" , fromEnd ( inp , del1 ) ) ; NEW_LINE"}
{"id": "codeforces_215_B", "sol": 0, "python_code": "RO = sorted ( map ( int , input ( ).split ( ) [ 1 : ] ) ) [ - 1 ]\nPO = sorted ( map ( int , input ( ).split ( ) [ 1 : ] ) ) [ - 1 ]\nPI = sorted ( map ( int , input ( ).split ( ) [ 1 : ] ) ) [ 0 ]\nA , B = map ( int , input ( ).split ( ) )\nprint ( pow ( pow ( RO , 2 ) / ( ( ( A * PI ) / ( B * PO ) ) + 1 ) , 0.5 ) )\n", "python_code_tokenized": "RO = sorted ( map ( int , input ( ) . split ( ) [ 1 : ] ) ) [ - 1 ] NEW_LINE PO = sorted ( map ( int , input ( ) . split ( ) [ 1 : ] ) ) [ - 1 ] NEW_LINE PI = sorted ( map ( int , input ( ) . split ( ) [ 1 : ] ) ) [ 0 ] NEW_LINE A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( pow ( pow ( RO , 2 ) / ( ( ( A * PI ) / ( B * PO ) ) + 1 ) , 0.5 ) ) NEW_LINE"}
{"id": "geeksforgeeks_3995_A", "sol": 0, "python_code": "def factorial ( n ) :\n    i = n\n    fact = 1\n    while ( n / i != n ) :\n        fact = fact * i\n        i -= 1\n    return fact\nnum = 5 ;\nprint ( \"Factorial of\" , num , \"is\" , factorial ( num ) )\n", "python_code_tokenized": "def factorial ( n ) : NEW_LINE INDENT i = n NEW_LINE fact = 1 NEW_LINE while ( n / i != n ) : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT num = 5 ; NEW_LINE print ( \" Factorial \u2581 of \" , num , \" is \" , factorial ( num ) ) NEW_LINE"}
{"id": "atcoder_ABC160_B", "sol": 0, "python_code": "def main ( ) :\n    x = int ( input ( ) )\n    a = x // 500\n    b = x % 500\n    c = b // 5\n    ans = 1000 * a + 5 * c\n    print ( ans )\nmain ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE a = x // 500 NEW_LINE b = x % 500 NEW_LINE c = b // 5 NEW_LINE ans = 1000 * a + 5 * c NEW_LINE print ( ans ) NEW_LINE DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_2991_A", "sol": 0, "python_code": "def nCr ( n , r ) :\n    if ( r > n / 2 ) :\n        r = n - r ;\n    answer = 1 ;\n    for i in range ( 1 , r + 1 ) :\n        answer *= ( n - r + i ) ;\n        answer /= i ;\n    return answer ;\ndef binomialProbability ( n , k , p ) :\n    return ( nCr ( n , k ) * pow ( p , k ) * pow ( 1 - p , n - k ) ) ;\nn = 10 ;\nk = 5 ;\np = 1.0 / 3 ;\nprobability = binomialProbability ( n , k , p ) ;\nprint ( \"Probability of\" , k , \"heads when a coin is tossed\" , end = \" \" ) ;\nprint ( n , \"times where probability of each head is\" , round ( p , 6 ) ) ;\nprint ( \"is = \" , round ( probability , 6 ) ) ;\n", "python_code_tokenized": "def nCr ( n , r ) : NEW_LINE INDENT if ( r > n / 2 ) : NEW_LINE INDENT r = n - r ; NEW_LINE DEDENT answer = 1 ; NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT answer *= ( n - r + i ) ; NEW_LINE answer /= i ; NEW_LINE DEDENT return answer ; NEW_LINE DEDENT def binomialProbability ( n , k , p ) : NEW_LINE INDENT return ( nCr ( n , k ) * pow ( p , k ) * pow ( 1 - p , n - k ) ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE k = 5 ; NEW_LINE p = 1.0 / 3 ; NEW_LINE probability = binomialProbability ( n , k , p ) ; NEW_LINE print ( \" Probability \u2581 of \" , k , \" heads \u2581 when \u2581 a \u2581 coin \u2581 is \u2581 tossed \" , end = \" \u2581 \" ) ; NEW_LINE print ( n , \" times \u2581 where \u2581 probability \u2581 of \u2581 each \u2581 head \u2581 is \" , round ( p , 6 ) ) ; NEW_LINE print ( \" is \u2581 = \u2581 \" , round ( probability , 6 ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_4411_A", "sol": 0, "python_code": "def findSum ( N ) :\n    return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6\nif __name__ == '__main__' :\n    N = 4\n    print ( findSum ( N ) )\n", "python_code_tokenized": "def findSum ( N ) : NEW_LINE INDENT return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( findSum ( N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4301_A", "sol": 0, "python_code": "def findSum ( N ) :\n    return ( ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 )\nif __name__ == '__main__' :\n    N = 3\n    print ( findSum ( N ) )\n", "python_code_tokenized": "def findSum ( N ) : NEW_LINE INDENT return ( ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( findSum ( N ) ) NEW_LINE DEDENT"}
{"id": "codejam_12_12", "sol": 0, "python_code": "testCount = int ( raw_input ( ) )\nfor testIndex in range ( testCount ) :\n    ans = \"Case #\" + str ( testIndex + 1 ) + \": \"\n    n = int ( raw_input ( ) )\n    a = [ ]\n    for i in range ( n ) :\n        a1 , a2 = [ int ( x ) for x in raw_input ( ).split ( \" \" ) ]\n        a += [ ( a1 , a2 , 2 ) ]\n    a.sort ( key = lambda x : x [ 1 ] * 10000 + x [ 0 ] )\n    star = 0\n    count = 0\n    for i in range ( n ) :\n        need = a [ i ] [ 1 ] - star\n        while need > 0 :\n            flag = True\n            for j in range ( n - 1 , i - 1 , - 1 ) :\n                if a [ j ] [ 2 ] == 2 and star >= a [ j ] [ 0 ] :\n                    a [ j ] = ( a [ j ] [ 0 ] , a [ j ] [ 1 ] , 1 )\n                    need -= 1\n                    star += 1\n                    count += 1\n                    flag = False\n                    break\n            if flag :\n                break\n        if need > 0 :\n            ans += \"Too Bad\"\n            break\n        star += a [ i ] [ 2 ]\n        count += 1\n    if star == n * 2 :\n        ans += str ( count )\n    print ( ans )\n", "python_code_tokenized": "testCount = int ( raw_input ( ) ) NEW_LINE for testIndex in range ( testCount ) : NEW_LINE INDENT ans = \" Case \u2581 # \" + str ( testIndex + 1 ) + \" : \u2581 \" NEW_LINE n = int ( raw_input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a1 , a2 = [ int ( x ) for x in raw_input ( ) . split ( \" \u2581 \" ) ] NEW_LINE a += [ ( a1 , a2 , 2 ) ] NEW_LINE DEDENT a . sort ( key = lambda x : x [ 1 ] * 10000 + x [ 0 ] ) NEW_LINE star = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT need = a [ i ] [ 1 ] - star NEW_LINE while need > 0 : NEW_LINE INDENT flag = True NEW_LINE for j in range ( n - 1 , i - 1 , - 1 ) : NEW_LINE INDENT if a [ j ] [ 2 ] == 2 and star >= a [ j ] [ 0 ] : NEW_LINE INDENT a [ j ] = ( a [ j ] [ 0 ] , a [ j ] [ 1 ] , 1 ) NEW_LINE need -= 1 NEW_LINE star += 1 NEW_LINE count += 1 NEW_LINE flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if need > 0 : NEW_LINE INDENT ans += \" Too \u2581 Bad \" NEW_LINE break NEW_LINE DEDENT star += a [ i ] [ 2 ] NEW_LINE count += 1 NEW_LINE DEDENT if star == n * 2 : NEW_LINE INDENT ans += str ( count ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2921_A", "sol": 0, "python_code": "def term ( n ) :\n    d = 2\n    a1 = 0\n    An = a1 + ( n - 1 ) * d\n    An = An ** 3\n    return An ;\nn = 5\nprint ( term ( n ) )\n", "python_code_tokenized": "def term ( n ) : NEW_LINE INDENT d = 2 NEW_LINE a1 = 0 NEW_LINE An = a1 + ( n - 1 ) * d NEW_LINE An = An ** 3 NEW_LINE return An ; NEW_LINE DEDENT n = 5 NEW_LINE print ( term ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1973_A", "sol": 0, "python_code": "def xor_pair_sum ( ar , n ) :\n    total = 0\n    for i in range ( n ) :\n        total = total ^ ar [ i ]\n    return 2 * total\nif __name__ == \"__main__\" :\n    data = [ 1 , 2 , 3 ]\n    print ( xor_pair_sum ( data , len ( data ) ) )\n", "python_code_tokenized": "def xor_pair_sum ( ar , n ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT total = total ^ ar [ i ] NEW_LINE DEDENT return 2 * total NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT data = [ 1 , 2 , 3 ] NEW_LINE print ( xor_pair_sum ( data , len ( data ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4929_A", "sol": 0, "python_code": "def costToPanagram ( string , cost ) :\n    n = len ( string )\n    occurrences = [ 0 ] * 26\n    for i in range ( n ) :\n        occurrences [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1\n    gain = 0\n    for i in range ( 26 ) :\n        if occurrences [ i ] == 0 :\n            gain -= 2 * cost [ i ]\n        elif occurrences [ i ] > 1 :\n            gain += cost [ i ] * ( occurrences [ i ] - 1 )\n    if gain >= 0 :\n        return 0\n    return gain * - 1\nif __name__ == \"__main__\" :\n    cost = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ]\n    string = \"geeksforgeeks\"\n    print ( costToPanagram ( string , cost ) )\n", "python_code_tokenized": "def costToPanagram ( string , cost ) : NEW_LINE INDENT n = len ( string ) NEW_LINE occurrences = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT occurrences [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT gain = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if occurrences [ i ] == 0 : NEW_LINE INDENT gain -= 2 * cost [ i ] NEW_LINE DEDENT elif occurrences [ i ] > 1 : NEW_LINE INDENT gain += cost [ i ] * ( occurrences [ i ] - 1 ) NEW_LINE DEDENT DEDENT if gain >= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return gain * - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT cost = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE string = \" geeksforgeeks \" NEW_LINE print ( costToPanagram ( string , cost ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_930_A", "sol": 0, "python_code": "import math\nclass Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.next = None\ndef kAltReverse ( head , k ) :\n    current = head\n    next = None\n    prev = None\n    count = 0\n    while ( current != None and count < k ) :\n        next = current.next\n        current.next = prev\n        prev = current\n        current = next\n        count = count + 1 ;\n    if ( head != None ) :\n        head.next = current\n    count = 0\n    while ( count < k - 1 and current != None ) :\n        current = current.next\n        count = count + 1\n    if ( current != None ) :\n        current.next = kAltReverse ( current.next , k )\n    return prev\ndef push ( head_ref , new_data ) :\n    new_node = Node ( new_data )\n    new_node.next = head_ref\n    head_ref = new_node\n    return head_ref\ndef prList ( node ) :\n    count = 0\n    while ( node != None ) :\n        print ( node.data , end = \" \" )\n        node = node.next\n        count = count + 1\nif __name__ == '__main__' :\n    head = None\n    for i in range ( 20 , 0 , - 1 ) :\n        head = push ( head , i )\n    print ( \"Given linked list \" )\n    prList ( head )\n    head = kAltReverse ( head , 3 )\n    print ( \"\\nModified Linked list\" )\n    prList ( head )\n", "python_code_tokenized": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def kAltReverse ( head , k ) : NEW_LINE INDENT current = head NEW_LINE next = None NEW_LINE prev = None NEW_LINE count = 0 NEW_LINE while ( current != None and count < k ) : NEW_LINE INDENT next = current . next NEW_LINE current . next = prev NEW_LINE prev = current NEW_LINE current = next NEW_LINE count = count + 1 ; NEW_LINE DEDENT if ( head != None ) : NEW_LINE INDENT head . next = current NEW_LINE DEDENT count = 0 NEW_LINE while ( count < k - 1 and current != None ) : NEW_LINE INDENT current = current . next NEW_LINE count = count + 1 NEW_LINE DEDENT if ( current != None ) : NEW_LINE INDENT current . next = kAltReverse ( current . next , k ) NEW_LINE DEDENT return prev NEW_LINE DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def prList ( node ) : NEW_LINE INDENT count = 0 NEW_LINE while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" \u2581 \" ) NEW_LINE node = node . next NEW_LINE count = count + 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE for i in range ( 20 , 0 , - 1 ) : NEW_LINE INDENT head = push ( head , i ) NEW_LINE DEDENT print ( \" Given \u2581 linked \u2581 list \u2581 \" ) NEW_LINE prList ( head ) NEW_LINE head = kAltReverse ( head , 3 ) NEW_LINE print ( \" \\n Modified \u2581 Linked \u2581 list \" ) NEW_LINE prList ( head ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_931_A", "sol": 0, "python_code": "class node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.next = next\ndef push ( head_ref , new_data ) :\n    new_node = node ( 0 )\n    new_node.data = new_data\n    new_node.next = ( head_ref )\n    ( head_ref ) = new_node\n    return head_ref\ndef kAltReverse ( head , k ) :\n    return _kAltReverse ( head , k , True )\ndef _kAltReverse ( Node , k , b ) :\n    if ( Node == None ) :\n        return None\n    count = 1\n    prev = None\n    current = Node\n    next = None\n    while ( current != None and count <= k ) :\n        next = current.next\n        if ( b == True ) :\n            current.next = prev\n        prev = current\n        current = next\n        count = count + 1\n    if ( b == True ) :\n        Node.next = _kAltReverse ( current , k , not b )\n        return prev\n    else :\n        prev.next = _kAltReverse ( current , k , not b )\n        return Node\ndef printList ( node ) :\n    count = 0\n    while ( node != None ) :\n        print ( node.data , end = \" \" )\n        node = node.next\n        count = count + 1\nhead = None\ni = 20\nwhile ( i > 0 ) :\n    head = push ( head , i )\n    i = i - 1\nprint ( \"Given linked list \" )\nprintList ( head )\nhead = kAltReverse ( head , 3 )\nprint ( \"\\nModified Linked list \" )\nprintList ( head )\n", "python_code_tokenized": "class node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = next NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = node ( 0 ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE DEDENT def kAltReverse ( head , k ) : NEW_LINE INDENT return _kAltReverse ( head , k , True ) NEW_LINE DEDENT def _kAltReverse ( Node , k , b ) : NEW_LINE INDENT if ( Node == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT count = 1 NEW_LINE prev = None NEW_LINE current = Node NEW_LINE next = None NEW_LINE while ( current != None and count <= k ) : NEW_LINE INDENT next = current . next NEW_LINE if ( b == True ) : NEW_LINE INDENT current . next = prev NEW_LINE DEDENT prev = current NEW_LINE current = next NEW_LINE count = count + 1 NEW_LINE DEDENT if ( b == True ) : NEW_LINE INDENT Node . next = _kAltReverse ( current , k , not b ) NEW_LINE return prev NEW_LINE DEDENT else : NEW_LINE INDENT prev . next = _kAltReverse ( current , k , not b ) NEW_LINE return Node NEW_LINE DEDENT DEDENT def printList ( node ) : NEW_LINE INDENT count = 0 NEW_LINE while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" \u2581 \" ) NEW_LINE node = node . next NEW_LINE count = count + 1 NEW_LINE DEDENT DEDENT head = None NEW_LINE i = 20 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT head = push ( head , i ) NEW_LINE i = i - 1 NEW_LINE DEDENT print ( \" Given \u2581 linked \u2581 list \u2581 \" ) NEW_LINE printList ( head ) NEW_LINE head = kAltReverse ( head , 3 ) NEW_LINE print ( \" \\n Modified \u2581 Linked \u2581 list \u2581 \" ) NEW_LINE printList ( head ) NEW_LINE"}
{"id": "geeksforgeeks_3187_A", "sol": 0, "python_code": "import sys\ndef minimum_cost ( a , n ) :\n    mn = sys.maxsize\n    sum = 0\n    for i in range ( n ) :\n        mn = min ( a [ i ] , mn )\n        sum += a [ i ]\n    return mn * ( sum - mn )\nif __name__ == \"__main__\" :\n    a = [ 4 , 3 , 2 , 5 ]\n    n = len ( a )\n    print ( minimum_cost ( a , n ) )\n", "python_code_tokenized": "import sys NEW_LINE def minimum_cost ( a , n ) : NEW_LINE INDENT mn = sys . maxsize NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mn = min ( a [ i ] , mn ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT return mn * ( sum - mn ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 4 , 3 , 2 , 5 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimum_cost ( a , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1828_A", "sol": 0, "python_code": "def nthTerm ( n ) :\n    nth = 0\n    if ( n % 2 == 0 ) :\n        nth = 2 * ( ( n * n ) - n )\n    else :\n        nth = ( 2 * n * n ) - n\n    return nth\nn = 5\nprint ( nthTerm ( n ) )\nn = 25\nprint ( nthTerm ( n ) )\nn = 25000000\nprint ( nthTerm ( n ) )\nn = 250000007\nprint ( nthTerm ( n ) )\n", "python_code_tokenized": "def nthTerm ( n ) : NEW_LINE INDENT nth = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT nth = 2 * ( ( n * n ) - n ) NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( 2 * n * n ) - n NEW_LINE DEDENT return nth NEW_LINE DEDENT n = 5 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 25 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 25000000 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE"}
{"id": "codeforces_762_A", "sol": 0, "python_code": "from math import sqrt\nn , k = [ int ( i ) for i in input ( ).split ( ) ]\nd = [ ]\nfor i in range ( 1 , int ( sqrt ( n ) ) + 1 ) :\n    if n % i == 0 :\n        d.append ( i )\n        if i != n // i : d.append ( n // i )\nd = sorted ( d )\ntry : print ( d [ k - 1 ] )\nexcept IndexError : print ( - 1 )\n", "python_code_tokenized": "from math import sqrt NEW_LINE n , k = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE d = [ ] NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT d . append ( i ) NEW_LINE if i != n // i : d . append ( n // i ) NEW_LINE DEDENT DEDENT d = sorted ( d ) NEW_LINE try : print ( d [ k - 1 ] ) NEW_LINE except IndexError : print ( - 1 ) NEW_LINE"}
{"id": "geeksforgeeks_3598_A", "sol": 0, "python_code": "def pendulumArrangement ( arr , n ) :\n    arr.sort ( reverse = False )\n    pos = n - 1\n    if ( n % 2 == 0 ) :\n        odd = n - 1\n    else :\n        odd = n - 2\n    while ( odd > 0 ) :\n        temp = arr [ odd ]\n        in1 = odd\n        while ( in1 != pos ) :\n            arr [ in1 ] = arr [ in1 + 1 ]\n            in1 += 1\n        arr [ in1 ] = temp\n        odd = odd - 2\n        pos = pos - 1\n    start = 0\n    end = int ( ( n - 1 ) / 2 )\n    while ( start < end ) :\n        temp = arr [ start ]\n        arr [ start ] = arr [ end ]\n        arr [ end ] = temp\n        start += 1\n        end -= 1\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" )\nif __name__ == '__main__' :\n    arr = [ 11 , 2 , 4 , 55 , 6 , 8 ]\n    n = len ( arr )\n    pendulumArrangement ( arr , n )\n", "python_code_tokenized": "def pendulumArrangement ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE pos = n - 1 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT odd = n - 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = n - 2 NEW_LINE DEDENT while ( odd > 0 ) : NEW_LINE INDENT temp = arr [ odd ] NEW_LINE in1 = odd NEW_LINE while ( in1 != pos ) : NEW_LINE INDENT arr [ in1 ] = arr [ in1 + 1 ] NEW_LINE in1 += 1 NEW_LINE DEDENT arr [ in1 ] = temp NEW_LINE odd = odd - 2 NEW_LINE pos = pos - 1 NEW_LINE DEDENT start = 0 NEW_LINE end = int ( ( n - 1 ) / 2 ) NEW_LINE while ( start < end ) : NEW_LINE INDENT temp = arr [ start ] NEW_LINE arr [ start ] = arr [ end ] NEW_LINE arr [ end ] = temp NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 11 , 2 , 4 , 55 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE pendulumArrangement ( arr , n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_980_A", "sol": 0, "python_code": "class ItemValue :\n    def __init__ ( self , wt , val , ind ) :\n        self.wt = wt\n        self.val = val\n        self.ind = ind\n        self.cost = val // wt\n    def __lt__ ( self , other ) :\n        return self.cost < other.cost\nclass FractionalKnapSack :\n    @ staticmethod\n    def getMaxValue ( wt , val , capacity ) :\n        iVal = [ ]\n        for i in range ( len ( wt ) ) :\n            iVal.append ( ItemValue ( wt [ i ] , val [ i ] , i ) )\n        iVal.sort ( reverse = True )\n        totalValue = 0\n        for i in iVal :\n            curWt = int ( i.wt )\n            curVal = int ( i.val )\n            if capacity - curWt >= 0 :\n                capacity -= curWt\n                totalValue += curVal\n            else :\n                fraction = capacity / curWt\n                totalValue += curVal * fraction\n                capacity = int ( capacity - ( curWt * fraction ) )\n                break\n        return totalValue\nif __name__ == \"__main__\" :\n    wt = [ 10 , 40 , 20 , 30 ]\n    val = [ 60 , 40 , 100 , 120 ]\n    capacity = 50\n    maxValue = FractionalKnapSack.getMaxValue ( wt , val , capacity )\n    print ( \"Maximum value in Knapsack =\" , maxValue )\n", "python_code_tokenized": "class ItemValue : NEW_LINE INDENT def __init__ ( self , wt , val , ind ) : NEW_LINE INDENT self . wt = wt NEW_LINE self . val = val NEW_LINE self . ind = ind NEW_LINE self . cost = val // wt NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT return self . cost < other . cost NEW_LINE DEDENT DEDENT class FractionalKnapSack : NEW_LINE INDENT @ staticmethod NEW_LINE def getMaxValue ( wt , val , capacity ) : NEW_LINE INDENT iVal = [ ] NEW_LINE for i in range ( len ( wt ) ) : NEW_LINE INDENT iVal . append ( ItemValue ( wt [ i ] , val [ i ] , i ) ) NEW_LINE DEDENT iVal . sort ( reverse = True ) NEW_LINE totalValue = 0 NEW_LINE for i in iVal : NEW_LINE INDENT curWt = int ( i . wt ) NEW_LINE curVal = int ( i . val ) NEW_LINE if capacity - curWt >= 0 : NEW_LINE INDENT capacity -= curWt NEW_LINE totalValue += curVal NEW_LINE DEDENT else : NEW_LINE INDENT fraction = capacity / curWt NEW_LINE totalValue += curVal * fraction NEW_LINE capacity = int ( capacity - ( curWt * fraction ) ) NEW_LINE break NEW_LINE DEDENT DEDENT return totalValue NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT wt = [ 10 , 40 , 20 , 30 ] NEW_LINE val = [ 60 , 40 , 100 , 120 ] NEW_LINE capacity = 50 NEW_LINE maxValue = FractionalKnapSack . getMaxValue ( wt , val , capacity ) NEW_LINE print ( \" Maximum \u2581 value \u2581 in \u2581 Knapsack \u2581 = \" , maxValue ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3067_A", "sol": 0, "python_code": "MAX = 1000 ;\ndef replaceSpaces ( string ) :\n    string = string.strip ( )\n    i = len ( string )\n    space_count = string.count ( '' )\n    new_length = i + space_count * 2\n    if new_length > MAX :\n        return - 1\n    index = new_length - 1\n    string = list ( string )\n    for f in range ( i - 2 , new_length - 2 ) :\n        string.append ( '0' )\n    for j in range ( i - 1 , 0 , - 1 ) :\n        if string [ j ] == '' :\n            string [ index ] = '0'\n            string [ index - 1 ] = '2'\n            string [ index - 2 ] = '%'\n            index = index - 3\n        else :\n            string [ index ] = string [ j ]\n            index -= 1\n    return ''.join ( string )\nif __name__ == '__main__' :\n    s = \"Mr John Smith \"\n    s = replaceSpaces ( s )\n    print ( s )\n", "python_code_tokenized": "MAX = 1000 ; NEW_LINE def replaceSpaces ( string ) : NEW_LINE INDENT string = string . strip ( ) NEW_LINE i = len ( string ) NEW_LINE space_count = string . count ( ' \u2581 ' ) NEW_LINE new_length = i + space_count * 2 NEW_LINE if new_length > MAX : NEW_LINE INDENT return - 1 NEW_LINE DEDENT index = new_length - 1 NEW_LINE string = list ( string ) NEW_LINE for f in range ( i - 2 , new_length - 2 ) : NEW_LINE INDENT string . append ( '0' ) NEW_LINE DEDENT for j in range ( i - 1 , 0 , - 1 ) : NEW_LINE INDENT if string [ j ] == ' \u2581 ' : NEW_LINE INDENT string [ index ] = '0' NEW_LINE string [ index - 1 ] = '2' NEW_LINE string [ index - 2 ] = ' % ' NEW_LINE index = index - 3 NEW_LINE DEDENT else : NEW_LINE INDENT string [ index ] = string [ j ] NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT return ' ' . join ( string ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" Mr \u2581 John \u2581 Smith \u2581 \" NEW_LINE s = replaceSpaces ( s ) NEW_LINE print ( s ) NEW_LINE DEDENT"}
{"id": "codeforces_997_A", "sol": 0, "python_code": "n , x , y = map ( int , input ( ).split ( ) )\ns = input ( ).strip ( )\nzero = 0\nif s.count ( '0' ) == 0 :\n    print ( 0 )\n    exit ( )\ncnt = sum ( [ 1 for x in s.split ( '1' ) if len ( x ) > 0 ] )\nprint ( ( cnt - 1 ) * min ( x , y ) + y )\n", "python_code_tokenized": "n , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) . strip ( ) NEW_LINE zero = 0 NEW_LINE if s . count ( '0' ) == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT cnt = sum ( [ 1 for x in s . split ( '1' ) if len ( x ) > 0 ] ) NEW_LINE print ( ( cnt - 1 ) * min ( x , y ) + y ) NEW_LINE"}
{"id": "codeforces_52_A", "sol": 0, "python_code": "n = int ( input ( '' ) )\nl = list ( map ( int , input ( ).split ( ) ) )\na , b , c = l.count ( 1 ) , l.count ( 2 ) , l.count ( 3 )\nk = [ a , b , c ]\nm = max ( k )\nprint ( sum ( k ) - m )\n", "python_code_tokenized": "n = int ( input ( ' ' ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a , b , c = l . count ( 1 ) , l . count ( 2 ) , l . count ( 3 ) NEW_LINE k = [ a , b , c ] NEW_LINE m = max ( k ) NEW_LINE print ( sum ( k ) - m ) NEW_LINE"}
{"id": "geeksforgeeks_3448_A", "sol": 0, "python_code": "def harmonicMean ( arr , freq , n ) :\n    sm = 0\n    frequency_sum = 0\n    for i in range ( 0 , n ) :\n        sm = sm + freq [ i ] / arr [ i ]\n        frequency_sum = frequency_sum + freq [ i ]\n    return ( round ( frequency_sum / sm , 4 ) )\nnum = [ 13 , 14 , 15 , 16 , 17 ]\nfreq = [ 2 , 5 , 13 , 7 , 3 ]\nn = len ( num )\nprint ( harmonicMean ( num , freq , n ) )\n", "python_code_tokenized": "def harmonicMean ( arr , freq , n ) : NEW_LINE INDENT sm = 0 NEW_LINE frequency_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + freq [ i ] / arr [ i ] NEW_LINE frequency_sum = frequency_sum + freq [ i ] NEW_LINE DEDENT return ( round ( frequency_sum / sm , 4 ) ) NEW_LINE DEDENT num = [ 13 , 14 , 15 , 16 , 17 ] NEW_LINE freq = [ 2 , 5 , 13 , 7 , 3 ] NEW_LINE n = len ( num ) NEW_LINE print ( harmonicMean ( num , freq , n ) ) NEW_LINE"}
{"id": "atcoder_ABC079_C", "sol": 0, "python_code": "S = list ( map ( int , input ( ) ) )\nlength = len ( S ) - 1\nfor bit in range ( 2 ** length ) :\n    ans = S [ 0 ]\n    ope = [ '+' if bit & ( 2 ** i ) else '-' for i in range ( length ) ]\n    for i in range ( 1 , length + 1 ) :\n        if ope [ i - 1 ] == '+' :\n            ans += S [ i ]\n        else :\n            ans -= S [ i ]\n    if ans == 7 :\n        print ( '{}{}{}{}{}{}{}=7'.format ( S [ 0 ] , ope [ 0 ] , S [ 1 ] , ope [ 1 ] , S [ 2 ] , ope [ 2 ] , S [ 3 ] ) )\n        break\n", "python_code_tokenized": "S = list ( map ( int , input ( ) ) ) NEW_LINE length = len ( S ) - 1 NEW_LINE for bit in range ( 2 ** length ) : NEW_LINE INDENT ans = S [ 0 ] NEW_LINE ope = [ ' + ' if bit & ( 2 ** i ) else ' - ' for i in range ( length ) ] NEW_LINE for i in range ( 1 , length + 1 ) : NEW_LINE INDENT if ope [ i - 1 ] == ' + ' : NEW_LINE INDENT ans += S [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans -= S [ i ] NEW_LINE DEDENT DEDENT if ans == 7 : NEW_LINE INDENT print ( ' { } { } { } { } { } { } { } = 7' . format ( S [ 0 ] , ope [ 0 ] , S [ 1 ] , ope [ 1 ] , S [ 2 ] , ope [ 2 ] , S [ 3 ] ) ) NEW_LINE break NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4196_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    if ( a == 0 ) :\n        return b ;\n    if ( b == 0 ) :\n        return a ;\n    if ( a == b ) :\n        return a ;\n    if ( a > b ) :\n        return gcd ( a - b , b ) ;\n    return gcd ( a , b - a ) ;\ndef LCM ( den , N ) :\n    ans = den [ 0 ] ;\n    for i in range ( 1 , N ) :\n        ans = ( ( ( den [ i ] * ans ) ) / ( gcd ( den [ i ] , ans ) ) ) ;\n    return ans ;\ndef HCF ( num , N ) :\n    ans = num [ 0 ] ;\n    for i in range ( 1 , N ) :\n        ans = gcd ( num [ i ] , ans ) ;\n    return ans ;\ndef HCFOfFractions ( num , den , N ) :\n    Numerator = HCF ( num , N ) ;\n    Denominator = LCM ( den , N ) ;\n    gcd1 = gcd ( Numerator , Denominator ) ;\n    Numerator = int ( Numerator / gcd1 ) ;\n    Denominator = int ( Denominator / gcd1 ) ;\n    print ( \"HCF is =\" , Numerator , \"/\" , Denominator ) ;\nnum = [ 24 , 48 , 72 , 96 ] ;\nden = [ 2 , 6 , 8 , 3 ] ;\nN = len ( num ) ;\nHCFOfFractions ( num , den , N ) ;\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) ; NEW_LINE DEDENT return gcd ( a , b - a ) ; NEW_LINE DEDENT def LCM ( den , N ) : NEW_LINE INDENT ans = den [ 0 ] ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT ans = ( ( ( den [ i ] * ans ) ) / ( gcd ( den [ i ] , ans ) ) ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def HCF ( num , N ) : NEW_LINE INDENT ans = num [ 0 ] ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT ans = gcd ( num [ i ] , ans ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def HCFOfFractions ( num , den , N ) : NEW_LINE INDENT Numerator = HCF ( num , N ) ; NEW_LINE Denominator = LCM ( den , N ) ; NEW_LINE gcd1 = gcd ( Numerator , Denominator ) ; NEW_LINE Numerator = int ( Numerator / gcd1 ) ; NEW_LINE Denominator = int ( Denominator / gcd1 ) ; NEW_LINE print ( \" HCF \u2581 is \u2581 = \" , Numerator , \" / \" , Denominator ) ; NEW_LINE DEDENT num = [ 24 , 48 , 72 , 96 ] ; NEW_LINE den = [ 2 , 6 , 8 , 3 ] ; NEW_LINE N = len ( num ) ; NEW_LINE HCFOfFractions ( num , den , N ) ; NEW_LINE"}
{"id": "geeksforgeeks_2588_A", "sol": 0, "python_code": "def alternateFib ( n ) :\n    if ( n < 0 ) :\n        return - 1 ;\n    f1 = 0 ;\n    f2 = 1 ;\n    print ( f1 , end = \" \" ) ;\n    for i in range ( 2 , n + 1 ) :\n        f3 = f2 + f1 ;\n        if ( i % 2 == 0 ) :\n            print ( f3 , end = \" \" ) ;\n        f1 = f2 ;\n        f2 = f3 ;\nN = 15 ;\nalternateFib ( N ) ;\n", "python_code_tokenized": "def alternateFib ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT f1 = 0 ; NEW_LINE f2 = 1 ; NEW_LINE print ( f1 , end = \" \u2581 \" ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f3 = f2 + f1 ; NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT print ( f3 , end = \" \u2581 \" ) ; NEW_LINE DEDENT f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE DEDENT DEDENT N = 15 ; NEW_LINE alternateFib ( N ) ; NEW_LINE"}
{"id": "atcoder_ABC091_D", "sol": 0, "python_code": "import sys\nsdin = sys.stdin.readline\nn = int ( sdin ( ) )\na = list ( map ( int , sdin ( ).split ( ) ) )\nb = list ( map ( int , sdin ( ).split ( ) ) )\nans = 0\nfor k in range ( 29 ) :\n    a_nex = [ [ ] , [ ] ]\n    b_nex = [ [ ] , [ ] ]\n    for ai in a :\n        a_nex [ ( ai & ( 1 << k ) ) >> k ].append ( ai )\n    for bj in b :\n        b_nex [ ( bj & ( 1 << k ) ) >> k ].append ( bj )\n    a = [ ]\n    b = [ ]\n    for i in range ( 2 ) :\n        a = a + a_nex [ i ]\n        b = b + b_nex [ i ]\n    mask = pow ( 2 , k + 1 ) - 1\n    a_mask = [ ai & mask for ai in a ]\n    b_mask = [ bj & mask for bj in b ]\n    base = pow ( 2 , k )\n    itr = [ n ] * 4\n    count = 0\n    for ai in a_mask :\n        border = [ base - ai , 2 * base - ai , 3 * base - ai , 4 * base - ai ]\n        for i in range ( 4 ) :\n            while 0 < itr [ i ] and border [ i ] <= b_mask [ itr [ i ] - 1 ] :\n                itr [ i ] -= 1\n        count += ( ( itr [ 1 ] - itr [ 0 ] ) + ( itr [ 3 ] - itr [ 2 ] ) )\n    if count & 1 :\n        ans += base\nprint ( ans )\n", "python_code_tokenized": "import sys NEW_LINE sdin = sys . stdin . readline NEW_LINE n = int ( sdin ( ) ) NEW_LINE a = list ( map ( int , sdin ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , sdin ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for k in range ( 29 ) : NEW_LINE INDENT a_nex = [ [ ] , [ ] ] NEW_LINE b_nex = [ [ ] , [ ] ] NEW_LINE for ai in a : NEW_LINE INDENT a_nex [ ( ai & ( 1 << k ) ) >> k ] . append ( ai ) NEW_LINE DEDENT for bj in b : NEW_LINE INDENT b_nex [ ( bj & ( 1 << k ) ) >> k ] . append ( bj ) NEW_LINE DEDENT a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT a = a + a_nex [ i ] NEW_LINE b = b + b_nex [ i ] NEW_LINE DEDENT mask = pow ( 2 , k + 1 ) - 1 NEW_LINE a_mask = [ ai & mask for ai in a ] NEW_LINE b_mask = [ bj & mask for bj in b ] NEW_LINE base = pow ( 2 , k ) NEW_LINE itr = [ n ] * 4 NEW_LINE count = 0 NEW_LINE for ai in a_mask : NEW_LINE INDENT border = [ base - ai , 2 * base - ai , 3 * base - ai , 4 * base - ai ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT while 0 < itr [ i ] and border [ i ] <= b_mask [ itr [ i ] - 1 ] : NEW_LINE INDENT itr [ i ] -= 1 NEW_LINE DEDENT DEDENT count += ( ( itr [ 1 ] - itr [ 0 ] ) + ( itr [ 3 ] - itr [ 2 ] ) ) NEW_LINE DEDENT if count & 1 : NEW_LINE INDENT ans += base NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "aizu_p01522_A", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nboats = [ set ( list ( map ( int , input ( ).split ( ) ) ) [ 1 : ] ) for _ in range ( k ) ]\nr = int ( input ( ) )\nout = set ( )\nfor _ in range ( r ) :\n    p , q = map ( int , input ( ).split ( ) )\n    for boat in boats :\n        if p in boat and q in boat :\n            out.add ( p )\n            out.add ( q )\n            break\nprint ( len ( out ) )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE boats = [ set ( list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] ) for _ in range ( k ) ] NEW_LINE r = int ( input ( ) ) NEW_LINE out = set ( ) NEW_LINE for _ in range ( r ) : NEW_LINE INDENT p , q = map ( int , input ( ) . split ( ) ) NEW_LINE for boat in boats : NEW_LINE INDENT if p in boat and q in boat : NEW_LINE INDENT out . add ( p ) NEW_LINE out . add ( q ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( len ( out ) ) NEW_LINE"}
{"id": "geeksforgeeks_4540_A", "sol": 0, "python_code": "def countgroup ( a , n ) :\n    xs = 0\n    for i in range ( n ) :\n        xs = xs ^ a [ i ]\n    if xs == 0 :\n        return ( 1 << ( n - 1 ) ) - 1\n    return 0\na = [ 1 , 2 , 3 ]\nn = len ( a )\nprint ( countgroup ( a , n ) )\n", "python_code_tokenized": "def countgroup ( a , n ) : NEW_LINE INDENT xs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xs = xs ^ a [ i ] NEW_LINE DEDENT if xs == 0 : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( countgroup ( a , n ) ) NEW_LINE"}
{"id": "codeforces_1082_A", "sol": 0, "python_code": "t = int ( input ( ) )\nwhile t > 0 :\n    t -= 1\n    n , x , y , d = ( int ( _ ) for _ in input ( ).strip ( ).split ( ' ' ) )\n    if abs ( y - x ) % d != 0 and ( y - 1 ) % d != 0 and ( n - y ) % d != 0 :\n        print ( - 1 )\n    else :\n        if abs ( y - x ) % d == 0 :\n            print ( abs ( y - x ) // d )\n        else :\n            a = ( ( x - 1 ) // d + ( y - 1 ) // d if ( x - 1 ) % d == 0 else ( x - 1 ) // d + 1 + ( y - 1 ) // d ) if ( y - 1 ) % d == 0 else 0x3f3f3f3f\n            b = ( ( n - x ) // d + ( n - y ) // d if ( n - x ) % d == 0 else ( n - x ) // d + 1 + ( n - y ) // d ) if ( n - y ) % d == 0 else 0x3f3f3f3f\n            print ( min ( a , b ) )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE n , x , y , d = ( int ( _ ) for _ in input ( ) . strip ( ) . split ( ' \u2581 ' ) ) NEW_LINE if abs ( y - x ) % d != 0 and ( y - 1 ) % d != 0 and ( n - y ) % d != 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if abs ( y - x ) % d == 0 : NEW_LINE INDENT print ( abs ( y - x ) // d ) NEW_LINE DEDENT else : NEW_LINE INDENT a = ( ( x - 1 ) // d + ( y - 1 ) // d if ( x - 1 ) % d == 0 else ( x - 1 ) // d + 1 + ( y - 1 ) // d ) if ( y - 1 ) % d == 0 else 0x3f3f3f3f NEW_LINE b = ( ( n - x ) // d + ( n - y ) // d if ( n - x ) % d == 0 else ( n - x ) // d + 1 + ( n - y ) // d ) if ( n - y ) % d == 0 else 0x3f3f3f3f NEW_LINE print ( min ( a , b ) ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "projecteuler_p002_A", "sol": 0, "python_code": "def compute ( ) :\n    ans = 0\n    x = 1\n    y = 2\n    while x <= 4000000 :\n        if x % 2 == 0 :\n            ans += x\n        x , y = y , x + y\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE x = 1 NEW_LINE y = 2 NEW_LINE while x <= 4000000 : NEW_LINE INDENT if x % 2 == 0 : NEW_LINE INDENT ans += x NEW_LINE DEDENT x , y = y , x + y NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC174_A", "sol": 0, "python_code": "X = int ( input ( ) )\nprint ( [ 'No' , 'Yes' ] [ X >= 30 ] )\n", "python_code_tokenized": "X = int ( input ( ) ) NEW_LINE print ( [ ' No ' , ' Yes ' ] [ X >= 30 ] ) NEW_LINE"}
{"id": "geeksforgeeks_4985_A", "sol": 0, "python_code": "def printAllAPTriplets ( arr , n ) :\n    for i in range ( 1 , n - 1 ) :\n        j = i - 1\n        k = i + 1\n        while ( j >= 0 and k < n ) :\n            if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) :\n                print ( arr [ j ] , \"\" , arr [ i ] , \"\" , arr [ k ] )\n                k += 1\n                j -= 1\n            elif ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) :\n                k += 1\n            else :\n                j -= 1\narr = [ 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 ]\nn = len ( arr )\nprintAllAPTriplets ( arr , n )\n", "python_code_tokenized": "def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT j = i - 1 NEW_LINE k = i + 1 NEW_LINE while ( j >= 0 and k < n ) : NEW_LINE INDENT if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) : NEW_LINE INDENT print ( arr [ j ] , \" \" , arr [ i ] , \" \" , arr [ k ] ) NEW_LINE k += 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 ] NEW_LINE n = len ( arr ) NEW_LINE printAllAPTriplets ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_3401_A", "sol": 0, "python_code": "def findTriplets ( arr , n , sum ) :\n    for i in range ( 0 , n - 2 ) :\n        for j in range ( i + 1 , n - 1 ) :\n            for k in range ( j + 1 , n ) :\n                if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) :\n                    print ( arr [ i ] , \"\" , arr [ j ] , \"\" , arr [ k ] , sep = \"\" )\narr = [ 0 , - 1 , 2 , - 3 , 1 ]\nn = len ( arr )\nfindTriplets ( arr , n , - 2 )\n", "python_code_tokenized": "def findTriplets ( arr , n , sum ) : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) : NEW_LINE INDENT print ( arr [ i ] , \" \u2581 \" , arr [ j ] , \" \u2581 \" , arr [ k ] , sep = \" \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT arr = [ 0 , - 1 , 2 , - 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findTriplets ( arr , n , - 2 ) NEW_LINE"}
{"id": "geeksforgeeks_3770_A", "sol": 0, "python_code": "def minSum ( arr , n ) :\n    sm = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        if arr [ i ] == arr [ i - 1 ] :\n            j = i\n            while j < n and arr [ j ] <= arr [ j - 1 ] :\n                arr [ j ] = arr [ j ] + 1\n                j += 1\n        sm = sm + arr [ i ]\n    return sm\narr = [ 2 , 2 , 3 , 5 , 6 ]\nn = len ( arr )\nprint ( minSum ( arr , n ) )\n", "python_code_tokenized": "def minSum ( arr , n ) : NEW_LINE INDENT sm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ i - 1 ] : NEW_LINE INDENT j = i NEW_LINE while j < n and arr [ j ] <= arr [ j - 1 ] : NEW_LINE INDENT arr [ j ] = arr [ j ] + 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT sm = sm + arr [ i ] NEW_LINE DEDENT return sm NEW_LINE DEDENT arr = [ 2 , 2 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minSum ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_44_A", "sol": 0, "python_code": "MAX = 1000000\nprime = [ True ] * ( MAX + 1 )\nsum = [ 0 ] * ( MAX + 1 )\ndef SieveOfEratosthenes ( ) :\n    prime [ 1 ] = False\n    p = 2\n    while p * p <= MAX :\n        if ( prime [ p ] ) :\n            i = p * 2\n            while i <= MAX :\n                prime [ i ] = False\n                i += p\n        p += 1\n    for i in range ( 1 , MAX + 1 ) :\n        if ( prime [ i ] == True ) :\n            sum [ i ] = 1\n        sum [ i ] += sum [ i - 1 ]\nif __name__ == \"__main__\" :\n    SieveOfEratosthenes ( )\n    l = 3\n    r = 9\n    c = ( sum [ r ] - sum [ l - 1 ] )\n    print ( \"Count:\" , c )\n", "python_code_tokenized": "MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE sum = [ 0 ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT i = p * 2 NEW_LINE while i <= MAX : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT sum [ i ] = 1 NEW_LINE DEDENT sum [ i ] += sum [ i - 1 ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE l = 3 NEW_LINE r = 9 NEW_LINE c = ( sum [ r ] - sum [ l - 1 ] ) NEW_LINE print ( \" Count : \" , c ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2528_A", "sol": 0, "python_code": "def minOperations ( n , m ) :\n    if ( m % n != 0 ) :\n        return - 1\n    minOperations = 0\n    q = int ( m / n )\n    while ( q % 2 == 0 ) :\n        q = int ( q / 2 )\n        minOperations += 1\n    while ( q % 3 == 0 ) :\n        q = int ( q / 3 )\n        minOperations += 1\n    if ( q == 1 ) :\n        return minOperations\n    return - 1\nif __name__ == '__main__' :\n    n = 120\n    m = 51840\n    print ( minOperations ( n , m ) )\n", "python_code_tokenized": "def minOperations ( n , m ) : NEW_LINE INDENT if ( m % n != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minOperations = 0 NEW_LINE q = int ( m / n ) NEW_LINE while ( q % 2 == 0 ) : NEW_LINE INDENT q = int ( q / 2 ) NEW_LINE minOperations += 1 NEW_LINE DEDENT while ( q % 3 == 0 ) : NEW_LINE INDENT q = int ( q / 3 ) NEW_LINE minOperations += 1 NEW_LINE DEDENT if ( q == 1 ) : NEW_LINE INDENT return minOperations NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 120 NEW_LINE m = 51840 NEW_LINE print ( minOperations ( n , m ) ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC020_D", "sol": 0, "python_code": "for t in range ( int ( input ( ) ) ) :\n    a , b , c , d = map ( int , input ( ).split ( ' ' ) ) ; l , x , y , o = ( a + b ) // ( min ( a , b ) + 1 ) , a + b , 0 , \"\"\n    if a * l <= b : x , y = 0 , a + b\n    elif b * l > a : x , y = ( a * l - b ) // ( l - 1 ) , ( b * l - a ) // ( l - 1 )\n    for i in range ( c , d + 1 ) : o += \"AB\" [ i % ( l + 1 ) == 0 ] if i <= x else \"BA\" [ ( a + b - i + 1 ) % ( l + 1 ) == 0 ] if a + b - i + 1 <= y else \"AB\" [ a - x + x // ( l + 1 ) - y // ( l + 1 ) == 0 ]\n    print ( o )\n", "python_code_tokenized": "for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ' \u2581 ' ) ) ; l , x , y , o = ( a + b ) // ( min ( a , b ) + 1 ) , a + b , 0 , \" \" NEW_LINE if a * l <= b : x , y = 0 , a + b NEW_LINE elif b * l > a : x , y = ( a * l - b ) // ( l - 1 ) , ( b * l - a ) // ( l - 1 ) NEW_LINE for i in range ( c , d + 1 ) : o += \" AB \" [ i % ( l + 1 ) == 0 ] if i <= x else \" BA \" [ ( a + b - i + 1 ) % ( l + 1 ) == 0 ] if a + b - i + 1 <= y else \" AB \" [ a - x + x // ( l + 1 ) - y // ( l + 1 ) == 0 ] NEW_LINE print ( o ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4592_A", "sol": 0, "python_code": "def multipleOfThree ( K , dig0 , dig1 ) :\n    sum = 0\n    temp = ( dig0 + dig1 ) % 10\n    sum = dig0 + dig1\n    if ( K == 2 ) :\n        if ( sum % 3 == 0 ) :\n            return True\n        else :\n            return False\n    sum += temp\n    numberofGroups = ( K - 3 ) // 4\n    remNumberofDigits = ( K - 3 ) % 4\n    sum += ( numberofGroups * 20 )\n    for i in range ( remNumberofDigits ) :\n        temp = ( 2 * temp ) % 10\n        sum += temp\n    if ( sum % 3 == 0 ) :\n        return True\n    else :\n        return False\nif __name__ == \"__main__\" :\n    K = 5\n    dig0 = 3\n    dig1 = 4\n    if ( multipleOfThree ( K , dig0 , dig1 ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def multipleOfThree ( K , dig0 , dig1 ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = ( dig0 + dig1 ) % 10 NEW_LINE sum = dig0 + dig1 NEW_LINE if ( K == 2 ) : NEW_LINE INDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT sum += temp NEW_LINE numberofGroups = ( K - 3 ) // 4 NEW_LINE remNumberofDigits = ( K - 3 ) % 4 NEW_LINE sum += ( numberofGroups * 20 ) NEW_LINE for i in range ( remNumberofDigits ) : NEW_LINE INDENT temp = ( 2 * temp ) % 10 NEW_LINE sum += temp NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT K = 5 NEW_LINE dig0 = 3 NEW_LINE dig1 = 4 NEW_LINE if ( multipleOfThree ( K , dig0 , dig1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3746_A", "sol": 0, "python_code": "def numberOfLines ( S , widths ) :\n    if ( S == \"\" ) :\n        return 0 , 0\n    lines , width = 1 , 0\n    for c in S :\n        w = widths [ ord ( c ) - ord ( 'a' ) ]\n        width += w\n        if width > 10 :\n            lines += 1\n            width = w\n    return lines , width\nS = \"bbbcccdddaa\"\nWidths = [ 4 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ]\nprint ( numberOfLines ( S , Widths ) )\n", "python_code_tokenized": "def numberOfLines ( S , widths ) : NEW_LINE INDENT if ( S == \" \" ) : NEW_LINE INDENT return 0 , 0 NEW_LINE DEDENT lines , width = 1 , 0 NEW_LINE for c in S : NEW_LINE INDENT w = widths [ ord ( c ) - ord ( ' a ' ) ] NEW_LINE width += w NEW_LINE if width > 10 : NEW_LINE INDENT lines += 1 NEW_LINE width = w NEW_LINE DEDENT DEDENT return lines , width NEW_LINE DEDENT S = \" bbbcccdddaa \" NEW_LINE Widths = [ 4 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE print ( numberOfLines ( S , Widths ) ) NEW_LINE"}
{"id": "geeksforgeeks_5145_A", "sol": 0, "python_code": "if __name__ == '__main__' :\n    a , b , i , j = 0 , 0 , 0 , 0\n    print ( \"Enter lower bound of the interval:\" , end = \"\" )\n    a = int ( input ( ) )\n    print ( a )\n    print ( \"Enter upper bound of the interval:\" , end = \"\" )\n    b = int ( input ( ) )\n    print ( b )\n    print ( \"Prime numbers between\" , a , \"and\" , b , \"are:\" , end = \"\" )\n    if ( a == 1 ) :\n        print ( a , end = \" \" )\n        a += 1\n        if ( b >= 2 ) :\n            print ( a , end = \" \" )\n            a += 1\n    if ( a == 2 ) :\n        print ( a , end = \" \" )\n    if ( a % 2 == 0 ) :\n        a += 1\n    for i in range ( a , b + 1 , 2 ) :\n        flag = 1\n        j = 2\n        while ( j * j <= i ) :\n            if ( i % j == 0 ) :\n                flag = 0\n                break\n            j += 1\n        if ( flag == 1 ) :\n            print ( i , end = \" \" )\n", "python_code_tokenized": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b , i , j = 0 , 0 , 0 , 0 NEW_LINE print ( \" Enter \u2581 lower \u2581 bound \u2581 of \u2581 the \u2581 interval : \" , end = \" \" ) NEW_LINE a = int ( input ( ) ) NEW_LINE print ( a ) NEW_LINE print ( \" Enter \u2581 upper \u2581 bound \u2581 of \u2581 the \u2581 interval : \" , end = \" \" ) NEW_LINE b = int ( input ( ) ) NEW_LINE print ( b ) NEW_LINE print ( \" Prime \u2581 numbers \u2581 between \" , a , \" and \" , b , \" are : \" , end = \" \" ) NEW_LINE if ( a == 1 ) : NEW_LINE INDENT print ( a , end = \" \u2581 \" ) NEW_LINE a += 1 NEW_LINE if ( b >= 2 ) : NEW_LINE INDENT print ( a , end = \" \u2581 \" ) NEW_LINE a += 1 NEW_LINE DEDENT DEDENT if ( a == 2 ) : NEW_LINE INDENT print ( a , end = \" \u2581 \" ) NEW_LINE DEDENT if ( a % 2 == 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT for i in range ( a , b + 1 , 2 ) : NEW_LINE INDENT flag = 1 NEW_LINE j = 2 NEW_LINE while ( j * j <= i ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_5144_A", "sol": 0, "python_code": "if __name__ == '__main__' :\n    a , b , i , j , flag = 0 , 0 , 0 , 0 , 0\n    print ( \"Enter lower bound of the interval:\" , end = \"\" )\n    a = int ( input ( ) )\n    print ( a )\n    print ( \"Enter upper bound of the interval:\" , end = \"\" )\n    b = int ( input ( ) )\n    print ( b )\n    print ( \"Prime numbers between\" , a , \"and\" , b , \"are:\" , end = \"\" )\n    for i in range ( a , b + 1 ) :\n        if ( i == 1 ) :\n            continue\n        flag = 1\n        for j in range ( 2 , i // 2 + 1 ) :\n            if ( i % j == 0 ) :\n                flag = 0\n                break\n        if ( flag == 1 ) :\n            print ( i , end = \" \" )\n", "python_code_tokenized": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b , i , j , flag = 0 , 0 , 0 , 0 , 0 NEW_LINE print ( \" Enter \u2581 lower \u2581 bound \u2581 of \u2581 the \u2581 interval : \" , end = \" \" ) NEW_LINE a = int ( input ( ) ) NEW_LINE print ( a ) NEW_LINE print ( \" Enter \u2581 upper \u2581 bound \u2581 of \u2581 the \u2581 interval : \" , end = \" \" ) NEW_LINE b = int ( input ( ) ) NEW_LINE print ( b ) NEW_LINE print ( \" Prime \u2581 numbers \u2581 between \" , a , \" and \" , b , \" are : \" , end = \" \" ) NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT flag = 1 NEW_LINE for j in range ( 2 , i // 2 + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_2387_A", "sol": 0, "python_code": "def isMagic ( n ) :\n    sum = 0 ;\n    while ( n > 0 or sum > 9 ) :\n        if ( n == 0 ) :\n            n = sum ;\n            sum = 0 ;\n        sum = sum + n % 10 ;\n        n = int ( n / 10 ) ;\n    return True if ( sum == 1 ) else False ;\nn = 1234 ;\nif ( isMagic ( n ) ) :\n    print ( \"Magic Number\" ) ;\nelse :\n    print ( \"Not a magic Number\" ) ;\n", "python_code_tokenized": "def isMagic ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( n > 0 or sum > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = sum ; NEW_LINE sum = 0 ; NEW_LINE DEDENT sum = sum + n % 10 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return True if ( sum == 1 ) else False ; NEW_LINE DEDENT n = 1234 ; NEW_LINE if ( isMagic ( n ) ) : NEW_LINE INDENT print ( \" Magic \u2581 Number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 a \u2581 magic \u2581 Number \" ) ; NEW_LINE DEDENT"}
{"id": "aizu_p02524_A", "sol": 0, "python_code": "import math\na , b , C = map ( int , raw_input ( ).split ( ) )\nC = C / 180.0 * math.pi\nS = ( float ) ( 0.5 * a * b * math.sin ( C ) )\nL = ( float ) ( a + b + math.sqrt ( a ** 2 + b ** 2 - 2 * a * b * math.cos ( C ) ) )\nh = ( float ) ( b * math.sin ( C ) )\nprint ( \"{0:.8f} {1:.8f} {2:.8f}\" ).format ( S , L , h )\n", "python_code_tokenized": "import math NEW_LINE a , b , C = map ( int , raw_input ( ) . split ( ) ) NEW_LINE C = C / 180.0 * math . pi NEW_LINE S = ( float ) ( 0.5 * a * b * math . sin ( C ) ) NEW_LINE L = ( float ) ( a + b + math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( C ) ) ) NEW_LINE h = ( float ) ( b * math . sin ( C ) ) NEW_LINE print ( \" { 0 : . 8f } \u2581 { 1 : . 8f } \u2581 { 2 : . 8f } \" ) . format ( S , L , h ) NEW_LINE"}
{"id": "geeksforgeeks_4760_A", "sol": 0, "python_code": "import numpy as np\nMAX_INDEX = 51\nMAX_SUM = 2505\ndp = np.ones ( ( MAX_INDEX , MAX_SUM , MAX_INDEX ) ) * - 1 ;\ndef waysutil ( index , sum , count , arr , K ) :\n    if ( index < 0 ) :\n        return 0 ;\n    if ( index == 0 ) :\n        if ( count == 0 ) :\n            return 0 ;\n        remainder = sum % count ;\n        if ( remainder != 0 ) :\n            return 0 ;\n        average = sum // count ;\n        if ( average == K ) :\n            return 1 ;\n    if ( dp [ index ] [ sum ] [ count ] != - 1 ) :\n        return dp [ index ] [ sum ] [ count ] ;\n    dontpick = waysutil ( index - 1 , sum , count , arr , K ) ;\n    pick = waysutil ( index - 1 , sum + arr [ index ] , count + 1 , arr , K ) ;\n    total = pick + dontpick ;\n    dp [ index ] [ sum ] [ count ] = total ;\n    return total ;\ndef ways ( N , K , arr ) :\n    Arr = [ ] ;\n    Arr.append ( - 1 ) ;\n    for i in range ( N ) :\n        Arr.append ( arr [ i ] ) ;\n    answer = waysutil ( N , 0 , 0 , Arr , K ) ;\n    return answer ;\nif __name__ == \"__main__\" :\n    arr = [ 3 , 6 , 2 , 8 , 7 , 6 , 5 , 9 ] ;\n    N = len ( arr ) ;\n    K = 5 ;\n    print ( ways ( N , K , arr ) ) ;\n", "python_code_tokenized": "import numpy as np NEW_LINE MAX_INDEX = 51 NEW_LINE MAX_SUM = 2505 NEW_LINE dp = np . ones ( ( MAX_INDEX , MAX_SUM , MAX_INDEX ) ) * - 1 ; NEW_LINE def waysutil ( index , sum , count , arr , K ) : NEW_LINE INDENT if ( index < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( index == 0 ) : NEW_LINE INDENT if ( count == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT remainder = sum % count ; NEW_LINE if ( remainder != 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT average = sum // count ; NEW_LINE if ( average == K ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT if ( dp [ index ] [ sum ] [ count ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ sum ] [ count ] ; NEW_LINE DEDENT dontpick = waysutil ( index - 1 , sum , count , arr , K ) ; NEW_LINE pick = waysutil ( index - 1 , sum + arr [ index ] , count + 1 , arr , K ) ; NEW_LINE total = pick + dontpick ; NEW_LINE dp [ index ] [ sum ] [ count ] = total ; NEW_LINE return total ; NEW_LINE DEDENT def ways ( N , K , arr ) : NEW_LINE INDENT Arr = [ ] ; NEW_LINE Arr . append ( - 1 ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT Arr . append ( arr [ i ] ) ; NEW_LINE DEDENT answer = waysutil ( N , 0 , 0 , Arr , K ) ; NEW_LINE return answer ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 6 , 2 , 8 , 7 , 6 , 5 , 9 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE K = 5 ; NEW_LINE print ( ways ( N , K , arr ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1871_A", "sol": 0, "python_code": "def setmiddlebits ( n ) :\n    n |= n >> 1 ;\n    n |= n >> 2 ;\n    n |= n >> 4 ;\n    n |= n >> 8 ;\n    n |= n >> 16 ;\n    return ( n >> 1 ) ^ 1\ndef togglemiddlebits ( n ) :\n    if ( n == 1 ) :\n        return 1\n    return n ^ setmiddlebits ( n )\nn = 9\nprint ( togglemiddlebits ( n ) )\n", "python_code_tokenized": "def setmiddlebits ( n ) : NEW_LINE INDENT n |= n >> 1 ; NEW_LINE n |= n >> 2 ; NEW_LINE n |= n >> 4 ; NEW_LINE n |= n >> 8 ; NEW_LINE n |= n >> 16 ; NEW_LINE return ( n >> 1 ) ^ 1 NEW_LINE DEDENT def togglemiddlebits ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n ^ setmiddlebits ( n ) NEW_LINE DEDENT n = 9 NEW_LINE print ( togglemiddlebits ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3106_A", "sol": 0, "python_code": "def countOcc ( s ) :\n    cnt = 0\n    for i in range ( 0 , len ( s ) - 3 ) :\n        c , l , a , p = 0 , 0 , 0 , 0\n        for j in range ( i , i + 4 ) :\n            if s [ j ] == 'c' :\n                c += 1\n            elif s [ j ] == 'l' :\n                l += 1\n            elif s [ j ] == 'a' :\n                a += 1\n            elif s [ j ] == 'p' :\n                p += 1\n        if c == 1 and l == 1 and a == 1 and p == 1 :\n            cnt += 1\n    return cnt\nif __name__ == \"__main__\" :\n    s = \"clapc\"\n    print ( countOcc ( s.lower ( ) ) )\n", "python_code_tokenized": "def countOcc ( s ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 0 , len ( s ) - 3 ) : NEW_LINE INDENT c , l , a , p = 0 , 0 , 0 , 0 NEW_LINE for j in range ( i , i + 4 ) : NEW_LINE INDENT if s [ j ] == ' c ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif s [ j ] == ' l ' : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif s [ j ] == ' a ' : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif s [ j ] == ' p ' : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT if c == 1 and l == 1 and a == 1 and p == 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" clapc \" NEW_LINE print ( countOcc ( s . lower ( ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3353_A", "sol": 0, "python_code": "def isKAlternating ( s , k ) :\n    if ( len ( s ) < k ) :\n        return False\n    checker = 0\n    for i in range ( k ) :\n        bitAtIndex = ord ( s [ i ] ) - ord ( 'a' )\n        if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) :\n            return False\n        checker = checker | ( 1 << bitAtIndex )\n    for i in range ( k , len ( s ) ) :\n        if ( s [ i - k ] != s [ i ] ) :\n            return False\n    return True\nif __name__ == \"__main__\" :\n    st = \"acdeac\"\n    K = 4\n    if ( isKAlternating ( st , K ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def isKAlternating ( s , k ) : NEW_LINE INDENT if ( len ( s ) < k ) : NEW_LINE INDENT return False NEW_LINE DEDENT checker = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT bitAtIndex = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT checker = checker | ( 1 << bitAtIndex ) NEW_LINE DEDENT for i in range ( k , len ( s ) ) : NEW_LINE INDENT if ( s [ i - k ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \" acdeac \" NEW_LINE K = 4 NEW_LINE if ( isKAlternating ( st , K ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "projecteuler_p518_A", "sol": 0, "python_code": "import eulerlib , fractions , itertools\ndef compute ( ) :\n    LIMIT = 10 ** 8\n    ans = 0\n    isprime = eulerlib.list_primality ( LIMIT - 1 )\n    for x in range ( 1 , LIMIT // 4 + 1 ) :\n        for y in itertools.count ( 1 ) :\n            a = x * y * y - 1\n            if a >= LIMIT :\n                break\n            if not isprime [ a ] :\n                continue\n            for z in itertools.count ( y + 1 ) :\n                if fractions.gcd ( y , z ) != 1 :\n                    continue\n                c = x * z * z - 1\n                if c >= LIMIT :\n                    break\n                if isprime [ c ] :\n                    b = x * y * z - 1\n                    if isprime [ b ] :\n                        ans += a + b + c\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE ans = 0 NEW_LINE isprime = eulerlib . list_primality ( LIMIT - 1 ) NEW_LINE for x in range ( 1 , LIMIT // 4 + 1 ) : NEW_LINE INDENT for y in itertools . count ( 1 ) : NEW_LINE INDENT a = x * y * y - 1 NEW_LINE if a >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if not isprime [ a ] : NEW_LINE INDENT continue NEW_LINE DEDENT for z in itertools . count ( y + 1 ) : NEW_LINE INDENT if fractions . gcd ( y , z ) != 1 : NEW_LINE INDENT continue NEW_LINE DEDENT c = x * z * z - 1 NEW_LINE if c >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if isprime [ c ] : NEW_LINE INDENT b = x * y * z - 1 NEW_LINE if isprime [ b ] : NEW_LINE INDENT ans += a + b + c NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "projecteuler_p187_A", "sol": 0, "python_code": "import eulerlib\ndef compute ( ) :\n    LIMIT = 10 ** 8 - 1\n    ans = 0\n    primes = eulerlib.list_primes ( LIMIT // 2 )\n    sqrt = eulerlib.sqrt ( LIMIT )\n    for ( i , p ) in enumerate ( primes ) :\n        if p > sqrt :\n            break\n        end = binary_search ( primes , LIMIT // p )\n        ans += ( end + 1 if end >= 0 else - end - 1 ) - i\n    return str ( ans )\ndef binary_search ( lst , x ) :\n    start = 0\n    end = len ( lst )\n    while start < end :\n        mid = ( start + end ) // 2\n        if x < lst [ mid ] :\n            end = mid\n        elif x > lst [ mid ] :\n            start = mid + 1\n        elif x == lst [ mid ] :\n            return mid\n        else :\n            raise AssertionError ( )\n    return - start - 1\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 - 1 NEW_LINE ans = 0 NEW_LINE primes = eulerlib . list_primes ( LIMIT // 2 ) NEW_LINE sqrt = eulerlib . sqrt ( LIMIT ) NEW_LINE for ( i , p ) in enumerate ( primes ) : NEW_LINE INDENT if p > sqrt : NEW_LINE INDENT break NEW_LINE DEDENT end = binary_search ( primes , LIMIT // p ) NEW_LINE ans += ( end + 1 if end >= 0 else - end - 1 ) - i NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT def binary_search ( lst , x ) : NEW_LINE INDENT start = 0 NEW_LINE end = len ( lst ) NEW_LINE while start < end : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if x < lst [ mid ] : NEW_LINE INDENT end = mid NEW_LINE DEDENT elif x > lst [ mid ] : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT elif x == lst [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT DEDENT return - start - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3816_A", "sol": 0, "python_code": "import sys ;\ndef solve ( X , A ) :\n    minimum = sys.maxsize ;\n    ind = - 1 ;\n    for i in range ( len ( A ) ) :\n        if ( A [ i ] < minimum ) :\n            minimum = A [ i ] ;\n            ind = i ;\n    maxIndChosen = X // minimum ;\n    ans = [ ] ;\n    if ( maxIndChosen == 0 ) :\n        return ans ;\n    for i in range ( maxIndChosen ) :\n        ans.append ( ind ) ;\n    temp = maxIndChosen ;\n    sum = maxIndChosen * A [ ind ] ;\n    for i in range ( ind ) :\n        if ( sum - X == 0 or temp == 0 ) :\n            break ;\n        while ( ( sum - A [ ind ] + A [ i ] ) <= X and temp != 0 ) :\n            del ( ans [ 0 ] ) ;\n            ans.append ( i ) ;\n            temp -= 1 ;\n            sum += ( A [ i ] - A [ ind ] ) ;\n    ans.sort ( ) ;\n    return ans ;\nif __name__ == \"__main__\" :\n    A = [ 5 , 6 , 4 , 8 ] ;\n    X = 18 ;\n    ans = solve ( X , A ) ;\n    for i in range ( len ( ans ) ) :\n        print ( ans [ i ] , end = \" \" ) ;\n", "python_code_tokenized": "import sys ; NEW_LINE def solve ( X , A ) : NEW_LINE INDENT minimum = sys . maxsize ; NEW_LINE ind = - 1 ; NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] < minimum ) : NEW_LINE INDENT minimum = A [ i ] ; NEW_LINE ind = i ; NEW_LINE DEDENT DEDENT maxIndChosen = X // minimum ; NEW_LINE ans = [ ] ; NEW_LINE if ( maxIndChosen == 0 ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT for i in range ( maxIndChosen ) : NEW_LINE INDENT ans . append ( ind ) ; NEW_LINE DEDENT temp = maxIndChosen ; NEW_LINE sum = maxIndChosen * A [ ind ] ; NEW_LINE for i in range ( ind ) : NEW_LINE INDENT if ( sum - X == 0 or temp == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT while ( ( sum - A [ ind ] + A [ i ] ) <= X and temp != 0 ) : NEW_LINE INDENT del ( ans [ 0 ] ) ; NEW_LINE ans . append ( i ) ; NEW_LINE temp -= 1 ; NEW_LINE sum += ( A [ i ] - A [ ind ] ) ; NEW_LINE DEDENT DEDENT ans . sort ( ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 5 , 6 , 4 , 8 ] ; NEW_LINE X = 18 ; NEW_LINE ans = solve ( X , A ) ; NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_65_A", "sol": 0, "python_code": "a , b , c , d , e , f = map ( int , input ( ).split ( ) )\nprint ( 'Ron' if a * e * c < f * d * b or ( c == 0 and d ) or ( a == 0 and b and d ) else 'Hermione' )\n", "python_code_tokenized": "a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ' Ron ' if a * e * c < f * d * b or ( c == 0 and d ) or ( a == 0 and b and d ) else ' Hermione ' ) NEW_LINE"}
{"id": "codeforces_1535_B", "sol": 0, "python_code": "import math\nfor _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    arr = list ( map ( int , input ( ).split ( ) ) )\n    ans = 0\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            if math.gcd ( arr [ i ] , 2 * arr [ j ] ) > 1 or math.gcd ( 2 * arr [ i ] , arr [ j ] ) > 1 :\n                ans += 1\n    print ( ans )\n", "python_code_tokenized": "import math NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if math . gcd ( arr [ i ] , 2 * arr [ j ] ) > 1 or math . gcd ( 2 * arr [ i ] , arr [ j ] ) > 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3633_A", "sol": 0, "python_code": "def isSlopeGood ( slope , arr , n ) :\n    setOfLines = dict ( )\n    for i in range ( n ) :\n        setOfLines [ arr [ i ] - slope * ( i ) ] = 1\n    return len ( setOfLines ) == 2\ndef checkForParallel ( arr , n ) :\n    slope1 = isSlopeGood ( arr [ 1 ] - arr [ 0 ] , arr , n )\n    slope2 = isSlopeGood ( arr [ 2 ] - arr [ 1 ] , arr , n )\n    slope3 = isSlopeGood ( ( arr [ 2 ] - arr [ 0 ] ) // 2 , arr , n )\n    return ( slope1 or slope2 or slope3 )\narr = [ 1 , 6 , 3 , 8 , 5 ]\nn = len ( arr )\nif checkForParallel ( arr , n ) :\n    print ( 1 )\nelse :\n    print ( 0 )\n", "python_code_tokenized": "def isSlopeGood ( slope , arr , n ) : NEW_LINE INDENT setOfLines = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT setOfLines [ arr [ i ] - slope * ( i ) ] = 1 NEW_LINE DEDENT return len ( setOfLines ) == 2 NEW_LINE DEDENT def checkForParallel ( arr , n ) : NEW_LINE INDENT slope1 = isSlopeGood ( arr [ 1 ] - arr [ 0 ] , arr , n ) NEW_LINE slope2 = isSlopeGood ( arr [ 2 ] - arr [ 1 ] , arr , n ) NEW_LINE slope3 = isSlopeGood ( ( arr [ 2 ] - arr [ 0 ] ) // 2 , arr , n ) NEW_LINE return ( slope1 or slope2 or slope3 ) NEW_LINE DEDENT arr = [ 1 , 6 , 3 , 8 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE if checkForParallel ( arr , n ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3045_A", "sol": 0, "python_code": "MAX_K = 15\nfac = [ 1 for i in range ( MAX_K ) ]\ndef factorial ( k ) :\n    fac [ 0 ] = 1\n    for i in range ( 1 , k + 2 ) :\n        fac [ i ] = ( i * fac [ i - 1 ] )\ndef bin ( a , b ) :\n    ans = fac [ a ] // ( fac [ a - b ] * fac [ b ] )\n    return ans\ndef sumofn ( n , k ) :\n    p = 0\n    num1 , temp = 1 , 1\n    arr = [ 1 for i in range ( 1000 ) ]\n    for j in range ( 1 , k + 1 ) :\n        if j == 1 :\n            num1 = ( n * ( n + 1 ) ) // 2\n            arr [ p ] = num1\n            p += 1\n        else :\n            temp = pow ( n + 1 , j + 1 ) - 1 - n\n            for s in range ( 1 , j ) :\n                temp = temp - ( arr [ j - s - 1 ] * bin ( j + 1 , s + 1 ) )\n            temp = temp // ( j + 1 )\n            arr [ p ] = temp\n            p += 1\n    temp = arr [ p - 1 ]\n    return temp\nn , k = 5 , 2\nfactorial ( k )\nprint ( sumofn ( n , k ) )\n", "python_code_tokenized": "MAX_K = 15 NEW_LINE fac = [ 1 for i in range ( MAX_K ) ] NEW_LINE def factorial ( k ) : NEW_LINE INDENT fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , k + 2 ) : NEW_LINE INDENT fac [ i ] = ( i * fac [ i - 1 ] ) NEW_LINE DEDENT DEDENT def bin ( a , b ) : NEW_LINE INDENT ans = fac [ a ] // ( fac [ a - b ] * fac [ b ] ) NEW_LINE return ans NEW_LINE DEDENT def sumofn ( n , k ) : NEW_LINE INDENT p = 0 NEW_LINE num1 , temp = 1 , 1 NEW_LINE arr = [ 1 for i in range ( 1000 ) ] NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if j == 1 : NEW_LINE INDENT num1 = ( n * ( n + 1 ) ) // 2 NEW_LINE arr [ p ] = num1 NEW_LINE p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp = pow ( n + 1 , j + 1 ) - 1 - n NEW_LINE for s in range ( 1 , j ) : NEW_LINE INDENT temp = temp - ( arr [ j - s - 1 ] * bin ( j + 1 , s + 1 ) ) NEW_LINE DEDENT temp = temp // ( j + 1 ) NEW_LINE arr [ p ] = temp NEW_LINE p += 1 NEW_LINE DEDENT DEDENT temp = arr [ p - 1 ] NEW_LINE return temp NEW_LINE DEDENT n , k = 5 , 2 NEW_LINE factorial ( k ) NEW_LINE print ( sumofn ( n , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_471_A", "sol": 0, "python_code": "mod = 1000000007\nMAX = 10000\nprefix = [ 0 ] * ( MAX + 1 )\ndef buildPrefix ( ) :\n    prime = [ True ] * ( MAX + 1 )\n    p = 2\n    while p * p <= MAX :\n        if ( prime [ p ] == True ) :\n            for i in range ( p * 2 , MAX + 1 , p ) :\n                prime [ i ] = False\n        p += 1\n    prefix [ 0 ] = prefix [ 1 ] = 1\n    for p in range ( 2 , MAX + 1 ) :\n        prefix [ p ] = prefix [ p - 1 ]\n        if ( prime [ p ] ) :\n            prefix [ p ] = ( prefix [ p ] * p ) % mod\ndef power ( x , y , p ) :\n    res = 1\n    x = x % p\n    while ( y > 0 ) :\n        if ( y & 1 ) :\n            res = ( res * x ) % p\n        y = y >> 1\n        x = ( x * x ) % p\n    return res\ndef inverse ( n ) :\n    return power ( n , mod - 2 , mod )\ndef productPrimeRange ( L , R ) :\n    return ( prefix [ R ] * inverse ( prefix [ L - 1 ] ) ) % mod\nif __name__ == \"__main__\" :\n    buildPrefix ( )\n    L = 10\n    R = 20\n    print ( productPrimeRange ( L , R ) )\n", "python_code_tokenized": "mod = 1000000007 NEW_LINE MAX = 10000 NEW_LINE prefix = [ 0 ] * ( MAX + 1 ) NEW_LINE def buildPrefix ( ) : NEW_LINE INDENT prime = [ True ] * ( MAX + 1 ) NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT prefix [ 0 ] = prefix [ 1 ] = 1 NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT prefix [ p ] = prefix [ p - 1 ] NEW_LINE if ( prime [ p ] ) : NEW_LINE INDENT prefix [ p ] = ( prefix [ p ] * p ) % mod NEW_LINE DEDENT DEDENT DEDENT def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def inverse ( n ) : NEW_LINE INDENT return power ( n , mod - 2 , mod ) NEW_LINE DEDENT def productPrimeRange ( L , R ) : NEW_LINE INDENT return ( prefix [ R ] * inverse ( prefix [ L - 1 ] ) ) % mod NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT buildPrefix ( ) NEW_LINE L = 10 NEW_LINE R = 20 NEW_LINE print ( productPrimeRange ( L , R ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4714_A", "sol": 0, "python_code": "def factorial ( n ) :\n    if ( n == 0 ) :\n        return 1 ;\n    return n * factorial ( n - 1 ) ;\ndef countNum ( n ) :\n    if ( n > 10 ) :\n        return 0 ;\n    return ( 9 * factorial ( 9 ) // factorial ( 10 - n ) ) ;\nif __name__ == \"__main__\" :\n    n = 3 ;\n    print ( countNum ( n ) ) ;\n", "python_code_tokenized": "def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return n * factorial ( n - 1 ) ; NEW_LINE DEDENT def countNum ( n ) : NEW_LINE INDENT if ( n > 10 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return ( 9 * factorial ( 9 ) // factorial ( 10 - n ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE print ( countNum ( n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3306_A", "sol": 0, "python_code": "def countWays ( n , k ) :\n    total = k\n    mod = 1000000007\n    same , diff = 0 , k\n    for i in range ( 2 , n + 1 ) :\n        same = diff\n        diff = total * ( k - 1 )\n        diff = diff % mod\n        total = ( same + diff ) % mod\n    return total\nif __name__ == \"__main__\" :\n    n , k = 3 , 2\n    print ( countWays ( n , k ) )\n", "python_code_tokenized": "def countWays ( n , k ) : NEW_LINE INDENT total = k NEW_LINE mod = 1000000007 NEW_LINE same , diff = 0 , k NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT same = diff NEW_LINE diff = total * ( k - 1 ) NEW_LINE diff = diff % mod NEW_LINE total = ( same + diff ) % mod NEW_LINE DEDENT return total NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 3 , 2 NEW_LINE print ( countWays ( n , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1441_A", "sol": 0, "python_code": "def print_max ( a , n , k ) :\n    max_upto = [ 0 for i in range ( n ) ]\n    s = [ ]\n    s.append ( 0 )\n    for i in range ( 1 , n ) :\n        while ( len ( s ) > 0 and a [ s [ - 1 ] ] < a [ i ] ) :\n            max_upto [ s [ - 1 ] ] = i - 1\n            del s [ - 1 ]\n        s.append ( i )\n    while ( len ( s ) > 0 ) :\n        max_upto [ s [ - 1 ] ] = n - 1\n        del s [ - 1 ]\n    j = 0\n    for i in range ( n - k + 1 ) :\n        while ( j < i or max_upto [ j ] < i + k - 1 ) :\n            j += 1\n        print ( a [ j ] , end = \" \" )\n    print ( )\na = [ 9 , 7 , 2 , 4 , 6 , 8 , 2 , 1 , 5 ]\nn = len ( a )\nk = 3\nprint_max ( a , n , k )\n", "python_code_tokenized": "def print_max ( a , n , k ) : NEW_LINE INDENT max_upto = [ 0 for i in range ( n ) ] NEW_LINE s = [ ] NEW_LINE s . append ( 0 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( s ) > 0 and a [ s [ - 1 ] ] < a [ i ] ) : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = i - 1 NEW_LINE del s [ - 1 ] NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = n - 1 NEW_LINE del s [ - 1 ] NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT while ( j < i or max_upto [ j ] < i + k - 1 ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT print ( a [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT a = [ 9 , 7 , 2 , 4 , 6 , 8 , 2 , 1 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print_max ( a , n , k ) NEW_LINE"}
{"id": "geeksforgeeks_4359_A", "sol": 0, "python_code": "R = 4\nC = 4\ndef reverseColumns ( arr ) :\n    for i in range ( C ) :\n        j = 0\n        k = C - 1\n        while j < k :\n            t = arr [ j ] [ i ]\n            arr [ j ] [ i ] = arr [ k ] [ i ]\n            arr [ k ] [ i ] = t\n            j += 1\n            k -= 1\ndef transpose ( arr ) :\n    for i in range ( R ) :\n        for j in range ( i , C ) :\n            t = arr [ i ] [ j ]\n            arr [ i ] [ j ] = arr [ j ] [ i ]\n            arr [ j ] [ i ] = t\ndef printMatrix ( arr ) :\n    for i in range ( R ) :\n        for j in range ( C ) :\n            print ( arr [ i ] [ j ] , end = \" \" ) ;\n        print ( ) ;\ndef rotate180 ( arr ) :\n    transpose ( arr ) ;\n    reverseColumns ( arr ) ;\n    transpose ( arr ) ;\n    reverseColumns ( arr ) ;\narr = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] , [ 13 , 14 , 15 , 16 ] ] ;\nrotate180 ( arr ) ;\nprintMatrix ( arr ) ;\n", "python_code_tokenized": "R = 4 NEW_LINE C = 4 NEW_LINE def reverseColumns ( arr ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT j = 0 NEW_LINE k = C - 1 NEW_LINE while j < k : NEW_LINE INDENT t = arr [ j ] [ i ] NEW_LINE arr [ j ] [ i ] = arr [ k ] [ i ] NEW_LINE arr [ k ] [ i ] = t NEW_LINE j += 1 NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT DEDENT def transpose ( arr ) : NEW_LINE INDENT for i in range ( R ) : NEW_LINE INDENT for j in range ( i , C ) : NEW_LINE INDENT t = arr [ i ] [ j ] NEW_LINE arr [ i ] [ j ] = arr [ j ] [ i ] NEW_LINE arr [ j ] [ i ] = t NEW_LINE DEDENT DEDENT DEDENT def printMatrix ( arr ) : NEW_LINE INDENT for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT def rotate180 ( arr ) : NEW_LINE INDENT transpose ( arr ) ; NEW_LINE reverseColumns ( arr ) ; NEW_LINE transpose ( arr ) ; NEW_LINE reverseColumns ( arr ) ; NEW_LINE DEDENT arr = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] , [ 13 , 14 , 15 , 16 ] ] ; NEW_LINE rotate180 ( arr ) ; NEW_LINE printMatrix ( arr ) ; NEW_LINE"}
{"id": "geeksforgeeks_4943_A", "sol": 0, "python_code": "def printLargestString ( s , l , r ) :\n    freq = [ 0 ] * 26\n    l -= 1\n    r -= 1\n    for i in range ( min ( l , r ) , max ( l , r ) + 1 ) :\n        freq [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1\n    ans = \"\"\n    for i in range ( 25 , - 1 , - 1 ) :\n        while ( freq [ i ] ) :\n            ans += chr ( ord ( 'a' ) + i )\n            freq [ i ] -= 1\n    return ans\nif __name__ == \"__main__\" :\n    s = \"striver\"\n    l = 3\n    r = 5\n    print ( printLargestString ( s , l , r ) )\n", "python_code_tokenized": "def printLargestString ( s , l , r ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE for i in range ( min ( l , r ) , max ( l , r ) + 1 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE for i in range ( 25 , - 1 , - 1 ) : NEW_LINE INDENT while ( freq [ i ] ) : NEW_LINE INDENT ans += chr ( ord ( ' a ' ) + i ) NEW_LINE freq [ i ] -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" striver \" NEW_LINE l = 3 NEW_LINE r = 5 NEW_LINE print ( printLargestString ( s , l , r ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_253_A", "sol": 0, "python_code": "def xorOfArray ( arr , n ) :\n    xor_arr = 0\n    for i in range ( n ) :\n        xor_arr = xor_arr ^ arr [ i ]\n    return xor_arr\nif __name__ == '__main__' :\n    arr = [ 3 , 9 , 12 , 13 , 15 ]\n    n = len ( arr )\n    print ( xorOfArray ( arr , n ) )\n", "python_code_tokenized": "def xorOfArray ( arr , n ) : NEW_LINE INDENT xor_arr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xor_arr = xor_arr ^ arr [ i ] NEW_LINE DEDENT return xor_arr NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 9 , 12 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( xorOfArray ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00728_A", "sol": 0, "python_code": "while True :\n    N = int ( input ( ) )\n    if N == 0 :\n        break\n    S = [ ]\n    for i in range ( N ) :\n        S.append ( int ( input ( ) ) )\n    print ( ( sum ( S ) - max ( S ) - min ( S ) ) // ( N - 2 ) )\n", "python_code_tokenized": "while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT S = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT S . append ( int ( input ( ) ) ) NEW_LINE DEDENT print ( ( sum ( S ) - max ( S ) - min ( S ) ) // ( N - 2 ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1003_B", "sol": 0, "python_code": "from math import ceil\nfrom sys import stdin , stdout\nimport sys\ndef get_ints ( ) : return map ( int , sys.stdin.readline ( ).strip ( ).split ( ) )\ndef get_arr ( ) : return list ( map ( int , sys.stdin.readline ( ).strip ( ).split ( ) ) )\ndef get_string ( ) : return sys.stdin.readline ( ).strip ( )\na , b , x = get_ints ( )\nif x % 2 == 0 :\n    if a > b :\n        for i in range ( 0 , int ( x / 2 ) ) :\n            print ( \"01\" , end = \"\" )\n        a -= int ( x / 2 )\n        b -= int ( x / 2 )\n        for i in range ( 0 , b ) :\n            print ( \"1\" , end = \"\" )\n        for i in range ( 0 , a ) :\n            print ( \"0\" , end = \"\" )\n    else :\n        for i in range ( 0 , int ( x / 2 ) ) :\n            print ( \"10\" , end = \"\" )\n        a -= int ( x / 2 )\n        b -= int ( x / 2 )\n        for i in range ( 0 , a ) :\n            print ( \"0\" , end = \"\" )\n        for i in range ( 0 , b ) :\n            print ( \"1\" , end = \"\" )\nelse :\n    for i in range ( 0 , int ( ( x ) / 2 ) ) :\n        print ( \"01\" , end = \"\" )\n    a -= int ( x / 2 )\n    b -= int ( x / 2 )\n    for i in range ( 0 , a ) :\n        print ( \"0\" , end = \"\" )\n    for i in range ( 0 , b ) :\n        print ( \"1\" , end = \"\" )\n", "python_code_tokenized": "from math import ceil NEW_LINE from sys import stdin , stdout NEW_LINE import sys NEW_LINE def get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE def get_arr ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE a , b , x = get_ints ( ) NEW_LINE if x % 2 == 0 : NEW_LINE INDENT if a > b : NEW_LINE INDENT for i in range ( 0 , int ( x / 2 ) ) : NEW_LINE INDENT print ( \"01\" , end = \" \" ) NEW_LINE DEDENT a -= int ( x / 2 ) NEW_LINE b -= int ( x / 2 ) NEW_LINE for i in range ( 0 , b ) : NEW_LINE INDENT print ( \"1\" , end = \" \" ) NEW_LINE DEDENT for i in range ( 0 , a ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 0 , int ( x / 2 ) ) : NEW_LINE INDENT print ( \"10\" , end = \" \" ) NEW_LINE DEDENT a -= int ( x / 2 ) NEW_LINE b -= int ( x / 2 ) NEW_LINE for i in range ( 0 , a ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT for i in range ( 0 , b ) : NEW_LINE INDENT print ( \"1\" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 0 , int ( ( x ) / 2 ) ) : NEW_LINE INDENT print ( \"01\" , end = \" \" ) NEW_LINE DEDENT a -= int ( x / 2 ) NEW_LINE b -= int ( x / 2 ) NEW_LINE for i in range ( 0 , a ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) NEW_LINE DEDENT for i in range ( 0 , b ) : NEW_LINE INDENT print ( \"1\" , end = \" \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3875_A", "sol": 0, "python_code": "def difference ( arr , n ) :\n    largest = arr [ 0 ] ;\n    i = 0 ;\n    for i in range ( n ) :\n        if ( largest < arr [ i ] ) :\n            largest = arr [ i ] ;\n    for i in range ( n ) :\n        arr [ i ] = largest - arr [ i ] ;\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" ) ;\nif __name__ == '__main__' :\n    arr = [ 10 , 5 , 9 , 3 , 2 ] ;\n    n = len ( arr ) ;\n    difference ( arr , n ) ;\n", "python_code_tokenized": "def difference ( arr , n ) : NEW_LINE INDENT largest = arr [ 0 ] ; NEW_LINE i = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( largest < arr [ i ] ) : NEW_LINE INDENT largest = arr [ i ] ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = largest - arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 5 , 9 , 3 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE difference ( arr , n ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3561_A", "sol": 0, "python_code": "mod = 1000000007\ndef power ( a , n ) :\n    if ( n == 0 ) :\n        return 1\n    p = power ( a , int ( n / 2 ) ) % mod ;\n    p = ( p * p ) % mod\n    if ( n & 1 ) :\n        p = ( p * a ) % mod\n    return p\ndef countPermutations ( n ) :\n    if ( n == 1 ) :\n        return 0\n    return ( power ( 2 , n - 1 ) - 2 ) % mod\nif __name__ == '__main__' :\n    n = 5\n    print ( countPermutations ( n ) )\n", "python_code_tokenized": "mod = 1000000007 NEW_LINE def power ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , int ( n / 2 ) ) % mod ; NEW_LINE p = ( p * p ) % mod NEW_LINE if ( n & 1 ) : NEW_LINE INDENT p = ( p * a ) % mod NEW_LINE DEDENT return p NEW_LINE DEDENT def countPermutations ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( power ( 2 , n - 1 ) - 2 ) % mod NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( countPermutations ( n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1370_B", "sol": 0, "python_code": "for s in [ * open ( 0 ) ] [ 2 : : 2 ] :\n    a = [ [ ] , [ ] ] ; i = 0\n    for x in s.split ( ) : i += 1 ; a [ int ( x ) % 2 ] += i ,\n    a.sort ( key = len ) ; b , c = a ; c.pop ( ) ; a [ len ( c ) % 2 ].pop ( ) ; print ( * b , * c )\n", "python_code_tokenized": "for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT a = [ [ ] , [ ] ] ; i = 0 NEW_LINE for x in s . split ( ) : i += 1 ; a [ int ( x ) % 2 ] += i , NEW_LINE a . sort ( key = len ) ; b , c = a ; c . pop ( ) ; a [ len ( c ) % 2 ] . pop ( ) ; print ( * b , * c ) NEW_LINE DEDENT"}
{"id": "codeforces_634_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = [ int ( x ) for x in input ( ).split ( ) ]\nb = [ int ( x ) for x in input ( ).split ( ) ]\nif a [ 0 ] != 0 :\n    index_b = b.index ( a [ 0 ] )\nelse :\n    index_b = b.index ( a [ 1 ] )\nfor index_a in range ( 0 , len ( a ) ) :\n    if a [ index_a ] == 0 :\n        continue\n    if b [ index_b % len ( a ) ] == 0 :\n        index_b += 1\n    if a [ index_a ] != b [ index_b % len ( a ) ] :\n        print ( 'NO' )\n        exit ( )\n    index_b += 1\nprint ( 'YES' )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if a [ 0 ] != 0 : NEW_LINE INDENT index_b = b . index ( a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT index_b = b . index ( a [ 1 ] ) NEW_LINE DEDENT for index_a in range ( 0 , len ( a ) ) : NEW_LINE INDENT if a [ index_a ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if b [ index_b % len ( a ) ] == 0 : NEW_LINE INDENT index_b += 1 NEW_LINE DEDENT if a [ index_a ] != b [ index_b % len ( a ) ] : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE exit ( ) NEW_LINE DEDENT index_b += 1 NEW_LINE DEDENT print ( ' YES ' ) NEW_LINE"}
{"id": "geeksforgeeks_4888_A", "sol": 0, "python_code": "def minCost ( arr , cost , n ) :\n    costThree = 10 ** 9\n    for j in range ( n ) :\n        costI = 10 ** 9\n        costK = 10 ** 9\n        for i in range ( j ) :\n            if ( arr [ i ] < arr [ j ] ) :\n                costI = min ( costI , cost [ i ] )\n        for k in range ( j + 1 , n ) :\n            if ( arr [ k ] > arr [ j ] ) :\n                costK = min ( costK , cost [ k ] )\n        if ( costI != 10 ** 9 and costK != 10 ** 9 ) :\n            costThree = min ( costThree , cost [ j ] + costI + costK )\n    if ( costThree == 10 ** 9 ) :\n        return - 1\n    return costThree\narr = [ 2 , 4 , 5 , 4 , 10 ]\ncost = [ 40 , 30 , 20 , 10 , 40 ]\nn = len ( arr )\nprint ( minCost ( arr , cost , n ) )\n", "python_code_tokenized": "def minCost ( arr , cost , n ) : NEW_LINE INDENT costThree = 10 ** 9 NEW_LINE for j in range ( n ) : NEW_LINE INDENT costI = 10 ** 9 NEW_LINE costK = 10 ** 9 NEW_LINE for i in range ( j ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT costI = min ( costI , cost [ i ] ) NEW_LINE DEDENT DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ k ] > arr [ j ] ) : NEW_LINE INDENT costK = min ( costK , cost [ k ] ) NEW_LINE DEDENT DEDENT if ( costI != 10 ** 9 and costK != 10 ** 9 ) : NEW_LINE INDENT costThree = min ( costThree , cost [ j ] + costI + costK ) NEW_LINE DEDENT DEDENT if ( costThree == 10 ** 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return costThree NEW_LINE DEDENT arr = [ 2 , 4 , 5 , 4 , 10 ] NEW_LINE cost = [ 40 , 30 , 20 , 10 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , cost , n ) ) NEW_LINE"}
{"id": "codeforces_1095_A", "sol": 0, "python_code": "n = int ( input ( ) )\nm = input ( )\ni , j = 0 , 0\nwhile ( i < n ) :\n    print ( m [ i ] , end = '' )\n    j += 1\n    i += j\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE m = input ( ) NEW_LINE i , j = 0 , 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT print ( m [ i ] , end = ' ' ) NEW_LINE j += 1 NEW_LINE i += j NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2122_A", "sol": 0, "python_code": "def KthMinValAfterMconcatenate ( A , N , M , K ) :\n    V = [ ]\n    for i in range ( 0 , M ) :\n        for j in range ( 0 , N ) :\n            V.append ( A [ j ] )\n    V.sort ( )\n    return V [ K - 1 ]\nif __name__ == \"__main__\" :\n    A = [ 3 , 1 , 2 ]\n    M , K = 3 , 4\n    N = len ( A )\n    print ( KthMinValAfterMconcatenate ( A , N , M , K ) )\n", "python_code_tokenized": "def KthMinValAfterMconcatenate ( A , N , M , K ) : NEW_LINE INDENT V = [ ] NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT V . append ( A [ j ] ) NEW_LINE DEDENT DEDENT V . sort ( ) NEW_LINE return V [ K - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 3 , 1 , 2 ] NEW_LINE M , K = 3 , 4 NEW_LINE N = len ( A ) NEW_LINE print ( KthMinValAfterMconcatenate ( A , N , M , K ) ) NEW_LINE DEDENT"}
{"id": "codeforces_792_A", "sol": 0, "python_code": "n = int ( input ( ) )\ncities = list ( map ( int , input ( ).split ( ) ) )\ncities.sort ( )\nmin_lenth = 10 ** 11\ncol = 0\nfor i in range ( n - 1 ) :\n    if cities [ i + 1 ] - cities [ i ] < min_lenth :\n        min_lenth = cities [ i + 1 ] - cities [ i ]\n        col = 1\n    elif cities [ i + 1 ] - cities [ i ] == min_lenth :\n        col += 1\nprint ( min_lenth , col )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE cities = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cities . sort ( ) NEW_LINE min_lenth = 10 ** 11 NEW_LINE col = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if cities [ i + 1 ] - cities [ i ] < min_lenth : NEW_LINE INDENT min_lenth = cities [ i + 1 ] - cities [ i ] NEW_LINE col = 1 NEW_LINE DEDENT elif cities [ i + 1 ] - cities [ i ] == min_lenth : NEW_LINE INDENT col += 1 NEW_LINE DEDENT DEDENT print ( min_lenth , col ) NEW_LINE"}
{"id": "geeksforgeeks_208_A", "sol": 0, "python_code": "def drawPattern ( N ) :\n    n = N ;\n    row = 1 ;\n    nst = 1 ;\n    nsp1 = n - 1 ;\n    nsp2 = - 1 ;\n    val1 = row ;\n    val2 = 1 ;\n    while ( row <= n ) :\n        csp1 = 1 ;\n        while ( csp1 <= nsp1 ) :\n            print ( \" \" , end = \" \" ) ;\n            csp1 = csp1 + 1 ;\n        cst1 = 1 ;\n        while ( cst1 <= nst ) :\n            print ( val1 , end = \" \" ) ;\n            val1 = val1 - 1 ;\n            cst1 = cst1 + 1 ;\n        csp2 = 1 ;\n        while ( csp2 <= nsp2 ) :\n            print ( \" \" , end = \" \" ) ;\n            csp2 = csp2 + 1 ;\n        if ( row != 1 and row != n ) :\n            cst2 = 1 ;\n            while ( cst2 <= nst ) :\n                print ( val2 , end = \" \" ) ;\n                val2 = val2 + 1 ;\n                cst2 = cst2 + 1 ;\n        print ( )\n        if ( row <= n // 2 ) :\n            nst = nst + 1 ;\n            nsp1 = nsp1 - 2 ;\n            nsp2 = nsp2 + 2 ;\n            val1 = row + 1 ;\n            val2 = 1 ;\n        else :\n            nst = nst - 1 ;\n            nsp1 = nsp1 + 2 ;\n            nsp2 = nsp2 - 2 ;\n            val1 = n - row ;\n            val2 = 1 ;\n        row = row + 1 ;\nif __name__ == \"__main__\" :\n    N = 7 ;\n    drawPattern ( N ) ;\n", "python_code_tokenized": "def drawPattern ( N ) : NEW_LINE INDENT n = N ; NEW_LINE row = 1 ; NEW_LINE nst = 1 ; NEW_LINE nsp1 = n - 1 ; NEW_LINE nsp2 = - 1 ; NEW_LINE val1 = row ; NEW_LINE val2 = 1 ; NEW_LINE while ( row <= n ) : NEW_LINE INDENT csp1 = 1 ; NEW_LINE while ( csp1 <= nsp1 ) : NEW_LINE INDENT print ( \" \u2581 \" , end = \" \u2581 \" ) ; NEW_LINE csp1 = csp1 + 1 ; NEW_LINE DEDENT cst1 = 1 ; NEW_LINE while ( cst1 <= nst ) : NEW_LINE INDENT print ( val1 , end = \" \u2581 \" ) ; NEW_LINE val1 = val1 - 1 ; NEW_LINE cst1 = cst1 + 1 ; NEW_LINE DEDENT csp2 = 1 ; NEW_LINE while ( csp2 <= nsp2 ) : NEW_LINE INDENT print ( \" \u2581 \" , end = \" \u2581 \" ) ; NEW_LINE csp2 = csp2 + 1 ; NEW_LINE DEDENT if ( row != 1 and row != n ) : NEW_LINE INDENT cst2 = 1 ; NEW_LINE while ( cst2 <= nst ) : NEW_LINE INDENT print ( val2 , end = \" \u2581 \" ) ; NEW_LINE val2 = val2 + 1 ; NEW_LINE cst2 = cst2 + 1 ; NEW_LINE DEDENT DEDENT print ( ) NEW_LINE if ( row <= n // 2 ) : NEW_LINE INDENT nst = nst + 1 ; NEW_LINE nsp1 = nsp1 - 2 ; NEW_LINE nsp2 = nsp2 + 2 ; NEW_LINE val1 = row + 1 ; NEW_LINE val2 = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT nst = nst - 1 ; NEW_LINE nsp1 = nsp1 + 2 ; NEW_LINE nsp2 = nsp2 - 2 ; NEW_LINE val1 = n - row ; NEW_LINE val2 = 1 ; NEW_LINE DEDENT row = row + 1 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 7 ; NEW_LINE drawPattern ( N ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2103_A", "sol": 0, "python_code": "MAX = 10005\nMOD = 1000000007\ndef countNum ( idx , sum , tight , num , len1 , k ) :\n    if ( len1 == idx ) :\n        if ( sum == 0 ) :\n            return 1\n        else :\n            return 0\n    if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) :\n        return dp [ idx ] [ sum ] [ tight ]\n    res = 0\n    if ( tight == 0 ) :\n        limit = num [ idx ]\n    else :\n        limit = 9\n    for i in range ( limit + 1 ) :\n        new_tight = tight\n        if ( tight == 0 and i < limit ) :\n            new_tight = 1\n        res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len1 , k )\n        res %= MOD\n    if ( res < 0 ) :\n        res += MOD\n    dp [ idx ] [ sum ] [ tight ] = res\n    return dp [ idx ] [ sum ] [ tight ]\ndef process ( s ) :\n    num = [ ]\n    for i in range ( len ( s ) ) :\n        num.append ( ord ( s [ i ] ) - ord ( '0' ) )\n    return num\nif __name__ == '__main__' :\n    n = \"98765432109876543210\"\n    len1 = len ( n )\n    k = 58\n    dp = [ [ [ - 1 for i in range ( 2 ) ] for j in range ( 101 ) ] for k in range ( MAX ) ]\n    num = process ( n )\n    print ( countNum ( 0 , 0 , 0 , num , len1 , k ) )\n", "python_code_tokenized": "MAX = 10005 NEW_LINE MOD = 1000000007 NEW_LINE def countNum ( idx , sum , tight , num , len1 , k ) : NEW_LINE INDENT if ( len1 == idx ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ sum ] [ tight ] NEW_LINE DEDENT res = 0 NEW_LINE if ( tight == 0 ) : NEW_LINE INDENT limit = num [ idx ] NEW_LINE DEDENT else : NEW_LINE INDENT limit = 9 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT new_tight = tight NEW_LINE if ( tight == 0 and i < limit ) : NEW_LINE INDENT new_tight = 1 NEW_LINE DEDENT res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len1 , k ) NEW_LINE res %= MOD NEW_LINE DEDENT if ( res < 0 ) : NEW_LINE INDENT res += MOD NEW_LINE DEDENT dp [ idx ] [ sum ] [ tight ] = res NEW_LINE return dp [ idx ] [ sum ] [ tight ] NEW_LINE DEDENT def process ( s ) : NEW_LINE INDENT num = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT num . append ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return num NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = \"98765432109876543210\" NEW_LINE len1 = len ( n ) NEW_LINE k = 58 NEW_LINE dp = [ [ [ - 1 for i in range ( 2 ) ] for j in range ( 101 ) ] for k in range ( MAX ) ] NEW_LINE num = process ( n ) NEW_LINE print ( countNum ( 0 , 0 , 0 , num , len1 , k ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02052_A", "sol": 0, "python_code": "H , W = map ( int , input ( ).split ( ) )\ns = [ ]\nfor k in range ( H ) :\n    s.append ( input ( ) )\nB = [ ]\nfor k in range ( H ) :\n    for l in range ( W ) :\n        if s [ k ] [ l ] == \"B\" :\n            B.append ( [ k , l ] )\nans = 0\nfor e in B :\n    for f in B :\n        ans = max ( ans , abs ( e [ 0 ] - f [ 0 ] ) + abs ( e [ 1 ] - f [ 1 ] ) )\nprint ( ans )\n", "python_code_tokenized": "H , W = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for k in range ( H ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT B = [ ] NEW_LINE for k in range ( H ) : NEW_LINE INDENT for l in range ( W ) : NEW_LINE INDENT if s [ k ] [ l ] == \" B \" : NEW_LINE INDENT B . append ( [ k , l ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for e in B : NEW_LINE INDENT for f in B : NEW_LINE INDENT ans = max ( ans , abs ( e [ 0 ] - f [ 0 ] ) + abs ( e [ 1 ] - f [ 1 ] ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_1472_A", "sol": 0, "python_code": "def printRepeating ( arr , n ) :\n    for i in range ( 0 , n ) :\n        index = arr [ i ] % n\n        arr [ index ] += n\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] / n ) > 1 :\n            print ( i , end = \" \" )\narr = [ 1 , 6 , 3 , 1 , 3 , 6 , 6 ]\narr_size = len ( arr )\nprint ( \"The repeating elements are:\" )\nprintRepeating ( arr , arr_size )\n", "python_code_tokenized": "def printRepeating ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT index = arr [ i ] % n NEW_LINE arr [ index ] += n NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] / n ) > 1 : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 6 , 3 , 1 , 3 , 6 , 6 ] NEW_LINE arr_size = len ( arr ) NEW_LINE print ( \" The \u2581 repeating \u2581 elements \u2581 are : \" ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE"}
{"id": "geeksforgeeks_951_A", "sol": 0, "python_code": "def sameOccurrence ( arr , n , x , y ) :\n    result = 0\n    for i in range ( n ) :\n        ctX = 0\n        ctY = 0\n        for j in range ( i , n , 1 ) :\n            if ( arr [ j ] == x ) :\n                ctX += 1 ;\n            elif ( arr [ j ] == y ) :\n                ctY += 1\n            if ( ctX == ctY ) :\n                result += 1\n    return ( result )\nif __name__ == '__main__' :\n    arr = [ 1 , 2 , 2 , 3 , 4 , 1 ]\n    n = len ( arr )\n    x = 2\n    y = 3\n    print ( sameOccurrence ( arr , n , x , y ) )\n", "python_code_tokenized": "def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ctX = 0 NEW_LINE ctY = 0 NEW_LINE for j in range ( i , n , 1 ) : NEW_LINE INDENT if ( arr [ j ] == x ) : NEW_LINE INDENT ctX += 1 ; NEW_LINE DEDENT elif ( arr [ j ] == y ) : NEW_LINE INDENT ctY += 1 NEW_LINE DEDENT if ( ctX == ctY ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE y = 3 NEW_LINE print ( sameOccurrence ( arr , n , x , y ) ) NEW_LINE DEDENT"}
{"id": "codeforces_614_A", "sol": 0, "python_code": "n = 3\ns = [ int ( x ) for x in input ( ).split ( ) ]\nflag = 1\nnow = 1\nwhile now < s [ 0 ] :\n    now = now * s [ 2 ]\nwhile now <= s [ 1 ] :\n    print ( now , end = \" \" )\n    flag = 0\n    now = now * s [ 2 ]\nif flag :\n    print ( \"-1\" )\n", "python_code_tokenized": "n = 3 NEW_LINE s = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE flag = 1 NEW_LINE now = 1 NEW_LINE while now < s [ 0 ] : NEW_LINE INDENT now = now * s [ 2 ] NEW_LINE DEDENT while now <= s [ 1 ] : NEW_LINE INDENT print ( now , end = \" \u2581 \" ) NEW_LINE flag = 0 NEW_LINE now = now * s [ 2 ] NEW_LINE DEDENT if flag : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT"}
{"id": "aizu_p00856_A", "sol": 0, "python_code": "while True :\n    n , t , L , b = ( int ( s ) for s in input ( ).split ( ) )\n    if ( n , t , L , b ) == ( 0 , 0 , 0 , 0 ) :\n        break\n    loses = [ int ( input ( ) ) for i in range ( L ) ]\n    backs = [ int ( input ( ) ) for i in range ( b ) ]\n    dp = [ [ 0.] * n + [ 1.] for i in range ( 3 ) ]\n    stops = list ( range ( n + 1 ) ) + list ( reversed ( range ( n - 5 , n ) ) )\n    for i in reversed ( range ( t ) ) :\n        for j in range ( n ) :\n            dp [ i % 3 ] [ j ] = sum ( dp [ ( i + 2 ) % 3 ] [ d ] if d in loses else dp [ ( i + 1 ) % 3 ] [ 0 ] if d in backs else dp [ ( i + 1 ) % 3 ] [ d ] for d in stops [ j + 1 : j + 7 ] ) / 6\n    print ( '{:.6f}'.format ( dp [ 0 ] [ 0 ] ) )\n", "python_code_tokenized": "while True : NEW_LINE INDENT n , t , L , b = ( int ( s ) for s in input ( ) . split ( ) ) NEW_LINE if ( n , t , L , b ) == ( 0 , 0 , 0 , 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT loses = [ int ( input ( ) ) for i in range ( L ) ] NEW_LINE backs = [ int ( input ( ) ) for i in range ( b ) ] NEW_LINE dp = [ [ 0. ] * n + [ 1. ] for i in range ( 3 ) ] NEW_LINE stops = list ( range ( n + 1 ) ) + list ( reversed ( range ( n - 5 , n ) ) ) NEW_LINE for i in reversed ( range ( t ) ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i % 3 ] [ j ] = sum ( dp [ ( i + 2 ) % 3 ] [ d ] if d in loses else dp [ ( i + 1 ) % 3 ] [ 0 ] if d in backs else dp [ ( i + 1 ) % 3 ] [ d ] for d in stops [ j + 1 : j + 7 ] ) / 6 NEW_LINE DEDENT DEDENT print ( ' { : . 6f } ' . format ( dp [ 0 ] [ 0 ] ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4431_A", "sol": 0, "python_code": "def printFirstRepeating ( arr , n ) :\n    Min = - 1\n    myset = dict ( )\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        if arr [ i ] in myset.keys ( ) :\n            Min = i\n        else :\n            myset [ arr [ i ] ] = 1\n    if ( Min != - 1 ) :\n        print ( \"The first repeating element is\" , arr [ Min ] )\n    else :\n        print ( \"There are no repeating elements\" )\narr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ]\nn = len ( arr )\nprintFirstRepeating ( arr , n )\n", "python_code_tokenized": "def printFirstRepeating ( arr , n ) : NEW_LINE INDENT Min = - 1 NEW_LINE myset = dict ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] in myset . keys ( ) : NEW_LINE INDENT Min = i NEW_LINE DEDENT else : NEW_LINE INDENT myset [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT if ( Min != - 1 ) : NEW_LINE INDENT print ( \" The \u2581 first \u2581 repeating \u2581 element \u2581 is \" , arr [ Min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" There \u2581 are \u2581 no \u2581 repeating \u2581 elements \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printFirstRepeating ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_3969_A", "sol": 0, "python_code": "def lds ( arr , n ) :\n    lds = [ 0 ] * n\n    max = 0\n    for i in range ( n ) :\n        lds [ i ] = 1\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ i ] < arr [ j ] and lds [ i ] < lds [ j ] + 1 ) :\n                lds [ i ] = lds [ j ] + 1\n    for i in range ( n ) :\n        if ( max < lds [ i ] ) :\n            max = lds [ i ]\n    return max\nif __name__ == \"__main__\" :\n    arr = [ 15 , 27 , 14 , 38 , 63 , 55 , 46 , 65 , 85 ]\n    n = len ( arr )\n    print ( \"Length of LDS is\" , lds ( arr , n ) )\n", "python_code_tokenized": "def lds ( arr , n ) : NEW_LINE INDENT lds = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lds [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < lds [ i ] ) : NEW_LINE INDENT max = lds [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 15 , 27 , 14 , 38 , 63 , 55 , 46 , 65 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length \u2581 of \u2581 LDS \u2581 is \" , lds ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1574_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) : a , b , c , m = map ( int , input ( ).split ( ' ' ) ) ; a , b , c = sorted ( [ a , b , c ] ) ; print ( \"YES\" if c - ( a + b + 1 ) <= m <= a + b + c - 3 else \"NO\" )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : a , b , c , m = map ( int , input ( ) . split ( ' \u2581 ' ) ) ; a , b , c = sorted ( [ a , b , c ] ) ; print ( \" YES \" if c - ( a + b + 1 ) <= m <= a + b + c - 3 else \" NO \" ) NEW_LINE"}
{"id": "geeksforgeeks_2930_A", "sol": 0, "python_code": "def countFreq ( a , n ) :\n    hm = { }\n    for i in range ( 0 , n ) :\n        hm [ a [ i ] ] = hm.get ( a [ i ] , 0 ) + 1\n    st = set ( )\n    for x in hm :\n        st.add ( ( x , hm [ x ] ) )\n    cumul = 0\n    for x in sorted ( st ) :\n        cumul += x [ 1 ]\n        print ( x [ 0 ] , cumul )\nif __name__ == \"__main__\" :\n    a = [ 1 , 3 , 2 , 4 , 2 , 1 ]\n    n = len ( a )\n    countFreq ( a , n )\n", "python_code_tokenized": "def countFreq ( a , n ) : NEW_LINE INDENT hm = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT st = set ( ) NEW_LINE for x in hm : NEW_LINE INDENT st . add ( ( x , hm [ x ] ) ) NEW_LINE DEDENT cumul = 0 NEW_LINE for x in sorted ( st ) : NEW_LINE INDENT cumul += x [ 1 ] NEW_LINE print ( x [ 0 ] , cumul ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 3 , 2 , 4 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE countFreq ( a , n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4227_A", "sol": 0, "python_code": "from math import log10\ndef generateNumbers ( m ) :\n    numbers = [ ]\n    for y in range ( 1 , 10 ) :\n        k_max = ( ( 10 ** ( m - 2 ) * ( 10 * y + 1 ) ) // ( 10 ** ( m - 1 ) + y ) )\n        for k in range ( 1 , k_max + 1 ) :\n            x = ( ( y * ( 10 ** ( m - 1 ) - k ) ) // ( 10 * k - 1 ) )\n            if ( ( y * ( 10 ** ( m - 1 ) - k ) ) % ( 10 * k - 1 ) == 0 ) :\n                numbers.append ( 10 * x + y )\n    for n in sorted ( numbers ) :\n        print ( n )\nm = 3\ngenerateNumbers ( m )\n", "python_code_tokenized": "from math import log10 NEW_LINE def generateNumbers ( m ) : NEW_LINE INDENT numbers = [ ] NEW_LINE for y in range ( 1 , 10 ) : NEW_LINE INDENT k_max = ( ( 10 ** ( m - 2 ) * ( 10 * y + 1 ) ) // ( 10 ** ( m - 1 ) + y ) ) NEW_LINE for k in range ( 1 , k_max + 1 ) : NEW_LINE INDENT x = ( ( y * ( 10 ** ( m - 1 ) - k ) ) // ( 10 * k - 1 ) ) NEW_LINE if ( ( y * ( 10 ** ( m - 1 ) - k ) ) % ( 10 * k - 1 ) == 0 ) : NEW_LINE INDENT numbers . append ( 10 * x + y ) NEW_LINE DEDENT DEDENT DEDENT for n in sorted ( numbers ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT m = 3 NEW_LINE generateNumbers ( m ) NEW_LINE"}
{"id": "codeforces_242_A", "sol": 0, "python_code": "x , y , a , b = [ int ( i ) for i in input ( ).split ( ) ]\nc = [ [ i , j ] for i in range ( a , x + 1 ) for j in range ( b , y + 1 ) if i > j ]\nprint ( len ( c ) ) ; [ print ( * i ) for i in c ]\n", "python_code_tokenized": "x , y , a , b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE c = [ [ i , j ] for i in range ( a , x + 1 ) for j in range ( b , y + 1 ) if i > j ] NEW_LINE print ( len ( c ) ) ; [ print ( * i ) for i in c ] NEW_LINE"}
{"id": "codejam_08_23", "sol": 0, "python_code": "import sys\nline = sys.stdin.readline ( )\nline = line.rstrip ( )\ncases = int ( line )\nfor case in xrange ( 0 , cases ) :\n    K = int ( sys.stdin.readline ( ).strip ( ) )\n    ds = map ( int , sys.stdin.readline ( ).rstrip ( ).split ( ) )\n    ds [ 0 : 1 ] = [ ]\n    indexes = range ( 0 , K )\n    cards = [ - 1 ] * K\n    I = 0\n    for X in xrange ( 0 , K ) :\n        I += X\n        I = I % ( len ( indexes ) )\n        ii = I % ( K - X )\n        i = indexes [ ii ]\n        indexes [ ii : ii + 1 ] = [ ]\n        cards [ i ] = X\n    sys.stdout.write ( \"Case #%d:\" % ( case + 1 ) )\n    for d in ds :\n        sys.stdout.write ( \" %d\" % ( cards [ d - 1 ] + 1 ) )\n    sys.stdout.write ( \"\\n\" )\n", "python_code_tokenized": "import sys NEW_LINE line = sys . stdin . readline ( ) NEW_LINE line = line . rstrip ( ) NEW_LINE cases = int ( line ) NEW_LINE for case in xrange ( 0 , cases ) : NEW_LINE INDENT K = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE ds = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) NEW_LINE ds [ 0 : 1 ] = [ ] NEW_LINE indexes = range ( 0 , K ) NEW_LINE cards = [ - 1 ] * K NEW_LINE I = 0 NEW_LINE for X in xrange ( 0 , K ) : NEW_LINE INDENT I += X NEW_LINE I = I % ( len ( indexes ) ) NEW_LINE ii = I % ( K - X ) NEW_LINE i = indexes [ ii ] NEW_LINE indexes [ ii : ii + 1 ] = [ ] NEW_LINE cards [ i ] = X NEW_LINE DEDENT sys . stdout . write ( \" Case \u2581 # % d : \" % ( case + 1 ) ) NEW_LINE for d in ds : NEW_LINE INDENT sys . stdout . write ( \" \u2581 % d \" % ( cards [ d - 1 ] + 1 ) ) NEW_LINE DEDENT sys . stdout . write ( \" \\n \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5220_A", "sol": 0, "python_code": "import sys\ndef getMinimumSum ( arr , n ) :\n    fMin = sys.maxsize ;\n    sMin = sys.maxsize ;\n    tMin = sys.maxsize ;\n    for i in range ( n ) :\n        if ( arr [ i ] < fMin ) :\n            tMin = sMin ;\n            sMin = fMin ;\n            fMin = arr [ i ] ;\n        elif ( arr [ i ] < sMin ) :\n            tMin = sMin ;\n            sMin = arr [ i ] ;\n        elif ( arr [ i ] < tMin ) :\n            tMin = arr [ i ] ;\n    return ( fMin + sMin + tMin ) ;\nif __name__ == '__main__' :\n    arr = [ 1 , 2 , 3 , 4 , 5 , - 1 , 5 , - 2 ] ;\n    n = len ( arr ) ;\n    print ( getMinimumSum ( arr , n ) ) ;\n", "python_code_tokenized": "import sys NEW_LINE def getMinimumSum ( arr , n ) : NEW_LINE INDENT fMin = sys . maxsize ; NEW_LINE sMin = sys . maxsize ; NEW_LINE tMin = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < fMin ) : NEW_LINE INDENT tMin = sMin ; NEW_LINE sMin = fMin ; NEW_LINE fMin = arr [ i ] ; NEW_LINE DEDENT elif ( arr [ i ] < sMin ) : NEW_LINE INDENT tMin = sMin ; NEW_LINE sMin = arr [ i ] ; NEW_LINE DEDENT elif ( arr [ i ] < tMin ) : NEW_LINE INDENT tMin = arr [ i ] ; NEW_LINE DEDENT DEDENT return ( fMin + sMin + tMin ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , - 1 , 5 , - 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( getMinimumSum ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2740_A", "sol": 0, "python_code": "def isPalindrome ( s ) :\n    s1 = \"\"\n    N = len ( s )\n    i = ( N - 1 )\n    while ( i >= 0 ) :\n        s1 += s [ i ]\n        i = i - 1\n    if ( s == s1 ) :\n        return True\n    return False\ndef createString ( N ) :\n    s2 = \"\"\n    s = str ( N )\n    letters = \"abcdefghij\"\n    sum = 0\n    substr = \"\"\n    for i in range ( 0 , len ( s ) ) :\n        digit = int ( s [ i ] )\n        substr += letters [ digit ]\n        sum += digit\n    while ( len ( s2 ) <= sum ) :\n        s2 += substr\n    s2 = s2 [ : sum ]\n    return isPalindrome ( s2 )\nN = 61 ;\nflag = createString ( N )\nif ( flag ) :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "def isPalindrome ( s ) : NEW_LINE INDENT s1 = \" \" NEW_LINE N = len ( s ) NEW_LINE i = ( N - 1 ) NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE i = i - 1 NEW_LINE DEDENT if ( s == s1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createString ( N ) : NEW_LINE INDENT s2 = \" \" NEW_LINE s = str ( N ) NEW_LINE letters = \" abcdefghij \" NEW_LINE sum = 0 NEW_LINE substr = \" \" NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT digit = int ( s [ i ] ) NEW_LINE substr += letters [ digit ] NEW_LINE sum += digit NEW_LINE DEDENT while ( len ( s2 ) <= sum ) : NEW_LINE INDENT s2 += substr NEW_LINE DEDENT s2 = s2 [ : sum ] NEW_LINE return isPalindrome ( s2 ) NEW_LINE DEDENT N = 61 ; NEW_LINE flag = createString ( N ) NEW_LINE if ( flag ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1255_A", "sol": 0, "python_code": "import math\ndef checkSquare ( s1 , s2 ) :\n    c = int ( s1 + s2 )\n    d = math.sqrt ( c )\n    if ( d * d == c ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\nif __name__ == \"__main__\" :\n    s1 = \"12\"\n    s2 = \"1\"\n    checkSquare ( s1 , s2 )\n", "python_code_tokenized": "import math NEW_LINE def checkSquare ( s1 , s2 ) : NEW_LINE INDENT c = int ( s1 + s2 ) NEW_LINE d = math . sqrt ( c ) NEW_LINE if ( d * d == c ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \"12\" NEW_LINE s2 = \"1\" NEW_LINE checkSquare ( s1 , s2 ) NEW_LINE DEDENT"}
{"id": "codeforces_682_B", "sol": 0, "python_code": "import os , sys , io , math\nfrom array import array\nfrom math import *\nI = lambda : [ * map ( int , sys.stdin.readline ( ).split ( ) ) ]\nIS = lambda : input ( )\nIN = lambda : int ( input ( ) )\nIF = lambda : float ( input ( ) )\nn = IN ( )\nl = I ( )\nf = 1\nl.sort ( )\nc = 0\nfor i in l :\n    if i > c : c += 1\nprint ( c + 1 )\n", "python_code_tokenized": "import os , sys , io , math NEW_LINE from array import array NEW_LINE from math import * NEW_LINE I = lambda : [ * map ( int , sys . stdin . readline ( ) . split ( ) ) ] NEW_LINE IS = lambda : input ( ) NEW_LINE IN = lambda : int ( input ( ) ) NEW_LINE IF = lambda : float ( input ( ) ) NEW_LINE n = IN ( ) NEW_LINE l = I ( ) NEW_LINE f = 1 NEW_LINE l . sort ( ) NEW_LINE c = 0 NEW_LINE for i in l : NEW_LINE INDENT if i > c : c += 1 NEW_LINE DEDENT print ( c + 1 ) NEW_LINE"}
{"id": "geeksforgeeks_3832_A", "sol": 0, "python_code": "def maxsum_SIS ( arr , n ) :\n    max_sum = 0\n    current_sum = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        if ( arr [ i - 1 ] < arr [ i ] ) :\n            current_sum = current_sum + arr [ i ]\n        else :\n            max_sum = max ( max_sum , current_sum )\n            current_sum = arr [ i ]\n    return max ( max_sum , current_sum )\ndef main ( ) :\n    arr = [ 1 , 2 , 2 , 4 ]\n    n = len ( arr )\n    print ( \"Maximum sum : \" , maxsum_SIS ( arr , n ) ) ,\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "def maxsum_SIS ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max ( max_sum , current_sum ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum \u2581 sum \u2581 : \u2581 \" , maxsum_SIS ( arr , n ) ) , NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_1_A", "sol": 0, "python_code": "from math import ceil\nm , n , a = map ( int , input ( ).split ( \" \" ) )\noutput = ceil ( m / a ) * ceil ( n / a )\nprint ( output )\n", "python_code_tokenized": "from math import ceil NEW_LINE m , n , a = map ( int , input ( ) . split ( \" \u2581 \" ) ) NEW_LINE output = ceil ( m / a ) * ceil ( n / a ) NEW_LINE print ( output ) NEW_LINE"}
{"id": "geeksforgeeks_2854_A", "sol": 0, "python_code": "M = 50\ndef constructDP ( dp , string ) :\n    l = len ( string )\n    isPalin = [ [ 0 for i in range ( l + 1 ) ] for j in range ( l + 1 ) ]\n    for i in range ( l - 1 , - 1 , - 1 ) :\n        isPalin [ i ] [ i ] , dp [ i ] [ i ] = 1 , 1\n        for j in range ( i + 1 , l ) :\n            isPalin [ i ] [ j ] = ( string [ i ] == string [ j ] and ( i + 1 > j - 1 or isPalin [ i + 1 ] [ j - 1 ] ) )\n            dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] + isPalin [ i ] [ j ] )\ndef countOfPalindromeInRange ( dp , l , r ) :\n    return dp [ l ] [ r ]\nif __name__ == \"__main__\" :\n    string = \"xyaabax\"\n    dp = [ [ 0 for i in range ( M ) ] for j in range ( M ) ]\n    constructDP ( dp , string )\n    l , r = 3 , 5\n    print ( countOfPalindromeInRange ( dp , l , r ) )\n", "python_code_tokenized": "M = 50 NEW_LINE def constructDP ( dp , string ) : NEW_LINE INDENT l = len ( string ) NEW_LINE isPalin = [ [ 0 for i in range ( l + 1 ) ] for j in range ( l + 1 ) ] NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT isPalin [ i ] [ i ] , dp [ i ] [ i ] = 1 , 1 NEW_LINE for j in range ( i + 1 , l ) : NEW_LINE INDENT isPalin [ i ] [ j ] = ( string [ i ] == string [ j ] and ( i + 1 > j - 1 or isPalin [ i + 1 ] [ j - 1 ] ) ) NEW_LINE dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] + isPalin [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def countOfPalindromeInRange ( dp , l , r ) : NEW_LINE INDENT return dp [ l ] [ r ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" xyaabax \" NEW_LINE dp = [ [ 0 for i in range ( M ) ] for j in range ( M ) ] NEW_LINE constructDP ( dp , string ) NEW_LINE l , r = 3 , 5 NEW_LINE print ( countOfPalindromeInRange ( dp , l , r ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1520_B", "sol": 0, "python_code": "from itertools import count\nfor _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    count = 0\n    start = 0\n    for i in range ( 1 , 10 ) :\n        start = i\n        while ( start <= n ) :\n            count += 1\n            start = start * 10 + i\n    print ( count )\n", "python_code_tokenized": "from itertools import count NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE start = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT start = i NEW_LINE while ( start <= n ) : NEW_LINE INDENT count += 1 NEW_LINE start = start * 10 + i NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5193_A", "sol": 0, "python_code": "def calcFunction ( n , r ) :\n    finalDenominator = 1\n    mx = max ( r , n - r )\n    for i in range ( mx + 1 , n + 1 ) :\n        denominator = pow ( i , i )\n        numerator = pow ( i - mx , i - mx )\n        finalDenominator = ( finalDenominator * denominator ) // numerator\n    return finalDenominator\nif __name__ == \"__main__\" :\n    n = 6\n    r = 2\n    print ( \"1/\" , end = \"\" )\n    print ( calcFunction ( n , r ) )\n", "python_code_tokenized": "def calcFunction ( n , r ) : NEW_LINE INDENT finalDenominator = 1 NEW_LINE mx = max ( r , n - r ) NEW_LINE for i in range ( mx + 1 , n + 1 ) : NEW_LINE INDENT denominator = pow ( i , i ) NEW_LINE numerator = pow ( i - mx , i - mx ) NEW_LINE finalDenominator = ( finalDenominator * denominator ) // numerator NEW_LINE DEDENT return finalDenominator NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE r = 2 NEW_LINE print ( \"1 / \" , end = \" \" ) NEW_LINE print ( calcFunction ( n , r ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1620_A", "sol": 0, "python_code": "def printMatrix ( n , m ) :\n    if ( n < 5 or m < 5 ) :\n        print ( - 1 , end = \" \" ) ;\n        return ;\n    s = \"aeiou\" ;\n    s = list ( s ) ;\n    for i in range ( n ) :\n        for j in range ( m ) :\n            print ( s [ j % 5 ] , end = \" \" ) ;\n        print ( )\n        c = s [ 0 ] ;\n        for i in range ( 4 ) :\n            s [ i ] = s [ i + 1 ] ;\n        s [ 4 ] = c ;\nif __name__ == \"__main__\" :\n    n = 5 ; m = 5 ;\n    printMatrix ( n , m ) ;\n", "python_code_tokenized": "def printMatrix ( n , m ) : NEW_LINE INDENT if ( n < 5 or m < 5 ) : NEW_LINE INDENT print ( - 1 , end = \" \u2581 \" ) ; NEW_LINE return ; NEW_LINE DEDENT s = \" aeiou \" ; NEW_LINE s = list ( s ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT print ( s [ j % 5 ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT print ( ) NEW_LINE c = s [ 0 ] ; NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT s [ i ] = s [ i + 1 ] ; NEW_LINE DEDENT s [ 4 ] = c ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; m = 5 ; NEW_LINE printMatrix ( n , m ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2074_A", "sol": 0, "python_code": "def isPrime ( n ) :\n    if n <= 1 :\n        return False\n    for i in range ( 2 , n ) :\n        if n % i == 0 :\n            return False\n    return True\ndef printPrime ( n ) :\n    for i in range ( 2 , n + 1 ) :\n        if isPrime ( i ) :\n            print ( i , end = \" \" )\nif __name__ == \"__main__\" :\n    n = 7\n    printPrime ( n )\n", "python_code_tokenized": "def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def printPrime ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if isPrime ( i ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 7 NEW_LINE printPrime ( n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2075_A", "sol": 0, "python_code": "def isPrime ( n ) :\n    if ( n <= 1 ) :\n        return False\n    if ( n <= 3 ) :\n        return True\n    if ( n % 2 == 0 or n % 3 == 0 ) :\n        return False\n    i = 5\n    while ( i * i <= n ) :\n        if ( n % i == 0 or n % ( i + 2 ) == 0 ) :\n            return False\n        i = i + 6\n    return True\ndef printPrime ( n ) :\n    for i in range ( 2 , n + 1 ) :\n        if isPrime ( i ) :\n            print ( i , end = \" \" )\nn = 7\nprintPrime ( n )\n", "python_code_tokenized": "def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def printPrime ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if isPrime ( i ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT n = 7 NEW_LINE printPrime ( n ) NEW_LINE"}
{"id": "aizu_p00045_A", "sol": 0, "python_code": "i = 0\nsumsell = 0\nsumn = 0\nwhile True :\n    try :\n        at , n = map ( int , input ( ).split ( \",\" ) )\n        sumsell += at * n\n        sumn += n\n        i += 1\n    except EOFError : break\nprint ( sumsell )\nprint ( ( int ) ( sumn / i + 0.5 ) )\n", "python_code_tokenized": "i = 0 NEW_LINE sumsell = 0 NEW_LINE sumn = 0 NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT at , n = map ( int , input ( ) . split ( \" , \" ) ) NEW_LINE sumsell += at * n NEW_LINE sumn += n NEW_LINE i += 1 NEW_LINE DEDENT except EOFError : break NEW_LINE DEDENT print ( sumsell ) NEW_LINE print ( ( int ) ( sumn / i + 0.5 ) ) NEW_LINE"}
{"id": "atcoder_ABC060_B", "sol": 0, "python_code": "a , b , c = map ( int , input ( ).split ( ) )\nisOK = False\nfor i in range ( 1 , 100000 ) :\n    if ( b * i + c ) % a == 0 :\n        isOK = True\n        break\nif isOK :\n    print ( 'YES' )\nelse :\n    print ( 'NO' )\n", "python_code_tokenized": "a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE isOK = False NEW_LINE for i in range ( 1 , 100000 ) : NEW_LINE INDENT if ( b * i + c ) % a == 0 : NEW_LINE INDENT isOK = True NEW_LINE break NEW_LINE DEDENT DEDENT if isOK : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1565_A", "sol": 0, "python_code": "MAX_VAL = 200000\ndef countIntervals ( arr , V , N ) :\n    minimum = float ( \"inf\" )\n    maximum = 0\n    freq = [ 0 ] * ( MAX_VAL )\n    for i in range ( 0 , N ) :\n        li = arr [ i ] [ 0 ]\n        freq [ li ] = freq [ li ] + 1\n        ri = arr [ i ] [ 1 ]\n        freq [ ri + 1 ] = freq [ ri + 1 ] - 1\n        if li < minimum :\n            minimum = li\n        if ri > maximum :\n            maximum = ri\n    for i in range ( minimum , maximum + 1 ) :\n        freq [ i ] = freq [ i ] + freq [ i - 1 ]\n    return freq [ V ]\nif __name__ == \"__main__\" :\n    arr = [ [ 1 , 10 ] , [ 5 , 10 ] , [ 15 , 25 ] , [ 7 , 12 ] , [ 20 , 25 ] ]\n    V = 7\n    N = len ( arr )\n    print ( countIntervals ( arr , V , N ) )\n", "python_code_tokenized": "MAX_VAL = 200000 NEW_LINE def countIntervals ( arr , V , N ) : NEW_LINE INDENT minimum = float ( \" inf \" ) NEW_LINE maximum = 0 NEW_LINE freq = [ 0 ] * ( MAX_VAL ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT li = arr [ i ] [ 0 ] NEW_LINE freq [ li ] = freq [ li ] + 1 NEW_LINE ri = arr [ i ] [ 1 ] NEW_LINE freq [ ri + 1 ] = freq [ ri + 1 ] - 1 NEW_LINE if li < minimum : NEW_LINE INDENT minimum = li NEW_LINE DEDENT if ri > maximum : NEW_LINE INDENT maximum = ri NEW_LINE DEDENT DEDENT for i in range ( minimum , maximum + 1 ) : NEW_LINE INDENT freq [ i ] = freq [ i ] + freq [ i - 1 ] NEW_LINE DEDENT return freq [ V ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 10 ] , [ 5 , 10 ] , [ 15 , 25 ] , [ 7 , 12 ] , [ 20 , 25 ] ] NEW_LINE V = 7 NEW_LINE N = len ( arr ) NEW_LINE print ( countIntervals ( arr , V , N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4023_A", "sol": 0, "python_code": "def sumOfTheSeries ( n ) :\n    return int ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 )\nn = 5\nprint ( \"Sum =\" , sumOfTheSeries ( n ) )\n", "python_code_tokenized": "def sumOfTheSeries ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum \u2581 = \" , sumOfTheSeries ( n ) ) NEW_LINE"}
{"id": "aizu_p00473_A", "sol": 0, "python_code": "dp = [ 0 ] + [ 1 << 20 ] * 10000\nn = int ( input ( ) )\nfor i in range ( 1 , n ) :\n    a = int ( input ( ) )\n    for j in range ( i // 2 + 1 ) :\n        if dp [ j ] > dp [ i - j ] + a : dp [ j ] = dp [ i - j ] + a\n        if dp [ i - j ] > dp [ j ] + a : dp [ i - j ] = dp [ j ] + a\nprint ( dp [ n // 2 ] )\n", "python_code_tokenized": "dp = [ 0 ] + [ 1 << 20 ] * 10000 NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE for j in range ( i // 2 + 1 ) : NEW_LINE INDENT if dp [ j ] > dp [ i - j ] + a : dp [ j ] = dp [ i - j ] + a NEW_LINE if dp [ i - j ] > dp [ j ] + a : dp [ i - j ] = dp [ j ] + a NEW_LINE DEDENT DEDENT print ( dp [ n // 2 ] ) NEW_LINE"}
{"id": "codeforces_80_B", "sol": 0, "python_code": "s = str ( input ( ) )\nl = s.split ( \":\" )\nhrs = int ( l [ 0 ] )\nmins = int ( l [ 1 ] )\nif hrs >= 12 :\n    hrs -= 12\nprint ( ( ( hrs * 30 ) + ( mins / 2 ) ) , mins * 6 )\n", "python_code_tokenized": "s = str ( input ( ) ) NEW_LINE l = s . split ( \" : \" ) NEW_LINE hrs = int ( l [ 0 ] ) NEW_LINE mins = int ( l [ 1 ] ) NEW_LINE if hrs >= 12 : NEW_LINE INDENT hrs -= 12 NEW_LINE DEDENT print ( ( ( hrs * 30 ) + ( mins / 2 ) ) , mins * 6 ) NEW_LINE"}
{"id": "codeforces_89_A", "sol": 0, "python_code": "import sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\nn , m , k = map ( int , input ( ).split ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nx = n // 2 + 1\nif not n % 2 or m < x :\n    ans = 0\nelse :\n    c = pow ( 10 , 9 ) + 1\n    for i in range ( 0 , n , 2 ) :\n        c = min ( c , a [ i ] )\n    u = m // x\n    ans = min ( u * k , c )\nprint ( ans )\n", "python_code_tokenized": "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = n // 2 + 1 NEW_LINE if not n % 2 or m < x : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT else : NEW_LINE INDENT c = pow ( 10 , 9 ) + 1 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT c = min ( c , a [ i ] ) NEW_LINE DEDENT u = m // x NEW_LINE ans = min ( u * k , c ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "aizu_p01839_A", "sol": 0, "python_code": "if __name__ == \"__main__\" :\n    n = int ( input ( ) )\n    data = [ ]\n    for _ in range ( n ) : data.append ( input ( ) )\n    p = [ ]\n    state = True\n    for i in data :\n        if len ( p ) == 0 and i == 'Un' : state = False\n        elif len ( p ) != 0 and i == 'Un' : p.pop ( )\n        if i == 'A' : p.append ( 1 )\n    if len ( p ) != 0 : state = False\n    if state : print ( \"YES\" )\n    else : print ( \"NO\" )\n", "python_code_tokenized": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE data = [ ] NEW_LINE for _ in range ( n ) : data . append ( input ( ) ) NEW_LINE p = [ ] NEW_LINE state = True NEW_LINE for i in data : NEW_LINE INDENT if len ( p ) == 0 and i == ' Un ' : state = False NEW_LINE elif len ( p ) != 0 and i == ' Un ' : p . pop ( ) NEW_LINE if i == ' A ' : p . append ( 1 ) NEW_LINE DEDENT if len ( p ) != 0 : state = False NEW_LINE if state : print ( \" YES \" ) NEW_LINE else : print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "codeforces_637_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nK = max ( map ( a.count , a ) )\ni = 0\nwhile True :\n    if a.count ( a [ i ] ) < K :\n        C = a.count ( a [ i ] )\n        n -= C\n        Val = a [ i ]\n        for k in range ( C ) :\n            a.remove ( Val )\n    else :\n        i += 1\n    if i == n :\n        break\nMinI = 1000001\nID = - 1\nA = list ( set ( a ) )\nfor i in range ( len ( A ) ) :\n    j = n - 1\n    while j >= 0 and a [ j ] != A [ i ] :\n        j -= 1\n    if j < MinI :\n        MinI = j\n        ID = A [ i ]\nprint ( ID )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE K = max ( map ( a . count , a ) ) NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT if a . count ( a [ i ] ) < K : NEW_LINE INDENT C = a . count ( a [ i ] ) NEW_LINE n -= C NEW_LINE Val = a [ i ] NEW_LINE for k in range ( C ) : NEW_LINE INDENT a . remove ( Val ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT MinI = 1000001 NEW_LINE ID = - 1 NEW_LINE A = list ( set ( a ) ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT j = n - 1 NEW_LINE while j >= 0 and a [ j ] != A [ i ] : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if j < MinI : NEW_LINE INDENT MinI = j NEW_LINE ID = A [ i ] NEW_LINE DEDENT DEDENT print ( ID ) NEW_LINE"}
{"id": "geeksforgeeks_3001_A", "sol": 0, "python_code": "def calculateSum ( n ) :\n    sum = 0\n    for row in range ( n ) :\n        sum = sum + ( 1 << row )\n    return sum\nn = 10\nprint ( \"Sum of all elements:\" , calculateSum ( n ) )\n", "python_code_tokenized": "def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for row in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << row ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( \" Sum \u2581 of \u2581 all \u2581 elements : \" , calculateSum ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3002_A", "sol": 0, "python_code": "def calculateSum ( n ) :\n    sum = 0\n    sum = 1 << n ;\n    return ( sum - 1 )\nn = 10\nprint ( \"Sum of all elements:\" , calculateSum ( n ) )\n", "python_code_tokenized": "def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = 1 << n ; NEW_LINE return ( sum - 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( \" Sum \u2581 of \u2581 all \u2581 elements : \" , calculateSum ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4648_A", "sol": 0, "python_code": "def findMinZero ( p ) :\n    first = 1\n    second = 1\n    number = 2\n    next = 1\n    while ( next ) :\n        next = ( first + second ) % p\n        first = second\n        second = next\n        number = number + 1\n    return number\nif __name__ == '__main__' :\n    p = 7\n    print ( \"Minimal zero is:\" , findMinZero ( p ) )\n", "python_code_tokenized": "def findMinZero ( p ) : NEW_LINE INDENT first = 1 NEW_LINE second = 1 NEW_LINE number = 2 NEW_LINE next = 1 NEW_LINE while ( next ) : NEW_LINE INDENT next = ( first + second ) % p NEW_LINE first = second NEW_LINE second = next NEW_LINE number = number + 1 NEW_LINE DEDENT return number NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = 7 NEW_LINE print ( \" Minimal \u2581 zero \u2581 is : \" , findMinZero ( p ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1620_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    s = input ( )\n    print ( \"NO\" if s.count ( \"N\" ) == 1 else \"YES\" )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE print ( \" NO \" if s . count ( \" N \" ) == 1 else \" YES \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1354_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    a , b , c , d = map ( int , input ( ).split ( ) )\n    if b >= a :\n        print ( b )\n        continue\n    if c <= d :\n        print ( - 1 )\n        continue\n    a -= b\n    dif = c - d\n    print ( b + ( a + dif - 1 ) // dif * c )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if b >= a : NEW_LINE INDENT print ( b ) NEW_LINE continue NEW_LINE DEDENT if c <= d : NEW_LINE INDENT print ( - 1 ) NEW_LINE continue NEW_LINE DEDENT a -= b NEW_LINE dif = c - d NEW_LINE print ( b + ( a + dif - 1 ) // dif * c ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3916_A", "sol": 0, "python_code": "class Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.right = None\n        self.left = None\ndef printRoute ( stack , root ) :\n    if root == None :\n        return\n    stack.append ( root.data )\n    if ( root.left == None and root.right == None ) :\n        print ( ' '.join ( [ str ( i ) for i in stack ] ) )\n    printRoute ( stack , root.left )\n    printRoute ( stack , root.right )\n    stack.pop ( )\nroot = Node ( 1 ) ;\nroot.left = Node ( 2 ) ;\nroot.right = Node ( 3 ) ;\nroot.left.left = Node ( 4 ) ;\nroot.left.right = Node ( 5 ) ;\nprintRoute ( [ ] , root )\n", "python_code_tokenized": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . right = None NEW_LINE self . left = None NEW_LINE DEDENT DEDENT def printRoute ( stack , root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT stack . append ( root . data ) NEW_LINE if ( root . left == None and root . right == None ) : NEW_LINE INDENT print ( ' \u2581 ' . join ( [ str ( i ) for i in stack ] ) ) NEW_LINE DEDENT printRoute ( stack , root . left ) NEW_LINE printRoute ( stack , root . right ) NEW_LINE stack . pop ( ) NEW_LINE DEDENT root = Node ( 1 ) ; NEW_LINE root . left = Node ( 2 ) ; NEW_LINE root . right = Node ( 3 ) ; NEW_LINE root . left . left = Node ( 4 ) ; NEW_LINE root . left . right = Node ( 5 ) ; NEW_LINE printRoute ( [ ] , root ) NEW_LINE"}
{"id": "geeksforgeeks_3915_A", "sol": 0, "python_code": "class Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.left = None\n        self.right = None\ndef printPaths ( root ) :\n    path = [ ]\n    printPathsRec ( root , path , 0 )\ndef printPathsRec ( root , path , pathLen ) :\n    if root is None :\n        return\n    if ( len ( path ) > pathLen ) :\n        path [ pathLen ] = root.data\n    else :\n        path.append ( root.data )\n    pathLen = pathLen + 1\n    if root.left is None and root.right is None :\n        printArray ( path , pathLen )\n    else :\n        printPathsRec ( root.left , path , pathLen )\n        printPathsRec ( root.right , path , pathLen )\ndef printArray ( ints , len ) :\n    for i in ints [ 0 : len ] :\n        print ( i , \"\" , end = \"\" )\n    print ( )\nroot = Node ( 10 )\nroot.left = Node ( 8 )\nroot.right = Node ( 2 )\nroot.left.left = Node ( 3 )\nroot.left.right = Node ( 5 )\nroot.right.left = Node ( 2 )\nprintPaths ( root )\n", "python_code_tokenized": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printPaths ( root ) : NEW_LINE INDENT path = [ ] NEW_LINE printPathsRec ( root , path , 0 ) NEW_LINE DEDENT def printPathsRec ( root , path , pathLen ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT if ( len ( path ) > pathLen ) : NEW_LINE INDENT path [ pathLen ] = root . data NEW_LINE DEDENT else : NEW_LINE INDENT path . append ( root . data ) NEW_LINE DEDENT pathLen = pathLen + 1 NEW_LINE if root . left is None and root . right is None : NEW_LINE INDENT printArray ( path , pathLen ) NEW_LINE DEDENT else : NEW_LINE INDENT printPathsRec ( root . left , path , pathLen ) NEW_LINE printPathsRec ( root . right , path , pathLen ) NEW_LINE DEDENT DEDENT def printArray ( ints , len ) : NEW_LINE INDENT for i in ints [ 0 : len ] : NEW_LINE INDENT print ( i , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT root = Node ( 10 ) NEW_LINE root . left = Node ( 8 ) NEW_LINE root . right = Node ( 2 ) NEW_LINE root . left . left = Node ( 3 ) NEW_LINE root . left . right = Node ( 5 ) NEW_LINE root . right . left = Node ( 2 ) NEW_LINE printPaths ( root ) NEW_LINE"}
{"id": "aizu_p01137_A", "sol": 0, "python_code": "import math\nwhile True :\n    E = int ( input ( ) )\n    if E == 0 : break\n    ans = 10 ** 10\n    z = 0\n    while z ** 3 <= E :\n        y = int ( math.sqrt ( E - z ** 3 ) )\n        x = E - z ** 3 - y ** 2\n        ans = min ( x + y + z , ans )\n        z += 1\n    print ( ans )\n", "python_code_tokenized": "import math NEW_LINE while True : NEW_LINE INDENT E = int ( input ( ) ) NEW_LINE if E == 0 : break NEW_LINE ans = 10 ** 10 NEW_LINE z = 0 NEW_LINE while z ** 3 <= E : NEW_LINE INDENT y = int ( math . sqrt ( E - z ** 3 ) ) NEW_LINE x = E - z ** 3 - y ** 2 NEW_LINE ans = min ( x + y + z , ans ) NEW_LINE z += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "codeforces_1360_B", "sol": 0, "python_code": "for r in [ * open ( 0 ) ] [ 2 : : 2 ] :\n    b = sorted ( map ( int , r.split ( ) ) )\n    print ( min ( y - x for x , y in zip ( b , b [ 1 : ] ) ) )\n", "python_code_tokenized": "for r in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT b = sorted ( map ( int , r . split ( ) ) ) NEW_LINE print ( min ( y - x for x , y in zip ( b , b [ 1 : ] ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2865_A", "sol": 0, "python_code": "def cost ( st ) :\n    l = len ( st )\n    res = 0\n    j = l - 1\n    i = 0\n    while ( i < j ) :\n        if ( st [ i ] != st [ j ] ) :\n            res += ( min ( ord ( st [ i ] ) , ord ( st [ j ] ) ) - ord ( 'a' ) + 1 )\n        i = i + 1\n        j = j - 1\n    return res\nst = \"abcdef\" ;\nprint ( cost ( st ) )\n", "python_code_tokenized": "def cost ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE res = 0 NEW_LINE j = l - 1 NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( st [ i ] != st [ j ] ) : NEW_LINE INDENT res += ( min ( ord ( st [ i ] ) , ord ( st [ j ] ) ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT st = \" abcdef \" ; NEW_LINE print ( cost ( st ) ) NEW_LINE"}
{"id": "atcoder_ARC085_A", "sol": 0, "python_code": "N , M = map ( int , input ( ).split ( ) )\none = 100 * ( N - M ) + 1900 * M\ncount = 2 ** M\nprint ( one * count )\n", "python_code_tokenized": "N , M = map ( int , input ( ) . split ( ) ) NEW_LINE one = 100 * ( N - M ) + 1900 * M NEW_LINE count = 2 ** M NEW_LINE print ( one * count ) NEW_LINE"}
{"id": "aizu_p00228_A", "sol": 0, "python_code": "NUM = ( 0b0111111 , 0b0000110 , 0b1011011 , 0b1001111 , 0b1100110 , 0b1101101 , 0b1111101 , 0b0100111 , 0b1111111 , 0b1101111 , )\nwhile 1 :\n    n = int ( input ( ) )\n    if n == - 1 : break\n    current = 0\n    for i in range ( n ) :\n        num = NUM [ int ( input ( ) ) ]\n        print ( format ( current ^ num , 'b' ).zfill ( 7 ) )\n        current = num\n", "python_code_tokenized": "NUM = ( 0b0111111 , 0b0000110 , 0b1011011 , 0b1001111 , 0b1100110 , 0b1101101 , 0b1111101 , 0b0100111 , 0b1111111 , 0b1101111 , ) NEW_LINE while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == - 1 : break NEW_LINE current = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = NUM [ int ( input ( ) ) ] NEW_LINE print ( format ( current ^ num , ' b ' ) . zfill ( 7 ) ) NEW_LINE current = num NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_766_B", "sol": 0, "python_code": "from math import ceil\nn = int ( input ( ) )\nx = list ( map ( int , input ( ).split ( ) ) )\nx.sort ( )\nflag = False\nfor i in range ( n - 2 ) :\n    a = x [ i ]\n    b = x [ i + 1 ]\n    c = x [ i + 2 ]\n    if ( a + b > c and b + c > a and a + c > b ) :\n        flag = True\n        break\nif ( flag ) :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "from math import ceil NEW_LINE n = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x . sort ( ) NEW_LINE flag = False NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT a = x [ i ] NEW_LINE b = x [ i + 1 ] NEW_LINE c = x [ i + 2 ] NEW_LINE if ( a + b > c and b + c > a and a + c > b ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4170_A", "sol": 0, "python_code": "def encode ( s , k ) :\n    newS = \"\"\n    for i in range ( len ( s ) ) :\n        val = ord ( s [ i ] )\n        dup = k\n        if val + k > 122 :\n            k -= ( 122 - val )\n            k = k % 26\n            newS += chr ( 96 + k )\n        else :\n            newS += chr ( val + k )\n        k = dup\n    print ( newS )\nstr = \"abc\"\nk = 28\nencode ( str , k )\n", "python_code_tokenized": "def encode ( s , k ) : NEW_LINE INDENT newS = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT val = ord ( s [ i ] ) NEW_LINE dup = k NEW_LINE if val + k > 122 : NEW_LINE INDENT k -= ( 122 - val ) NEW_LINE k = k % 26 NEW_LINE newS += chr ( 96 + k ) NEW_LINE DEDENT else : NEW_LINE INDENT newS += chr ( val + k ) NEW_LINE DEDENT k = dup NEW_LINE DEDENT print ( newS ) NEW_LINE DEDENT str = \" abc \" NEW_LINE k = 28 NEW_LINE encode ( str , k ) NEW_LINE"}
{"id": "atcoder_ABC109_B", "sol": 0, "python_code": "N = int ( input ( ) )\nW = [ ]\nfor i in range ( N ) :\n    W.append ( list ( input ( ) ) )\ncnt = 0\nfor i in range ( 1 , N ) :\n    if W [ i ] [ 0 ] != W [ i - 1 ] [ - 1 ] :\n        cnt = 1\nW.sort ( )\nfor i in range ( 1 , N ) :\n    if W [ i ] == W [ i - 1 ] :\n        cnt = 1\nif cnt == 1 :\n    print ( \"No\" )\nelse :\n    print ( \"Yes\" )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE W = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT W . append ( list ( input ( ) ) ) NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if W [ i ] [ 0 ] != W [ i - 1 ] [ - 1 ] : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT DEDENT W . sort ( ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if W [ i ] == W [ i - 1 ] : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT DEDENT if cnt == 1 : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC123_C", "sol": 0, "python_code": "N = int ( input ( ) )\nP = [ int ( input ( ) ) for _ in range ( 5 ) ]\np = min ( P )\ng = N // p + ( 1 if N % p > 0 else 0 )\nprint ( 5 + g - 1 )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE P = [ int ( input ( ) ) for _ in range ( 5 ) ] NEW_LINE p = min ( P ) NEW_LINE g = N // p + ( 1 if N % p > 0 else 0 ) NEW_LINE print ( 5 + g - 1 ) NEW_LINE"}
{"id": "codeforces_292_B", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nd = dict ( )\nmaxi = 0\nmaxv = 0\nfor _ in range ( m ) :\n    a , b = map ( int , input ( ).split ( ) )\n    if a - 1 in d :\n        d [ a - 1 ] += 1\n    else :\n        d [ a - 1 ] = 1\n    if b - 1 in d :\n        d [ b - 1 ] += 1\n    else :\n        d [ b - 1 ] = 1\n    if d [ a - 1 ] > maxv :\n        maxv = d [ a - 1 ]\n        maxi = a - 1\n    if d [ b - 1 ] > maxv :\n        maxv = d [ b - 1 ]\n        maxi = b - 1\nif m + 1 == n :\n    if maxv == m :\n        print ( 'star topology' )\n    elif maxv == 2 :\n        print ( 'bus topology' )\n    else :\n        print ( 'unknown topology' )\nelif m == n :\n    if maxv == 2 :\n        print ( 'ring topology' )\n    else :\n        print ( 'unknown topology' )\nelse :\n    print ( 'unknown topology' )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE d = dict ( ) NEW_LINE maxi = 0 NEW_LINE maxv = 0 NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a - 1 in d : NEW_LINE INDENT d [ a - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ a - 1 ] = 1 NEW_LINE DEDENT if b - 1 in d : NEW_LINE INDENT d [ b - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ b - 1 ] = 1 NEW_LINE DEDENT if d [ a - 1 ] > maxv : NEW_LINE INDENT maxv = d [ a - 1 ] NEW_LINE maxi = a - 1 NEW_LINE DEDENT if d [ b - 1 ] > maxv : NEW_LINE INDENT maxv = d [ b - 1 ] NEW_LINE maxi = b - 1 NEW_LINE DEDENT DEDENT if m + 1 == n : NEW_LINE INDENT if maxv == m : NEW_LINE INDENT print ( ' star \u2581 topology ' ) NEW_LINE DEDENT elif maxv == 2 : NEW_LINE INDENT print ( ' bus \u2581 topology ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' unknown \u2581 topology ' ) NEW_LINE DEDENT DEDENT elif m == n : NEW_LINE INDENT if maxv == 2 : NEW_LINE INDENT print ( ' ring \u2581 topology ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' unknown \u2581 topology ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' unknown \u2581 topology ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_818_A", "sol": 0, "python_code": "def XandYandZintercept ( A , B , C , D ) :\n    x = - D / A\n    y = - D / B\n    z = - D / C\n    return [ x , y , z ]\ndef equation_plane ( p , q , r ) :\n    x1 = p [ 0 ]\n    y1 = p [ 1 ]\n    z1 = p [ 2 ]\n    x2 = q [ 0 ]\n    y2 = q [ 1 ]\n    z2 = q [ 2 ]\n    x3 = r [ 0 ]\n    y3 = r [ 1 ]\n    z3 = r [ 2 ]\n    a1 = x2 - x1\n    b1 = y2 - y1\n    c1 = z2 - z1\n    a2 = x3 - x1\n    b2 = y3 - y1\n    c2 = z3 - z1\n    A = b1 * c2 - b2 * c1\n    B = a2 * c1 - a1 * c2\n    C = a1 * b2 - b1 * a2\n    D = ( - A * x1 - B * y1 - C * z1 )\n    print ( XandYandZintercept ( A , B , C , D ) )\nx1 = - 1\ny1 = 2\nz1 = 1\nx2 = 0\ny2 = - 3\nz2 = 2\nx3 = 1\ny3 = 1\nz3 = - 4\nequation_plane ( ( x1 , y1 , z1 ) , ( x2 , y2 , z2 ) , ( x3 , y3 , z3 ) )\n", "python_code_tokenized": "def XandYandZintercept ( A , B , C , D ) : NEW_LINE INDENT x = - D / A NEW_LINE y = - D / B NEW_LINE z = - D / C NEW_LINE return [ x , y , z ] NEW_LINE DEDENT def equation_plane ( p , q , r ) : NEW_LINE INDENT x1 = p [ 0 ] NEW_LINE y1 = p [ 1 ] NEW_LINE z1 = p [ 2 ] NEW_LINE x2 = q [ 0 ] NEW_LINE y2 = q [ 1 ] NEW_LINE z2 = q [ 2 ] NEW_LINE x3 = r [ 0 ] NEW_LINE y3 = r [ 1 ] NEW_LINE z3 = r [ 2 ] NEW_LINE a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE A = b1 * c2 - b2 * c1 NEW_LINE B = a2 * c1 - a1 * c2 NEW_LINE C = a1 * b2 - b1 * a2 NEW_LINE D = ( - A * x1 - B * y1 - C * z1 ) NEW_LINE print ( XandYandZintercept ( A , B , C , D ) ) NEW_LINE DEDENT x1 = - 1 NEW_LINE y1 = 2 NEW_LINE z1 = 1 NEW_LINE x2 = 0 NEW_LINE y2 = - 3 NEW_LINE z2 = 2 NEW_LINE x3 = 1 NEW_LINE y3 = 1 NEW_LINE z3 = - 4 NEW_LINE equation_plane ( ( x1 , y1 , z1 ) , ( x2 , y2 , z2 ) , ( x3 , y3 , z3 ) ) NEW_LINE"}
{"id": "atcoder_ABC131_D", "sol": 0, "python_code": "n = int ( input ( ) )\nli = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( n ) ]\nli.sort ( key = lambda x : x [ 1 ] )\ntime = 0\nfor i , j in li :\n    time += i\n    if time > j :\n        print ( 'No' )\n        exit ( )\nprint ( 'Yes' )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE li = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE li . sort ( key = lambda x : x [ 1 ] ) NEW_LINE time = 0 NEW_LINE for i , j in li : NEW_LINE INDENT time += i NEW_LINE if time > j : NEW_LINE INDENT print ( ' No ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ' Yes ' ) NEW_LINE"}
{"id": "codeforces_1512_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    ar = list ( map ( int , input ( ).split ( ) ) )\n    flg = True\n    for i in range ( 1 , n - 1 ) :\n        if ar [ i ] != ar [ i + 1 ] and ar [ i ] != ar [ i - 1 ] :\n            print ( i + 1 )\n            flg = False\n    if flg :\n        if ar [ 0 ] != ar [ 1 ] :\n            print ( 1 )\n        else :\n            print ( n )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ar = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE flg = True NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ar [ i ] != ar [ i + 1 ] and ar [ i ] != ar [ i - 1 ] : NEW_LINE INDENT print ( i + 1 ) NEW_LINE flg = False NEW_LINE DEDENT DEDENT if flg : NEW_LINE INDENT if ar [ 0 ] != ar [ 1 ] : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "codejam_08_31", "sol": 0, "python_code": "fin = open ( \"b.in\" , \"r\" )\nn = int ( fin.readline ( ) )\nfout = open ( \"b.out\" , \"w\" )\nfor i in xrange ( 1 , n + 1 ) :\n    p , k , l = map ( int , fin.readline ( ).split ( ) )\n    freqs = map ( int , fin.readline ( ).split ( ) )\n    if p * k < l :\n        print >> fout , \"Case #%d: Impossible\" % i\n    else :\n        freqs.sort ( lambda a , b : b - a )\n        total = 0\n        for j in xrange ( 1 , p + 1 ) :\n            total += sum ( freqs [ : k ] ) * j\n            freqs = freqs [ k : ]\n            if len ( freqs ) == 0 :\n                break\n        print >> fout , \"Case #%d: %d\" % ( i , total )\nfout.close ( )\n", "python_code_tokenized": "fin = open ( \" b . in \" , \" r \" ) NEW_LINE n = int ( fin . readline ( ) ) NEW_LINE fout = open ( \" b . out \" , \" w \" ) NEW_LINE for i in xrange ( 1 , n + 1 ) : NEW_LINE INDENT p , k , l = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE freqs = map ( int , fin . readline ( ) . split ( ) ) NEW_LINE if p * k < l : NEW_LINE INDENT print >> fout , \" Case \u2581 # % d : \u2581 Impossible \" % i NEW_LINE DEDENT else : NEW_LINE INDENT freqs . sort ( lambda a , b : b - a ) NEW_LINE total = 0 NEW_LINE for j in xrange ( 1 , p + 1 ) : NEW_LINE INDENT total += sum ( freqs [ : k ] ) * j NEW_LINE freqs = freqs [ k : ] NEW_LINE if len ( freqs ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print >> fout , \" Case \u2581 # % d : \u2581 % d \" % ( i , total ) NEW_LINE DEDENT DEDENT fout . close ( ) NEW_LINE"}
{"id": "aizu_p02496_A", "sol": 0, "python_code": "suits = { \"S\" : 0 , \"H\" : 1 , \"C\" : 2 , \"D\" : 3 }\ntramp_list = [ 0 for i in range ( 52 ) ]\nn = int ( input ( ) )\nfor j in range ( n ) :\n    card = input ( ).split ( )\n    card_number = suits [ card [ 0 ] ] * 13 + int ( card [ 1 ] ) - 1\n    tramp_list [ card_number ] = 1\nfor k in range ( 52 ) :\n    if tramp_list [ k ] == 0 :\n        suit_key = k // 13\n        number_key = k % 13\n        the_suit = 'undefined'\n        for suit_name , suit_number in suits.items ( ) :\n            if suit_number == suit_key :\n                the_suit = suit_name\n        print ( '{0} {1}'.format ( the_suit , number_key + 1 ) )\n", "python_code_tokenized": "suits = { \" S \" : 0 , \" H \" : 1 , \" C \" : 2 , \" D \" : 3 } NEW_LINE tramp_list = [ 0 for i in range ( 52 ) ] NEW_LINE n = int ( input ( ) ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT card = input ( ) . split ( ) NEW_LINE card_number = suits [ card [ 0 ] ] * 13 + int ( card [ 1 ] ) - 1 NEW_LINE tramp_list [ card_number ] = 1 NEW_LINE DEDENT for k in range ( 52 ) : NEW_LINE INDENT if tramp_list [ k ] == 0 : NEW_LINE INDENT suit_key = k // 13 NEW_LINE number_key = k % 13 NEW_LINE the_suit = ' undefined ' NEW_LINE for suit_name , suit_number in suits . items ( ) : NEW_LINE INDENT if suit_number == suit_key : NEW_LINE INDENT the_suit = suit_name NEW_LINE DEDENT DEDENT print ( ' { 0 } \u2581 { 1 } ' . format ( the_suit , number_key + 1 ) ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_47_B", "sol": 0, "python_code": "lst1 = [ 'A' , 'B' , 'C' ]\nlst2 = [ 0 , 0 , 0 ]\nin1 = input ( )\nin2 = input ( )\nin3 = input ( )\ns = \"\"\nif ( in1 [ 1 ] == '>' ) :\n    temp = in1 [ 0 ]\n    lst2 [ lst1.index ( ( temp ) ) ] = lst2 [ lst1.index ( ( temp ) ) ] + 1\nelif ( in1 [ 1 ] == '<' ) :\n    temp = in1 [ 2 ]\n    lst2 [ lst1.index ( ( temp ) ) ] = lst2 [ lst1.index ( ( temp ) ) ] + 1\nif ( in2 [ 1 ] == '>' ) :\n    temp = in2 [ 0 ]\n    lst2 [ lst1.index ( ( temp ) ) ] = lst2 [ lst1.index ( ( temp ) ) ] + 1\nelif ( in2 [ 1 ] == '<' ) :\n    temp = in2 [ 2 ]\n    lst2 [ lst1.index ( ( temp ) ) ] = lst2 [ lst1.index ( ( temp ) ) ] + 1\nif ( in3 [ 1 ] == '>' ) :\n    temp = in3 [ 0 ]\n    lst2 [ lst1.index ( ( temp ) ) ] = lst2 [ lst1.index ( ( temp ) ) ] + 1\nelif ( in3 [ 1 ] == '<' ) :\n    temp = in3 [ 2 ]\n    lst2 [ lst1.index ( ( temp ) ) ] = lst2 [ lst1.index ( ( temp ) ) ] + 1\nif ( lst2 [ 0 ] == lst2 [ 1 ] == lst2 [ 2 ] == 1 ) :\n    s = \"Impossible\"\nelse :\n    for i in range ( 0 , 3 ) :\n        t = lst2.index ( min ( lst2 ) )\n        s = s + lst1 [ t ]\n        lst2 [ t ] = 100\nprint ( s )\n", "python_code_tokenized": "lst1 = [ ' A ' , ' B ' , ' C ' ] NEW_LINE lst2 = [ 0 , 0 , 0 ] NEW_LINE in1 = input ( ) NEW_LINE in2 = input ( ) NEW_LINE in3 = input ( ) NEW_LINE s = \" \" NEW_LINE if ( in1 [ 1 ] == ' > ' ) : NEW_LINE INDENT temp = in1 [ 0 ] NEW_LINE lst2 [ lst1 . index ( ( temp ) ) ] = lst2 [ lst1 . index ( ( temp ) ) ] + 1 NEW_LINE DEDENT elif ( in1 [ 1 ] == ' < ' ) : NEW_LINE INDENT temp = in1 [ 2 ] NEW_LINE lst2 [ lst1 . index ( ( temp ) ) ] = lst2 [ lst1 . index ( ( temp ) ) ] + 1 NEW_LINE DEDENT if ( in2 [ 1 ] == ' > ' ) : NEW_LINE INDENT temp = in2 [ 0 ] NEW_LINE lst2 [ lst1 . index ( ( temp ) ) ] = lst2 [ lst1 . index ( ( temp ) ) ] + 1 NEW_LINE DEDENT elif ( in2 [ 1 ] == ' < ' ) : NEW_LINE INDENT temp = in2 [ 2 ] NEW_LINE lst2 [ lst1 . index ( ( temp ) ) ] = lst2 [ lst1 . index ( ( temp ) ) ] + 1 NEW_LINE DEDENT if ( in3 [ 1 ] == ' > ' ) : NEW_LINE INDENT temp = in3 [ 0 ] NEW_LINE lst2 [ lst1 . index ( ( temp ) ) ] = lst2 [ lst1 . index ( ( temp ) ) ] + 1 NEW_LINE DEDENT elif ( in3 [ 1 ] == ' < ' ) : NEW_LINE INDENT temp = in3 [ 2 ] NEW_LINE lst2 [ lst1 . index ( ( temp ) ) ] = lst2 [ lst1 . index ( ( temp ) ) ] + 1 NEW_LINE DEDENT if ( lst2 [ 0 ] == lst2 [ 1 ] == lst2 [ 2 ] == 1 ) : NEW_LINE INDENT s = \" Impossible \" NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , 3 ) : NEW_LINE INDENT t = lst2 . index ( min ( lst2 ) ) NEW_LINE s = s + lst1 [ t ] NEW_LINE lst2 [ t ] = 100 NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE"}
{"id": "geeksforgeeks_525_A", "sol": 0, "python_code": "def solve ( a , b ) :\n    if ( a > 0 and b > 0 ) :\n        print ( \"Positive\" )\n    elif ( a <= 0 and b >= 0 ) :\n        print ( \"Zero\" )\n    else :\n        n = abs ( a - b ) + 1\n        if ( n % 2 == 0 ) :\n            print ( \"Positive\" )\n        else :\n            print ( \"Negative\" )\nif __name__ == '__main__' :\n    a = - 10\n    b = - 2\n    solve ( a , b )\n", "python_code_tokenized": "def solve ( a , b ) : NEW_LINE INDENT if ( a > 0 and b > 0 ) : NEW_LINE INDENT print ( \" Positive \" ) NEW_LINE DEDENT elif ( a <= 0 and b >= 0 ) : NEW_LINE INDENT print ( \" Zero \" ) NEW_LINE DEDENT else : NEW_LINE INDENT n = abs ( a - b ) + 1 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT print ( \" Positive \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Negative \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = - 10 NEW_LINE b = - 2 NEW_LINE solve ( a , b ) NEW_LINE DEDENT"}
{"id": "aizu_p02191_A", "sol": 0, "python_code": "def num ( ) :\n    return int ( input ( ) )\ndef nums ( ) :\n    return list ( map ( int , input ( ).split ( ) ) )\ndef get_near_index ( sorted_l , val , last ) :\n    left = 0\n    right = len ( sorted_l ) - 1\n    while left <= right :\n        mid = ( right + left ) // 2\n        if sorted_l [ mid ] == val :\n            return mid if last else mid\n        elif sorted_l [ mid ] > val :\n            right = mid - 1\n        else :\n            left = mid + 1\n    return right if last else left\nN , Q = nums ( )\nA = nums ( )\nA.sort ( )\nL , R = [ ] , [ ]\nfor i in range ( Q ) :\n    li , ri = nums ( )\n    L.append ( li )\n    R.append ( ri )\nfor l , r in zip ( L , R ) :\n    l_idx = get_near_index ( A , l , 0 )\n    r_idx = get_near_index ( A , r , 1 )\n    print ( r_idx - l_idx + 1 )\n", "python_code_tokenized": "def num ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def nums ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def get_near_index ( sorted_l , val , last ) : NEW_LINE INDENT left = 0 NEW_LINE right = len ( sorted_l ) - 1 NEW_LINE while left <= right : NEW_LINE INDENT mid = ( right + left ) // 2 NEW_LINE if sorted_l [ mid ] == val : NEW_LINE INDENT return mid if last else mid NEW_LINE DEDENT elif sorted_l [ mid ] > val : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT DEDENT return right if last else left NEW_LINE DEDENT N , Q = nums ( ) NEW_LINE A = nums ( ) NEW_LINE A . sort ( ) NEW_LINE L , R = [ ] , [ ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT li , ri = nums ( ) NEW_LINE L . append ( li ) NEW_LINE R . append ( ri ) NEW_LINE DEDENT for l , r in zip ( L , R ) : NEW_LINE INDENT l_idx = get_near_index ( A , l , 0 ) NEW_LINE r_idx = get_near_index ( A , r , 1 ) NEW_LINE print ( r_idx - l_idx + 1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2043_A", "sol": 0, "python_code": "PI = 3.14159265\ndef length_rope ( r ) :\n    return ( ( 2 * PI * r ) + 6 * r )\nr = 7\nprint ( length_rope ( r ) )\n", "python_code_tokenized": "PI = 3.14159265 NEW_LINE def length_rope ( r ) : NEW_LINE INDENT return ( ( 2 * PI * r ) + 6 * r ) NEW_LINE DEDENT r = 7 NEW_LINE print ( length_rope ( r ) ) NEW_LINE"}
{"id": "aizu_p00875_A", "sol": 0, "python_code": "def substitute ( text , a , b ) :\n    pos = 0\n    newText = text\n    L1 = len ( a )\n    L2 = len ( b )\n    while True :\n        idx = newText.find ( a , pos )\n        if idx < 0 :\n            return newText\n        newText = newText [ : idx ] + b + newText [ idx + L1 : ]\n        pos = idx + L2\n    return newText\ndef transform ( orig , goal , count ) :\n    global subs\n    global minCount\n    if len ( orig ) > len ( goal ) :\n        return\n    if orig == goal :\n        minCount = min ( minCount , count )\n        return\n    for key in subs :\n        newStr = substitute ( orig , key , subs [ key ] )\n        if newStr != orig :\n            transform ( newStr , goal , count + 1 )\nif __name__ == '__main__' :\n    while True :\n        N = int ( input ( ) )\n        if N == 0 :\n            break\n        subs = { }\n        for _ in range ( N ) :\n            a , b = input ( ).strip ( ).split ( )\n            subs [ a ] = b\n        orig = input ( ).strip ( )\n        goal = input ( ).strip ( )\n        minCount = 999999999\n        transform ( orig , goal , 0 )\n        if minCount == 999999999 :\n            print ( - 1 )\n        else :\n            print ( minCount )\n", "python_code_tokenized": "def substitute ( text , a , b ) : NEW_LINE INDENT pos = 0 NEW_LINE newText = text NEW_LINE L1 = len ( a ) NEW_LINE L2 = len ( b ) NEW_LINE while True : NEW_LINE INDENT idx = newText . find ( a , pos ) NEW_LINE if idx < 0 : NEW_LINE INDENT return newText NEW_LINE DEDENT newText = newText [ : idx ] + b + newText [ idx + L1 : ] NEW_LINE pos = idx + L2 NEW_LINE DEDENT return newText NEW_LINE DEDENT def transform ( orig , goal , count ) : NEW_LINE INDENT global subs NEW_LINE global minCount NEW_LINE if len ( orig ) > len ( goal ) : NEW_LINE INDENT return NEW_LINE DEDENT if orig == goal : NEW_LINE INDENT minCount = min ( minCount , count ) NEW_LINE return NEW_LINE DEDENT for key in subs : NEW_LINE INDENT newStr = substitute ( orig , key , subs [ key ] ) NEW_LINE if newStr != orig : NEW_LINE INDENT transform ( newStr , goal , count + 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT subs = { } NEW_LINE for _ in range ( N ) : NEW_LINE INDENT a , b = input ( ) . strip ( ) . split ( ) NEW_LINE subs [ a ] = b NEW_LINE DEDENT orig = input ( ) . strip ( ) NEW_LINE goal = input ( ) . strip ( ) NEW_LINE minCount = 999999999 NEW_LINE transform ( orig , goal , 0 ) NEW_LINE if minCount == 999999999 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( minCount ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_1607_A", "sol": 0, "python_code": "R = 3\nC = 4\ndef gcd ( a , b ) :\n    if ( b == 0 ) :\n        return a\n    return gcd ( b , a % b )\ndef replacematrix ( mat , n , m ) :\n    rgcd = [ 0 ] * R\n    cgcd = [ 0 ] * C\n    for i in range ( n ) :\n        for j in range ( m ) :\n            rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i ] [ j ] )\n            cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i ] [ j ] )\n    for i in range ( n ) :\n        for j in range ( m ) :\n            mat [ i ] [ j ] = max ( rgcd [ i ] , cgcd [ j ] )\nif __name__ == \"__main__\" :\n    m = [ [ 1 , 2 , 3 , 3 ] , [ 4 , 5 , 6 , 6 ] , [ 7 , 8 , 9 , 9 ] ]\n    replacematrix ( m , R , C )\n    for i in range ( R ) :\n        for j in range ( C ) :\n            print ( m [ i ] [ j ] , end = \" \" )\n        print ( )\n", "python_code_tokenized": "R = 3 NEW_LINE C = 4 NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def replacematrix ( mat , n , m ) : NEW_LINE INDENT rgcd = [ 0 ] * R NEW_LINE cgcd = [ 0 ] * C NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i ] [ j ] ) NEW_LINE cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i ] [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT mat [ i ] [ j ] = max ( rgcd [ i ] , cgcd [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = [ [ 1 , 2 , 3 , 3 ] , [ 4 , 5 , 6 , 6 ] , [ 7 , 8 , 9 , 9 ] ] NEW_LINE replacematrix ( m , R , C ) NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT print ( m [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1102_A", "sol": 0, "python_code": "n = int ( input ( ) )\nif ( n % 4 == 0 or n % 4 == 3 ) :\n    print ( 0 )\nelse :\n    print ( 1 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE if ( n % 4 == 0 or n % 4 == 3 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT"}
{"id": "codeforces_155_B", "sol": 0, "python_code": "from collections import defaultdict , deque\nfrom functools import lru_cache\nfrom heapq import heappush , heappop\nfrom typing import Counter\nfrom bisect import bisect_right , bisect_left\nimport math\nhpop = heappop\nhpush = heappush\ndef solution ( ) :\n    n = int ( input ( ) )\n    arr = [ ]\n    for _ in range ( n ) :\n        val , move = map ( int , input ( ).split ( ) )\n        arr.append ( ( move , val ) )\n    arr.sort ( )\n    moves = 1\n    res = 0\n    while moves and arr :\n        moves -= 1\n        move , score = arr.pop ( )\n        moves += move\n        res += score\n    print ( res )\ndef main ( ) :\n    t = 1\n    for _ in range ( t ) :\n        solution ( )\nmain ( )\n", "python_code_tokenized": "from collections import defaultdict , deque NEW_LINE from functools import lru_cache NEW_LINE from heapq import heappush , heappop NEW_LINE from typing import Counter NEW_LINE from bisect import bisect_right , bisect_left NEW_LINE import math NEW_LINE hpop = heappop NEW_LINE hpush = heappush NEW_LINE def solution ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT val , move = map ( int , input ( ) . split ( ) ) NEW_LINE arr . append ( ( move , val ) ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE moves = 1 NEW_LINE res = 0 NEW_LINE while moves and arr : NEW_LINE INDENT moves -= 1 NEW_LINE move , score = arr . pop ( ) NEW_LINE moves += move NEW_LINE res += score NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = 1 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT solution ( ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_2699_A", "sol": 0, "python_code": "import math as mt\ndef isPalindrome ( str1 , i , j ) :\n    while ( i < j ) :\n        if ( str1 [ i ] != str1 [ j ] ) :\n            return False\n        i += 1\n        j -= 1\n    return True\ndef countPrimePalindrome ( str1 , Len ) :\n    prime = [ True for i in range ( Len + 1 ) ]\n    prime [ 0 ] , prime [ 1 ] = False , False\n    for p in range ( 2 , mt.ceil ( mt.sqrt ( Len + 1 ) ) ) :\n        if ( prime [ p ] ) :\n            for i in range ( 2 * p , Len + 1 , p ) :\n                prime [ i ] = False\n    count = 0\n    for j in range ( 2 , Len + 1 ) :\n        if ( prime [ j ] ) :\n            for i in range ( Len + 1 - j ) :\n                if ( isPalindrome ( str1 , i , i + j - 1 ) ) :\n                    count += 1\n    return count\ns = \"geeksforgeeks\"\nLen = len ( s )\nprint ( countPrimePalindrome ( s , Len ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def isPalindrome ( str1 , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT if ( str1 [ i ] != str1 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def countPrimePalindrome ( str1 , Len ) : NEW_LINE INDENT prime = [ True for i in range ( Len + 1 ) ] NEW_LINE prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( Len + 1 ) ) ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , Len + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for j in range ( 2 , Len + 1 ) : NEW_LINE INDENT if ( prime [ j ] ) : NEW_LINE INDENT for i in range ( Len + 1 - j ) : NEW_LINE INDENT if ( isPalindrome ( str1 , i , i + j - 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE Len = len ( s ) NEW_LINE print ( countPrimePalindrome ( s , Len ) ) NEW_LINE"}
{"id": "geeksforgeeks_2537_A", "sol": 0, "python_code": "def productAscii ( str ) :\n    prod = 1\n    for i in range ( 0 , len ( str ) ) :\n        prod = prod * ord ( str [ i ] )\n    return prod\nif __name__ == '__main__' :\n    str = \"GfG\"\n    print ( productAscii ( str ) )\n", "python_code_tokenized": "def productAscii ( str ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT prod = prod * ord ( str [ i ] ) NEW_LINE DEDENT return prod NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" GfG \" NEW_LINE print ( productAscii ( str ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3822_A", "sol": 0, "python_code": "def count ( arr , n , x ) :\n    if ( x == 1 ) :\n        ans = pow ( 2 , n ) - 1\n        return ans ;\n    count = 0\n    for i in range ( n ) :\n        if ( arr [ i ] % x == 0 ) :\n            count += 1\n    ans = pow ( 2 , count ) - 1\n    return ans\nif __name__ == \"__main__\" :\n    arr = [ 2 , 4 , 3 , 5 ]\n    n = len ( arr )\n    x = 1\n    print ( count ( arr , n , x ) )\n", "python_code_tokenized": "def count ( arr , n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT ans = pow ( 2 , n ) - 1 NEW_LINE return ans ; NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = pow ( 2 , count ) - 1 NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( count ( arr , n , x ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1633_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    n = int ( input ( ) )\n    if n % 7 == 0 :\n        print ( n )\n    else :\n        ans = - 1\n        for j in range ( 10 ) :\n            if ( n - n % 10 + j ) % 7 == 0 :\n                ans = n - n % 10 + j\n        print ( ans )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 7 == 0 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT if ( n - n % 10 + j ) % 7 == 0 : NEW_LINE INDENT ans = n - n % 10 + j NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4002_A", "sol": 0, "python_code": "MAX = 50002 ;\nprimes = [ ]\ndef sieve ( ) :\n    isPrime = [ True ] * ( MAX )\n    p = 2\n    while p * p < MAX :\n        if ( isPrime [ p ] == True ) :\n            for i in range ( p * 2 , MAX , p ) :\n                isPrime [ i ] = False\n        p += 1\n    for p in range ( 2 , MAX ) :\n        if ( isPrime [ p ] ) :\n            primes.append ( p )\ndef power ( x , y ) :\n    count = 0\n    z = y\n    while ( x >= z ) :\n        count += ( x // z )\n        z *= y\n    return count\ndef modMult ( a , b , mod ) :\n    res = 0\n    a = a % mod\n    while ( b > 0 ) :\n        if ( b % 2 == 1 ) :\n            res = ( res + a ) % mod\n        a = ( a * 2 ) % mod\n        b //= 2\n    return res % mod\ndef countWays ( n , m ) :\n    ans = 1\n    for i in range ( 1 , len ( primes ) ) :\n        powers = power ( n , primes [ i ] )\n        if ( powers == 0 ) :\n            break\n        ans = modMult ( ans , powers + 1 , m ) % m\n    if ( ( ( ans - 1 ) % m ) < 0 ) :\n        return ( ans - 1 + m ) % m\n    else :\n        return ( ans - 1 ) % m\nif __name__ == \"__main__\" :\n    sieve ( )\n    n = 4\n    m = 7\n    print ( countWays ( n , m ) )\n", "python_code_tokenized": "MAX = 50002 ; NEW_LINE primes = [ ] NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime = [ True ] * ( MAX ) NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def power ( x , y ) : NEW_LINE INDENT count = 0 NEW_LINE z = y NEW_LINE while ( x >= z ) : NEW_LINE INDENT count += ( x // z ) NEW_LINE z *= y NEW_LINE DEDENT return count NEW_LINE DEDENT def modMult ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b //= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def countWays ( n , m ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , len ( primes ) ) : NEW_LINE INDENT powers = power ( n , primes [ i ] ) NEW_LINE if ( powers == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = modMult ( ans , powers + 1 , m ) % m NEW_LINE DEDENT if ( ( ( ans - 1 ) % m ) < 0 ) : NEW_LINE INDENT return ( ans - 1 + m ) % m NEW_LINE DEDENT else : NEW_LINE INDENT return ( ans - 1 ) % m NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sieve ( ) NEW_LINE n = 4 NEW_LINE m = 7 NEW_LINE print ( countWays ( n , m ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1455_A", "sol": 0, "python_code": "p = int ( input ( ) )\nwhile p > 0 :\n    n = input ( )\n    x = len ( n )\n    print ( x )\n    p = p - 1\n", "python_code_tokenized": "p = int ( input ( ) ) NEW_LINE while p > 0 : NEW_LINE INDENT n = input ( ) NEW_LINE x = len ( n ) NEW_LINE print ( x ) NEW_LINE p = p - 1 NEW_LINE DEDENT"}
{"id": "atcoder_ABC062_D", "sol": 0, "python_code": "from heapq import heapify , heappushpop\nN , * A = map ( int , open ( 0 ).read ( ).split ( ) )\nL , C , R = A [ : N ] , A [ N : 2 * N ] , A [ 2 * N : ]\nF = [ sum ( L ) ]\nheapify ( L )\nfor c in C :\n    F.append ( F [ - 1 ] + c - heappushpop ( L , c ) )\nR = [ - r for r in R ]\nB = [ sum ( R ) ]\nheapify ( R )\nfor c in reversed ( C ) :\n    B.append ( B [ - 1 ] - c - heappushpop ( R , - c ) )\nprint ( max ( f + b for f , b in zip ( F , reversed ( B ) ) ) )\n", "python_code_tokenized": "from heapq import heapify , heappushpop NEW_LINE N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE L , C , R = A [ : N ] , A [ N : 2 * N ] , A [ 2 * N : ] NEW_LINE F = [ sum ( L ) ] NEW_LINE heapify ( L ) NEW_LINE for c in C : NEW_LINE INDENT F . append ( F [ - 1 ] + c - heappushpop ( L , c ) ) NEW_LINE DEDENT R = [ - r for r in R ] NEW_LINE B = [ sum ( R ) ] NEW_LINE heapify ( R ) NEW_LINE for c in reversed ( C ) : NEW_LINE INDENT B . append ( B [ - 1 ] - c - heappushpop ( R , - c ) ) NEW_LINE DEDENT print ( max ( f + b for f , b in zip ( F , reversed ( B ) ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_2584_A", "sol": 0, "python_code": "def isValidNesbitt ( a , b , c ) :\n    A = a / ( b + c ) ;\n    B = b / ( a + c ) ;\n    C = c / ( a + b ) ;\n    inequality = A + B + C ;\n    return ( inequality >= 1.5 ) ;\na = 1.0 ;\nb = 2.0 ;\nc = 3.0 ;\nif ( isValidNesbitt ( a , b , c ) ) :\n    print ( \"Nesbitt's inequality satisfied.\" , \" for real numbers \" , a , \", \" , b , \", \" , c ) ;\nelse :\n    print ( \"Not satisfied\" ) ;\n", "python_code_tokenized": "def isValidNesbitt ( a , b , c ) : NEW_LINE INDENT A = a / ( b + c ) ; NEW_LINE B = b / ( a + c ) ; NEW_LINE C = c / ( a + b ) ; NEW_LINE inequality = A + B + C ; NEW_LINE return ( inequality >= 1.5 ) ; NEW_LINE DEDENT a = 1.0 ; NEW_LINE b = 2.0 ; NEW_LINE c = 3.0 ; NEW_LINE if ( isValidNesbitt ( a , b , c ) ) : NEW_LINE INDENT print ( \" Nesbitt ' s \u2581 inequality \u2581 satisfied . \" , \" \u2581 for \u2581 real \u2581 numbers \u2581 \" , a , \" , \u2581 \" , b , \" , \u2581 \" , c ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 satisfied \" ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1255_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    a , b = map ( int , input ( ).split ( ) )\n    k = abs ( a - b )\n    p = k // 5\n    k -= p * 5\n    q = k // 2\n    k -= q * 2\n    s = k // 1\n    k -= s\n    print ( p + q + s )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE k = abs ( a - b ) NEW_LINE p = k // 5 NEW_LINE k -= p * 5 NEW_LINE q = k // 2 NEW_LINE k -= q * 2 NEW_LINE s = k // 1 NEW_LINE k -= s NEW_LINE print ( p + q + s ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1628_A", "sol": 0, "python_code": "def mySort ( arr ) :\n    n = len ( arr ) ;\n    arr1 = arr [ : n // 2 ]\n    arr2 = arr [ n // 2 : ]\n    arr1.sort ( )\n    arr2.sort ( )\n    arr = arr1 + arr2\n    low = n // 2 ;\n    high = n - 1 ;\n    while ( low < high ) :\n        temp = arr [ low ] ;\n        arr [ low ] = arr [ high ] ;\n        arr [ high ] = temp ;\n        low += 1 ;\n        high -= 1 ;\n    return arr ;\nif __name__ == '__main__' :\n    arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , 7 ] ;\n    arr = mySort ( arr ) ;\n    print ( \"Modified Array : \" )\n    print ( arr )\n", "python_code_tokenized": "def mySort ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE arr1 = arr [ : n // 2 ] NEW_LINE arr2 = arr [ n // 2 : ] NEW_LINE arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE arr = arr1 + arr2 NEW_LINE low = n // 2 ; NEW_LINE high = n - 1 ; NEW_LINE while ( low < high ) : NEW_LINE INDENT temp = arr [ low ] ; NEW_LINE arr [ low ] = arr [ high ] ; NEW_LINE arr [ high ] = temp ; NEW_LINE low += 1 ; NEW_LINE high -= 1 ; NEW_LINE DEDENT return arr ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , 7 ] ; NEW_LINE arr = mySort ( arr ) ; NEW_LINE print ( \" Modified \u2581 Array \u2581 : \u2581 \" ) NEW_LINE print ( arr ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_393_A", "sol": 0, "python_code": "def calcSum ( arr , n , k ) :\n    sum = 0\n    for i in range ( k ) :\n        sum += arr [ i ]\n    print ( sum , end = \" \" )\n    for i in range ( k , n ) :\n        sum = ( sum - arr [ i - k ] ) + arr [ i ]\n        print ( sum , end = \" \" )\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 3 , 4 , 5 , 6 ]\n    n = len ( arr )\n    k = 3\n    calcSum ( arr , n , k )\n", "python_code_tokenized": "def calcSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( sum , end = \" \u2581 \" ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = ( sum - arr [ i - k ] ) + arr [ i ] NEW_LINE print ( sum , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE calcSum ( arr , n , k ) NEW_LINE DEDENT"}
{"id": "codeforces_106_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = [ [ * map ( int , input ( ).split ( ) ) , i ] for i in range ( n ) ]\na = * filter ( lambda x : all ( any ( v >= u for u , v in zip ( c [ : 3 ] , x [ : 3 ] ) ) for c in a ) , a ) ,\nprint ( min ( a , key = lambda x : x [ 3 ] ) [ 4 ] + 1 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = [ [ * map ( int , input ( ) . split ( ) ) , i ] for i in range ( n ) ] NEW_LINE a = * filter ( lambda x : all ( any ( v >= u for u , v in zip ( c [ : 3 ] , x [ : 3 ] ) ) for c in a ) , a ) , NEW_LINE print ( min ( a , key = lambda x : x [ 3 ] ) [ 4 ] + 1 ) NEW_LINE"}
{"id": "atcoder_ABC144_D", "sol": 0, "python_code": "import math\na , b , x = map ( int , input ( ).split ( ) )\nif a * a * b >= x * 2 :\n    c = x * 2 / ( b * a )\n    print ( math.degrees ( math.atan ( b / c ) ) )\nelse :\n    d = 2 * ( b - x / a / a )\n    print ( math.degrees ( math.atan ( d / a ) ) )\n", "python_code_tokenized": "import math NEW_LINE a , b , x = map ( int , input ( ) . split ( ) ) NEW_LINE if a * a * b >= x * 2 : NEW_LINE INDENT c = x * 2 / ( b * a ) NEW_LINE print ( math . degrees ( math . atan ( b / c ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT d = 2 * ( b - x / a / a ) NEW_LINE print ( math . degrees ( math . atan ( d / a ) ) ) NEW_LINE DEDENT"}
{"id": "codeforces_501_B", "sol": 0, "python_code": "import sys\nimport threading\nsys.setrecursionlimit ( 2147483647 )\ninput = sys.stdin.readline\ndef print ( * args , end = '\\n' , sep = ' ' ) -> None :\n    sys.stdout.write ( sep.join ( map ( str , args ) ) + end )\ndef dfs ( node ) :\n    global graph , seen\n    if node in graph.keys ( ) :\n        child = graph [ node ]\n        if child not in seen :\n            seen.add ( child )\n            return dfs ( child )\n    return node\ndef Solve ( ) :\n    global graph , seen\n    graph = { }\n    for q in range ( int ( input ( ) ) ) :\n        old , new = input ( ).split ( ) ; graph [ old ] = new\n    seen = set ( )\n    ans = [ ]\n    for i in graph.keys ( ) :\n        if i not in seen :\n            ans.append ( [ i , dfs ( i ) ] )\n    print ( len ( ans ) )\n    for i in ans :\n        print ( * i )\nif __name__ == \"__main__\" :\n    threading.stack_size ( 10 ** 8 )\n    threading.Thread ( target = Solve ).start ( )\n", "python_code_tokenized": "import sys NEW_LINE import threading NEW_LINE sys . setrecursionlimit ( 2147483647 ) NEW_LINE input = sys . stdin . readline NEW_LINE def print ( * args , end = ' \\n ' , sep = ' \u2581 ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def dfs ( node ) : NEW_LINE INDENT global graph , seen NEW_LINE if node in graph . keys ( ) : NEW_LINE INDENT child = graph [ node ] NEW_LINE if child not in seen : NEW_LINE INDENT seen . add ( child ) NEW_LINE return dfs ( child ) NEW_LINE DEDENT DEDENT return node NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT global graph , seen NEW_LINE graph = { } NEW_LINE for q in range ( int ( input ( ) ) ) : NEW_LINE INDENT old , new = input ( ) . split ( ) ; graph [ old ] = new NEW_LINE DEDENT seen = set ( ) NEW_LINE ans = [ ] NEW_LINE for i in graph . keys ( ) : NEW_LINE INDENT if i not in seen : NEW_LINE INDENT ans . append ( [ i , dfs ( i ) ] ) NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE for i in ans : NEW_LINE INDENT print ( * i ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT threading . stack_size ( 10 ** 8 ) NEW_LINE threading . Thread ( target = Solve ) . start ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_694_A", "sol": 0, "python_code": "def pushZerosToEnd ( arr , n ) :\n    count = 0\n    for i in range ( n ) :\n        if arr [ i ] != 0 :\n            arr [ count ] = arr [ i ]\n            count += 1\n    while count < n :\n        arr [ count ] = 0\n        count += 1\narr = [ 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ]\nn = len ( arr )\npushZerosToEnd ( arr , n )\nprint ( \"Array after pushing all zeros to end of array:\" )\nprint ( arr )\n", "python_code_tokenized": "def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE pushZerosToEnd ( arr , n ) NEW_LINE print ( \" Array \u2581 after \u2581 pushing \u2581 all \u2581 zeros \u2581 to \u2581 end \u2581 of \u2581 array : \" ) NEW_LINE print ( arr ) NEW_LINE"}
{"id": "aizu_p02492_A", "sol": 0, "python_code": "while True :\n    tmp = input ( ).split ( )\n    if tmp [ 1 ] == '?' :\n        break\n    if tmp [ 1 ] == '+' :\n        print ( int ( tmp [ 0 ] ) + int ( tmp [ 2 ] ) )\n    if tmp [ 1 ] == '-' :\n        print ( int ( tmp [ 0 ] ) - int ( tmp [ 2 ] ) )\n    if tmp [ 1 ] == '*' :\n        print ( int ( tmp [ 0 ] ) * int ( tmp [ 2 ] ) )\n    if tmp [ 1 ] == '/' :\n        print ( int ( tmp [ 0 ] ) // int ( tmp [ 2 ] ) )\n", "python_code_tokenized": "while True : NEW_LINE INDENT tmp = input ( ) . split ( ) NEW_LINE if tmp [ 1 ] == ' ? ' : NEW_LINE INDENT break NEW_LINE DEDENT if tmp [ 1 ] == ' + ' : NEW_LINE INDENT print ( int ( tmp [ 0 ] ) + int ( tmp [ 2 ] ) ) NEW_LINE DEDENT if tmp [ 1 ] == ' - ' : NEW_LINE INDENT print ( int ( tmp [ 0 ] ) - int ( tmp [ 2 ] ) ) NEW_LINE DEDENT if tmp [ 1 ] == ' * ' : NEW_LINE INDENT print ( int ( tmp [ 0 ] ) * int ( tmp [ 2 ] ) ) NEW_LINE DEDENT if tmp [ 1 ] == ' / ' : NEW_LINE INDENT print ( int ( tmp [ 0 ] ) // int ( tmp [ 2 ] ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3672_A", "sol": 0, "python_code": "def PointInKSquares ( n , a , k ) :\n    a.sort ( )\n    return a [ n - k ]\nif __name__ == \"__main__\" :\n    k = 2\n    a = [ 1 , 2 , 3 , 4 ]\n    n = len ( a )\n    x = PointInKSquares ( n , a , k )\n    print ( \"(\" , x , \",\" , x , \")\" )\n", "python_code_tokenized": "def PointInKSquares ( n , a , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return a [ n - k ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 2 NEW_LINE a = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE x = PointInKSquares ( n , a , k ) NEW_LINE print ( \" ( \" , x , \" , \" , x , \" ) \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1730_A", "sol": 0, "python_code": "T = int ( input ( ) )\nwhile T :\n    n , c = input ( ).split ( )\n    A = list ( map ( int , input ( ).split ( ) ) )\n    dicti = { }\n    for each in A :\n        if each in dicti :\n            dicti [ each ] += 1\n        else :\n            dicti [ each ] = 1\n    tot_ans = 0\n    for each in dicti :\n        if dicti [ each ] >= int ( c ) :\n            tot_ans += int ( c )\n        else :\n            tot_ans += dicti [ each ]\n    print ( tot_ans )\n    T -= 1\n", "python_code_tokenized": "T = int ( input ( ) ) NEW_LINE while T : NEW_LINE INDENT n , c = input ( ) . split ( ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dicti = { } NEW_LINE for each in A : NEW_LINE INDENT if each in dicti : NEW_LINE INDENT dicti [ each ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dicti [ each ] = 1 NEW_LINE DEDENT DEDENT tot_ans = 0 NEW_LINE for each in dicti : NEW_LINE INDENT if dicti [ each ] >= int ( c ) : NEW_LINE INDENT tot_ans += int ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT tot_ans += dicti [ each ] NEW_LINE DEDENT DEDENT print ( tot_ans ) NEW_LINE T -= 1 NEW_LINE DEDENT"}
{"id": "aizu_p02271_A", "sol": 0, "python_code": "n = int ( input ( ) )\nN = list ( map ( int , input ( ).split ( ) ) )\nm = int ( input ( ) )\nM = list ( map ( int , input ( ).split ( ) ) )\nsum_lis = [ ]\nfor i in range ( 2 ** n ) :\n    lis = [ ]\n    for j in range ( n ) :\n        if ( i >> j ) & 1 == 1 :\n            lis.append ( N [ j ] )\n    sum_lis.append ( sum ( lis ) )\nsum_set = set ( sum_lis )\nfor i in range ( m ) :\n    if M [ i ] in sum_set :\n        M [ i ] = 'yes'\n    else :\n        M [ i ] = 'no'\n[ print ( _ ) for _ in M ]\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE N = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE M = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum_lis = [ ] NEW_LINE for i in range ( 2 ** n ) : NEW_LINE INDENT lis = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i >> j ) & 1 == 1 : NEW_LINE INDENT lis . append ( N [ j ] ) NEW_LINE DEDENT DEDENT sum_lis . append ( sum ( lis ) ) NEW_LINE DEDENT sum_set = set ( sum_lis ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT if M [ i ] in sum_set : NEW_LINE INDENT M [ i ] = ' yes ' NEW_LINE DEDENT else : NEW_LINE INDENT M [ i ] = ' no ' NEW_LINE DEDENT DEDENT [ print ( _ ) for _ in M ] NEW_LINE"}
{"id": "geeksforgeeks_2500_A", "sol": 0, "python_code": "import math as mt\ndef getPosition ( a , n , m ) :\n    for i in range ( n ) :\n        a [ i ] = ( a [ i ] // m + ( a [ i ] % m != 0 ) )\n    ans , maxx = - 1 , - 1\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        if ( maxx < a [ i ] ) :\n            maxx = a [ i ]\n            ans = i\n    return ans + 1\na = [ 2 , 5 , 4 ]\nn = len ( a )\nm = 2\nprint ( getPosition ( a , n , m ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def getPosition ( a , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = ( a [ i ] // m + ( a [ i ] % m != 0 ) ) NEW_LINE DEDENT ans , maxx = - 1 , - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxx < a [ i ] ) : NEW_LINE INDENT maxx = a [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT a = [ 2 , 5 , 4 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( getPosition ( a , n , m ) ) NEW_LINE"}
{"id": "codeforces_1333_B", "sol": 0, "python_code": "for t in range ( int ( input ( ) ) ) :\n    input ( ) ; seen = { } ; r = 'yes' ; i = lambda : map ( int , input ( ).split ( ) )\n    for a , b in zip ( i ( ) , i ( ) ) :\n        if a != b and not seen.get ( b > a ) : r = 'no' ; break\n        if a and not seen.get ( a > 0 ) :\n            if seen.get ( a < 0 ) : break\n            seen [ a > 0 ] = 1\n    print ( r )\n", "python_code_tokenized": "for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT input ( ) ; seen = { } ; r = ' yes ' ; i = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE for a , b in zip ( i ( ) , i ( ) ) : NEW_LINE INDENT if a != b and not seen . get ( b > a ) : r = ' no ' ; break NEW_LINE if a and not seen . get ( a > 0 ) : NEW_LINE INDENT if seen . get ( a < 0 ) : break NEW_LINE seen [ a > 0 ] = 1 NEW_LINE DEDENT DEDENT print ( r ) NEW_LINE DEDENT"}
{"id": "aizu_p02261_A", "sol": 0, "python_code": "def bubble_sort ( num_list ) :\n    list_b = num_list [ : ]\n    for i in range ( len ( list_b ) - 1 ) :\n        for j in range ( len ( list_b ) - 1 , i , - 1 ) :\n            if list_b [ j ] [ 1 ] < list_b [ j - 1 ] [ 1 ] :\n                list_b [ j ] , list_b [ j - 1 ] = list_b [ j - 1 ] , list_b [ j ]\n    return list_b\ndef selection_sort ( num_list ) :\n    list_s = num_list [ : ]\n    for i in range ( len ( list_s ) ) :\n        minj = i\n        for j in range ( i , len ( list_s ) ) :\n            if list_s [ minj ] [ 1 ] > list_s [ j ] [ 1 ] :\n                minj = j\n        list_s [ i ] , list_s [ minj ] = list_s [ minj ] , list_s [ i ]\n    return list_s\ndef isStable ( list_x , list_y ) :\n    leng = int ( len ( list_x ) )\n    for i in range ( leng - 1 ) :\n        for j in range ( i + 1 , leng ) :\n            for x in range ( leng - 1 ) :\n                for y in range ( x + 1 , leng ) :\n                    if list_x [ i ] [ 1 ] == list_x [ j ] [ 1 ] and list_x [ i ] == list_y [ y ] and list_x [ j ] == list_y [ x ] :\n                        return \"Not stable\"\n    return \"Stable\"\nqnt = int ( input ( ) )\nnum_list = input ( ).split ( )\nbs = bubble_sort ( num_list )\nss = selection_sort ( num_list )\nprint ( \" \".join ( bs ) )\nprint ( isStable ( num_list , bs ) )\nprint ( \" \".join ( ss ) )\nprint ( isStable ( num_list , ss ) )\n", "python_code_tokenized": "def bubble_sort ( num_list ) : NEW_LINE INDENT list_b = num_list [ : ] NEW_LINE for i in range ( len ( list_b ) - 1 ) : NEW_LINE INDENT for j in range ( len ( list_b ) - 1 , i , - 1 ) : NEW_LINE INDENT if list_b [ j ] [ 1 ] < list_b [ j - 1 ] [ 1 ] : NEW_LINE INDENT list_b [ j ] , list_b [ j - 1 ] = list_b [ j - 1 ] , list_b [ j ] NEW_LINE DEDENT DEDENT DEDENT return list_b NEW_LINE DEDENT def selection_sort ( num_list ) : NEW_LINE INDENT list_s = num_list [ : ] NEW_LINE for i in range ( len ( list_s ) ) : NEW_LINE INDENT minj = i NEW_LINE for j in range ( i , len ( list_s ) ) : NEW_LINE INDENT if list_s [ minj ] [ 1 ] > list_s [ j ] [ 1 ] : NEW_LINE INDENT minj = j NEW_LINE DEDENT DEDENT list_s [ i ] , list_s [ minj ] = list_s [ minj ] , list_s [ i ] NEW_LINE DEDENT return list_s NEW_LINE DEDENT def isStable ( list_x , list_y ) : NEW_LINE INDENT leng = int ( len ( list_x ) ) NEW_LINE for i in range ( leng - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , leng ) : NEW_LINE INDENT for x in range ( leng - 1 ) : NEW_LINE INDENT for y in range ( x + 1 , leng ) : NEW_LINE INDENT if list_x [ i ] [ 1 ] == list_x [ j ] [ 1 ] and list_x [ i ] == list_y [ y ] and list_x [ j ] == list_y [ x ] : NEW_LINE INDENT return \" Not \u2581 stable \" NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return \" Stable \" NEW_LINE DEDENT qnt = int ( input ( ) ) NEW_LINE num_list = input ( ) . split ( ) NEW_LINE bs = bubble_sort ( num_list ) NEW_LINE ss = selection_sort ( num_list ) NEW_LINE print ( \" \u2581 \" . join ( bs ) ) NEW_LINE print ( isStable ( num_list , bs ) ) NEW_LINE print ( \" \u2581 \" . join ( ss ) ) NEW_LINE print ( isStable ( num_list , ss ) ) NEW_LINE"}
{"id": "geeksforgeeks_2935_A", "sol": 0, "python_code": "from math import gcd\ndef findNumbers ( a , b ) :\n    __gcd = gcd ( a , b ) ;\n    print ( ( a // __gcd ) , ( b // __gcd ) ) ;\nif __name__ == \"__main__\" :\n    a = 12 ; b = 16 ;\n    findNumbers ( a , b ) ;\n", "python_code_tokenized": "from math import gcd NEW_LINE def findNumbers ( a , b ) : NEW_LINE INDENT __gcd = gcd ( a , b ) ; NEW_LINE print ( ( a // __gcd ) , ( b // __gcd ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 12 ; b = 16 ; NEW_LINE findNumbers ( a , b ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2595_A", "sol": 0, "python_code": "def relativeComplement ( arr1 , arr2 , n , m ) :\n    i = 0\n    j = 0\n    while ( i < n and j < m ) :\n        if ( arr1 [ i ] < arr2 [ j ] ) :\n            print ( arr1 [ i ] , \"\" , end = \"\" )\n            i += 1\n        elif ( arr1 [ i ] > arr2 [ j ] ) :\n            j += 1\n        elif ( arr1 [ i ] == arr2 [ j ] ) :\n            i += 1\n            j += 1\n    while ( i < n ) :\n        print ( arr1 [ i ] , \"\" , end = \"\" )\narr1 = [ 3 , 6 , 10 , 12 , 15 ]\narr2 = [ 1 , 3 , 5 , 10 , 16 ]\nn = len ( arr1 )\nm = len ( arr2 )\nrelativeComplement ( arr1 , arr2 , n , m )\n", "python_code_tokenized": "def relativeComplement ( arr1 , arr2 , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , \" \u2581 \" , end = \" \" ) NEW_LINE i += 1 NEW_LINE DEDENT elif ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT print ( arr1 [ i ] , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT DEDENT arr1 = [ 3 , 6 , 10 , 12 , 15 ] NEW_LINE arr2 = [ 1 , 3 , 5 , 10 , 16 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE relativeComplement ( arr1 , arr2 , n , m ) NEW_LINE"}
{"id": "geeksforgeeks_2493_A", "sol": 0, "python_code": "def judgeSquareSum ( n ) :\n    i = 2 ;\n    while ( i * i <= n ) :\n        count = 0 ;\n        if ( n % i == 0 ) :\n            while ( n % i == 0 ) :\n                count += 1 ;\n                n = int ( n / i ) ;\n            if ( i % 4 == 3 and count % 2 != 0 ) :\n                return False ;\n        i += 1 ;\n    return n % 4 != 3 ;\nn = 17 ;\nif ( judgeSquareSum ( n ) ) :\n    print ( \"Yes\" ) ;\nelse :\n    print ( \"No\" ) ;\n", "python_code_tokenized": "def judgeSquareSum ( n ) : NEW_LINE INDENT i = 2 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n % i == 0 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n = int ( n / i ) ; NEW_LINE DEDENT if ( i % 4 == 3 and count % 2 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return n % 4 != 3 ; NEW_LINE DEDENT n = 17 ; NEW_LINE if ( judgeSquareSum ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2890_A", "sol": 0, "python_code": "def findNthEvenDigitNumber ( n ) :\n    count = 0 ;\n    i = 0 ;\n    while ( True ) :\n        curr = i ;\n        isCurrEvenDigit = True ;\n        while ( curr != 0 ) :\n            if ( curr % 10 == 1 or curr % 10 == 3 or curr % 10 == 5 or curr % 10 == 7 or curr % 10 == 9 ) :\n                isCurrEvenDigit = False ;\n            curr = curr // 10 ;\n        if ( isCurrEvenDigit == True ) :\n            count += 1 ;\n        if ( count == n ) :\n            return i ;\n        i += 1 ;\nprint ( findNthEvenDigitNumber ( 2 ) ) ;\nprint ( findNthEvenDigitNumber ( 10 ) ) ;\n", "python_code_tokenized": "def findNthEvenDigitNumber ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT curr = i ; NEW_LINE isCurrEvenDigit = True ; NEW_LINE while ( curr != 0 ) : NEW_LINE INDENT if ( curr % 10 == 1 or curr % 10 == 3 or curr % 10 == 5 or curr % 10 == 7 or curr % 10 == 9 ) : NEW_LINE INDENT isCurrEvenDigit = False ; NEW_LINE DEDENT curr = curr // 10 ; NEW_LINE DEDENT if ( isCurrEvenDigit == True ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT print ( findNthEvenDigitNumber ( 2 ) ) ; NEW_LINE print ( findNthEvenDigitNumber ( 10 ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_4225_A", "sol": 0, "python_code": "def maxSum ( arr , n ) :\n    sum = 0\n    pivot = findPivot ( arr , n )\n    diff = n - 1 - pivot\n    for i in range ( n ) :\n        sum = sum + ( ( i + diff ) % n ) * arr [ i ] ;\n    return sum\ndef findPivot ( arr , n ) :\n    for i in range ( n ) :\n        if ( arr [ i ] > arr [ ( i + 1 ) % n ] ) :\n            return i ;\nif __name__ == \"__main__\" :\n    arr = [ 8 , 3 , 1 , 2 ]\n    n = len ( arr )\n    max = maxSum ( arr , n )\n    print ( max )\n", "python_code_tokenized": "def maxSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE pivot = findPivot ( arr , n ) NEW_LINE diff = n - 1 - pivot NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( ( i + diff ) % n ) * arr [ i ] ; NEW_LINE DEDENT return sum NEW_LINE DEDENT def findPivot ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ ( i + 1 ) % n ] ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 3 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE max = maxSum ( arr , n ) NEW_LINE print ( max ) NEW_LINE DEDENT"}
{"id": "atcoder_ARC092_A", "sol": 0, "python_code": "import sys , queue , math , copy , itertools , bisect , collections , heapq\nsys.setrecursionlimit ( 10 ** 7 )\nINF = 10 ** 3\nMOD = 10 ** 9 + 7\nLI = lambda : [ int ( x ) for x in sys.stdin.readline ( ).split ( ) ]\nNI = lambda : int ( sys.stdin.readline ( ) )\nN = NI ( )\nred = [ LI ( ) for _ in range ( N ) ]\nblue = [ LI ( ) for _ in range ( N ) ]\nred.sort ( key = lambda x : x [ 1 ] , reverse = True )\nblue.sort ( )\nans = 0\nfor bx , by in blue :\n    for i in range ( N ) :\n        if bx > red [ i ] [ 0 ] and by > red [ i ] [ 1 ] :\n            ans += 1\n            red [ i ] [ 0 ] = INF\n            break\nprint ( ans )\n", "python_code_tokenized": "import sys , queue , math , copy , itertools , bisect , collections , heapq NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 3 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE LI = lambda : [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE NI = lambda : int ( sys . stdin . readline ( ) ) NEW_LINE N = NI ( ) NEW_LINE red = [ LI ( ) for _ in range ( N ) ] NEW_LINE blue = [ LI ( ) for _ in range ( N ) ] NEW_LINE red . sort ( key = lambda x : x [ 1 ] , reverse = True ) NEW_LINE blue . sort ( ) NEW_LINE ans = 0 NEW_LINE for bx , by in blue : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if bx > red [ i ] [ 0 ] and by > red [ i ] [ 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE red [ i ] [ 0 ] = INF NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_2627_A", "sol": 0, "python_code": "def nthTerm ( n ) :\n    return ( n * n ) + ( n * n * n )\nn = 4\nprint ( nthTerm ( n ) )\n", "python_code_tokenized": "def nthTerm ( n ) : NEW_LINE INDENT return ( n * n ) + ( n * n * n ) NEW_LINE DEDENT n = 4 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE"}
{"id": "codeforces_160_A", "sol": 0, "python_code": "input ( ) ; l = sorted ( map ( int , input ( ).split ( ) ) ) ; s = count = 0\nwhile s <= sum ( l ) : s += l.pop ( ) ; count += 1\nprint ( count )\n", "python_code_tokenized": "input ( ) ; l = sorted ( map ( int , input ( ) . split ( ) ) ) ; s = count = 0 NEW_LINE while s <= sum ( l ) : s += l . pop ( ) ; count += 1 NEW_LINE print ( count ) NEW_LINE"}
{"id": "geeksforgeeks_748_A", "sol": 0, "python_code": "def minDiff ( arr , n , k ) :\n    result = + 2147483647\n    arr.sort ( )\n    for i in range ( n - k + 1 ) :\n        result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) )\n    return result\narr = [ 10 , 100 , 300 , 200 , 1000 , 20 , 30 ]\nn = len ( arr )\nk = 3\nprint ( minDiff ( arr , n , k ) )\n", "python_code_tokenized": "def minDiff ( arr , n , k ) : NEW_LINE INDENT result = + 2147483647 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 10 , 100 , 300 , 200 , 1000 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( minDiff ( arr , n , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_2086_A", "sol": 0, "python_code": "MAX = 10\ndef getMaxEven ( string , length ) :\n    string = list ( string )\n    freq = [ 0 ] * MAX\n    minEvenDigit = MAX ;\n    minDigit = MAX ;\n    for i in range ( length ) :\n        digit = ord ( string [ i ] ) - ord ( '0' ) ;\n        freq [ digit ] += 1 ;\n        if ( digit % 2 == 0 ) :\n            minEvenDigit = min ( digit , minEvenDigit ) ;\n        minDigit = min ( digit , minDigit ) ;\n    if ( minEvenDigit == MAX ) :\n        return \"-1\" ;\n    freq [ minEvenDigit ] -= 1 ;\n    freq [ minDigit ] -= 1 ;\n    i = 0 ;\n    for j in range ( MAX - 1 , - 1 , - 1 ) :\n        for k in range ( freq [ j ] ) :\n            string [ i ] = chr ( j + ord ( '0' ) ) ;\n            i += 1\n        if ( j == minEvenDigit ) :\n            string [ i ] = chr ( minDigit + ord ( '0' ) ) ;\n            i += 1\n    return \"\".join ( string ) ;\nif __name__ == \"__main__\" :\n    string = \"1023422\" ;\n    length = len ( string ) ;\n    print ( getMaxEven ( string , length ) ) ;\n", "python_code_tokenized": "MAX = 10 NEW_LINE def getMaxEven ( string , length ) : NEW_LINE INDENT string = list ( string ) NEW_LINE freq = [ 0 ] * MAX NEW_LINE minEvenDigit = MAX ; NEW_LINE minDigit = MAX ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT digit = ord ( string [ i ] ) - ord ( '0' ) ; NEW_LINE freq [ digit ] += 1 ; NEW_LINE if ( digit % 2 == 0 ) : NEW_LINE INDENT minEvenDigit = min ( digit , minEvenDigit ) ; NEW_LINE DEDENT minDigit = min ( digit , minDigit ) ; NEW_LINE DEDENT if ( minEvenDigit == MAX ) : NEW_LINE INDENT return \" - 1\" ; NEW_LINE DEDENT freq [ minEvenDigit ] -= 1 ; NEW_LINE freq [ minDigit ] -= 1 ; NEW_LINE i = 0 ; NEW_LINE for j in range ( MAX - 1 , - 1 , - 1 ) : NEW_LINE INDENT for k in range ( freq [ j ] ) : NEW_LINE INDENT string [ i ] = chr ( j + ord ( '0' ) ) ; NEW_LINE i += 1 NEW_LINE DEDENT if ( j == minEvenDigit ) : NEW_LINE INDENT string [ i ] = chr ( minDigit + ord ( '0' ) ) ; NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return \" \" . join ( string ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"1023422\" ; NEW_LINE length = len ( string ) ; NEW_LINE print ( getMaxEven ( string , length ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1820_A", "sol": 0, "python_code": "MAX_DIGITS = 20 ;\ndef isOctal ( n ) :\n    while ( n ) :\n        if ( ( n % 10 ) >= 8 ) :\n            return False\n        else :\n            n = int ( n / 10 )\n    return True\ndef isPalindrome ( n ) :\n    divide = 8 if ( isOctal ( n ) == False ) else 10\n    octal = [ ]\n    while ( n != 0 ) :\n        octal.append ( n % divide )\n        n = int ( n / divide )\n    j = len ( octal ) - 1\n    k = 0\n    while ( k <= j ) :\n        if ( octal [ j ] != octal [ k ] ) :\n            return False\n        j -= 1\n        k += 1\n    return True\nif __name__ == '__main__' :\n    n = 97 ;\n    if ( isPalindrome ( n ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "MAX_DIGITS = 20 ; NEW_LINE def isOctal ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) >= 8 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT n = int ( n / 10 ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divide = 8 if ( isOctal ( n ) == False ) else 10 NEW_LINE octal = [ ] NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octal . append ( n % divide ) NEW_LINE n = int ( n / divide ) NEW_LINE DEDENT j = len ( octal ) - 1 NEW_LINE k = 0 NEW_LINE while ( k <= j ) : NEW_LINE INDENT if ( octal [ j ] != octal [ k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 97 ; NEW_LINE if ( isPalindrome ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1701_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    a = [ list ( map ( int , input ( ).split ( ) ) ) for i in range ( 2 ) ]\n    cnt = sum ( [ sum ( a [ i ] ) for i in range ( 2 ) ] )\n    if cnt == 0 :\n        print ( 0 )\n    elif cnt == 4 :\n        print ( 2 )\n    else :\n        print ( 1 )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 2 ) ] NEW_LINE cnt = sum ( [ sum ( a [ i ] ) for i in range ( 2 ) ] ) NEW_LINE if cnt == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif cnt == 4 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1574_A", "sol": 0, "python_code": "def reversedigit ( num ) :\n    rev_num = 0\n    while num > 0 :\n        rev_num = rev_num * 10 + num % 10\n        num = num // 10\n    return rev_num\ndef icanobifNumbers ( N ) :\n    first = 0\n    second = 1\n    if N == 1 :\n        print ( first )\n    elif N == 2 :\n        print ( first , second )\n    else :\n        print ( first , second , end = \" \" )\n        for i in range ( 3 , N + 1 ) :\n            x = reversedigit ( first )\n            y = reversedigit ( second )\n            print ( x + y , end = \" \" )\n            temp = second\n            second = x + y\n            first = temp\nN = 12\nicanobifNumbers ( N )\n", "python_code_tokenized": "def reversedigit ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while num > 0 : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT def icanobifNumbers ( N ) : NEW_LINE INDENT first = 0 NEW_LINE second = 1 NEW_LINE if N == 1 : NEW_LINE INDENT print ( first ) NEW_LINE DEDENT elif N == 2 : NEW_LINE INDENT print ( first , second ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( first , second , end = \" \u2581 \" ) NEW_LINE for i in range ( 3 , N + 1 ) : NEW_LINE INDENT x = reversedigit ( first ) NEW_LINE y = reversedigit ( second ) NEW_LINE print ( x + y , end = \" \u2581 \" ) NEW_LINE temp = second NEW_LINE second = x + y NEW_LINE first = temp NEW_LINE DEDENT DEDENT DEDENT N = 12 NEW_LINE icanobifNumbers ( N ) NEW_LINE"}
{"id": "codeforces_820_B", "sol": 0, "python_code": "def main ( ) :\n    n , a = [ int ( i ) for i in input ( ).split ( ) ]\n    if n == 3 :\n        print ( 1 , 2 , 3 )\n        return\n    s = ( n - 2 ) * 180\n    a1 = s / n\n    f = ( a1 - a ) / ( 180 - a1 ) * 2\n    c = 2\n    b = n - f\n    if b - int ( b ) > 0.50 :\n        b = max ( min ( int ( b ) + 1 , n ) , 3 )\n    else :\n        b = max ( min ( int ( b ) , n ) , 3 )\n    if c - int ( c ) > 0.50 :\n        c = max ( int ( c ) + 1 , 2 )\n    else :\n        c = max ( int ( c ) , 2 )\n    print ( c , 1 , b )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT n , a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if n == 3 : NEW_LINE INDENT print ( 1 , 2 , 3 ) NEW_LINE return NEW_LINE DEDENT s = ( n - 2 ) * 180 NEW_LINE a1 = s / n NEW_LINE f = ( a1 - a ) / ( 180 - a1 ) * 2 NEW_LINE c = 2 NEW_LINE b = n - f NEW_LINE if b - int ( b ) > 0.50 : NEW_LINE INDENT b = max ( min ( int ( b ) + 1 , n ) , 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = max ( min ( int ( b ) , n ) , 3 ) NEW_LINE DEDENT if c - int ( c ) > 0.50 : NEW_LINE INDENT c = max ( int ( c ) + 1 , 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT c = max ( int ( c ) , 2 ) NEW_LINE DEDENT print ( c , 1 , b ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_1339_B", "sol": 0, "python_code": "itr = int ( input ( ) )\nfor i in range ( 0 , itr ) :\n    num = int ( input ( ) )\n    x = list ( map ( int , input ( ).split ( ) ) )\n    arr = sorted ( x )\n    ans = [ ]\n    if len ( arr ) % 2 != 0 :\n        ans.append ( arr [ len ( arr ) // 2 ] )\n        for i in range ( len ( arr ) // 2 ) :\n            ans.append ( arr [ ( len ( arr ) // 2 ) + 1 + i ] )\n            ans.append ( arr [ ( len ( arr ) // 2 ) - 1 - i ] )\n        for item in ans :\n            print ( item , end = \" \" )\n            print ( '' )\n    else :\n        for i in range ( len ( arr ) // 2 ) :\n            ans.append ( arr [ ( len ( arr ) // 2 ) + i ] )\n            ans.append ( arr [ ( len ( arr ) // 2 ) - i - 1 ] )\n        for item in ans :\n            print ( item , end = \" \" )\n    print ( '' )\n", "python_code_tokenized": "itr = int ( input ( ) ) NEW_LINE for i in range ( 0 , itr ) : NEW_LINE INDENT num = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr = sorted ( x ) NEW_LINE ans = [ ] NEW_LINE if len ( arr ) % 2 != 0 : NEW_LINE INDENT ans . append ( arr [ len ( arr ) // 2 ] ) NEW_LINE for i in range ( len ( arr ) // 2 ) : NEW_LINE INDENT ans . append ( arr [ ( len ( arr ) // 2 ) + 1 + i ] ) NEW_LINE ans . append ( arr [ ( len ( arr ) // 2 ) - 1 - i ] ) NEW_LINE DEDENT for item in ans : NEW_LINE INDENT print ( item , end = \" \u2581 \" ) NEW_LINE print ( ' ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( len ( arr ) // 2 ) : NEW_LINE INDENT ans . append ( arr [ ( len ( arr ) // 2 ) + i ] ) NEW_LINE ans . append ( arr [ ( len ( arr ) // 2 ) - i - 1 ] ) NEW_LINE DEDENT for item in ans : NEW_LINE INDENT print ( item , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT print ( ' ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1464_A", "sol": 0, "python_code": "def maxAlternateSum ( arr , n ) :\n    if ( n == 1 ) :\n        return arr [ 0 ]\n    dec = [ 0 for i in range ( n + 1 ) ]\n    inc = [ 0 for i in range ( n + 1 ) ]\n    dec [ 0 ] = inc [ 0 ] = arr [ 0 ]\n    flag = 0\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ j ] > arr [ i ] ) :\n                dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] )\n                flag = 1\n            elif ( arr [ j ] < arr [ i ] and flag == 1 ) :\n                inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] )\n    result = - 2147483648\n    for i in range ( n ) :\n        if ( result < inc [ i ] ) :\n            result = inc [ i ]\n        if ( result < dec [ i ] ) :\n            result = dec [ i ]\n    return result\narr = [ 8 , 2 , 3 , 5 , 7 , 9 , 10 ]\nn = len ( arr )\nprint ( \"Maximum sum = \" , maxAlternateSum ( arr , n ) )\n", "python_code_tokenized": "def maxAlternateSum ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT dec = [ 0 for i in range ( n + 1 ) ] NEW_LINE inc = [ 0 for i in range ( n + 1 ) ] NEW_LINE dec [ 0 ] = inc [ 0 ] = arr [ 0 ] NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif ( arr [ j ] < arr [ i ] and flag == 1 ) : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT result = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < inc [ i ] ) : NEW_LINE INDENT result = inc [ i ] NEW_LINE DEDENT if ( result < dec [ i ] ) : NEW_LINE INDENT result = dec [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 8 , 2 , 3 , 5 , 7 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum \u2581 sum \u2581 = \u2581 \" , maxAlternateSum ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_1202_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    x = input ( )\n    y = input ( )\n    x , y = x [ : : - 1 ] , y [ : : - 1 ]\n    n = len ( x )\n    m = len ( y )\n    for i in range ( m ) :\n        if ( y [ i ] == '1' ) :\n            break\n    for j in range ( i , n ) :\n        if ( x [ j ] == '1' ) :\n            break\n    print ( j - i )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x = input ( ) NEW_LINE y = input ( ) NEW_LINE x , y = x [ : : - 1 ] , y [ : : - 1 ] NEW_LINE n = len ( x ) NEW_LINE m = len ( y ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( y [ i ] == '1' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( i , n ) : NEW_LINE INDENT if ( x [ j ] == '1' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( j - i ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2236_A", "sol": 0, "python_code": "def countNumbers ( x , n ) :\n    if x > n :\n        return 0\n    return ( 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) )\nif __name__ == '__main__' :\n    n = 120 ;\n    print ( countNumbers ( 1 , n ) ) ;\n", "python_code_tokenized": "def countNumbers ( x , n ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 120 ; NEW_LINE print ( countNumbers ( 1 , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_409_A", "sol": 0, "python_code": "def minimumSets ( arr , n , key ) :\n    arr.sort ( reverse = False )\n    j = n - 1\n    for i in range ( 0 , j + 1 , 1 ) :\n        if ( arr [ i ] + arr [ j ] <= key ) :\n            j -= 1\n    return i + 1\nif __name__ == '__main__' :\n    arr = [ 3 , 5 , 3 , 4 ]\n    n = len ( arr )\n    key = 5\n    print ( minimumSets ( arr , n , key ) )\n", "python_code_tokenized": "def minimumSets ( arr , n , key ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , j + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] <= key ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return i + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 5 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE key = 5 NEW_LINE print ( minimumSets ( arr , n , key ) ) NEW_LINE DEDENT"}
{"id": "codeforces_591_A", "sol": 0, "python_code": "if __name__ == '__main__' :\n    l = int ( input ( ) )\n    p = int ( input ( ) )\n    q = int ( input ( ) )\n    s = l / ( p + q )\n    x = p * s\n    print ( x )\n", "python_code_tokenized": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = int ( input ( ) ) NEW_LINE p = int ( input ( ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE s = l / ( p + q ) NEW_LINE x = p * s NEW_LINE print ( x ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC031_A", "sol": 0, "python_code": "from collections import Counter\nn = int ( input ( ) )\ns = input ( )\nsc = Counter ( s ).most_common ( )\nans = 1\nfor i , j in sc :\n    ans = ans * ( j + 1 ) % 1000000007\nprint ( ans - 1 )\n", "python_code_tokenized": "from collections import Counter NEW_LINE n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE sc = Counter ( s ) . most_common ( ) NEW_LINE ans = 1 NEW_LINE for i , j in sc : NEW_LINE INDENT ans = ans * ( j + 1 ) % 1000000007 NEW_LINE DEDENT print ( ans - 1 ) NEW_LINE"}
{"id": "atcoder_ABC128_F", "sol": 0, "python_code": "def make_divisors ( n ) :\n    lower_divisors , upper_divisors = [ ] , [ ]\n    i = 1\n    while i * i <= n :\n        if n % i == 0 :\n            lower_divisors.append ( i )\n            if i != n // i :\n                upper_divisors.append ( n // i )\n        i += 1\n    return lower_divisors + upper_divisors [ : : - 1 ]\nN = int ( input ( ) )\ns = list ( map ( int , input ( ).split ( ) ) )\nD = [ [ ] ]\nfor i in range ( 1 , N ) :\n    DD = [ ]\n    T = [ 0 ]\n    for j in range ( i , N , i ) :\n        T.append ( T [ - 1 ] + s [ j ] )\n    DD.append ( T )\n    T = [ 0 ]\n    start = ( N - 1 ) % i\n    if start == 0 : start += i\n    for j in range ( start , N , i ) :\n        T.append ( T [ - 1 ] + s [ j ] )\n    DD.append ( T )\n    D.append ( DD )\nans = s [ - 1 ]\ncnt = 0\nfor n in range ( 2 , N - 1 ) :\n    end = N - 1 - n\n    for m in make_divisors ( end ) :\n        if n <= m : break\n        if n % m == 0 and end >= n : continue\n        k = end // m\n        a = D [ m ] [ 0 ] [ k ]\n        l = len ( D [ m ] [ 1 ] )\n        b = D [ m ] [ 1 ] [ - 1 ] - D [ m ] [ 1 ] [ l - k - 2 ]\n        ans = max ( ans , a + b )\nprint ( ans )\n", "python_code_tokenized": "def make_divisors ( n ) : NEW_LINE INDENT lower_divisors , upper_divisors = [ ] , [ ] NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT lower_divisors . append ( i ) NEW_LINE if i != n // i : NEW_LINE INDENT upper_divisors . append ( n // i ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return lower_divisors + upper_divisors [ : : - 1 ] NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE D = [ [ ] ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT DD = [ ] NEW_LINE T = [ 0 ] NEW_LINE for j in range ( i , N , i ) : NEW_LINE INDENT T . append ( T [ - 1 ] + s [ j ] ) NEW_LINE DEDENT DD . append ( T ) NEW_LINE T = [ 0 ] NEW_LINE start = ( N - 1 ) % i NEW_LINE if start == 0 : start += i NEW_LINE for j in range ( start , N , i ) : NEW_LINE INDENT T . append ( T [ - 1 ] + s [ j ] ) NEW_LINE DEDENT DD . append ( T ) NEW_LINE D . append ( DD ) NEW_LINE DEDENT ans = s [ - 1 ] NEW_LINE cnt = 0 NEW_LINE for n in range ( 2 , N - 1 ) : NEW_LINE INDENT end = N - 1 - n NEW_LINE for m in make_divisors ( end ) : NEW_LINE INDENT if n <= m : break NEW_LINE if n % m == 0 and end >= n : continue NEW_LINE k = end // m NEW_LINE a = D [ m ] [ 0 ] [ k ] NEW_LINE l = len ( D [ m ] [ 1 ] ) NEW_LINE b = D [ m ] [ 1 ] [ - 1 ] - D [ m ] [ 1 ] [ l - k - 2 ] NEW_LINE ans = max ( ans , a + b ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_3148_A", "sol": 0, "python_code": "def precomput ( f ) :\n    f.append ( 0 )\n    f.append ( 1 )\n    for i in range ( 2 , 300 ) :\n        f.append ( ( f [ i - 1 ] + f [ i - 2 ] ) % 100 )\ndef findLastDigit ( f , n ) :\n    return f [ n % 300 ]\nf = list ( )\nprecomput ( f )\nn = 1\nprint ( findLastDigit ( f , n ) )\nn = 61\nprint ( findLastDigit ( f , n ) )\nn = 7\nprint ( findLastDigit ( f , n ) )\nn = 67\nprint ( findLastDigit ( f , n ) )\n", "python_code_tokenized": "def precomput ( f ) : NEW_LINE INDENT f . append ( 0 ) NEW_LINE f . append ( 1 ) NEW_LINE for i in range ( 2 , 300 ) : NEW_LINE INDENT f . append ( ( f [ i - 1 ] + f [ i - 2 ] ) % 100 ) NEW_LINE DEDENT DEDENT def findLastDigit ( f , n ) : NEW_LINE INDENT return f [ n % 300 ] NEW_LINE DEDENT f = list ( ) NEW_LINE precomput ( f ) NEW_LINE n = 1 NEW_LINE print ( findLastDigit ( f , n ) ) NEW_LINE n = 61 NEW_LINE print ( findLastDigit ( f , n ) ) NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( f , n ) ) NEW_LINE n = 67 NEW_LINE print ( findLastDigit ( f , n ) ) NEW_LINE"}
{"id": "aizu_p02221_A", "sol": 0, "python_code": "import sys\nreadline = sys.stdin.readline\nN = int ( readline ( ) )\nNs = 1 << N\nS = [ None ] + list ( map ( int , readline ( ).strip ( ) ) )\nP = list ( map ( int , readline ( ).split ( ) ) )\nres = [ None ] * Ns\nres [ 0 ] = P\nres [ 1 ] = P [ 1 : ] + [ P [ 0 ] ]\nAns = [ None ] * Ns\nfor i in range ( Ns ) :\n    ri = res [ i ]\n    leng = len ( ri )\n    for level in range ( leng.bit_length ( ) - 1 ) :\n        cnt = [ ]\n        for j in range ( len ( ri ) // 2 ) :\n            a = ri [ 2 * j ]\n            b = ri [ 2 * j + 1 ]\n            if S [ abs ( a - b ) ] == 1 :\n                cnt.append ( max ( a , b ) )\n            else :\n                cnt.append ( min ( a , b ) )\n        ri = cnt [ : ]\n        lri = len ( ri )\n        if 1 < Ns // lri < Ns - i :\n            res [ i + Ns // lri ] = ri [ 1 : ] + [ ri [ 0 ] ]\n    Ans [ i ] = ri [ 0 ]\nprint ( '\\n'.join ( map ( str , Ans ) ) )\n", "python_code_tokenized": "import sys NEW_LINE readline = sys . stdin . readline NEW_LINE N = int ( readline ( ) ) NEW_LINE Ns = 1 << N NEW_LINE S = [ None ] + list ( map ( int , readline ( ) . strip ( ) ) ) NEW_LINE P = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE res = [ None ] * Ns NEW_LINE res [ 0 ] = P NEW_LINE res [ 1 ] = P [ 1 : ] + [ P [ 0 ] ] NEW_LINE Ans = [ None ] * Ns NEW_LINE for i in range ( Ns ) : NEW_LINE INDENT ri = res [ i ] NEW_LINE leng = len ( ri ) NEW_LINE for level in range ( leng . bit_length ( ) - 1 ) : NEW_LINE INDENT cnt = [ ] NEW_LINE for j in range ( len ( ri ) // 2 ) : NEW_LINE INDENT a = ri [ 2 * j ] NEW_LINE b = ri [ 2 * j + 1 ] NEW_LINE if S [ abs ( a - b ) ] == 1 : NEW_LINE INDENT cnt . append ( max ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt . append ( min ( a , b ) ) NEW_LINE DEDENT DEDENT ri = cnt [ : ] NEW_LINE lri = len ( ri ) NEW_LINE if 1 < Ns // lri < Ns - i : NEW_LINE INDENT res [ i + Ns // lri ] = ri [ 1 : ] + [ ri [ 0 ] ] NEW_LINE DEDENT DEDENT Ans [ i ] = ri [ 0 ] NEW_LINE DEDENT print ( ' \\n ' . join ( map ( str , Ans ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_3981_A", "sol": 0, "python_code": "import math as mt\ndef printPrevSmaller ( arr , n ) :\n    S = list ( )\n    for i in range ( n ) :\n        while ( len ( S ) > 0 and S [ - 1 ] >= arr [ i ] ) :\n            S.pop ( )\n        if ( len ( S ) == 0 ) :\n            print ( \"_, \" , end = \"\" )\n        else :\n            print ( S [ - 1 ] , end = \", \" )\n        S.append ( arr [ i ] )\narr = [ 1 , 3 , 0 , 2 , 5 ]\nn = len ( arr )\nprintPrevSmaller ( arr , n )\n", "python_code_tokenized": "import math as mt NEW_LINE def printPrevSmaller ( arr , n ) : NEW_LINE INDENT S = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( len ( S ) > 0 and S [ - 1 ] >= arr [ i ] ) : NEW_LINE INDENT S . pop ( ) NEW_LINE DEDENT if ( len ( S ) == 0 ) : NEW_LINE INDENT print ( \" _ , \u2581 \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( S [ - 1 ] , end = \" , \u2581 \" ) NEW_LINE DEDENT S . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 0 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printPrevSmaller ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_4486_A", "sol": 0, "python_code": "def pattern ( ) :\n    k = 0\n    spaces = 1\n    n = 7\n    for i in range ( n , 0 , - 1 ) :\n        for j in range ( 1 , i + 1 ) :\n            print ( i , end = \"\" )\n        if ( i != n ) :\n            for k in range ( 1 , spaces + 1 ) :\n                print ( end = \"\" )\n            spaces = spaces + 2\n        for j in range ( i , 0 , - 1 ) :\n            if ( j != n ) :\n                print ( i , end = \"\" )\n        print ( )\n    spaces = spaces - 4\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( 1 , i + 1 ) :\n            print ( i , end = \"\" )\n        if ( i != n ) :\n            for k in range ( 1 , spaces + 1 ) :\n                print ( end = \"\" )\n            spaces = spaces - 2\n        for j in range ( i , 0 , - 1 ) :\n            if ( j != n ) :\n                print ( i , end = \"\" )\n        print ( )\npattern ( )\n", "python_code_tokenized": "def pattern ( ) : NEW_LINE INDENT k = 0 NEW_LINE spaces = 1 NEW_LINE n = 7 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT if ( i != n ) : NEW_LINE INDENT for k in range ( 1 , spaces + 1 ) : NEW_LINE INDENT print ( end = \" \u2581 \" ) NEW_LINE DEDENT spaces = spaces + 2 NEW_LINE DEDENT for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT if ( j != n ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT spaces = spaces - 4 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT if ( i != n ) : NEW_LINE INDENT for k in range ( 1 , spaces + 1 ) : NEW_LINE INDENT print ( end = \" \u2581 \" ) NEW_LINE DEDENT spaces = spaces - 2 NEW_LINE DEDENT for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT if ( j != n ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT pattern ( ) NEW_LINE"}
{"id": "atcoder_ABC061_D", "sol": 0, "python_code": "def BF ( p , n , s ) :\n    inf = float ( \"inf\" )\n    d = [ inf for i in range ( n ) ]\n    d [ s - 1 ] = 0\n    for i in range ( n + 1 ) :\n        for e in p :\n            if e [ 0 ] != inf and d [ e [ 1 ] - 1 ] > d [ e [ 0 ] - 1 ] + e [ 2 ] :\n                d [ e [ 1 ] - 1 ] = d [ e [ 0 ] - 1 ] + e [ 2 ]\n        if i == n - 1 : t = d [ - 1 ]\n        if i == n and t != d [ - 1 ] :\n            return [ 0 , 'inf' ]\n    return list ( map ( lambda x : - x , d ) )\nn , m = map ( int , input ( ).split ( ) )\na = [ list ( map ( int , input ( ).split ( ) ) ) for i in range ( m ) ]\na = [ [ x , y , - z ] for x , y , z in a ]\nprint ( BF ( a , n , 1 ) [ - 1 ] )\n", "python_code_tokenized": "def BF ( p , n , s ) : NEW_LINE INDENT inf = float ( \" inf \" ) NEW_LINE d = [ inf for i in range ( n ) ] NEW_LINE d [ s - 1 ] = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for e in p : NEW_LINE INDENT if e [ 0 ] != inf and d [ e [ 1 ] - 1 ] > d [ e [ 0 ] - 1 ] + e [ 2 ] : NEW_LINE INDENT d [ e [ 1 ] - 1 ] = d [ e [ 0 ] - 1 ] + e [ 2 ] NEW_LINE DEDENT DEDENT if i == n - 1 : t = d [ - 1 ] NEW_LINE if i == n and t != d [ - 1 ] : NEW_LINE INDENT return [ 0 , ' inf ' ] NEW_LINE DEDENT DEDENT return list ( map ( lambda x : - x , d ) ) NEW_LINE DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] NEW_LINE a = [ [ x , y , - z ] for x , y , z in a ] NEW_LINE print ( BF ( a , n , 1 ) [ - 1 ] ) NEW_LINE"}
{"id": "geeksforgeeks_3881_A", "sol": 0, "python_code": "def ReplaceElements ( arr , n ) :\n    prod = 1\n    for i in range ( n ) :\n        prod *= arr [ i ]\n    for i in range ( n ) :\n        arr [ i ] = prod // arr [ i ]\nif __name__ == \"__main__\" :\n    arr = [ 2 , 3 , 3 , 5 , 7 ]\n    n = len ( arr )\n    ReplaceElements ( arr , n )\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" )\n", "python_code_tokenized": "def ReplaceElements ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = prod // arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 3 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_701_A", "sol": 0, "python_code": "n = int ( input ( ) )\nl = tuple ( map ( int , input ( ).split ( ) ) )\nl1 = [ 0 ] * n\nm = sum ( l ) // ( n // 2 )\nflag = True\nfor i in range ( n ) :\n    if l1 [ i ] == 0 :\n        for j in range ( i + 1 , n ) :\n            if ( l [ i ] + l [ j ] ) == m and l1 [ j ] == 0 :\n                print ( i + 1 , j + 1 )\n                l1 [ j ] = 1\n                break\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE l = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l1 = [ 0 ] * n NEW_LINE m = sum ( l ) // ( n // 2 ) NEW_LINE flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l1 [ i ] == 0 : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( l [ i ] + l [ j ] ) == m and l1 [ j ] == 0 : NEW_LINE INDENT print ( i + 1 , j + 1 ) NEW_LINE l1 [ j ] = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT"}
{"id": "atcoder_ABC097_D", "sol": 0, "python_code": "class UnionFind ( ) :\n    def __init__ ( self , n ) :\n        self.par = [ i for i in range ( n + 1 ) ]\n        self.rank = [ 0 ] * ( n + 1 )\n    def root ( self , x ) :\n        if self.par [ x ] == x :\n            return x\n        r = self.root ( self.par [ x ] )\n        self.par [ x ] = r\n        return r\n    def same ( self , x , y ) :\n        return self.root ( x ) == self.root ( y )\n    def unite ( self , x , y ) :\n        rx = self.root ( x )\n        ry = self.root ( y )\n        if rx == ry :\n            return\n        if self.rank [ rx ] < self.rank [ ry ] :\n            self.par [ x ] = ry\n            self.par [ rx ] = ry\n        else :\n            self.par [ y ] = rx\n            self.par [ ry ] = rx\n            if self.rank [ rx ] == self.rank [ ry ] :\n                self.rank [ rx ] += 1\ndef main ( ) :\n    N , M , * PXY = map ( int , open ( 0 ).read ( ).split ( ) )\n    P = PXY [ : N ]\n    uf = UnionFind ( N + 1 )\n    for i in range ( M ) :\n        x , y = PXY [ N + 2 * i + 0 ] , PXY [ N + 2 * i + 1 ]\n        uf.unite ( x , y )\n    ans = 0\n    for i in range ( N ) :\n        is_same = uf.same ( i + 1 , P [ i ] )\n        if is_same :\n            ans += 1\n    print ( ans )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "class UnionFind ( ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . par = [ i for i in range ( n + 1 ) ] NEW_LINE self . rank = [ 0 ] * ( n + 1 ) NEW_LINE DEDENT def root ( self , x ) : NEW_LINE INDENT if self . par [ x ] == x : NEW_LINE INDENT return x NEW_LINE DEDENT r = self . root ( self . par [ x ] ) NEW_LINE self . par [ x ] = r NEW_LINE return r NEW_LINE DEDENT def same ( self , x , y ) : NEW_LINE INDENT return self . root ( x ) == self . root ( y ) NEW_LINE DEDENT def unite ( self , x , y ) : NEW_LINE INDENT rx = self . root ( x ) NEW_LINE ry = self . root ( y ) NEW_LINE if rx == ry : NEW_LINE INDENT return NEW_LINE DEDENT if self . rank [ rx ] < self . rank [ ry ] : NEW_LINE INDENT self . par [ x ] = ry NEW_LINE self . par [ rx ] = ry NEW_LINE DEDENT else : NEW_LINE INDENT self . par [ y ] = rx NEW_LINE self . par [ ry ] = rx NEW_LINE if self . rank [ rx ] == self . rank [ ry ] : NEW_LINE INDENT self . rank [ rx ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT N , M , * PXY = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE P = PXY [ : N ] NEW_LINE uf = UnionFind ( N + 1 ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT x , y = PXY [ N + 2 * i + 0 ] , PXY [ N + 2 * i + 1 ] NEW_LINE uf . unite ( x , y ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT is_same = uf . same ( i + 1 , P [ i ] ) NEW_LINE if is_same : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_662_A", "sol": 0, "python_code": "def reverse ( n ) :\n    rev = 0 ;\n    while ( n > 0 ) :\n        d = n % 10 ;\n        rev = rev * 10 + d ;\n        n = n // 10 ;\n    return rev ;\ndef isPalin ( n ) :\n    return ( n == reverse ( n ) ) ;\ndef countDigits ( n ) :\n    c = 0 ;\n    while ( n > 0 ) :\n        n = n // 10 ;\n        c += 1 ;\n    return c ;\ndef countPalinDigits ( arr , n ) :\n    s = 0 ;\n    for i in range ( n ) :\n        if ( arr [ i ] < 10 or isPalin ( arr [ i ] ) ) :\n            s += countDigits ( arr [ i ] ) ;\n    return s ;\narr = [ 121 , 56 , 434 ] ;\nn = len ( arr ) ;\nprint ( countPalinDigits ( arr , n ) ) ;\n", "python_code_tokenized": "def reverse ( n ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 ; NEW_LINE rev = rev * 10 + d ; NEW_LINE n = n // 10 ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def isPalin ( n ) : NEW_LINE INDENT return ( n == reverse ( n ) ) ; NEW_LINE DEDENT def countDigits ( n ) : NEW_LINE INDENT c = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n // 10 ; NEW_LINE c += 1 ; NEW_LINE DEDENT return c ; NEW_LINE DEDENT def countPalinDigits ( arr , n ) : NEW_LINE INDENT s = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 10 or isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += countDigits ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT return s ; NEW_LINE DEDENT arr = [ 121 , 56 , 434 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPalinDigits ( arr , n ) ) ; NEW_LINE"}
{"id": "aizu_p00107_A", "sol": 0, "python_code": "import sys\nimport os\nimport math\nfor s in sys.stdin :\n    d , w , h = map ( int , s.split ( ) )\n    if d == w == h == 0 :\n        break\n    lst = [ d , w , h ]\n    lst.sort ( )\n    diameter = math.sqrt ( lst [ 0 ] ** 2 + lst [ 1 ] ** 2 )\n    n = int ( input ( ) )\n    for i in range ( n ) :\n        r = int ( input ( ) )\n        if 2 * r > diameter :\n            print ( 'OK' )\n        else :\n            print ( 'NA' )\n", "python_code_tokenized": "import sys NEW_LINE import os NEW_LINE import math NEW_LINE for s in sys . stdin : NEW_LINE INDENT d , w , h = map ( int , s . split ( ) ) NEW_LINE if d == w == h == 0 : NEW_LINE INDENT break NEW_LINE DEDENT lst = [ d , w , h ] NEW_LINE lst . sort ( ) NEW_LINE diameter = math . sqrt ( lst [ 0 ] ** 2 + lst [ 1 ] ** 2 ) NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT r = int ( input ( ) ) NEW_LINE if 2 * r > diameter : NEW_LINE INDENT print ( ' OK ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NA ' ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "codeforces_1706_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n , m = list ( map ( int , input ( ).split ( '' ) ) )\n    s = [ 'B' ] * m\n    a = list ( map ( int , input ( ).split ( '' ) ) )\n    for i in range ( n ) :\n        if m + 1 - a [ i ] >= 0 and m + 1 - a [ i ] <= a [ i ] :\n            if s [ m + 1 - a [ i ] - 1 ] == 'B' :\n                s [ m + 1 - a [ i ] - 1 ] = 'A'\n            else :\n                s [ a [ i ] - 1 ] = 'A'\n        else :\n            if s [ a [ i ] - 1 ] == 'B' :\n                s [ a [ i ] - 1 ] = 'A'\n            else :\n                s [ m + 1 - a [ i ] - 1 ] = 'A'\n    print ( ''.join ( s ) )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE s = [ ' B ' ] * m NEW_LINE a = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if m + 1 - a [ i ] >= 0 and m + 1 - a [ i ] <= a [ i ] : NEW_LINE INDENT if s [ m + 1 - a [ i ] - 1 ] == ' B ' : NEW_LINE INDENT s [ m + 1 - a [ i ] - 1 ] = ' A ' NEW_LINE DEDENT else : NEW_LINE INDENT s [ a [ i ] - 1 ] = ' A ' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if s [ a [ i ] - 1 ] == ' B ' : NEW_LINE INDENT s [ a [ i ] - 1 ] = ' A ' NEW_LINE DEDENT else : NEW_LINE INDENT s [ m + 1 - a [ i ] - 1 ] = ' A ' NEW_LINE DEDENT DEDENT DEDENT print ( ' ' . join ( s ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3347_A", "sol": 0, "python_code": "def findRotations ( str ) :\n    tmp = str + str\n    n = len ( str )\n    for i in range ( 1 , n + 1 ) :\n        substring = tmp [ i : i + n ]\n        if ( str == substring ) :\n            return i\n    return n\nif __name__ == '__main__' :\n    str = \"abc\"\n    print ( findRotations ( str ) )\n", "python_code_tokenized": "def findRotations ( str ) : NEW_LINE INDENT tmp = str + str NEW_LINE n = len ( str ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT substring = tmp [ i : i + n ] NEW_LINE if ( str == substring ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" abc \" NEW_LINE print ( findRotations ( str ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC102_D", "sol": 0, "python_code": "def solve ( string ) :\n    n , * a = map ( int , string.split ( ) )\n    l , c , r = 1 , 2 , 3\n    sll , slr , srl , srr = sum ( a [ : l ] ) , sum ( a [ l : c ] ) , sum ( a [ c : r ] ) , sum ( a [ r : ] )\n    ans = max ( sll , slr , srl , srr ) - min ( sll , slr , srl , srr )\n    while c < n - 1 :\n        d = abs ( sll - slr )\n        dn = abs ( sll + 2 * a [ l ] - slr )\n        while dn < d :\n            sll , slr = sll + a [ l ] , slr - a [ l ]\n            l += 1\n            d = abs ( sll - slr )\n            dn = abs ( sll + 2 * a [ l ] - slr )\n        d = abs ( srl - srr )\n        dn = abs ( srl + 2 * a [ r ] - srr )\n        while dn < d :\n            srl , srr = srl + a [ r ] , srr - a [ r ]\n            r += 1\n            d = abs ( srl - srr )\n            dn = abs ( srl + 2 * a [ r ] - srr )\n        ans = min ( ans , max ( sll , slr , srl , srr ) - min ( sll , slr , srl , srr ) )\n        slr += a [ c ]\n        srl -= a [ c ]\n        c += 1\n    return str ( ans )\nif __name__ == '__main__' :\n    print ( solve ( '\\n'.join ( [ input ( ) , input ( ) ] ) ) )\n", "python_code_tokenized": "def solve ( string ) : NEW_LINE INDENT n , * a = map ( int , string . split ( ) ) NEW_LINE l , c , r = 1 , 2 , 3 NEW_LINE sll , slr , srl , srr = sum ( a [ : l ] ) , sum ( a [ l : c ] ) , sum ( a [ c : r ] ) , sum ( a [ r : ] ) NEW_LINE ans = max ( sll , slr , srl , srr ) - min ( sll , slr , srl , srr ) NEW_LINE while c < n - 1 : NEW_LINE INDENT d = abs ( sll - slr ) NEW_LINE dn = abs ( sll + 2 * a [ l ] - slr ) NEW_LINE while dn < d : NEW_LINE INDENT sll , slr = sll + a [ l ] , slr - a [ l ] NEW_LINE l += 1 NEW_LINE d = abs ( sll - slr ) NEW_LINE dn = abs ( sll + 2 * a [ l ] - slr ) NEW_LINE DEDENT d = abs ( srl - srr ) NEW_LINE dn = abs ( srl + 2 * a [ r ] - srr ) NEW_LINE while dn < d : NEW_LINE INDENT srl , srr = srl + a [ r ] , srr - a [ r ] NEW_LINE r += 1 NEW_LINE d = abs ( srl - srr ) NEW_LINE dn = abs ( srl + 2 * a [ r ] - srr ) NEW_LINE DEDENT ans = min ( ans , max ( sll , slr , srl , srr ) - min ( sll , slr , srl , srr ) ) NEW_LINE slr += a [ c ] NEW_LINE srl -= a [ c ] NEW_LINE c += 1 NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( solve ( ' \\n ' . join ( [ input ( ) , input ( ) ] ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3255_A", "sol": 0, "python_code": "def numberOfTriangles ( n ) :\n    answer = [ None ] * ( n + 1 ) ;\n    answer [ 0 ] = 1 ;\n    i = 1\n    while i <= n :\n        answer [ i ] = answer [ i - 1 ] * 3 + 2 ;\n        i = i + 1\n    return answer [ n ] ;\nn = 2\nprint ( numberOfTriangles ( n ) )\n", "python_code_tokenized": "def numberOfTriangles ( n ) : NEW_LINE INDENT answer = [ None ] * ( n + 1 ) ; NEW_LINE answer [ 0 ] = 1 ; NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT answer [ i ] = answer [ i - 1 ] * 3 + 2 ; NEW_LINE i = i + 1 NEW_LINE DEDENT return answer [ n ] ; NEW_LINE DEDENT n = 2 NEW_LINE print ( numberOfTriangles ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1339_A", "sol": 0, "python_code": "fib = [ 0 ] * 100005 ;\ndef computeFibonacci ( ) :\n    fib [ 0 ] = 1 ;\n    fib [ 1 ] = 1 ;\n    for i in range ( 2 , 100005 ) :\n        fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ;\ndef countString ( string ) :\n    ans = 1 ;\n    cnt = 1 ;\n    for i in range ( 1 , len ( string ) ) :\n        if ( string [ i ] == string [ i - 1 ] ) :\n            cnt += 1 ;\n        else :\n            ans = ans * fib [ cnt ] ;\n            cnt = 1 ;\n    ans = ans * fib [ cnt ] ;\n    return ans ;\nif __name__ == \"__main__\" :\n    string = \"abdllldefkkkk\" ;\n    computeFibonacci ( ) ;\n    print ( countString ( string ) ) ;\n", "python_code_tokenized": "fib = [ 0 ] * 100005 ; NEW_LINE def computeFibonacci ( ) : NEW_LINE INDENT fib [ 0 ] = 1 ; NEW_LINE fib [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , 100005 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; NEW_LINE DEDENT DEDENT def countString ( string ) : NEW_LINE INDENT ans = 1 ; NEW_LINE cnt = 1 ; NEW_LINE for i in range ( 1 , len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == string [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans * fib [ cnt ] ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT ans = ans * fib [ cnt ] ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abdllldefkkkk \" ; NEW_LINE computeFibonacci ( ) ; NEW_LINE print ( countString ( string ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_256_A", "sol": 0, "python_code": "def minimumSwaps ( arr ) :\n    count = 0 ;\n    i = 0 ;\n    while ( i < len ( arr ) ) :\n        if ( arr [ i ] != i + 1 ) :\n            while ( arr [ i ] != i + 1 ) :\n                temp = 0 ;\n                temp = arr [ arr [ i ] - 1 ] ;\n                arr [ arr [ i ] - 1 ] = arr [ i ] ;\n                arr [ i ] = temp ;\n                count += 1 ;\n        i += 1 ;\n    return count ;\nif __name__ == '__main__' :\n    arr = [ 2 , 3 , 4 , 1 , 5 ] ;\n    print ( minimumSwaps ( arr ) ) ;\n", "python_code_tokenized": "def minimumSwaps ( arr ) : NEW_LINE INDENT count = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] != i + 1 ) : NEW_LINE INDENT while ( arr [ i ] != i + 1 ) : NEW_LINE INDENT temp = 0 ; NEW_LINE temp = arr [ arr [ i ] - 1 ] ; NEW_LINE arr [ arr [ i ] - 1 ] = arr [ i ] ; NEW_LINE arr [ i ] = temp ; NEW_LINE count += 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 1 , 5 ] ; NEW_LINE print ( minimumSwaps ( arr ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3681_A", "sol": 0, "python_code": "import math\ndef minPerimeter ( n ) :\n    l = math.sqrt ( n )\n    sq = l * l\n    if ( sq == n ) :\n        return l * 4\n    else :\n        row = n / l\n        perimeter = 2 * ( l + row )\n        if ( n % l != 0 ) :\n            perimeter += 2\n        return perimeter\nn = 10\nprint ( int ( minPerimeter ( n ) ) )\n", "python_code_tokenized": "import math NEW_LINE def minPerimeter ( n ) : NEW_LINE INDENT l = math . sqrt ( n ) NEW_LINE sq = l * l NEW_LINE if ( sq == n ) : NEW_LINE INDENT return l * 4 NEW_LINE DEDENT else : NEW_LINE INDENT row = n / l NEW_LINE perimeter = 2 * ( l + row ) NEW_LINE if ( n % l != 0 ) : NEW_LINE INDENT perimeter += 2 NEW_LINE DEDENT return perimeter NEW_LINE DEDENT DEDENT n = 10 NEW_LINE print ( int ( minPerimeter ( n ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_4284_A", "sol": 0, "python_code": "def isValidSeq ( a , n ) :\n    nodes = n + 2 ;\n    for i in range ( n ) :\n        if ( a [ i ] < 1 or a [ i ] > nodes ) :\n            return False ;\n    return True ;\nif __name__ == \"__main__\" :\n    a = [ 4 , 1 , 3 , 4 ] ;\n    n = len ( a ) ;\n    if ( isValidSeq ( a , n ) ) :\n        print ( \"Valid\" ) ;\n    else :\n        print ( \"Invalid\" ) ;\n", "python_code_tokenized": "def isValidSeq ( a , n ) : NEW_LINE INDENT nodes = n + 2 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] < 1 or a [ i ] > nodes ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 4 , 1 , 3 , 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( isValidSeq ( a , n ) ) : NEW_LINE INDENT print ( \" Valid \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Invalid \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3130_A", "sol": 0, "python_code": "from queue import Queue\ndef reverseQueueFirstKElements ( k , Queue ) :\n    if ( Queue.empty ( ) == True or k > Queue.qsize ( ) ) :\n        return\n    if ( k <= 0 ) :\n        return\n    Stack = [ ]\n    for i in range ( k ) :\n        Stack.append ( Queue.queue [ 0 ] )\n        Queue.get ( )\n    while ( len ( Stack ) != 0 ) :\n        Queue.put ( Stack [ - 1 ] )\n        Stack.pop ( )\n    for i in range ( Queue.qsize ( ) - k ) :\n        Queue.put ( Queue.queue [ 0 ] )\n        Queue.get ( )\ndef Print ( Queue ) :\n    while ( not Queue.empty ( ) ) :\n        print ( Queue.queue [ 0 ] , end = \" \" )\n        Queue.get ( )\nif __name__ == '__main__' :\n    Queue = Queue ( )\n    Queue.put ( 10 )\n    Queue.put ( 20 )\n    Queue.put ( 30 )\n    Queue.put ( 40 )\n    Queue.put ( 50 )\n    Queue.put ( 60 )\n    Queue.put ( 70 )\n    Queue.put ( 80 )\n    Queue.put ( 90 )\n    Queue.put ( 100 )\n    k = 5\n    reverseQueueFirstKElements ( k , Queue )\n    Print ( Queue )\n", "python_code_tokenized": "from queue import Queue NEW_LINE def reverseQueueFirstKElements ( k , Queue ) : NEW_LINE INDENT if ( Queue . empty ( ) == True or k > Queue . qsize ( ) ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( k <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT Stack = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT Stack . append ( Queue . queue [ 0 ] ) NEW_LINE Queue . get ( ) NEW_LINE DEDENT while ( len ( Stack ) != 0 ) : NEW_LINE INDENT Queue . put ( Stack [ - 1 ] ) NEW_LINE Stack . pop ( ) NEW_LINE DEDENT for i in range ( Queue . qsize ( ) - k ) : NEW_LINE INDENT Queue . put ( Queue . queue [ 0 ] ) NEW_LINE Queue . get ( ) NEW_LINE DEDENT DEDENT def Print ( Queue ) : NEW_LINE INDENT while ( not Queue . empty ( ) ) : NEW_LINE INDENT print ( Queue . queue [ 0 ] , end = \" \u2581 \" ) NEW_LINE Queue . get ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Queue = Queue ( ) NEW_LINE Queue . put ( 10 ) NEW_LINE Queue . put ( 20 ) NEW_LINE Queue . put ( 30 ) NEW_LINE Queue . put ( 40 ) NEW_LINE Queue . put ( 50 ) NEW_LINE Queue . put ( 60 ) NEW_LINE Queue . put ( 70 ) NEW_LINE Queue . put ( 80 ) NEW_LINE Queue . put ( 90 ) NEW_LINE Queue . put ( 100 ) NEW_LINE k = 5 NEW_LINE reverseQueueFirstKElements ( k , Queue ) NEW_LINE Print ( Queue ) NEW_LINE DEDENT"}
{"id": "aizu_p00255_A", "sol": 0, "python_code": "import sys\nfrom itertools import accumulate\nf = sys.stdin\nwhile True :\n    n = int ( f.readline ( ) )\n    if n == 0 :\n        break\n    p = list ( map ( int , f.readline ( ).split ( ) ) )\n    j = list ( map ( int , f.readline ( ).split ( ) ) )\n    j.sort ( reverse = True )\n    j.insert ( 0 , 0 )\n    total_length = sum ( p )\n    num_of_pipe = len ( p )\n    print ( max ( ( num_of_pipe - i ) * ( total_length + ji ) for i , ji in enumerate ( accumulate ( j ) ) ) )\n", "python_code_tokenized": "import sys NEW_LINE from itertools import accumulate NEW_LINE f = sys . stdin NEW_LINE while True : NEW_LINE INDENT n = int ( f . readline ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT p = list ( map ( int , f . readline ( ) . split ( ) ) ) NEW_LINE j = list ( map ( int , f . readline ( ) . split ( ) ) ) NEW_LINE j . sort ( reverse = True ) NEW_LINE j . insert ( 0 , 0 ) NEW_LINE total_length = sum ( p ) NEW_LINE num_of_pipe = len ( p ) NEW_LINE print ( max ( ( num_of_pipe - i ) * ( total_length + ji ) for i , ji in enumerate ( accumulate ( j ) ) ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00345_A", "sol": 0, "python_code": "def gcd ( m , n ) :\n    r = m % n\n    return gcd ( n , r ) if r else n\ndef f ( v ) :\n    d = v.find ( \".\" )\n    if d == - 1 :\n        return int ( v ) , 1\n    a = int ( v [ : d ] + v [ d + 1 : ] )\n    n = 10 ** ( len ( v ) - d - 1 )\n    if a == 0 :\n        return 0 , 1\n    g = gcd ( n , a )\n    return int ( a / g ) , int ( n / g )\ns = input ( )\nd = s.find ( \".\" )\nl = s.find ( \"(\" )\nr = s.find ( \")\" )\nif l == - 1 :\n    res = f ( s )\nelse :\n    assert l >= 2 and r == len ( s ) - 1\n    aa , na = f ( s [ : l ] )\n    ab , nb = f ( \"0.\" + \"0\" * ( l - d - 1 ) + s [ l + 1 : r ] )\n    t = r - l - 1\n    a = ( 10 ** t - 1 ) * aa * nb + 10 ** t * ab * na\n    n = ( 10 ** t - 1 ) * na * nb\n    g = gcd ( a , n )\n    res = int ( a / g ) , int ( n / g )\nprint ( \"%d/%d\" % res )\n", "python_code_tokenized": "def gcd ( m , n ) : NEW_LINE INDENT r = m % n NEW_LINE return gcd ( n , r ) if r else n NEW_LINE DEDENT def f ( v ) : NEW_LINE INDENT d = v . find ( \" . \" ) NEW_LINE if d == - 1 : NEW_LINE INDENT return int ( v ) , 1 NEW_LINE DEDENT a = int ( v [ : d ] + v [ d + 1 : ] ) NEW_LINE n = 10 ** ( len ( v ) - d - 1 ) NEW_LINE if a == 0 : NEW_LINE INDENT return 0 , 1 NEW_LINE DEDENT g = gcd ( n , a ) NEW_LINE return int ( a / g ) , int ( n / g ) NEW_LINE DEDENT s = input ( ) NEW_LINE d = s . find ( \" . \" ) NEW_LINE l = s . find ( \" ( \" ) NEW_LINE r = s . find ( \" ) \" ) NEW_LINE if l == - 1 : NEW_LINE INDENT res = f ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT assert l >= 2 and r == len ( s ) - 1 NEW_LINE aa , na = f ( s [ : l ] ) NEW_LINE ab , nb = f ( \"0 . \" + \"0\" * ( l - d - 1 ) + s [ l + 1 : r ] ) NEW_LINE t = r - l - 1 NEW_LINE a = ( 10 ** t - 1 ) * aa * nb + 10 ** t * ab * na NEW_LINE n = ( 10 ** t - 1 ) * na * nb NEW_LINE g = gcd ( a , n ) NEW_LINE res = int ( a / g ) , int ( n / g ) NEW_LINE DEDENT print ( \" % d / % d \" % res ) NEW_LINE"}
{"id": "aizu_p02163_A", "sol": 0, "python_code": "n = int ( input ( ) )\na , b = 1 , 0\nfor i in range ( n ) :\n    q , x = map ( int , input ( ).split ( ) )\n    if q == 1 :\n        a *= x\n        b *= x\n    elif q == 2 :\n        b += x\n    elif q == 3 :\n        b -= x\nprint ( - b , a )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a , b = 1 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT q , x = map ( int , input ( ) . split ( ) ) NEW_LINE if q == 1 : NEW_LINE INDENT a *= x NEW_LINE b *= x NEW_LINE DEDENT elif q == 2 : NEW_LINE INDENT b += x NEW_LINE DEDENT elif q == 3 : NEW_LINE INDENT b -= x NEW_LINE DEDENT DEDENT print ( - b , a ) NEW_LINE"}
{"id": "geeksforgeeks_4322_A", "sol": 0, "python_code": "def EvenOddProduct ( arr , n ) :\n    even = 1\n    odd = 1\n    for i in range ( 0 , n ) :\n        if ( i % 2 == 0 ) :\n            even *= arr [ i ]\n        else :\n            odd *= arr [ i ]\n    print ( \"Even Index Product : \" , even )\n    print ( \"Odd Index Product : \" , odd )\narr = 1 , 2 , 3 , 4 , 5 , 6\nn = len ( arr )\nEvenOddProduct ( arr , n )\n", "python_code_tokenized": "def EvenOddProduct ( arr , n ) : NEW_LINE INDENT even = 1 NEW_LINE odd = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT even *= arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT odd *= arr [ i ] NEW_LINE DEDENT DEDENT print ( \" Even \u2581 Index \u2581 Product \u2581 : \u2581 \" , even ) NEW_LINE print ( \" Odd \u2581 Index \u2581 Product \u2581 : \u2581 \" , odd ) NEW_LINE DEDENT arr = 1 , 2 , 3 , 4 , 5 , 6 NEW_LINE n = len ( arr ) NEW_LINE EvenOddProduct ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_2090_A", "sol": 0, "python_code": "def min_sum ( n , k , a ) :\n    a.sort ( reverse = False )\n    if ( a [ 0 ] < 0 ) :\n        return - 1\n    if ( k == 0 ) :\n        if ( a [ 0 ] == a [ n - 1 ] ) :\n            return ( n * a [ 0 ] )\n        else :\n            return - 1\n    else :\n        f = 0\n        for i in range ( 1 , n , 1 ) :\n            p = a [ i ] - a [ 0 ]\n            if ( p % k == 0 ) :\n                continue\n            else :\n                f = 1\n                break\n        if ( f ) :\n            return - 1\n        else :\n            if ( k == 1 ) :\n                return n\n            else :\n                return ( n * ( a [ 0 ] % k ) )\nif __name__ == '__main__' :\n    arr = [ 2 , 3 , 4 , 5 ]\n    K = 1\n    N = len ( arr )\n    print ( min_sum ( N , K , arr ) )\n", "python_code_tokenized": "def min_sum ( n , k , a ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE if ( a [ 0 ] < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT if ( a [ 0 ] == a [ n - 1 ] ) : NEW_LINE INDENT return ( n * a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT p = a [ i ] - a [ 0 ] NEW_LINE if ( p % k == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( f ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( a [ 0 ] % k ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 ] NEW_LINE K = 1 NEW_LINE N = len ( arr ) NEW_LINE print ( min_sum ( N , K , arr ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3278_A", "sol": 0, "python_code": "MAX = 1001\nprefix = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ]\nar = [ 0 for i in range ( MAX ) ]\ndef cal_prefix ( n , arr ) :\n    for i in range ( n ) :\n        ar [ i + 1 ] = arr [ i ]\n    for i in range ( 1 , 1001 , 1 ) :\n        for j in range ( n + 1 ) :\n            prefix [ i ] [ j ] = 0\n        for j in range ( 1 , n + 1 ) :\n            if ar [ j ] <= i :\n                k = 1\n            else :\n                k = 0\n            prefix [ i ] [ j ] = prefix [ i ] [ j - 1 ] + k\ndef ksub ( l , r , n , k ) :\n    lo = 1\n    hi = 1000\n    while ( lo + 1 < hi ) :\n        mid = int ( ( lo + hi ) / 2 )\n        if ( prefix [ mid ] [ r ] - prefix [ mid ] [ l - 1 ] >= k ) :\n            hi = mid\n        else :\n            lo = mid + 1\n    if ( prefix [ lo ] [ r ] - prefix [ lo ] [ l - 1 ] >= k ) :\n        hi = lo\n    return hi\nif __name__ == '__main__' :\n    arr = [ 1 , 4 , 2 , 3 , 5 , 7 , 6 ]\n    n = len ( arr )\n    k = 4\n    cal_prefix ( n , arr )\n    queries = [ [ 1 , n , 1 ] , [ 2 , n - 2 , 2 ] , [ 3 , n - 1 , 3 ] ]\n    q = len ( queries )\n    for i in range ( q ) :\n        print ( ksub ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , n , queries [ i ] [ 2 ] ) )\n", "python_code_tokenized": "MAX = 1001 NEW_LINE prefix = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE ar = [ 0 for i in range ( MAX ) ] NEW_LINE def cal_prefix ( n , arr ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT ar [ i + 1 ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , 1001 , 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT prefix [ i ] [ j ] = 0 NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ar [ j ] <= i : NEW_LINE INDENT k = 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 0 NEW_LINE DEDENT prefix [ i ] [ j ] = prefix [ i ] [ j - 1 ] + k NEW_LINE DEDENT DEDENT DEDENT def ksub ( l , r , n , k ) : NEW_LINE INDENT lo = 1 NEW_LINE hi = 1000 NEW_LINE while ( lo + 1 < hi ) : NEW_LINE INDENT mid = int ( ( lo + hi ) / 2 ) NEW_LINE if ( prefix [ mid ] [ r ] - prefix [ mid ] [ l - 1 ] >= k ) : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT if ( prefix [ lo ] [ r ] - prefix [ lo ] [ l - 1 ] >= k ) : NEW_LINE INDENT hi = lo NEW_LINE DEDENT return hi NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 3 , 5 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE cal_prefix ( n , arr ) NEW_LINE queries = [ [ 1 , n , 1 ] , [ 2 , n - 2 , 2 ] , [ 3 , n - 1 , 3 ] ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( ksub ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , n , queries [ i ] [ 2 ] ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1870_A", "sol": 0, "python_code": "def toggleLastMBits ( n , m ) :\n    if ( m == 0 ) :\n        return n\n    num = ( 1 << m ) - 1\n    return ( n ^ num )\ndef largeNumWithNSetAndMUnsetBits ( n , m ) :\n    num = ( 1 << ( n + m ) ) - 1\n    return toggleLastMBits ( num , m )\nn = 2\nm = 2\nprint ( largeNumWithNSetAndMUnsetBits ( n , m ) )\n", "python_code_tokenized": "def toggleLastMBits ( n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def largeNumWithNSetAndMUnsetBits ( n , m ) : NEW_LINE INDENT num = ( 1 << ( n + m ) ) - 1 NEW_LINE return toggleLastMBits ( num , m ) NEW_LINE DEDENT n = 2 NEW_LINE m = 2 NEW_LINE print ( largeNumWithNSetAndMUnsetBits ( n , m ) ) NEW_LINE"}
{"id": "geeksforgeeks_2238_A", "sol": 0, "python_code": "def get_maximum ( s , a ) :\n    s = list ( s )\n    n = len ( s )\n    for i in range ( n ) :\n        if ( ord ( s [ i ] ) - ord ( '0' ) < a [ ord ( s [ i ] ) - ord ( '0' ) ] ) :\n            j = i\n            while ( j < n and ( ord ( s [ j ] ) - ord ( '0' ) <= a [ ord ( s [ j ] ) - ord ( '0' ) ] ) ) :\n                s [ j ] = chr ( ord ( '0' ) + a [ ord ( s [ j ] ) - ord ( '0' ) ] )\n                j += 1\n            return \"\".join ( s ) ;\n    return s\nif __name__ == \"__main__\" :\n    s = \"1337\"\n    a = [ 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 ]\n    print ( get_maximum ( s , a ) )\n", "python_code_tokenized": "def get_maximum ( s , a ) : NEW_LINE INDENT s = list ( s ) NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) < a [ ord ( s [ i ] ) - ord ( '0' ) ] ) : NEW_LINE INDENT j = i NEW_LINE while ( j < n and ( ord ( s [ j ] ) - ord ( '0' ) <= a [ ord ( s [ j ] ) - ord ( '0' ) ] ) ) : NEW_LINE INDENT s [ j ] = chr ( ord ( '0' ) + a [ ord ( s [ j ] ) - ord ( '0' ) ] ) NEW_LINE j += 1 NEW_LINE DEDENT return \" \" . join ( s ) ; NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"1337\" NEW_LINE a = [ 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 ] NEW_LINE print ( get_maximum ( s , a ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4506_A", "sol": 0, "python_code": "def addOne ( x ) :\n    return ( - ( ~ x ) ) ;\nprint ( addOne ( 13 ) )\n", "python_code_tokenized": "def addOne ( x ) : NEW_LINE INDENT return ( - ( ~ x ) ) ; NEW_LINE DEDENT print ( addOne ( 13 ) ) NEW_LINE"}
{"id": "geeksforgeeks_3162_A", "sol": 0, "python_code": "def sum ( arr , n ) :\n    i = n\n    if ( arr [ i ] < 9 ) :\n        arr [ i ] = arr [ i ] + 1\n        return\n    arr [ i ] = 0\n    i -= 1\n    sum ( arr , i )\n    if ( arr [ 0 ] > 0 ) :\n        print ( arr [ 0 ] , \", \" , end = \"\" )\n    for i in range ( 1 , n + 1 ) :\n        print ( arr [ i ] , end = \"\" )\n        if ( i < n ) :\n            print ( \", \" , end = \"\" )\nn = 4\narr = [ 0 , 1 , 9 , 3 , 9 ]\nsum ( arr , n )\n", "python_code_tokenized": "def sum ( arr , n ) : NEW_LINE INDENT i = n NEW_LINE if ( arr [ i ] < 9 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] + 1 NEW_LINE return NEW_LINE DEDENT arr [ i ] = 0 NEW_LINE i -= 1 NEW_LINE sum ( arr , i ) NEW_LINE if ( arr [ 0 ] > 0 ) : NEW_LINE INDENT print ( arr [ 0 ] , \" , \u2581 \" , end = \" \" ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \" ) NEW_LINE if ( i < n ) : NEW_LINE INDENT print ( \" , \u2581 \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT n = 4 NEW_LINE arr = [ 0 , 1 , 9 , 3 , 9 ] NEW_LINE sum ( arr , n ) NEW_LINE"}
{"id": "aizu_p00705_A", "sol": 0, "python_code": "from collections import defaultdict\ndef main ( n , m ) :\n    d = defaultdict ( int )\n    for _ in range ( n ) :\n        M = list ( map ( int , input ( ).split ( ) ) )\n        for num , i in enumerate ( M ) :\n            if num == 0 : continue\n            d [ i ] += 1\n    ans = 10 ** 20\n    for key , value in d.items ( ) :\n        if value > m :\n            ans = key\n            m = value\n        elif value == m :\n            ans = min ( ans , key )\n    if ans == 10 ** 20 :\n        ans = 0\n    print ( ans )\nwhile 1 :\n    n , m = map ( int , input ( ).split ( ) )\n    if n == m == 0 :\n        break\n    main ( n , m )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE def main ( n , m ) : NEW_LINE INDENT d = defaultdict ( int ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT M = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for num , i in enumerate ( M ) : NEW_LINE INDENT if num == 0 : continue NEW_LINE d [ i ] += 1 NEW_LINE DEDENT DEDENT ans = 10 ** 20 NEW_LINE for key , value in d . items ( ) : NEW_LINE INDENT if value > m : NEW_LINE INDENT ans = key NEW_LINE m = value NEW_LINE DEDENT elif value == m : NEW_LINE INDENT ans = min ( ans , key ) NEW_LINE DEDENT DEDENT if ans == 10 ** 20 : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT while 1 : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT main ( n , m ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3404_A", "sol": 0, "python_code": "def isToOneRec ( n : int , s : set ) -> bool :\n    if n == 1 :\n        return True\n    if n in s :\n        return False\n    if n % 2 :\n        return isToOneRec ( 3 * n + 1 , s )\n    else :\n        return isToOneRec ( n // 2 , s )\ndef isToOne ( n : int ) -> bool :\n    s = set ( )\n    return isToOneRec ( n , s )\nif __name__ == \"__main__\" :\n    n = 5\n    if isToOne ( n ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def isToOneRec ( n : int , s : set ) -> bool : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if n in s : NEW_LINE INDENT return False NEW_LINE DEDENT if n % 2 : NEW_LINE INDENT return isToOneRec ( 3 * n + 1 , s ) NEW_LINE DEDENT else : NEW_LINE INDENT return isToOneRec ( n // 2 , s ) NEW_LINE DEDENT DEDENT def isToOne ( n : int ) -> bool : NEW_LINE INDENT s = set ( ) NEW_LINE return isToOneRec ( n , s ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE if isToOne ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1282_A", "sol": 0, "python_code": "class GFG :\n    class Node :\n        def __init__ ( self , n , data ) :\n            self.children = [ None ] * n\n            self.data = data\n    def inorder ( self , node ) :\n        if node == None :\n            return\n        total = len ( node.children )\n        for i in range ( total - 1 ) :\n            self.inorder ( node.children [ i ] )\n        print ( node.data , end = \" \" )\n        self.inorder ( node.children [ total - 1 ] )\n    def main ( self ) :\n        n = 3\n        root = self.Node ( n , 1 )\n        root.children [ 0 ] = self.Node ( n , 2 )\n        root.children [ 1 ] = self.Node ( n , 3 )\n        root.children [ 2 ] = self.Node ( n , 4 )\n        root.children [ 0 ].children [ 0 ] = self.Node ( n , 5 )\n        root.children [ 0 ].children [ 1 ] = self.Node ( n , 6 )\n        root.children [ 0 ].children [ 2 ] = self.Node ( n , 7 )\n        self.inorder ( root )\nob = GFG ( )\nob.main ( )\n", "python_code_tokenized": "class GFG : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self , n , data ) : NEW_LINE INDENT self . children = [ None ] * n NEW_LINE self . data = data NEW_LINE DEDENT DEDENT def inorder ( self , node ) : NEW_LINE INDENT if node == None : NEW_LINE INDENT return NEW_LINE DEDENT total = len ( node . children ) NEW_LINE for i in range ( total - 1 ) : NEW_LINE INDENT self . inorder ( node . children [ i ] ) NEW_LINE DEDENT print ( node . data , end = \" \u2581 \" ) NEW_LINE self . inorder ( node . children [ total - 1 ] ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n = 3 NEW_LINE root = self . Node ( n , 1 ) NEW_LINE root . children [ 0 ] = self . Node ( n , 2 ) NEW_LINE root . children [ 1 ] = self . Node ( n , 3 ) NEW_LINE root . children [ 2 ] = self . Node ( n , 4 ) NEW_LINE root . children [ 0 ] . children [ 0 ] = self . Node ( n , 5 ) NEW_LINE root . children [ 0 ] . children [ 1 ] = self . Node ( n , 6 ) NEW_LINE root . children [ 0 ] . children [ 2 ] = self . Node ( n , 7 ) NEW_LINE self . inorder ( root ) NEW_LINE DEDENT DEDENT ob = GFG ( ) NEW_LINE ob . main ( ) NEW_LINE"}
{"id": "geeksforgeeks_3578_A", "sol": 0, "python_code": "class node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.next = None\ndef add ( data ) :\n    newnode = node ( 0 )\n    newnode.data = data\n    newnode.next = None\n    return newnode\ndef printArr ( a , n ) :\n    i = 0\n    while ( i < n ) :\n        print ( a [ i ] , end = \" \" )\n        i = i + 1\ndef findlength ( head ) :\n    curr = head\n    cnt = 0\n    while ( curr != None ) :\n        cnt = cnt + 1\n        curr = curr.next\n    return cnt\ndef convertArr ( head ) :\n    len1 = findlength ( head )\n    arr = [ ]\n    index = 0\n    curr = head\n    while ( curr != None ) :\n        arr.append ( curr.data )\n        curr = curr.next\n    printArr ( arr , len1 )\nhead = node ( 0 )\nhead = add ( 1 )\nhead.next = add ( 2 )\nhead.next.next = add ( 3 )\nhead.next.next.next = add ( 4 )\nhead.next.next.next.next = add ( 5 )\nconvertArr ( head )\n", "python_code_tokenized": "class node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def add ( data ) : NEW_LINE INDENT newnode = node ( 0 ) NEW_LINE newnode . data = data NEW_LINE newnode . next = None NEW_LINE return newnode NEW_LINE DEDENT def printArr ( a , n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT def findlength ( head ) : NEW_LINE INDENT curr = head NEW_LINE cnt = 0 NEW_LINE while ( curr != None ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE curr = curr . next NEW_LINE DEDENT return cnt NEW_LINE DEDENT def convertArr ( head ) : NEW_LINE INDENT len1 = findlength ( head ) NEW_LINE arr = [ ] NEW_LINE index = 0 NEW_LINE curr = head NEW_LINE while ( curr != None ) : NEW_LINE INDENT arr . append ( curr . data ) NEW_LINE curr = curr . next NEW_LINE DEDENT printArr ( arr , len1 ) NEW_LINE DEDENT head = node ( 0 ) NEW_LINE head = add ( 1 ) NEW_LINE head . next = add ( 2 ) NEW_LINE head . next . next = add ( 3 ) NEW_LINE head . next . next . next = add ( 4 ) NEW_LINE head . next . next . next . next = add ( 5 ) NEW_LINE convertArr ( head ) NEW_LINE"}
{"id": "geeksforgeeks_1751_A", "sol": 0, "python_code": "def countUnmarked ( N ) :\n    if ( N % 2 == 0 ) :\n        return N / 2 ;\n    else :\n        return N / 2 + 1 ;\nN = 4 ;\nprint ( \"Number of unmarked elements:\" , int ( countUnmarked ( N ) ) ) ;\n", "python_code_tokenized": "def countUnmarked ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return N / 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return N / 2 + 1 ; NEW_LINE DEDENT DEDENT N = 4 ; NEW_LINE print ( \" Number \u2581 of \u2581 unmarked \u2581 elements : \" , int ( countUnmarked ( N ) ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_2782_A", "sol": 0, "python_code": "MAX = 256\ndef compare ( arr1 , arr2 ) :\n    for i in range ( MAX ) :\n        if arr1 [ i ] != arr2 [ i ] :\n            return False\n    return True\ndef search ( pat , txt ) :\n    M = len ( pat )\n    N = len ( txt )\n    countP = [ 0 ] * MAX\n    countTW = [ 0 ] * MAX\n    for i in range ( M ) :\n        ( countP [ ord ( pat [ i ] ) ] ) += 1\n        ( countTW [ ord ( txt [ i ] ) ] ) += 1\n    for i in range ( M , N ) :\n        if compare ( countP , countTW ) :\n            print ( \"Found at Index\" , ( i - M ) )\n        ( countTW [ ord ( txt [ i ] ) ] ) += 1\n        ( countTW [ ord ( txt [ i - M ] ) ] ) -= 1\n    if compare ( countP , countTW ) :\n        print ( \"Found at Index\" , N - M )\ntxt = \"BACDGABCDA\"\npat = \"ABCD\"\nsearch ( pat , txt )\n", "python_code_tokenized": "MAX = 256 NEW_LINE def compare ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT if arr1 [ i ] != arr2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE countP = [ 0 ] * MAX NEW_LINE countTW = [ 0 ] * MAX NEW_LINE for i in range ( M ) : NEW_LINE INDENT ( countP [ ord ( pat [ i ] ) ] ) += 1 NEW_LINE ( countTW [ ord ( txt [ i ] ) ] ) += 1 NEW_LINE DEDENT for i in range ( M , N ) : NEW_LINE INDENT if compare ( countP , countTW ) : NEW_LINE INDENT print ( \" Found \u2581 at \u2581 Index \" , ( i - M ) ) NEW_LINE DEDENT ( countTW [ ord ( txt [ i ] ) ] ) += 1 NEW_LINE ( countTW [ ord ( txt [ i - M ] ) ] ) -= 1 NEW_LINE DEDENT if compare ( countP , countTW ) : NEW_LINE INDENT print ( \" Found \u2581 at \u2581 Index \" , N - M ) NEW_LINE DEDENT DEDENT txt = \" BACDGABCDA \" NEW_LINE pat = \" ABCD \" NEW_LINE search ( pat , txt ) NEW_LINE"}
{"id": "codeforces_660_A", "sol": 0, "python_code": "def solution ( ) :\n    def checkDivisor ( a , b ) :\n        min_ = min ( a , b )\n        max_ = max ( a , b )\n        if min_ == 1 :\n            return True\n        if max_ % min_ == 0 :\n            return False\n        temp_min = min_\n        temp_max = max_\n        while temp_min != 0 :\n            temp = temp_min\n            temp_min = temp_max % temp_min\n            temp_max = temp\n        if temp_max != 1 :\n            return False\n        return True\n    n = int ( input ( ) )\n    arr = [ int ( i ) for i in map ( int , input ( ).split ( ) ) ]\n    mistakes = [ ]\n    for i in range ( len ( arr ) - 1 ) :\n        if not checkDivisor ( arr [ i ] , arr [ i + 1 ] ) :\n            mistakes.append ( i )\n    print ( len ( mistakes ) )\n    flag = 1\n    for i in range ( len ( mistakes ) ) :\n        arr.insert ( mistakes [ i ] + flag , 1 )\n        flag += 1\n    for i in range ( len ( arr ) ) :\n        print ( arr [ i ] , end = ' ' )\nsolution ( )\n", "python_code_tokenized": "def solution ( ) : NEW_LINE INDENT def checkDivisor ( a , b ) : NEW_LINE INDENT min_ = min ( a , b ) NEW_LINE max_ = max ( a , b ) NEW_LINE if min_ == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if max_ % min_ == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT temp_min = min_ NEW_LINE temp_max = max_ NEW_LINE while temp_min != 0 : NEW_LINE INDENT temp = temp_min NEW_LINE temp_min = temp_max % temp_min NEW_LINE temp_max = temp NEW_LINE DEDENT if temp_max != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE arr = [ int ( i ) for i in map ( int , input ( ) . split ( ) ) ] NEW_LINE mistakes = [ ] NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT if not checkDivisor ( arr [ i ] , arr [ i + 1 ] ) : NEW_LINE INDENT mistakes . append ( i ) NEW_LINE DEDENT DEDENT print ( len ( mistakes ) ) NEW_LINE flag = 1 NEW_LINE for i in range ( len ( mistakes ) ) : NEW_LINE INDENT arr . insert ( mistakes [ i ] + flag , 1 ) NEW_LINE flag += 1 NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] , end = ' \u2581 ' ) NEW_LINE DEDENT DEDENT solution ( ) NEW_LINE"}
{"id": "geeksforgeeks_2220_A", "sol": 0, "python_code": "import math\ndef Parts ( Arr , N ) :\n    factor = Arr [ 1 ] - Arr [ 0 ]\n    for i in range ( 2 , N ) :\n        factor = math.gcd ( factor , Arr [ i ] - Arr [ i - 1 ] )\n    factor = math.gcd ( factor , 360 - Arr [ N - 1 ] + Arr [ 0 ] )\n    cuts = ( 360 // factor ) - N\n    return cuts\nif __name__ == \"__main__\" :\n    Arr = [ 0 , 1 ]\n    N = len ( Arr )\n    print ( Parts ( Arr , N ) )\n", "python_code_tokenized": "import math NEW_LINE def Parts ( Arr , N ) : NEW_LINE INDENT factor = Arr [ 1 ] - Arr [ 0 ] NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT factor = math . gcd ( factor , Arr [ i ] - Arr [ i - 1 ] ) NEW_LINE DEDENT factor = math . gcd ( factor , 360 - Arr [ N - 1 ] + Arr [ 0 ] ) NEW_LINE cuts = ( 360 // factor ) - N NEW_LINE return cuts NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Arr = [ 0 , 1 ] NEW_LINE N = len ( Arr ) NEW_LINE print ( Parts ( Arr , N ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1003_A", "sol": 0, "python_code": "coins = int ( input ( ) )\narray = list ( map ( int , input ( ).split ( ) ) )\ncounter = 1\nmaxPockets = 1\nfor i in array :\n    if array.count ( i ) == 1 :\n        continue\n    else :\n        counter = array.count ( i )\n        if counter >= maxPockets :\n            maxPockets = counter\nprint ( maxPockets )\n", "python_code_tokenized": "coins = int ( input ( ) ) NEW_LINE array = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE counter = 1 NEW_LINE maxPockets = 1 NEW_LINE for i in array : NEW_LINE INDENT if array . count ( i ) == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT counter = array . count ( i ) NEW_LINE if counter >= maxPockets : NEW_LINE INDENT maxPockets = counter NEW_LINE DEDENT DEDENT DEDENT print ( maxPockets ) NEW_LINE"}
{"id": "codeforces_1293_A", "sol": 0, "python_code": "def solve ( ) :\n    n , s , k = map ( int , input ( ).split ( ) )\n    a = list ( map ( int , input ( ).split ( ) ) )\n    for i in range ( 0 , k + 1 ) :\n        if s - i >= 1 and not s - i in a :\n            print ( i ) ;\n            break\n        if s + i <= n and not s + i in a :\n            print ( i ) ;\n            break\n    else :\n        assert False\nfor _ in range ( int ( input ( ) ) ) :\n    solve ( )\n", "python_code_tokenized": "def solve ( ) : NEW_LINE INDENT n , s , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 0 , k + 1 ) : NEW_LINE INDENT if s - i >= 1 and not s - i in a : NEW_LINE INDENT print ( i ) ; NEW_LINE break NEW_LINE DEDENT if s + i <= n and not s + i in a : NEW_LINE INDENT print ( i ) ; NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT assert False NEW_LINE DEDENT DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"}
{"id": "codeforces_323_A", "sol": 0, "python_code": "k = int ( input ( ) )\nif k % 2 == 1 :\n    print ( - 1 )\nelse :\n    for i in range ( k ) :\n        for j in range ( k ) :\n            a = ''\n            for l in range ( k ) :\n                a += 'bw' [ ( i // 2 + j + l // 2 ) % 2 ]\n            print ( a )\n        if i < k - 1 :\n            print ( )\n", "python_code_tokenized": "k = int ( input ( ) ) NEW_LINE if k % 2 == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT a = ' ' NEW_LINE for l in range ( k ) : NEW_LINE INDENT a += ' bw ' [ ( i // 2 + j + l // 2 ) % 2 ] NEW_LINE DEDENT print ( a ) NEW_LINE DEDENT if i < k - 1 : NEW_LINE INDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "atcoder_ABC096_C", "sol": 0, "python_code": "h , w = map ( int , input ( ).split ( ) )\nt = [ list ( input ( ) ) for i in range ( h ) ]\ndef check ( x , y ) :\n    dx = [ 0 , 0 , 1 , - 1 ]\n    dy = [ 1 , - 1 , 0 , 0 ]\n    jugde = False\n    for k in range ( 4 ) :\n        i = x + dx [ k ]\n        j = y + dy [ k ]\n        if 0 <= i and i < h and 0 <= j and j < w and t [ i ] [ j ] == \"#\" :\n            jugde = True\n    if jugde == False :\n        return False\n    return True\nfor i in range ( h ) :\n    for j in range ( w ) :\n        if t [ i ] [ j ] == \"#\" :\n            if check ( i , j ) :\n                jugde = True\n            else :\n                print ( \"No\" )\n                exit ( )\nprint ( \"Yes\" )\n", "python_code_tokenized": "h , w = map ( int , input ( ) . split ( ) ) NEW_LINE t = [ list ( input ( ) ) for i in range ( h ) ] NEW_LINE def check ( x , y ) : NEW_LINE INDENT dx = [ 0 , 0 , 1 , - 1 ] NEW_LINE dy = [ 1 , - 1 , 0 , 0 ] NEW_LINE jugde = False NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT i = x + dx [ k ] NEW_LINE j = y + dy [ k ] NEW_LINE if 0 <= i and i < h and 0 <= j and j < w and t [ i ] [ j ] == \" # \" : NEW_LINE INDENT jugde = True NEW_LINE DEDENT DEDENT if jugde == False : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if t [ i ] [ j ] == \" # \" : NEW_LINE INDENT if check ( i , j ) : NEW_LINE INDENT jugde = True NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( \" Yes \" ) NEW_LINE"}
{"id": "geeksforgeeks_2617_A", "sol": 0, "python_code": "def printMaxValPair ( v , n ) :\n    v.sort ( )\n    N = v [ n - 1 ]\n    if N % 2 == 1 :\n        first_maxima = N // 2\n        second_maxima = first_maxima + 1\n        ans1 , ans2 = 3 * ( 10 ** 18 ) , 3 * ( 10 ** 18 )\n        from_left , from_right = - 1 , - 1\n        _from = - 1\n        for i in range ( 0 , n ) :\n            if v [ i ] > first_maxima :\n                _from = i\n                break\n            else :\n                diff = first_maxima - v [ i ]\n                if diff < ans1 :\n                    ans1 = diff\n                    from_left = v [ i ]\n        from_right = v [ _from ]\n        diff1 = first_maxima - from_left\n        diff2 = from_right - second_maxima\n        if diff1 < diff2 :\n            print ( N , from_left )\n        else :\n            print ( N , from_right )\n    else :\n        maxima = N // 2\n        ans1 = 3 * ( 10 ** 18 )\n        R = - 1\n        for i in range ( 0 , n - 1 ) :\n            diff = abs ( v [ i ] - maxima )\n            if diff < ans1 :\n                ans1 = diff\n                R = v [ i ]\n        print ( N , R )\nif __name__ == \"__main__\" :\n    v = [ 1 , 1 , 2 , 3 , 6 , 1 ]\n    n = len ( v )\n    printMaxValPair ( v , n )\n", "python_code_tokenized": "def printMaxValPair ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE N = v [ n - 1 ] NEW_LINE if N % 2 == 1 : NEW_LINE INDENT first_maxima = N // 2 NEW_LINE second_maxima = first_maxima + 1 NEW_LINE ans1 , ans2 = 3 * ( 10 ** 18 ) , 3 * ( 10 ** 18 ) NEW_LINE from_left , from_right = - 1 , - 1 NEW_LINE _from = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if v [ i ] > first_maxima : NEW_LINE INDENT _from = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT diff = first_maxima - v [ i ] NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE from_left = v [ i ] NEW_LINE DEDENT DEDENT DEDENT from_right = v [ _from ] NEW_LINE diff1 = first_maxima - from_left NEW_LINE diff2 = from_right - second_maxima NEW_LINE if diff1 < diff2 : NEW_LINE INDENT print ( N , from_left ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , from_right ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxima = N // 2 NEW_LINE ans1 = 3 * ( 10 ** 18 ) NEW_LINE R = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT diff = abs ( v [ i ] - maxima ) NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE R = v [ i ] NEW_LINE DEDENT DEDENT print ( N , R ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT v = [ 1 , 1 , 2 , 3 , 6 , 1 ] NEW_LINE n = len ( v ) NEW_LINE printMaxValPair ( v , n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5165_A", "sol": 0, "python_code": "def powerSet ( str1 , index , curr ) :\n    n = len ( str1 )\n    if ( index == n ) :\n        return\n    print ( curr )\n    for i in range ( index + 1 , n ) :\n        curr += str1 [ i ]\n        powerSet ( str1 , i , curr )\n        curr = curr.replace ( curr [ len ( curr ) - 1 ] , \"\" )\n    return\nif __name__ == '__main__' :\n    str = \"abc\" ;\n    powerSet ( str , - 1 , \"\" )\n", "python_code_tokenized": "def powerSet ( str1 , index , curr ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( index == n ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( curr ) NEW_LINE for i in range ( index + 1 , n ) : NEW_LINE INDENT curr += str1 [ i ] NEW_LINE powerSet ( str1 , i , curr ) NEW_LINE curr = curr . replace ( curr [ len ( curr ) - 1 ] , \" \" ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" abc \" ; NEW_LINE powerSet ( str , - 1 , \" \" ) NEW_LINE DEDENT"}
{"id": "aizu_p00011_A", "sol": 0, "python_code": "w = int ( input ( ) )\nn = int ( input ( ) )\na = list ( range ( w ) )\nfor i in range ( n ) :\n    k1 , k2 = map ( int , input ( ).split ( \",\" ) )\n    a [ k1 - 1 ] , a [ k2 - 1 ] = a [ k2 - 1 ] , a [ k1 - 1 ]\nfor i in a :\n    print ( i + 1 )\n", "python_code_tokenized": "w = int ( input ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( range ( w ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT k1 , k2 = map ( int , input ( ) . split ( \" , \" ) ) NEW_LINE a [ k1 - 1 ] , a [ k2 - 1 ] = a [ k2 - 1 ] , a [ k1 - 1 ] NEW_LINE DEDENT for i in a : NEW_LINE INDENT print ( i + 1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3873_A", "sol": 0, "python_code": "def updateArray ( arr , n ) :\n    i = n - 1\n    while ( i > 0 ) :\n        arr [ i ] = arr [ i - 1 ]\n        i -= 1\n    arr [ 0 ] = - 1\n    for i in range ( 0 , n , 1 ) :\n        print ( arr [ i ] , end = \" \" )\nif __name__ == '__main__' :\n    arr = [ 5 , 1 , 3 , 2 , 4 ]\n    N = len ( arr )\n    updateArray ( arr , N )\n", "python_code_tokenized": "def updateArray ( arr , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ 0 ] = - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3878_A", "sol": 0, "python_code": "def findEncryptedArray ( arr , n ) :\n    sum = 0\n    for i in range ( n ) :\n        sum += arr [ i ]\n    for i in range ( n ) :\n        print ( sum - arr [ i ] , end = \" \" )\nif __name__ == \"__main__\" :\n    arr = [ 5 , 1 , 3 , 2 , 4 ]\n    N = len ( arr )\n    findEncryptedArray ( arr , N )\n", "python_code_tokenized": "def findEncryptedArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( sum - arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE findEncryptedArray ( arr , N ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3874_A", "sol": 0, "python_code": "def updateArray ( arr , n ) :\n    for i in range ( n - 1 ) :\n        arr [ i ] = arr [ i + 1 ]\n    arr [ n - 1 ] = - 1\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" )\nif __name__ == \"__main__\" :\n    arr = [ 5 , 1 , 3 , 2 , 4 ]\n    N = len ( arr )\n    updateArray ( arr , N )\n", "python_code_tokenized": "def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE DEDENT"}
{"id": "codeforces_1265_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor c in range ( t ) :\n    n = int ( input ( ) )\n    seq = [ int ( n ) for n in input ( ).split ( ) ]\n    posis = [ None ] * ( n + 1 )\n    for u in range ( 0 , n ) :\n        posis [ seq [ u ] ] = u\n    print ( 1 , end = \"\" )\n    l = posis [ 1 ] ;\n    r = posis [ 1 ]\n    for num in range ( 2 , n + 1 ) :\n        if ( posis [ num ] < l ) : l = posis [ num ]\n        if ( posis [ num ] > r ) : r = posis [ num ]\n        print ( 1 if num == r - l + 1 else 0 , end = \"\" )\n    print ( )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for c in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE seq = [ int ( n ) for n in input ( ) . split ( ) ] NEW_LINE posis = [ None ] * ( n + 1 ) NEW_LINE for u in range ( 0 , n ) : NEW_LINE INDENT posis [ seq [ u ] ] = u NEW_LINE DEDENT print ( 1 , end = \" \" ) NEW_LINE l = posis [ 1 ] ; NEW_LINE r = posis [ 1 ] NEW_LINE for num in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( posis [ num ] < l ) : l = posis [ num ] NEW_LINE if ( posis [ num ] > r ) : r = posis [ num ] NEW_LINE print ( 1 if num == r - l + 1 else 0 , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"id": "codeforces_699_A", "sol": 0, "python_code": "n = int ( input ( ) )\ndirection = input ( )\ndistance = [ int ( x ) for x in input ( ).split ( ) ]\ntuples = list ( zip ( direction , distance ) )\nidx , minDist = 0 , 2 ** 31 - 1\nwhile idx + 1 < len ( tuples ) :\n    if tuples [ idx ] [ 0 ] == \"R\" and tuples [ idx + 1 ] [ 0 ] == \"L\" :\n        minDist = min ( minDist , ( tuples [ idx + 1 ] [ 1 ] - tuples [ idx ] [ 1 ] ) // 2 )\n    idx += 1\nif minDist == 2 ** 31 - 1 :\n    print ( - 1 )\nelse :\n    print ( minDist )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE direction = input ( ) NEW_LINE distance = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE tuples = list ( zip ( direction , distance ) ) NEW_LINE idx , minDist = 0 , 2 ** 31 - 1 NEW_LINE while idx + 1 < len ( tuples ) : NEW_LINE INDENT if tuples [ idx ] [ 0 ] == \" R \" and tuples [ idx + 1 ] [ 0 ] == \" L \" : NEW_LINE INDENT minDist = min ( minDist , ( tuples [ idx + 1 ] [ 1 ] - tuples [ idx ] [ 1 ] ) // 2 ) NEW_LINE DEDENT idx += 1 NEW_LINE DEDENT if minDist == 2 ** 31 - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( minDist ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_612_A", "sol": 0, "python_code": "def printTrib ( n ) :\n    if ( n < 1 ) :\n        return\n    first = 0\n    second = 0\n    third = 1\n    print ( first , \"\" , end = \"\" )\n    if ( n > 1 ) :\n        print ( second , \"\" , end = \"\" )\n    if ( n > 2 ) :\n        print ( second , \"\" , end = \"\" )\n    for i in range ( 3 , n ) :\n        curr = first + second + third\n        first = second\n        second = third\n        third = curr\n        print ( curr , \"\" , end = \"\" )\nn = 10\nprintTrib ( n )\n", "python_code_tokenized": "def printTrib ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE third = 1 NEW_LINE print ( first , \" \u2581 \" , end = \" \" ) NEW_LINE if ( n > 1 ) : NEW_LINE INDENT print ( second , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( second , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT curr = first + second + third NEW_LINE first = second NEW_LINE second = third NEW_LINE third = curr NEW_LINE print ( curr , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE"}
{"id": "geeksforgeeks_2382_A", "sol": 0, "python_code": "import math\ndef nthElement ( a , b , n ) :\n    lcm = ( a * b ) / int ( math.gcd ( a , b ) )\n    l = 1\n    r = min ( a , b ) * n\n    while ( l <= r ) :\n        mid = ( l + r ) >> 1\n        val = ( int ( mid / a ) + int ( mid / b ) - int ( mid / lcm ) )\n        if ( val == n ) :\n            return int ( max ( int ( mid / a ) * a , int ( mid / b ) * b ) )\n        if ( val < n ) :\n            l = mid + 1\n        else :\n            r = mid - 1\na = 5\nb = 3\nn = 5\nprint ( nthElement ( a , b , n ) )\n", "python_code_tokenized": "import math NEW_LINE def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) / int ( math . gcd ( a , b ) ) NEW_LINE l = 1 NEW_LINE r = min ( a , b ) * n NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE val = ( int ( mid / a ) + int ( mid / b ) - int ( mid / lcm ) ) NEW_LINE if ( val == n ) : NEW_LINE INDENT return int ( max ( int ( mid / a ) * a , int ( mid / b ) * b ) ) NEW_LINE DEDENT if ( val < n ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT DEDENT a = 5 NEW_LINE b = 3 NEW_LINE n = 5 NEW_LINE print ( nthElement ( a , b , n ) ) NEW_LINE"}
{"id": "codeforces_869_A", "sol": 0, "python_code": "import math\nimport sys\nfrom collections import deque , OrderedDict , defaultdict\nimport heapq , re\nfrom collections import Counter\ndef inp ( ) : return sys.stdin.readline ( ).rstrip ( )\ndef mpp ( ) : return map ( int , inp ( ).split ( ) )\ndef lis ( ) : return list ( mpp ( ) )\ndef yn ( n ) :\n    if n :\n        return \"YES\"\n    else :\n        return \"NO\"\ndef cd ( s ) :\n    return ord ( s ) - ord ( 'a' ) + 1\ndef fn ( arr , brr , n ) :\n    cn = 0\n    s = set ( arr + brr )\n    for i in range ( n ) :\n        for j in range ( n ) :\n            if arr [ i ] ^ brr [ j ] in s :\n                cn += 1\n    if cn & 1 : return \"Koyomi\"\n    return \"Karen\"\ndef main ( ) :\n    n = int ( inp ( ) )\n    arr = lis ( )\n    brr = lis ( )\n    print ( fn ( arr , brr , n ) )\nif __name__ == \"__main__\" :\n    main ( )\n", "python_code_tokenized": "import math NEW_LINE import sys NEW_LINE from collections import deque , OrderedDict , defaultdict NEW_LINE import heapq , re NEW_LINE from collections import Counter NEW_LINE def inp ( ) : return sys . stdin . readline ( ) . rstrip ( ) NEW_LINE def mpp ( ) : return map ( int , inp ( ) . split ( ) ) NEW_LINE def lis ( ) : return list ( mpp ( ) ) NEW_LINE def yn ( n ) : NEW_LINE INDENT if n : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT def cd ( s ) : NEW_LINE INDENT return ord ( s ) - ord ( ' a ' ) + 1 NEW_LINE DEDENT def fn ( arr , brr , n ) : NEW_LINE INDENT cn = 0 NEW_LINE s = set ( arr + brr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if arr [ i ] ^ brr [ j ] in s : NEW_LINE INDENT cn += 1 NEW_LINE DEDENT DEDENT DEDENT if cn & 1 : return \" Koyomi \" NEW_LINE return \" Karen \" NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( inp ( ) ) NEW_LINE arr = lis ( ) NEW_LINE brr = lis ( ) NEW_LINE print ( fn ( arr , brr , n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_504_A", "sol": 0, "python_code": "import math\ndef findNumber ( n ) :\n    x = int ( math.floor ( ( - 1 + math.sqrt ( 1 + 8 * n - 8 ) ) / 2 ) )\n    base = ( x * ( x + 1 ) ) / 2 + 1\n    return n - base + 1\nn = 55\nprint ( findNumber ( n ) )\n", "python_code_tokenized": "import math NEW_LINE def findNumber ( n ) : NEW_LINE INDENT x = int ( math . floor ( ( - 1 + math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ) NEW_LINE base = ( x * ( x + 1 ) ) / 2 + 1 NEW_LINE return n - base + 1 NEW_LINE DEDENT n = 55 NEW_LINE print ( findNumber ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2698_A", "sol": 0, "python_code": "def result ( s , n ) :\n    st = set ( ) ;\n    for i in range ( len ( s ) ) :\n        ans = \"\" ;\n        for j in range ( i , len ( s ) ) :\n            ans += s [ j ] ;\n            if ( len ( ans ) == n ) :\n                st.add ( ans ) ;\n                break ;\n    for it in st :\n        print ( it , end = \" \" ) ;\nif __name__ == \"__main__\" :\n    s = \"abca\" ;\n    n = 3 ;\n    result ( s , n ) ;\n", "python_code_tokenized": "def result ( s , n ) : NEW_LINE INDENT st = set ( ) ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ans = \" \" ; NEW_LINE for j in range ( i , len ( s ) ) : NEW_LINE INDENT ans += s [ j ] ; NEW_LINE if ( len ( ans ) == n ) : NEW_LINE INDENT st . add ( ans ) ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT for it in st : NEW_LINE INDENT print ( it , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abca \" ; NEW_LINE n = 3 ; NEW_LINE result ( s , n ) ; NEW_LINE DEDENT"}
{"id": "codeforces_554_A", "sol": 0, "python_code": "st = input ( )\nans = ( len ( st ) + 1 ) * 25\nprint ( ans + 1 )\n", "python_code_tokenized": "st = input ( ) NEW_LINE ans = ( len ( st ) + 1 ) * 25 NEW_LINE print ( ans + 1 ) NEW_LINE"}
{"id": "codeforces_995_B", "sol": 0, "python_code": "input ( )\na = input ( ).split ( )\ncount = 0\nwhile len ( a ) > 0 :\n    k = a [ 1 : ].index ( a [ 0 ] ) + 1\n    count += k - 1\n    a = a [ 1 : k ] + a [ k + 1 : ]\nprint ( count )\n", "python_code_tokenized": "input ( ) NEW_LINE a = input ( ) . split ( ) NEW_LINE count = 0 NEW_LINE while len ( a ) > 0 : NEW_LINE INDENT k = a [ 1 : ] . index ( a [ 0 ] ) + 1 NEW_LINE count += k - 1 NEW_LINE a = a [ 1 : k ] + a [ k + 1 : ] NEW_LINE DEDENT print ( count ) NEW_LINE"}
{"id": "geeksforgeeks_4020_A", "sol": 0, "python_code": "from math import floor\ndef solve ( n , base ) :\n    sum = 0\n    while ( n > 0 ) :\n        remainder = n % base\n        sum = sum + remainder\n        n = int ( n / base )\n    return sum\ndef SumsOfDigits ( n ) :\n    sum = 0\n    N = floor ( n / 2 )\n    for base in range ( 2 , N + 1 , 1 ) :\n        sum = sum + solve ( n , base )\n    print ( sum )\nif __name__ == '__main__' :\n    n = 8\n    SumsOfDigits ( n )\n", "python_code_tokenized": "from math import floor NEW_LINE def solve ( n , base ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT remainder = n % base NEW_LINE sum = sum + remainder NEW_LINE n = int ( n / base ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def SumsOfDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE N = floor ( n / 2 ) NEW_LINE for base in range ( 2 , N + 1 , 1 ) : NEW_LINE INDENT sum = sum + solve ( n , base ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE SumsOfDigits ( n ) NEW_LINE DEDENT"}
{"id": "aizu_p00437_A", "sol": 0, "python_code": "import heapq\nfrom collections import deque\nfrom enum import Enum\nimport sys\nimport math\nfrom _heapq import heappush , heappop\nimport copy\nfrom test.support import _MemoryWatchdog\nBIG_NUM = 2000000000\nHUGE_NUM = 99999999999999999\nMOD = 1000000007\nEPS = 0.000000001\nsys.setrecursionlimit ( 100000 )\nclass Type ( Enum ) :\n    UNKOWN = 0\n    OK = 1\n    NOT = 2\nclass Info :\n    def __init__ ( self , arg_a , arg_b , arg_c ) :\n        self.work = [ arg_a , arg_b , arg_c ]\nwhile True :\n    A , B , C = map ( int , input ( ).split ( ) )\n    if A == 0 and B == 0 and C == 0 :\n        break\n    table = [ Type.UNKOWN ] * ( ( A + B + C ) + 1 )\n    N = int ( input ( ) )\n    info = [ ]\n    for _ in range ( N ) :\n        a , b , c , result = map ( int , input ( ).split ( ) )\n        if result == 1 :\n            table [ a ] = Type.OK\n            table [ b ] = Type.OK\n            table [ c ] = Type.OK\n        else :\n            info.append ( Info ( a , b , c ) )\n    for i in range ( len ( info ) ) :\n        count = 0\n        tmp = - 1\n        for k in range ( 3 ) :\n            if table [ info [ i ].work [ k ] ] == Type.OK :\n                count += 1\n            elif table [ info [ i ].work [ k ] ] == Type.UNKOWN :\n                tmp = info [ i ].work [ k ]\n        if count != 2 or tmp == - 1 :\n            continue\n        table [ tmp ] = Type.NOT\n    for i in range ( 1 , ( A + B + C ) + 1 ) :\n        if table [ i ] == Type.OK :\n            print ( \"1\" )\n        elif table [ i ] == Type.NOT :\n            print ( \"0\" )\n        else :\n            print ( \"2\" )\n", "python_code_tokenized": "import heapq NEW_LINE from collections import deque NEW_LINE from enum import Enum NEW_LINE import sys NEW_LINE import math NEW_LINE from _heapq import heappush , heappop NEW_LINE import copy NEW_LINE from test . support import _MemoryWatchdog NEW_LINE BIG_NUM = 2000000000 NEW_LINE HUGE_NUM = 99999999999999999 NEW_LINE MOD = 1000000007 NEW_LINE EPS = 0.000000001 NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE class Type ( Enum ) : NEW_LINE INDENT UNKOWN = 0 NEW_LINE OK = 1 NEW_LINE NOT = 2 NEW_LINE DEDENT class Info : NEW_LINE INDENT def __init__ ( self , arg_a , arg_b , arg_c ) : NEW_LINE INDENT self . work = [ arg_a , arg_b , arg_c ] NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE if A == 0 and B == 0 and C == 0 : NEW_LINE INDENT break NEW_LINE DEDENT table = [ Type . UNKOWN ] * ( ( A + B + C ) + 1 ) NEW_LINE N = int ( input ( ) ) NEW_LINE info = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT a , b , c , result = map ( int , input ( ) . split ( ) ) NEW_LINE if result == 1 : NEW_LINE INDENT table [ a ] = Type . OK NEW_LINE table [ b ] = Type . OK NEW_LINE table [ c ] = Type . OK NEW_LINE DEDENT else : NEW_LINE INDENT info . append ( Info ( a , b , c ) ) NEW_LINE DEDENT DEDENT for i in range ( len ( info ) ) : NEW_LINE INDENT count = 0 NEW_LINE tmp = - 1 NEW_LINE for k in range ( 3 ) : NEW_LINE INDENT if table [ info [ i ] . work [ k ] ] == Type . OK : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif table [ info [ i ] . work [ k ] ] == Type . UNKOWN : NEW_LINE INDENT tmp = info [ i ] . work [ k ] NEW_LINE DEDENT DEDENT if count != 2 or tmp == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT table [ tmp ] = Type . NOT NEW_LINE DEDENT for i in range ( 1 , ( A + B + C ) + 1 ) : NEW_LINE INDENT if table [ i ] == Type . OK : NEW_LINE INDENT print ( \"1\" ) NEW_LINE DEDENT elif table [ i ] == Type . NOT : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"2\" ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "atcoder_AGC037_C", "sol": 0, "python_code": "import heapq\nN = int ( input ( ) )\nA = list ( map ( int , input ( ).split ( ) ) )\nB = input ( ).split ( )\nC = [ ]\nfor i in range ( N ) :\n    heapq.heappush ( C , ( A [ i ] - int ( B [ i ] ) , i ) )\nB = list ( map ( int , B ) )\nans = 0\nwhile True :\n    v , i = heapq.heappop ( C )\n    if v == 0 :\n        break\n    nv = B [ i - 1 ] + B [ ( i + 1 ) % N ]\n    n = - v // nv\n    if n <= 0 :\n        print ( - 1 )\n        exit ( )\n    v += n * nv\n    B [ i ] -= n * nv\n    heapq.heappush ( C , ( v , i ) )\n    ans += n\nprint ( ans )\n", "python_code_tokenized": "import heapq NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = input ( ) . split ( ) NEW_LINE C = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT heapq . heappush ( C , ( A [ i ] - int ( B [ i ] ) , i ) ) NEW_LINE DEDENT B = list ( map ( int , B ) ) NEW_LINE ans = 0 NEW_LINE while True : NEW_LINE INDENT v , i = heapq . heappop ( C ) NEW_LINE if v == 0 : NEW_LINE INDENT break NEW_LINE DEDENT nv = B [ i - 1 ] + B [ ( i + 1 ) % N ] NEW_LINE n = - v // nv NEW_LINE if n <= 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT v += n * nv NEW_LINE B [ i ] -= n * nv NEW_LINE heapq . heappush ( C , ( v , i ) ) NEW_LINE ans += n NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_259_A", "sol": 0, "python_code": "ans = 'YES'\nfor _ in range ( 8 ) :\n    line = input ( )\n    for i in range ( 7 ) :\n        if line [ i ] == line [ i + 1 ] :\n            ans = 'NO'\n            break\nprint ( ans )\n", "python_code_tokenized": "ans = ' YES ' NEW_LINE for _ in range ( 8 ) : NEW_LINE INDENT line = input ( ) NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT if line [ i ] == line [ i + 1 ] : NEW_LINE INDENT ans = ' NO ' NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_1582_A", "sol": 0, "python_code": "def modInverse ( a , m ) :\n    a = a % m ;\n    for x in range ( 1 , m ) :\n        if ( ( a * x ) % m == 1 ) :\n            return x\n    return 1\na = 3\nm = 11\nprint ( modInverse ( a , m ) )\n", "python_code_tokenized": "def modInverse ( a , m ) : NEW_LINE INDENT a = a % m ; NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( modInverse ( a , m ) ) NEW_LINE"}
{"id": "aizu_p00458_A", "sol": 0, "python_code": "import sys\nr = sys.stdin.readline\ndef s ( ) :\n    def b ( M , x , y , n = 1 ) :\n        M [ x ] [ y ] = 0 ; a = n\n        if M [ x - 1 ] [ y ] : a = max ( a , b ( M , x - 1 , y , n + 1 ) )\n        if M [ x ] [ y - 1 ] : a = max ( a , b ( M , x , y - 1 , n + 1 ) )\n        if M [ x + 1 ] [ y ] : a = max ( a , b ( M , x + 1 , y , n + 1 ) )\n        if M [ x ] [ y + 1 ] : a = max ( a , b ( M , x , y + 1 , n + 1 ) )\n        M [ x ] [ y ] = 1\n        return a\n    for e in iter ( r , '0\\n' ) :\n        n , m = int ( e ) , int ( r ( ) )\n        P = [ [ 0 ] * ( n + 2 ) for _ in [ 0 ] * ( m + 2 ) ]\n        for i in range ( m ) : P [ i + 1 ] [ 1 : - 1 ] = map ( int , r ( ).split ( ) )\n        print ( max ( b ( P , i , j ) for i in range ( 1 , m + 1 ) for j in range ( 1 , n + 1 ) if P [ i ] [ j ] ) )\nif '__main__' == __name__ : s ( )\n", "python_code_tokenized": "import sys NEW_LINE r = sys . stdin . readline NEW_LINE def s ( ) : NEW_LINE INDENT def b ( M , x , y , n = 1 ) : NEW_LINE INDENT M [ x ] [ y ] = 0 ; a = n NEW_LINE if M [ x - 1 ] [ y ] : a = max ( a , b ( M , x - 1 , y , n + 1 ) ) NEW_LINE if M [ x ] [ y - 1 ] : a = max ( a , b ( M , x , y - 1 , n + 1 ) ) NEW_LINE if M [ x + 1 ] [ y ] : a = max ( a , b ( M , x + 1 , y , n + 1 ) ) NEW_LINE if M [ x ] [ y + 1 ] : a = max ( a , b ( M , x , y + 1 , n + 1 ) ) NEW_LINE M [ x ] [ y ] = 1 NEW_LINE return a NEW_LINE DEDENT for e in iter ( r , '0 \\n ' ) : NEW_LINE INDENT n , m = int ( e ) , int ( r ( ) ) NEW_LINE P = [ [ 0 ] * ( n + 2 ) for _ in [ 0 ] * ( m + 2 ) ] NEW_LINE for i in range ( m ) : P [ i + 1 ] [ 1 : - 1 ] = map ( int , r ( ) . split ( ) ) NEW_LINE print ( max ( b ( P , i , j ) for i in range ( 1 , m + 1 ) for j in range ( 1 , n + 1 ) if P [ i ] [ j ] ) ) NEW_LINE DEDENT DEDENT if ' _ _ main _ _ ' == __name__ : s ( ) NEW_LINE"}
{"id": "geeksforgeeks_3651_A", "sol": 0, "python_code": "def isPossible ( arr , n , C , mid ) :\n    magnet = 1\n    currPosition = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        if ( arr [ i ] - currPosition >= mid ) :\n            magnet += 1\n            currPosition = arr [ i ]\n            if ( magnet == C ) :\n                return True\n    return False\ndef binarySearch ( n , C , arr ) :\n    arr.sort ( reverse = False )\n    lo = 0\n    hi = arr [ n - 1 ]\n    ans = 0\n    while ( lo <= hi ) :\n        mid = int ( ( lo + hi ) / 2 )\n        if ( isPossible ( arr , n , C , mid ) == False ) :\n            hi = mid - 1\n        else :\n            ans = max ( ans , mid )\n            lo = mid + 1\n    return ans\nif __name__ == '__main__' :\n    C = 4\n    arr = [ 1 , 2 , 5 , 8 , 10 , 18 ]\n    n = len ( arr )\n    print ( binarySearch ( n , C , arr ) )\n", "python_code_tokenized": "def isPossible ( arr , n , C , mid ) : NEW_LINE INDENT magnet = 1 NEW_LINE currPosition = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - currPosition >= mid ) : NEW_LINE INDENT magnet += 1 NEW_LINE currPosition = arr [ i ] NEW_LINE if ( magnet == C ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def binarySearch ( n , C , arr ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE lo = 0 NEW_LINE hi = arr [ n - 1 ] NEW_LINE ans = 0 NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT mid = int ( ( lo + hi ) / 2 ) NEW_LINE if ( isPossible ( arr , n , C , mid ) == False ) : NEW_LINE INDENT hi = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , mid ) NEW_LINE lo = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT C = 4 NEW_LINE arr = [ 1 , 2 , 5 , 8 , 10 , 18 ] NEW_LINE n = len ( arr ) NEW_LINE print ( binarySearch ( n , C , arr ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1371_A", "sol": 0, "python_code": "a = int ( input ( ) )\nfor i in range ( a ) :\n    b = int ( input ( ) )\n    if b % 2 == 0 :\n        print ( b // 2 )\n    else :\n        print ( b // 2 + 1 )\n", "python_code_tokenized": "a = int ( input ( ) ) NEW_LINE for i in range ( a ) : NEW_LINE INDENT b = int ( input ( ) ) NEW_LINE if b % 2 == 0 : NEW_LINE INDENT print ( b // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b // 2 + 1 ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC069_B", "sol": 0, "python_code": "s = input ( )\nprint ( s [ : 1 ] + str ( len ( s ) - 2 ) + s [ - 1 : ] )\n", "python_code_tokenized": "s = input ( ) NEW_LINE print ( s [ : 1 ] + str ( len ( s ) - 2 ) + s [ - 1 : ] ) NEW_LINE"}
{"id": "codeforces_592_A", "sol": 0, "python_code": "s = [ ]\nw = 9\nb = 9\nw1 = [ ]\nb1 = [ ]\ns1 = [ ]\nfor i in range ( 8 ) :\n    s = input ( ).strip ( )\n    s1.append ( s )\n    for j in range ( 8 ) :\n        if \"W\" == s [ j ] and j not in b1 :\n            w = min ( w , i )\n        if \"B\" == s [ j ] :\n            b1.append ( j )\ns1 = s1 [ : : - 1 ]\nfor i in range ( 8 ) :\n    s = s1 [ i ]\n    for j in range ( 8 ) :\n        if \"B\" == s [ j ] and j not in w1 :\n            b = min ( b , i )\n        if \"W\" == s [ j ] :\n            w1.append ( j )\nif w <= b :\n    print ( \"A\" )\nelse :\n    print ( \"B\" )\n", "python_code_tokenized": "s = [ ] NEW_LINE w = 9 NEW_LINE b = 9 NEW_LINE w1 = [ ] NEW_LINE b1 = [ ] NEW_LINE s1 = [ ] NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT s = input ( ) . strip ( ) NEW_LINE s1 . append ( s ) NEW_LINE for j in range ( 8 ) : NEW_LINE INDENT if \" W \" == s [ j ] and j not in b1 : NEW_LINE INDENT w = min ( w , i ) NEW_LINE DEDENT if \" B \" == s [ j ] : NEW_LINE INDENT b1 . append ( j ) NEW_LINE DEDENT DEDENT DEDENT s1 = s1 [ : : - 1 ] NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT s = s1 [ i ] NEW_LINE for j in range ( 8 ) : NEW_LINE INDENT if \" B \" == s [ j ] and j not in w1 : NEW_LINE INDENT b = min ( b , i ) NEW_LINE DEDENT if \" W \" == s [ j ] : NEW_LINE INDENT w1 . append ( j ) NEW_LINE DEDENT DEDENT DEDENT if w <= b : NEW_LINE INDENT print ( \" A \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" B \" ) NEW_LINE DEDENT"}
{"id": "codeforces_306_A", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nq = n // m\nr = n % m\na = [ q ] * m\nfor i in range ( r ) :\n    a [ i ] += 1\nfor i in range ( m ) :\n    print ( a [ i ] , end = ' ' )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE q = n // m NEW_LINE r = n % m NEW_LINE a = [ q ] * m NEW_LINE for i in range ( r ) : NEW_LINE INDENT a [ i ] += 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT print ( a [ i ] , end = ' \u2581 ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2282_A", "sol": 0, "python_code": "from math import ceil , floor\ndef Alcuin ( n ) :\n    _n = n\n    ans = 0\n    ans = ( round ( ( _n * _n ) / 12 ) - floor ( _n / 4 ) * floor ( ( _n + 2 ) / 4 ) )\n    return ans\ndef solve ( n ) :\n    for i in range ( 1 , n + 1 ) :\n        print ( Alcuin ( i ) , end = \", \" )\nn = 15\nsolve ( n )\n", "python_code_tokenized": "from math import ceil , floor NEW_LINE def Alcuin ( n ) : NEW_LINE INDENT _n = n NEW_LINE ans = 0 NEW_LINE ans = ( round ( ( _n * _n ) / 12 ) - floor ( _n / 4 ) * floor ( ( _n + 2 ) / 4 ) ) NEW_LINE return ans NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( Alcuin ( i ) , end = \" , \u2581 \" ) NEW_LINE DEDENT DEDENT n = 15 NEW_LINE solve ( n ) NEW_LINE"}
{"id": "geeksforgeeks_4513_A", "sol": 0, "python_code": "def toggle ( n ) :\n    temp = 1\n    while ( temp <= n ) :\n        n = n ^ temp\n        temp = temp << 1\n    return n\nn = 10\nn = toggle ( n )\nprint ( n )\n", "python_code_tokenized": "def toggle ( n ) : NEW_LINE INDENT temp = 1 NEW_LINE while ( temp <= n ) : NEW_LINE INDENT n = n ^ temp NEW_LINE temp = temp << 1 NEW_LINE DEDENT return n NEW_LINE DEDENT n = 10 NEW_LINE n = toggle ( n ) NEW_LINE print ( n ) NEW_LINE"}
{"id": "geeksforgeeks_688_A", "sol": 0, "python_code": "def CalculateMax ( arr , n ) :\n    arr.sort ( )\n    min_sum = arr [ 0 ] + arr [ 1 ]\n    max_sum = arr [ n - 1 ] + arr [ n - 2 ]\n    return abs ( max_sum - min_sum )\narr = [ 6 , 7 , 1 , 11 ]\nn = len ( arr )\nprint ( CalculateMax ( arr , n ) )\n", "python_code_tokenized": "def CalculateMax ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE max_sum = arr [ n - 1 ] + arr [ n - 2 ] NEW_LINE return abs ( max_sum - min_sum ) NEW_LINE DEDENT arr = [ 6 , 7 , 1 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CalculateMax ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2851_A", "sol": 0, "python_code": "def newString ( s ) :\n    l = len ( s )\n    freq = [ 0 ] * ( 26 )\n    for i in range ( 0 , l ) :\n        freq [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1\n    ans = \"\"\n    for i in range ( 0 , 26 ) :\n        for j in range ( 0 , freq [ i ] ) :\n            ans += chr ( 97 + i )\n    return ans\nif __name__ == \"__main__\" :\n    s = \"aabab\"\n    print ( newString ( s ) )\n", "python_code_tokenized": "def newString ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE freq = [ 0 ] * ( 26 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT for j in range ( 0 , freq [ i ] ) : NEW_LINE INDENT ans += chr ( 97 + i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aabab \" NEW_LINE print ( newString ( s ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1189_A", "sol": 0, "python_code": "from collections import defaultdict\ndef minOperations ( a , n , K ) :\n    Map = defaultdict ( lambda : False )\n    for i in range ( 0 , n ) :\n        if Map [ a [ i ] ] == True :\n            return 0\n        Map [ a [ i ] ] = True\n    b = [ ]\n    for i in range ( 0 , n ) :\n        b.append ( a [ i ] & K )\n    Map.clear ( )\n    for i in range ( 0 , n ) :\n        if a [ i ] != b [ i ] :\n            Map [ b [ i ] ] = True\n    for i in range ( 0 , n ) :\n        if Map [ a [ i ] ] == True :\n            return 1\n    Map.clear ( )\n    for i in range ( 0 , n ) :\n        if Map [ b [ i ] ] == True :\n            return 2\n        Map [ b [ i ] ] = True\n    return - 1\nif __name__ == \"__main__\" :\n    K = 3\n    a = [ 1 , 2 , 3 , 7 ]\n    n = len ( a )\n    print ( minOperations ( a , n , K ) )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE def minOperations ( a , n , K ) : NEW_LINE INDENT Map = defaultdict ( lambda : False ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if Map [ a [ i ] ] == True : NEW_LINE INDENT return 0 NEW_LINE DEDENT Map [ a [ i ] ] = True NEW_LINE DEDENT b = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT b . append ( a [ i ] & K ) NEW_LINE DEDENT Map . clear ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] != b [ i ] : NEW_LINE INDENT Map [ b [ i ] ] = True NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if Map [ a [ i ] ] == True : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT Map . clear ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if Map [ b [ i ] ] == True : NEW_LINE INDENT return 2 NEW_LINE DEDENT Map [ b [ i ] ] = True NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT K = 3 NEW_LINE a = [ 1 , 2 , 3 , 7 ] NEW_LINE n = len ( a ) NEW_LINE print ( minOperations ( a , n , K ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1103_A", "sol": 0, "python_code": "s = input ( )\nj = 1\nk = 1\nfor i in range ( len ( s ) ) :\n    if j > 4 : j = 1\n    if k > 3 : k = 1\n    if s [ i ] == '0' :\n        print ( 1 , j )\n        j += 1\n    else :\n        print ( 3 , k )\n        k += 2\n", "python_code_tokenized": "s = input ( ) NEW_LINE j = 1 NEW_LINE k = 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if j > 4 : j = 1 NEW_LINE if k > 3 : k = 1 NEW_LINE if s [ i ] == '0' : NEW_LINE INDENT print ( 1 , j ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( 3 , k ) NEW_LINE k += 2 NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3054_A", "sol": 0, "python_code": "def maxSubarrayXOR ( arr , n ) :\n    ans = - 2147483648\n    for i in range ( n ) :\n        curr_xor = 0\n        for j in range ( i , n ) :\n            curr_xor = curr_xor ^ arr [ j ]\n            ans = max ( ans , curr_xor )\n    return ans\narr = [ 8 , 1 , 2 , 12 ]\nn = len ( arr )\nprint ( \"Max subarray XOR is \" , maxSubarrayXOR ( arr , n ) )\n", "python_code_tokenized": "def maxSubarrayXOR ( arr , n ) : NEW_LINE INDENT ans = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_xor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_xor = curr_xor ^ arr [ j ] NEW_LINE ans = max ( ans , curr_xor ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 8 , 1 , 2 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Max \u2581 subarray \u2581 XOR \u2581 is \u2581 \" , maxSubarrayXOR ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_608_A", "sol": 0, "python_code": "n , s = list ( map ( int , input ( ).split ( ) ) )\nans = s\nfor _ in range ( n ) :\n    a , b = list ( map ( int , input ( ).split ( ) ) )\n    ans = max ( ans , a + b )\nprint ( ans )\n", "python_code_tokenized": "n , s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = s NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = max ( ans , a + b ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "projecteuler_p069_A", "sol": 0, "python_code": "import eulerlib , fractions\ndef compute ( ) :\n    totients = eulerlib.list_totients ( 10 ** 6 )\n    ans = max ( range ( 2 , len ( totients ) ) , key = ( lambda i : fractions.Fraction ( i , totients [ i ] ) ) )\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 6 ) NEW_LINE ans = max ( range ( 2 , len ( totients ) ) , key = ( lambda i : fractions . Fraction ( i , totients [ i ] ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2657_A", "sol": 0, "python_code": "def __gcd ( a , b ) :\n    return a if ( b == 0 ) else __gcd ( b , a % b )\ndef digitGCD ( n ) :\n    gcd = 0\n    while ( n > 0 ) :\n        gcd = __gcd ( n % 10 , gcd )\n        if ( gcd == 1 ) :\n            return 1\n        n = n // 10\n    return gcd\nn = 2448\nprint ( digitGCD ( n ) )\n", "python_code_tokenized": "def __gcd ( a , b ) : NEW_LINE INDENT return a if ( b == 0 ) else __gcd ( b , a % b ) NEW_LINE DEDENT def digitGCD ( n ) : NEW_LINE INDENT gcd = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT gcd = __gcd ( n % 10 , gcd ) NEW_LINE if ( gcd == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return gcd NEW_LINE DEDENT n = 2448 NEW_LINE print ( digitGCD ( n ) ) NEW_LINE"}
{"id": "aizu_p02361_A", "sol": 0, "python_code": "import heapq\nV , E , r = map ( int , input ( ).split ( ) )\nG = [ [ ] for i in range ( V ) ]\nfor i in range ( E ) :\n    s , t , d = map ( int , input ( ).split ( ) )\n    G [ s ].append ( [ d , t ] )\nINF = 1000000007\nmn = [ INF ] * V\ntodo = [ [ 0 , r ] ]\nfin = [ 0 ] * V\nheapq.heapify ( todo )\nwhile ( todo != [ ] ) :\n    v = heapq.heappop ( todo )\n    if not fin [ v [ 1 ] ] :\n        mn [ v [ 1 ] ] = v [ 0 ]\n        fin [ v [ 1 ] ] = 1\n        for i in G [ v [ 1 ] ] :\n            if mn [ v [ 1 ] ] + i [ 0 ] < mn [ i [ 1 ] ] :\n                heapq.heappush ( todo , [ mn [ v [ 1 ] ] + i [ 0 ] , i [ 1 ] ] )\nfor i in range ( V ) :\n    print ( mn [ i ] if mn [ i ] != INF else 'INF' )\n", "python_code_tokenized": "import heapq NEW_LINE V , E , r = map ( int , input ( ) . split ( ) ) NEW_LINE G = [ [ ] for i in range ( V ) ] NEW_LINE for i in range ( E ) : NEW_LINE INDENT s , t , d = map ( int , input ( ) . split ( ) ) NEW_LINE G [ s ] . append ( [ d , t ] ) NEW_LINE DEDENT INF = 1000000007 NEW_LINE mn = [ INF ] * V NEW_LINE todo = [ [ 0 , r ] ] NEW_LINE fin = [ 0 ] * V NEW_LINE heapq . heapify ( todo ) NEW_LINE while ( todo != [ ] ) : NEW_LINE INDENT v = heapq . heappop ( todo ) NEW_LINE if not fin [ v [ 1 ] ] : NEW_LINE INDENT mn [ v [ 1 ] ] = v [ 0 ] NEW_LINE fin [ v [ 1 ] ] = 1 NEW_LINE for i in G [ v [ 1 ] ] : NEW_LINE INDENT if mn [ v [ 1 ] ] + i [ 0 ] < mn [ i [ 1 ] ] : NEW_LINE INDENT heapq . heappush ( todo , [ mn [ v [ 1 ] ] + i [ 0 ] , i [ 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( V ) : NEW_LINE INDENT print ( mn [ i ] if mn [ i ] != INF else ' INF ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2439_A", "sol": 0, "python_code": "from math import gcd\ndef countNumbers ( X , Y , N ) :\n    divisibleByX = int ( N / X )\n    divisibleByY = int ( N / Y )\n    LCM = int ( ( X * Y ) / gcd ( X , Y ) )\n    divisibleByLCM = int ( N / LCM )\n    divisibleByXorY = ( divisibleByX + divisibleByY - divisibleByLCM )\n    divisibleByXnotY = ( divisibleByXorY - divisibleByY )\n    return divisibleByXnotY\nif __name__ == '__main__' :\n    X = 2\n    Y = 3\n    N = 10\n    print ( countNumbers ( X , Y , N ) )\n", "python_code_tokenized": "from math import gcd NEW_LINE def countNumbers ( X , Y , N ) : NEW_LINE INDENT divisibleByX = int ( N / X ) NEW_LINE divisibleByY = int ( N / Y ) NEW_LINE LCM = int ( ( X * Y ) / gcd ( X , Y ) ) NEW_LINE divisibleByLCM = int ( N / LCM ) NEW_LINE divisibleByXorY = ( divisibleByX + divisibleByY - divisibleByLCM ) NEW_LINE divisibleByXnotY = ( divisibleByXorY - divisibleByY ) NEW_LINE return divisibleByXnotY NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 2 NEW_LINE Y = 3 NEW_LINE N = 10 NEW_LINE print ( countNumbers ( X , Y , N ) ) NEW_LINE DEDENT"}
{"id": "codeforces_399_A", "sol": 0, "python_code": "user_input = input ( ).split ( ' ' )\nn , p , k = user_input\nn = int ( n )\np = int ( p )\nk = int ( k )\nnav = [ ]\nstart = p - k\nif start <= 1 :\n    start = 1\nelse :\n    nav.append ( '<<' )\nfor i in range ( start , p + k + 1 ) :\n    if i < n :\n        if i == p :\n            nav.append ( f'({str(i)})' )\n        else :\n            nav.append ( str ( i ) )\n    else :\n        if i == p :\n            nav.append ( f'({str(i)})' )\n        else :\n            nav.append ( str ( i ) )\n        break\nelse :\n    nav.append ( '>>' )\nprint ( ' '.join ( nav ) )\n", "python_code_tokenized": "user_input = input ( ) . split ( ' \u2581 ' ) NEW_LINE n , p , k = user_input NEW_LINE n = int ( n ) NEW_LINE p = int ( p ) NEW_LINE k = int ( k ) NEW_LINE nav = [ ] NEW_LINE start = p - k NEW_LINE if start <= 1 : NEW_LINE INDENT start = 1 NEW_LINE DEDENT else : NEW_LINE INDENT nav . append ( ' < < ' ) NEW_LINE DEDENT for i in range ( start , p + k + 1 ) : NEW_LINE INDENT if i < n : NEW_LINE INDENT if i == p : NEW_LINE INDENT nav . append ( f ' ( { str ( i ) } ) ' ) NEW_LINE DEDENT else : NEW_LINE INDENT nav . append ( str ( i ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if i == p : NEW_LINE INDENT nav . append ( f ' ( { str ( i ) } ) ' ) NEW_LINE DEDENT else : NEW_LINE INDENT nav . append ( str ( i ) ) NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT nav . append ( ' > > ' ) NEW_LINE DEDENT print ( ' \u2581 ' . join ( nav ) ) NEW_LINE"}
{"id": "geeksforgeeks_4205_A", "sol": 0, "python_code": "def countPairs ( n ) :\n    count = 0 ;\n    for x in range ( 1 , n ) :\n        for y in range ( x + 1 , n + 1 ) :\n            if ( ( y + x ) % ( y ^ x ) == 0 ) :\n                count += 1 ;\n    return count ;\nif __name__ == \"__main__\" :\n    n = 6 ;\n    print ( countPairs ( n ) ) ;\n", "python_code_tokenized": "def countPairs ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 ; NEW_LINE print ( countPairs ( n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3030_A", "sol": 0, "python_code": "def countPairs ( n ) :\n    count = 0\n    for x in range ( 1 , n ) :\n        for y in range ( x + 1 , n + 1 ) :\n            if ( ( y * x ) % ( y + x ) == 0 ) :\n                count += 1\n    return count\nn = 15\nprint ( countPairs ( n ) )\n", "python_code_tokenized": "def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y * x ) % ( y + x ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT n = 15 NEW_LINE print ( countPairs ( n ) ) NEW_LINE"}
{"id": "aizu_p00016_A", "sol": 0, "python_code": "import math\nPI = 3.1415926535897932384626433832795\nM = 0.01745329251994329576923690768489\nEPS = 1e-8\nr , q , f = 0 , 90 * M , 0\nwhile True :\n    d , a = list ( map ( int , input ( ).split ( ',' ) ) )\n    if d == 0 and a == 0 : break\n    r2 = math.sqrt ( r * r + d * d - 2 * r * d * math.cos ( PI - math.fabs ( f ) ) )\n    if math.fabs ( r ) < EPS or math.fabs ( r2 ) < EPS :\n        q2 = q - f\n        f = a * M\n    else :\n        t = math.acos ( ( r * r + r2 * r2 - d * d ) / ( 2 * r * r2 ) ) ;\n        if f >= 0 :\n            q2 = q - t\n            f += a * M - t\n        else :\n            q2 = q + t\n            f += a * M + t\n    r = r2\n    q = q2\nprint ( int ( r * math.cos ( q ) ) , int ( r * math.sin ( q ) ) , sep = '\\n' )\n", "python_code_tokenized": "import math NEW_LINE PI = 3.1415926535897932384626433832795 NEW_LINE M = 0.01745329251994329576923690768489 NEW_LINE EPS = 1e-8 NEW_LINE r , q , f = 0 , 90 * M , 0 NEW_LINE while True : NEW_LINE INDENT d , a = list ( map ( int , input ( ) . split ( ' , ' ) ) ) NEW_LINE if d == 0 and a == 0 : break NEW_LINE r2 = math . sqrt ( r * r + d * d - 2 * r * d * math . cos ( PI - math . fabs ( f ) ) ) NEW_LINE if math . fabs ( r ) < EPS or math . fabs ( r2 ) < EPS : NEW_LINE INDENT q2 = q - f NEW_LINE f = a * M NEW_LINE DEDENT else : NEW_LINE INDENT t = math . acos ( ( r * r + r2 * r2 - d * d ) / ( 2 * r * r2 ) ) ; NEW_LINE if f >= 0 : NEW_LINE INDENT q2 = q - t NEW_LINE f += a * M - t NEW_LINE DEDENT else : NEW_LINE INDENT q2 = q + t NEW_LINE f += a * M + t NEW_LINE DEDENT DEDENT r = r2 NEW_LINE q = q2 NEW_LINE DEDENT print ( int ( r * math . cos ( q ) ) , int ( r * math . sin ( q ) ) , sep = ' \\n ' ) NEW_LINE"}
{"id": "codeforces_1382_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    n = int ( input ( ) )\n    a = [ int ( i ) for i in input ( ).split ( ) ]\n    for i in range ( n ) :\n        if a [ i ] != 1 :\n            break\n    print ( 'Second' if i & 1 else 'First' )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ' Second ' if i & 1 else ' First ' ) NEW_LINE DEDENT"}
{"id": "codeforces_299_A", "sol": 0, "python_code": "n = int ( input ( ) )\narray = input ( ).split ( )\na = 0\nwhile a < n :\n    array [ a ] = int ( array [ a ] )\n    a += 1\nsmallest = min ( array )\narray.sort ( )\ni = 1\nt_or_f = True\nwhile i < n :\n    if array [ i ] / smallest != int ( array [ i ] / smallest ) :\n        t_or_f = False\n    i += 1\nif t_or_f == True :\n    print ( smallest )\nelse :\n    print ( - 1 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE array = input ( ) . split ( ) NEW_LINE a = 0 NEW_LINE while a < n : NEW_LINE INDENT array [ a ] = int ( array [ a ] ) NEW_LINE a += 1 NEW_LINE DEDENT smallest = min ( array ) NEW_LINE array . sort ( ) NEW_LINE i = 1 NEW_LINE t_or_f = True NEW_LINE while i < n : NEW_LINE INDENT if array [ i ] / smallest != int ( array [ i ] / smallest ) : NEW_LINE INDENT t_or_f = False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if t_or_f == True : NEW_LINE INDENT print ( smallest ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"}
{"id": "codeforces_573_B", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nn = int ( input ( ) )\nh = list ( map ( int , input ( ).split ( ) ) )\nres = [ 0 ] * n\nworst = 0\nfor i in range ( n ) :\n    worst = min ( worst , h [ i ] - i - 1 )\n    res [ i ] = i + 1 + worst\nworst = n + 1\nfor i in range ( n ) [ : : - 1 ] :\n    worst = min ( worst , h [ i ] + i + 1 )\n    res [ i ] = min ( res [ i ] , worst - i - 1 )\nprint ( max ( res ) )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE h = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE res = [ 0 ] * n NEW_LINE worst = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT worst = min ( worst , h [ i ] - i - 1 ) NEW_LINE res [ i ] = i + 1 + worst NEW_LINE DEDENT worst = n + 1 NEW_LINE for i in range ( n ) [ : : - 1 ] : NEW_LINE INDENT worst = min ( worst , h [ i ] + i + 1 ) NEW_LINE res [ i ] = min ( res [ i ] , worst - i - 1 ) NEW_LINE DEDENT print ( max ( res ) ) NEW_LINE"}
{"id": "geeksforgeeks_4641_A", "sol": 0, "python_code": "def longestSubsequenceCommonSegment ( k , s1 , s2 ) :\n    n = len ( s1 )\n    m = len ( s2 )\n    lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ]\n    cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ]\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , m + 1 ) :\n            lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] )\n            if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) :\n                cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ;\n            if ( cnt [ i ] [ j ] >= k ) :\n                for a in range ( k , cnt [ i ] [ j ] + 1 ) :\n                    lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a )\n    return lcs [ n ] [ m ]\nk = 4\ns1 = \"aggasdfa\"\ns2 = \"aggajasdfa\"\nprint ( longestSubsequenceCommonSegment ( k , s1 , s2 ) )\n", "python_code_tokenized": "def longestSubsequenceCommonSegment ( k , s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) NEW_LINE if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) : NEW_LINE INDENT cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; NEW_LINE DEDENT if ( cnt [ i ] [ j ] >= k ) : NEW_LINE INDENT for a in range ( k , cnt [ i ] [ j ] + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return lcs [ n ] [ m ] NEW_LINE DEDENT k = 4 NEW_LINE s1 = \" aggasdfa \" NEW_LINE s2 = \" aggajasdfa \" NEW_LINE print ( longestSubsequenceCommonSegment ( k , s1 , s2 ) ) NEW_LINE"}
{"id": "codeforces_544_A", "sol": 0, "python_code": "k = int ( input ( ) )\ns = input ( )\nans = [ ]\ncur = \"\"\nused = set ( )\nfor i in range ( len ( s ) ) :\n    if s [ i ] not in used :\n        if len ( cur ) > 0 :\n            ans.append ( cur )\n        cur = s [ i ]\n        used.add ( s [ i ] )\n    else :\n        cur += s [ i ]\nans.append ( cur )\nif len ( ans ) < k :\n    print ( \"NO\" )\nelse :\n    print ( \"YES\" )\n    for i in range ( k , len ( ans ) ) :\n        ans [ k - 1 ] += ans [ i ]\n    for i in range ( k ) :\n        print ( ans [ i ] )\n", "python_code_tokenized": "k = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = [ ] NEW_LINE cur = \" \" NEW_LINE used = set ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] not in used : NEW_LINE INDENT if len ( cur ) > 0 : NEW_LINE INDENT ans . append ( cur ) NEW_LINE DEDENT cur = s [ i ] NEW_LINE used . add ( s [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT cur += s [ i ] NEW_LINE DEDENT DEDENT ans . append ( cur ) NEW_LINE if len ( ans ) < k : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE for i in range ( k , len ( ans ) ) : NEW_LINE INDENT ans [ k - 1 ] += ans [ i ] NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( ans [ i ] ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ARC098_C", "sol": 0, "python_code": "from itertools import *\nN , K , Q , * A = map ( int , open ( 0 ).read ( ).split ( ) )\ns = sorted\nprint ( min ( ( s ( sum ( ( v [ : max ( 0 , len ( v ) - K + 1 ) ] for v in ( k * s ( v ) for k , v in groupby ( A , lambda a : a >= Y ) ) ) , [ ] ) ) [ Q - 1 : ] or [ 2e9 ] ) [ 0 ] - Y for Y in A ) )\n", "python_code_tokenized": "from itertools import * NEW_LINE N , K , Q , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE s = sorted NEW_LINE print ( min ( ( s ( sum ( ( v [ : max ( 0 , len ( v ) - K + 1 ) ] for v in ( k * s ( v ) for k , v in groupby ( A , lambda a : a >= Y ) ) ) , [ ] ) ) [ Q - 1 : ] or [ 2e9 ] ) [ 0 ] - Y for Y in A ) ) NEW_LINE"}
{"id": "geeksforgeeks_5178_A", "sol": 0, "python_code": "def printSubArray ( arr , start , end ) :\n    print ( \"[ \" , end = \"\" )\n    for i in range ( start , end + 1 ) :\n        print ( arr [ i ] , end = \"\" )\n    print ( \"]\" , end = \"\" )\ndef divideArray ( arr , n ) :\n    sum = 0\n    for i in range ( 0 , n ) :\n        sum += arr [ i ]\n    sum_so_far = 0\n    for i in range ( 0 , n ) :\n        if 2 * sum_so_far + arr [ i ] == sum :\n            print ( \"The array can be divided into\" , \"two subarrays with equal sum\" )\n            print ( \"two subarrays are -\" , end = \"\" )\n            printSubArray ( arr , 0 , i - 1 )\n            printSubArray ( arr , i + 1 , n - 1 )\n            return True\n        sum_so_far += arr [ i ]\n    print ( \"The array cannot be divided into\"\"two subarrays with equal sum\" , end = \"\" )\n    return False\narr = [ 6 , 2 , 3 , 2 , 1 ]\nn = len ( arr )\ndivideArray ( arr , n )\n", "python_code_tokenized": "def printSubArray ( arr , start , end ) : NEW_LINE INDENT print ( \" [ \u2581 \" , end = \" \" ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" ] \" , end = \" \" ) NEW_LINE DEDENT def divideArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT sum_so_far = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if 2 * sum_so_far + arr [ i ] == sum : NEW_LINE INDENT print ( \" The \u2581 array \u2581 can \u2581 be \u2581 divided \u2581 into \" , \" two \u2581 subarrays \u2581 with \u2581 equal \u2581 sum \" ) NEW_LINE print ( \" two \u2581 subarrays \u2581 are \u2581 - \" , end = \" \" ) NEW_LINE printSubArray ( arr , 0 , i - 1 ) NEW_LINE printSubArray ( arr , i + 1 , n - 1 ) NEW_LINE return True NEW_LINE DEDENT sum_so_far += arr [ i ] NEW_LINE DEDENT print ( \" The \u2581 array \u2581 cannot \u2581 be \u2581 divided \u2581 into \" \" two \u2581 subarrays \u2581 with \u2581 equal \u2581 sum \" , end = \" \" ) NEW_LINE return False NEW_LINE DEDENT arr = [ 6 , 2 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE divideArray ( arr , n ) NEW_LINE"}
{"id": "codeforces_1324_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    x = int ( input ( ) ) ; a = list ( map ( int , input ( ).split ( ) ) ) ; p = 0\n    for i in range ( x - 2 ) :\n        if a [ i ] in a [ i + 2 : ] :\n            p = 1\n            break\n    print ( 'YES' if p != 0 else 'NO' )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x = int ( input ( ) ) ; a = list ( map ( int , input ( ) . split ( ) ) ) ; p = 0 NEW_LINE for i in range ( x - 2 ) : NEW_LINE INDENT if a [ i ] in a [ i + 2 : ] : NEW_LINE INDENT p = 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ' YES ' if p != 0 else ' NO ' ) NEW_LINE DEDENT"}
{"id": "codeforces_61_A", "sol": 0, "python_code": "s1 = str ( input ( ) )\ns2 = str ( input ( ) )\ns3 = str ( )\nfor i in range ( len ( s1 ) ) :\n    if s1 [ i ] != s2 [ i ] :\n        s3 = s3 + '1'\n    else :\n        s3 = s3 + '0'\nprint ( s3 )\n", "python_code_tokenized": "s1 = str ( input ( ) ) NEW_LINE s2 = str ( input ( ) ) NEW_LINE s3 = str ( ) NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if s1 [ i ] != s2 [ i ] : NEW_LINE INDENT s3 = s3 + '1' NEW_LINE DEDENT else : NEW_LINE INDENT s3 = s3 + '0' NEW_LINE DEDENT DEDENT print ( s3 ) NEW_LINE"}
{"id": "aizu_p01224_A", "sol": 0, "python_code": "while True :\n    n = int ( input ( ) )\n    if n == 0 : break\n    solvers = set ( )\n    for i in range ( 1 , int ( n ** ( 1 / 2 ) ) + 2 ) :\n        if n % i == 0 :\n            solvers.add ( i )\n            solvers.add ( n // i )\n    score = sum ( solvers ) - n\n    if n < score :\n        print ( \"abundant number\" )\n    elif n == score :\n        print ( \"perfect number\" )\n    else :\n        print ( \"deficient number\" )\n", "python_code_tokenized": "while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE solvers = set ( ) NEW_LINE for i in range ( 1 , int ( n ** ( 1 / 2 ) ) + 2 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT solvers . add ( i ) NEW_LINE solvers . add ( n // i ) NEW_LINE DEDENT DEDENT score = sum ( solvers ) - n NEW_LINE if n < score : NEW_LINE INDENT print ( \" abundant \u2581 number \" ) NEW_LINE DEDENT elif n == score : NEW_LINE INDENT print ( \" perfect \u2581 number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" deficient \u2581 number \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1363_A", "sol": 0, "python_code": "t = int ( input ( ) )\nn_counter = 0\nresult = [ ]\nfor i in range ( 0 , t ) :\n    n_counter = 0\n    n , x = ( int ( x ) for x in input ( ).split ( ) )\n    arr = [ int ( x ) for x in input ( ).split ( ) ]\n    for j in range ( 0 , n ) :\n        if arr [ j ] % 2 == 1 :\n            n_counter += 1\n    if n_counter == 0 or ( n_counter % 2 == 0 and n == x ) or ( n_counter == n and x % 2 == 0 ) :\n        print ( 'No' )\n    else :\n        print ( 'Yes' )\nfor i in result :\n    print ( i )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE n_counter = 0 NEW_LINE result = [ ] NEW_LINE for i in range ( 0 , t ) : NEW_LINE INDENT n_counter = 0 NEW_LINE n , x = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE arr = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] % 2 == 1 : NEW_LINE INDENT n_counter += 1 NEW_LINE DEDENT DEDENT if n_counter == 0 or ( n_counter % 2 == 0 and n == x ) or ( n_counter == n and x % 2 == 0 ) : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT DEDENT for i in result : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT"}
{"id": "aizu_p00165_A", "sol": 0, "python_code": "import bisect\nn = 1000000\np = [ 1 ] * ( n + 1 )\np [ 0 ] , p [ 1 ] = 0 , 0\nfor i in range ( 2 , int ( n ** 0.5 ) + 1 ) :\n    if p [ i ] :\n        for j in range ( i * i , n + 1 , i ) :\n            p [ j ] = 0\np = [ i for i in range ( n + 1 ) if p [ i ] == 1 ]\nwhile 1 :\n    n = int ( input ( ) )\n    ans = - n\n    if n == 0 : break\n    while n :\n        n -= 1\n        a , m = map ( int , input ( ).split ( ) )\n        ans += bisect.bisect_left ( p , a + m + 1 ) - bisect.bisect_left ( p , a - m )\n    print ( ans )\n", "python_code_tokenized": "import bisect NEW_LINE n = 1000000 NEW_LINE p = [ 1 ] * ( n + 1 ) NEW_LINE p [ 0 ] , p [ 1 ] = 0 , 0 NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if p [ i ] : NEW_LINE INDENT for j in range ( i * i , n + 1 , i ) : NEW_LINE INDENT p [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT p = [ i for i in range ( n + 1 ) if p [ i ] == 1 ] NEW_LINE while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = - n NEW_LINE if n == 0 : break NEW_LINE while n : NEW_LINE INDENT n -= 1 NEW_LINE a , m = map ( int , input ( ) . split ( ) ) NEW_LINE ans += bisect . bisect_left ( p , a + m + 1 ) - bisect . bisect_left ( p , a - m ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC078_B", "sol": 0, "python_code": "x , y , z = map ( int , input ( ).split ( ) )\na = x % ( y + z )\nb = x // ( y + z )\nif ( a >= z ) :\n    print ( b )\nelse :\n    print ( b - 1 )\n", "python_code_tokenized": "x , y , z = map ( int , input ( ) . split ( ) ) NEW_LINE a = x % ( y + z ) NEW_LINE b = x // ( y + z ) NEW_LINE if ( a >= z ) : NEW_LINE INDENT print ( b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b - 1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4143_A", "sol": 0, "python_code": "cnt_neg = 0 ;\nexists_zero = None ;\ndef preProcess ( arr , n ) :\n    global cnt_neg\n    for i in range ( n ) :\n        if ( arr [ i ] < 0 ) :\n            cnt_neg += 1 ;\n        if ( arr [ i ] == 0 ) :\n            exists_zero = True ;\ndef isPossible ( k ) :\n    if ( not exists_zero ) :\n        if ( k >= cnt_neg and ( k - cnt_neg ) % 2 == 0 ) :\n            return True ;\n        else :\n            return False ;\n    else :\n        if ( k >= cnt_neg ) :\n            return True ;\n        else :\n            return False ;\nif __name__ == \"__main__\" :\n    arr = [ - 1 , 2 , - 3 , 4 , 5 ] ;\n    n = len ( arr ) ;\n    preProcess ( arr , n ) ;\n    queries = [ 1 , 2 , 3 , 4 ] ;\n    q = len ( queries ) ;\n    for i in range ( q ) :\n        if ( isPossible ( queries [ i ] ) ) :\n            print ( \"Yes\" ) ;\n        else :\n            print ( \"No\" ) ;\n", "python_code_tokenized": "cnt_neg = 0 ; NEW_LINE exists_zero = None ; NEW_LINE def preProcess ( arr , n ) : NEW_LINE INDENT global cnt_neg NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT cnt_neg += 1 ; NEW_LINE DEDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT exists_zero = True ; NEW_LINE DEDENT DEDENT DEDENT def isPossible ( k ) : NEW_LINE INDENT if ( not exists_zero ) : NEW_LINE INDENT if ( k >= cnt_neg and ( k - cnt_neg ) % 2 == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( k >= cnt_neg ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 1 , 2 , - 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE preProcess ( arr , n ) ; NEW_LINE queries = [ 1 , 2 , 3 , 4 ] ; NEW_LINE q = len ( queries ) ; NEW_LINE for i in range ( q ) : NEW_LINE INDENT if ( isPossible ( queries [ i ] ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_1444_A", "sol": 0, "python_code": "def returnMaxSum ( A , B , n ) :\n    mp = set ( )\n    result = 0\n    curr_sum = curr_begin = 0\n    for i in range ( 0 , n ) :\n        while A [ i ] in mp :\n            mp.remove ( A [ curr_begin ] )\n            curr_sum -= B [ curr_begin ]\n            curr_begin += 1\n        mp.add ( A [ i ] )\n        curr_sum += B [ i ]\n        result = max ( result , curr_sum )\n    return result\nif __name__ == \"__main__\" :\n    A = [ 0 , 1 , 2 , 3 , 0 , 1 , 4 ]\n    B = [ 9 , 8 , 1 , 2 , 3 , 4 , 5 ]\n    n = len ( A )\n    print ( returnMaxSum ( A , B , n ) )\n", "python_code_tokenized": "def returnMaxSum ( A , B , n ) : NEW_LINE INDENT mp = set ( ) NEW_LINE result = 0 NEW_LINE curr_sum = curr_begin = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while A [ i ] in mp : NEW_LINE INDENT mp . remove ( A [ curr_begin ] ) NEW_LINE curr_sum -= B [ curr_begin ] NEW_LINE curr_begin += 1 NEW_LINE DEDENT mp . add ( A [ i ] ) NEW_LINE curr_sum += B [ i ] NEW_LINE result = max ( result , curr_sum ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 0 , 1 , 2 , 3 , 0 , 1 , 4 ] NEW_LINE B = [ 9 , 8 , 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE print ( returnMaxSum ( A , B , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4476_A", "sol": 0, "python_code": "from math import *\ndef previousFibonacci ( n ) :\n    a = n / ( ( 1 + sqrt ( 5 ) ) / 2.0 )\n    return round ( a )\nn = 8\nprint ( previousFibonacci ( n ) )\n", "python_code_tokenized": "from math import * NEW_LINE def previousFibonacci ( n ) : NEW_LINE INDENT a = n / ( ( 1 + sqrt ( 5 ) ) / 2.0 ) NEW_LINE return round ( a ) NEW_LINE DEDENT n = 8 NEW_LINE print ( previousFibonacci ( n ) ) NEW_LINE"}
{"id": "codeforces_1368_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor test in range ( t ) :\n    a , b , n = map ( int , input ( ).split ( ) )\n    num = 0\n    while a <= n and b <= n :\n        if a <= b :\n            a += b\n        else :\n            b += a\n        num += 1\n    print ( num )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for test in range ( t ) : NEW_LINE INDENT a , b , n = map ( int , input ( ) . split ( ) ) NEW_LINE num = 0 NEW_LINE while a <= n and b <= n : NEW_LINE INDENT if a <= b : NEW_LINE INDENT a += b NEW_LINE DEDENT else : NEW_LINE INDENT b += a NEW_LINE DEDENT num += 1 NEW_LINE DEDENT print ( num ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1730_A", "sol": 0, "python_code": "def centeredOctahedral ( n ) :\n    return ( 2 * n + 1 ) * ( 2 * n * n + 2 * n + 3 ) // 3\nif __name__ == '__main__' :\n    n = 3\n    print ( centeredOctahedral ( n ) )\n    n = 9\n    print ( centeredOctahedral ( n ) )\n", "python_code_tokenized": "def centeredOctahedral ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( 2 * n * n + 2 * n + 3 ) // 3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( centeredOctahedral ( n ) ) NEW_LINE n = 9 NEW_LINE print ( centeredOctahedral ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2203_A", "sol": 0, "python_code": "def findSmallest ( a , n ) :\n    for i in range ( 0 , n ) :\n        for j in range ( 0 , n ) :\n            if ( ( a [ j ] % a [ i ] ) >= 1 ) :\n                break\n        if ( j == n - 1 ) :\n            return a [ i ]\n    return - 1\na = [ 25 , 20 , 5 , 10 , 100 ]\nn = len ( a )\nprint ( findSmallest ( a , n ) )\n", "python_code_tokenized": "def findSmallest ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( a [ j ] % a [ i ] ) >= 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == n - 1 ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT a = [ 25 , 20 , 5 , 10 , 100 ] NEW_LINE n = len ( a ) NEW_LINE print ( findSmallest ( a , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_407_A", "sol": 0, "python_code": "def maxAvgSubArray ( a , n , x , y ) :\n    prefix = [ 0 ] * n ;\n    prefix [ 0 ] = a [ 0 ] ;\n    for i in range ( 1 , n ) :\n        prefix [ i ] = prefix [ i - 1 ] + a [ i ] ;\n    maximum = 0 ;\n    for i in range ( n ) :\n        j = i + x - 1\n        while ( j < i + y and j < n ) :\n            sum = prefix [ j ] ;\n            if ( i > 0 ) :\n                sum -= prefix [ i - 1 ] ;\n            current = sum / ( j - i + 1 ) ;\n            maximum = max ( maximum , current ) ;\n            j += 1\n    return maximum ;\nif __name__ == \"__main__\" :\n    a = [ 6 , 7 , 8 , 3 , 2 , 4 , 2 ] ;\n    X = 2 ; Y = 4 ;\n    n = len ( a ) ;\n    print ( maxAvgSubArray ( a , n , X , Y ) ) ;\n", "python_code_tokenized": "def maxAvgSubArray ( a , n , x , y ) : NEW_LINE INDENT prefix = [ 0 ] * n ; NEW_LINE prefix [ 0 ] = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + a [ i ] ; NEW_LINE DEDENT maximum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + x - 1 NEW_LINE while ( j < i + y and j < n ) : NEW_LINE INDENT sum = prefix [ j ] ; NEW_LINE if ( i > 0 ) : NEW_LINE INDENT sum -= prefix [ i - 1 ] ; NEW_LINE DEDENT current = sum / ( j - i + 1 ) ; NEW_LINE maximum = max ( maximum , current ) ; NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return maximum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 6 , 7 , 8 , 3 , 2 , 4 , 2 ] ; NEW_LINE X = 2 ; Y = 4 ; NEW_LINE n = len ( a ) ; NEW_LINE print ( maxAvgSubArray ( a , n , X , Y ) ) ; NEW_LINE DEDENT"}
{"id": "atcoder_ABC062_C", "sol": 0, "python_code": "hight , width = map ( int , input ( ).split ( ) )\nans = 10 ** 18\ndef F ( H , W ) :\n    global ans\n    for h in range ( 1 , H ) :\n        sa = h * W\n        h2 = ( H - h ) // 2\n        sb = h2 * W\n        sc = ( H - h - h2 ) * W\n        ans = min ( ans , max ( sa , sb , sc ) - min ( sa , sb , sc ) )\n        w = W // 2\n        sb = ( H - h ) * w\n        sc = ( H - h ) * ( W - w )\n        ans = min ( ans , max ( sa , sb , sc ) - min ( sa , sb , sc ) )\nF ( hight , width )\nF ( width , hight )\nprint ( ans )\n", "python_code_tokenized": "hight , width = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 10 ** 18 NEW_LINE def F ( H , W ) : NEW_LINE INDENT global ans NEW_LINE for h in range ( 1 , H ) : NEW_LINE INDENT sa = h * W NEW_LINE h2 = ( H - h ) // 2 NEW_LINE sb = h2 * W NEW_LINE sc = ( H - h - h2 ) * W NEW_LINE ans = min ( ans , max ( sa , sb , sc ) - min ( sa , sb , sc ) ) NEW_LINE w = W // 2 NEW_LINE sb = ( H - h ) * w NEW_LINE sc = ( H - h ) * ( W - w ) NEW_LINE ans = min ( ans , max ( sa , sb , sc ) - min ( sa , sb , sc ) ) NEW_LINE DEDENT DEDENT F ( hight , width ) NEW_LINE F ( width , hight ) NEW_LINE print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_3810_A", "sol": 0, "python_code": "def sumOddOccurring ( mat ) :\n    mp = { }\n    n , m = len ( mat ) , len ( mat [ 0 ] )\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if mat [ i ] [ j ] in mp :\n                mp [ mat [ i ] [ j ] ] = mp.get ( mat [ i ] [ j ] ) + 1\n            else :\n                mp [ mat [ i ] [ j ] ] = 1\n    _sum = 0\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if mp.get ( mat [ i ] [ j ] ) % 2 == 1 :\n                _sum += mat [ i ] [ j ]\n    return _sum\nif __name__ == '__main__' :\n    mat = [ [ 1 , 2 , 3 ] , [ 1 , 3 , 2 ] , [ 1 , 5 , 6 ] ]\n    print ( sumOddOccurring ( mat ) )\n", "python_code_tokenized": "def sumOddOccurring ( mat ) : NEW_LINE INDENT mp = { } NEW_LINE n , m = len ( mat ) , len ( mat [ 0 ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if mat [ i ] [ j ] in mp : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = mp . get ( mat [ i ] [ j ] ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT _sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if mp . get ( mat [ i ] [ j ] ) % 2 == 1 : NEW_LINE INDENT _sum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return _sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 1 , 3 , 2 ] , [ 1 , 5 , 6 ] ] NEW_LINE print ( sumOddOccurring ( mat ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3792_A", "sol": 0, "python_code": "import sys\nN = 3\nM = 3\ndef sumMaxOccuring ( arr ) :\n    mp = dict ( )\n    for i in range ( N ) :\n        for j in range ( M ) :\n            if arr [ i ] [ j ] in mp :\n                mp [ arr [ i ] [ j ] ] += 1\n            else :\n                mp [ arr [ i ] [ j ] ] = 1\n    s = 0\n    maxFreq = - sys.maxsize\n    for i in mp :\n        if mp [ i ] > maxFreq :\n            maxFreq = mp [ i ]\n    for i in mp :\n        if mp [ i ] == maxFreq :\n            s += i * mp [ i ]\n    return s\nif __name__ == \"__main__\" :\n    mat = [ [ 1 , 2 , 3 ] , [ 1 , 3 , 2 ] , [ 1 , 5 , 6 ] ]\n    print ( sumMaxOccuring ( mat ) )\n", "python_code_tokenized": "import sys NEW_LINE N = 3 NEW_LINE M = 3 NEW_LINE def sumMaxOccuring ( arr ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if arr [ i ] [ j ] in mp : NEW_LINE INDENT mp [ arr [ i ] [ j ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] [ j ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT s = 0 NEW_LINE maxFreq = - sys . maxsize NEW_LINE for i in mp : NEW_LINE INDENT if mp [ i ] > maxFreq : NEW_LINE INDENT maxFreq = mp [ i ] NEW_LINE DEDENT DEDENT for i in mp : NEW_LINE INDENT if mp [ i ] == maxFreq : NEW_LINE INDENT s += i * mp [ i ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 1 , 3 , 2 ] , [ 1 , 5 , 6 ] ] NEW_LINE print ( sumMaxOccuring ( mat ) ) NEW_LINE DEDENT"}
{"id": "codejam_14_42", "sol": 0, "python_code": "import sys\ndef solve ( n , s ) :\n    cnt = 0\n    while n > 0 :\n        m = 0\n        for i in range ( 1 , n ) :\n            if s [ i ] < s [ m ] :\n                m = i\n        cnt += min ( m , n - 1 - m )\n        n = n - 1\n        del s [ m ]\n    return cnt\nt = int ( sys.stdin.readline ( ) )\nfor test_case in range ( 1 , t + 1 ) :\n    n = int ( sys.stdin.readline ( ) )\n    s = [ int ( y ) for y in sys.stdin.readline ( ).split ( ) ]\n    print ( 'Case #%d: %d' % ( test_case , solve ( n , s ) ) )\n", "python_code_tokenized": "import sys NEW_LINE def solve ( n , s ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n > 0 : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] < s [ m ] : NEW_LINE INDENT m = i NEW_LINE DEDENT DEDENT cnt += min ( m , n - 1 - m ) NEW_LINE n = n - 1 NEW_LINE del s [ m ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT t = int ( sys . stdin . readline ( ) ) NEW_LINE for test_case in range ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE s = [ int ( y ) for y in sys . stdin . readline ( ) . split ( ) ] NEW_LINE print ( ' Case \u2581 # % d : \u2581 % d ' % ( test_case , solve ( n , s ) ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00446_A", "sol": 0, "python_code": "import bisect\nwhile True :\n    n = int ( input ( ) )\n    if n == 0 :\n        break\n    tc = sorted ( [ int ( input ( ) ) for _ in range ( n ) ] )\n    hc = sorted ( [ v for v in range ( 1 , 2 * n + 1 ) if v not in tc ] )\n    ba = [ ]\n    flag = True\n    while tc and hc :\n        if len ( ba ) == 0 :\n            try :\n                if flag :\n                    tmp = tc.pop ( 0 )\n                    flag = False\n                else :\n                    tmp = hc.pop ( 0 )\n                    flag = True\n            except IndexError :\n                pass\n            ba = [ tmp ]\n            continue\n        last_card = ba [ - 1 ]\n        if flag :\n            x = bisect.bisect_left ( tc , last_card )\n            flag = False\n            try :\n                tmp = tc.pop ( x )\n            except IndexError :\n                ba = [ ]\n                continue\n        else :\n            x = bisect.bisect_left ( hc , last_card )\n            flag = True\n            try :\n                tmp = hc.pop ( x )\n            except IndexError :\n                ba = [ ]\n                continue\n        ba.append ( tmp )\n    print ( len ( hc ) )\n    print ( len ( tc ) )\n", "python_code_tokenized": "import bisect NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT tc = sorted ( [ int ( input ( ) ) for _ in range ( n ) ] ) NEW_LINE hc = sorted ( [ v for v in range ( 1 , 2 * n + 1 ) if v not in tc ] ) NEW_LINE ba = [ ] NEW_LINE flag = True NEW_LINE while tc and hc : NEW_LINE INDENT if len ( ba ) == 0 : NEW_LINE INDENT try : NEW_LINE INDENT if flag : NEW_LINE INDENT tmp = tc . pop ( 0 ) NEW_LINE flag = False NEW_LINE DEDENT else : NEW_LINE INDENT tmp = hc . pop ( 0 ) NEW_LINE flag = True NEW_LINE DEDENT DEDENT except IndexError : NEW_LINE INDENT pass NEW_LINE DEDENT ba = [ tmp ] NEW_LINE continue NEW_LINE DEDENT last_card = ba [ - 1 ] NEW_LINE if flag : NEW_LINE INDENT x = bisect . bisect_left ( tc , last_card ) NEW_LINE flag = False NEW_LINE try : NEW_LINE INDENT tmp = tc . pop ( x ) NEW_LINE DEDENT except IndexError : NEW_LINE INDENT ba = [ ] NEW_LINE continue NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT x = bisect . bisect_left ( hc , last_card ) NEW_LINE flag = True NEW_LINE try : NEW_LINE INDENT tmp = hc . pop ( x ) NEW_LINE DEDENT except IndexError : NEW_LINE INDENT ba = [ ] NEW_LINE continue NEW_LINE DEDENT DEDENT ba . append ( tmp ) NEW_LINE DEDENT print ( len ( hc ) ) NEW_LINE print ( len ( tc ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_71_A", "sol": 0, "python_code": "def getnumbers ( n ) :\n    divisor = [ ]\n    for i in range ( 2 , n + 1 ) :\n        while ( n % i == 0 ) :\n            divisor.append ( i )\n            n //= i\n    if ( n != 1 ) :\n        divisor.append ( n )\n    a , b , c , size = 0 , 0 , 0 , 0\n    a = b = c = 1\n    size = len ( divisor )\n    for i in range ( size ) :\n        if ( a == 1 ) :\n            a = a * divisor [ i ]\n        elif ( b == 1 or b == a ) :\n            b = b * divisor [ i ]\n        else :\n            c = c * divisor [ i ]\n    if ( a == 1 or b == 1 or c == 1 or a == b or b == c or a == c ) :\n        print ( \"-1\" )\n    else :\n        print ( a , b , c )\nn = 64\ngetnumbers ( n )\n", "python_code_tokenized": "def getnumbers ( n ) : NEW_LINE INDENT divisor = [ ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT divisor . append ( i ) NEW_LINE n //= i NEW_LINE DEDENT DEDENT if ( n != 1 ) : NEW_LINE INDENT divisor . append ( n ) NEW_LINE DEDENT a , b , c , size = 0 , 0 , 0 , 0 NEW_LINE a = b = c = 1 NEW_LINE size = len ( divisor ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( a == 1 ) : NEW_LINE INDENT a = a * divisor [ i ] NEW_LINE DEDENT elif ( b == 1 or b == a ) : NEW_LINE INDENT b = b * divisor [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT c = c * divisor [ i ] NEW_LINE DEDENT DEDENT if ( a == 1 or b == 1 or c == 1 or a == b or b == c or a == c ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a , b , c ) NEW_LINE DEDENT DEDENT n = 64 NEW_LINE getnumbers ( n ) NEW_LINE"}
{"id": "geeksforgeeks_226_A", "sol": 0, "python_code": "def totalways ( arr , n ) :\n    cnt = dict ( )\n    for i in range ( n ) :\n        cnt [ arr [ i ] ] = cnt.get ( arr [ i ] , 0 ) + 1\n    if ( n % 2 == 1 ) :\n        start , endd = 0 , n - 1\n        for i in range ( start , endd + 1 , 2 ) :\n            if ( i == 0 ) :\n                if ( cnt [ i ] != 1 ) :\n                    return 0\n            else :\n                if ( cnt [ i ] != 2 ) :\n                    return 0\n        ways = 1\n        start = 2\n        endd = n - 1\n        for i in range ( start , endd + 1 , 2 ) :\n            ways = ways * 2\n        return ways\n    elif ( n % 2 == 0 ) :\n        start = 1\n        endd = n - 1\n        for i in range ( 1 , endd + 1 , 2 ) :\n            if ( cnt [ i ] != 2 ) :\n                return 0\n        ways = 1\n        for i in range ( start , endd + 1 , 2 ) :\n            ways = ways * 2\n        return ways\nN = 5\narr = [ 2 , 4 , 4 , 0 , 2 ]\nprint ( totalways ( arr , N ) )\n", "python_code_tokenized": "def totalways ( arr , n ) : NEW_LINE INDENT cnt = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ arr [ i ] ] = cnt . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT start , endd = 0 , n - 1 NEW_LINE for i in range ( start , endd + 1 , 2 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( cnt [ i ] != 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( cnt [ i ] != 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT ways = 1 NEW_LINE start = 2 NEW_LINE endd = n - 1 NEW_LINE for i in range ( start , endd + 1 , 2 ) : NEW_LINE INDENT ways = ways * 2 NEW_LINE DEDENT return ways NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT start = 1 NEW_LINE endd = n - 1 NEW_LINE for i in range ( 1 , endd + 1 , 2 ) : NEW_LINE INDENT if ( cnt [ i ] != 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ways = 1 NEW_LINE for i in range ( start , endd + 1 , 2 ) : NEW_LINE INDENT ways = ways * 2 NEW_LINE DEDENT return ways NEW_LINE DEDENT DEDENT N = 5 NEW_LINE arr = [ 2 , 4 , 4 , 0 , 2 ] NEW_LINE print ( totalways ( arr , N ) ) NEW_LINE"}
{"id": "codeforces_391_B", "sol": 0, "python_code": "t = { }\nfor i , c in enumerate ( input ( ) ) :\n    if c not in t : t [ c ] = ( i , 1 )\n    elif ( t [ c ] [ 0 ] - i ) & 1 : t [ c ] = ( i , t [ c ] [ 1 ] + 1 )\nprint ( max ( b for a , b in t.values ( ) ) )\n", "python_code_tokenized": "t = { } NEW_LINE for i , c in enumerate ( input ( ) ) : NEW_LINE INDENT if c not in t : t [ c ] = ( i , 1 ) NEW_LINE elif ( t [ c ] [ 0 ] - i ) & 1 : t [ c ] = ( i , t [ c ] [ 1 ] + 1 ) NEW_LINE DEDENT print ( max ( b for a , b in t . values ( ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_5052_A", "sol": 0, "python_code": "def findStrictlyIncreasingNum ( start , out , n ) :\n    if ( n == 0 ) :\n        print ( out , end = \"\" )\n        return\n    for i in range ( start , 10 ) :\n        str1 = out + str ( i )\n        findStrictlyIncreasingNum ( i + 1 , str1 , n - 1 )\nn = 3\nfindStrictlyIncreasingNum ( 0 , \"\" , n )\n", "python_code_tokenized": "def findStrictlyIncreasingNum ( start , out , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT print ( out , end = \" \u2581 \" ) NEW_LINE return NEW_LINE DEDENT for i in range ( start , 10 ) : NEW_LINE INDENT str1 = out + str ( i ) NEW_LINE findStrictlyIncreasingNum ( i + 1 , str1 , n - 1 ) NEW_LINE DEDENT DEDENT n = 3 NEW_LINE findStrictlyIncreasingNum ( 0 , \" \" , n ) NEW_LINE"}
{"id": "geeksforgeeks_3473_A", "sol": 0, "python_code": "def CountWords ( str , k ) :\n    sum = 0\n    NumberOfWords = 0\n    counter = 0\n    l = len ( str )\n    for i in range ( l ) :\n        if ( str [ i ] == ' ' ) :\n            if ( sum < k ) :\n                counter += 1\n            sum = 0\n            NumberOfWords += 1\n        else :\n            sum += ord ( str [ i ] )\n    NumberOfWords += 1\n    if ( sum < k ) :\n        counter += 1\n    print ( \"Number of words having sum of ASCII\" , \"values less than k =\" , counter )\n    print ( \"Number of words having sum of ASCII values\" , \"greater than or equal to k =\" , NumberOfWords - counter )\nif __name__ == \"__main__\" :\n    str = \"Learn how to code\"\n    k = 400\n    CountWords ( str , k )\n", "python_code_tokenized": "def CountWords ( str , k ) : NEW_LINE INDENT sum = 0 NEW_LINE NumberOfWords = 0 NEW_LINE counter = 0 NEW_LINE l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] == ' \u2581 ' ) : NEW_LINE INDENT if ( sum < k ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT sum = 0 NEW_LINE NumberOfWords += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += ord ( str [ i ] ) NEW_LINE DEDENT DEDENT NumberOfWords += 1 NEW_LINE if ( sum < k ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT print ( \" Number \u2581 of \u2581 words \u2581 having \u2581 sum \u2581 of \u2581 ASCII \" , \" values \u2581 less \u2581 than \u2581 k \u2581 = \" , counter ) NEW_LINE print ( \" Number \u2581 of \u2581 words \u2581 having \u2581 sum \u2581 of \u2581 ASCII \u2581 values \" , \" greater \u2581 than \u2581 or \u2581 equal \u2581 to \u2581 k \u2581 = \" , NumberOfWords - counter ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" Learn \u2581 how \u2581 to \u2581 code \" NEW_LINE k = 400 NEW_LINE CountWords ( str , k ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC090_A", "sol": 0, "python_code": "mat = [ input ( ) for _ in range ( 3 ) ]\nprint ( mat [ 0 ] [ 0 ] , mat [ 1 ] [ 1 ] , mat [ 2 ] [ 2 ] , sep = '' )\n", "python_code_tokenized": "mat = [ input ( ) for _ in range ( 3 ) ] NEW_LINE print ( mat [ 0 ] [ 0 ] , mat [ 1 ] [ 1 ] , mat [ 2 ] [ 2 ] , sep = ' ' ) NEW_LINE"}
{"id": "geeksforgeeks_1239_A", "sol": 0, "python_code": "def trianglearea ( l , b ) :\n    if ( l < 0 or b < 0 ) :\n        return - 1\n    area = ( l * b ) / 2\n    return area\nl = 5\nb = 4\nprint ( trianglearea ( l , b ) )\n", "python_code_tokenized": "def trianglearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = ( l * b ) / 2 NEW_LINE return area NEW_LINE DEDENT l = 5 NEW_LINE b = 4 NEW_LINE print ( trianglearea ( l , b ) ) NEW_LINE"}
{"id": "leetcode_697_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def findShortestSubArray ( self , nums ) :\n        left , right , count = { } , { } , { }\n        for i , x in enumerate ( nums ) :\n            if x not in left : left [ x ] = i\n            right [ x ] = i\n            count [ x ] = count.get ( x , 0 ) + 1\n        ans = len ( nums )\n        degree = max ( count.values ( ) )\n        for x in count :\n            if count [ x ] == degree :\n                ans = min ( ans , right [ x ] - left [ x ] + 1 )\n        return ans\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def findShortestSubArray ( self , nums ) : NEW_LINE INDENT left , right , count = { } , { } , { } NEW_LINE for i , x in enumerate ( nums ) : NEW_LINE INDENT if x not in left : left [ x ] = i NEW_LINE right [ x ] = i NEW_LINE count [ x ] = count . get ( x , 0 ) + 1 NEW_LINE DEDENT ans = len ( nums ) NEW_LINE degree = max ( count . values ( ) ) NEW_LINE for x in count : NEW_LINE INDENT if count [ x ] == degree : NEW_LINE INDENT ans = min ( ans , right [ x ] - left [ x ] + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00230_A", "sol": 0, "python_code": "from collections import deque\ndef bfs ( bldg ) :\n    dict = { }\n    que = deque ( [ ( bldg [ 0 ] [ 0 ] , 0 , 0 ) , ( bldg [ 1 ] [ 0 ] , 1 , 0 ) ] )\n    while len ( que ) :\n        h , b , t = que.popleft ( )\n        try :\n            if dict [ ( h , b ) ] <= t :\n                continue\n        except KeyError :\n            dict [ ( h , b ) ] = t\n        if h == len ( bldg [ 0 ] ) - 3 :\n            return t\n        t += 1\n        if 100 < t :\n            break\n        que.append ( ( bldg [ b ^ 1 ] [ h + 2 ] , b ^ 1 , t ) )\n    return 'NA'\ndef building ( ) :\n    bldg = f.readline ( ).split ( ) + [ '2' , '2' ]\n    scaffold = 0\n    for i in range ( len ( bldg ) ) :\n        if '2' == bldg [ i ] :\n            bldg [ i ] = scaffold\n        else :\n            scaffold = i\n        if '0' == bldg [ i ] :\n            bldg [ i ] = i\n    scaffold = None\n    for i in reversed ( range ( len ( bldg ) ) ) :\n        if '1' == bldg [ i ] :\n            if scaffold is None :\n                scaffold = i\n            bldg [ i ] = scaffold\n        else :\n            scaffold = None\n    return bldg\nimport sys\nf = sys.stdin\nwhile True :\n    n = int ( f.readline ( ) )\n    if n == 0 :\n        break\n    print ( bfs ( [ building ( ) , building ( ) ] ) )\n", "python_code_tokenized": "from collections import deque NEW_LINE def bfs ( bldg ) : NEW_LINE INDENT dict = { } NEW_LINE que = deque ( [ ( bldg [ 0 ] [ 0 ] , 0 , 0 ) , ( bldg [ 1 ] [ 0 ] , 1 , 0 ) ] ) NEW_LINE while len ( que ) : NEW_LINE INDENT h , b , t = que . popleft ( ) NEW_LINE try : NEW_LINE INDENT if dict [ ( h , b ) ] <= t : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT except KeyError : NEW_LINE INDENT dict [ ( h , b ) ] = t NEW_LINE DEDENT if h == len ( bldg [ 0 ] ) - 3 : NEW_LINE INDENT return t NEW_LINE DEDENT t += 1 NEW_LINE if 100 < t : NEW_LINE INDENT break NEW_LINE DEDENT que . append ( ( bldg [ b ^ 1 ] [ h + 2 ] , b ^ 1 , t ) ) NEW_LINE DEDENT return ' NA ' NEW_LINE DEDENT def building ( ) : NEW_LINE INDENT bldg = f . readline ( ) . split ( ) + [ '2' , '2' ] NEW_LINE scaffold = 0 NEW_LINE for i in range ( len ( bldg ) ) : NEW_LINE INDENT if '2' == bldg [ i ] : NEW_LINE INDENT bldg [ i ] = scaffold NEW_LINE DEDENT else : NEW_LINE INDENT scaffold = i NEW_LINE DEDENT if '0' == bldg [ i ] : NEW_LINE INDENT bldg [ i ] = i NEW_LINE DEDENT DEDENT scaffold = None NEW_LINE for i in reversed ( range ( len ( bldg ) ) ) : NEW_LINE INDENT if '1' == bldg [ i ] : NEW_LINE INDENT if scaffold is None : NEW_LINE INDENT scaffold = i NEW_LINE DEDENT bldg [ i ] = scaffold NEW_LINE DEDENT else : NEW_LINE INDENT scaffold = None NEW_LINE DEDENT DEDENT return bldg NEW_LINE DEDENT import sys NEW_LINE f = sys . stdin NEW_LINE while True : NEW_LINE INDENT n = int ( f . readline ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( bfs ( [ building ( ) , building ( ) ] ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1320_A", "sol": 0, "python_code": "def calSum ( n ) :\n    a = 3\n    b = 0\n    c = 2\n    if ( n == 0 ) :\n        return 3\n    if ( n == 1 ) :\n        return 3\n    if ( n == 2 ) :\n        return 5\n    sum = 5\n    while ( n > 2 ) :\n        d = a + b\n        sum = sum + d\n        a = b\n        b = c\n        c = d\n        n = n - 1\n    return sum\nn = 9\nprint ( calSum ( n ) )\n", "python_code_tokenized": "def calSum ( n ) : NEW_LINE INDENT a = 3 NEW_LINE b = 0 NEW_LINE c = 2 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT sum = 5 NEW_LINE while ( n > 2 ) : NEW_LINE INDENT d = a + b NEW_LINE sum = sum + d NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE n = n - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 9 NEW_LINE print ( calSum ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3316_A", "sol": 0, "python_code": "N = 3\ndef minimumflip ( mat , n ) :\n    transpose = [ [ 0 ] * n ] * n\n    for i in range ( n ) :\n        for j in range ( n ) :\n            transpose [ i ] [ j ] = mat [ j ] [ i ]\n    flip = 0\n    for i in range ( n ) :\n        for j in range ( n ) :\n            if transpose [ i ] [ j ] != mat [ i ] [ j ] :\n                flip += 1\n    return int ( flip / 2 )\nn = 3\nmat = [ [ 0 , 0 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] ]\nprint ( minimumflip ( mat , n ) )\n", "python_code_tokenized": "N = 3 NEW_LINE def minimumflip ( mat , n ) : NEW_LINE INDENT transpose = [ [ 0 ] * n ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT transpose [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE DEDENT DEDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if transpose [ i ] [ j ] != mat [ i ] [ j ] : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( flip / 2 ) NEW_LINE DEDENT n = 3 NEW_LINE mat = [ [ 0 , 0 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] ] NEW_LINE print ( minimumflip ( mat , n ) ) NEW_LINE"}
{"id": "codeforces_1174_A", "sol": 0, "python_code": "from sys import stdin , stdout\nfrom collections import Counter\nstr_stdin = lambda : stdin.readline ( ) [ : - 1 ]\nstrs_stdin = lambda : list ( map ( str , stdin.readline ( ).split ( ) ) )\nint_stdin = lambda : int ( stdin.readline ( ) )\nints_stdin = lambda : map ( int , stdin.readline ( ).split ( ) )\nint_list_stdin = lambda : list ( map ( int , stdin.readline ( ).split ( ) ) )\ndef output ( val ) :\n    if type ( val ) is list :\n        length = len ( val )\n        for elem in range ( length ) : stdout.write ( f\"{val[elem]}\" + \" \\n\" [ ( length - 1 ) == elem ] )\n    else : stdout.write ( f\"{val}\\n\" )\ndef solve ( ) :\n    pass\ndef main ( ) :\n    n = int_stdin ( )\n    nums = sorted ( int_list_stdin ( ) )\n    lSum = 0\n    rSum = 0\n    for i in range ( n ) :\n        lSum += nums [ i ]\n        rSum += nums [ n + i ]\n    if lSum == rSum :\n        return - 1\n    return nums\nif __name__ == \"__main__\" : output ( main ( ) )\n", "python_code_tokenized": "from sys import stdin , stdout NEW_LINE from collections import Counter NEW_LINE str_stdin = lambda : stdin . readline ( ) [ : - 1 ] NEW_LINE strs_stdin = lambda : list ( map ( str , stdin . readline ( ) . split ( ) ) ) NEW_LINE int_stdin = lambda : int ( stdin . readline ( ) ) NEW_LINE ints_stdin = lambda : map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE int_list_stdin = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE def output ( val ) : NEW_LINE INDENT if type ( val ) is list : NEW_LINE INDENT length = len ( val ) NEW_LINE for elem in range ( length ) : stdout . write ( f \" { val [ elem ] } \" + \" \u2581 \\n \" [ ( length - 1 ) == elem ] ) NEW_LINE DEDENT else : stdout . write ( f \" { val } \\n \" ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT pass NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int_stdin ( ) NEW_LINE nums = sorted ( int_list_stdin ( ) ) NEW_LINE lSum = 0 NEW_LINE rSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lSum += nums [ i ] NEW_LINE rSum += nums [ n + i ] NEW_LINE DEDENT if lSum == rSum : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return nums NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : output ( main ( ) ) NEW_LINE"}
{"id": "codeforces_807_A", "sol": 0, "python_code": "def rating ( ) :\n    n = int ( input ( ) )\n    c = 0\n    x = [ ]\n    y = [ ]\n    for i in range ( n ) :\n        a , b = map ( int , input ( ).split ( ) )\n        x.append ( a )\n        y.append ( b )\n        if a != b :\n            c = 1\n    if ( c == 1 ) :\n        print ( \"rated\" )\n        return 0\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            if ( x [ i ] < x [ j ] ) :\n                c = - 1\n    if c == - 1 :\n        print ( \"unrated\" )\n    else :\n        print ( \"maybe\" )\n    return 0\nrating ( )\n", "python_code_tokenized": "def rating ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE c = 0 NEW_LINE x = [ ] NEW_LINE y = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE x . append ( a ) NEW_LINE y . append ( b ) NEW_LINE if a != b : NEW_LINE INDENT c = 1 NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT print ( \" rated \" ) NEW_LINE return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( x [ i ] < x [ j ] ) : NEW_LINE INDENT c = - 1 NEW_LINE DEDENT DEDENT DEDENT if c == - 1 : NEW_LINE INDENT print ( \" unrated \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" maybe \" ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT rating ( ) NEW_LINE"}
{"id": "aizu_p01213_A", "sol": 0, "python_code": "def lcs ( x , y , pre_lcs , pre_lcs_len ) :\n    pm = dict ( ( zip ( 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' , [ 0 ] * 26 ) ) )\n    for c in pm :\n        for i , xc in enumerate ( x ) :\n            if c == xc :\n                pm [ c ] |= ( 1 << i )\n    V = ( 1 << len ( x ) ) - 1\n    rec = [ ]\n    for yc in y :\n        V = ( ( V + ( V & pm [ yc ] ) ) | ( V & ~ pm [ yc ] ) )\n        rec.append ( bin ( V ) [ - len ( x ) : ] )\n    lcs_len = bin ( V ) [ - len ( x ) : ].count ( '0' )\n    if lcs_len > pre_lcs_len :\n        rx = x [ : : - 1 ]\n        lcs = ''\n        idx = 0\n        for v , yc in zip ( rec [ : : - 1 ] , reversed ( y ) ) :\n            idx = v.find ( '0' , idx )\n            if yc == rx [ idx ] :\n                lcs += yc\n                if len ( lcs ) == lcs_len :\n                    return ( lcs [ : : - 1 ] , lcs_len )\n                idx += 1\n    else :\n        return ( pre_lcs , pre_lcs_len )\nfrom sys import stdin\ndef solve ( ) :\n    file_input = stdin\n    ans_out = [ ]\n    for s in file_input :\n        s = s.rstrip ( )\n        if s [ 0 ] == '#' :\n            break\n        s_len = len ( s )\n        sep = s_len // 2\n        ans , ans_len = lcs ( s [ : sep ] , s [ sep : ] , '' , 0 )\n        while sep > ans_len :\n            ans , ans_len = lcs ( s [ : - sep ] , s [ - sep : ] , ans , ans_len )\n            sep -= 1\n            ans , ans_len = lcs ( s [ : sep ] , s [ sep : ] , ans , ans_len )\n        ans_out.append ( ans )\n    print ( * ans_out , sep = '\\n' )\nsolve ( )\n", "python_code_tokenized": "def lcs ( x , y , pre_lcs , pre_lcs_len ) : NEW_LINE INDENT pm = dict ( ( zip ( ' ABCDEFGHIJKLMNOPQRSTUVWXYZ ' , [ 0 ] * 26 ) ) ) NEW_LINE for c in pm : NEW_LINE INDENT for i , xc in enumerate ( x ) : NEW_LINE INDENT if c == xc : NEW_LINE INDENT pm [ c ] |= ( 1 << i ) NEW_LINE DEDENT DEDENT DEDENT V = ( 1 << len ( x ) ) - 1 NEW_LINE rec = [ ] NEW_LINE for yc in y : NEW_LINE INDENT V = ( ( V + ( V & pm [ yc ] ) ) | ( V & ~ pm [ yc ] ) ) NEW_LINE rec . append ( bin ( V ) [ - len ( x ) : ] ) NEW_LINE DEDENT lcs_len = bin ( V ) [ - len ( x ) : ] . count ( '0' ) NEW_LINE if lcs_len > pre_lcs_len : NEW_LINE INDENT rx = x [ : : - 1 ] NEW_LINE lcs = ' ' NEW_LINE idx = 0 NEW_LINE for v , yc in zip ( rec [ : : - 1 ] , reversed ( y ) ) : NEW_LINE INDENT idx = v . find ( '0' , idx ) NEW_LINE if yc == rx [ idx ] : NEW_LINE INDENT lcs += yc NEW_LINE if len ( lcs ) == lcs_len : NEW_LINE INDENT return ( lcs [ : : - 1 ] , lcs_len ) NEW_LINE DEDENT idx += 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT return ( pre_lcs , pre_lcs_len ) NEW_LINE DEDENT DEDENT from sys import stdin NEW_LINE def solve ( ) : NEW_LINE INDENT file_input = stdin NEW_LINE ans_out = [ ] NEW_LINE for s in file_input : NEW_LINE INDENT s = s . rstrip ( ) NEW_LINE if s [ 0 ] == ' # ' : NEW_LINE INDENT break NEW_LINE DEDENT s_len = len ( s ) NEW_LINE sep = s_len // 2 NEW_LINE ans , ans_len = lcs ( s [ : sep ] , s [ sep : ] , ' ' , 0 ) NEW_LINE while sep > ans_len : NEW_LINE INDENT ans , ans_len = lcs ( s [ : - sep ] , s [ - sep : ] , ans , ans_len ) NEW_LINE sep -= 1 NEW_LINE ans , ans_len = lcs ( s [ : sep ] , s [ sep : ] , ans , ans_len ) NEW_LINE DEDENT ans_out . append ( ans ) NEW_LINE DEDENT print ( * ans_out , sep = ' \\n ' ) NEW_LINE DEDENT solve ( ) NEW_LINE"}
{"id": "aizu_p00020_A", "sol": 0, "python_code": "import sys\nline = sys.stdin.readline ( )\nret = \"\"\nfor s in line :\n    ret += s.upper ( )\nprint ( ret , end = \"\" )\n", "python_code_tokenized": "import sys NEW_LINE line = sys . stdin . readline ( ) NEW_LINE ret = \" \" NEW_LINE for s in line : NEW_LINE INDENT ret += s . upper ( ) NEW_LINE DEDENT print ( ret , end = \" \" ) NEW_LINE"}
{"id": "geeksforgeeks_1374_A", "sol": 0, "python_code": "MAX = 1000000\nsieve_Prime = [ 0 for i in range ( MAX + 4 ) ]\nsieve_count = [ 0 for i in range ( MAX + 4 ) ]\ndef form_sieve ( ) :\n    sieve_Prime [ 1 ] = 1\n    for i in range ( 2 , MAX + 1 ) :\n        if sieve_Prime [ i ] == 0 :\n            for j in range ( i * 2 , MAX + 1 , i ) :\n                if sieve_Prime [ j ] == 0 :\n                    sieve_Prime [ j ] = 1\n                    sieve_count [ i ] += 1\nform_sieve ( )\nn = 2\nprint ( \"Count =\" , sieve_count [ n ] + 1 )\nn = 3\nprint ( \"Count =\" , sieve_count [ n ] + 1 )\n", "python_code_tokenized": "MAX = 1000000 NEW_LINE sieve_Prime = [ 0 for i in range ( MAX + 4 ) ] NEW_LINE sieve_count = [ 0 for i in range ( MAX + 4 ) ] NEW_LINE def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if sieve_Prime [ i ] == 0 : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if sieve_Prime [ j ] == 0 : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT form_sieve ( ) NEW_LINE n = 2 NEW_LINE print ( \" Count \u2581 = \" , sieve_count [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( \" Count \u2581 = \" , sieve_count [ n ] + 1 ) NEW_LINE"}
{"id": "codeforces_15_A", "sol": 0, "python_code": "n , t = map ( int , input ( ).split ( ) )\ns = [ ] ; p = 2\nfor i in range ( n ) :\n    x , d = map ( int , input ( ).split ( ) )\n    s.append ( [ x - d / 2 , x + d / 2 ] )\ns.sort ( )\nfor j in range ( 1 , len ( s ) ) :\n    if s [ j ] [ 0 ] - s [ j - 1 ] [ 1 ] > t :\n        p += 2\n    elif s [ j ] [ 0 ] - s [ j - 1 ] [ 1 ] == t :\n        p += 1\nprint ( str ( p ) )\n", "python_code_tokenized": "n , t = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] ; p = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , d = map ( int , input ( ) . split ( ) ) NEW_LINE s . append ( [ x - d / 2 , x + d / 2 ] ) NEW_LINE DEDENT s . sort ( ) NEW_LINE for j in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ j ] [ 0 ] - s [ j - 1 ] [ 1 ] > t : NEW_LINE INDENT p += 2 NEW_LINE DEDENT elif s [ j ] [ 0 ] - s [ j - 1 ] [ 1 ] == t : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT print ( str ( p ) ) NEW_LINE"}
{"id": "codeforces_500_A", "sol": 0, "python_code": "n , t = list ( map ( int , input ( ).split ( ) ) )\na = list ( map ( int , input ( ).split ( ) ) )\nf = False\nc = 1\ni = 0\nwhile True :\n    c = ( i + 1 ) + a [ i ]\n    if ( c - 1 ) < i :\n        break\n    if c == t :\n        f = True\n        break\n    if c > t :\n        break\n    i = c - 1\nif f :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "n , t = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE f = False NEW_LINE c = 1 NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT c = ( i + 1 ) + a [ i ] NEW_LINE if ( c - 1 ) < i : NEW_LINE INDENT break NEW_LINE DEDENT if c == t : NEW_LINE INDENT f = True NEW_LINE break NEW_LINE DEDENT if c > t : NEW_LINE INDENT break NEW_LINE DEDENT i = c - 1 NEW_LINE DEDENT if f : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "codejam_11_03", "sol": 0, "python_code": "import sys , re\nfrom pprint import pprint\nfi = open ( 'C-large.in' , 'r' )\nfo = open ( 'C-large.out' , 'w' )\nt = int ( fi.readline ( ) )\nfor _ in range ( 1 , t + 1 ) :\n    n = int ( fi.readline ( ) )\n    v = map ( int , fi.readline ( ).split ( ) )\n    s = 0\n    ss = 0\n    for x in v :\n        s ^= x\n        ss += x\n    if s > 0 :\n        fo.write ( 'Case #%d: NO\\n' % _ )\n    else :\n        fo.write ( 'Case #%d: %d\\n' % ( _ , ss - min ( v ) ) )\nfi.close ( )\nfo.close ( )\n", "python_code_tokenized": "import sys , re NEW_LINE from pprint import pprint NEW_LINE fi = open ( ' C - large . in ' , ' r ' ) NEW_LINE fo = open ( ' C - large . out ' , ' w ' ) NEW_LINE t = int ( fi . readline ( ) ) NEW_LINE for _ in range ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( fi . readline ( ) ) NEW_LINE v = map ( int , fi . readline ( ) . split ( ) ) NEW_LINE s = 0 NEW_LINE ss = 0 NEW_LINE for x in v : NEW_LINE INDENT s ^= x NEW_LINE ss += x NEW_LINE DEDENT if s > 0 : NEW_LINE INDENT fo . write ( ' Case \u2581 # % d : \u2581 NO \\n ' % _ ) NEW_LINE DEDENT else : NEW_LINE INDENT fo . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( _ , ss - min ( v ) ) ) NEW_LINE DEDENT DEDENT fi . close ( ) NEW_LINE fo . close ( ) NEW_LINE"}
{"id": "geeksforgeeks_729_A", "sol": 0, "python_code": "def NumberOfRectangles ( n , m ) :\n    if ( n % 2 == 0 ) :\n        return ( n / 2 ) * m\n    elif ( m % 2 == 0 ) :\n        return ( m // 2 ) * n\n    return ( n * m - 1 ) // 2\nif __name__ == \"__main__\" :\n    n = 3\n    m = 3\n    print ( NumberOfRectangles ( n , m ) )\n", "python_code_tokenized": "def NumberOfRectangles ( n , m ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return ( n / 2 ) * m NEW_LINE DEDENT elif ( m % 2 == 0 ) : NEW_LINE INDENT return ( m // 2 ) * n NEW_LINE DEDENT return ( n * m - 1 ) // 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE m = 3 NEW_LINE print ( NumberOfRectangles ( n , m ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_629_A", "sol": 0, "python_code": "def A ( m , n , s = \"% s\" ) :\n    print ( s % ( \"A(% d, % d)\" % ( m , n ) ) )\n    if m == 0 :\n        return n + 1\n    if n == 0 :\n        return A ( m - 1 , 1 , s )\n    n2 = A ( m , n - 1 , s % ( \"A(% d, %% s)\" % ( m - 1 ) ) )\n    return A ( m - 1 , n2 , s )\nprint ( A ( 1 , 2 ) )\n", "python_code_tokenized": "def A ( m , n , s = \" % \u2581 s \" ) : NEW_LINE INDENT print ( s % ( \" A ( % \u2581 d , \u2581 % \u2581 d ) \" % ( m , n ) ) ) NEW_LINE if m == 0 : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return A ( m - 1 , 1 , s ) NEW_LINE DEDENT n2 = A ( m , n - 1 , s % ( \" A ( % \u2581 d , \u2581 % % \u2581 s ) \" % ( m - 1 ) ) ) NEW_LINE return A ( m - 1 , n2 , s ) NEW_LINE DEDENT print ( A ( 1 , 2 ) ) NEW_LINE"}
{"id": "geeksforgeeks_2712_A", "sol": 0, "python_code": "def permutation ( arr , N ) :\n    hash = [ 0 ] * ( N + 1 ) ;\n    for i in range ( N ) :\n        hash [ arr [ i ] ] += 1 ;\n    for i in range ( 1 , N + 1 ) :\n        if ( hash [ i ] != 1 ) :\n            return \"No\" ;\n    return \"Yes\" ;\nif __name__ == \"__main__\" :\n    arr = [ 1 , 1 , 5 , 5 , 3 ] ;\n    n = len ( arr ) ;\n    print ( permutation ( arr , n ) ) ;\n", "python_code_tokenized": "def permutation ( arr , N ) : NEW_LINE INDENT hash = [ 0 ] * ( N + 1 ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 ; NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( hash [ i ] != 1 ) : NEW_LINE INDENT return \" No \" ; NEW_LINE DEDENT DEDENT return \" Yes \" ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 5 , 5 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( permutation ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_673_A", "sol": 0, "python_code": "def result ( n : int , a : list ) -> int :\n    valid_min = 15\n    if a [ 0 ] > valid_min :\n        return valid_min\n    for i in range ( n ) :\n        if a [ i ] <= valid_min :\n            valid_min = 15 + a [ i ]\n    return 90 if valid_min >= 90 else valid_min\nif __name__ == \"__main__\" :\n    n = int ( input ( ) )\n    a = list ( map ( int , input ( ).split ( ) ) )\n    print ( result ( n , a ) )\n", "python_code_tokenized": "def result ( n : int , a : list ) -> int : NEW_LINE INDENT valid_min = 15 NEW_LINE if a [ 0 ] > valid_min : NEW_LINE INDENT return valid_min NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= valid_min : NEW_LINE INDENT valid_min = 15 + a [ i ] NEW_LINE DEDENT DEDENT return 90 if valid_min >= 90 else valid_min NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( result ( n , a ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_259_A", "sol": 0, "python_code": "def SquareCube ( N ) :\n    cnt , i = 0 , 1\n    while ( i ** 6 <= N ) :\n        cnt += 1\n        i += 1\n    return cnt\nN = 100000\nprint ( SquareCube ( N ) )\n", "python_code_tokenized": "def SquareCube ( N ) : NEW_LINE INDENT cnt , i = 0 , 1 NEW_LINE while ( i ** 6 <= N ) : NEW_LINE INDENT cnt += 1 NEW_LINE i += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT N = 100000 NEW_LINE print ( SquareCube ( N ) ) NEW_LINE"}
{"id": "geeksforgeeks_5036_A", "sol": 0, "python_code": "def constructPalin ( string , l ) :\n    string = list ( string )\n    i = - 1\n    j = l\n    while i < j :\n        i += 1\n        j -= 1\n        if ( string [ i ] == string [ j ] and string [ i ] != '*' ) :\n            continue\n        elif ( string [ i ] == string [ j ] and string [ i ] == '*' ) :\n            string [ i ] = 'a'\n            string [ j ] = 'a'\n            continue\n        elif string [ i ] == '*' :\n            string [ i ] = string [ j ]\n            continue\n        elif string [ j ] == '*' :\n            string [ j ] = string [ i ]\n            continue\n        print ( \"Not Possible\" )\n        return \"\"\n    return ''.join ( string )\nif __name__ == \"__main__\" :\n    string = \"bca*xc**b\"\n    l = len ( string )\n    print ( constructPalin ( string , l ) )\n", "python_code_tokenized": "def constructPalin ( string , l ) : NEW_LINE INDENT string = list ( string ) NEW_LINE i = - 1 NEW_LINE j = l NEW_LINE while i < j : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE if ( string [ i ] == string [ j ] and string [ i ] != ' * ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( string [ i ] == string [ j ] and string [ i ] == ' * ' ) : NEW_LINE INDENT string [ i ] = ' a ' NEW_LINE string [ j ] = ' a ' NEW_LINE continue NEW_LINE DEDENT elif string [ i ] == ' * ' : NEW_LINE INDENT string [ i ] = string [ j ] NEW_LINE continue NEW_LINE DEDENT elif string [ j ] == ' * ' : NEW_LINE INDENT string [ j ] = string [ i ] NEW_LINE continue NEW_LINE DEDENT print ( \" Not \u2581 Possible \" ) NEW_LINE return \" \" NEW_LINE DEDENT return ' ' . join ( string ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" bca * xc * * b \" NEW_LINE l = len ( string ) NEW_LINE print ( constructPalin ( string , l ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ARC070_B", "sol": 0, "python_code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nimport itertools\nN , K , * A = map ( int , read ( ).split ( ) )\nA = [ x if x <= K else K + 1 for x in A ]\nA.sort ( )\nmask = ( 1 << K ) - 1\ndef test ( x ) :\n    if A [ x ] > K :\n        return True\n    dp = 1\n    for a in itertools.chain ( A [ : x ] , A [ x + 1 : ] ) :\n        dp |= ( dp << a )\n        dp &= mask\n    dp >>= ( K - A [ x ] )\n    return ( dp > 0 )\nleft = - 1\nright = N\nwhile left + 1 < right :\n    x = ( left + right ) // 2\n    if test ( x ) :\n        right = x\n    else :\n        left = x\nanswer = left + 1\nprint ( answer )\n", "python_code_tokenized": "import sys NEW_LINE read = sys . stdin . buffer . read NEW_LINE readline = sys . stdin . buffer . readline NEW_LINE readlines = sys . stdin . buffer . readlines NEW_LINE import itertools NEW_LINE N , K , * A = map ( int , read ( ) . split ( ) ) NEW_LINE A = [ x if x <= K else K + 1 for x in A ] NEW_LINE A . sort ( ) NEW_LINE mask = ( 1 << K ) - 1 NEW_LINE def test ( x ) : NEW_LINE INDENT if A [ x ] > K : NEW_LINE INDENT return True NEW_LINE DEDENT dp = 1 NEW_LINE for a in itertools . chain ( A [ : x ] , A [ x + 1 : ] ) : NEW_LINE INDENT dp |= ( dp << a ) NEW_LINE dp &= mask NEW_LINE DEDENT dp >>= ( K - A [ x ] ) NEW_LINE return ( dp > 0 ) NEW_LINE DEDENT left = - 1 NEW_LINE right = N NEW_LINE while left + 1 < right : NEW_LINE INDENT x = ( left + right ) // 2 NEW_LINE if test ( x ) : NEW_LINE INDENT right = x NEW_LINE DEDENT else : NEW_LINE INDENT left = x NEW_LINE DEDENT DEDENT answer = left + 1 NEW_LINE print ( answer ) NEW_LINE"}
{"id": "geeksforgeeks_4742_A", "sol": 0, "python_code": "def Log2n ( n ) :\n    if ( n > 1 ) :\n        return ( 1 + Log2n ( n / 2 ) )\n    else :\n        return 0\ndef isPowerOfTwo ( n ) :\n    return n and ( not ( n & ( n - 1 ) ) )\ndef findPosition ( n ) :\n    if ( not isPowerOfTwo ( n ) ) :\n        return - 1\n    return Log2n ( n ) + 1\nn = 0\npos = findPosition ( n )\nif ( pos == - 1 ) :\n    print ( \"n =\" , n , \", Invalid number\" )\nelse :\n    print ( \"n = \" , n , \", Position \" , pos )\nn = 12\npos = findPosition ( n )\nif ( pos == - 1 ) :\n    print ( \"n =\" , n , \", Invalid number\" )\nelse :\n    print ( \"n = \" , n , \", Position \" , pos )\nn = 128\npos = findPosition ( n )\nif ( pos == - 1 ) :\n    print ( \"n = \" , n , \", Invalid number\" )\nelse :\n    print ( \"n = \" , n , \", Position \" , pos )\n", "python_code_tokenized": "def Log2n ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT return ( 1 + Log2n ( n / 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def isPowerOfTwo ( n ) : NEW_LINE INDENT return n and ( not ( n & ( n - 1 ) ) ) NEW_LINE DEDENT def findPosition ( n ) : NEW_LINE INDENT if ( not isPowerOfTwo ( n ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return Log2n ( n ) + 1 NEW_LINE DEDENT n = 0 NEW_LINE pos = findPosition ( n ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n \u2581 = \" , n , \" , \u2581 Invalid \u2581 number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n \u2581 = \u2581 \" , n , \" , \u2581 Position \u2581 \" , pos ) NEW_LINE DEDENT n = 12 NEW_LINE pos = findPosition ( n ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n \u2581 = \" , n , \" , \u2581 Invalid \u2581 number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n \u2581 = \u2581 \" , n , \" , \u2581 Position \u2581 \" , pos ) NEW_LINE DEDENT n = 128 NEW_LINE pos = findPosition ( n ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n \u2581 = \u2581 \" , n , \" , \u2581 Invalid \u2581 number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n \u2581 = \u2581 \" , n , \" , \u2581 Position \u2581 \" , pos ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4741_A", "sol": 0, "python_code": "def isPowerOfTwo ( n ) :\n    return ( n and ( not ( n & ( n - 1 ) ) ) )\ndef findPosition ( n ) :\n    if not isPowerOfTwo ( n ) :\n        return - 1\n    count = 0\n    while ( n ) :\n        n = n >> 1\n        count += 1\n    return count\nif __name__ == \"__main__\" :\n    n = 0\n    pos = findPosition ( n )\n    if pos == - 1 :\n        print ( \"n =\" , n , \"Invalid number\" )\n    else :\n        print ( \"n =\" , n , \"Position\" , pos )\n    n = 12\n    pos = findPosition ( n )\n    if pos == - 1 :\n        print ( \"n =\" , n , \"Invalid number\" )\n    else :\n        print ( \"n =\" , n , \"Position\" , pos )\n    n = 128\n    pos = findPosition ( n )\n    if pos == - 1 :\n        print ( \"n =\" , n , \"Invalid number\" )\n    else :\n        print ( \"n =\" , n , \"Position\" , pos )\n", "python_code_tokenized": "def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT def findPosition ( n ) : NEW_LINE INDENT if not isPowerOfTwo ( n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n = n >> 1 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 0 NEW_LINE pos = findPosition ( n ) NEW_LINE if pos == - 1 : NEW_LINE INDENT print ( \" n \u2581 = \" , n , \" Invalid \u2581 number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n \u2581 = \" , n , \" Position \" , pos ) NEW_LINE DEDENT n = 12 NEW_LINE pos = findPosition ( n ) NEW_LINE if pos == - 1 : NEW_LINE INDENT print ( \" n \u2581 = \" , n , \" Invalid \u2581 number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n \u2581 = \" , n , \" Position \" , pos ) NEW_LINE DEDENT n = 128 NEW_LINE pos = findPosition ( n ) NEW_LINE if pos == - 1 : NEW_LINE INDENT print ( \" n \u2581 = \" , n , \" Invalid \u2581 number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n \u2581 = \" , n , \" Position \" , pos ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2039_A", "sol": 0, "python_code": "def kthOdd ( arr , n , k ) :\n    for i in range ( n ) :\n        if ( arr [ i ] % 2 == 1 ) :\n            k -= 1 ;\n        if ( k == 0 ) :\n            return arr [ i ] ;\n    return - 1 ;\narr = [ 1 , 2 , 3 , 4 , 5 ] ;\nn = len ( arr ) ;\nk = 2 ;\nprint ( kthOdd ( arr , n , k ) ) ;\n", "python_code_tokenized": "def kthOdd ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return arr [ i ] ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE print ( kthOdd ( arr , n , k ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_1805_A", "sol": 0, "python_code": "def isBinary ( number ) :\n    set1 = set ( )\n    while ( number > 0 ) :\n        digit = number % 10\n        set1.add ( digit )\n        number = int ( number / 10 )\n    set1.discard ( 0 )\n    set1.discard ( 1 )\n    if ( len ( set1 ) == 0 ) :\n        return True\n    return False\nif __name__ == '__main__' :\n    n = 1000111\n    if ( isBinary ( n ) == 1 ) :\n        print ( \"true\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def isBinary ( number ) : NEW_LINE INDENT set1 = set ( ) NEW_LINE while ( number > 0 ) : NEW_LINE INDENT digit = number % 10 NEW_LINE set1 . add ( digit ) NEW_LINE number = int ( number / 10 ) NEW_LINE DEDENT set1 . discard ( 0 ) NEW_LINE set1 . discard ( 1 ) NEW_LINE if ( len ( set1 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1000111 NEW_LINE if ( isBinary ( n ) == 1 ) : NEW_LINE INDENT print ( \" true \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1031_A", "sol": 0, "python_code": "w , h , k = ( int ( i ) for i in input ( ).split ( ) )\nres = 0\nwhile w > 0 and h > 2 and k > 0 :\n    res += 2 * w + 2 * ( h - 2 )\n    w -= 4\n    h -= 4\n    k -= 1\nprint ( res )\n", "python_code_tokenized": "w , h , k = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE res = 0 NEW_LINE while w > 0 and h > 2 and k > 0 : NEW_LINE INDENT res += 2 * w + 2 * ( h - 2 ) NEW_LINE w -= 4 NEW_LINE h -= 4 NEW_LINE k -= 1 NEW_LINE DEDENT print ( res ) NEW_LINE"}
{"id": "projecteuler_p587_A", "sol": 0, "python_code": "import itertools , math\ndef compute ( ) :\n    def integral ( x ) :\n        t = x - 1.0\n        return t - ( math.sqrt ( x * ( 2.0 - x ) ) * t + math.asin ( t ) ) / 2.0\n    lsectionarea = 1.0 - math.pi / 4.0\n    for i in itertools.count ( 1 ) :\n        slope = 1.0 / i\n        a = slope ** 2 + 1.0\n        b = - 2.0 * ( slope + 1.0 )\n        c = 1.0\n        x = ( 2.0 * c ) / ( - b + math.sqrt ( b * b - 4 * a * c ) )\n        concavetrianglearea = ( x ** 2 * slope / 2 ) + ( integral ( 1.0 ) - integral ( x ) )\n        if concavetrianglearea / lsectionarea < 0.001 :\n            return str ( i )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import itertools , math NEW_LINE def compute ( ) : NEW_LINE INDENT def integral ( x ) : NEW_LINE INDENT t = x - 1.0 NEW_LINE return t - ( math . sqrt ( x * ( 2.0 - x ) ) * t + math . asin ( t ) ) / 2.0 NEW_LINE DEDENT lsectionarea = 1.0 - math . pi / 4.0 NEW_LINE for i in itertools . count ( 1 ) : NEW_LINE INDENT slope = 1.0 / i NEW_LINE a = slope ** 2 + 1.0 NEW_LINE b = - 2.0 * ( slope + 1.0 ) NEW_LINE c = 1.0 NEW_LINE x = ( 2.0 * c ) / ( - b + math . sqrt ( b * b - 4 * a * c ) ) NEW_LINE concavetrianglearea = ( x ** 2 * slope / 2 ) + ( integral ( 1.0 ) - integral ( x ) ) NEW_LINE if concavetrianglearea / lsectionarea < 0.001 : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "aizu_p01275_A", "sol": 0, "python_code": "def solve ( ) :\n    def bfs ( k ) :\n        start , goal = file_input.readline ( ).split ( )\n        if start == goal :\n            return 0\n        start = map ( int , start )\n        goal = map ( int , goal )\n        diff = [ ( g - s ) % 10 for g , s in zip ( goal , start ) ]\n        q = [ diff ]\n        checked = { tuple ( diff ) : True }\n        ans = 0\n        while q :\n            ans += 1\n            t_q = [ ]\n            for d in q :\n                for i , r in enumerate ( d ) :\n                    if r != 0 :\n                        break\n                for j in range ( i , k ) :\n                    d [ j ] -= r\n                    d [ j ] %= 10\n                    key = tuple ( d )\n                    if key in checked :\n                        continue\n                    if sum ( d ) == 0 :\n                        return ans\n                    checked [ key ] = True\n                    t_q.append ( d [ : ] )\n                q = t_q\n    from sys import stdin\n    file_input = stdin\n    while True :\n        k = int ( file_input.readline ( ) )\n        if k == 0 :\n            break\n        print ( bfs ( k ) )\nsolve ( )\n", "python_code_tokenized": "def solve ( ) : NEW_LINE INDENT def bfs ( k ) : NEW_LINE INDENT start , goal = file_input . readline ( ) . split ( ) NEW_LINE if start == goal : NEW_LINE INDENT return 0 NEW_LINE DEDENT start = map ( int , start ) NEW_LINE goal = map ( int , goal ) NEW_LINE diff = [ ( g - s ) % 10 for g , s in zip ( goal , start ) ] NEW_LINE q = [ diff ] NEW_LINE checked = { tuple ( diff ) : True } NEW_LINE ans = 0 NEW_LINE while q : NEW_LINE INDENT ans += 1 NEW_LINE t_q = [ ] NEW_LINE for d in q : NEW_LINE INDENT for i , r in enumerate ( d ) : NEW_LINE INDENT if r != 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( i , k ) : NEW_LINE INDENT d [ j ] -= r NEW_LINE d [ j ] %= 10 NEW_LINE key = tuple ( d ) NEW_LINE if key in checked : NEW_LINE INDENT continue NEW_LINE DEDENT if sum ( d ) == 0 : NEW_LINE INDENT return ans NEW_LINE DEDENT checked [ key ] = True NEW_LINE t_q . append ( d [ : ] ) NEW_LINE DEDENT q = t_q NEW_LINE DEDENT DEDENT DEDENT from sys import stdin NEW_LINE file_input = stdin NEW_LINE while True : NEW_LINE INDENT k = int ( file_input . readline ( ) ) NEW_LINE if k == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( bfs ( k ) ) NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE"}
{"id": "geeksforgeeks_2349_A", "sol": 0, "python_code": "def maxOnesIndex ( arr , n ) :\n    max_count = 0\n    max_index = 0\n    prev_zero = - 1\n    prev_prev_zero = - 1\n    for curr in range ( n ) :\n        if ( arr [ curr ] == 0 ) :\n            if ( curr - prev_prev_zero > max_count ) :\n                max_count = curr - prev_prev_zero\n                max_index = prev_zero\n            prev_prev_zero = prev_zero\n            prev_zero = curr\n    if ( n - prev_prev_zero > max_count ) :\n        max_index = prev_zero\n    return max_index\narr = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ]\nn = len ( arr )\nprint ( \"Index of 0 to be replaced is \" , maxOnesIndex ( arr , n ) )\n", "python_code_tokenized": "def maxOnesIndex ( arr , n ) : NEW_LINE INDENT max_count = 0 NEW_LINE max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if ( arr [ curr ] == 0 ) : NEW_LINE INDENT if ( curr - prev_prev_zero > max_count ) : NEW_LINE INDENT max_count = curr - prev_prev_zero NEW_LINE max_index = prev_zero NEW_LINE DEDENT prev_prev_zero = prev_zero NEW_LINE prev_zero = curr NEW_LINE DEDENT DEDENT if ( n - prev_prev_zero > max_count ) : NEW_LINE INDENT max_index = prev_zero NEW_LINE DEDENT return max_index NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Index \u2581 of \u2581 0 \u2581 to \u2581 be \u2581 replaced \u2581 is \u2581 \" , maxOnesIndex ( arr , n ) ) NEW_LINE"}
{"id": "atcoder_ABC123_A", "sol": 0, "python_code": "a = int ( input ( ) )\nb = int ( input ( ) )\nc = int ( input ( ) )\nd = int ( input ( ) )\ne = int ( input ( ) )\nk = int ( input ( ) )\nif e - a <= k :\n    print ( \"Yay!\" )\nelse :\n    print ( \":(\" )\n", "python_code_tokenized": "a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE c = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE e = int ( input ( ) ) NEW_LINE k = int ( input ( ) ) NEW_LINE if e - a <= k : NEW_LINE INDENT print ( \" Yay ! \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" : ( \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2389_A", "sol": 0, "python_code": "def tidyNum ( str , len ) :\n    for i in range ( len - 2 , - 1 , - 1 ) :\n        if ( str [ i ] > str [ i + 1 ] ) :\n            str [ i ] -= 1\n            for j in range ( i + 1 , len ) :\n                str [ j ] = 9\n    return str\nstr = [ 1 , 1 , 3 , 3 , 3 , 4 , 4 , 5 , 5 , 3 , 8 ]\nlen = len ( str )\nnum = tidyNum ( str , len )\nfor i in range ( 0 , len ) :\n    print ( str [ i ] , end = \"\" )\n", "python_code_tokenized": "def tidyNum ( str , len ) : NEW_LINE INDENT for i in range ( len - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] > str [ i + 1 ] ) : NEW_LINE INDENT str [ i ] -= 1 NEW_LINE for j in range ( i + 1 , len ) : NEW_LINE INDENT str [ j ] = 9 NEW_LINE DEDENT DEDENT DEDENT return str NEW_LINE DEDENT str = [ 1 , 1 , 3 , 3 , 3 , 4 , 4 , 5 , 5 , 3 , 8 ] NEW_LINE len = len ( str ) NEW_LINE num = tidyNum ( str , len ) NEW_LINE for i in range ( 0 , len ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_658_A", "sol": 0, "python_code": "def minAdjDifference ( arr , n ) :\n    if ( n < 2 ) : return\n    res = abs ( arr [ 1 ] - arr [ 0 ] )\n    for i in range ( 2 , n ) :\n        res = min ( res , abs ( arr [ i ] - arr [ i - 1 ] ) )\n    res = min ( res , abs ( arr [ n - 1 ] - arr [ 0 ] ) )\n    print ( \"Min Difference = \" , res )\na = [ 10 , 12 , 13 , 15 , 10 ]\nn = len ( a )\nminAdjDifference ( a , n )\n", "python_code_tokenized": "def minAdjDifference ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : return NEW_LINE res = abs ( arr [ 1 ] - arr [ 0 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT res = min ( res , abs ( arr [ i ] - arr [ i - 1 ] ) ) NEW_LINE DEDENT res = min ( res , abs ( arr [ n - 1 ] - arr [ 0 ] ) ) NEW_LINE print ( \" Min \u2581 Difference \u2581 = \u2581 \" , res ) NEW_LINE DEDENT a = [ 10 , 12 , 13 , 15 , 10 ] NEW_LINE n = len ( a ) NEW_LINE minAdjDifference ( a , n ) NEW_LINE"}
{"id": "geeksforgeeks_2756_A", "sol": 0, "python_code": "def isPlusPossible ( arr , n ) :\n    mp = dict ( )\n    for i in range ( n ) :\n        mp [ arr [ i ] ] = mp.get ( arr [ i ] , 0 ) + 1\n    foundModOne = False\n    for x in mp :\n        element = x\n        frequency = mp [ x ]\n        if ( frequency % 4 == 0 ) :\n            continue\n        if ( frequency % 4 == 1 ) :\n            if ( foundModOne == True ) :\n                return False\n            foundModOne = True\n        else :\n            return False\n    return True\narr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 , 2 ]\nn = len ( arr )\nif ( isPlusPossible ( arr , n ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def isPlusPossible ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT foundModOne = False NEW_LINE for x in mp : NEW_LINE INDENT element = x NEW_LINE frequency = mp [ x ] NEW_LINE if ( frequency % 4 == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( frequency % 4 == 1 ) : NEW_LINE INDENT if ( foundModOne == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT foundModOne = True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isPlusPossible ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_458_A", "sol": 0, "python_code": "def numberOfPaths ( m , n ) :\n    count = [ [ 0 for x in range ( m ) ] for y in range ( n ) ]\n    for i in range ( m ) :\n        count [ i ] [ 0 ] = 1 ;\n    for j in range ( n ) :\n        count [ 0 ] [ j ] = 1 ;\n    for i in range ( 1 , m ) :\n        for j in range ( 1 , n ) :\n            count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ]\n    return count [ m - 1 ] [ n - 1 ]\nm = 3\nn = 3\nprint ( numberOfPaths ( m , n ) )\n", "python_code_tokenized": "def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for x in range ( m ) ] for y in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 ; NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT m = 3 NEW_LINE n = 3 NEW_LINE print ( numberOfPaths ( m , n ) ) NEW_LINE"}
{"id": "leetcode_771_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def numJewelsInStones ( self , J , S ) :\n        if len ( J ) == 0 or len ( S ) == 0 :\n            return 0\n        j_set = set ( J )\n        ans = 0\n        for c in S :\n            if c in j_set :\n                ans += 1\n        return ans\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def numJewelsInStones ( self , J , S ) : NEW_LINE INDENT if len ( J ) == 0 or len ( S ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT j_set = set ( J ) NEW_LINE ans = 0 NEW_LINE for c in S : NEW_LINE INDENT if c in j_set : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p01866_A", "sol": 0, "python_code": "N = int ( input ( ) )\nX = input ( )\nD = int ( input ( ) )\nans = list ( X )\ndone = [ False ] * N\nfor i in range ( N ) :\n    if D == 0 :\n        break\n    if ans [ i ] == \"0\" :\n        ans [ i ] = \"1\"\n        done [ i ] = True\n        D -= 1\nfor i in range ( N ) [ : : - 1 ] :\n    if D == 0 :\n        break\n    if ans [ i ] == \"1\" and not done [ i ] :\n        ans [ i ] = \"0\"\n        D -= 1\nprint ( \"\".join ( ans ) )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE X = input ( ) NEW_LINE D = int ( input ( ) ) NEW_LINE ans = list ( X ) NEW_LINE done = [ False ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if D == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if ans [ i ] == \"0\" : NEW_LINE INDENT ans [ i ] = \"1\" NEW_LINE done [ i ] = True NEW_LINE D -= 1 NEW_LINE DEDENT DEDENT for i in range ( N ) [ : : - 1 ] : NEW_LINE INDENT if D == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if ans [ i ] == \"1\" and not done [ i ] : NEW_LINE INDENT ans [ i ] = \"0\" NEW_LINE D -= 1 NEW_LINE DEDENT DEDENT print ( \" \" . join ( ans ) ) NEW_LINE"}
{"id": "geeksforgeeks_2069_A", "sol": 0, "python_code": "def closestNumber ( n , m ) :\n    q = int ( n / m )\n    n1 = m * q\n    if ( ( n * m ) > 0 ) :\n        n2 = ( m * ( q + 1 ) )\n    else :\n        n2 = ( m * ( q - 1 ) )\n    if ( abs ( n - n1 ) < abs ( n - n2 ) ) :\n        return n1\n    return n2\nn = 13 ; m = 4\nprint ( closestNumber ( n , m ) )\nn = - 15 ; m = 6\nprint ( closestNumber ( n , m ) )\nn = 0 ; m = 8\nprint ( closestNumber ( n , m ) )\nn = 18 ; m = - 7\nprint ( closestNumber ( n , m ) )\n", "python_code_tokenized": "def closestNumber ( n , m ) : NEW_LINE INDENT q = int ( n / m ) NEW_LINE n1 = m * q NEW_LINE if ( ( n * m ) > 0 ) : NEW_LINE INDENT n2 = ( m * ( q + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n2 = ( m * ( q - 1 ) ) NEW_LINE DEDENT if ( abs ( n - n1 ) < abs ( n - n2 ) ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return n2 NEW_LINE DEDENT n = 13 ; m = 4 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = - 15 ; m = 6 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 0 ; m = 8 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 ; m = - 7 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE"}
{"id": "geeksforgeeks_3783_A", "sol": 0, "python_code": "def maxOfSegmentMins ( a , n , k ) :\n    if k == 1 :\n        return min ( a )\n    if k == 2 :\n        return max ( a [ 0 ] , a [ n - 1 ] )\n    return max ( a )\nif __name__ == '__main__' :\n    a = [ - 10 , - 9 , - 8 , 2 , 7 , - 6 , - 5 ]\n    n = len ( a )\n    k = 2\n    print ( maxOfSegmentMins ( a , n , k ) )\n", "python_code_tokenized": "def maxOfSegmentMins ( a , n , k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return min ( a ) NEW_LINE DEDENT if k == 2 : NEW_LINE INDENT return max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE DEDENT return max ( a ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ - 10 , - 9 , - 8 , 2 , 7 , - 6 , - 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 2 NEW_LINE print ( maxOfSegmentMins ( a , n , k ) ) NEW_LINE DEDENT"}
{"id": "codeforces_404_A", "sol": 0, "python_code": "n = int ( input ( ) )\ns = [ ]\nfor i in range ( n ) :\n    k = input ( )\n    s.append ( k )\nflag = 0\nd1 = [ ]\nd2 = [ ]\nrem = set ( )\nfor i in range ( n ) :\n    for j in range ( n ) :\n        if ( i == j ) :\n            d1.append ( s [ i ] [ j ] )\n        if ( i == n - j - 1 ) :\n            d2.append ( s [ i ] [ j ] )\n        if ( i != j and i != n - j - 1 ) :\n            rem.add ( s [ i ] [ j ] )\nif ( len ( rem ) != 1 ) :\n    print ( 'NO' )\nelif ( d1 != d2 ) :\n    print ( 'NO' )\nelif ( len ( set ( d1 ) ) != 1 ) :\n    print ( 'NO' )\nelif ( set ( d1 ) == rem ) :\n    print ( 'NO' )\nelse :\n    print ( 'YES' )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = input ( ) NEW_LINE s . append ( k ) NEW_LINE DEDENT flag = 0 NEW_LINE d1 = [ ] NEW_LINE d2 = [ ] NEW_LINE rem = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT d1 . append ( s [ i ] [ j ] ) NEW_LINE DEDENT if ( i == n - j - 1 ) : NEW_LINE INDENT d2 . append ( s [ i ] [ j ] ) NEW_LINE DEDENT if ( i != j and i != n - j - 1 ) : NEW_LINE INDENT rem . add ( s [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( rem ) != 1 ) : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT elif ( d1 != d2 ) : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT elif ( len ( set ( d1 ) ) != 1 ) : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT elif ( set ( d1 ) == rem ) : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4369_A", "sol": 0, "python_code": "from __future__ import print_function\ndef reverse ( a , n , k ) :\n    if ( k > n ) :\n        print ( \"Invalid k\" )\n        return\n    for i in range ( 0 , ( int ) ( k / 2 ) ) :\n        temp = a [ i ]\n        a [ i ] = a [ k - i - 1 ]\n        a [ k - i - 1 ] = temp\na = [ 1 , 2 , 3 , 4 , 5 , 6 ]\nn = len ( a )\nk = 4\nreverse ( a , n , k ) ;\nfor i in range ( 0 , n ) :\n    print ( a [ i ] , end = \" \" )\n", "python_code_tokenized": "from __future__ import print_function NEW_LINE def reverse ( a , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT print ( \" Invalid \u2581 k \" ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , ( int ) ( k / 2 ) ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE a [ i ] = a [ k - i - 1 ] NEW_LINE a [ k - i - 1 ] = temp NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE k = 4 NEW_LINE reverse ( a , n , k ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3105_A", "sol": 0, "python_code": "MAX_CHAR = 26\ndef findAndPrintUncommonChars ( str1 , str2 ) :\n    present = [ 0 ] * MAX_CHAR\n    for i in range ( 0 , MAX_CHAR ) :\n        present [ i ] = 0\n    l1 = len ( str1 )\n    l2 = len ( str2 )\n    for i in range ( 0 , l1 ) :\n        present [ ord ( str1 [ i ] ) - ord ( 'a' ) ] = 1\n    for i in range ( 0 , l2 ) :\n        if ( present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] == 1 or present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] == - 1 ) :\n            present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] = - 1\n        else :\n            present [ ord ( str2 [ i ] ) - ord ( 'a' ) ] = 2\n    for i in range ( 0 , MAX_CHAR ) :\n        if ( present [ i ] == 1 or present [ i ] == 2 ) :\n            print ( chr ( i + ord ( 'a' ) ) , end = \" \" )\nif __name__ == \"__main__\" :\n    str1 = \"characters\"\n    str2 = \"alphabets\"\n    findAndPrintUncommonChars ( str1 , str2 )\n", "python_code_tokenized": "MAX_CHAR = 26 NEW_LINE def findAndPrintUncommonChars ( str1 , str2 ) : NEW_LINE INDENT present = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT present [ i ] = 0 NEW_LINE DEDENT l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE for i in range ( 0 , l1 ) : NEW_LINE INDENT present [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( 0 , l2 ) : NEW_LINE INDENT if ( present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == 1 or present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = 2 NEW_LINE DEDENT DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( present [ i ] == 1 or present [ i ] == 2 ) : NEW_LINE INDENT print ( chr ( i + ord ( ' a ' ) ) , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" characters \" NEW_LINE str2 = \" alphabets \" NEW_LINE findAndPrintUncommonChars ( str1 , str2 ) NEW_LINE DEDENT"}
{"id": "codeforces_9_A", "sol": 0, "python_code": "from fractions import Fraction\ns = list ( map ( int , input ( ).split ( ) ) )\ny = max ( s ) - 1\nx = ( 6 - y )\nd = Fraction ( x , 6 )\nif d == 1 :\n    print ( '1/1' )\nelif d == 0 :\n    print ( '0/1' )\nelse :\n    print ( d )\n", "python_code_tokenized": "from fractions import Fraction NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE y = max ( s ) - 1 NEW_LINE x = ( 6 - y ) NEW_LINE d = Fraction ( x , 6 ) NEW_LINE if d == 1 : NEW_LINE INDENT print ( '1/1' ) NEW_LINE DEDENT elif d == 0 : NEW_LINE INDENT print ( '0/1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4644_A", "sol": 0, "python_code": "def sumOfSeries ( n ) :\n    res = 0.0\n    sum = 0\n    prod = 1\n    for i in range ( 1 , n + 1 ) :\n        sum = sum + i\n        prod = prod * i\n        res = res + ( sum / prod )\n    return res\nn = 4\nprint ( round ( sumOfSeries ( n ) , 5 ) )\n", "python_code_tokenized": "def sumOfSeries ( n ) : NEW_LINE INDENT res = 0.0 NEW_LINE sum = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + i NEW_LINE prod = prod * i NEW_LINE res = res + ( sum / prod ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE print ( round ( sumOfSeries ( n ) , 5 ) ) NEW_LINE"}
{"id": "geeksforgeeks_3152_A", "sol": 0, "python_code": "def countSquares ( m , n ) :\n    if ( n < m ) :\n        temp = m\n        m = n\n        n = temp\n    return n * ( n + 1 ) * ( 3 * m - n + 1 ) // 6\nif __name__ == '__main__' :\n    m = 4\n    n = 3\n    print ( \"Count of squares is\" , countSquares ( m , n ) )\n", "python_code_tokenized": "def countSquares ( m , n ) : NEW_LINE INDENT if ( n < m ) : NEW_LINE INDENT temp = m NEW_LINE m = n NEW_LINE n = temp NEW_LINE DEDENT return n * ( n + 1 ) * ( 3 * m - n + 1 ) // 6 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 4 NEW_LINE n = 3 NEW_LINE print ( \" Count \u2581 of \u2581 squares \u2581 is \" , countSquares ( m , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1284_A", "sol": 0, "python_code": "MAX = 1000\ndef maxSubsequenceSubstring ( x , y , n , m ) :\n    dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ]\n    for i in range ( 1 , m + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            if ( x [ j - 1 ] == y [ i - 1 ] ) :\n                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]\n            else :\n                dp [ i ] [ j ] = dp [ i ] [ j - 1 ]\n    ans = 0\n    for i in range ( 1 , m + 1 ) :\n        ans = max ( ans , dp [ i ] [ n ] )\n    return ans\nx = \"ABCD\"\ny = \"BACDBDCD\"\nn = len ( x )\nm = len ( y )\nprint ( maxSubsequenceSubstring ( x , y , n , m ) )\n", "python_code_tokenized": "MAX = 1000 NEW_LINE def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT x = \" ABCD \" NEW_LINE y = \" BACDBDCD \" NEW_LINE n = len ( x ) NEW_LINE m = len ( y ) NEW_LINE print ( maxSubsequenceSubstring ( x , y , n , m ) ) NEW_LINE"}
{"id": "leetcode_868_A", "sol": 0, "python_code": "class Solution :\n    def binaryGap ( self , n : int ) -> int :\n        current = 1\n        last1 = - 1\n        out = 0\n        while n > 0 :\n            if n % 2 == 1 :\n                if last1 >= 1 :\n                    out = max ( out , current - last1 )\n                last1 = current\n            current += 1\n            n = n // 2\n        return out\n", "python_code_tokenized": "class Solution : NEW_LINE INDENT def binaryGap ( self , n : int ) -> int : NEW_LINE INDENT current = 1 NEW_LINE last1 = - 1 NEW_LINE out = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT if last1 >= 1 : NEW_LINE INDENT out = max ( out , current - last1 ) NEW_LINE DEDENT last1 = current NEW_LINE DEDENT current += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT return out NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4629_A", "sol": 0, "python_code": "prime = [ True for i in range ( 100 ) ]\ndef sieve ( n , prime ) :\n    for i in range ( 1 , n + 1 ) :\n        prime [ i ] = True\n    prime [ 0 ] = prime [ 1 ] = False\n    for i in range ( 2 , n + 1 ) :\n        if ( prime [ i ] ) :\n            for j in range ( 2 * i , n + 1 , i ) :\n                prime [ j ] = False\ndef SumOfSubset ( a , n ) :\n    maxi = max ( a )\n    sieve ( maxi , prime )\n    times = pow ( 2 , n - 1 )\n    Sum = 1\n    for i in range ( n ) :\n        if ( prime [ a [ i ] ] ) :\n            Sum = Sum * ( pow ( a [ i ] , times ) )\n    return Sum\na = [ 3 , 7 ]\nn = len ( a )\nprint ( SumOfSubset ( a , n ) )\n", "python_code_tokenized": "prime = [ True for i in range ( 100 ) ] NEW_LINE def sieve ( n , prime ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 0 ] = prime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , n + 1 , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def SumOfSubset ( a , n ) : NEW_LINE INDENT maxi = max ( a ) NEW_LINE sieve ( maxi , prime ) NEW_LINE times = pow ( 2 , n - 1 ) NEW_LINE Sum = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ a [ i ] ] ) : NEW_LINE INDENT Sum = Sum * ( pow ( a [ i ] , times ) ) NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT a = [ 3 , 7 ] NEW_LINE n = len ( a ) NEW_LINE print ( SumOfSubset ( a , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_957_A", "sol": 0, "python_code": "import math as mt\ndef countWindowDistinct ( win , k ) :\n    dist_count = 0\n    for i in range ( k ) :\n        j = 0\n        while j < i :\n            if ( win [ i ] == win [ j ] ) :\n                break\n            else :\n                j += 1\n        if ( j == i ) :\n            dist_count += 1\n    return dist_count\ndef countDistinct ( arr , n , k ) :\n    for i in range ( n - k + 1 ) :\n        print ( countWindowDistinct ( arr [ i : k + i ] , k ) )\narr = [ 1 , 2 , 1 , 3 , 4 , 2 , 3 ]\nk = 4\nn = len ( arr )\ncountDistinct ( arr , n , k )\n", "python_code_tokenized": "import math as mt NEW_LINE def countWindowDistinct ( win , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT j = 0 NEW_LINE while j < i : NEW_LINE INDENT if ( win [ i ] == win [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT DEDENT return dist_count NEW_LINE DEDENT def countDistinct ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT print ( countWindowDistinct ( arr [ i : k + i ] , k ) ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 1 , 3 , 4 , 2 , 3 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE countDistinct ( arr , n , k ) NEW_LINE"}
{"id": "aizu_p01845_A", "sol": 0, "python_code": "while True :\n    R0 , W0 , C , R = map ( int , input ( ).split ( ) )\n    if R0 + W0 + C + R == 0 :\n        break\n    n = 0\n    while True :\n        if ( n * R + R0 ) / W0 >= C :\n            break\n        n += 1\n    print ( n )\n", "python_code_tokenized": "while True : NEW_LINE INDENT R0 , W0 , C , R = map ( int , input ( ) . split ( ) ) NEW_LINE if R0 + W0 + C + R == 0 : NEW_LINE INDENT break NEW_LINE DEDENT n = 0 NEW_LINE while True : NEW_LINE INDENT if ( n * R + R0 ) / W0 >= C : NEW_LINE INDENT break NEW_LINE DEDENT n += 1 NEW_LINE DEDENT print ( n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4091_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    if a == 0 :\n        return b\n    return gcd ( b % a , a )\ndef lcm ( a , b ) :\n    return ( a * b ) / gcd ( a , b )\na = 15\nb = 20\nprint ( 'LCM of' , a , 'and' , b , 'is' , lcm ( a , b ) )\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) / gcd ( a , b ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( ' LCM \u2581 of ' , a , ' and ' , b , ' is ' , lcm ( a , b ) ) NEW_LINE"}
{"id": "geeksforgeeks_1416_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    if ( b == 0 ) :\n        return a\n    return gcd ( b , a % b )\na = 98\nb = 56\nif ( gcd ( a , b ) ) :\n    print ( 'GCD of' , a , 'and' , b , 'is' , gcd ( a , b ) )\nelse :\n    print ( 'not found' )\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD \u2581 of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not \u2581 found ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1415_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    if ( a == 0 ) :\n        return b\n    if ( b == 0 ) :\n        return a\n    if ( a == b ) :\n        return a\n    if ( a > b ) :\n        return gcd ( a - b , b )\n    return gcd ( a , b - a )\na = 98\nb = 56\nif ( gcd ( a , b ) ) :\n    print ( 'GCD of' , a , 'and' , b , 'is' , gcd ( a , b ) )\nelse :\n    print ( 'not found' )\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD \u2581 of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not \u2581 found ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1572_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    if a == 0 :\n        return b\n    return gcd ( b % a , a )\ndef lcm ( a , b ) :\n    return ( a * b ) / gcd ( a , b )\na = 15\nb = 20\nprint ( 'LCM of' , a , 'and' , b , 'is' , lcm ( a , b ) )\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) / gcd ( a , b ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( ' LCM \u2581 of ' , a , ' and ' , b , ' is ' , lcm ( a , b ) ) NEW_LINE"}
{"id": "geeksforgeeks_1579_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    if ( b == 0 ) :\n        return a\n    return gcd ( b , a % b )\na = 98\nb = 56\nif ( gcd ( a , b ) ) :\n    print ( 'GCD of' , a , 'and' , b , 'is' , gcd ( a , b ) )\nelse :\n    print ( 'not found' )\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD \u2581 of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not \u2581 found ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1578_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    if ( a == 0 or b == 0 ) :\n        False\n    if ( a == b ) :\n        return a\n    if ( a > b ) :\n        return gcd ( a - b , b )\n    return gcd ( a , b - a )\na = 98\nb = 56\nif ( gcd ( a , b ) ) :\n    print ( 'GCD of' , a , 'and' , b , 'is' , gcd ( a , b ) )\nelse :\n    print ( 'not found' )\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT False NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD \u2581 of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not \u2581 found ' ) NEW_LINE DEDENT"}
{"id": "codejam_10_32", "sol": 0, "python_code": "import sys\ndef ntests ( L , P , C ) :\n    ratio = P * 1.0 / L\n    if ratio <= C : return 0\n    if L == 1 and P == 3 : return 1\n    testpoint = int ( L * ( ratio ** 0.5 ) )\n    count = max ( 1 + ntests ( L , testpoint , C ) , 1 + ntests ( testpoint , P , C ) )\n    if ( testpoint * testpoint == L * P or testpoint + 1 == P ) :\n        return count\n    count2 = max ( 1 + ntests ( L , testpoint + 1 , C ) , 1 + ntests ( testpoint + 1 , P , C ) )\n    return min ( count , count2 )\ninfile = sys.stdin\nT = int ( infile.readline ( ).strip ( ) )\nfor i in xrange ( T ) :\n    L , P , C = map ( int , infile.readline ( ).strip ( ).split ( ) )\n    result = ntests ( L , P , C )\n    print ( \"Case #%d: %s\" % ( i + 1 , str ( result ) ) )\n", "python_code_tokenized": "import sys NEW_LINE def ntests ( L , P , C ) : NEW_LINE INDENT ratio = P * 1.0 / L NEW_LINE if ratio <= C : return 0 NEW_LINE if L == 1 and P == 3 : return 1 NEW_LINE testpoint = int ( L * ( ratio ** 0.5 ) ) NEW_LINE count = max ( 1 + ntests ( L , testpoint , C ) , 1 + ntests ( testpoint , P , C ) ) NEW_LINE if ( testpoint * testpoint == L * P or testpoint + 1 == P ) : NEW_LINE INDENT return count NEW_LINE DEDENT count2 = max ( 1 + ntests ( L , testpoint + 1 , C ) , 1 + ntests ( testpoint + 1 , P , C ) ) NEW_LINE return min ( count , count2 ) NEW_LINE DEDENT infile = sys . stdin NEW_LINE T = int ( infile . readline ( ) . strip ( ) ) NEW_LINE for i in xrange ( T ) : NEW_LINE INDENT L , P , C = map ( int , infile . readline ( ) . strip ( ) . split ( ) ) NEW_LINE result = ntests ( L , P , C ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % s \" % ( i + 1 , str ( result ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_331_A", "sol": 0, "python_code": "def cntSubsets ( arr , n ) :\n    a = [ 0 ] * n\n    b = [ 0 ] * n ;\n    a [ 0 ] = b [ 0 ] = 1 ;\n    for i in range ( 1 , n ) :\n        a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;\n        b [ i ] = a [ i - 1 ] ;\n    result = a [ n - 1 ] + b [ n - 1 ] ;\n    return result ;\nif __name__ == \"__main__\" :\n    arr = [ 3 , 5 , 7 ] ;\n    n = len ( arr ) ;\n    print ( cntSubsets ( arr , n ) ) ;\n", "python_code_tokenized": "def cntSubsets ( arr , n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE b = [ 0 ] * n ; NEW_LINE a [ 0 ] = b [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; NEW_LINE b [ i ] = a [ i - 1 ] ; NEW_LINE DEDENT result = a [ n - 1 ] + b [ n - 1 ] ; NEW_LINE return result ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( cntSubsets ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1395_A", "sol": 0, "python_code": "def isPrime ( n ) :\n    if ( n <= 1 ) : return False ;\n    if ( n <= 3 ) : return True ;\n    if ( n % 2 == 0 or n % 3 == 0 ) :\n        return False ;\n    i = 5 ;\n    while ( i * i <= n ) :\n        if ( n % i == 0 or n % ( i + 2 ) == 0 ) :\n            return False ;\n        i = i + 6 ;\n    return True ;\ndef primeBitsInRange ( l , r ) :\n    count = 0 ;\n    for i in range ( l , r + 1 ) :\n        tot_bit = bin ( i ).count ( '1' ) ;\n        if ( isPrime ( tot_bit ) ) :\n            count += 1 ;\n    return count ;\nl = 6 ;\nr = 10 ;\nprint ( primeBitsInRange ( l , r ) ) ;\n", "python_code_tokenized": "def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : return False ; NEW_LINE if ( n <= 3 ) : return True ; NEW_LINE if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i = 5 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i = i + 6 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def primeBitsInRange ( l , r ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT tot_bit = bin ( i ) . count ( '1' ) ; NEW_LINE if ( isPrime ( tot_bit ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT l = 6 ; NEW_LINE r = 10 ; NEW_LINE print ( primeBitsInRange ( l , r ) ) ; NEW_LINE"}
{"id": "codeforces_1331_B", "sol": 0, "python_code": "import math\nans = int ( input ( ) )\ni = 2\nj = 0\nwhile ( i * i <= ans ) :\n    if ans % i == 0 : j = i\n    i += 1\nprint ( \"%d%d\" % ( j , ans // j ) )\n", "python_code_tokenized": "import math NEW_LINE ans = int ( input ( ) ) NEW_LINE i = 2 NEW_LINE j = 0 NEW_LINE while ( i * i <= ans ) : NEW_LINE INDENT if ans % i == 0 : j = i NEW_LINE i += 1 NEW_LINE DEDENT print ( \" % d % d \" % ( j , ans // j ) ) NEW_LINE"}
{"id": "geeksforgeeks_4509_A", "sol": 0, "python_code": "def countSetBits ( n ) :\n    i = 0\n    ans = 0\n    while ( ( 1 << i ) <= n ) :\n        k = 0\n        change = 1 << i\n        for j in range ( 0 , n + 1 ) :\n            ans += k\n            if change == 1 :\n                k = not k\n                change = 1 << i\n            else :\n                change -= 1\n        i += 1\n    return ans\nif __name__ == \"__main__\" :\n    n = 17\n    print ( countSetBits ( n ) )\n", "python_code_tokenized": "def countSetBits ( n ) : NEW_LINE INDENT i = 0 NEW_LINE ans = 0 NEW_LINE while ( ( 1 << i ) <= n ) : NEW_LINE INDENT k = 0 NEW_LINE change = 1 << i NEW_LINE for j in range ( 0 , n + 1 ) : NEW_LINE INDENT ans += k NEW_LINE if change == 1 : NEW_LINE INDENT k = not k NEW_LINE change = 1 << i NEW_LINE DEDENT else : NEW_LINE INDENT change -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 17 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00400_A", "sol": 0, "python_code": "digits = input ( )\nuppercaseList = [ str ( i ) for i in range ( 65 , 90 + 1 ) ]\nlowercaseList = [ str ( i ) for i in range ( 97 , 122 + 1 ) ]\nif digits in uppercaseList :\n    print ( '1' )\nelif digits in lowercaseList :\n    print ( '2' )\nelse :\n    print ( '0' )\n", "python_code_tokenized": "digits = input ( ) NEW_LINE uppercaseList = [ str ( i ) for i in range ( 65 , 90 + 1 ) ] NEW_LINE lowercaseList = [ str ( i ) for i in range ( 97 , 122 + 1 ) ] NEW_LINE if digits in uppercaseList : NEW_LINE INDENT print ( '1' ) NEW_LINE DEDENT elif digits in lowercaseList : NEW_LINE INDENT print ( '2' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_93_A", "sol": 0, "python_code": "def CountTheElements ( arr , n , k ) :\n    counter = 0\n    for i in range ( 0 , n , 1 ) :\n        if ( arr [ i ] % k == 0 ) :\n            counter = counter + 1\n    return counter\nif __name__ == '__main__' :\n    arr = [ 2 , 6 , 7 , 12 , 14 , 18 ] ;\n    n = len ( arr )\n    k = 3\n    print ( CountTheElements ( arr , n , k ) )\n", "python_code_tokenized": "def CountTheElements ( arr , n , k ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 6 , 7 , 12 , 14 , 18 ] ; NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( CountTheElements ( arr , n , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1377_A", "sol": 0, "python_code": "def countSubSeq ( arr , n , k ) :\n    count = 0 ;\n    for i in range ( n ) :\n        if ( arr [ i ] % k == 0 ) :\n            count += 1 ;\n    return ( 2 ** count - 1 ) ;\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 3 , 6 ] ;\n    n = len ( arr ) ;\n    k = 3 ;\n    print ( countSubSeq ( arr , n , k ) ) ;\n", "python_code_tokenized": "def countSubSeq ( arr , n , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return ( 2 ** count - 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 3 ; NEW_LINE print ( countSubSeq ( arr , n , k ) ) ; NEW_LINE DEDENT"}
{"id": "aizu_p00775_A", "sol": 0, "python_code": "while True :\n    R , N = map ( int , input ( ).split ( ) )\n    if not ( R | N ) :\n        break\n    geta = 20\n    buildings = [ 0 ] * ( geta * 2 )\n    for _ in range ( N ) :\n        xl , xr , h = map ( int , input ( ).split ( ) )\n        for i in range ( xl + geta , xr + geta ) :\n            buildings [ i ] = max ( buildings [ i ] , h )\n    left , right = 0 , 20\n    for _ in range ( 100 ) :\n        mid = ( left + right ) / 2\n        flag = True\n        for i in range ( - R + geta , R + geta ) :\n            if i < geta :\n                y = pow ( R * R - ( i - geta + 1 ) * ( i - geta + 1 ) , 0.5 )\n                flag &= buildings [ i ] >= y - R + mid\n            else :\n                y = pow ( R * R - ( i - geta ) * ( i - geta ) , 0.5 )\n                flag &= buildings [ i ] >= y - R + mid\n        if flag :\n            left = mid\n        else :\n            right = mid\n    print ( \"{:.20f}\".format ( left ) )\n", "python_code_tokenized": "while True : NEW_LINE INDENT R , N = map ( int , input ( ) . split ( ) ) NEW_LINE if not ( R | N ) : NEW_LINE INDENT break NEW_LINE DEDENT geta = 20 NEW_LINE buildings = [ 0 ] * ( geta * 2 ) NEW_LINE for _ in range ( N ) : NEW_LINE INDENT xl , xr , h = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( xl + geta , xr + geta ) : NEW_LINE INDENT buildings [ i ] = max ( buildings [ i ] , h ) NEW_LINE DEDENT DEDENT left , right = 0 , 20 NEW_LINE for _ in range ( 100 ) : NEW_LINE INDENT mid = ( left + right ) / 2 NEW_LINE flag = True NEW_LINE for i in range ( - R + geta , R + geta ) : NEW_LINE INDENT if i < geta : NEW_LINE INDENT y = pow ( R * R - ( i - geta + 1 ) * ( i - geta + 1 ) , 0.5 ) NEW_LINE flag &= buildings [ i ] >= y - R + mid NEW_LINE DEDENT else : NEW_LINE INDENT y = pow ( R * R - ( i - geta ) * ( i - geta ) , 0.5 ) NEW_LINE flag &= buildings [ i ] >= y - R + mid NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT left = mid NEW_LINE DEDENT else : NEW_LINE INDENT right = mid NEW_LINE DEDENT DEDENT print ( \" { : . 20f } \" . format ( left ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2285_A", "sol": 0, "python_code": "def gouldSequence ( n ) :\n    for row_num in range ( 1 , n ) :\n        count = 1\n        c = 1\n        for i in range ( 1 , row_num ) :\n            c = c * ( row_num - i ) / i\n            if ( c % 2 == 1 ) :\n                count += 1\n        print ( count , end = \" \" )\nn = 16 ;\ngouldSequence ( n )\n", "python_code_tokenized": "def gouldSequence ( n ) : NEW_LINE INDENT for row_num in range ( 1 , n ) : NEW_LINE INDENT count = 1 NEW_LINE c = 1 NEW_LINE for i in range ( 1 , row_num ) : NEW_LINE INDENT c = c * ( row_num - i ) / i NEW_LINE if ( c % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT n = 16 ; NEW_LINE gouldSequence ( n ) NEW_LINE"}
{"id": "geeksforgeeks_5139_A", "sol": 0, "python_code": "def recursiveFun ( n ) :\n    if ( n == 1 ) :\n        return \"int\"\n    return \"gcd(int, \" + recursiveFun ( n - 1 ) + \")\"\nif __name__ == '__main__' :\n    n = 5\n    print ( recursiveFun ( n ) )\n", "python_code_tokenized": "def recursiveFun ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return \" int \" NEW_LINE DEDENT return \" gcd ( int , \u2581 \" + recursiveFun ( n - 1 ) + \" ) \" NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( recursiveFun ( n ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02063_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\nd = e = - ( - b // a ) * a\nc = 0\nwhile d >= b :\n    d -= b\n    c += 1\nwhile d >= a :\n    d -= a\n    c += 1\nc += d\nif c > e // a :\n    print ( e )\nelse :\n    print ( - 1 )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE d = e = - ( - b // a ) * a NEW_LINE c = 0 NEW_LINE while d >= b : NEW_LINE INDENT d -= b NEW_LINE c += 1 NEW_LINE DEDENT while d >= a : NEW_LINE INDENT d -= a NEW_LINE c += 1 NEW_LINE DEDENT c += d NEW_LINE if c > e // a : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2210_A", "sol": 0, "python_code": "dp = [ [ [ - 1 for i in range ( 5 ) ] for i in range ( 501 ) ] for i in range ( 501 ) ]\ndef countWaysUtil ( n , parts , nextPart ) :\n    if ( parts == 0 and n == 0 ) :\n        return 1\n    if ( n <= 0 or parts <= 0 ) :\n        return 0\n    if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) :\n        return dp [ n ] [ nextPart ] [ parts ]\n    ans = 0\n    for i in range ( nextPart , n + 1 ) :\n        ans += countWaysUtil ( n - i , parts - 1 , i )\n    dp [ n ] [ nextPart ] [ parts ] = ans\n    return ( ans )\ndef countWays ( n ) :\n    return countWaysUtil ( n , 4 , 1 )\nn = 8\nprint ( countWays ( n ) )\n", "python_code_tokenized": "dp = [ [ [ - 1 for i in range ( 5 ) ] for i in range ( 501 ) ] for i in range ( 501 ) ] NEW_LINE def countWaysUtil ( n , parts , nextPart ) : NEW_LINE INDENT if ( parts == 0 and n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 or parts <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ nextPart ] [ parts ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( nextPart , n + 1 ) : NEW_LINE INDENT ans += countWaysUtil ( n - i , parts - 1 , i ) NEW_LINE DEDENT dp [ n ] [ nextPart ] [ parts ] = ans NEW_LINE return ( ans ) NEW_LINE DEDENT def countWays ( n ) : NEW_LINE INDENT return countWaysUtil ( n , 4 , 1 ) NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4437_A", "sol": 0, "python_code": "def search ( ar , size ) :\n    a = 0\n    b = size - 1\n    mid = 0\n    while b > a + 1 :\n        mid = ( a + b ) // 2\n        if ( ar [ a ] - a ) != ( ar [ mid ] - mid ) :\n            b = mid\n        elif ( ar [ b ] - b ) != ( ar [ mid ] - mid ) :\n            a = mid\n    return ar [ mid ] + 1\na = [ 1 , 2 , 3 , 4 , 5 , 6 , 8 ]\nn = len ( a )\nprint ( \"Missing number:\" , search ( a , n ) )\n", "python_code_tokenized": "def search ( ar , size ) : NEW_LINE INDENT a = 0 NEW_LINE b = size - 1 NEW_LINE mid = 0 NEW_LINE while b > a + 1 : NEW_LINE INDENT mid = ( a + b ) // 2 NEW_LINE if ( ar [ a ] - a ) != ( ar [ mid ] - mid ) : NEW_LINE INDENT b = mid NEW_LINE DEDENT elif ( ar [ b ] - b ) != ( ar [ mid ] - mid ) : NEW_LINE INDENT a = mid NEW_LINE DEDENT DEDENT return ar [ mid ] + 1 NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 , 5 , 6 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( \" Missing \u2581 number : \" , search ( a , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4428_A", "sol": 0, "python_code": "def pattern ( n , d ) :\n    for i in range ( 0 , n - 2 ) :\n        print ( \"1\" , end = \" \" )\n    print ( \"2\" , end = \" \" )\n    print ( n + d )\nN = 3\nD = 5\npattern ( N , D )\n", "python_code_tokenized": "def pattern ( n , d ) : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( \"1\" , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \"2\" , end = \" \u2581 \" ) NEW_LINE print ( n + d ) NEW_LINE DEDENT N = 3 NEW_LINE D = 5 NEW_LINE pattern ( N , D ) NEW_LINE"}
{"id": "geeksforgeeks_1879_A", "sol": 0, "python_code": "num_to_bits = [ 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 ] ;\ndef countSetBitsRec ( num ) :\n    nibble = 0 ;\n    if ( 0 == num ) :\n        return num_to_bits [ 0 ] ;\n    nibble = num & 0xf ;\n    return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ;\nnum = 31 ;\nprint ( countSetBitsRec ( num ) ) ;\n", "python_code_tokenized": "num_to_bits = [ 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 ] ; NEW_LINE def countSetBitsRec ( num ) : NEW_LINE INDENT nibble = 0 ; NEW_LINE if ( 0 == num ) : NEW_LINE INDENT return num_to_bits [ 0 ] ; NEW_LINE DEDENT nibble = num & 0xf ; NEW_LINE return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; NEW_LINE DEDENT num = 31 ; NEW_LINE print ( countSetBitsRec ( num ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_3564_A", "sol": 0, "python_code": "def findN ( k ) :\n    if ( k == 0 ) :\n        ans = 3\n    if ( k == 1 ) :\n        ans = 1\n    elif ( k % 4 == 0 ) :\n        ans = k\n    elif ( k % 4 == 3 ) :\n        ans = k - 1\n    else :\n        ans = - 1\n    return ans\nk = 7\nres = findN ( k )\nif ( res == - 1 ) :\n    print ( \"Not possible\" )\nelse :\n    print ( res )\n", "python_code_tokenized": "def findN ( k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif ( k % 4 == 0 ) : NEW_LINE INDENT ans = k NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT k = 7 NEW_LINE res = findN ( k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( \" Not \u2581 possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4530_A", "sol": 0, "python_code": "def checkSparse ( n ) :\n    if ( n & ( n >> 1 ) ) :\n        return 0\n    return 1\nprint ( checkSparse ( 72 ) )\nprint ( checkSparse ( 12 ) )\nprint ( checkSparse ( 2 ) )\nprint ( checkSparse ( 30 ) )\n", "python_code_tokenized": "def checkSparse ( n ) : NEW_LINE INDENT if ( n & ( n >> 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT print ( checkSparse ( 72 ) ) NEW_LINE print ( checkSparse ( 12 ) ) NEW_LINE print ( checkSparse ( 2 ) ) NEW_LINE print ( checkSparse ( 30 ) ) NEW_LINE"}
{"id": "geeksforgeeks_4138_A", "sol": 0, "python_code": "def countStrs ( n ) :\n    dp = [ [ 0 for j in range ( 27 ) ] for i in range ( n + 1 ) ]\n    for i in range ( 0 , 26 ) :\n        dp [ 1 ] [ i ] = 1\n    for i in range ( 2 , n + 1 ) :\n        for j in range ( 0 , 26 ) :\n            if ( j == 0 ) :\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;\n            else :\n                dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] )\n    sum = 0\n    for i in range ( 0 , 26 ) :\n        sum = sum + dp [ n ] [ i ]\n    return sum\nif __name__ == \"__main__\" :\n    n = 3\n    print ( \"Total strings are : \" , countStrs ( n ) )\n", "python_code_tokenized": "def countStrs ( n ) : NEW_LINE INDENT dp = [ [ 0 for j in range ( 27 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 26 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT sum = sum + dp [ n ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( \" Total \u2581 strings \u2581 are \u2581 : \u2581 \" , countStrs ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_589_A", "sol": 0, "python_code": "def solve ( N , K ) :\n    combo = [ 0 ] * ( N + 1 )\n    combo [ 0 ] = 1\n    for i in range ( 1 , K + 1 ) :\n        for j in range ( 0 , N + 1 ) :\n            if j >= i :\n                combo [ j ] += combo [ j - i ]\n    return combo [ N ]\nif __name__ == \"__main__\" :\n    N , K = 29 , 5\n    print ( solve ( N , K ) )\n", "python_code_tokenized": "def solve ( N , K ) : NEW_LINE INDENT combo = [ 0 ] * ( N + 1 ) NEW_LINE combo [ 0 ] = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 0 , N + 1 ) : NEW_LINE INDENT if j >= i : NEW_LINE INDENT combo [ j ] += combo [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return combo [ N ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , K = 29 , 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4022_A", "sol": 0, "python_code": "def sumOfTheSeries ( n ) :\n    sum = 0\n    for i in range ( 1 , n + 1 ) :\n        k = 1\n        for j in range ( 1 , i + 1 ) :\n            sum += k\n            k += 2\n    return sum\nn = 5\nprint ( \"Sum =\" , sumOfTheSeries ( n ) )\n", "python_code_tokenized": "def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT sum += k NEW_LINE k += 2 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum \u2581 = \" , sumOfTheSeries ( n ) ) NEW_LINE"}
{"id": "codeforces_689_A", "sol": 0, "python_code": "t = 1\nwhile t > 0 :\n    t -= 1\n    n = int ( input ( ) )\n    s = input ( )\n    a = [ ]\n    for i in range ( 0 , len ( s ) ) :\n        if s [ i ] != '0' :\n            a.append ( int ( s [ i ] ) )\n        else :\n            a.append ( 11 )\n    b = [ ]\n    c = [ ]\n    d = [ ]\n    e = [ ]\n    for i in range ( 0 , len ( s ) ) :\n        b.append ( a [ i ] - 3 )\n        c.append ( a [ i ] % 3 - 1 if a [ i ] % 3 != 0 else 2 )\n        d.append ( a [ i ] + 3 )\n        e.append ( a [ i ] % 3 + 1 if a [ i ] % 3 != 0 else 4 )\n    k1 = k2 = h1 = h2 = False\n    for i in range ( 0 , len ( s ) ) :\n        if b [ i ] <= 0 :\n            k1 = True\n        if c [ i ] <= 0 or a [ i ] == 11 :\n            h1 = True\n        if d [ i ] > 9 and d [ i ] != 11 :\n            k2 = True\n        if e [ i ] >= 4 or a [ i ] == 11 :\n            h2 = True\n    if k1 == True and h1 == True and k2 == True and h2 == True :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "t = 1 NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ ] NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] != '0' : NEW_LINE INDENT a . append ( int ( s [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT a . append ( 11 ) NEW_LINE DEDENT DEDENT b = [ ] NEW_LINE c = [ ] NEW_LINE d = [ ] NEW_LINE e = [ ] NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT b . append ( a [ i ] - 3 ) NEW_LINE c . append ( a [ i ] % 3 - 1 if a [ i ] % 3 != 0 else 2 ) NEW_LINE d . append ( a [ i ] + 3 ) NEW_LINE e . append ( a [ i ] % 3 + 1 if a [ i ] % 3 != 0 else 4 ) NEW_LINE DEDENT k1 = k2 = h1 = h2 = False NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if b [ i ] <= 0 : NEW_LINE INDENT k1 = True NEW_LINE DEDENT if c [ i ] <= 0 or a [ i ] == 11 : NEW_LINE INDENT h1 = True NEW_LINE DEDENT if d [ i ] > 9 and d [ i ] != 11 : NEW_LINE INDENT k2 = True NEW_LINE DEDENT if e [ i ] >= 4 or a [ i ] == 11 : NEW_LINE INDENT h2 = True NEW_LINE DEDENT DEDENT if k1 == True and h1 == True and k2 == True and h2 == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2297_A", "sol": 0, "python_code": "def minChanges ( A , n ) :\n    cnt = 0\n    for i in range ( n - 2 ) :\n        if ( ( i - 1 >= 0 ) and A [ i - 1 ] == 1 and A [ i + 1 ] == 1 and A [ i ] == 0 ) :\n            A [ i + 1 ] = 0\n            cnt = cnt + 1\n    return cnt\nA = [ 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 ]\nn = len ( A )\nprint ( minChanges ( A , n ) )\n", "python_code_tokenized": "def minChanges ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( ( i - 1 >= 0 ) and A [ i - 1 ] == 1 and A [ i + 1 ] == 1 and A [ i ] == 0 ) : NEW_LINE INDENT A [ i + 1 ] = 0 NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT A = [ 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( A ) NEW_LINE print ( minChanges ( A , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1482_A", "sol": 0, "python_code": "def findAndPrintOriginalArray ( arr , n ) :\n    arr_sum = 0\n    for i in range ( 0 , n ) :\n        arr_sum += arr [ i ]\n    arr_sum = int ( arr_sum / ( n - 1 ) )\n    for i in range ( 0 , n ) :\n        print ( ( arr_sum - arr [ i ] ) , end = \" \" )\narr = [ 10 , 14 , 12 , 13 , 11 ]\nn = len ( arr )\nfindAndPrintOriginalArray ( arr , n )\n", "python_code_tokenized": "def findAndPrintOriginalArray ( arr , n ) : NEW_LINE INDENT arr_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT arr_sum += arr [ i ] NEW_LINE DEDENT arr_sum = int ( arr_sum / ( n - 1 ) ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( ( arr_sum - arr [ i ] ) , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 14 , 12 , 13 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE findAndPrintOriginalArray ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_260_A", "sol": 0, "python_code": "import random\nimport math\ne = 2.71828 ;\ndef roundNo ( num ) :\n    if ( num < 0 ) :\n        return ( num - 0.5 )\n    else :\n        return ( num + 0.5 ) ;\ndef printBestCandidate ( candidate , n ) :\n    sample_size = roundNo ( n / e ) ;\n    print ( \"\\n\\nSample size is\" , math.floor ( sample_size ) ) ;\n    best = 0 ;\n    for i in range ( 1 , int ( sample_size ) ) :\n        if ( candidate [ i ] > candidate [ best ] ) :\n            best = i ;\n    for i in range ( int ( sample_size ) , n ) :\n        if ( candidate [ i ] >= candidate [ best ] ) :\n            best = i ;\n            break ;\n    if ( best >= int ( sample_size ) ) :\n        print ( \"\\nBest candidate found is\" , math.floor ( best + 1 ) , \"with talent\" , math.floor ( candidate [ best ] ) ) ;\n    else :\n        print ( \"Couldn't find a best candidate\" ) ;\nn = 8 ;\ncandidate = [ 0 ] * ( n ) ;\nfor i in range ( n ) :\n    candidate [ i ] = 1 + random.randint ( 1 , 8 ) ;\nprint ( \"Candidate : \" , end = \"\" ) ;\nfor i in range ( n ) :\n    print ( ( i + 1 ) , end = \"\" ) ;\nprint ( \"\\nTalents : \" , end = \"\" ) ;\nfor i in range ( n ) :\n    print ( candidate [ i ] , end = \"\" ) ;\nprintBestCandidate ( candidate , n ) ;\n", "python_code_tokenized": "import random NEW_LINE import math NEW_LINE e = 2.71828 ; NEW_LINE def roundNo ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return ( num - 0.5 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( num + 0.5 ) ; NEW_LINE DEDENT DEDENT def printBestCandidate ( candidate , n ) : NEW_LINE INDENT sample_size = roundNo ( n / e ) ; NEW_LINE print ( \" \\n \\n Sample \u2581 size \u2581 is \" , math . floor ( sample_size ) ) ; NEW_LINE best = 0 ; NEW_LINE for i in range ( 1 , int ( sample_size ) ) : NEW_LINE INDENT if ( candidate [ i ] > candidate [ best ] ) : NEW_LINE INDENT best = i ; NEW_LINE DEDENT DEDENT for i in range ( int ( sample_size ) , n ) : NEW_LINE INDENT if ( candidate [ i ] >= candidate [ best ] ) : NEW_LINE INDENT best = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( best >= int ( sample_size ) ) : NEW_LINE INDENT print ( \" \\n Best \u2581 candidate \u2581 found \u2581 is \" , math . floor ( best + 1 ) , \" with \u2581 talent \" , math . floor ( candidate [ best ] ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Couldn ' t \u2581 find \u2581 a \u2581 best \u2581 candidate \" ) ; NEW_LINE DEDENT DEDENT n = 8 ; NEW_LINE candidate = [ 0 ] * ( n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT candidate [ i ] = 1 + random . randint ( 1 , 8 ) ; NEW_LINE DEDENT print ( \" Candidate \u2581 : \u2581 \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( ( i + 1 ) , end = \" \u2581 \" ) ; NEW_LINE DEDENT print ( \" \\n Talents \u2581 : \u2581 \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( candidate [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT printBestCandidate ( candidate , n ) ; NEW_LINE"}
{"id": "geeksforgeeks_1338_A", "sol": 0, "python_code": "def maxPrimefactorNum ( N ) :\n    arr = [ True ] * ( N + 5 ) ;\n    i = 3 ;\n    while ( i * i <= N ) :\n        if ( arr [ i ] ) :\n            for j in range ( i * i , N + 1 , i ) :\n                arr [ j ] = False ;\n        i += 2 ;\n    prime = [ ] ;\n    prime.append ( 2 ) ;\n    for i in range ( 3 , N + 1 , 2 ) :\n        if ( arr [ i ] ) :\n            prime.append ( i ) ;\n    i = 0 ;\n    ans = 1 ;\n    while ( ans * prime [ i ] <= N and i < len ( prime ) ) :\n        ans *= prime [ i ] ;\n        i += 1 ;\n    return ans ;\nN = 40 ;\nprint ( maxPrimefactorNum ( N ) ) ;\n", "python_code_tokenized": "def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ True ] * ( N + 5 ) ; NEW_LINE i = 3 ; NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] = False ; NEW_LINE DEDENT DEDENT i += 2 ; NEW_LINE DEDENT prime = [ ] ; NEW_LINE prime . append ( 2 ) ; NEW_LINE for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT prime . append ( i ) ; NEW_LINE DEDENT DEDENT i = 0 ; NEW_LINE ans = 1 ; NEW_LINE while ( ans * prime [ i ] <= N and i < len ( prime ) ) : NEW_LINE INDENT ans *= prime [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT N = 40 ; NEW_LINE print ( maxPrimefactorNum ( N ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_47_A", "sol": 0, "python_code": "def numberOfDivisors ( num ) :\n    c = 0\n    for i in range ( 1 , num + 1 ) :\n        if ( num % i == 0 ) :\n            c += 1\n    return c\ndef countNumbers ( n ) :\n    c = 0\n    for i in range ( 1 , n + 1 ) :\n        if ( numberOfDivisors ( i ) == 9 ) :\n            c += 1\n    return c\nif __name__ == \"__main__\" :\n    n = 1000\n    print ( countNumbers ( n ) )\n", "python_code_tokenized": "def numberOfDivisors ( num ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT def countNumbers ( n ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( numberOfDivisors ( i ) == 9 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1000 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4639_A", "sol": 0, "python_code": "import math\nclass Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.next = None\ndef reversePrint ( head_ref ) :\n    tail = head_ref\n    while ( tail.next != None ) :\n        tail = tail.next\n    while ( tail != head_ref ) :\n        print ( tail.data , end = \" \" )\n        tail = tail.prev\n    print ( tail.data )\ndef push ( head_ref , new_data ) :\n    new_node = Node ( new_data )\n    new_node.data = new_data\n    new_node.prev = None\n    new_node.next = head_ref\n    if ( head_ref != None ) :\n        head_ref.prev = new_node\n    head_ref = new_node\n    return head_ref\nif __name__ == '__main__' :\n    head = None\n    head = push ( head , 2 )\n    head = push ( head , 4 )\n    head = push ( head , 8 )\n    head = push ( head , 10 )\n    print ( \"Linked List elements in reverse order : \" )\n    reversePrint ( head )\n", "python_code_tokenized": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def reversePrint ( head_ref ) : NEW_LINE INDENT tail = head_ref NEW_LINE while ( tail . next != None ) : NEW_LINE INDENT tail = tail . next NEW_LINE DEDENT while ( tail != head_ref ) : NEW_LINE INDENT print ( tail . data , end = \" \u2581 \" ) NEW_LINE tail = tail . prev NEW_LINE DEDENT print ( tail . data ) NEW_LINE DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . data = new_data NEW_LINE new_node . prev = None NEW_LINE new_node . next = head_ref NEW_LINE if ( head_ref != None ) : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 10 ) NEW_LINE print ( \" Linked \u2581 List \u2581 elements \u2581 in \u2581 reverse \u2581 order \u2581 : \u2581 \" ) NEW_LINE reversePrint ( head ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4794_A", "sol": 0, "python_code": "def checkCentrosymmetricted ( n , m ) :\n    mid_row = 0 ;\n    if ( ( n & 1 ) > 0 ) :\n        mid_row = n / 2 + 1 ;\n    else :\n        mid_row = n / 2 ;\n    for i in range ( int ( mid_row ) ) :\n        for j in range ( n ) :\n            if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) :\n                return False ;\n    return True ;\nn = 3 ;\nm = [ [ 1 , 3 , 5 ] , [ 6 , 8 , 6 ] , [ 5 , 3 , 1 ] ] ;\nif ( checkCentrosymmetricted ( n , m ) ) :\n    print ( \"Yes\" ) ;\nelse :\n    print ( \"No\" ) ;\n", "python_code_tokenized": "def checkCentrosymmetricted ( n , m ) : NEW_LINE INDENT mid_row = 0 ; NEW_LINE if ( ( n & 1 ) > 0 ) : NEW_LINE INDENT mid_row = n / 2 + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mid_row = n / 2 ; NEW_LINE DEDENT for i in range ( int ( mid_row ) ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT n = 3 ; NEW_LINE m = [ [ 1 , 3 , 5 ] , [ 6 , 8 , 6 ] , [ 5 , 3 , 1 ] ] ; NEW_LINE if ( checkCentrosymmetricted ( n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1557_B", "sol": 0, "python_code": "for pratyush in range ( int ( input ( ) ) ) :\n    n , k = map ( int , input ( ).split ( ) )\n    l = list ( map ( int , input ( ).split ( ) ) )\n    x = [ ]\n    for i in range ( n ) :\n        x.append ( [ l [ i ] , i ] )\n    y = x.copy ( )\n    y.sort ( )\n    p = 1\n    for i in range ( n - 1 ) :\n        if y [ i ] [ 1 ] + 1 != y [ i + 1 ] [ 1 ] :\n            p += 1\n    if p <= k :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "for pratyush in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x . append ( [ l [ i ] , i ] ) NEW_LINE DEDENT y = x . copy ( ) NEW_LINE y . sort ( ) NEW_LINE p = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if y [ i ] [ 1 ] + 1 != y [ i + 1 ] [ 1 ] : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT if p <= k : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC093_B", "sol": 0, "python_code": "import math\nimport itertools\nimport sys\nimport copy\nA , B , K = map ( int , input ( ).split ( ) )\nif B - A < K * 2 :\n    for i in range ( A , B + 1 ) :\n        print ( str ( i ) )\nelse :\n    for i in range ( A , A + K ) :\n        print ( str ( i ) )\n    for i in range ( B - K + 1 , B + 1 ) :\n        print ( str ( i ) )\n", "python_code_tokenized": "import math NEW_LINE import itertools NEW_LINE import sys NEW_LINE import copy NEW_LINE A , B , K = map ( int , input ( ) . split ( ) ) NEW_LINE if B - A < K * 2 : NEW_LINE INDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT print ( str ( i ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( A , A + K ) : NEW_LINE INDENT print ( str ( i ) ) NEW_LINE DEDENT for i in range ( B - K + 1 , B + 1 ) : NEW_LINE INDENT print ( str ( i ) ) NEW_LINE DEDENT DEDENT"}
{"id": "codejam_11_41", "sol": 0, "python_code": "infile = open ( 'airport_walk.in' )\noutfile = open ( 'airport_walk.out' , 'w' )\nT = int ( infile.readline ( ).strip ( ) )\nfor t in xrange ( T ) :\n    X , S , R , runtime , N = [ int ( s ) for s in infile.readline ( ).strip ( ).split ( ) ]\n    run_bonus = R - S\n    speeds , lengths = [ ] , [ ]\n    walkways = [ ]\n    for i in xrange ( N ) :\n        B , E , w = [ int ( s ) for s in infile.readline ( ).strip ( ).split ( ) ]\n        walkways.append ( ( w + S , E - B ) )\n    sum_lens = sum ( w [ 1 ] for w in walkways )\n    walkways.append ( ( S , X - sum_lens ) )\n    walkways = sorted ( walkways , key = lambda w : w [ 0 ] )\n    answer = 0.0\n    for speed , distance in walkways :\n        cur_runtime = min ( distance / float ( speed + run_bonus ) , float ( runtime ) )\n        runtime -= cur_runtime\n        answer += cur_runtime + ( ( distance - ( speed + run_bonus ) * cur_runtime ) / float ( speed ) )\n    outfile.write ( 'Case #%d: %.9f\\n' % ( t + 1 , answer ) )\n", "python_code_tokenized": "infile = open ( ' airport _ walk . in ' ) NEW_LINE outfile = open ( ' airport _ walk . out ' , ' w ' ) NEW_LINE T = int ( infile . readline ( ) . strip ( ) ) NEW_LINE for t in xrange ( T ) : NEW_LINE INDENT X , S , R , runtime , N = [ int ( s ) for s in infile . readline ( ) . strip ( ) . split ( ) ] NEW_LINE run_bonus = R - S NEW_LINE speeds , lengths = [ ] , [ ] NEW_LINE walkways = [ ] NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT B , E , w = [ int ( s ) for s in infile . readline ( ) . strip ( ) . split ( ) ] NEW_LINE walkways . append ( ( w + S , E - B ) ) NEW_LINE DEDENT sum_lens = sum ( w [ 1 ] for w in walkways ) NEW_LINE walkways . append ( ( S , X - sum_lens ) ) NEW_LINE walkways = sorted ( walkways , key = lambda w : w [ 0 ] ) NEW_LINE answer = 0.0 NEW_LINE for speed , distance in walkways : NEW_LINE INDENT cur_runtime = min ( distance / float ( speed + run_bonus ) , float ( runtime ) ) NEW_LINE runtime -= cur_runtime NEW_LINE answer += cur_runtime + ( ( distance - ( speed + run_bonus ) * cur_runtime ) / float ( speed ) ) NEW_LINE DEDENT outfile . write ( ' Case \u2581 # % d : \u2581 % .9f \\n ' % ( t + 1 , answer ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1269_A", "sol": 0, "python_code": "class newNode :\n    def __init__ ( self , key ) :\n        self.left = self.right = None\n        self.key = key\n        self.isThreaded = None\ndef createThreaded ( root ) :\n    if root == None :\n        return None\n    if root.left == None and root.right == None :\n        return root\n    if root.left != None :\n        l = createThreaded ( root.left )\n        l.right = root\n        l.isThreaded = True\n    if root.right == None :\n        return root\n    return createThreaded ( root.right )\ndef leftMost ( root ) :\n    while root != None and root.left != None :\n        root = root.left\n    return root\ndef inOrder ( root ) :\n    if root == None :\n        return\n    cur = leftMost ( root )\n    while cur != None :\n        print ( cur.key , end = \" \" )\n        if cur.isThreaded :\n            cur = cur.right\n        else :\n            cur = leftMost ( cur.right )\nif __name__ == '__main__' :\n    root = newNode ( 1 )\n    root.left = newNode ( 2 )\n    root.right = newNode ( 3 )\n    root.left.left = newNode ( 4 )\n    root.left.right = newNode ( 5 )\n    root.right.left = newNode ( 6 )\n    root.right.right = newNode ( 7 )\n    createThreaded ( root )\n    print ( \"Inorder traversal of created\" , \"threaded tree is\" )\n    inOrder ( root )\n", "python_code_tokenized": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . left = self . right = None NEW_LINE self . key = key NEW_LINE self . isThreaded = None NEW_LINE DEDENT DEDENT def createThreaded ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return None NEW_LINE DEDENT if root . left == None and root . right == None : NEW_LINE INDENT return root NEW_LINE DEDENT if root . left != None : NEW_LINE INDENT l = createThreaded ( root . left ) NEW_LINE l . right = root NEW_LINE l . isThreaded = True NEW_LINE DEDENT if root . right == None : NEW_LINE INDENT return root NEW_LINE DEDENT return createThreaded ( root . right ) NEW_LINE DEDENT def leftMost ( root ) : NEW_LINE INDENT while root != None and root . left != None : NEW_LINE INDENT root = root . left NEW_LINE DEDENT return root NEW_LINE DEDENT def inOrder ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT cur = leftMost ( root ) NEW_LINE while cur != None : NEW_LINE INDENT print ( cur . key , end = \" \u2581 \" ) NEW_LINE if cur . isThreaded : NEW_LINE INDENT cur = cur . right NEW_LINE DEDENT else : NEW_LINE INDENT cur = leftMost ( cur . right ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . left = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 7 ) NEW_LINE createThreaded ( root ) NEW_LINE print ( \" Inorder \u2581 traversal \u2581 of \u2581 created \" , \" threaded \u2581 tree \u2581 is \" ) NEW_LINE inOrder ( root ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2613_A", "sol": 0, "python_code": "import sys\ndef getMaxValue ( arr , arr_size ) :\n    if ( arr_size < 2 ) :\n        return 0\n    first = - sys.maxsize - 1\n    second = - sys.maxsize - 1\n    for i in range ( arr_size ) :\n        if ( arr [ i ] > first ) :\n            second = first\n            first = arr [ i ]\n        elif ( arr [ i ] > second and arr [ i ] != first ) :\n            second = arr [ i ]\n    if ( second == - sys.maxsize - 1 ) :\n        return 0\n    else :\n        return second\nif __name__ == '__main__' :\n    arr = [ 4 , 5 , 1 , 8 ]\n    n = len ( arr )\n    print ( getMaxValue ( arr , n ) )\n", "python_code_tokenized": "import sys NEW_LINE def getMaxValue ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT first = - sys . maxsize - 1 NEW_LINE second = - sys . maxsize - 1 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second and arr [ i ] != first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT if ( second == - sys . maxsize - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return second NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 5 , 1 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMaxValue ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3691_A", "sol": 0, "python_code": "def product ( N ) :\n    ans = 1 ;\n    val = 2 ** ( N - 1 ) ;\n    for i in range ( 1 , N + 1 ) :\n        ans *= ( i ** val ) ;\n    return ans ;\nif __name__ == \"__main__\" :\n    N = 2 ;\n    print ( product ( N ) ) ;\n", "python_code_tokenized": "def product ( N ) : NEW_LINE INDENT ans = 1 ; NEW_LINE val = 2 ** ( N - 1 ) ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans *= ( i ** val ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 2 ; NEW_LINE print ( product ( N ) ) ; NEW_LINE DEDENT"}
{"id": "aizu_p00116_A", "sol": 0, "python_code": "from itertools import product\nwhile ( True ) :\n    H , W = map ( int , input ( ).split ( ) )\n    if not H : break\n    ma = [ list ( map ( int , input ( ).replace ( \".\" , \"1\" ).replace ( \"*\" , \"0\" ) ) ) + [ 0 ] for _ in range ( H ) ]\n    for i , j in product ( range ( 1 , H ) , range ( W ) ) :\n        if ma [ i ] [ j ] : ma [ i ] [ j ] += ma [ i - 1 ] [ j ]\n    ans = 0\n    for i in range ( H ) :\n        stk = [ ]\n        for j in range ( W + 1 ) :\n            cur = ma [ i ] [ j ]\n            if ( not stk ) or stk [ - 1 ] [ 1 ] < cur :\n                stk.append ( [ j , cur ] )\n            elif stk [ - 1 ] [ 1 ] > cur :\n                idx = j\n                while stk and stk [ - 1 ] [ 1 ] >= cur :\n                    idx = stk [ - 1 ] [ 0 ]\n                    ans = max ( ans , stk [ - 1 ] [ 1 ] * ( j - stk [ - 1 ] [ 0 ] ) )\n                    stk.pop ( )\n                stk.append ( [ idx , cur ] )\n    print ( ans )\n", "python_code_tokenized": "from itertools import product NEW_LINE while ( True ) : NEW_LINE INDENT H , W = map ( int , input ( ) . split ( ) ) NEW_LINE if not H : break NEW_LINE ma = [ list ( map ( int , input ( ) . replace ( \" . \" , \"1\" ) . replace ( \" * \" , \"0\" ) ) ) + [ 0 ] for _ in range ( H ) ] NEW_LINE for i , j in product ( range ( 1 , H ) , range ( W ) ) : NEW_LINE INDENT if ma [ i ] [ j ] : ma [ i ] [ j ] += ma [ i - 1 ] [ j ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( H ) : NEW_LINE INDENT stk = [ ] NEW_LINE for j in range ( W + 1 ) : NEW_LINE INDENT cur = ma [ i ] [ j ] NEW_LINE if ( not stk ) or stk [ - 1 ] [ 1 ] < cur : NEW_LINE INDENT stk . append ( [ j , cur ] ) NEW_LINE DEDENT elif stk [ - 1 ] [ 1 ] > cur : NEW_LINE INDENT idx = j NEW_LINE while stk and stk [ - 1 ] [ 1 ] >= cur : NEW_LINE INDENT idx = stk [ - 1 ] [ 0 ] NEW_LINE ans = max ( ans , stk [ - 1 ] [ 1 ] * ( j - stk [ - 1 ] [ 0 ] ) ) NEW_LINE stk . pop ( ) NEW_LINE DEDENT stk . append ( [ idx , cur ] ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "codeforces_1637_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    n = int ( input ( ) )\n    l = [ int ( x ) for x in input ( ).split ( ) ]\n    ans = 0\n    for i in range ( n ) :\n        ans += ( ( n - i ) * ( n - i + 1 ) ) // 2\n        if l [ i ] == 0 :\n            ans += ( i + 1 ) * ( n - i )\n    print ( ans )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += ( ( n - i ) * ( n - i + 1 ) ) // 2 NEW_LINE if l [ i ] == 0 : NEW_LINE INDENT ans += ( i + 1 ) * ( n - i ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC050_C", "sol": 0, "python_code": "n = int ( input ( ) )\nL = [ int ( i ) for i in input ( ).split ( ) ]\nL.sort ( )\ndef out_detect ( n , L ) :\n    flag = 0\n    if n % 2 == 0 :\n        for i in range ( n ) :\n            if L [ i ] != - ( - ( i + 1 ) // 2 ) * 2 - 1 :\n                flag = 1\n                break\n    else :\n        if L [ 0 ] != 0 :\n            flag = 1\n            return ( flag )\n        for i in range ( 1 , n ) :\n            if L [ i ] != ( - ( - i // 2 ) * 2 ) :\n                flag = 1\n                break\n    return ( flag )\nif out_detect ( n , L ) == 1 :\n    print ( 0 )\nelse :\n    if n % 2 == 0 :\n        out = pow ( 2 , n // 2 )\n    else :\n        out = pow ( 2 , ( n - 1 ) // 2 )\n    print ( out % ( pow ( 10 , 9 ) + 7 ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE L = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE L . sort ( ) NEW_LINE def out_detect ( n , L ) : NEW_LINE INDENT flag = 0 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if L [ i ] != - ( - ( i + 1 ) // 2 ) * 2 - 1 : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if L [ 0 ] != 0 : NEW_LINE INDENT flag = 1 NEW_LINE return ( flag ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if L [ i ] != ( - ( - i // 2 ) * 2 ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return ( flag ) NEW_LINE DEDENT if out_detect ( n , L ) == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT out = pow ( 2 , n // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT out = pow ( 2 , ( n - 1 ) // 2 ) NEW_LINE DEDENT print ( out % ( pow ( 10 , 9 ) + 7 ) ) NEW_LINE DEDENT"}
{"id": "codeforces_37_B", "sol": 0, "python_code": "import itertools\nimport math\nN , x , y = [ int ( n ) for n in input ( ).split ( ) ]\npills = [ ]\nfor i in range ( N ) :\n    pills.append ( tuple ( int ( n ) for n in input ( ).split ( ) ) + ( i + 1 , ) )\npills.sort ( )\nrques = x\nqauto = 0\ntime = 0\nused = [ ]\npossible = set ( )\nwhile rques > 0 :\n    while len ( pills ) > 0 and pills [ - 1 ] [ 0 ] >= 100 * rques / x :\n        possible.add ( pills.pop ( ) [ 1 : ] )\n    if len ( possible ) > 0 :\n        best = max ( possible )\n        used.append ( ( best , time ) )\n        possible.remove ( best )\n        qauto += best [ 0 ]\n    elif qauto <= y :\n        print ( 'NO' )\n        break\n    rques = min ( rques + y - qauto , x )\n    time += 1\nelse :\n    print ( 'YES' )\n    print ( time , len ( used ) )\n    for scroll in used :\n        print ( scroll [ 1 ] , scroll [ 0 ] [ 1 ] )\n", "python_code_tokenized": "import itertools NEW_LINE import math NEW_LINE N , x , y = [ int ( n ) for n in input ( ) . split ( ) ] NEW_LINE pills = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT pills . append ( tuple ( int ( n ) for n in input ( ) . split ( ) ) + ( i + 1 , ) ) NEW_LINE DEDENT pills . sort ( ) NEW_LINE rques = x NEW_LINE qauto = 0 NEW_LINE time = 0 NEW_LINE used = [ ] NEW_LINE possible = set ( ) NEW_LINE while rques > 0 : NEW_LINE INDENT while len ( pills ) > 0 and pills [ - 1 ] [ 0 ] >= 100 * rques / x : NEW_LINE INDENT possible . add ( pills . pop ( ) [ 1 : ] ) NEW_LINE DEDENT if len ( possible ) > 0 : NEW_LINE INDENT best = max ( possible ) NEW_LINE used . append ( ( best , time ) ) NEW_LINE possible . remove ( best ) NEW_LINE qauto += best [ 0 ] NEW_LINE DEDENT elif qauto <= y : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE break NEW_LINE DEDENT rques = min ( rques + y - qauto , x ) NEW_LINE time += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE print ( time , len ( used ) ) NEW_LINE for scroll in used : NEW_LINE INDENT print ( scroll [ 1 ] , scroll [ 0 ] [ 1 ] ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2753_A", "sol": 0, "python_code": "def getCount ( a , b ) :\n    if ( len ( b ) % len ( a ) != 0 ) :\n        return - 1 ;\n    count = int ( len ( b ) / len ( a ) )\n    a = a * count\n    if ( a == b ) :\n        return count\n    return - 1 ;\nif __name__ == '__main__' :\n    a = 'geeks'\n    b = 'geeksgeeks'\n    print ( getCount ( a , b ) )\n", "python_code_tokenized": "def getCount ( a , b ) : NEW_LINE INDENT if ( len ( b ) % len ( a ) != 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT count = int ( len ( b ) / len ( a ) ) NEW_LINE a = a * count NEW_LINE if ( a == b ) : NEW_LINE INDENT return count NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = ' geeks ' NEW_LINE b = ' geeksgeeks ' NEW_LINE print ( getCount ( a , b ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00748_A", "sol": 0, "python_code": "INF = 10 ** 20\nMAX_INT = 10 ** 6\na = [ INF ] * MAX_INT\nb = [ INF ] * MAX_INT\na [ 0 ] , b [ 0 ] = 0 , 0\nfor i in range ( 1 , 200 ) :\n    t = i * ( i + 1 ) * ( i + 2 ) // 6\n    mm = min ( t * 5 , MAX_INT )\n    for j in range ( t , mm ) :\n        if a [ j ] > a [ j - t ] + 1 :\n            a [ j ] = a [ j - t ] + 1\n    if t % 2 == 0 : continue\n    for j in range ( t , MAX_INT ) :\n        if b [ j ] > b [ j - t ] + 1 :\n            b [ j ] = b [ j - t ] + 1\nwhile True :\n    N = int ( input ( ) )\n    if N == 0 : exit ( )\n    print ( a [ N ] , b [ N ] )\n", "python_code_tokenized": "INF = 10 ** 20 NEW_LINE MAX_INT = 10 ** 6 NEW_LINE a = [ INF ] * MAX_INT NEW_LINE b = [ INF ] * MAX_INT NEW_LINE a [ 0 ] , b [ 0 ] = 0 , 0 NEW_LINE for i in range ( 1 , 200 ) : NEW_LINE INDENT t = i * ( i + 1 ) * ( i + 2 ) // 6 NEW_LINE mm = min ( t * 5 , MAX_INT ) NEW_LINE for j in range ( t , mm ) : NEW_LINE INDENT if a [ j ] > a [ j - t ] + 1 : NEW_LINE INDENT a [ j ] = a [ j - t ] + 1 NEW_LINE DEDENT DEDENT if t % 2 == 0 : continue NEW_LINE for j in range ( t , MAX_INT ) : NEW_LINE INDENT if b [ j ] > b [ j - t ] + 1 : NEW_LINE INDENT b [ j ] = b [ j - t ] + 1 NEW_LINE DEDENT DEDENT DEDENT while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : exit ( ) NEW_LINE print ( a [ N ] , b [ N ] ) NEW_LINE DEDENT"}
{"id": "aizu_p01713_A", "sol": 0, "python_code": "w = int ( input ( ) )\nalst = list ( map ( int , input ( ).split ( ) ) )\nINF = 10 ** 20\nacc = - INF\nleft = [ ]\nfor i in range ( w ) :\n    a = alst [ i ]\n    if a == 0 :\n        acc = INF\n    elif a > 0 :\n        acc -= 1\n    elif a < 0 :\n        acc = min ( acc - 1 , - a )\n    left.append ( acc )\nacc = - INF\nright = [ ]\nfor i in range ( w ) :\n    a = alst [ w - i - 1 ]\n    if a == 0 :\n        acc = INF\n    elif a > 0 :\n        acc -= 1\n    elif a < 0 :\n        acc = min ( acc - 1 , - a )\n    right.append ( acc )\nright.reverse ( )\nprint ( sum ( [ max ( 0 , min ( alst [ i ] , max ( left [ i ] , right [ i ] ) ) ) for i in range ( w ) ] ) )\n", "python_code_tokenized": "w = int ( input ( ) ) NEW_LINE alst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE INF = 10 ** 20 NEW_LINE acc = - INF NEW_LINE left = [ ] NEW_LINE for i in range ( w ) : NEW_LINE INDENT a = alst [ i ] NEW_LINE if a == 0 : NEW_LINE INDENT acc = INF NEW_LINE DEDENT elif a > 0 : NEW_LINE INDENT acc -= 1 NEW_LINE DEDENT elif a < 0 : NEW_LINE INDENT acc = min ( acc - 1 , - a ) NEW_LINE DEDENT left . append ( acc ) NEW_LINE DEDENT acc = - INF NEW_LINE right = [ ] NEW_LINE for i in range ( w ) : NEW_LINE INDENT a = alst [ w - i - 1 ] NEW_LINE if a == 0 : NEW_LINE INDENT acc = INF NEW_LINE DEDENT elif a > 0 : NEW_LINE INDENT acc -= 1 NEW_LINE DEDENT elif a < 0 : NEW_LINE INDENT acc = min ( acc - 1 , - a ) NEW_LINE DEDENT right . append ( acc ) NEW_LINE DEDENT right . reverse ( ) NEW_LINE print ( sum ( [ max ( 0 , min ( alst [ i ] , max ( left [ i ] , right [ i ] ) ) ) for i in range ( w ) ] ) ) NEW_LINE"}
{"id": "aizu_p00340_A", "sol": 0, "python_code": "a , b , c , d = ( int ( x ) for x in input ( ).split ( ) )\na , b , c , d = sorted ( [ a , b , c , d ] )\nif a == b and c == d :\n    print ( \"yes\" )\nelse :\n    print ( \"no\" )\n", "python_code_tokenized": "a , b , c , d = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE a , b , c , d = sorted ( [ a , b , c , d ] ) NEW_LINE if a == b and c == d : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4416_A", "sol": 0, "python_code": "def spiralDiaSum ( n ) :\n    if n == 1 :\n        return 1\n    return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) )\nn = 7 ;\nprint ( spiralDiaSum ( n ) )\n", "python_code_tokenized": "def spiralDiaSum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) NEW_LINE DEDENT n = 7 ; NEW_LINE print ( spiralDiaSum ( n ) ) NEW_LINE"}
{"id": "atcoder_ABC168_B", "sol": 0, "python_code": "k = input ( )\nk = int ( k )\ns = input ( )\nif len ( s ) <= k :\n    print ( str ( s ) )\nelse :\n    s = s [ : k ]\n    print ( str ( s ) + \"...\" )\n", "python_code_tokenized": "k = input ( ) NEW_LINE k = int ( k ) NEW_LINE s = input ( ) NEW_LINE if len ( s ) <= k : NEW_LINE INDENT print ( str ( s ) ) NEW_LINE DEDENT else : NEW_LINE INDENT s = s [ : k ] NEW_LINE print ( str ( s ) + \" . . . \" ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC172_A", "sol": 0, "python_code": "a = int ( input ( ) )\nprint ( a + a ** 2 + a ** 3 )\n", "python_code_tokenized": "a = int ( input ( ) ) NEW_LINE print ( a + a ** 2 + a ** 3 ) NEW_LINE"}
{"id": "geeksforgeeks_2399_A", "sol": 0, "python_code": "def checkUtil ( num , dig , base ) :\n    if ( dig == 1 and num < base ) :\n        return True\n    if ( dig > 1 and num >= base ) :\n        return checkUtil ( num / base , - - dig , base )\n    return False\ndef check ( num , dig ) :\n    for base in range ( 2 , 33 ) :\n        if ( checkUtil ( num , dig , base ) ) :\n            return True\n    return False\nnum = 8\ndig = 3\nif ( check ( num , dig ) == True ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def checkUtil ( num , dig , base ) : NEW_LINE INDENT if ( dig == 1 and num < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig > 1 and num >= base ) : NEW_LINE INDENT return checkUtil ( num / base , - - dig , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 33 ) : NEW_LINE INDENT if ( checkUtil ( num , dig , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT num = 8 NEW_LINE dig = 3 NEW_LINE if ( check ( num , dig ) == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "codeforces_79_B", "sol": 0, "python_code": "n , m , k , t = map ( int , input ( ).split ( ) )\nwasted , wanted = [ ] , [ ]\ndic = { 1 : \"Carrots\" , 2 : \"Kiwis\" , 0 : \"Grapes\" }\nfor i in range ( k + t ) :\n    if k :\n        a , b = map ( int , input ( ).split ( ) )\n        wasted.append ( [ a , b ] ) ; k -= 1\n    else :\n        i , j = map ( int , input ( ).split ( ) )\n        wanted.append ( [ i , j ] )\nshift = 0 ; wasted.sort ( )\nfor cell in wanted :\n    if cell in wasted : print ( \"Waste\" )\n    else :\n        for ele in wasted :\n            if ele [ 0 ] < cell [ 0 ] : shift += 1\n            elif ele [ 0 ] == cell [ 0 ] and ele [ 1 ] < cell [ 1 ] : shift += 1\n            else : break\n        print ( dic [ ( cell [ 1 ] + ( ( cell [ 0 ] - 1 ) * m ) - shift ) % 3 ] )\n        shift = 0\n", "python_code_tokenized": "n , m , k , t = map ( int , input ( ) . split ( ) ) NEW_LINE wasted , wanted = [ ] , [ ] NEW_LINE dic = { 1 : \" Carrots \" , 2 : \" Kiwis \" , 0 : \" Grapes \" } NEW_LINE for i in range ( k + t ) : NEW_LINE INDENT if k : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE wasted . append ( [ a , b ] ) ; k -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i , j = map ( int , input ( ) . split ( ) ) NEW_LINE wanted . append ( [ i , j ] ) NEW_LINE DEDENT DEDENT shift = 0 ; wasted . sort ( ) NEW_LINE for cell in wanted : NEW_LINE INDENT if cell in wasted : print ( \" Waste \" ) NEW_LINE else : NEW_LINE INDENT for ele in wasted : NEW_LINE INDENT if ele [ 0 ] < cell [ 0 ] : shift += 1 NEW_LINE elif ele [ 0 ] == cell [ 0 ] and ele [ 1 ] < cell [ 1 ] : shift += 1 NEW_LINE else : break NEW_LINE DEDENT print ( dic [ ( cell [ 1 ] + ( ( cell [ 0 ] - 1 ) * m ) - shift ) % 3 ] ) NEW_LINE shift = 0 NEW_LINE DEDENT DEDENT"}
{"id": "codejam_16_02", "sol": 0, "python_code": "import sys\nwith open ( sys.argv [ 1 ] ) as f :\n    lines = f.readlines ( )\nT = int ( lines [ 0 ] , 10 )\nfor tt , l in enumerate ( lines [ 1 : ] ) :\n    pancakes = l.strip ( )\n    done = False\n    flips = 0\n    while 1 :\n        index = pancakes.rfind ( \"-\" )\n        if index == - 1 :\n            break\n        flips += 1\n        new_cakes = \"\"\n        for i in xrange ( index + 1 ) :\n            if pancakes [ i ] == \"+\" :\n                new_cakes += \"-\"\n            elif pancakes [ i ] == \"-\" :\n                new_cakes += \"+\"\n            else :\n                raise Exception ( \"wtf\" )\n        pancakes = new_cakes + pancakes [ index + 1 : ]\n    print ( \"Case #%d:\" % ( tt + 1 ) ) , flips\n", "python_code_tokenized": "import sys NEW_LINE with open ( sys . argv [ 1 ] ) as f : NEW_LINE INDENT lines = f . readlines ( ) NEW_LINE DEDENT T = int ( lines [ 0 ] , 10 ) NEW_LINE for tt , l in enumerate ( lines [ 1 : ] ) : NEW_LINE INDENT pancakes = l . strip ( ) NEW_LINE done = False NEW_LINE flips = 0 NEW_LINE while 1 : NEW_LINE INDENT index = pancakes . rfind ( \" - \" ) NEW_LINE if index == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT flips += 1 NEW_LINE new_cakes = \" \" NEW_LINE for i in xrange ( index + 1 ) : NEW_LINE INDENT if pancakes [ i ] == \" + \" : NEW_LINE INDENT new_cakes += \" - \" NEW_LINE DEDENT elif pancakes [ i ] == \" - \" : NEW_LINE INDENT new_cakes += \" + \" NEW_LINE DEDENT else : NEW_LINE INDENT raise Exception ( \" wtf \" ) NEW_LINE DEDENT DEDENT pancakes = new_cakes + pancakes [ index + 1 : ] NEW_LINE DEDENT print ( \" Case \u2581 # % d : \" % ( tt + 1 ) ) , flips NEW_LINE DEDENT"}
{"id": "aizu_p00925_A", "sol": 0, "python_code": "s = input ( )\nt = int ( input ( ) )\ne1 = eval ( s )\ne2 = int ( s [ 0 ] )\ni = 1\nwhile i < len ( s ) :\n    x = int ( s [ i + 1 ] )\n    if s [ i ] == '+' :\n        e2 += x\n    else :\n        e2 *= x\n    i += 2\nif e1 == t and e2 == t :\n    print ( \"U\" )\nelif e1 == t :\n    print ( \"M\" )\nelif e2 == t :\n    print ( \"L\" )\nelse :\n    print ( \"I\" )\n", "python_code_tokenized": "s = input ( ) NEW_LINE t = int ( input ( ) ) NEW_LINE e1 = eval ( s ) NEW_LINE e2 = int ( s [ 0 ] ) NEW_LINE i = 1 NEW_LINE while i < len ( s ) : NEW_LINE INDENT x = int ( s [ i + 1 ] ) NEW_LINE if s [ i ] == ' + ' : NEW_LINE INDENT e2 += x NEW_LINE DEDENT else : NEW_LINE INDENT e2 *= x NEW_LINE DEDENT i += 2 NEW_LINE DEDENT if e1 == t and e2 == t : NEW_LINE INDENT print ( \" U \" ) NEW_LINE DEDENT elif e1 == t : NEW_LINE INDENT print ( \" M \" ) NEW_LINE DEDENT elif e2 == t : NEW_LINE INDENT print ( \" L \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" I \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1006_B", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\na = [ ( int ( x ) , i ) for ( i , x ) in enumerate ( input ( ).split ( ) ) ]\na.sort ( )\nused = [ False for i in range ( n ) ]\nsum = 0\nfor ( val , index ) in a [ - k : ] :\n    sum += val\n    used [ index ] = True\nprint ( sum )\ncur = 0\nans = [ ]\nfor i in range ( n ) :\n    if used [ i ] :\n        ans.append ( cur + 1 )\n        cur = 0\n    else :\n        cur += 1\nif cur > 0 :\n    ans [ - 1 ] += cur\nprint ( * ans )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ( int ( x ) , i ) for ( i , x ) in enumerate ( input ( ) . split ( ) ) ] NEW_LINE a . sort ( ) NEW_LINE used = [ False for i in range ( n ) ] NEW_LINE sum = 0 NEW_LINE for ( val , index ) in a [ - k : ] : NEW_LINE INDENT sum += val NEW_LINE used [ index ] = True NEW_LINE DEDENT print ( sum ) NEW_LINE cur = 0 NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if used [ i ] : NEW_LINE INDENT ans . append ( cur + 1 ) NEW_LINE cur = 0 NEW_LINE DEDENT else : NEW_LINE INDENT cur += 1 NEW_LINE DEDENT DEDENT if cur > 0 : NEW_LINE INDENT ans [ - 1 ] += cur NEW_LINE DEDENT print ( * ans ) NEW_LINE"}
{"id": "codejam_09_41", "sol": 0, "python_code": "import sys\ndef max1 ( r ) :\n    z = [ i for i in range ( len ( r ) ) if r [ i ] == 1 ]\n    if ( z == [ ] ) :\n        return 0\n    else :\n        return max ( z )\ndef solve ( inp ) :\n    inp = [ max1 ( s ) for s in inp ]\n    ans = 0\n    for i in range ( len ( inp ) ) :\n        z = min ( [ q for q in range ( len ( inp ) ) if q >= i and inp [ q ] <= i ] )\n        r = list ( range ( i , z ) )\n        r.reverse ( )\n        for j in r :\n            inp [ j ] , inp [ j + 1 ] = inp [ j + 1 ] , inp [ j ]\n            ans += 1\n    return ans\nrdln = sys.stdin.readline\nT = int ( rdln ( ) )\nfor t in range ( T ) :\n    N = int ( rdln ( ) )\n    print ( \"Case #\" , t + 1 , \": \" , solve ( [ [ int ( c ) for c in rdln ( ).strip ( ) ] for w in range ( N ) ] ) , sep = \"\" )\n", "python_code_tokenized": "import sys NEW_LINE def max1 ( r ) : NEW_LINE INDENT z = [ i for i in range ( len ( r ) ) if r [ i ] == 1 ] NEW_LINE if ( z == [ ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return max ( z ) NEW_LINE DEDENT DEDENT def solve ( inp ) : NEW_LINE INDENT inp = [ max1 ( s ) for s in inp ] NEW_LINE ans = 0 NEW_LINE for i in range ( len ( inp ) ) : NEW_LINE INDENT z = min ( [ q for q in range ( len ( inp ) ) if q >= i and inp [ q ] <= i ] ) NEW_LINE r = list ( range ( i , z ) ) NEW_LINE r . reverse ( ) NEW_LINE for j in r : NEW_LINE INDENT inp [ j ] , inp [ j + 1 ] = inp [ j + 1 ] , inp [ j ] NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT rdln = sys . stdin . readline NEW_LINE T = int ( rdln ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT N = int ( rdln ( ) ) NEW_LINE print ( \" Case \u2581 # \" , t + 1 , \" : \u2581 \" , solve ( [ [ int ( c ) for c in rdln ( ) . strip ( ) ] for w in range ( N ) ] ) , sep = \" \" ) NEW_LINE DEDENT"}
{"id": "codeforces_680_B", "sol": 0, "python_code": "cty , loc = map ( int , input ( ).split ( ) )\ncrim = list ( map ( int , input ( ).split ( ) ) )\ncoont = 0\nif crim [ loc - 1 ] == 1 :\n    coont += 1\nfor i in range ( 1000 ) :\n    if i == 0 :\n        continue\n    if loc - 1 - i >= 0 and loc + i - 1 < cty :\n        if crim [ loc - 1 - i ] == 1 and crim [ loc + i - 1 ] == 1 :\n            coont += 2\n    elif loc - 1 - i >= 0 :\n        if crim [ loc - 1 - i ] == 1 :\n            coont += 1\n    elif loc + i - 1 < cty and crim [ loc + i - 1 ] == 1 :\n        coont += 1\nprint ( coont )\n", "python_code_tokenized": "cty , loc = map ( int , input ( ) . split ( ) ) NEW_LINE crim = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE coont = 0 NEW_LINE if crim [ loc - 1 ] == 1 : NEW_LINE INDENT coont += 1 NEW_LINE DEDENT for i in range ( 1000 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if loc - 1 - i >= 0 and loc + i - 1 < cty : NEW_LINE INDENT if crim [ loc - 1 - i ] == 1 and crim [ loc + i - 1 ] == 1 : NEW_LINE INDENT coont += 2 NEW_LINE DEDENT DEDENT elif loc - 1 - i >= 0 : NEW_LINE INDENT if crim [ loc - 1 - i ] == 1 : NEW_LINE INDENT coont += 1 NEW_LINE DEDENT DEDENT elif loc + i - 1 < cty and crim [ loc + i - 1 ] == 1 : NEW_LINE INDENT coont += 1 NEW_LINE DEDENT DEDENT print ( coont ) NEW_LINE"}
{"id": "aizu_p01119_A", "sol": 0, "python_code": "from bisect import bisect_left , bisect_right\nwhile True :\n    n , m = map ( int , input ( ).split ( ) )\n    if n == m == 0 :\n        break\n    a = list ( map ( int , input ( ).split ( ) ) )\n    w = list ( map ( int , input ( ).split ( ) ) )\n    Set = set ( )\n    def go ( i , weight ) :\n        if i == m :\n            Set.add ( weight )\n            return\n        go ( i + 1 , weight )\n        go ( i + 1 , weight + w [ i ] )\n        go ( i + 1 , weight - w [ i ] )\n    go ( 0 , 0 )\n    ans = False\n    for i in a :\n        if i not in Set :\n            if ans == False :\n                ans = set ( abs ( s - i ) for s in Set )\n            else :\n                ans = set ( s for s in ans if i + s in Set or i - s in Set )\n    if ans == False :\n        print ( 0 )\n        continue\n    elif len ( ans ) == 0 :\n        print ( - 1 )\n        continue\n    else :\n        print ( min ( ans ) )\n", "python_code_tokenized": "from bisect import bisect_left , bisect_right NEW_LINE while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Set = set ( ) NEW_LINE def go ( i , weight ) : NEW_LINE INDENT if i == m : NEW_LINE INDENT Set . add ( weight ) NEW_LINE return NEW_LINE DEDENT go ( i + 1 , weight ) NEW_LINE go ( i + 1 , weight + w [ i ] ) NEW_LINE go ( i + 1 , weight - w [ i ] ) NEW_LINE DEDENT go ( 0 , 0 ) NEW_LINE ans = False NEW_LINE for i in a : NEW_LINE INDENT if i not in Set : NEW_LINE INDENT if ans == False : NEW_LINE INDENT ans = set ( abs ( s - i ) for s in Set ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = set ( s for s in ans if i + s in Set or i - s in Set ) NEW_LINE DEDENT DEDENT DEDENT if ans == False : NEW_LINE INDENT print ( 0 ) NEW_LINE continue NEW_LINE DEDENT elif len ( ans ) == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( ans ) ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_412_B", "sol": 0, "python_code": "n_computers , k_participants = map ( int , input ( ).split ( ) )\nkps = list ( map ( int , input ( ).split ( ) ) )\nprint ( min ( sorted ( kps , reverse = True ) [ : k_participants ] ) )\n", "python_code_tokenized": "n_computers , k_participants = map ( int , input ( ) . split ( ) ) NEW_LINE kps = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( min ( sorted ( kps , reverse = True ) [ : k_participants ] ) ) NEW_LINE"}
{"id": "geeksforgeeks_2504_A", "sol": 0, "python_code": "def minimumOperations ( arr , n ) :\n    brr = [ 0 , 0 , 0 , 0 ]\n    for i in range ( n ) :\n        brr [ arr [ i ] % 4 ] += 1 ;\n    if ( ( brr [ 1 ] + 2 * brr [ 2 ] + 3 * brr [ 3 ] ) % 4 == 0 ) :\n        min_opr = min ( brr [ 3 ] , brr [ 1 ] )\n        brr [ 3 ] -= min_opr\n        brr [ 1 ] -= min_opr\n        min_opr += brr [ 2 ] // 2\n        brr [ 2 ] %= 2\n        if ( brr [ 2 ] ) :\n            min_opr += 2\n            brr [ 2 ] = 0\n            if ( brr [ 3 ] ) :\n                brr [ 3 ] -= 2\n            if ( brr [ 1 ] ) :\n                brr [ 1 ] -= 2\n        if ( brr [ 1 ] ) :\n            min_opr += ( brr [ 1 ] // 4 ) * 3\n        if ( brr [ 3 ] ) :\n            min_opr += ( brr [ 3 ] // 4 ) * 3\n        return min_opr\n    return - 1\narr = [ 1 , 2 , 3 , 1 , 2 , 3 , 8 ]\nn = len ( arr )\nprint ( minimumOperations ( arr , n ) )\n", "python_code_tokenized": "def minimumOperations ( arr , n ) : NEW_LINE INDENT brr = [ 0 , 0 , 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ arr [ i ] % 4 ] += 1 ; NEW_LINE DEDENT if ( ( brr [ 1 ] + 2 * brr [ 2 ] + 3 * brr [ 3 ] ) % 4 == 0 ) : NEW_LINE INDENT min_opr = min ( brr [ 3 ] , brr [ 1 ] ) NEW_LINE brr [ 3 ] -= min_opr NEW_LINE brr [ 1 ] -= min_opr NEW_LINE min_opr += brr [ 2 ] // 2 NEW_LINE brr [ 2 ] %= 2 NEW_LINE if ( brr [ 2 ] ) : NEW_LINE INDENT min_opr += 2 NEW_LINE brr [ 2 ] = 0 NEW_LINE if ( brr [ 3 ] ) : NEW_LINE INDENT brr [ 3 ] -= 2 NEW_LINE DEDENT if ( brr [ 1 ] ) : NEW_LINE INDENT brr [ 1 ] -= 2 NEW_LINE DEDENT DEDENT if ( brr [ 1 ] ) : NEW_LINE INDENT min_opr += ( brr [ 1 ] // 4 ) * 3 NEW_LINE DEDENT if ( brr [ 3 ] ) : NEW_LINE INDENT min_opr += ( brr [ 3 ] // 4 ) * 3 NEW_LINE DEDENT return min_opr NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 1 , 2 , 3 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumOperations ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_862_A", "sol": 0, "python_code": "from math import *\ndef SieveOfEratosthenes ( n , isPrime ) :\n    isPrime [ 0 ] , isPrime [ 1 ] = False , False\n    for i in range ( 2 , n + 1 ) :\n        isPrime [ i ] = True\n    for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) :\n        if isPrime [ p ] == True :\n            for i in range ( p * 2 , n + 1 , p ) :\n                isPrime [ i ] = False\ndef findPrimePair ( n ) :\n    flag = 0\n    isPrime = [ False ] * ( n + 1 )\n    SieveOfEratosthenes ( n , isPrime )\n    for i in range ( 2 , n ) :\n        x = int ( n / i )\n        if ( isPrime [ i ] & isPrime [ x ] and x != i and x * i == n ) :\n            print ( i , x )\n            flag = 1\n            break\n    if not flag :\n        print ( \"No such pair found\" )\nif __name__ == \"__main__\" :\n    n = 39 ;\n    findPrimePair ( n )\n", "python_code_tokenized": "from math import * NEW_LINE def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] , isPrime [ 1 ] = False , False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if isPrime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def findPrimePair ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE isPrime = [ False ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT x = int ( n / i ) NEW_LINE if ( isPrime [ i ] & isPrime [ x ] and x != i and x * i == n ) : NEW_LINE INDENT print ( i , x ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT print ( \" No \u2581 such \u2581 pair \u2581 found \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 39 ; NEW_LINE findPrimePair ( n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_698_A", "sol": 0, "python_code": "def positiveNegativeZero ( arr ) :\n    length = len ( arr ) ;\n    positiveCount = 0 ;\n    negativeCount = 0 ;\n    zeroCount = 0 ;\n    for i in range ( length ) :\n        if ( arr [ i ] > 0 ) :\n            positiveCount += 1 ;\n        elif ( arr [ i ] < 0 ) :\n            negativeCount += 1 ;\n        elif ( arr [ i ] == 0 ) :\n            zeroCount += 1 ;\n    print ( \"{0:.4f}\".format ( ( positiveCount / length ) ) , end = \" \" ) ;\n    print ( \"%1.4f \" % ( negativeCount / length ) , end = \" \" ) ;\n    print ( \"%1.4f \" % ( zeroCount / length ) , end = \" \" ) ;\n    print ( ) ;\nif __name__ == '__main__' :\n    a1 = [ 2 , - 1 , 5 , 6 , 0 , - 3 ] ;\n    positiveNegativeZero ( a1 ) ;\n    a2 = [ 4 , 0 , - 2 , - 9 , - 7 , 1 ] ;\n    positiveNegativeZero ( a2 ) ;\n", "python_code_tokenized": "def positiveNegativeZero ( arr ) : NEW_LINE INDENT length = len ( arr ) ; NEW_LINE positiveCount = 0 ; NEW_LINE negativeCount = 0 ; NEW_LINE zeroCount = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT positiveCount += 1 ; NEW_LINE DEDENT elif ( arr [ i ] < 0 ) : NEW_LINE INDENT negativeCount += 1 ; NEW_LINE DEDENT elif ( arr [ i ] == 0 ) : NEW_LINE INDENT zeroCount += 1 ; NEW_LINE DEDENT DEDENT print ( \" { 0 : . 4f } \" . format ( ( positiveCount / length ) ) , end = \" \u2581 \" ) ; NEW_LINE print ( \" % 1.4f \u2581 \" % ( negativeCount / length ) , end = \" \u2581 \" ) ; NEW_LINE print ( \" % 1.4f \u2581 \" % ( zeroCount / length ) , end = \" \u2581 \" ) ; NEW_LINE print ( ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a1 = [ 2 , - 1 , 5 , 6 , 0 , - 3 ] ; NEW_LINE positiveNegativeZero ( a1 ) ; NEW_LINE a2 = [ 4 , 0 , - 2 , - 9 , - 7 , 1 ] ; NEW_LINE positiveNegativeZero ( a2 ) ; NEW_LINE DEDENT"}
{"id": "aizu_p02273_A", "sol": 0, "python_code": "import math\ndef plot ( x , y ) :\n    print ( f'{x:.8f} {y:.8f}' )\ndef Koch ( n , x1 , y1 , x2 , y2 ) :\n    if n == 0 :\n        plot ( x1 , y1 )\n        return\n    sx = ( 2 * x1 + x2 ) / 3\n    sy = ( 2 * y1 + y2 ) / 3\n    tx = ( x1 + 2 * x2 ) / 3\n    ty = ( y1 + 2 * y2 ) / 3\n    ux = ( tx - sx ) * ( 1 / 2 ) - ( ty - sy ) * ( math.sqrt ( 3 ) / 2 ) + sx\n    uy = ( tx - sx ) * ( math.sqrt ( 3 ) / 2 ) + ( ty - sy ) * ( 1 / 2 ) + sy\n    Koch ( n - 1 , x1 , y1 , sx , sy )\n    Koch ( n - 1 , sx , sy , ux , uy )\n    Koch ( n - 1 , ux , uy , tx , ty )\n    Koch ( n - 1 , tx , ty , x2 , y2 )\nn = int ( input ( ) )\nKoch ( n , 0 , 0 , 100 , 0 )\nplot ( 100 , 0 )\n", "python_code_tokenized": "import math NEW_LINE def plot ( x , y ) : NEW_LINE INDENT print ( f ' { x : .8f } \u2581 { y : .8f } ' ) NEW_LINE DEDENT def Koch ( n , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT plot ( x1 , y1 ) NEW_LINE return NEW_LINE DEDENT sx = ( 2 * x1 + x2 ) / 3 NEW_LINE sy = ( 2 * y1 + y2 ) / 3 NEW_LINE tx = ( x1 + 2 * x2 ) / 3 NEW_LINE ty = ( y1 + 2 * y2 ) / 3 NEW_LINE ux = ( tx - sx ) * ( 1 / 2 ) - ( ty - sy ) * ( math . sqrt ( 3 ) / 2 ) + sx NEW_LINE uy = ( tx - sx ) * ( math . sqrt ( 3 ) / 2 ) + ( ty - sy ) * ( 1 / 2 ) + sy NEW_LINE Koch ( n - 1 , x1 , y1 , sx , sy ) NEW_LINE Koch ( n - 1 , sx , sy , ux , uy ) NEW_LINE Koch ( n - 1 , ux , uy , tx , ty ) NEW_LINE Koch ( n - 1 , tx , ty , x2 , y2 ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE Koch ( n , 0 , 0 , 100 , 0 ) NEW_LINE plot ( 100 , 0 ) NEW_LINE"}
{"id": "atcoder_ARC060_C", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nimport bisect\nn = int ( input ( ) )\nX = list ( map ( int , input ( ).split ( ) ) )\nl = int ( input ( ) )\nU = 17\ndp = [ [ 0 ] * n for _ in range ( U + 1 ) ]\nfor i , x in enumerate ( X ) :\n    t = bisect.bisect_left ( X , x + l )\n    dp [ 0 ] [ i ] = bisect.bisect_right ( X , x + l ) - 1\nfor k in range ( U ) :\n    for i in range ( n ) :\n        dp [ k + 1 ] [ i ] = dp [ k ] [ dp [ k ] [ i ] ]\ndef test ( x , a , b ) :\n    for i in range ( U , - 1 , - 1 ) :\n        if x >> i & 1 :\n            a = dp [ i ] [ a ]\n    return a >= b\ndef solve ( a , b ) :\n    if a > b :\n        a , b = b , a\n    ng = 0\n    ok = n - 1\n    while ok - ng > 1 :\n        mid = ( ng + ok ) // 2\n        if test ( mid , a , b ) :\n            ok = mid\n        else :\n            ng = mid\n    print ( ok )\nq = int ( input ( ) )\nfor _ in range ( q ) :\n    a , b = map ( int , input ( ).split ( ) )\n    a -= 1\n    b -= 1\n    solve ( a , b )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = int ( input ( ) ) NEW_LINE U = 17 NEW_LINE dp = [ [ 0 ] * n for _ in range ( U + 1 ) ] NEW_LINE for i , x in enumerate ( X ) : NEW_LINE INDENT t = bisect . bisect_left ( X , x + l ) NEW_LINE dp [ 0 ] [ i ] = bisect . bisect_right ( X , x + l ) - 1 NEW_LINE DEDENT for k in range ( U ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT dp [ k + 1 ] [ i ] = dp [ k ] [ dp [ k ] [ i ] ] NEW_LINE DEDENT DEDENT def test ( x , a , b ) : NEW_LINE INDENT for i in range ( U , - 1 , - 1 ) : NEW_LINE INDENT if x >> i & 1 : NEW_LINE INDENT a = dp [ i ] [ a ] NEW_LINE DEDENT DEDENT return a >= b NEW_LINE DEDENT def solve ( a , b ) : NEW_LINE INDENT if a > b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT ng = 0 NEW_LINE ok = n - 1 NEW_LINE while ok - ng > 1 : NEW_LINE INDENT mid = ( ng + ok ) // 2 NEW_LINE if test ( mid , a , b ) : NEW_LINE INDENT ok = mid NEW_LINE DEDENT else : NEW_LINE INDENT ng = mid NEW_LINE DEDENT DEDENT print ( ok ) NEW_LINE DEDENT q = int ( input ( ) ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE solve ( a , b ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3826_A", "sol": 0, "python_code": "def findIntegers ( n , x , y ) :\n    ans = [ ]\n    for i in range ( n - 1 ) :\n        ans.append ( 1 )\n    if ( y - ( n - 1 ) <= 0 ) :\n        print ( \"-1\" , end = \"\" )\n        return\n    ans.append ( y - ( n - 1 ) )\n    store = 0\n    for i in range ( n ) :\n        store += ans [ i ] * ans [ i ]\n    if ( store < x ) :\n        print ( \"-1\" , end = \"\" )\n        return ;\n    for i in range ( n ) :\n        print ( ans [ i ] , end = \" \" )\nn , x , y = 3 , 254 , 18\nfindIntegers ( n , x , y )\n", "python_code_tokenized": "def findIntegers ( n , x , y ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT if ( y - ( n - 1 ) <= 0 ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT ans . append ( y - ( n - 1 ) ) NEW_LINE store = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT store += ans [ i ] * ans [ i ] NEW_LINE DEDENT if ( store < x ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) NEW_LINE return ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT n , x , y = 3 , 254 , 18 NEW_LINE findIntegers ( n , x , y ) NEW_LINE"}
{"id": "codeforces_1256_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    a , b , n , s = map ( int , input ( ).split ( ) )\n    print ( 'YES' ) if n * min ( s // n , a ) + b >= s else print ( 'NO' )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , n , s = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ' YES ' ) if n * min ( s // n , a ) + b >= s else print ( ' NO ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4923_A", "sol": 0, "python_code": "MAX_CHAR = 26 ;\ndef countSubstringWithEqualEnds ( s ) :\n    result = 0 ;\n    n = len ( s ) ;\n    count = [ 0 ] * MAX_CHAR ;\n    for i in range ( n ) :\n        count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 ;\n    for i in range ( MAX_CHAR ) :\n        result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ;\n    return result ;\ns = \"abcab\" ;\nprint ( countSubstringWithEqualEnds ( s ) ) ;\n", "python_code_tokenized": "MAX_CHAR = 26 ; NEW_LINE def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE count = [ 0 ] * MAX_CHAR ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT s = \" abcab \" ; NEW_LINE print ( countSubstringWithEqualEnds ( s ) ) ; NEW_LINE"}
{"id": "atcoder_ARC078_A", "sol": 0, "python_code": "N = int ( input ( ) )\nS = 0\ns_list = [ ]\ninput_list = list ( map ( int , input ( ).split ( ) ) )\nallS = sum ( input_list )\nfor n in input_list [ : - 1 ] :\n    S += n\n    s_list.append ( abs ( allS - 2 * S ) )\nprint ( min ( s_list ) )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE S = 0 NEW_LINE s_list = [ ] NEW_LINE input_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE allS = sum ( input_list ) NEW_LINE for n in input_list [ : - 1 ] : NEW_LINE INDENT S += n NEW_LINE s_list . append ( abs ( allS - 2 * S ) ) NEW_LINE DEDENT print ( min ( s_list ) ) NEW_LINE"}
{"id": "geeksforgeeks_7_A", "sol": 0, "python_code": "N = 1000005\ndef isPrime ( n ) :\n    if n <= 1 :\n        return False\n    if n <= 3 :\n        return True\n    if n % 2 == 0 or n % 3 == 0 :\n        return False\n    i = 5\n    while i * i <= n :\n        if ( n % i == 0 or n % ( i + 2 ) == 0 ) :\n            return False\n        i = i + 6\n    return True\ndef SumOfPrimeDivisors ( n ) :\n    sum = 0\n    for i in range ( 1 , n + 1 ) :\n        if n % i == 0 :\n            if isPrime ( i ) :\n                sum += i\n    return sum\nn = 60\nprint ( \"Sum of prime divisors of 60 is \" + str ( SumOfPrimeDivisors ( n ) ) )\n", "python_code_tokenized": "N = 1000005 NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if isPrime ( i ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT n = 60 NEW_LINE print ( \" Sum \u2581 of \u2581 prime \u2581 divisors \u2581 of \u2581 60 \u2581 is \u2581 \" + str ( SumOfPrimeDivisors ( n ) ) ) NEW_LINE"}
{"id": "codeforces_986_B", "sol": 0, "python_code": "print ( ( 'Um_nik' , 'Petr' ) [ int ( input ( ) ) // 1000 <= sum ( i == x for i , x in enumerate ( map ( int , input ( ).split ( ) ) , 1 ) ) ] )\n", "python_code_tokenized": "print ( ( ' Um _ nik ' , ' Petr ' ) [ int ( input ( ) ) // 1000 <= sum ( i == x for i , x in enumerate ( map ( int , input ( ) . split ( ) ) , 1 ) ) ] ) NEW_LINE"}
{"id": "geeksforgeeks_793_A", "sol": 0, "python_code": "def findCount ( m , n ) :\n    num1 = 0\n    for i in range ( 0 , m ) :\n        num1 = ( num1 * 10 ) + 9\n    num2 = 0\n    for i in range ( 0 , ( m - 1 ) ) :\n        num2 = ( num2 * 10 ) + 9\n    return int ( ( num1 / n ) - ( num2 / n ) )\nm = 2 ; n = 6\nprint ( findCount ( m , n ) )\n", "python_code_tokenized": "def findCount ( m , n ) : NEW_LINE INDENT num1 = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT num1 = ( num1 * 10 ) + 9 NEW_LINE DEDENT num2 = 0 NEW_LINE for i in range ( 0 , ( m - 1 ) ) : NEW_LINE INDENT num2 = ( num2 * 10 ) + 9 NEW_LINE DEDENT return int ( ( num1 / n ) - ( num2 / n ) ) NEW_LINE DEDENT m = 2 ; n = 6 NEW_LINE print ( findCount ( m , n ) ) NEW_LINE"}
{"id": "atcoder_ABC100_D", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nx = [ ]\ny = [ ]\nz = [ ]\nfor i in range ( n ) :\n    a , b , c = map ( int , input ( ).split ( ) )\n    x.append ( a )\n    y.append ( b )\n    z.append ( c )\nans = - 1e18\nfor i in range ( - 1 , 2 , 2 ) :\n    for j in range ( - 1 , 2 , 2 ) :\n        for k in range ( - 1 , 2 , 2 ) :\n            v = [ ]\n            for l in range ( n ) :\n                v.append ( x [ l ] * i + y [ l ] * j + z [ l ] * k )\n            v.sort ( )\n            v.reverse ( )\n            now = 0\n            for l in range ( m ) :\n                now += v [ l ]\n            ans = max ( ans , now )\nprint ( ans )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE x = [ ] NEW_LINE y = [ ] NEW_LINE z = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE x . append ( a ) NEW_LINE y . append ( b ) NEW_LINE z . append ( c ) NEW_LINE DEDENT ans = - 1e18 NEW_LINE for i in range ( - 1 , 2 , 2 ) : NEW_LINE INDENT for j in range ( - 1 , 2 , 2 ) : NEW_LINE INDENT for k in range ( - 1 , 2 , 2 ) : NEW_LINE INDENT v = [ ] NEW_LINE for l in range ( n ) : NEW_LINE INDENT v . append ( x [ l ] * i + y [ l ] * j + z [ l ] * k ) NEW_LINE DEDENT v . sort ( ) NEW_LINE v . reverse ( ) NEW_LINE now = 0 NEW_LINE for l in range ( m ) : NEW_LINE INDENT now += v [ l ] NEW_LINE DEDENT ans = max ( ans , now ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "atcoder_ABC177_C", "sol": 0, "python_code": "x = input ( )\nN = int ( x )\nA = list ( map ( int , input ( ).split ( ) ) )\na = 0\nb = 0\nfor i in range ( N - 1 ) :\n    a = a + A [ i + 1 ]\nfor i in range ( N - 1 ) :\n    b = b + A [ i ] * a\n    a = a - A [ i + 1 ]\nprint ( b % ( 10 ** 9 + 7 ) )\n", "python_code_tokenized": "x = input ( ) NEW_LINE N = int ( x ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT a = a + A [ i + 1 ] NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT b = b + A [ i ] * a NEW_LINE a = a - A [ i + 1 ] NEW_LINE DEDENT print ( b % ( 10 ** 9 + 7 ) ) NEW_LINE"}
{"id": "codeforces_1642_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) ) ; l = list ( map ( int , input ( ).split ( ) ) )\n    a = set ( l )\n    l1 = [ ]\n    for i in range ( 1 , n + 1 ) : l1.append ( max ( i , len ( a ) ) )\n    print ( * l1 )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) ; l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = set ( l ) NEW_LINE l1 = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : l1 . append ( max ( i , len ( a ) ) ) NEW_LINE print ( * l1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_301_A", "sol": 0, "python_code": "from math import log2\ndiscard_count = 0\ndef power ( a , n ) :\n    if ( n == 0 ) :\n        return 1\n    p = power ( a , n // 2 )\n    p = p * p\n    if ( n & 1 ) :\n        p = p * a\n    return p\ndef solve ( i , n , sum , k , a , prefix ) :\n    global discard_count\n    if ( sum > k ) :\n        discard_count += power ( 2 , n - i )\n        return ;\n    if ( i == n ) :\n        return\n    rem = prefix [ n - 1 ] - prefix [ i ]\n    if ( sum + a [ i ] + rem > k ) :\n        solve ( i + 1 , n , sum + a [ i ] , k , a , prefix )\n    if ( sum + rem > k ) :\n        solve ( i + 1 , n , sum , k , a , prefix )\ndef countSubsequences ( arr , n , K ) :\n    sum = 0.0\n    k = log2 ( K )\n    prefix = [ 0 ] * n\n    a = [ 0 ] * n\n    for i in range ( n ) :\n        a [ i ] = log2 ( arr [ i ] )\n        sum += a [ i ]\n    prefix [ 0 ] = a [ 0 ]\n    for i in range ( 1 , n ) :\n        prefix [ i ] = prefix [ i - 1 ] + a [ i ]\n    total = power ( 2 , n ) - 1\n    if ( sum <= k ) :\n        return total\n    solve ( 0 , n , 0.0 , k , a , prefix )\n    return total - discard_count\nif __name__ == \"__main__\" :\n    arr = [ 4 , 8 , 7 , 2 ]\n    n = len ( arr )\n    k = 50 ;\n    print ( countSubsequences ( arr , n , k ) )\n", "python_code_tokenized": "from math import log2 NEW_LINE discard_count = 0 NEW_LINE def power ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , n // 2 ) NEW_LINE p = p * p NEW_LINE if ( n & 1 ) : NEW_LINE INDENT p = p * a NEW_LINE DEDENT return p NEW_LINE DEDENT def solve ( i , n , sum , k , a , prefix ) : NEW_LINE INDENT global discard_count NEW_LINE if ( sum > k ) : NEW_LINE INDENT discard_count += power ( 2 , n - i ) NEW_LINE return ; NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return NEW_LINE DEDENT rem = prefix [ n - 1 ] - prefix [ i ] NEW_LINE if ( sum + a [ i ] + rem > k ) : NEW_LINE INDENT solve ( i + 1 , n , sum + a [ i ] , k , a , prefix ) NEW_LINE DEDENT if ( sum + rem > k ) : NEW_LINE INDENT solve ( i + 1 , n , sum , k , a , prefix ) NEW_LINE DEDENT DEDENT def countSubsequences ( arr , n , K ) : NEW_LINE INDENT sum = 0.0 NEW_LINE k = log2 ( K ) NEW_LINE prefix = [ 0 ] * n NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = log2 ( arr [ i ] ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT prefix [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + a [ i ] NEW_LINE DEDENT total = power ( 2 , n ) - 1 NEW_LINE if ( sum <= k ) : NEW_LINE INDENT return total NEW_LINE DEDENT solve ( 0 , n , 0.0 , k , a , prefix ) NEW_LINE return total - discard_count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 8 , 7 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 ; NEW_LINE print ( countSubsequences ( arr , n , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_706_A", "sol": 0, "python_code": "def maxAND ( L , R ) :\n    maximum = L & R\n    for i in range ( L , R , 1 ) :\n        for j in range ( i + 1 , R + 1 , 1 ) :\n            maximum = max ( maximum , ( i & j ) )\n    return maximum\nif __name__ == '__main__' :\n    L = 1\n    R = 632\n    print ( maxAND ( L , R ) )\n", "python_code_tokenized": "def maxAND ( L , R ) : NEW_LINE INDENT maximum = L & R NEW_LINE for i in range ( L , R , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , R + 1 , 1 ) : NEW_LINE INDENT maximum = max ( maximum , ( i & j ) ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 1 NEW_LINE R = 632 NEW_LINE print ( maxAND ( L , R ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1408_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n , k = map ( int , input ( ).split ( ) )\n    a = len ( set ( map ( int , input ( ).split ( ) ) ) )\n    if k == 1 and a > 1 :\n        print ( - 1 )\n    elif k >= a :\n        print ( 1 )\n    else :\n        print ( 1 + ( a - 2 ) // ( k - 1 ) )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = len ( set ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE if k == 1 and a > 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif k >= a : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 + ( a - 2 ) // ( k - 1 ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_901_A", "sol": 0, "python_code": "import math ;\ndef sieve ( primes , x ) :\n    primes [ 1 ] = False ;\n    i = 2 ;\n    while ( i * i <= x ) :\n        if ( primes [ i ] == True ) :\n            j = 2 ;\n            while ( j * i <= x ) :\n                primes [ i * j ] = False ;\n                j += 1 ;\n        i += 1 ;\ndef nDivisors ( primes , x , a , b , n ) :\n    result = 0 ;\n    v = [ ] ;\n    for i in range ( 2 , x + 1 ) :\n        if ( primes [ i ] ) :\n            v.append ( i ) ;\n    for i in range ( a , b + 1 ) :\n        temp = i ;\n        total = 1 ;\n        j = 0 ;\n        k = v [ j ] ;\n        while ( k * k <= temp ) :\n            count = 0 ;\n            while ( temp % k == 0 ) :\n                count += 1 ;\n                temp = int ( temp / k ) ;\n            total = total * ( count + 1 ) ;\n            j += 1 ;\n            k = v [ j ] ;\n        if ( temp != 1 ) :\n            total = total * 2 ;\n        if ( total == n ) :\n            result += 1 ;\n    return result ;\ndef countNDivisors ( a , b , n ) :\n    x = int ( math.sqrt ( b ) + 1 ) ;\n    primes = [ True ] * ( x + 1 ) ;\n    sieve ( primes , x ) ;\n    return nDivisors ( primes , x , a , b , n ) ;\na = 1 ;\nb = 7 ;\nn = 2 ;\nprint ( countNDivisors ( a , b , n ) ) ;\n", "python_code_tokenized": "import math ; NEW_LINE def sieve ( primes , x ) : NEW_LINE INDENT primes [ 1 ] = False ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= x ) : NEW_LINE INDENT if ( primes [ i ] == True ) : NEW_LINE INDENT j = 2 ; NEW_LINE while ( j * i <= x ) : NEW_LINE INDENT primes [ i * j ] = False ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT DEDENT def nDivisors ( primes , x , a , b , n ) : NEW_LINE INDENT result = 0 ; NEW_LINE v = [ ] ; NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT if ( primes [ i ] ) : NEW_LINE INDENT v . append ( i ) ; NEW_LINE DEDENT DEDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT temp = i ; NEW_LINE total = 1 ; NEW_LINE j = 0 ; NEW_LINE k = v [ j ] ; NEW_LINE while ( k * k <= temp ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( temp % k == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE temp = int ( temp / k ) ; NEW_LINE DEDENT total = total * ( count + 1 ) ; NEW_LINE j += 1 ; NEW_LINE k = v [ j ] ; NEW_LINE DEDENT if ( temp != 1 ) : NEW_LINE INDENT total = total * 2 ; NEW_LINE DEDENT if ( total == n ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT def countNDivisors ( a , b , n ) : NEW_LINE INDENT x = int ( math . sqrt ( b ) + 1 ) ; NEW_LINE primes = [ True ] * ( x + 1 ) ; NEW_LINE sieve ( primes , x ) ; NEW_LINE return nDivisors ( primes , x , a , b , n ) ; NEW_LINE DEDENT a = 1 ; NEW_LINE b = 7 ; NEW_LINE n = 2 ; NEW_LINE print ( countNDivisors ( a , b , n ) ) ; NEW_LINE"}
{"id": "aizu_p00312_A", "sol": 0, "python_code": "d , l = map ( int , input ( ).split ( ) )\nprint ( d // l + d % l )\n", "python_code_tokenized": "d , l = map ( int , input ( ) . split ( ) ) NEW_LINE print ( d // l + d % l ) NEW_LINE"}
{"id": "atcoder_ABC133_D", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nans = [ 0 ] * n\nans [ 0 ] = sum ( a [ : : 2 ] ) - sum ( a [ 1 : : 2 ] )\nfor i in range ( 1 , n ) :\n    ans [ i ] = 2 * a [ i - 1 ] - ans [ i - 1 ]\nans = list ( map ( str , ans ) )\nprint ( \" \".join ( ans ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ 0 ] * n NEW_LINE ans [ 0 ] = sum ( a [ : : 2 ] ) - sum ( a [ 1 : : 2 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans [ i ] = 2 * a [ i - 1 ] - ans [ i - 1 ] NEW_LINE DEDENT ans = list ( map ( str , ans ) ) NEW_LINE print ( \" \u2581 \" . join ( ans ) ) NEW_LINE"}
{"id": "geeksforgeeks_312_A", "sol": 0, "python_code": "def longestSubarry ( arr , n ) :\n    res = 0\n    for i in range ( n ) :\n        curr_count = 0\n        while ( i < n and arr [ i ] >= 0 ) :\n            curr_count += 1\n            i += 1\n        res = max ( res , curr_count )\n    return res\narr = [ 1 , 0 , 4 , 0 , 1 , - 1 , - 1 , 0 , 0 , 1 , 0 ]\nn = len ( arr )\nprint ( longestSubarry ( arr , n ) )\n", "python_code_tokenized": "def longestSubarry ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_count = 0 NEW_LINE while ( i < n and arr [ i ] >= 0 ) : NEW_LINE INDENT curr_count += 1 NEW_LINE i += 1 NEW_LINE DEDENT res = max ( res , curr_count ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 0 , 4 , 0 , 1 , - 1 , - 1 , 0 , 0 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubarry ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3592_A", "sol": 0, "python_code": "def countPairs ( n ) :\n    num = ( ( n // 2 ) + 1 )\n    Max = n % num\n    count = 0\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            val = ( ( n % i ) % j ) % n\n            if ( val == Max ) :\n                count += 1\n    return count\nn = 5\nprint ( countPairs ( n ) )\n", "python_code_tokenized": "def countPairs ( n ) : NEW_LINE INDENT num = ( ( n // 2 ) + 1 ) NEW_LINE Max = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n NEW_LINE if ( val == Max ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT n = 5 NEW_LINE print ( countPairs ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_855_A", "sol": 0, "python_code": "def bitsoncount ( x ) :\n    return bin ( x ).count ( '1' )\ndef find_count ( arr ) :\n    ans = 0\n    for i in arr :\n        x = bitsoncount ( i )\n        if ( i % x == 0 ) :\n            ans += 1\n    return ans\narr = [ 1 , 2 , 3 , 4 , 5 , 6 ]\nprint ( find_count ( arr ) )\n", "python_code_tokenized": "def bitsoncount ( x ) : NEW_LINE INDENT return bin ( x ) . count ( '1' ) NEW_LINE DEDENT def find_count ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = bitsoncount ( i ) NEW_LINE if ( i % x == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( find_count ( arr ) ) NEW_LINE"}
{"id": "codeforces_776_A", "sol": 0, "python_code": "A = input ( ).split ( )\nprint ( * A )\nS = int ( input ( ) )\nfor _ in \" \" * S :\n    B , C = input ( ).split ( )\n    A [ A.index ( B ) ] = C\n    print ( * A )\n", "python_code_tokenized": "A = input ( ) . split ( ) NEW_LINE print ( * A ) NEW_LINE S = int ( input ( ) ) NEW_LINE for _ in \" \u2581 \" * S : NEW_LINE INDENT B , C = input ( ) . split ( ) NEW_LINE A [ A . index ( B ) ] = C NEW_LINE print ( * A ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC037_B", "sol": 0, "python_code": "mod = 998244353\nn = int ( input ( ) )\na = list ( map ( lambda x : ord ( x ) % 3 , list ( input ( ) ) ) )\ng = [ list ( ) for _ in range ( 3 ) ]\nfor i in range ( 3 * n ) :\n    g [ a [ i ] ].append ( i )\nl = [ 0 ] * 3 * n\nfor i in range ( n ) :\n    a , b , c = sorted ( [ g [ 0 ] [ i ] , g [ 1 ] [ i ] , g [ 2 ] [ i ] ] )\n    l [ b ] = 1\n    l [ c ] = 2\nans = 1\nfor i in range ( n ) :\n    ans = ans * ( i + 1 ) % mod\nc = 0\nfor x in l :\n    if x == 0 :\n        c += 1\n    elif x == 1 :\n        ans = ans * c % mod\n        c -= 1\nfor x in reversed ( l ) :\n    if x == 2 :\n        c += 1\n    elif x == 1 :\n        ans = ans * c % mod\n        c -= 1\nprint ( ans )\n", "python_code_tokenized": "mod = 998244353 NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( lambda x : ord ( x ) % 3 , list ( input ( ) ) ) ) NEW_LINE g = [ list ( ) for _ in range ( 3 ) ] NEW_LINE for i in range ( 3 * n ) : NEW_LINE INDENT g [ a [ i ] ] . append ( i ) NEW_LINE DEDENT l = [ 0 ] * 3 * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b , c = sorted ( [ g [ 0 ] [ i ] , g [ 1 ] [ i ] , g [ 2 ] [ i ] ] ) NEW_LINE l [ b ] = 1 NEW_LINE l [ c ] = 2 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = ans * ( i + 1 ) % mod NEW_LINE DEDENT c = 0 NEW_LINE for x in l : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif x == 1 : NEW_LINE INDENT ans = ans * c % mod NEW_LINE c -= 1 NEW_LINE DEDENT DEDENT for x in reversed ( l ) : NEW_LINE INDENT if x == 2 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif x == 1 : NEW_LINE INDENT ans = ans * c % mod NEW_LINE c -= 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_1493_A", "sol": 0, "python_code": "import math\ndef printRepeating ( arr , size ) :\n    S = 0 ;\n    P = 1 ;\n    n = size - 2\n    for i in range ( 0 , size ) :\n        S = S + arr [ i ]\n        P = P * arr [ i ]\n    S = S - n * ( n + 1 ) // 2\n    P = P // fact ( n )\n    D = math.sqrt ( S * S - 4 * P )\n    x = ( D + S ) // 2\n    y = ( S - D ) // 2\n    print ( \"The two Repeating elements are \" , ( int ) ( x ) , \" & \" , ( int ) ( y ) )\ndef fact ( n ) :\n    if ( n == 0 ) :\n        return 1\n    else :\n        return ( n * fact ( n - 1 ) )\narr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ]\narr_size = len ( arr )\nprintRepeating ( arr , arr_size )\n", "python_code_tokenized": "import math NEW_LINE def printRepeating ( arr , size ) : NEW_LINE INDENT S = 0 ; NEW_LINE P = 1 ; NEW_LINE n = size - 2 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT S = S + arr [ i ] NEW_LINE P = P * arr [ i ] NEW_LINE DEDENT S = S - n * ( n + 1 ) // 2 NEW_LINE P = P // fact ( n ) NEW_LINE D = math . sqrt ( S * S - 4 * P ) NEW_LINE x = ( D + S ) // 2 NEW_LINE y = ( S - D ) // 2 NEW_LINE print ( \" The \u2581 two \u2581 Repeating \u2581 elements \u2581 are \u2581 \" , ( int ) ( x ) , \" \u2581 & \u2581 \" , ( int ) ( y ) ) NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * fact ( n - 1 ) ) NEW_LINE DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE"}
{"id": "codeforces_259_B", "sol": 0, "python_code": "mat = [ ]\nk = 0\nfor i in range ( 3 ) :\n    x = list ( map ( int , input ( ).split ( ) ) )\n    k += sum ( x )\n    mat.append ( x )\np = ( k ) // 2\nfor i in range ( 3 ) :\n    mat [ i ] [ i ] = p - sum ( mat [ i ] )\nfor i in mat :\n    print ( ' '.join ( map ( str , i ) ) )\n", "python_code_tokenized": "mat = [ ] NEW_LINE k = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k += sum ( x ) NEW_LINE mat . append ( x ) NEW_LINE DEDENT p = ( k ) // 2 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT mat [ i ] [ i ] = p - sum ( mat [ i ] ) NEW_LINE DEDENT for i in mat : NEW_LINE INDENT print ( ' \u2581 ' . join ( map ( str , i ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2729_A", "sol": 0, "python_code": "def GetPrefixSuffix ( a , b , l ) :\n    prefix = a [ : l ] ;\n    lb = len ( b ) ;\n    suffix = b [ lb - l : ] ;\n    return ( prefix + suffix ) ;\na = \"remuneration\" ;\nb = \"acquiesce\" ;\nl = 5 ;\nprint ( GetPrefixSuffix ( a , b , l ) ) ;\n", "python_code_tokenized": "def GetPrefixSuffix ( a , b , l ) : NEW_LINE INDENT prefix = a [ : l ] ; NEW_LINE lb = len ( b ) ; NEW_LINE suffix = b [ lb - l : ] ; NEW_LINE return ( prefix + suffix ) ; NEW_LINE DEDENT a = \" remuneration \" ; NEW_LINE b = \" acquiesce \" ; NEW_LINE l = 5 ; NEW_LINE print ( GetPrefixSuffix ( a , b , l ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_2289_A", "sol": 0, "python_code": "def gen ( n ) :\n    if n == 0 :\n        return 0\n    elif n == 1 :\n        return 1\n    elif n % 2 == 0 :\n        return 4 * gen ( n // 2 )\n    elif n % 2 == 1 :\n        return 4 * gen ( n // 2 ) + 1\ndef moserDeBruijn ( n ) :\n    for i in range ( n ) :\n        print ( gen ( i ) , end = \" \" )\nn = 15\nprint ( \"First\" , n , \"terms of \" , \"Moser-de Brujn Sequence:\" )\nmoserDeBruijn ( n )\n", "python_code_tokenized": "def gen ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT return 4 * gen ( n // 2 ) NEW_LINE DEDENT elif n % 2 == 1 : NEW_LINE INDENT return 4 * gen ( n // 2 ) + 1 NEW_LINE DEDENT DEDENT def moserDeBruijn ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( gen ( i ) , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT n = 15 NEW_LINE print ( \" First \" , n , \" terms \u2581 of \u2581 \" , \" Moser - de \u2581 Brujn \u2581 Sequence : \" ) NEW_LINE moserDeBruijn ( n ) NEW_LINE"}
{"id": "geeksforgeeks_534_A", "sol": 0, "python_code": "def countSum ( arr , n ) :\n    result = 0\n    count_odd = 0\n    count_even = 0\n    for i in range ( 1 , n + 1 ) :\n        if ( arr [ i - 1 ] % 2 == 0 ) :\n            count_even = count_even + count_even + 1\n            count_odd = count_odd + count_odd\n        else :\n            temp = count_even\n            count_even = count_even + count_odd\n            count_odd = count_odd + temp + 1\n    return ( count_even , count_odd )\narr = [ 1 , 2 , 2 , 3 ] ;\nn = len ( arr )\ncount_even , count_odd = countSum ( arr , n ) ;\nprint ( \"EvenSum = \" , count_even , \" OddSum = \" , count_odd )\n", "python_code_tokenized": "def countSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE count_odd = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] % 2 == 0 ) : NEW_LINE INDENT count_even = count_even + count_even + 1 NEW_LINE count_odd = count_odd + count_odd NEW_LINE DEDENT else : NEW_LINE INDENT temp = count_even NEW_LINE count_even = count_even + count_odd NEW_LINE count_odd = count_odd + temp + 1 NEW_LINE DEDENT DEDENT return ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 ] ; NEW_LINE n = len ( arr ) NEW_LINE count_even , count_odd = countSum ( arr , n ) ; NEW_LINE print ( \" EvenSum \u2581 = \u2581 \" , count_even , \" \u2581 OddSum \u2581 = \u2581 \" , count_odd ) NEW_LINE"}
{"id": "projecteuler_p218_A", "sol": 0, "python_code": "def compute ( ) :\n    return \"0\"\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1289_A", "sol": 0, "python_code": "def isSumDivides ( N ) :\n    temp = N\n    sum = 0\n    while ( temp ) :\n        sum += temp % 10\n        temp = int ( temp / 10 )\n    if ( N % sum == 0 ) :\n        return 1\n    else :\n        return 0\nif __name__ == '__main__' :\n    N = 12\n    if ( isSumDivides ( N ) ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "def isSumDivides ( N ) : NEW_LINE INDENT temp = N NEW_LINE sum = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE DEDENT if ( N % sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE if ( isSumDivides ( N ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_604_A", "sol": 0, "python_code": "num_inp = lambda : int ( input ( ) )\narr_inp = lambda : list ( map ( int , input ( ).split ( ) ) )\nsp_inp = lambda : map ( int , input ( ).split ( ) )\ncin = lambda : map ( int , input ( ).split ( ) )\nx = 500\nsum = 0\nfor i , j in zip ( cin ( ) , cin ( ) ) :\n    sum += max ( 0.3 * x , ( 1 - i / 250 ) * x - 50 * j )\n    x += 500\ns , u = cin ( )\nprint ( int ( sum + 100 * s - 50 * u ) )\n", "python_code_tokenized": "num_inp = lambda : int ( input ( ) ) NEW_LINE arr_inp = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sp_inp = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE cin = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE x = 500 NEW_LINE sum = 0 NEW_LINE for i , j in zip ( cin ( ) , cin ( ) ) : NEW_LINE INDENT sum += max ( 0.3 * x , ( 1 - i / 250 ) * x - 50 * j ) NEW_LINE x += 500 NEW_LINE DEDENT s , u = cin ( ) NEW_LINE print ( int ( sum + 100 * s - 50 * u ) ) NEW_LINE"}
{"id": "codeforces_1366_A", "sol": 0, "python_code": "n = int ( input ( ) )\nfor _ in range ( n ) :\n    st , di = map ( int , input ( ).split ( ) )\n    em = 0\n    if ( st >= di and st < 2 * di ) or ( di >= st and di < 2 * st ) :\n        em = ( st // 3 ) + ( di // 3 )\n        if ( ( st % 3 ) + ( di % 3 ) ) > 2 :\n            em += 1\n    elif st >= 2 * di or di >= 2 * st :\n        if st > di :\n            em = di\n        elif di > st :\n            em = st\n    print ( em )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT st , di = map ( int , input ( ) . split ( ) ) NEW_LINE em = 0 NEW_LINE if ( st >= di and st < 2 * di ) or ( di >= st and di < 2 * st ) : NEW_LINE INDENT em = ( st // 3 ) + ( di // 3 ) NEW_LINE if ( ( st % 3 ) + ( di % 3 ) ) > 2 : NEW_LINE INDENT em += 1 NEW_LINE DEDENT DEDENT elif st >= 2 * di or di >= 2 * st : NEW_LINE INDENT if st > di : NEW_LINE INDENT em = di NEW_LINE DEDENT elif di > st : NEW_LINE INDENT em = st NEW_LINE DEDENT DEDENT print ( em ) NEW_LINE DEDENT"}
{"id": "codeforces_234_A", "sol": 0, "python_code": "if __name__ == \"__main__\" :\n    f = open ( \"input.txt\" , \"r\" )\n    n = int ( f.readline ( ) )\n    students = list ( f.readline ( ) )\n    f = open ( \"output.txt\" , \"w\" )\n    row = int ( n / 2 )\n    for i in range ( row ) :\n        a = students [ i ]\n        if i + row <= n :\n            b = students [ i + row ]\n            arr = [ [ i + 1 , a ] , [ i + row + 1 , b ] ]\n        else :\n            b = students [ i - row ]\n            arr = [ [ i + 1 , a ] , [ i - row - 1 , b ] ]\n        arr.sort ( key = lambda x : x [ 1 ] )\n        print ( arr [ 0 ] [ 0 ] , arr [ 1 ] [ 0 ] , file = f )\n", "python_code_tokenized": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT f = open ( \" input . txt \" , \" r \" ) NEW_LINE n = int ( f . readline ( ) ) NEW_LINE students = list ( f . readline ( ) ) NEW_LINE f = open ( \" output . txt \" , \" w \" ) NEW_LINE row = int ( n / 2 ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT a = students [ i ] NEW_LINE if i + row <= n : NEW_LINE INDENT b = students [ i + row ] NEW_LINE arr = [ [ i + 1 , a ] , [ i + row + 1 , b ] ] NEW_LINE DEDENT else : NEW_LINE INDENT b = students [ i - row ] NEW_LINE arr = [ [ i + 1 , a ] , [ i - row - 1 , b ] ] NEW_LINE DEDENT arr . sort ( key = lambda x : x [ 1 ] ) NEW_LINE print ( arr [ 0 ] [ 0 ] , arr [ 1 ] [ 0 ] , file = f ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_687_A", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\ngraph = [ [ ] for _ in range ( n ) ]\nfor i in range ( m ) :\n    a , b = map ( int , input ( ).split ( ) )\n    graph [ a - 1 ].append ( b - 1 )\n    graph [ b - 1 ].append ( a - 1 )\ncolors = [ None ] * n\ndef bipartite ( u , color ) :\n    if not graph [ u ] :\n        return True\n    colors [ u ] = color\n    stack = [ [ u , color ] ]\n    while stack :\n        u , color = stack.pop ( )\n        for v in graph [ u ] :\n            if colors [ v ] != None and colors [ v ] == color :\n                return False\n            elif colors [ v ] != None :\n                continue\n            colors [ v ] = 1 - color\n            stack.append ( [ v , 1 - color ] )\n    return True\nisBipartite = True\nfor u in range ( n ) :\n    if colors [ u ] == None and not bipartite ( u , 0 ) :\n        isBipartite = False\n        break\nif isBipartite == False :\n    print ( '-1' )\nelse :\n    a , b = [ ] , [ ]\n    for i in range ( n ) :\n        if colors [ i ] == 1 :\n            a.append ( i + 1 )\n        elif colors [ i ] == 0 :\n            b.append ( i + 1 )\n    print ( len ( a ) )\n    print ( * a )\n    print ( len ( b ) )\n    print ( * b )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE graph [ a - 1 ] . append ( b - 1 ) NEW_LINE graph [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT colors = [ None ] * n NEW_LINE def bipartite ( u , color ) : NEW_LINE INDENT if not graph [ u ] : NEW_LINE INDENT return True NEW_LINE DEDENT colors [ u ] = color NEW_LINE stack = [ [ u , color ] ] NEW_LINE while stack : NEW_LINE INDENT u , color = stack . pop ( ) NEW_LINE for v in graph [ u ] : NEW_LINE INDENT if colors [ v ] != None and colors [ v ] == color : NEW_LINE INDENT return False NEW_LINE DEDENT elif colors [ v ] != None : NEW_LINE INDENT continue NEW_LINE DEDENT colors [ v ] = 1 - color NEW_LINE stack . append ( [ v , 1 - color ] ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT isBipartite = True NEW_LINE for u in range ( n ) : NEW_LINE INDENT if colors [ u ] == None and not bipartite ( u , 0 ) : NEW_LINE INDENT isBipartite = False NEW_LINE break NEW_LINE DEDENT DEDENT if isBipartite == False : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT else : NEW_LINE INDENT a , b = [ ] , [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if colors [ i ] == 1 : NEW_LINE INDENT a . append ( i + 1 ) NEW_LINE DEDENT elif colors [ i ] == 0 : NEW_LINE INDENT b . append ( i + 1 ) NEW_LINE DEDENT DEDENT print ( len ( a ) ) NEW_LINE print ( * a ) NEW_LINE print ( len ( b ) ) NEW_LINE print ( * b ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3121_A", "sol": 0, "python_code": "def factorial ( n ) :\n    fact = 1\n    for i in range ( 2 , n + 1 ) :\n        fact = fact * i\n    return fact\ndef ncr ( n , r ) :\n    return ( factorial ( n ) // ( factorial ( r ) * factorial ( n - r ) ) )\nif __name__ == \"__main__\" :\n    m = 3\n    n = 4\n    k = 5\n    totalTriangles = ( ncr ( m + n + k , 3 ) - ncr ( m , 3 ) - ncr ( n , 3 ) - ncr ( k , 3 ) )\n    print ( totalTriangles )\n", "python_code_tokenized": "def factorial ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def ncr ( n , r ) : NEW_LINE INDENT return ( factorial ( n ) // ( factorial ( r ) * factorial ( n - r ) ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = 3 NEW_LINE n = 4 NEW_LINE k = 5 NEW_LINE totalTriangles = ( ncr ( m + n + k , 3 ) - ncr ( m , 3 ) - ncr ( n , 3 ) - ncr ( k , 3 ) ) NEW_LINE print ( totalTriangles ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2969_A", "sol": 0, "python_code": "import sys\ndef findMax ( arr , n ) :\n    maxFirst = - sys.maxsize - 1\n    mid = n // 2 ;\n    for i in range ( 0 , mid ) :\n        maxFirst = max ( maxFirst , arr [ i ] )\n    if ( n % 2 == 1 ) :\n        maxFirst = max ( maxFirst , arr [ mid ] )\n    maxSecond = - sys.maxsize - 1\n    for i in range ( mid , n ) :\n        maxSecond = max ( maxSecond , arr [ i ] )\n    print ( maxFirst , \",\" , maxSecond )\narr = [ 1 , 12 , 14 , 5 ]\nn = len ( arr )\nfindMax ( arr , n )\n", "python_code_tokenized": "import sys NEW_LINE def findMax ( arr , n ) : NEW_LINE INDENT maxFirst = - sys . maxsize - 1 NEW_LINE mid = n // 2 ; NEW_LINE for i in range ( 0 , mid ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ i ] ) NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT maxFirst = max ( maxFirst , arr [ mid ] ) NEW_LINE DEDENT maxSecond = - sys . maxsize - 1 NEW_LINE for i in range ( mid , n ) : NEW_LINE INDENT maxSecond = max ( maxSecond , arr [ i ] ) NEW_LINE DEDENT print ( maxFirst , \" , \" , maxSecond ) NEW_LINE DEDENT arr = [ 1 , 12 , 14 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findMax ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_970_A", "sol": 0, "python_code": "def lexo_small ( n , k ) :\n    arr = \"\" ;\n    for i in range ( n ) :\n        arr += 'a' ;\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        k -= i ;\n        if ( k >= 0 ) :\n            if ( k >= 26 ) :\n                arr = arr [ : i ] + 'z' + arr [ i + 1 : ] ;\n                k -= 26 ;\n            else :\n                c = ( k + 97 - 1 ) ;\n                arr = arr [ : i ] + chr ( c ) + arr [ i + 1 : ] ;\n                k -= ord ( arr [ i ] ) - ord ( 'a' ) + 1 ;\n        else :\n            break ;\n        k += i ;\n    return arr ;\nif __name__ == '__main__' :\n    n = 5 ; k = 42 ;\n    arr = lexo_small ( n , k ) ;\n    print ( arr ) ;\n", "python_code_tokenized": "def lexo_small ( n , k ) : NEW_LINE INDENT arr = \" \" ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr += ' a ' ; NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT k -= i ; NEW_LINE if ( k >= 0 ) : NEW_LINE INDENT if ( k >= 26 ) : NEW_LINE INDENT arr = arr [ : i ] + ' z ' + arr [ i + 1 : ] ; NEW_LINE k -= 26 ; NEW_LINE DEDENT else : NEW_LINE INDENT c = ( k + 97 - 1 ) ; NEW_LINE arr = arr [ : i ] + chr ( c ) + arr [ i + 1 : ] ; NEW_LINE k -= ord ( arr [ i ] ) - ord ( ' a ' ) + 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT k += i ; NEW_LINE DEDENT return arr ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; k = 42 ; NEW_LINE arr = lexo_small ( n , k ) ; NEW_LINE print ( arr ) ; NEW_LINE DEDENT"}
{"id": "aizu_p02235_A", "sol": 0, "python_code": "e = input\nfor _ in [ 0 ] * int ( e ( ) ) :\n    X , z = e ( ) , [ ]\n    for y in e ( ) :\n        s = i = 0\n        for k in z :\n            t = X.find ( y , s ) + 1\n            if t < 1 : break\n            if t < k : z [ i ] = t\n            s = k ; i += 1\n        else :\n            t = X.find ( y , s ) + 1\n            if t : z += [ t ]\n    print ( len ( z ) )\n", "python_code_tokenized": "e = input NEW_LINE for _ in [ 0 ] * int ( e ( ) ) : NEW_LINE INDENT X , z = e ( ) , [ ] NEW_LINE for y in e ( ) : NEW_LINE INDENT s = i = 0 NEW_LINE for k in z : NEW_LINE INDENT t = X . find ( y , s ) + 1 NEW_LINE if t < 1 : break NEW_LINE if t < k : z [ i ] = t NEW_LINE s = k ; i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT t = X . find ( y , s ) + 1 NEW_LINE if t : z += [ t ] NEW_LINE DEDENT DEDENT print ( len ( z ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1023_B", "sol": 0, "python_code": "n , k = [ int ( x ) for x in input ( ).split ( ) ]\nif k >= 2 * n :\n    print ( 0 )\nelif k > n :\n    print ( ( 2 * n - k + 1 ) // 2 )\nelif k == n :\n    print ( ( n - 1 ) // 2 )\nelse :\n    print ( ( k - 1 ) // 2 )\n", "python_code_tokenized": "n , k = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if k >= 2 * n : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif k > n : NEW_LINE INDENT print ( ( 2 * n - k + 1 ) // 2 ) NEW_LINE DEDENT elif k == n : NEW_LINE INDENT print ( ( n - 1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( k - 1 ) // 2 ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC146_E", "sol": 0, "python_code": "from itertools import accumulate\nfrom collections import defaultdict , deque\ndef resolve ( ) :\n    N , K = map ( int , input ( ).split ( ) )\n    A = list ( map ( int , input ( ).split ( ) ) )\n    A = accumulate ( [ a % K for a in A ] )\n    A = [ 0 ] + list ( A )\n    cnt = defaultdict ( int )\n    q = deque ( )\n    ans = 0\n    for r in range ( N + 1 ) :\n        t = ( A [ r ] - r ) % K\n        ans += cnt [ t ]\n        cnt [ t ] += 1\n        q.append ( t )\n        if len ( q ) == K :\n            left = q.popleft ( )\n            cnt [ left ] -= 1\n    print ( ans )\nif __name__ == \"__main__\" :\n    resolve ( )\n", "python_code_tokenized": "from itertools import accumulate NEW_LINE from collections import defaultdict , deque NEW_LINE def resolve ( ) : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A = accumulate ( [ a % K for a in A ] ) NEW_LINE A = [ 0 ] + list ( A ) NEW_LINE cnt = defaultdict ( int ) NEW_LINE q = deque ( ) NEW_LINE ans = 0 NEW_LINE for r in range ( N + 1 ) : NEW_LINE INDENT t = ( A [ r ] - r ) % K NEW_LINE ans += cnt [ t ] NEW_LINE cnt [ t ] += 1 NEW_LINE q . append ( t ) NEW_LINE if len ( q ) == K : NEW_LINE INDENT left = q . popleft ( ) NEW_LINE cnt [ left ] -= 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT resolve ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_315_A", "sol": 0, "python_code": "import math as mt\ndef search ( searchspace , s , e , key ) :\n    ans = - 1\n    while s <= e :\n        mid = ( s + e ) // 2\n        if searchspace [ mid ] - key >= 0 :\n            ans = mid\n            e = mid - 1\n        else :\n            s = mid + 1\n    return ans\ndef longestSubarray ( a , n ) :\n    SuffixSum = [ 0 for i in range ( n + 1 ) ]\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        SuffixSum [ i ] = SuffixSum [ i + 1 ] + a [ i ]\n    ans = 0\n    searchspace = [ 0 for i in range ( n ) ]\n    index = [ 0 for i in range ( n ) ]\n    j = 0\n    for i in range ( n ) :\n        if j == 0 or ( SuffixSum [ i ] > searchspace [ j - 1 ] ) :\n            searchspace [ j ] = SuffixSum [ i ]\n            index [ j ] = i\n            j += 1\n        idx = search ( searchspace , 0 , j - 1 , SuffixSum [ i + 1 ] )\n        if idx != - 1 :\n            ans = max ( ans , i - index [ idx ] + 1 )\n    return ans\na = [ - 1 , 4 , - 2 , - 5 , 6 , - 8 ]\nn = len ( a )\nprint ( longestSubarray ( a , n ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def search ( searchspace , s , e , key ) : NEW_LINE INDENT ans = - 1 NEW_LINE while s <= e : NEW_LINE INDENT mid = ( s + e ) // 2 NEW_LINE if searchspace [ mid ] - key >= 0 : NEW_LINE INDENT ans = mid NEW_LINE e = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT s = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def longestSubarray ( a , n ) : NEW_LINE INDENT SuffixSum = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT SuffixSum [ i ] = SuffixSum [ i + 1 ] + a [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE searchspace = [ 0 for i in range ( n ) ] NEW_LINE index = [ 0 for i in range ( n ) ] NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if j == 0 or ( SuffixSum [ i ] > searchspace [ j - 1 ] ) : NEW_LINE INDENT searchspace [ j ] = SuffixSum [ i ] NEW_LINE index [ j ] = i NEW_LINE j += 1 NEW_LINE DEDENT idx = search ( searchspace , 0 , j - 1 , SuffixSum [ i + 1 ] ) NEW_LINE if idx != - 1 : NEW_LINE INDENT ans = max ( ans , i - index [ idx ] + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT a = [ - 1 , 4 , - 2 , - 5 , 6 , - 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestSubarray ( a , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_480_A", "sol": 0, "python_code": "import sys\ndef count_greater ( arr , n ) :\n    min = sys.maxsize ;\n    counter = 0 ;\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        if ( arr [ i ] > min ) :\n            counter += 1 ;\n        if ( arr [ i ] <= min ) :\n            min = arr [ i ] ;\n    return counter ;\nif __name__ == \"__main__\" :\n    arr = [ 3 , 2 , 1 , 2 , 3 , 4 , 5 ] ;\n    n = len ( arr ) ;\n    print ( count_greater ( arr , n ) ) ;\n", "python_code_tokenized": "import sys NEW_LINE def count_greater ( arr , n ) : NEW_LINE INDENT min = sys . maxsize ; NEW_LINE counter = 0 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > min ) : NEW_LINE INDENT counter += 1 ; NEW_LINE DEDENT if ( arr [ i ] <= min ) : NEW_LINE INDENT min = arr [ i ] ; NEW_LINE DEDENT DEDENT return counter ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( count_greater ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "aizu_p02525_A", "sol": 0, "python_code": "import math\nwhile ( True ) :\n    n = input ( )\n    if ( n == 0 ) :\n        break\n    s = map ( int , raw_input ( ).split ( ) )\n    sum = 0\n    for i in range ( len ( s ) ) :\n        sum += s [ i ]\n    average = float ( sum ) / n ;\n    temp = 0.0\n    for i in range ( len ( s ) ) :\n        temp += ( s [ i ] - average ) * ( s [ i ] - average ) ;\n    print ( math.sqrt ( temp / n ) )\n", "python_code_tokenized": "import math NEW_LINE while ( True ) : NEW_LINE INDENT n = input ( ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT s = map ( int , raw_input ( ) . split ( ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum += s [ i ] NEW_LINE DEDENT average = float ( sum ) / n ; NEW_LINE temp = 0.0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT temp += ( s [ i ] - average ) * ( s [ i ] - average ) ; NEW_LINE DEDENT print ( math . sqrt ( temp / n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2277_A", "sol": 0, "python_code": "def countnndSay ( n ) :\n    if ( n == 1 ) :\n        return \"1\"\n    if ( n == 2 ) :\n        return \"11\"\n    s = \"11\"\n    for i in range ( 3 , n + 1 ) :\n        s += '$'\n        l = len ( s )\n        cnt = 1\n        tmp = \"\"\n        for j in range ( 1 , l ) :\n            if ( s [ j ] != s [ j - 1 ] ) :\n                tmp += str ( cnt + 0 )\n                tmp += s [ j - 1 ]\n                cnt = 1\n            else :\n                cnt += 1\n        s = tmp\n    return s ;\nN = 3\nprint ( countnndSay ( N ) )\n", "python_code_tokenized": "def countnndSay ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return \"1\" NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return \"11\" NEW_LINE DEDENT s = \"11\" NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT s += ' $ ' NEW_LINE l = len ( s ) NEW_LINE cnt = 1 NEW_LINE tmp = \" \" NEW_LINE for j in range ( 1 , l ) : NEW_LINE INDENT if ( s [ j ] != s [ j - 1 ] ) : NEW_LINE INDENT tmp += str ( cnt + 0 ) NEW_LINE tmp += s [ j - 1 ] NEW_LINE cnt = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT s = tmp NEW_LINE DEDENT return s ; NEW_LINE DEDENT N = 3 NEW_LINE print ( countnndSay ( N ) ) NEW_LINE"}
{"id": "geeksforgeeks_4276_A", "sol": 0, "python_code": "def vowelOrConsonant ( x ) :\n    if ( x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' or x == 'A' or x == 'E' or x == 'I' or x == 'O' or x == 'U' ) :\n        print ( \"Vowel\" )\n    else :\n        print ( \"Consonant\" )\nif __name__ == '__main__' :\n    vowelOrConsonant ( 'c' )\n    vowelOrConsonant ( 'E' )\n", "python_code_tokenized": "def vowelOrConsonant ( x ) : NEW_LINE INDENT if ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' or x == ' A ' or x == ' E ' or x == ' I ' or x == ' O ' or x == ' U ' ) : NEW_LINE INDENT print ( \" Vowel \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Consonant \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT vowelOrConsonant ( ' c ' ) NEW_LINE vowelOrConsonant ( ' E ' ) NEW_LINE DEDENT"}
{"id": "codeforces_721_A", "sol": 0, "python_code": "n = input ( )\nstring = input ( )\nlist = [ i for i in string ]\nblack_before = False\nblack_current = False\ngroups = 0\nencrypting = [ ]\nnumber_squares = 0\nfor i in range ( len ( list ) ) :\n    if ( list [ i ] == \"B\" ) :\n        black_current = True\n        number_squares += 1\n        if ( i == len ( list ) - 1 ) :\n            groups += 1\n            encrypting.append ( number_squares )\n    elif ( black_before == True ) :\n        black_current = False\n        groups += 1\n        encrypting.append ( number_squares )\n        number_squares = 0\n    black_before = black_current\nprint ( groups )\nif ( len ( encrypting ) != 0 ) :\n    phrase = \"\"\n    for i in encrypting :\n        phrase += str ( i ) + \" \"\n    print ( phrase )\n", "python_code_tokenized": "n = input ( ) NEW_LINE string = input ( ) NEW_LINE list = [ i for i in string ] NEW_LINE black_before = False NEW_LINE black_current = False NEW_LINE groups = 0 NEW_LINE encrypting = [ ] NEW_LINE number_squares = 0 NEW_LINE for i in range ( len ( list ) ) : NEW_LINE INDENT if ( list [ i ] == \" B \" ) : NEW_LINE INDENT black_current = True NEW_LINE number_squares += 1 NEW_LINE if ( i == len ( list ) - 1 ) : NEW_LINE INDENT groups += 1 NEW_LINE encrypting . append ( number_squares ) NEW_LINE DEDENT DEDENT elif ( black_before == True ) : NEW_LINE INDENT black_current = False NEW_LINE groups += 1 NEW_LINE encrypting . append ( number_squares ) NEW_LINE number_squares = 0 NEW_LINE DEDENT black_before = black_current NEW_LINE DEDENT print ( groups ) NEW_LINE if ( len ( encrypting ) != 0 ) : NEW_LINE INDENT phrase = \" \" NEW_LINE for i in encrypting : NEW_LINE INDENT phrase += str ( i ) + \" \u2581 \" NEW_LINE DEDENT print ( phrase ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1050_A", "sol": 0, "python_code": "INT_MIN = - 100000000\ndef maxEvenSum ( arr , n ) :\n    pos_sum = 0\n    for i in range ( n ) :\n        if ( arr [ i ] > 0 ) :\n            pos_sum += arr [ i ]\n    if ( pos_sum % 2 == 0 ) :\n        return pos_sum\n    ans = INT_MIN ;\n    for i in range ( n ) :\n        if ( arr [ i ] % 2 != 0 ) :\n            if ( arr [ i ] > 0 ) :\n                ans = max ( ans , pos_sum - arr [ i ] )\n            else :\n                ans = max ( ans , pos_sum + arr [ i ] )\n    return ans\na = [ - 2 , 2 , - 3 , 1 ]\nn = len ( a )\nprint ( maxEvenSum ( a , n ) )\n", "python_code_tokenized": "INT_MIN = - 100000000 NEW_LINE def maxEvenSum ( arr , n ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( pos_sum % 2 == 0 ) : NEW_LINE INDENT return pos_sum NEW_LINE DEDENT ans = INT_MIN ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT ans = max ( ans , pos_sum - arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , pos_sum + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT a = [ - 2 , 2 , - 3 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( maxEvenSum ( a , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3926_A", "sol": 0, "python_code": "max = 4\ndef countWays ( index , cnt , dp , n , m , k ) :\n    if ( index == n ) :\n        if ( cnt == k ) :\n            return 1\n        else :\n            return 0\n    if ( dp [ index ] [ cnt ] != - 1 ) :\n        return dp [ index ] [ cnt ]\n    ans = 0\n    ans += countWays ( index + 1 , cnt , dp , n , m , k )\n    ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k )\n    dp [ index ] [ cnt ] = ans\n    return dp [ index ] [ cnt ]\nif __name__ == \"__main__\" :\n    n = 3\n    m = 3\n    k = 2\n    dp = [ [ - 1 for x in range ( n + 1 ) ] for y in range ( max ) ]\n    print ( m * countWays ( 1 , 0 , dp , n , m , k ) )\n", "python_code_tokenized": "max = 4 NEW_LINE def countWays ( index , cnt , dp , n , m , k ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ index ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE ans += countWays ( index + 1 , cnt , dp , n , m , k ) NEW_LINE ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) NEW_LINE dp [ index ] [ cnt ] = ans NEW_LINE return dp [ index ] [ cnt ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE m = 3 NEW_LINE k = 2 NEW_LINE dp = [ [ - 1 for x in range ( n + 1 ) ] for y in range ( max ) ] NEW_LINE print ( m * countWays ( 1 , 0 , dp , n , m , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_563_A", "sol": 0, "python_code": "def count ( x , y ) :\n    ans = 0\n    m = dict ( )\n    while x % y != 0 :\n        x %= y\n        ans += 1\n        if x in m :\n            return - 1\n        m [ x ] = 1\n        x *= 10\n    return ans\nif __name__ == \"__main__\" :\n    res = count ( 1 , 2 )\n    print ( \"INF\" ) if res == - 1 else print ( res )\n    res = count ( 5 , 3 )\n    print ( \"INF\" ) if res == - 1 else print ( res )\n    res = count ( 3 , 5 )\n    print ( \"INF\" ) if res == - 1 else print ( res )\n", "python_code_tokenized": "def count ( x , y ) : NEW_LINE INDENT ans = 0 NEW_LINE m = dict ( ) NEW_LINE while x % y != 0 : NEW_LINE INDENT x %= y NEW_LINE ans += 1 NEW_LINE if x in m : NEW_LINE INDENT return - 1 NEW_LINE DEDENT m [ x ] = 1 NEW_LINE x *= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT res = count ( 1 , 2 ) NEW_LINE print ( \" INF \" ) if res == - 1 else print ( res ) NEW_LINE res = count ( 5 , 3 ) NEW_LINE print ( \" INF \" ) if res == - 1 else print ( res ) NEW_LINE res = count ( 3 , 5 ) NEW_LINE print ( \" INF \" ) if res == - 1 else print ( res ) NEW_LINE DEDENT"}
{"id": "codeforces_901_B", "sol": 0, "python_code": "n = int ( input ( ) )\np = [ [ 1 ] , [ 0 , 1 ] ]\nfor i in range ( n - 1 ) :\n    t = [ 0 ] + p [ - 1 ]\n    for j in range ( len ( p [ i ] ) ) : t [ j ] ^= p [ i ] [ j ]\n    p.append ( t )\nprint ( n )\nprint ( * p [ n ] )\nprint ( n - 1 )\nprint ( * p [ - 2 ] )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE p = [ [ 1 ] , [ 0 , 1 ] ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT t = [ 0 ] + p [ - 1 ] NEW_LINE for j in range ( len ( p [ i ] ) ) : t [ j ] ^= p [ i ] [ j ] NEW_LINE p . append ( t ) NEW_LINE DEDENT print ( n ) NEW_LINE print ( * p [ n ] ) NEW_LINE print ( n - 1 ) NEW_LINE print ( * p [ - 2 ] ) NEW_LINE"}
{"id": "geeksforgeeks_4204_A", "sol": 0, "python_code": "from math import gcd\ndef find_LCM ( x , y ) :\n    return ( x * y ) // gcd ( x , y )\ndef CountPairs ( n , m , A , B ) :\n    cnt = 0\n    lcm = find_LCM ( A , B )\n    for i in range ( 1 , n + 1 ) :\n        cnt += ( m + ( i % lcm ) ) // lcm\n    return cnt\nif __name__ == \"__main__\" :\n    n , m , A , B = 60 , 90 , 5 , 10\n    print ( CountPairs ( n , m , A , B ) )\n", "python_code_tokenized": "from math import gcd NEW_LINE def find_LCM ( x , y ) : NEW_LINE INDENT return ( x * y ) // gcd ( x , y ) NEW_LINE DEDENT def CountPairs ( n , m , A , B ) : NEW_LINE INDENT cnt = 0 NEW_LINE lcm = find_LCM ( A , B ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT cnt += ( m + ( i % lcm ) ) // lcm NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m , A , B = 60 , 90 , 5 , 10 NEW_LINE print ( CountPairs ( n , m , A , B ) ) NEW_LINE DEDENT"}
{"id": "codeforces_336_B", "sol": 0, "python_code": "m , r = map ( int , input ( ).split ( ) )\nres , sq2 = 0 , ( 2 **.5 )\nfor i in range ( 1 , m ) :\n    res += 2 + sq2 + 2 * sq2 * ( i - 1 ) + ( i - 1 ) * i\nres = ( res + m ) * 2 * r\nprint ( res / ( m * m ) )\n", "python_code_tokenized": "m , r = map ( int , input ( ) . split ( ) ) NEW_LINE res , sq2 = 0 , ( 2 ** .5 ) NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res += 2 + sq2 + 2 * sq2 * ( i - 1 ) + ( i - 1 ) * i NEW_LINE DEDENT res = ( res + m ) * 2 * r NEW_LINE print ( res / ( m * m ) ) NEW_LINE"}
{"id": "atcoder_ABC134_E", "sol": 0, "python_code": "import sys\nfrom bisect import bisect_right as bi_r\ninf = float ( 'inf' )\nn , * A = map ( int , sys.stdin.read ( ).split ( ) )\ndef main ( ) :\n    res = [ inf ] * n\n    for a in A [ : : - 1 ] :\n        i = bi_r ( res , a )\n        res [ i ] = a\n    for i in range ( n ) :\n        if res [ i ] == inf :\n            return i\n    return n\nif __name__ == '__main__' :\n    ans = main ( )\n    print ( ans )\n", "python_code_tokenized": "import sys NEW_LINE from bisect import bisect_right as bi_r NEW_LINE inf = float ( ' inf ' ) NEW_LINE n , * A = map ( int , sys . stdin . read ( ) . split ( ) ) NEW_LINE def main ( ) : NEW_LINE INDENT res = [ inf ] * n NEW_LINE for a in A [ : : - 1 ] : NEW_LINE INDENT i = bi_r ( res , a ) NEW_LINE res [ i ] = a NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if res [ i ] == inf : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ans = main ( ) NEW_LINE print ( ans ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1621_A", "sol": 0, "python_code": "def sqrtSearch ( low , high , N ) :\n    if ( low <= high ) :\n        mid = ( low + high ) // 2 ;\n        if ( ( mid * mid <= N ) and ( ( mid + 1 ) * ( mid + 1 ) > N ) ) :\n            return mid ;\n        elif ( mid * mid < N ) :\n            return sqrtSearch ( mid + 1 , high , N ) ;\n        else :\n            return sqrtSearch ( low , mid - 1 , N ) ;\n    return low ;\nif __name__ == \"__main__\" :\n    N = 25 ;\n    print ( sqrtSearch ( 0 , N , N ) )\n", "python_code_tokenized": "def sqrtSearch ( low , high , N ) : NEW_LINE INDENT if ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 ; NEW_LINE if ( ( mid * mid <= N ) and ( ( mid + 1 ) * ( mid + 1 ) > N ) ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT elif ( mid * mid < N ) : NEW_LINE INDENT return sqrtSearch ( mid + 1 , high , N ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return sqrtSearch ( low , mid - 1 , N ) ; NEW_LINE DEDENT DEDENT return low ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 25 ; NEW_LINE print ( sqrtSearch ( 0 , N , N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_461_A", "sol": 0, "python_code": "def distinctChars ( s ) :\n    freq = [ 0 ] * 26 ;\n    count = 0 ;\n    for i in range ( len ( s ) ) :\n        freq [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 ;\n    for i in range ( 26 ) :\n        if ( freq [ i ] > 0 ) :\n            count += 1 ;\n    return count ;\ndef waysToSplit ( s ) :\n    n = len ( s ) ;\n    answer = 0 ;\n    for i in range ( 1 , n ) :\n        left = s [ 0 : i ] ;\n        right = s [ i : n ] ;\n        if ( distinctChars ( left ) == distinctChars ( right ) ) :\n            answer += 1 ;\n    return answer ;\nif __name__ == \"__main__\" :\n    s = \"ababa\" ;\n    print ( waysToSplit ( s ) ) ;\n", "python_code_tokenized": "def distinctChars ( s ) : NEW_LINE INDENT freq = [ 0 ] * 26 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE answer = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT left = s [ 0 : i ] ; NEW_LINE right = s [ i : n ] ; NEW_LINE if ( distinctChars ( left ) == distinctChars ( right ) ) : NEW_LINE INDENT answer += 1 ; NEW_LINE DEDENT DEDENT return answer ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ababa \" ; NEW_LINE print ( waysToSplit ( s ) ) ; NEW_LINE DEDENT"}
{"id": "aizu_p00456_A", "sol": 0, "python_code": "list_w = [ ]\nfor x in range ( 10 ) :\n    x = int ( input ( ) )\n    list_w.append ( x )\nlist_k = [ ]\nfor y in range ( 10 ) :\n    y = int ( input ( ) )\n    list_k.append ( y )\nlist_w.sort ( )\nlist_k.sort ( )\na = list_w [ 9 ] + list_w [ 8 ] + list_w [ 7 ]\nb = list_k [ 9 ] + list_k [ 8 ] + list_k [ 7 ]\nprint ( a , b )\n", "python_code_tokenized": "list_w = [ ] NEW_LINE for x in range ( 10 ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE list_w . append ( x ) NEW_LINE DEDENT list_k = [ ] NEW_LINE for y in range ( 10 ) : NEW_LINE INDENT y = int ( input ( ) ) NEW_LINE list_k . append ( y ) NEW_LINE DEDENT list_w . sort ( ) NEW_LINE list_k . sort ( ) NEW_LINE a = list_w [ 9 ] + list_w [ 8 ] + list_w [ 7 ] NEW_LINE b = list_k [ 9 ] + list_k [ 8 ] + list_k [ 7 ] NEW_LINE print ( a , b ) NEW_LINE"}
{"id": "geeksforgeeks_854_A", "sol": 0, "python_code": "def findNthNum ( N ) :\n    bit_L = 1 ;\n    last_num = 0 ;\n    while ( bit_L * ( bit_L + 1 ) / 2 < N ) :\n        last_num = last_num + bit_L ;\n        bit_L += 1 ;\n    bit_R = N - last_num - 1 ;\n    print ( ( 1 << bit_L ) + ( 1 << bit_R ) ) ;\nif __name__ == '__main__' :\n    N = 13 ;\n    findNthNum ( N ) ;\n", "python_code_tokenized": "def findNthNum ( N ) : NEW_LINE INDENT bit_L = 1 ; NEW_LINE last_num = 0 ; NEW_LINE while ( bit_L * ( bit_L + 1 ) / 2 < N ) : NEW_LINE INDENT last_num = last_num + bit_L ; NEW_LINE bit_L += 1 ; NEW_LINE DEDENT bit_R = N - last_num - 1 ; NEW_LINE print ( ( 1 << bit_L ) + ( 1 << bit_R ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 13 ; NEW_LINE findNthNum ( N ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1265_A", "sol": 0, "python_code": "class getNode :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.left = None\n        self.right = None\ndef isFullBinaryTree ( root ) :\n    if ( not root ) :\n        return True\n    q = [ ]\n    q.append ( root )\n    while ( not len ( q ) ) :\n        node = q [ 0 ]\n        q.pop ( 0 )\n        if ( node.left == None and node.right == None ) :\n            continue\n        if ( node.left == None or node.right == None ) :\n            return False\n        q.append ( node.left )\n        q.append ( node.right )\n    return True\nif __name__ == '__main__' :\n    root = getNode ( 1 )\n    root.left = getNode ( 2 )\n    root.right = getNode ( 3 )\n    root.left.left = getNode ( 4 )\n    root.left.right = getNode ( 5 )\n    if ( isFullBinaryTree ( root ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "class getNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def isFullBinaryTree ( root ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return True NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE while ( not len ( q ) ) : NEW_LINE INDENT node = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( node . left == None and node . right == None ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( node . left == None or node . right == None ) : NEW_LINE INDENT return False NEW_LINE DEDENT q . append ( node . left ) NEW_LINE q . append ( node . right ) NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = getNode ( 1 ) NEW_LINE root . left = getNode ( 2 ) NEW_LINE root . right = getNode ( 3 ) NEW_LINE root . left . left = getNode ( 4 ) NEW_LINE root . left . right = getNode ( 5 ) NEW_LINE if ( isFullBinaryTree ( root ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_842_A", "sol": 0, "python_code": "l , r , x , y , k = map ( int , input ( ).split ( ) )\nfor i in range ( x , y + 1 ) :\n    if l <= i * k and i * k <= r :\n        print ( 'YES' )\n        break\nelse :\n    print ( 'NO' )\n", "python_code_tokenized": "l , r , x , y , k = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( x , y + 1 ) : NEW_LINE INDENT if l <= i * k and i * k <= r : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"}
{"id": "aizu_p00592_A", "sol": 0, "python_code": "while True :\n    n , s , e = input ( ).split ( )\n    n = int ( n )\n    s = int ( s )\n    e = int ( e )\n    if not n + s + e :\n        break\n    s = s // 100 * 60 + s % 100\n    e = e // 100 * 60 + e % 100\n    t = [ 0 ] * ( 60 * 24 + 1 )\n    for i in range ( n ) :\n        m = int ( input ( ) )\n        g = input ( ).split ( )\n        j = 0\n        for o in g :\n            a = int ( o )\n            if j % 2 :\n                t [ a // 100 * 60 + a % 100 ] += 1\n            else :\n                t [ a // 100 * 60 + a % 100 ] -= 1\n            j += 1\n    cnt = n\n    ans = 0\n    ma = - 1\n    for i in range ( e ) :\n        cnt += t [ i ]\n        if i < s :\n            continue\n        if cnt :\n            ans += 1\n        else :\n            if ma < ans :\n                ma = ans\n            ans = 0\n    print ( ma if ma > ans else ans )\n", "python_code_tokenized": "while True : NEW_LINE INDENT n , s , e = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE s = int ( s ) NEW_LINE e = int ( e ) NEW_LINE if not n + s + e : NEW_LINE INDENT break NEW_LINE DEDENT s = s // 100 * 60 + s % 100 NEW_LINE e = e // 100 * 60 + e % 100 NEW_LINE t = [ 0 ] * ( 60 * 24 + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE g = input ( ) . split ( ) NEW_LINE j = 0 NEW_LINE for o in g : NEW_LINE INDENT a = int ( o ) NEW_LINE if j % 2 : NEW_LINE INDENT t [ a // 100 * 60 + a % 100 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT t [ a // 100 * 60 + a % 100 ] -= 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT cnt = n NEW_LINE ans = 0 NEW_LINE ma = - 1 NEW_LINE for i in range ( e ) : NEW_LINE INDENT cnt += t [ i ] NEW_LINE if i < s : NEW_LINE INDENT continue NEW_LINE DEDENT if cnt : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ma < ans : NEW_LINE INDENT ma = ans NEW_LINE DEDENT ans = 0 NEW_LINE DEDENT DEDENT print ( ma if ma > ans else ans ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_516_A", "sol": 0, "python_code": "def findY ( x ) :\n    if ( x > 2 ) :\n        return x - 2\n    return x + 2\nif __name__ == '__main__' :\n    x = 5\n    print ( findY ( x ) )\n", "python_code_tokenized": "def findY ( x ) : NEW_LINE INDENT if ( x > 2 ) : NEW_LINE INDENT return x - 2 NEW_LINE DEDENT return x + 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 5 NEW_LINE print ( findY ( x ) ) NEW_LINE DEDENT"}
{"id": "aizu_p01103_A", "sol": 0, "python_code": "while True :\n    d , w = map ( int , input ( ).split ( ) )\n    if d + w == 0 : break\n    pond = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( d ) ]\n    ans = 0\n    for left in range ( w - 1 ) :\n        for right in range ( w - 1 , left + 1 , - 1 ) :\n            for top in range ( d - 1 ) :\n                for under in range ( d - 1 , top + 1 , - 1 ) :\n                    outh = 10\n                    outh = min ( outh , min ( pond [ top ] [ left : right + 1 ] ) )\n                    outh = min ( outh , min ( pond [ under ] [ left : right + 1 ] ) )\n                    zpond = list ( zip ( * pond ) )\n                    outh = min ( outh , min ( zpond [ left ] [ top : under ] ) )\n                    outh = min ( outh , min ( zpond [ right ] [ top : under ] ) )\n                    pondh = 0\n                    for i in range ( top + 1 , under ) :\n                        pondh = max ( pondh , max ( pond [ i ] [ left + 1 : right ] ) )\n                    if pondh < outh :\n                        cap = outh * ( under - top - 1 ) * ( right - left - 1 ) - sum ( sum ( pond [ i ] [ left + 1 : right ] ) for i in range ( top + 1 , under ) )\n                        ans = max ( cap , ans )\n    print ( ans )\n", "python_code_tokenized": "while True : NEW_LINE INDENT d , w = map ( int , input ( ) . split ( ) ) NEW_LINE if d + w == 0 : break NEW_LINE pond = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] NEW_LINE ans = 0 NEW_LINE for left in range ( w - 1 ) : NEW_LINE INDENT for right in range ( w - 1 , left + 1 , - 1 ) : NEW_LINE INDENT for top in range ( d - 1 ) : NEW_LINE INDENT for under in range ( d - 1 , top + 1 , - 1 ) : NEW_LINE INDENT outh = 10 NEW_LINE outh = min ( outh , min ( pond [ top ] [ left : right + 1 ] ) ) NEW_LINE outh = min ( outh , min ( pond [ under ] [ left : right + 1 ] ) ) NEW_LINE zpond = list ( zip ( * pond ) ) NEW_LINE outh = min ( outh , min ( zpond [ left ] [ top : under ] ) ) NEW_LINE outh = min ( outh , min ( zpond [ right ] [ top : under ] ) ) NEW_LINE pondh = 0 NEW_LINE for i in range ( top + 1 , under ) : NEW_LINE INDENT pondh = max ( pondh , max ( pond [ i ] [ left + 1 : right ] ) ) NEW_LINE DEDENT if pondh < outh : NEW_LINE INDENT cap = outh * ( under - top - 1 ) * ( right - left - 1 ) - sum ( sum ( pond [ i ] [ left + 1 : right ] ) for i in range ( top + 1 , under ) ) NEW_LINE ans = max ( cap , ans ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "aizu_p01130_A", "sol": 0, "python_code": "from heapq import heapify , heappop , heappush\nfrom operator import add\nSENTINEL = 100000\nwhile True :\n    n , m , s , g1 , g2 = map ( int , input ( ).split ( ) )\n    s -= 1\n    g1 -= 1\n    g2 -= 1\n    if not n :\n        break\n    pipes = [ set ( ) for _ in range ( n ) ]\n    rpipes = [ set ( ) for _ in range ( n ) ]\n    for _ in range ( m ) :\n        b1 , b2 , c = map ( int , input ( ).split ( ) )\n        b1 -= 1\n        b2 -= 1\n        pipes [ b1 ].add ( ( c , b2 ) )\n        rpipes [ b2 ].add ( ( c , b1 ) )\n    dists = [ [ SENTINEL ] * n for _ in range ( 2 ) ]\n    for i in ( 0 , 1 ) :\n        g = ( g1 , g2 ) [ i ]\n        dist = dists [ i ]\n        dist [ g ] = 0\n        queue = list ( rpipes [ g ] )\n        heapify ( queue )\n        while queue :\n            total_cost , base = heappop ( queue )\n            if dist [ base ] < SENTINEL :\n                continue\n            dist [ base ] = total_cost\n            for next_cost , next_base in rpipes [ base ] :\n                if dist [ next_base ] == SENTINEL :\n                    heappush ( queue , ( total_cost + next_cost , next_base ) )\n    dists = list ( map ( add , * dists ) )\n    current_best = dists [ s ]\n    queue = list ( pipes [ s ] )\n    heapify ( queue )\n    visited = { s }\n    while queue :\n        total_cost , base = heappop ( queue )\n        if base in visited :\n            continue\n        visited.add ( base )\n        current_best = min ( current_best , total_cost + dists [ base ] )\n        for next_cost , next_base in pipes [ base ] :\n            if next_base not in visited :\n                heappush ( queue , ( total_cost + next_cost , next_base ) )\n    print ( current_best )\n", "python_code_tokenized": "from heapq import heapify , heappop , heappush NEW_LINE from operator import add NEW_LINE SENTINEL = 100000 NEW_LINE while True : NEW_LINE INDENT n , m , s , g1 , g2 = map ( int , input ( ) . split ( ) ) NEW_LINE s -= 1 NEW_LINE g1 -= 1 NEW_LINE g2 -= 1 NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT pipes = [ set ( ) for _ in range ( n ) ] NEW_LINE rpipes = [ set ( ) for _ in range ( n ) ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT b1 , b2 , c = map ( int , input ( ) . split ( ) ) NEW_LINE b1 -= 1 NEW_LINE b2 -= 1 NEW_LINE pipes [ b1 ] . add ( ( c , b2 ) ) NEW_LINE rpipes [ b2 ] . add ( ( c , b1 ) ) NEW_LINE DEDENT dists = [ [ SENTINEL ] * n for _ in range ( 2 ) ] NEW_LINE for i in ( 0 , 1 ) : NEW_LINE INDENT g = ( g1 , g2 ) [ i ] NEW_LINE dist = dists [ i ] NEW_LINE dist [ g ] = 0 NEW_LINE queue = list ( rpipes [ g ] ) NEW_LINE heapify ( queue ) NEW_LINE while queue : NEW_LINE INDENT total_cost , base = heappop ( queue ) NEW_LINE if dist [ base ] < SENTINEL : NEW_LINE INDENT continue NEW_LINE DEDENT dist [ base ] = total_cost NEW_LINE for next_cost , next_base in rpipes [ base ] : NEW_LINE INDENT if dist [ next_base ] == SENTINEL : NEW_LINE INDENT heappush ( queue , ( total_cost + next_cost , next_base ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT dists = list ( map ( add , * dists ) ) NEW_LINE current_best = dists [ s ] NEW_LINE queue = list ( pipes [ s ] ) NEW_LINE heapify ( queue ) NEW_LINE visited = { s } NEW_LINE while queue : NEW_LINE INDENT total_cost , base = heappop ( queue ) NEW_LINE if base in visited : NEW_LINE INDENT continue NEW_LINE DEDENT visited . add ( base ) NEW_LINE current_best = min ( current_best , total_cost + dists [ base ] ) NEW_LINE for next_cost , next_base in pipes [ base ] : NEW_LINE INDENT if next_base not in visited : NEW_LINE INDENT heappush ( queue , ( total_cost + next_cost , next_base ) ) NEW_LINE DEDENT DEDENT DEDENT print ( current_best ) NEW_LINE DEDENT"}
{"id": "codeforces_427_A", "sol": 0, "python_code": "l = int ( input ( ) )\nc = list ( map ( int , input ( ).split ( ) ) )\nhired = 0\nunthreated = 0\nfor i in c :\n    if i > 0 :\n        hired += i\n        continue\n    if i < 0 and hired > 0 :\n        hired -= 1\n        continue\n    if i < 0 :\n        unthreated += 1\nprint ( unthreated )\n", "python_code_tokenized": "l = int ( input ( ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE hired = 0 NEW_LINE unthreated = 0 NEW_LINE for i in c : NEW_LINE INDENT if i > 0 : NEW_LINE INDENT hired += i NEW_LINE continue NEW_LINE DEDENT if i < 0 and hired > 0 : NEW_LINE INDENT hired -= 1 NEW_LINE continue NEW_LINE DEDENT if i < 0 : NEW_LINE INDENT unthreated += 1 NEW_LINE DEDENT DEDENT print ( unthreated ) NEW_LINE"}
{"id": "geeksforgeeks_3252_A", "sol": 0, "python_code": "def arraySum ( arr , n ) :\n    _sum = 0\n    for i in range ( n ) :\n        _sum = _sum + arr [ i ]\n    return _sum\narr = [ 10 , 11 , 12 , 13 , 12 , 11 , 10 ]\nn = len ( arr )\nprint ( arraySum ( arr , n ) )\n", "python_code_tokenized": "def arraySum ( arr , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT _sum = _sum + arr [ i ] NEW_LINE DEDENT return _sum NEW_LINE DEDENT arr = [ 10 , 11 , 12 , 13 , 12 , 11 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( arraySum ( arr , n ) ) NEW_LINE"}
{"id": "atcoder_ABC165_D", "sol": 0, "python_code": "a , b , n = map ( int , input ( ).split ( ) )\nx = min ( b - 1 , n )\nprint ( ( a * x ) // b )\n", "python_code_tokenized": "a , b , n = map ( int , input ( ) . split ( ) ) NEW_LINE x = min ( b - 1 , n ) NEW_LINE print ( ( a * x ) // b ) NEW_LINE"}
{"id": "geeksforgeeks_2144_A", "sol": 0, "python_code": "import random\ndef lehmann ( n , t ) :\n    a = random.randint ( 2 , n - 1 )\n    e = ( n - 1 ) / 2\n    while ( t > 0 ) :\n        result = ( ( int ) ( a ** e ) ) % n\n        if ( ( result % n ) == 1 or ( result % n ) == ( n - 1 ) ) :\n            a = random.randint ( 2 , n - 1 )\n            t -= 1\n        else :\n            return - 1\n    return 1\nn = 13\nt = 10\nif ( n is 2 ) :\n    print ( \"2 is Prime.\" )\nif ( n % 2 == 0 ) :\n    print ( n , \"is Composite\" )\nelse :\n    flag = lehmann ( n , t )\n    if ( flag is 1 ) :\n        print ( n , \"may be Prime.\" )\n    else :\n        print ( n , \"is Composite.\" )\n", "python_code_tokenized": "import random NEW_LINE def lehmann ( n , t ) : NEW_LINE INDENT a = random . randint ( 2 , n - 1 ) NEW_LINE e = ( n - 1 ) / 2 NEW_LINE while ( t > 0 ) : NEW_LINE INDENT result = ( ( int ) ( a ** e ) ) % n NEW_LINE if ( ( result % n ) == 1 or ( result % n ) == ( n - 1 ) ) : NEW_LINE INDENT a = random . randint ( 2 , n - 1 ) NEW_LINE t -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT n = 13 NEW_LINE t = 10 NEW_LINE if ( n is 2 ) : NEW_LINE INDENT print ( \"2 \u2581 is \u2581 Prime . \" ) NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( n , \" is \u2581 Composite \" ) NEW_LINE DEDENT else : NEW_LINE INDENT flag = lehmann ( n , t ) NEW_LINE if ( flag is 1 ) : NEW_LINE INDENT print ( n , \" may \u2581 be \u2581 Prime . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , \" is \u2581 Composite . \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_294_B", "sol": 0, "python_code": "import collections\nimport heapq\nimport sys\nimport math\nimport itertools\nimport bisect\nfrom io import BytesIO , IOBase\nimport os\ndef values ( ) : return tuple ( map ( int , sys.stdin.readline ( ).split ( ) ) )\ndef inlsts ( ) : return [ int ( i ) for i in sys.stdin.readline ( ).split ( ) ]\ndef inp ( ) : return int ( sys.stdin.readline ( ) )\ndef instr ( ) : return sys.stdin.readline ( ).strip ( )\ndef words ( ) : return [ i for i in sys.stdin.readline ( ).strip ( ).split ( ) ]\ndef chars ( ) : return [ i for i in sys.stdin.readline ( ).strip ( ) ]\ndef solve ( ) :\n    n = inp ( )\n    t = [ ] ; w = [ ]\n    for i in range ( n ) :\n        a , b = values ( )\n        t.append ( a ) ; w.append ( b )\n    sm = sum ( t )\n    cnt = sum ( w )\n    dp = [ - float ( 'inf' ) ] * ( sm + 1 )\n    dp [ 0 ] = 0\n    for i in range ( n ) :\n        for j in range ( sm , t [ i ] - 1 , - 1 ) :\n            dp [ j ] = max ( dp [ j ] , dp [ j - t [ i ] ] + w [ i ] )\n    for i in range ( 1 , len ( dp ) ) :\n        rem = cnt - dp [ i ]\n        if dp [ i ] > 0 and rem <= i : print ( i ) ; break\nif __name__ == \"__main__\" :\n    solve ( )\n", "python_code_tokenized": "import collections NEW_LINE import heapq NEW_LINE import sys NEW_LINE import math NEW_LINE import itertools NEW_LINE import bisect NEW_LINE from io import BytesIO , IOBase NEW_LINE import os NEW_LINE def values ( ) : return tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def inlsts ( ) : return [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def inp ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def instr ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def words ( ) : return [ i for i in sys . stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE def chars ( ) : return [ i for i in sys . stdin . readline ( ) . strip ( ) ] NEW_LINE def solve ( ) : NEW_LINE INDENT n = inp ( ) NEW_LINE t = [ ] ; w = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = values ( ) NEW_LINE t . append ( a ) ; w . append ( b ) NEW_LINE DEDENT sm = sum ( t ) NEW_LINE cnt = sum ( w ) NEW_LINE dp = [ - float ( ' inf ' ) ] * ( sm + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( sm , t [ i ] - 1 , - 1 ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , dp [ j - t [ i ] ] + w [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( 1 , len ( dp ) ) : NEW_LINE INDENT rem = cnt - dp [ i ] NEW_LINE if dp [ i ] > 0 and rem <= i : print ( i ) ; break NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2859_A", "sol": 0, "python_code": "def lps ( str ) :\n    n = len ( str )\n    L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    for i in range ( n ) :\n        L [ i ] [ i ] = 1\n    for cl in range ( 2 , n + 1 ) :\n        for i in range ( n - cl + 1 ) :\n            j = i + cl - 1\n            if ( str [ i ] == str [ j ] and cl == 2 ) :\n                L [ i ] [ j ] = 2\n            elif ( str [ i ] == str [ j ] ) :\n                L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2\n            else :\n                L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] )\n    return L [ 0 ] [ n - 1 ]\ndef minimumNumberOfDeletions ( str ) :\n    n = len ( str )\n    l = lps ( str )\n    return ( n - l )\nif __name__ == \"__main__\" :\n    str = \"geeksforgeeks\"\n    print ( \"Minimum number of deletions = \" , minimumNumberOfDeletions ( str ) )\n", "python_code_tokenized": "def lps ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if ( str [ i ] == str [ j ] and cl == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( str [ i ] == str [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT def minimumNumberOfDeletions ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE l = lps ( str ) NEW_LINE return ( n - l ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE print ( \" Minimum \u2581 number \u2581 of \u2581 deletions \u2581 = \u2581 \" , minimumNumberOfDeletions ( str ) ) NEW_LINE DEDENT"}
{"id": "codeforces_484_B", "sol": 0, "python_code": "input ( )\ns = sorted ( set ( map ( int , input ( ).split ( ) ) ) )\nc = m = 0\nd = [ ]\nfor b in s :\n    d += [ c ] * ( b - c )\n    c = b\nfor b in s [ - 1 : : - 1 ] :\n    if b < m + 2 :\n        break\n    m = max ( m , c % b , * ( a % b for a in d [ 2 * b - 1 : : b ] ) )\nprint ( m )\n", "python_code_tokenized": "input ( ) NEW_LINE s = sorted ( set ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE c = m = 0 NEW_LINE d = [ ] NEW_LINE for b in s : NEW_LINE INDENT d += [ c ] * ( b - c ) NEW_LINE c = b NEW_LINE DEDENT for b in s [ - 1 : : - 1 ] : NEW_LINE INDENT if b < m + 2 : NEW_LINE INDENT break NEW_LINE DEDENT m = max ( m , c % b , * ( a % b for a in d [ 2 * b - 1 : : b ] ) ) NEW_LINE DEDENT print ( m ) NEW_LINE"}
{"id": "geeksforgeeks_354_A", "sol": 0, "python_code": "import sys\ndef minCoins ( coins , m , V ) :\n    table = [ 0 for i in range ( V + 1 ) ]\n    table [ 0 ] = 0\n    for i in range ( 1 , V + 1 ) :\n        table [ i ] = sys.maxsize\n    for i in range ( 1 , V + 1 ) :\n        for j in range ( m ) :\n            if ( coins [ j ] <= i ) :\n                sub_res = table [ i - coins [ j ] ]\n                if ( sub_res != sys.maxsize and sub_res + 1 < table [ i ] ) :\n                    table [ i ] = sub_res + 1\n    return table [ V ]\nif __name__ == \"__main__\" :\n    coins = [ 9 , 6 , 5 , 1 ]\n    m = len ( coins )\n    V = 11\n    print ( \"Minimum coins required is \" , minCoins ( coins , m , V ) )\n", "python_code_tokenized": "import sys NEW_LINE def minCoins ( coins , m , V ) : NEW_LINE INDENT table = [ 0 for i in range ( V + 1 ) ] NEW_LINE table [ 0 ] = 0 NEW_LINE for i in range ( 1 , V + 1 ) : NEW_LINE INDENT table [ i ] = sys . maxsize NEW_LINE DEDENT for i in range ( 1 , V + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( coins [ j ] <= i ) : NEW_LINE INDENT sub_res = table [ i - coins [ j ] ] NEW_LINE if ( sub_res != sys . maxsize and sub_res + 1 < table [ i ] ) : NEW_LINE INDENT table [ i ] = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return table [ V ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT coins = [ 9 , 6 , 5 , 1 ] NEW_LINE m = len ( coins ) NEW_LINE V = 11 NEW_LINE print ( \" Minimum \u2581 coins \u2581 required \u2581 is \u2581 \" , minCoins ( coins , m , V ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3630_A", "sol": 0, "python_code": "def canConvert ( a , b ) :\n    while ( b > a ) :\n        if ( b % 10 == 1 ) :\n            b //= 10 ;\n            continue ;\n        if ( b % 2 == 0 ) :\n            b /= 2 ;\n            continue ;\n        return false ;\n    if ( b == a ) :\n        return True ;\n    return False ;\nif __name__ == \"__main__\" :\n    A = 2 ; B = 82 ;\n    if ( canConvert ( A , B ) ) :\n        print ( \"Yes\" ) ;\n    else :\n        print ( \"No\" ) ;\n", "python_code_tokenized": "def canConvert ( a , b ) : NEW_LINE INDENT while ( b > a ) : NEW_LINE INDENT if ( b % 10 == 1 ) : NEW_LINE INDENT b //= 10 ; NEW_LINE continue ; NEW_LINE DEDENT if ( b % 2 == 0 ) : NEW_LINE INDENT b /= 2 ; NEW_LINE continue ; NEW_LINE DEDENT return false ; NEW_LINE DEDENT if ( b == a ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 2 ; B = 82 ; NEW_LINE if ( canConvert ( A , B ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00086_A", "sol": 0, "python_code": "from __future__ import ( division , absolute_import , print_function , unicode_literals )\nfrom sys import stdin\nfrom collections import Counter\ncnt = Counter ( )\nfor line in stdin :\n    start , end = ( int ( s ) for s in line.split ( ) )\n    if start or end :\n        cnt [ start ] += 1\n        cnt [ end ] += 1\n    else :\n        semi_eulerian = sum ( i % 2 for i in cnt.values ( ) ) == 2\n        if semi_eulerian and cnt [ 1 ] % 2 and cnt [ 2 ] % 2 :\n            print ( 'OK' )\n        else :\n            print ( 'NG' )\n        cnt.clear ( )\n", "python_code_tokenized": "from __future__ import ( division , absolute_import , print_function , unicode_literals ) NEW_LINE from sys import stdin NEW_LINE from collections import Counter NEW_LINE cnt = Counter ( ) NEW_LINE for line in stdin : NEW_LINE INDENT start , end = ( int ( s ) for s in line . split ( ) ) NEW_LINE if start or end : NEW_LINE INDENT cnt [ start ] += 1 NEW_LINE cnt [ end ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT semi_eulerian = sum ( i % 2 for i in cnt . values ( ) ) == 2 NEW_LINE if semi_eulerian and cnt [ 1 ] % 2 and cnt [ 2 ] % 2 : NEW_LINE INDENT print ( ' OK ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NG ' ) NEW_LINE DEDENT cnt . clear ( ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1101_B", "sol": 0, "python_code": "s = list ( input ( ) )\nt = 0\nn = len ( s )\nacc_start = False\nacc_c1 = False\nstart_ind = 0\nc1_ind = 0\nwhile t < len ( s ) and not all ( [ acc_start , acc_c1 ] ) :\n    if not acc_start :\n        if s [ t ] == '[' :\n            acc_start = True\n            start_ind = t\n    elif not acc_c1 :\n        if s [ t ] == ':' :\n            acc_c1 = True\n            c1_ind = t\n    t += 1\nt = 0\nacc_c2 = False\nacc_end = False\nc2_ind = 0\nend_ind = 0\nwhile t < len ( s ) and not all ( [ acc_end , acc_c2 ] ) :\n    if not acc_end :\n        if s [ ~ t ] == ']' :\n            acc_end = True\n            end_ind = n + ~ t\n    elif not acc_c2 :\n        if s [ ~ t ] == ':' :\n            acc_c2 = True\n            c2_ind = n + ~ t\n    t += 1\nif all ( [ acc_start , acc_c1 , acc_c2 , acc_end ] ) and start_ind < c1_ind < c2_ind < end_ind :\n    print ( 4 + s [ c1_ind + 1 : c2_ind ].count ( '|' ) )\nelse :\n    print ( - 1 )\n", "python_code_tokenized": "s = list ( input ( ) ) NEW_LINE t = 0 NEW_LINE n = len ( s ) NEW_LINE acc_start = False NEW_LINE acc_c1 = False NEW_LINE start_ind = 0 NEW_LINE c1_ind = 0 NEW_LINE while t < len ( s ) and not all ( [ acc_start , acc_c1 ] ) : NEW_LINE INDENT if not acc_start : NEW_LINE INDENT if s [ t ] == ' [ ' : NEW_LINE INDENT acc_start = True NEW_LINE start_ind = t NEW_LINE DEDENT DEDENT elif not acc_c1 : NEW_LINE INDENT if s [ t ] == ' : ' : NEW_LINE INDENT acc_c1 = True NEW_LINE c1_ind = t NEW_LINE DEDENT DEDENT t += 1 NEW_LINE DEDENT t = 0 NEW_LINE acc_c2 = False NEW_LINE acc_end = False NEW_LINE c2_ind = 0 NEW_LINE end_ind = 0 NEW_LINE while t < len ( s ) and not all ( [ acc_end , acc_c2 ] ) : NEW_LINE INDENT if not acc_end : NEW_LINE INDENT if s [ ~ t ] == ' ] ' : NEW_LINE INDENT acc_end = True NEW_LINE end_ind = n + ~ t NEW_LINE DEDENT DEDENT elif not acc_c2 : NEW_LINE INDENT if s [ ~ t ] == ' : ' : NEW_LINE INDENT acc_c2 = True NEW_LINE c2_ind = n + ~ t NEW_LINE DEDENT DEDENT t += 1 NEW_LINE DEDENT if all ( [ acc_start , acc_c1 , acc_c2 , acc_end ] ) and start_ind < c1_ind < c2_ind < end_ind : NEW_LINE INDENT print ( 4 + s [ c1_ind + 1 : c2_ind ] . count ( ' | ' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2534_A", "sol": 0, "python_code": "from math import log2 , ceil\ndef minOperations ( N ) :\n    x = log2 ( N )\n    ans = ceil ( x )\n    return ans\nif __name__ == '__main__' :\n    N = 10\n    print ( minOperations ( N ) )\n", "python_code_tokenized": "from math import log2 , ceil NEW_LINE def minOperations ( N ) : NEW_LINE INDENT x = log2 ( N ) NEW_LINE ans = ceil ( x ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( minOperations ( N ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02485_A", "sol": 0, "python_code": "while True :\n    x = input ( )\n    if x == \"0\" :\n        break\n    ans = 0\n    for i in x :\n        ans += int ( i )\n    print ( ans )\n", "python_code_tokenized": "while True : NEW_LINE INDENT x = input ( ) NEW_LINE if x == \"0\" : NEW_LINE INDENT break NEW_LINE DEDENT ans = 0 NEW_LINE for i in x : NEW_LINE INDENT ans += int ( i ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2367_A", "sol": 0, "python_code": "def Loss ( SP , P ) :\n    loss = 0\n    loss = ( ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) )\n    print ( \"Loss =\" , round ( loss , 3 ) )\nif __name__ == \"__main__\" :\n    SP , P = 2400 , 30\n    Loss ( SP , P )\n", "python_code_tokenized": "def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ) NEW_LINE print ( \" Loss \u2581 = \" , round ( loss , 3 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SP , P = 2400 , 30 NEW_LINE Loss ( SP , P ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4314_A", "sol": 0, "python_code": "import math\ndef printPattern ( radius ) :\n    for i in range ( ( 2 * radius ) + 1 ) :\n        for j in range ( ( 2 * radius ) + 1 ) :\n            dist = math.sqrt ( ( i - radius ) * ( i - radius ) + ( j - radius ) * ( j - radius ) )\n            if ( dist > radius - 0.5 and dist < radius + 0.5 ) :\n                print ( \"*\" , end = \"\" )\n            else :\n                print ( \"\" , end = \"\" )\n        print ( )\nradius = 6\nprintPattern ( radius )\n", "python_code_tokenized": "import math NEW_LINE def printPattern ( radius ) : NEW_LINE INDENT for i in range ( ( 2 * radius ) + 1 ) : NEW_LINE INDENT for j in range ( ( 2 * radius ) + 1 ) : NEW_LINE INDENT dist = math . sqrt ( ( i - radius ) * ( i - radius ) + ( j - radius ) * ( j - radius ) ) NEW_LINE if ( dist > radius - 0.5 and dist < radius + 0.5 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT radius = 6 NEW_LINE printPattern ( radius ) NEW_LINE"}
{"id": "codeforces_1108_B", "sol": 0, "python_code": "n = int ( input ( ) )\nd = list ( map ( int , input ( ).split ( ) ) )\nM = { }\nfor di in d :\n    if di not in M :\n        M [ di ] = 0\n    M [ di ] += 1\nd.sort ( )\nx = d [ - 1 ]\nfor i in range ( 1 , x + 1 ) :\n    if x % i == 0 :\n        M [ i ] -= 1\ny = 0\nfor di in M :\n    if M [ di ] == 1 :\n        y = max ( y , di )\nprint ( x , y )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE M = { } NEW_LINE for di in d : NEW_LINE INDENT if di not in M : NEW_LINE INDENT M [ di ] = 0 NEW_LINE DEDENT M [ di ] += 1 NEW_LINE DEDENT d . sort ( ) NEW_LINE x = d [ - 1 ] NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT M [ i ] -= 1 NEW_LINE DEDENT DEDENT y = 0 NEW_LINE for di in M : NEW_LINE INDENT if M [ di ] == 1 : NEW_LINE INDENT y = max ( y , di ) NEW_LINE DEDENT DEDENT print ( x , y ) NEW_LINE"}
{"id": "codeforces_1324_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    ans = \"YES\"\n    columnst = int ( input ( ) )\n    wcolumn = list ( map ( int , input ( ).split ( \" \" ) ) )\n    minwcolumn = min ( wcolumn )\n    if minwcolumn != 0 :\n        for j in range ( len ( wcolumn ) ) :\n            wcolumn [ j ] = wcolumn [ j ] - minwcolumn\n    for k in wcolumn :\n        if k % 2 != 0 :\n            ans = \"NO\"\n    print ( ans )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT ans = \" YES \" NEW_LINE columnst = int ( input ( ) ) NEW_LINE wcolumn = list ( map ( int , input ( ) . split ( \" \u2581 \" ) ) ) NEW_LINE minwcolumn = min ( wcolumn ) NEW_LINE if minwcolumn != 0 : NEW_LINE INDENT for j in range ( len ( wcolumn ) ) : NEW_LINE INDENT wcolumn [ j ] = wcolumn [ j ] - minwcolumn NEW_LINE DEDENT DEDENT for k in wcolumn : NEW_LINE INDENT if k % 2 != 0 : NEW_LINE INDENT ans = \" NO \" NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4400_A", "sol": 0, "python_code": "n = 4\ndef count ( arr ) :\n    diag1 = 0 ; diag2 = 0 ; row = 0\n    col = 0 ; count = 0 ; j = n - 1\n    for i in range ( n ) :\n        diag1 += arr [ i ] [ i ]\n        diag2 += arr [ i ] [ j ]\n        j -= 1\n    for i in range ( n ) :\n        row = 0 ; col = 0\n        for j in range ( n ) :\n            row += arr [ i ] [ j ]\n        for j in range ( n ) :\n            col += arr [ j ] [ i ]\n        if ( ( row == diag1 ) or ( row == diag2 ) ) :\n            count += 1\n        if ( ( col == diag1 ) or ( col == diag2 ) ) :\n            count += 1\n    return count\narr = [ [ 7 , 2 , 3 , 5 ] , [ 4 , 5 , 6 , 3 ] , [ 7 , 9 , 10 , 12 ] , [ 1 , 5 , 4 , 3 ] ]\nprint ( count ( arr ) )\n", "python_code_tokenized": "n = 4 NEW_LINE def count ( arr ) : NEW_LINE INDENT diag1 = 0 ; diag2 = 0 ; row = 0 NEW_LINE col = 0 ; count = 0 ; j = n - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT diag1 += arr [ i ] [ i ] NEW_LINE diag2 += arr [ i ] [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT row = 0 ; col = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT row += arr [ i ] [ j ] NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT col += arr [ j ] [ i ] NEW_LINE DEDENT if ( ( row == diag1 ) or ( row == diag2 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( ( col == diag1 ) or ( col == diag2 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ [ 7 , 2 , 3 , 5 ] , [ 4 , 5 , 6 , 3 ] , [ 7 , 9 , 10 , 12 ] , [ 1 , 5 , 4 , 3 ] ] NEW_LINE print ( count ( arr ) ) NEW_LINE"}
{"id": "codeforces_400_A", "sol": 0, "python_code": "import collections\nimport heapq\nimport sys\nimport math\nimport itertools\nimport bisect\nfrom io import BytesIO , IOBase\nimport os\ndef value ( ) : return tuple ( map ( int , input ( ).split ( ) ) )\ndef values ( ) : return tuple ( map ( int , sys.stdin.readline ( ).split ( ) ) )\ndef inlst ( ) : return [ int ( i ) for i in input ( ).split ( ) ]\ndef inlsts ( ) : return [ int ( i ) for i in sys.stdin.readline ( ).split ( ) ]\ndef inp ( ) : return int ( input ( ) )\ndef inps ( ) : return int ( sys.stdin.readline ( ) )\ndef instr ( ) : return input ( )\ndef stlst ( ) : return [ i for i in input ( ).split ( ) ]\ndef help ( a , b , l ) :\n    tot = [ ]\n    for i in range ( b ) :\n        tot.append ( l [ i * a : i * a + a ] )\n    for i in zip ( * tot ) :\n        if sum ( ( i ) ) == b : return True\n    return False\ndef solve ( ) :\n    tot = [ ]\n    x = instr ( )\n    s = [ ]\n    for i in x :\n        if i == 'O' : s.append ( 0 )\n        else : s.append ( 1 )\n    for i in range ( 1 , 13 ) :\n        if 12 % i == 0 :\n            if help ( i , 12 // i , s ) : tot.append ( ( 12 // i , i ) )\n    print ( len ( tot ) , end = ' ' )\n    for a , b in sorted ( tot ) :\n        print ( f'{a}x{b}' , end = ' ' )\n    print ( )\nif __name__ == \"__main__\" :\n    for i in range ( inp ( ) ) :\n        solve ( )\n", "python_code_tokenized": "import collections NEW_LINE import heapq NEW_LINE import sys NEW_LINE import math NEW_LINE import itertools NEW_LINE import bisect NEW_LINE from io import BytesIO , IOBase NEW_LINE import os NEW_LINE def value ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def values ( ) : return tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def inlst ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE def inlsts ( ) : return [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def inp ( ) : return int ( input ( ) ) NEW_LINE def inps ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def instr ( ) : return input ( ) NEW_LINE def stlst ( ) : return [ i for i in input ( ) . split ( ) ] NEW_LINE def help ( a , b , l ) : NEW_LINE INDENT tot = [ ] NEW_LINE for i in range ( b ) : NEW_LINE INDENT tot . append ( l [ i * a : i * a + a ] ) NEW_LINE DEDENT for i in zip ( * tot ) : NEW_LINE INDENT if sum ( ( i ) ) == b : return True NEW_LINE DEDENT return False NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT tot = [ ] NEW_LINE x = instr ( ) NEW_LINE s = [ ] NEW_LINE for i in x : NEW_LINE INDENT if i == ' O ' : s . append ( 0 ) NEW_LINE else : s . append ( 1 ) NEW_LINE DEDENT for i in range ( 1 , 13 ) : NEW_LINE INDENT if 12 % i == 0 : NEW_LINE INDENT if help ( i , 12 // i , s ) : tot . append ( ( 12 // i , i ) ) NEW_LINE DEDENT DEDENT print ( len ( tot ) , end = ' \u2581 ' ) NEW_LINE for a , b in sorted ( tot ) : NEW_LINE INDENT print ( f ' { a } x { b } ' , end = ' \u2581 ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT for i in range ( inp ( ) ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2034_A", "sol": 0, "python_code": "def findCount ( arr , n ) :\n    countOdd = 0 ;\n    for i in range ( n ) :\n        if ( arr [ i ] % 2 == 1 ) :\n            countOdd += 1 ;\n    if ( countOdd % 2 == 0 ) :\n        return 1 ;\n    else :\n        return 0 ;\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 3 , 5 , 1 ] ;\n    n = len ( arr ) ;\n    print ( findCount ( arr , n ) ) ;\n", "python_code_tokenized": "def findCount ( arr , n ) : NEW_LINE INDENT countOdd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT countOdd += 1 ; NEW_LINE DEDENT DEDENT if ( countOdd % 2 == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 5 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findCount ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_712_A", "sol": 0, "python_code": "def msbPos ( n ) :\n    msb_p = - 1\n    while ( n > 0 ) :\n        n = n >> 1\n        msb_p += 1\n    return msb_p\ndef andOperator ( x , y ) :\n    res = 0\n    while ( x > 0 and y > 0 ) :\n        msb_p1 = msbPos ( x )\n        msb_p2 = msbPos ( y )\n        if ( msb_p1 != msb_p2 ) :\n            break\n        msb_val = ( 1 << msb_p1 )\n        res = res + msb_val\n        x = x - msb_val\n        y = y - msb_val\n    return res\nx , y = 10 , 15\nprint ( andOperator ( x , y ) )\n", "python_code_tokenized": "def msbPos ( n ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def andOperator ( x , y ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT msb_p1 = msbPos ( x ) NEW_LINE msb_p2 = msbPos ( y ) NEW_LINE if ( msb_p1 != msb_p2 ) : NEW_LINE INDENT break NEW_LINE DEDENT msb_val = ( 1 << msb_p1 ) NEW_LINE res = res + msb_val NEW_LINE x = x - msb_val NEW_LINE y = y - msb_val NEW_LINE DEDENT return res NEW_LINE DEDENT x , y = 10 , 15 NEW_LINE print ( andOperator ( x , y ) ) NEW_LINE"}
{"id": "geeksforgeeks_1701_A", "sol": 0, "python_code": "def isMultipleof5 ( n ) :\n    while ( n > 0 ) :\n        n = n - 5\n    if ( n == 0 ) :\n        return 1\n    return 0\ni = 19\nif ( isMultipleof5 ( i ) == 1 ) :\n    print ( i , \"is multiple of 5\" )\nelse :\n    print ( i , \"is not a multiple of 5\" )\n", "python_code_tokenized": "def isMultipleof5 ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT n = n - 5 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT i = 19 NEW_LINE if ( isMultipleof5 ( i ) == 1 ) : NEW_LINE INDENT print ( i , \" is \u2581 multiple \u2581 of \u2581 5\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , \" is \u2581 not \u2581 a \u2581 multiple \u2581 of \u2581 5\" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_650_A", "sol": 0, "python_code": "def minDiff ( n , x , A ) :\n    mn = A [ 0 ]\n    mx = A [ 0 ]\n    for i in range ( 0 , n ) :\n        mn = min ( mn , A [ i ] )\n        mx = max ( mx , A [ i ] )\n    return max ( 0 , mx - mn - 2 * x )\nn = 3\nx = 3\nA = [ 1 , 3 , 6 ]\nprint ( minDiff ( n , x , A ) )\n", "python_code_tokenized": "def minDiff ( n , x , A ) : NEW_LINE INDENT mn = A [ 0 ] NEW_LINE mx = A [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mn = min ( mn , A [ i ] ) NEW_LINE mx = max ( mx , A [ i ] ) NEW_LINE DEDENT return max ( 0 , mx - mn - 2 * x ) NEW_LINE DEDENT n = 3 NEW_LINE x = 3 NEW_LINE A = [ 1 , 3 , 6 ] NEW_LINE print ( minDiff ( n , x , A ) ) NEW_LINE"}
{"id": "geeksforgeeks_886_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    if a == 0 :\n        return b\n    return gcd ( b % a , a )\na = 2\nb = 4\nprint ( gcd ( a , b ) )\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE"}
{"id": "geeksforgeeks_2458_A", "sol": 0, "python_code": "def rectanglearea ( a , b ) :\n    if a < 0 or b < 0 :\n        return - 1\n    return 2 * a * b\nif __name__ == \"__main__\" :\n    a , b = 10 , 8\n    print ( rectanglearea ( a , b ) )\n", "python_code_tokenized": "def rectanglearea ( a , b ) : NEW_LINE INDENT if a < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a * b NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b = 10 , 8 NEW_LINE print ( rectanglearea ( a , b ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5004_A", "sol": 0, "python_code": "def countX ( a , b ) :\n    if ( b > a ) :\n        return 0\n    elif ( a == b ) :\n        return - 1\n    else :\n        x = a - b\n        ans = 0\n        i = 1\n        while i * i <= x :\n            if ( x % i == 0 ) :\n                d1 = i\n                d2 = b - 1\n                if ( i * i != x ) :\n                    d2 = x // i\n                if ( d1 > b ) :\n                    ans += 1\n                if ( d2 > b ) :\n                    ans += 1\n            i += 1\n        return ans\nif __name__ == \"__main__\" :\n    a = 21\n    b = 5\n    print ( countX ( a , b ) )\n", "python_code_tokenized": "def countX ( a , b ) : NEW_LINE INDENT if ( b > a ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = a - b NEW_LINE ans = 0 NEW_LINE i = 1 NEW_LINE while i * i <= x : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT d1 = i NEW_LINE d2 = b - 1 NEW_LINE if ( i * i != x ) : NEW_LINE INDENT d2 = x // i NEW_LINE DEDENT if ( d1 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( d2 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 21 NEW_LINE b = 5 NEW_LINE print ( countX ( a , b ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2680_A", "sol": 0, "python_code": "def reverseSting ( text ) :\n    index = - 1\n    for i in range ( len ( text ) - 1 , int ( len ( text ) / 2 ) , - 1 ) :\n        if text [ i ].isalpha ( ) :\n            temp = text [ i ]\n            while True :\n                index += 1\n                if text [ index ].isalpha ( ) :\n                    text [ i ] = text [ index ]\n                    text [ index ] = temp\n                    break\n    return text\nstring = \"a!!!b.c.d,e'f,ghi\"\nprint ( \"Input string: \" , string )\nstring = reverseSting ( list ( string ) )\nprint ( \"Output string: \" , \"\".join ( string ) )\n", "python_code_tokenized": "def reverseSting ( text ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( len ( text ) - 1 , int ( len ( text ) / 2 ) , - 1 ) : NEW_LINE INDENT if text [ i ] . isalpha ( ) : NEW_LINE INDENT temp = text [ i ] NEW_LINE while True : NEW_LINE INDENT index += 1 NEW_LINE if text [ index ] . isalpha ( ) : NEW_LINE INDENT text [ i ] = text [ index ] NEW_LINE text [ index ] = temp NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return text NEW_LINE DEDENT string = \" a ! ! ! b . c . d , e ' f , ghi \" NEW_LINE print ( \" Input \u2581 string : \u2581 \" , string ) NEW_LINE string = reverseSting ( list ( string ) ) NEW_LINE print ( \" Output \u2581 string : \u2581 \" , \" \" . join ( string ) ) NEW_LINE"}
{"id": "geeksforgeeks_1544_A", "sol": 0, "python_code": "def insertSorted ( arr , n , key , capacity ) :\n    if ( n >= capacity ) :\n        return n\n    i = n - 1\n    while i >= 0 and arr [ i ] > key :\n        arr [ i + 1 ] = arr [ i ]\n        i -= 1\n    arr [ i + 1 ] = key\n    return ( n + 1 )\narr = [ 12 , 16 , 20 , 40 , 50 , 70 ]\nfor i in range ( 20 ) :\n    arr.append ( 0 )\ncapacity = len ( arr )\nn = 6\nkey = 26\nprint ( \"Before Insertion: \" , end = \"\" ) ;\nfor i in range ( n ) :\n    print ( arr [ i ] , end = \"\" )\nn = insertSorted ( arr , n , key , capacity )\nprint ( \"\\nAfter Insertion: \" , end = \"\" )\nfor i in range ( n ) :\n    print ( arr [ i ] , end = \"\" )\n", "python_code_tokenized": "def insertSorted ( arr , n , key , capacity ) : NEW_LINE INDENT if ( n >= capacity ) : NEW_LINE INDENT return n NEW_LINE DEDENT i = n - 1 NEW_LINE while i >= 0 and arr [ i ] > key : NEW_LINE INDENT arr [ i + 1 ] = arr [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ i + 1 ] = key NEW_LINE return ( n + 1 ) NEW_LINE DEDENT arr = [ 12 , 16 , 20 , 40 , 50 , 70 ] NEW_LINE for i in range ( 20 ) : NEW_LINE INDENT arr . append ( 0 ) NEW_LINE DEDENT capacity = len ( arr ) NEW_LINE n = 6 NEW_LINE key = 26 NEW_LINE print ( \" Before \u2581 Insertion : \u2581 \" , end = \" \u2581 \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT n = insertSorted ( arr , n , key , capacity ) NEW_LINE print ( \" \\n After \u2581 Insertion : \u2581 \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5046_A", "sol": 0, "python_code": "def dfs ( adj , node , parent , color ) :\n    count_color [ color ] += 1\n    for i in range ( len ( adj [ node ] ) ) :\n        if ( adj [ node ] [ i ] != parent ) :\n            dfs ( adj , adj [ node ] [ i ] , node , not color )\ndef findMaxEdges ( adj , n ) :\n    dfs ( adj , 1 , 0 , 0 )\n    return ( count_color [ 0 ] * count_color [ 1 ] - ( n - 1 ) )\ncount_color = [ 0 , 0 ]\nn = 5\nadj = [ [ ] for i in range ( n + 1 ) ]\nadj [ 1 ].append ( 2 )\nadj [ 1 ].append ( 3 )\nadj [ 2 ].append ( 4 )\nadj [ 3 ].append ( 5 )\nprint ( findMaxEdges ( adj , n ) )\n", "python_code_tokenized": "def dfs ( adj , node , parent , color ) : NEW_LINE INDENT count_color [ color ] += 1 NEW_LINE for i in range ( len ( adj [ node ] ) ) : NEW_LINE INDENT if ( adj [ node ] [ i ] != parent ) : NEW_LINE INDENT dfs ( adj , adj [ node ] [ i ] , node , not color ) NEW_LINE DEDENT DEDENT DEDENT def findMaxEdges ( adj , n ) : NEW_LINE INDENT dfs ( adj , 1 , 0 , 0 ) NEW_LINE return ( count_color [ 0 ] * count_color [ 1 ] - ( n - 1 ) ) NEW_LINE DEDENT count_color = [ 0 , 0 ] NEW_LINE n = 5 NEW_LINE adj = [ [ ] for i in range ( n + 1 ) ] NEW_LINE adj [ 1 ] . append ( 2 ) NEW_LINE adj [ 1 ] . append ( 3 ) NEW_LINE adj [ 2 ] . append ( 4 ) NEW_LINE adj [ 3 ] . append ( 5 ) NEW_LINE print ( findMaxEdges ( adj , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1039_A", "sol": 0, "python_code": "def findTwoThreePrime ( l , r ) :\n    if ( l == 1 ) :\n        l += 1\n    count = 0\n    for i in range ( l , r + 1 ) :\n        num = i\n        while ( num % 2 == 0 ) :\n            num //= 2 ;\n        while ( num % 3 == 0 ) :\n            num //= 3\n        if ( num == 1 ) :\n            count += 1\n    return count\nif __name__ == \"__main__\" :\n    l = 1\n    r = 10\n    print ( findTwoThreePrime ( l , r ) )\n", "python_code_tokenized": "def findTwoThreePrime ( l , r ) : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT num = i NEW_LINE while ( num % 2 == 0 ) : NEW_LINE INDENT num //= 2 ; NEW_LINE DEDENT while ( num % 3 == 0 ) : NEW_LINE INDENT num //= 3 NEW_LINE DEDENT if ( num == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 1 NEW_LINE r = 10 NEW_LINE print ( findTwoThreePrime ( l , r ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4834_A", "sol": 0, "python_code": "N = 1000000007 ;\ndef exponentiation ( bas , exp ) :\n    if ( exp == 0 ) :\n        return 1 ;\n    if ( exp == 1 ) :\n        return bas % N ;\n    t = exponentiation ( bas , int ( exp / 2 ) ) ;\n    t = ( t * t ) % N ;\n    if ( exp % 2 == 0 ) :\n        return t ;\n    else :\n        return ( ( bas % N ) * t ) % N ;\nbas = 5 ;\nexp = 100000 ;\nmodulo = exponentiation ( bas , exp ) ;\nprint ( modulo ) ;\n", "python_code_tokenized": "N = 1000000007 ; NEW_LINE def exponentiation ( bas , exp ) : NEW_LINE INDENT if ( exp == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( exp == 1 ) : NEW_LINE INDENT return bas % N ; NEW_LINE DEDENT t = exponentiation ( bas , int ( exp / 2 ) ) ; NEW_LINE t = ( t * t ) % N ; NEW_LINE if ( exp % 2 == 0 ) : NEW_LINE INDENT return t ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( bas % N ) * t ) % N ; NEW_LINE DEDENT DEDENT bas = 5 ; NEW_LINE exp = 100000 ; NEW_LINE modulo = exponentiation ( bas , exp ) ; NEW_LINE print ( modulo ) ; NEW_LINE"}
{"id": "geeksforgeeks_4835_A", "sol": 0, "python_code": "N = 1000000007 ;\ndef exponentiation ( bas , exp ) :\n    t = 1 ;\n    while ( exp > 0 ) :\n        if ( exp % 2 != 0 ) :\n            t = ( t * bas ) % N ;\n        bas = ( bas * bas ) % N ;\n        exp = int ( exp / 2 ) ;\n    return t % N ;\nbas = 5 ;\nexp = 100000 ;\nmodulo = exponentiation ( bas , exp ) ;\nprint ( modulo ) ;\n", "python_code_tokenized": "N = 1000000007 ; NEW_LINE def exponentiation ( bas , exp ) : NEW_LINE INDENT t = 1 ; NEW_LINE while ( exp > 0 ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * bas ) % N ; NEW_LINE DEDENT bas = ( bas * bas ) % N ; NEW_LINE exp = int ( exp / 2 ) ; NEW_LINE DEDENT return t % N ; NEW_LINE DEDENT bas = 5 ; NEW_LINE exp = 100000 ; NEW_LINE modulo = exponentiation ( bas , exp ) ; NEW_LINE print ( modulo ) ; NEW_LINE"}
{"id": "aizu_p00647_A", "sol": 0, "python_code": "tt = [ [ 660 , 899 ] , [ 1080 , 1259 ] , [ 1260 , 1559 ] ]\nss = [ \"lunch\" , \"dinner\" , \"midnight\" ]\nwhile True :\n    n = int ( input ( ) )\n    if n == 0 : break\n    cnt , ok = [ 0 ] * 3 , [ 0 ] * 3\n    for i in range ( n ) :\n        hm , MM = input ( ).split ( )\n        hh , mm = map ( int , hm.split ( ':' ) )\n        MM = int ( MM )\n        if hh <= 2 : hh += 24\n        MM = MM + hh * 60 if MM >= mm else MM + ( hh + 1 ) * 60\n        t = hh * 60 + mm\n        for j in range ( 3 ) :\n            if tt [ j ] [ 0 ] <= t and t <= tt [ j ] [ 1 ] :\n                cnt [ j ] += 1\n                if MM - t <= 8 : ok [ j ] += 1\n    for j in range ( 3 ) :\n        print ( ss [ j ] + '' , end = '' )\n        print ( \"no guest\" if cnt [ j ] == 0 else ok [ j ] * 100 // cnt [ j ] )\n", "python_code_tokenized": "tt = [ [ 660 , 899 ] , [ 1080 , 1259 ] , [ 1260 , 1559 ] ] NEW_LINE ss = [ \" lunch \" , \" dinner \" , \" midnight \" ] NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE cnt , ok = [ 0 ] * 3 , [ 0 ] * 3 NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm , MM = input ( ) . split ( ) NEW_LINE hh , mm = map ( int , hm . split ( ' : ' ) ) NEW_LINE MM = int ( MM ) NEW_LINE if hh <= 2 : hh += 24 NEW_LINE MM = MM + hh * 60 if MM >= mm else MM + ( hh + 1 ) * 60 NEW_LINE t = hh * 60 + mm NEW_LINE for j in range ( 3 ) : NEW_LINE INDENT if tt [ j ] [ 0 ] <= t and t <= tt [ j ] [ 1 ] : NEW_LINE INDENT cnt [ j ] += 1 NEW_LINE if MM - t <= 8 : ok [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for j in range ( 3 ) : NEW_LINE INDENT print ( ss [ j ] + ' \u2581 ' , end = ' ' ) NEW_LINE print ( \" no \u2581 guest \" if cnt [ j ] == 0 else ok [ j ] * 100 // cnt [ j ] ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC080_D", "sol": 0, "python_code": "N , C = map ( int , input ( ).split ( ) )\nlatest = 0\nP = [ [ ] for i in range ( C ) ]\nfor i in range ( N ) :\n    s , t , c = map ( int , input ( ).split ( ) )\n    P [ c - 1 ].append ( ( s , t ) )\n    latest = max ( latest , t )\nDup = [ 0 for i in range ( latest + 2 ) ]\nfor i in range ( C ) :\n    P [ i ].sort ( )\n    for j in range ( len ( P [ i ] ) ) :\n        Dup [ P [ i ] [ j ] [ 0 ] ] += 1\n        Dup [ P [ i ] [ j ] [ 1 ] + 1 ] -= 1\n        if j >= 1 :\n            if P [ i ] [ j ] [ 0 ] == P [ i ] [ j - 1 ] [ 1 ] :\n                Dup [ P [ i ] [ j ] [ 0 ] ] -= 1\n                Dup [ P [ i ] [ j ] [ 0 ] + 1 ] += 1\nfor i in range ( 1 , latest + 2 ) :\n    Dup [ i ] += Dup [ i - 1 ]\nprint ( max ( Dup ) )\n", "python_code_tokenized": "N , C = map ( int , input ( ) . split ( ) ) NEW_LINE latest = 0 NEW_LINE P = [ [ ] for i in range ( C ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT s , t , c = map ( int , input ( ) . split ( ) ) NEW_LINE P [ c - 1 ] . append ( ( s , t ) ) NEW_LINE latest = max ( latest , t ) NEW_LINE DEDENT Dup = [ 0 for i in range ( latest + 2 ) ] NEW_LINE for i in range ( C ) : NEW_LINE INDENT P [ i ] . sort ( ) NEW_LINE for j in range ( len ( P [ i ] ) ) : NEW_LINE INDENT Dup [ P [ i ] [ j ] [ 0 ] ] += 1 NEW_LINE Dup [ P [ i ] [ j ] [ 1 ] + 1 ] -= 1 NEW_LINE if j >= 1 : NEW_LINE INDENT if P [ i ] [ j ] [ 0 ] == P [ i ] [ j - 1 ] [ 1 ] : NEW_LINE INDENT Dup [ P [ i ] [ j ] [ 0 ] ] -= 1 NEW_LINE Dup [ P [ i ] [ j ] [ 0 ] + 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 1 , latest + 2 ) : NEW_LINE INDENT Dup [ i ] += Dup [ i - 1 ] NEW_LINE DEDENT print ( max ( Dup ) ) NEW_LINE"}
{"id": "geeksforgeeks_4306_A", "sol": 0, "python_code": "def alphabetPattern ( N ) :\n    left , middle , right = 0 , N - 1 , N + 1\n    for row in range ( 0 , 2 * N - 1 ) :\n        if row < N :\n            left += 1\n            print ( left , end = \"\" )\n        else :\n            left -= 1\n            print ( left , end = \"\" )\n        for col in range ( 1 , N - 1 ) :\n            if row != N - 1 :\n                print ( \"\" , end = \"\" )\n            else :\n                print ( \"\" + str ( middle ) , end = \"\" )\n                middle -= 1\n        if row < N :\n            right -= 1\n            print ( \"\" + str ( right ) , end = \"\" )\n        else :\n            right += 1\n            print ( \"\" + str ( right ) , end = \"\" )\n        print ( )\nif __name__ == \"__main__\" :\n    N = 4\n    alphabetPattern ( N )\n", "python_code_tokenized": "def alphabetPattern ( N ) : NEW_LINE INDENT left , middle , right = 0 , N - 1 , N + 1 NEW_LINE for row in range ( 0 , 2 * N - 1 ) : NEW_LINE INDENT if row < N : NEW_LINE INDENT left += 1 NEW_LINE print ( left , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT left -= 1 NEW_LINE print ( left , end = \" \" ) NEW_LINE DEDENT for col in range ( 1 , N - 1 ) : NEW_LINE INDENT if row != N - 1 : NEW_LINE INDENT print ( \" \u2581 \" , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \u2581 \" + str ( middle ) , end = \" \" ) NEW_LINE middle -= 1 NEW_LINE DEDENT DEDENT if row < N : NEW_LINE INDENT right -= 1 NEW_LINE print ( \" \u2581 \" + str ( right ) , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT right += 1 NEW_LINE print ( \" \u2581 \" + str ( right ) , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE alphabetPattern ( N ) NEW_LINE DEDENT"}
{"id": "aizu_p00686_A", "sol": 0, "python_code": "f = [ [ 0 , 1 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ - 1 , 0 ] ]\nb = [ [ 0 , - 1 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 1 , 0 ] ]\nwhile True :\n    w , h = map ( int , input ( ).split ( ) )\n    if w == 0 : break\n    r , c , d = 1 , 1 , 0\n    while True :\n        buf = input ( ).split ( )\n        if buf [ 0 ] == \"STOP\" : break\n        elif buf [ 0 ] == \"RIGHT\" : d = ( d + 1 ) % 4\n        elif buf [ 0 ] == \"LEFT\" : d = ( d + 3 ) % 4\n        else :\n            if buf [ 0 ] == \"FORWARD\" :\n                r2 = r + int ( buf [ 1 ] ) * f [ d ] [ 1 ]\n                c2 = c + int ( buf [ 1 ] ) * f [ d ] [ 0 ]\n            else :\n                r2 = r + int ( buf [ 1 ] ) * b [ d ] [ 1 ]\n                c2 = c + int ( buf [ 1 ] ) * b [ d ] [ 0 ]\n            if r2 < 1 : r2 = 1\n            if r2 > h : r2 = h\n            if c2 < 1 : c2 = 1\n            if c2 > w : c2 = w\n            r , c = r2 , c2\n    print ( c , r )\n", "python_code_tokenized": "f = [ [ 0 , 1 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ - 1 , 0 ] ] NEW_LINE b = [ [ 0 , - 1 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 1 , 0 ] ] NEW_LINE while True : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE if w == 0 : break NEW_LINE r , c , d = 1 , 1 , 0 NEW_LINE while True : NEW_LINE INDENT buf = input ( ) . split ( ) NEW_LINE if buf [ 0 ] == \" STOP \" : break NEW_LINE elif buf [ 0 ] == \" RIGHT \" : d = ( d + 1 ) % 4 NEW_LINE elif buf [ 0 ] == \" LEFT \" : d = ( d + 3 ) % 4 NEW_LINE else : NEW_LINE INDENT if buf [ 0 ] == \" FORWARD \" : NEW_LINE INDENT r2 = r + int ( buf [ 1 ] ) * f [ d ] [ 1 ] NEW_LINE c2 = c + int ( buf [ 1 ] ) * f [ d ] [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT r2 = r + int ( buf [ 1 ] ) * b [ d ] [ 1 ] NEW_LINE c2 = c + int ( buf [ 1 ] ) * b [ d ] [ 0 ] NEW_LINE DEDENT if r2 < 1 : r2 = 1 NEW_LINE if r2 > h : r2 = h NEW_LINE if c2 < 1 : c2 = 1 NEW_LINE if c2 > w : c2 = w NEW_LINE r , c = r2 , c2 NEW_LINE DEDENT DEDENT print ( c , r ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4856_A", "sol": 0, "python_code": "from math import sqrt\ndef isPrime ( n ) :\n    if ( n <= 1 ) :\n        return False\n    if ( n <= 3 ) :\n        return True\n    if ( n % 2 == 0 or n % 3 == 0 ) :\n        return False\n    i = 5\n    while ( i * i <= n ) :\n        if ( n % i == 0 or n % ( i + 2 ) == 0 ) :\n            return False\n        i = i + 6\n    return True\ndef power ( x , y , p ) :\n    res = 1\n    x = x % p\n    while ( y > 0 ) :\n        if ( y & 1 ) :\n            res = ( res * x ) % p\n        y = y >> 1\n        x = ( x * x ) % p\n    return res\ndef findPrimefactors ( s , n ) :\n    while ( n % 2 == 0 ) :\n        s.add ( 2 )\n        n = n // 2\n    for i in range ( 3 , int ( sqrt ( n ) ) , 2 ) :\n        while ( n % i == 0 ) :\n            s.add ( i )\n            n = n // i\n    if ( n > 2 ) :\n        s.add ( n )\ndef findPrimitive ( n ) :\n    s = set ( )\n    if ( isPrime ( n ) == False ) :\n        return - 1\n    phi = n - 1\n    findPrimefactors ( s , phi )\n    for r in range ( 2 , phi + 1 ) :\n        flag = False\n        for it in s :\n            if ( power ( r , phi // it , n ) == 1 ) :\n                flag = True\n                break\n        if ( flag == False ) :\n            return r\n    return - 1\nn = 761\nprint ( \"Smallest primitive root of\" , n , \"is\" , findPrimitive ( n ) )\n", "python_code_tokenized": "from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def findPrimefactors ( s , n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT s . add ( 2 ) NEW_LINE n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT s . add ( i ) NEW_LINE n = n // i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT s . add ( n ) NEW_LINE DEDENT DEDENT def findPrimitive ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE if ( isPrime ( n ) == False ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT phi = n - 1 NEW_LINE findPrimefactors ( s , phi ) NEW_LINE for r in range ( 2 , phi + 1 ) : NEW_LINE INDENT flag = False NEW_LINE for it in s : NEW_LINE INDENT if ( power ( r , phi // it , n ) == 1 ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT return r NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT n = 761 NEW_LINE print ( \" Smallest \u2581 primitive \u2581 root \u2581 of \" , n , \" is \" , findPrimitive ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4209_A", "sol": 0, "python_code": "def findCountOfPairs ( a , b , n ) :\n    ans = 0\n    ans += n * int ( a / n ) * int ( b / n )\n    ans += int ( a / n ) * ( b % n )\n    ans += ( a % n ) * int ( b / n )\n    ans += int ( ( ( a % n ) + ( b % n ) ) / n ) ;\n    return ans\nif __name__ == '__main__' :\n    a = 5\n    b = 13\n    n = 3\n    print ( findCountOfPairs ( a , b , n ) )\n", "python_code_tokenized": "def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * int ( a / n ) * int ( b / n ) NEW_LINE ans += int ( a / n ) * ( b % n ) NEW_LINE ans += ( a % n ) * int ( b / n ) NEW_LINE ans += int ( ( ( a % n ) + ( b % n ) ) / n ) ; NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE b = 13 NEW_LINE n = 3 NEW_LINE print ( findCountOfPairs ( a , b , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2521_A", "sol": 0, "python_code": "def recamanGenerator ( arr , n ) :\n    arr [ 0 ] = 0\n    for i in range ( 1 , n ) :\n        temp = arr [ i - 1 ] - i\n        j = 0\n        for j in range ( i ) :\n            if ( ( arr [ j ] == temp ) or temp < 0 ) :\n                temp = arr [ i - 1 ] + i\n                break\n        arr [ i ] = temp\ndef recamanArray ( arr , n ) :\n    s = dict ( )\n    recaman = [ 0 for i in range ( n ) ]\n    recamanGenerator ( recaman , n )\n    for i in range ( n ) :\n        s [ recaman [ i ] ] = s.get ( recaman [ i ] , 0 ) + 1\n    for i in range ( n ) :\n        if arr [ i ] in s.keys ( ) :\n            del s [ arr [ i ] ]\n    return len ( s )\narr = [ 7 , 11 , 20 , 4 , 2 , 1 , 8 , 6 ]\nn = len ( arr )\nprint ( recamanArray ( arr , n ) )\n", "python_code_tokenized": "def recamanGenerator ( arr , n ) : NEW_LINE INDENT arr [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT temp = arr [ i - 1 ] - i NEW_LINE j = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( ( arr [ j ] == temp ) or temp < 0 ) : NEW_LINE INDENT temp = arr [ i - 1 ] + i NEW_LINE break NEW_LINE DEDENT DEDENT arr [ i ] = temp NEW_LINE DEDENT DEDENT def recamanArray ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE recaman = [ 0 for i in range ( n ) ] NEW_LINE recamanGenerator ( recaman , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ recaman [ i ] ] = s . get ( recaman [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in s . keys ( ) : NEW_LINE INDENT del s [ arr [ i ] ] NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT arr = [ 7 , 11 , 20 , 4 , 2 , 1 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( recamanArray ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_363_A", "sol": 0, "python_code": "n = input ( )\nres = [ ]\nfor d in reversed ( n ) :\n    d = int ( d )\n    s = ( \"-O\" if d >= 5 else \"O-\" ) + \"|\" + \"O\" * ( d % 5 ) + \"-\" + \"O\" * ( 4 - d % 5 )\n    res.append ( s )\nres = \"\\n\".join ( res )\nprint ( res )\n", "python_code_tokenized": "n = input ( ) NEW_LINE res = [ ] NEW_LINE for d in reversed ( n ) : NEW_LINE INDENT d = int ( d ) NEW_LINE s = ( \" - O \" if d >= 5 else \" O - \" ) + \" | \" + \" O \" * ( d % 5 ) + \" - \" + \" O \" * ( 4 - d % 5 ) NEW_LINE res . append ( s ) NEW_LINE DEDENT res = \" \\n \" . join ( res ) NEW_LINE print ( res ) NEW_LINE"}
{"id": "codeforces_787_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( \" \" ) )\nc , d = map ( int , input ( ).split ( \" \" ) )\nl = [ ]\nf = False\nanw = - 1\nfor i in range ( 101 ) :\n    x = b + ( a * i )\n    y = d + ( c * i )\n    if f :\n        break\n    if x in l :\n        f = True\n        anw = x\n        break\n    l.append ( x )\n    if y in l :\n        f = True\n        anw = y\n        break\n    l.append ( y )\nprint ( anw )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( \" \u2581 \" ) ) NEW_LINE c , d = map ( int , input ( ) . split ( \" \u2581 \" ) ) NEW_LINE l = [ ] NEW_LINE f = False NEW_LINE anw = - 1 NEW_LINE for i in range ( 101 ) : NEW_LINE INDENT x = b + ( a * i ) NEW_LINE y = d + ( c * i ) NEW_LINE if f : NEW_LINE INDENT break NEW_LINE DEDENT if x in l : NEW_LINE INDENT f = True NEW_LINE anw = x NEW_LINE break NEW_LINE DEDENT l . append ( x ) NEW_LINE if y in l : NEW_LINE INDENT f = True NEW_LINE anw = y NEW_LINE break NEW_LINE DEDENT l . append ( y ) NEW_LINE DEDENT print ( anw ) NEW_LINE"}
{"id": "codeforces_805_A", "sol": 0, "python_code": "l , r = map ( int , input ( ).split ( ) )\nif l == r :\n    print ( l )\nelse :\n    print ( 2 )\n", "python_code_tokenized": "l , r = map ( int , input ( ) . split ( ) ) NEW_LINE if l == r : NEW_LINE INDENT print ( l ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT"}
{"id": "aizu_p01086_A", "sol": 0, "python_code": "while True :\n    n = int ( input ( ) )\n    if n == 0 :\n        break\n    else :\n        phlist = [ ]\n        phflag = 0\n        for i in range ( n ) :\n            phlist.append ( input ( ) )\n        for i in range ( len ( phlist ) - 4 ) :\n            cur = 0\n            state = 0\n            for j in range ( i , len ( phlist ) ) :\n                s = phlist [ j ]\n                cur += len ( s )\n                if state == 0 and cur < 5 :\n                    continue\n                elif state == 0 and cur == 5 :\n                    cur = 0\n                    state = 1\n                elif state == 1 and cur < 7 :\n                    continue\n                elif state == 1 and cur == 7 :\n                    cur = 0\n                    state = 2\n                elif state == 2 and cur < 5 :\n                    continue\n                elif state == 2 and cur == 5 :\n                    cur = 0\n                    state = 3\n                elif state == 3 and cur < 7 :\n                    continue\n                elif state == 3 and cur == 7 :\n                    cur = 0\n                    state = 4\n                elif state == 4 and cur < 7 :\n                    continue\n                elif state == 4 and cur == 7 :\n                    print ( i + 1 )\n                    phflag = 1\n                    break\n            if phflag :\n                break\n", "python_code_tokenized": "while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT phlist = [ ] NEW_LINE phflag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT phlist . append ( input ( ) ) NEW_LINE DEDENT for i in range ( len ( phlist ) - 4 ) : NEW_LINE INDENT cur = 0 NEW_LINE state = 0 NEW_LINE for j in range ( i , len ( phlist ) ) : NEW_LINE INDENT s = phlist [ j ] NEW_LINE cur += len ( s ) NEW_LINE if state == 0 and cur < 5 : NEW_LINE INDENT continue NEW_LINE DEDENT elif state == 0 and cur == 5 : NEW_LINE INDENT cur = 0 NEW_LINE state = 1 NEW_LINE DEDENT elif state == 1 and cur < 7 : NEW_LINE INDENT continue NEW_LINE DEDENT elif state == 1 and cur == 7 : NEW_LINE INDENT cur = 0 NEW_LINE state = 2 NEW_LINE DEDENT elif state == 2 and cur < 5 : NEW_LINE INDENT continue NEW_LINE DEDENT elif state == 2 and cur == 5 : NEW_LINE INDENT cur = 0 NEW_LINE state = 3 NEW_LINE DEDENT elif state == 3 and cur < 7 : NEW_LINE INDENT continue NEW_LINE DEDENT elif state == 3 and cur == 7 : NEW_LINE INDENT cur = 0 NEW_LINE state = 4 NEW_LINE DEDENT elif state == 4 and cur < 7 : NEW_LINE INDENT continue NEW_LINE DEDENT elif state == 4 and cur == 7 : NEW_LINE INDENT print ( i + 1 ) NEW_LINE phflag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if phflag : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT"}
{"id": "codeforces_466_A", "sol": 0, "python_code": "n , m , a , b = map ( int , input ( ).split ( ) )\nif b > a * m :\n    print ( n * a )\nelse :\n    f = int ( ( ( n % m ) * a ) + ( ( n - n % m ) / m ) * b )\n    if f - a + b < f and n % m != 0 :\n        f = f - ( ( n % m ) * a ) + b\n    if f > n * a :\n        f = n * a\n    if b < f and m >= n :\n        f = b\n    print ( f )\n", "python_code_tokenized": "n , m , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b > a * m : NEW_LINE INDENT print ( n * a ) NEW_LINE DEDENT else : NEW_LINE INDENT f = int ( ( ( n % m ) * a ) + ( ( n - n % m ) / m ) * b ) NEW_LINE if f - a + b < f and n % m != 0 : NEW_LINE INDENT f = f - ( ( n % m ) * a ) + b NEW_LINE DEDENT if f > n * a : NEW_LINE INDENT f = n * a NEW_LINE DEDENT if b < f and m >= n : NEW_LINE INDENT f = b NEW_LINE DEDENT print ( f ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3042_A", "sol": 0, "python_code": "def minimumSquare ( a , b ) :\n    result = 0\n    rem = 0\n    if ( a < b ) :\n        a , b = b , a\n    while ( b > 0 ) :\n        result += int ( a / b )\n        rem = int ( a % b )\n        a = b\n        b = rem\n    return result\nn = 13\nm = 29\nprint ( minimumSquare ( n , m ) )\n", "python_code_tokenized": "def minimumSquare ( a , b ) : NEW_LINE INDENT result = 0 NEW_LINE rem = 0 NEW_LINE if ( a < b ) : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT while ( b > 0 ) : NEW_LINE INDENT result += int ( a / b ) NEW_LINE rem = int ( a % b ) NEW_LINE a = b NEW_LINE b = rem NEW_LINE DEDENT return result NEW_LINE DEDENT n = 13 NEW_LINE m = 29 NEW_LINE print ( minimumSquare ( n , m ) ) NEW_LINE"}
{"id": "geeksforgeeks_1297_A", "sol": 0, "python_code": "def bestApproximate ( x , y , n ) :\n    sum_x = 0\n    sum_y = 0\n    sum_xy = 0\n    sum_x2 = 0\n    for i in range ( 0 , n ) :\n        sum_x += x [ i ]\n        sum_y += y [ i ]\n        sum_xy += x [ i ] * y [ i ]\n        sum_x2 += pow ( x [ i ] , 2 )\n    m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ) ;\n    c = ( float ) ( sum_y - m * sum_x ) / n ;\n    print ( \"m = \" , m ) ;\n    print ( \"c = \" , c ) ;\nx = [ 1 , 2 , 3 , 4 , 5 ]\ny = [ 14 , 27 , 40 , 55 , 68 ]\nn = len ( x )\nbestApproximate ( x , y , n )\n", "python_code_tokenized": "def bestApproximate ( x , y , n ) : NEW_LINE INDENT sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_y += y [ i ] NEW_LINE sum_xy += x [ i ] * y [ i ] NEW_LINE sum_x2 += pow ( x [ i ] , 2 ) NEW_LINE DEDENT m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ) ; NEW_LINE c = ( float ) ( sum_y - m * sum_x ) / n ; NEW_LINE print ( \" m \u2581 = \u2581 \" , m ) ; NEW_LINE print ( \" c \u2581 = \u2581 \" , c ) ; NEW_LINE DEDENT x = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE y = [ 14 , 27 , 40 , 55 , 68 ] NEW_LINE n = len ( x ) NEW_LINE bestApproximate ( x , y , n ) NEW_LINE"}
{"id": "codeforces_1278_A", "sol": 0, "python_code": "from collections import Counter\nk = int ( input ( ) )\nfor _ in range ( k ) :\n    key = input ( )\n    s = input ( )\n    length = len ( key )\n    ref = Counter ( key )\n    cur = Counter ( )\n    ans = False\n    for i , ch in enumerate ( s ) :\n        cur [ ch ] += 1\n        if i >= len ( key ) :\n            cur [ s [ i - len ( key ) ] ] -= 1\n        if i >= len ( key ) - 1 :\n            ans = ans or all ( cur [ i ] == ref [ i ] for i in ref )\n    print ( \"YES\" if ans else \"NO\" )\n", "python_code_tokenized": "from collections import Counter NEW_LINE k = int ( input ( ) ) NEW_LINE for _ in range ( k ) : NEW_LINE INDENT key = input ( ) NEW_LINE s = input ( ) NEW_LINE length = len ( key ) NEW_LINE ref = Counter ( key ) NEW_LINE cur = Counter ( ) NEW_LINE ans = False NEW_LINE for i , ch in enumerate ( s ) : NEW_LINE INDENT cur [ ch ] += 1 NEW_LINE if i >= len ( key ) : NEW_LINE INDENT cur [ s [ i - len ( key ) ] ] -= 1 NEW_LINE DEDENT if i >= len ( key ) - 1 : NEW_LINE INDENT ans = ans or all ( cur [ i ] == ref [ i ] for i in ref ) NEW_LINE DEDENT DEDENT print ( \" YES \" if ans else \" NO \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1529_A", "sol": 0, "python_code": "t = eval ( input ( ) )\nfor i in range ( t ) :\n    n = eval ( input ( ) )\n    input_list = list ( map ( lambda e : eval ( e ) , input ( ).split ( \" \" ) ) )\n    minimum = min ( input_list )\n    minimum_count = input_list.count ( minimum )\n    print ( n - minimum_count )\n", "python_code_tokenized": "t = eval ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = eval ( input ( ) ) NEW_LINE input_list = list ( map ( lambda e : eval ( e ) , input ( ) . split ( \" \u2581 \" ) ) ) NEW_LINE minimum = min ( input_list ) NEW_LINE minimum_count = input_list . count ( minimum ) NEW_LINE print ( n - minimum_count ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4757_A", "sol": 0, "python_code": "def checkBit ( pattern , arr , n ) :\n    count = 0\n    for i in range ( 0 , n ) :\n        if ( ( pattern & arr [ i ] ) == pattern ) :\n            count = count + 1\n    return count\ndef maxAND ( arr , n ) :\n    res = 0\n    for bit in range ( 31 , - 1 , - 1 ) :\n        count = checkBit ( res | ( 1 << bit ) , arr , n )\n        if ( count >= 2 ) :\n            res = res | ( 1 << bit )\n    return res\narr = [ 4 , 8 , 6 , 2 ]\nn = len ( arr )\nprint ( \"Maximum AND Value = \" , maxAND ( arr , n ) )\n", "python_code_tokenized": "def checkBit ( pattern , arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( pattern & arr [ i ] ) == pattern ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def maxAND ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for bit in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT count = checkBit ( res | ( 1 << bit ) , arr , n ) NEW_LINE if ( count >= 2 ) : NEW_LINE INDENT res = res | ( 1 << bit ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 4 , 8 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum \u2581 AND \u2581 Value \u2581 = \u2581 \" , maxAND ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_125_A", "sol": 0, "python_code": "n = int ( input ( ) )\ninches = round ( n / 3 )\nfeet = inches // 12\ninches = inches % 12\nprint ( feet , inches )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE inches = round ( n / 3 ) NEW_LINE feet = inches // 12 NEW_LINE inches = inches % 12 NEW_LINE print ( feet , inches ) NEW_LINE"}
{"id": "codeforces_1399_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    n = int ( input ( ) )\n    l1 = list ( map ( int , input ( ).split ( ) ) )\n    l2 = list ( map ( int , input ( ).split ( ) ) )\n    a = min ( l1 )\n    b = min ( l2 )\n    ans = 0\n    for j in range ( n ) :\n        ans += max ( l1 [ j ] - a , l2 [ j ] - b )\n    print ( ans )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l2 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = min ( l1 ) NEW_LINE b = min ( l2 ) NEW_LINE ans = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT ans += max ( l1 [ j ] - a , l2 [ j ] - b ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "codeforces_119_A", "sol": 0, "python_code": "import math\ns , a , n = map ( int , input ( ).split ( ) )\nz = 1\nx = s\ny = 0\nwhile n >= math.gcd ( x , n ) :\n    if z == 1 :\n        x = s\n        y = 0\n    else :\n        x = a\n        y = 1\n    n -= math.gcd ( x , n )\n    z = z * - 1\nprint ( y )\n", "python_code_tokenized": "import math NEW_LINE s , a , n = map ( int , input ( ) . split ( ) ) NEW_LINE z = 1 NEW_LINE x = s NEW_LINE y = 0 NEW_LINE while n >= math . gcd ( x , n ) : NEW_LINE INDENT if z == 1 : NEW_LINE INDENT x = s NEW_LINE y = 0 NEW_LINE DEDENT else : NEW_LINE INDENT x = a NEW_LINE y = 1 NEW_LINE DEDENT n -= math . gcd ( x , n ) NEW_LINE z = z * - 1 NEW_LINE DEDENT print ( y ) NEW_LINE"}
{"id": "codeforces_805_B", "sol": 0, "python_code": "n = int ( input ( ) )\ns = \"aabb\"\nwhile ( len ( s ) < n ) :\n    s = s + s\nprint ( s [ : n ] )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = \" aabb \" NEW_LINE while ( len ( s ) < n ) : NEW_LINE INDENT s = s + s NEW_LINE DEDENT print ( s [ : n ] ) NEW_LINE"}
{"id": "aizu_p02212_A", "sol": 0, "python_code": "def main ( ) :\n    A = list ( map ( int , input ( ).split ( ) ) )\n    ans = abs ( A [ 0 ] + A [ 1 ] - A [ 2 ] - A [ 3 ] )\n    for i in range ( 4 ) :\n        for j in range ( 4 ) :\n            if i == j :\n                continue\n            now = 0\n            for t in range ( 4 ) :\n                if t == i or t == j :\n                    now += A [ t ]\n                else :\n                    now -= A [ t ]\n            if abs ( now ) < ans :\n                ans = abs ( now )\n    print ( ans )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = abs ( A [ 0 ] + A [ 1 ] - A [ 2 ] - A [ 3 ] ) NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT for j in range ( 4 ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT now = 0 NEW_LINE for t in range ( 4 ) : NEW_LINE INDENT if t == i or t == j : NEW_LINE INDENT now += A [ t ] NEW_LINE DEDENT else : NEW_LINE INDENT now -= A [ t ] NEW_LINE DEDENT DEDENT if abs ( now ) < ans : NEW_LINE INDENT ans = abs ( now ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1000_A", "sol": 0, "python_code": "def coordinateCompression ( arr , n ) :\n    s = dict ( )\n    for i in range ( n ) :\n        s [ arr [ i ] ] = 1\n    index = 0\n    mp = dict ( )\n    for itr in sorted ( s ) :\n        index += 1\n        mp [ itr ] = index\n    for i in range ( n ) :\n        arr [ i ] = mp [ arr [ i ] ]\ndef query ( BIT , index , n ) :\n    ans = 0\n    while ( index > 0 ) :\n        ans = max ( ans , BIT [ index ] )\n        index -= index & ( - index )\n    return ans\ndef update ( BIT , index , n ) :\n    x = query ( BIT , index - 1 , n )\n    value = x + 1\n    while ( index <= n ) :\n        BIT [ index ] = max ( BIT [ index ] , value )\n        index += index & ( - index )\ndef findLISLength ( arr , n ) :\n    coordinateCompression ( arr , n )\n    BIT = [ 0 ] * ( n + 1 )\n    for i in range ( n ) :\n        update ( BIT , arr [ i ] , n )\n    ans = query ( BIT , n , n )\n    return ans\narr = [ 6 , 5 , 1 , 3 , 2 , 4 , 8 , 7 ]\nn = len ( arr )\nans = findLISLength ( arr , n )\nprint ( ans )\n", "python_code_tokenized": "def coordinateCompression ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE DEDENT index = 0 NEW_LINE mp = dict ( ) NEW_LINE for itr in sorted ( s ) : NEW_LINE INDENT index += 1 NEW_LINE mp [ itr ] = index NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = mp [ arr [ i ] ] NEW_LINE DEDENT DEDENT def query ( BIT , index , n ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( index > 0 ) : NEW_LINE INDENT ans = max ( ans , BIT [ index ] ) NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def update ( BIT , index , n ) : NEW_LINE INDENT x = query ( BIT , index - 1 , n ) NEW_LINE value = x + 1 NEW_LINE while ( index <= n ) : NEW_LINE INDENT BIT [ index ] = max ( BIT [ index ] , value ) NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT def findLISLength ( arr , n ) : NEW_LINE INDENT coordinateCompression ( arr , n ) NEW_LINE BIT = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT update ( BIT , arr [ i ] , n ) NEW_LINE DEDENT ans = query ( BIT , n , n ) NEW_LINE return ans NEW_LINE DEDENT arr = [ 6 , 5 , 1 , 3 , 2 , 4 , 8 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE ans = findLISLength ( arr , n ) NEW_LINE print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_332_A", "sol": 0, "python_code": "def countP ( n , k ) :\n    if ( n == 0 or k == 0 or k > n ) :\n        return 0\n    if ( k == 1 or k == n ) :\n        return 1\n    return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) )\nif __name__ == \"__main__\" :\n    print ( countP ( 3 , 2 ) )\n", "python_code_tokenized": "def countP ( n , k ) : NEW_LINE INDENT if ( n == 0 or k == 0 or k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( countP ( 3 , 2 ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00108_A", "sol": 0, "python_code": "while 1 :\n    n = int ( input ( ) )\n    if n == 0 : break\n    count = 0\n    S_keep = list ( map ( int , input ( ).split ( ) ) )\n    while 1 :\n        S = [ ]\n        for i in S_keep :\n            S.append ( S_keep.count ( i ) )\n        if S_keep == S :\n            print ( count )\n            print ( \" \".join ( map ( str , S ) ) )\n            break\n        else :\n            count += 1\n            S_keep = S\n", "python_code_tokenized": "while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE count = 0 NEW_LINE S_keep = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE while 1 : NEW_LINE INDENT S = [ ] NEW_LINE for i in S_keep : NEW_LINE INDENT S . append ( S_keep . count ( i ) ) NEW_LINE DEDENT if S_keep == S : NEW_LINE INDENT print ( count ) NEW_LINE print ( \" \u2581 \" . join ( map ( str , S ) ) ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE S_keep = S NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "projecteuler_p401_A", "sol": 0, "python_code": "import eulerlib\ndef compute ( ) :\n    LIMIT = 10 ** 15\n    MODULUS = 10 ** 9\n    splitcount = eulerlib.sqrt ( LIMIT )\n    splitat = LIMIT // ( splitcount + 1 )\n    def sum_squares ( s , e ) :\n        return ( e * ( e + 1 ) * ( e * 2 + 1 ) - s * ( s + 1 ) * ( s * 2 + 1 ) ) // 6\n    ans = sum ( ( i * i * ( LIMIT // i ) ) for i in range ( 1 , splitat + 1 ) )\n    ans += sum ( ( sum_squares ( LIMIT // ( i + 1 ) , LIMIT // i ) * i ) for i in range ( 1 , splitcount + 1 ) )\n    return str ( ans % MODULUS )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 15 NEW_LINE MODULUS = 10 ** 9 NEW_LINE splitcount = eulerlib . sqrt ( LIMIT ) NEW_LINE splitat = LIMIT // ( splitcount + 1 ) NEW_LINE def sum_squares ( s , e ) : NEW_LINE INDENT return ( e * ( e + 1 ) * ( e * 2 + 1 ) - s * ( s + 1 ) * ( s * 2 + 1 ) ) // 6 NEW_LINE DEDENT ans = sum ( ( i * i * ( LIMIT // i ) ) for i in range ( 1 , splitat + 1 ) ) NEW_LINE ans += sum ( ( sum_squares ( LIMIT // ( i + 1 ) , LIMIT // i ) * i ) for i in range ( 1 , splitcount + 1 ) ) NEW_LINE return str ( ans % MODULUS ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1209_A", "sol": 0, "python_code": "def solve ( arr ) :\n    ans = 0\n    arr.sort ( )\n    for i in range ( len ( arr ) ) :\n        ok = 0\n        for j in range ( i ) :\n            if arr [ i ] % arr [ j ] == 0 :\n                ok = 1\n                break\n        if not ok :\n            ans += 1\n    return ans\nn = int ( input ( ) )\narr = list ( map ( int , input ( ).split ( ) ) )\nprint ( solve ( arr ) )\n", "python_code_tokenized": "def solve ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT ok = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if arr [ i ] % arr [ j ] == 0 : NEW_LINE INDENT ok = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if not ok : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( solve ( arr ) ) NEW_LINE"}
{"id": "geeksforgeeks_1112_A", "sol": 0, "python_code": "def maxIndexDiff ( arr , n ) :\n    LMin = [ None ] * n\n    RMax = [ None ] * n\n    LMin [ 0 ] = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        LMin [ i ] = min ( arr [ i ] , LMin [ i - 1 ] )\n    RMax [ n - 1 ] = arr [ n - 1 ]\n    for j in range ( n - 2 , - 1 , - 1 ) :\n        RMax [ j ] = max ( arr [ j ] , RMax [ j + 1 ] )\n    i = 0\n    j = 0\n    maxDiff = - 1\n    while ( j < n and i < n ) :\n        if ( LMin [ i ] < RMax [ j ] ) :\n            maxDiff = max ( maxDiff , j - i )\n            j = j + 1\n        else :\n            i = i + 1\n    return maxDiff + 1\ndef modifyarr ( arr , n , x ) :\n    for i in range ( n ) :\n        arr [ i ] = arr [ i ] - x\ndef calcprefix ( arr , n ) :\n    s = 0\n    for i in range ( n ) :\n        s += arr [ i ]\n        arr [ i ] = s\ndef longestsubarray ( arr , n , x ) :\n    modifyarr ( arr , n , x )\n    calcprefix ( arr , n )\n    return maxIndexDiff ( arr , n )\nif __name__ == \"__main__\" :\n    arr = [ 1 , 1 , 2 , - 1 , - 1 , 1 ]\n    x = 1\n    n = len ( arr )\n    print ( longestsubarray ( arr , n , x ) )\n", "python_code_tokenized": "def maxIndexDiff ( arr , n ) : NEW_LINE INDENT LMin = [ None ] * n NEW_LINE RMax = [ None ] * n NEW_LINE LMin [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT LMin [ i ] = min ( arr [ i ] , LMin [ i - 1 ] ) NEW_LINE DEDENT RMax [ n - 1 ] = arr [ n - 1 ] NEW_LINE for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT RMax [ j ] = max ( arr [ j ] , RMax [ j + 1 ] ) NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE maxDiff = - 1 NEW_LINE while ( j < n and i < n ) : NEW_LINE INDENT if ( LMin [ i ] < RMax [ j ] ) : NEW_LINE INDENT maxDiff = max ( maxDiff , j - i ) NEW_LINE j = j + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT return maxDiff + 1 NEW_LINE DEDENT def modifyarr ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - x NEW_LINE DEDENT DEDENT def calcprefix ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE arr [ i ] = s NEW_LINE DEDENT DEDENT def longestsubarray ( arr , n , x ) : NEW_LINE INDENT modifyarr ( arr , n , x ) NEW_LINE calcprefix ( arr , n ) NEW_LINE return maxIndexDiff ( arr , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , - 1 , - 1 , 1 ] NEW_LINE x = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( longestsubarray ( arr , n , x ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2716_A", "sol": 0, "python_code": "def sortArrays ( arr ) :\n    length = len ( arr )\n    j = 0\n    while j < length - 1 :\n        if ( arr [ j ] > arr [ j + 1 ] ) :\n            temp = arr [ j ]\n            arr [ j ] = arr [ j + 1 ]\n            arr [ j + 1 ] = temp\n            j = - 1\n        j += 1\n    return arr\nif __name__ == '__main__' :\n    arr = [ 1 , 2 , 99 , 9 , 8 , 7 , 6 , 0 , 5 , 4 , 3 ]\n    print ( \"Original array: \" , arr )\n    arr = sortArrays ( arr )\n    print ( \"Sorted array: \" , arr )\n", "python_code_tokenized": "def sortArrays ( arr ) : NEW_LINE INDENT length = len ( arr ) NEW_LINE j = 0 NEW_LINE while j < length - 1 : NEW_LINE INDENT if ( arr [ j ] > arr [ j + 1 ] ) : NEW_LINE INDENT temp = arr [ j ] NEW_LINE arr [ j ] = arr [ j + 1 ] NEW_LINE arr [ j + 1 ] = temp NEW_LINE j = - 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT return arr NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 99 , 9 , 8 , 7 , 6 , 0 , 5 , 4 , 3 ] NEW_LINE print ( \" Original \u2581 array : \u2581 \" , arr ) NEW_LINE arr = sortArrays ( arr ) NEW_LINE print ( \" Sorted \u2581 array : \u2581 \" , arr ) NEW_LINE DEDENT"}
{"id": "codeforces_1264_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor iteretor in range ( t ) :\n    n = int ( input ( ) )\n    lst = list ( map ( int , input ( ).split ( ) ) )\n    if n < 5 :\n        print ( 0 , 0 , 0 )\n        continue\n    dicts = { }\n    max = n // 2\n    b = 0\n    for i in lst :\n        if i in dicts :\n            dicts [ i ] += 1\n        else :\n            dicts [ i ] = 1\n    for i in dicts :\n        if b + dicts [ i ] > max :\n            break\n        b += dicts [ i ]\n    i , g = 1 , dicts [ list ( dicts ) [ 0 ] ]\n    b , s = b - g , 0\n    while i < len ( list ( dicts ) ) and b - dicts [ list ( dicts ) [ i ] ] > g and s <= g :\n        s += dicts [ list ( dicts ) [ i ] ]\n        b -= dicts [ list ( dicts ) [ i ] ]\n        i += 1\n    if s <= g or b <= g :\n        print ( 0 , 0 , 0 )\n    else :\n        print ( g , s , b )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for iteretor in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n < 5 : NEW_LINE INDENT print ( 0 , 0 , 0 ) NEW_LINE continue NEW_LINE DEDENT dicts = { } NEW_LINE max = n // 2 NEW_LINE b = 0 NEW_LINE for i in lst : NEW_LINE INDENT if i in dicts : NEW_LINE INDENT dicts [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dicts [ i ] = 1 NEW_LINE DEDENT DEDENT for i in dicts : NEW_LINE INDENT if b + dicts [ i ] > max : NEW_LINE INDENT break NEW_LINE DEDENT b += dicts [ i ] NEW_LINE DEDENT i , g = 1 , dicts [ list ( dicts ) [ 0 ] ] NEW_LINE b , s = b - g , 0 NEW_LINE while i < len ( list ( dicts ) ) and b - dicts [ list ( dicts ) [ i ] ] > g and s <= g : NEW_LINE INDENT s += dicts [ list ( dicts ) [ i ] ] NEW_LINE b -= dicts [ list ( dicts ) [ i ] ] NEW_LINE i += 1 NEW_LINE DEDENT if s <= g or b <= g : NEW_LINE INDENT print ( 0 , 0 , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( g , s , b ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC155_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nans = \"APPROVED\"\nfor i in range ( n ) :\n    if a [ i ] % 2 == 0 :\n        if a [ i ] % 3 == 0 or a [ i ] % 5 == 0 :\n            continue\n        else :\n            ans = \"DENIED\"\n            break\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = \" APPROVED \" NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT if a [ i ] % 3 == 0 or a [ i ] % 5 == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT ans = \" DENIED \" NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_4095_A", "sol": 0, "python_code": "def findIndex ( str ) :\n    l = len ( str )\n    open = [ 0 ] * ( l + 1 )\n    close = [ 0 ] * ( l + 1 )\n    index = - 1\n    open [ 0 ] = 0\n    close [ l ] = 0\n    if ( str [ 0 ] == '(' ) :\n        open [ 1 ] = 1\n    if ( str [ l - 1 ] == ')' ) :\n        close [ l - 1 ] = 1\n    for i in range ( 1 , l ) :\n        if ( str [ i ] == '(' ) :\n            open [ i + 1 ] = open [ i ] + 1\n        else :\n            open [ i + 1 ] = open [ i ]\n    for i in range ( l - 2 , - 1 , - 1 ) :\n        if ( str [ i ] == ')' ) :\n            close [ i ] = close [ i + 1 ] + 1\n        else :\n            close [ i ] = close [ i + 1 ]\n    if ( open [ l ] == 0 ) :\n        return len\n    if ( close [ 0 ] == 0 ) :\n        return 0\n    for i in range ( l + 1 ) :\n        if ( open [ i ] == close [ i ] ) :\n            index = i\n    return index\nstr = \"(()))(()()())))\"\nprint ( findIndex ( str ) )\n", "python_code_tokenized": "def findIndex ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE open = [ 0 ] * ( l + 1 ) NEW_LINE close = [ 0 ] * ( l + 1 ) NEW_LINE index = - 1 NEW_LINE open [ 0 ] = 0 NEW_LINE close [ l ] = 0 NEW_LINE if ( str [ 0 ] == ' ( ' ) : NEW_LINE INDENT open [ 1 ] = 1 NEW_LINE DEDENT if ( str [ l - 1 ] == ' ) ' ) : NEW_LINE INDENT close [ l - 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , l ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT open [ i + 1 ] = open [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT open [ i + 1 ] = open [ i ] NEW_LINE DEDENT DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == ' ) ' ) : NEW_LINE INDENT close [ i ] = close [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT close [ i ] = close [ i + 1 ] NEW_LINE DEDENT DEDENT if ( open [ l ] == 0 ) : NEW_LINE INDENT return len NEW_LINE DEDENT if ( close [ 0 ] == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( l + 1 ) : NEW_LINE INDENT if ( open [ i ] == close [ i ] ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT str = \" ( ( ) ) ) ( ( ) ( ) ( ) ) ) ) \" NEW_LINE print ( findIndex ( str ) ) NEW_LINE"}
{"id": "geeksforgeeks_3809_A", "sol": 0, "python_code": "import collections\ndef findsum ( arr , N ) :\n    mp = collections.defaultdict ( int )\n    for i in range ( N ) :\n        mp [ arr [ i ] ] += 1\n    sum = 0\n    for i in mp :\n        if ( mp [ i ] % 2 != 0 ) :\n            sum += ( i * mp [ i ] )\n    return sum\narr = [ 10 , 20 , 20 , 10 , 40 , 40 , 10 ]\nN = len ( arr )\nprint ( findsum ( arr , N ) )\n", "python_code_tokenized": "import collections NEW_LINE def findsum ( arr , N ) : NEW_LINE INDENT mp = collections . defaultdict ( int ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in mp : NEW_LINE INDENT if ( mp [ i ] % 2 != 0 ) : NEW_LINE INDENT sum += ( i * mp [ i ] ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 10 , 20 , 20 , 10 , 40 , 40 , 10 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findsum ( arr , N ) ) NEW_LINE"}
{"id": "geeksforgeeks_769_A", "sol": 0, "python_code": "def findSum ( arr , N ) :\n    mp = dict ( )\n    for i in range ( N ) :\n        mp [ arr [ i ] ] = mp.get ( arr [ i ] , 0 ) + 1\n    maxFreq = 0\n    for itr in mp :\n        if ( mp [ itr ] > maxFreq ) :\n            maxFreq = mp [ itr ]\n    Sum = 0\n    for itr in mp :\n        if ( mp [ itr ] == maxFreq ) :\n            Sum += itr * mp [ itr ]\n    return Sum\narr = [ 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 ]\nN = len ( arr )\nprint ( findSum ( arr , N ) )\n", "python_code_tokenized": "def findSum ( arr , N ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT maxFreq = 0 NEW_LINE for itr in mp : NEW_LINE INDENT if ( mp [ itr ] > maxFreq ) : NEW_LINE INDENT maxFreq = mp [ itr ] NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE for itr in mp : NEW_LINE INDENT if ( mp [ itr ] == maxFreq ) : NEW_LINE INDENT Sum += itr * mp [ itr ] NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findSum ( arr , N ) ) NEW_LINE"}
{"id": "geeksforgeeks_2189_A", "sol": 0, "python_code": "from math import log2 ;\ndef invertBits ( num ) :\n    x = log2 ( num ) + 1 ;\n    for i in range ( int ( x ) ) :\n        num = ( num ^ ( 1 << i ) ) ;\n    return num ;\ndef totalPairs ( arr1 , arr2 , n , m ) :\n    s1 , s2 = set ( ) , set ( ) ;\n    for i in range ( m ) :\n        s2.add ( arr2 [ i ] ) ;\n    count = 0 ;\n    for i in range ( n ) :\n        if arr1 [ i ] not in s1 :\n            if invertBits ( arr1 [ i ] ) in s2 :\n                count += 1 ;\n                s1.add ( arr1 [ i ] ) ;\n    return count ;\nif __name__ == \"__main__\" :\n    arr1 = [ 43 , 7 , 1 , 99 ] ;\n    arr2 = [ 5 , 1 , 28 , 20 ] ;\n    n = len ( arr1 ) ;\n    m = len ( arr2 ) ;\n    print ( totalPairs ( arr1 , arr2 , n , m ) ) ;\n", "python_code_tokenized": "from math import log2 ; NEW_LINE def invertBits ( num ) : NEW_LINE INDENT x = log2 ( num ) + 1 ; NEW_LINE for i in range ( int ( x ) ) : NEW_LINE INDENT num = ( num ^ ( 1 << i ) ) ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT def totalPairs ( arr1 , arr2 , n , m ) : NEW_LINE INDENT s1 , s2 = set ( ) , set ( ) ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT s2 . add ( arr2 [ i ] ) ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr1 [ i ] not in s1 : NEW_LINE INDENT if invertBits ( arr1 [ i ] ) in s2 : NEW_LINE INDENT count += 1 ; NEW_LINE s1 . add ( arr1 [ i ] ) ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 43 , 7 , 1 , 99 ] ; NEW_LINE arr2 = [ 5 , 1 , 28 , 20 ] ; NEW_LINE n = len ( arr1 ) ; NEW_LINE m = len ( arr2 ) ; NEW_LINE print ( totalPairs ( arr1 , arr2 , n , m ) ) ; NEW_LINE DEDENT"}
{"id": "aizu_p01093_A", "sol": 0, "python_code": "while 1 :\n    n = int ( input ( ) )\n    if n == 0 : break\n    a = sorted ( list ( map ( int , input ( ).split ( ) ) ) )\n    print ( min ( a [ i + 1 ] - a [ i ] for i in range ( n - 1 ) ) )\n", "python_code_tokenized": "while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE print ( min ( a [ i + 1 ] - a [ i ] for i in range ( n - 1 ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4663_A", "sol": 0, "python_code": "def CountZeroBit ( n ) :\n    count = 0\n    while ( n ) :\n        if ( not ( n & 1 ) ) :\n            count += 1\n        n >>= 1\n    return count\ndef CountORandSumEqual ( N ) :\n    count = CountZeroBit ( N )\n    return ( 1 << count )\nN = 10\nprint ( CountORandSumEqual ( N ) )\n", "python_code_tokenized": "def CountZeroBit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( not ( n & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def CountORandSumEqual ( N ) : NEW_LINE INDENT count = CountZeroBit ( N ) NEW_LINE return ( 1 << count ) NEW_LINE DEDENT N = 10 NEW_LINE print ( CountORandSumEqual ( N ) ) NEW_LINE"}
{"id": "codeforces_1416_A", "sol": 0, "python_code": "maxn = 3e5 + 5\ndef solve ( arr , n ) :\n    f = [ 0 ] * ( n + 1 )\n    last = [ 0 ] * ( n + 1 )\n    ans = [ - 1 ] * ( n + 1 )\n    for i in range ( 1 , n + 1 ) :\n        x = arr [ i ]\n        f [ x ] = max ( f [ x ] , i - last [ x ] )\n        last [ x ] = i\n    for x in range ( 1 , n + 1 ) :\n        f [ x ] = max ( f [ x ] , n - last [ x ] + 1 )\n        i = f [ x ]\n        while i <= n and ans [ i ] == - 1 :\n            ans [ i ] = x\n            i += 1\n    print ( * ans [ 1 : ] )\nfor _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    arr = list ( map ( int , input ( ).split ( ) ) )\n    arr = [ 0 ] + arr\n    solve ( arr , n )\nnum_inp = lambda : int ( input ( ) )\narr_inp = lambda : list ( map ( int , input ( ).split ( ) ) )\nsp_inp = lambda : map ( int , input ( ).split ( ) )\nstr_inp = lambda : input ( )\n", "python_code_tokenized": "maxn = 3e5 + 5 NEW_LINE def solve ( arr , n ) : NEW_LINE INDENT f = [ 0 ] * ( n + 1 ) NEW_LINE last = [ 0 ] * ( n + 1 ) NEW_LINE ans = [ - 1 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE f [ x ] = max ( f [ x ] , i - last [ x ] ) NEW_LINE last [ x ] = i NEW_LINE DEDENT for x in range ( 1 , n + 1 ) : NEW_LINE INDENT f [ x ] = max ( f [ x ] , n - last [ x ] + 1 ) NEW_LINE i = f [ x ] NEW_LINE while i <= n and ans [ i ] == - 1 : NEW_LINE INDENT ans [ i ] = x NEW_LINE i += 1 NEW_LINE DEDENT DEDENT print ( * ans [ 1 : ] ) NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr = [ 0 ] + arr NEW_LINE solve ( arr , n ) NEW_LINE DEDENT num_inp = lambda : int ( input ( ) ) NEW_LINE arr_inp = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sp_inp = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE str_inp = lambda : input ( ) NEW_LINE"}
{"id": "geeksforgeeks_2018_A", "sol": 0, "python_code": "TEN = 10\ndef digitSum ( n ) :\n    sum = 0\n    while ( n > 0 ) :\n        sum += n % TEN\n        n //= TEN\n    return sum\ndef getNthTerm ( n ) :\n    sum = digitSum ( n )\n    if ( sum % TEN == 0 ) :\n        return ( n * TEN )\n    extra = TEN - ( sum % TEN )\n    return ( ( n * TEN ) + extra )\ndef firstNTerms ( n ) :\n    for i in range ( 1 , n + 1 ) :\n        print ( getNthTerm ( i ) , end = \" \" )\nn = 10\nfirstNTerms ( n )\n", "python_code_tokenized": "TEN = 10 NEW_LINE def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += n % TEN NEW_LINE n //= TEN NEW_LINE DEDENT return sum NEW_LINE DEDENT def getNthTerm ( n ) : NEW_LINE INDENT sum = digitSum ( n ) NEW_LINE if ( sum % TEN == 0 ) : NEW_LINE INDENT return ( n * TEN ) NEW_LINE DEDENT extra = TEN - ( sum % TEN ) NEW_LINE return ( ( n * TEN ) + extra ) NEW_LINE DEDENT def firstNTerms ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( getNthTerm ( i ) , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE firstNTerms ( n ) NEW_LINE"}
{"id": "codeforces_522_A", "sol": 0, "python_code": "import sys\nrd = sys.stdin.readline\nn = int ( rd ( ) )\npopdic = { }\nfor _ in range ( n ) :\n    name1 , temp , name2 = rd ( ).strip ( ).split ( )\n    name1 = name1.lower ( )\n    name2 = name2.lower ( )\n    if popdic.get ( name2 ) :\n        popdic [ name1 ] = popdic [ name2 ] + 1\n    else :\n        popdic [ name2 ] = 1\n        popdic [ name1 ] = 2\nprint ( max ( popdic.values ( ) ) )\n", "python_code_tokenized": "import sys NEW_LINE rd = sys . stdin . readline NEW_LINE n = int ( rd ( ) ) NEW_LINE popdic = { } NEW_LINE for _ in range ( n ) : NEW_LINE INDENT name1 , temp , name2 = rd ( ) . strip ( ) . split ( ) NEW_LINE name1 = name1 . lower ( ) NEW_LINE name2 = name2 . lower ( ) NEW_LINE if popdic . get ( name2 ) : NEW_LINE INDENT popdic [ name1 ] = popdic [ name2 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT popdic [ name2 ] = 1 NEW_LINE popdic [ name1 ] = 2 NEW_LINE DEDENT DEDENT print ( max ( popdic . values ( ) ) ) NEW_LINE"}
{"id": "leetcode_215_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def findKthLargest ( self , nums , k ) :\n        random.shuffle ( nums )\n        return self.quickSelection ( nums , 0 , len ( nums ) - 1 , len ( nums ) - k )\n    def quickSelection ( self , nums , start , end , k ) :\n        if start > end :\n            return float ( 'inf' )\n        pivot = nums [ end ]\n        left = start\n        for i in range ( start , end ) :\n            if nums [ i ] <= pivot :\n                nums [ left ] , nums [ i ] = nums [ i ] , nums [ left ]\n                left += 1\n        nums [ left ] , nums [ end ] = nums [ end ] , nums [ left ]\n        if left == k :\n            return nums [ left ]\n        elif left < k :\n            return self.quickSelection ( nums , left + 1 , end , k )\n        else :\n            return self.quickSelection ( nums , start , left - 1 , k )\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def findKthLargest ( self , nums , k ) : NEW_LINE INDENT random . shuffle ( nums ) NEW_LINE return self . quickSelection ( nums , 0 , len ( nums ) - 1 , len ( nums ) - k ) NEW_LINE DEDENT def quickSelection ( self , nums , start , end , k ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT pivot = nums [ end ] NEW_LINE left = start NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT if nums [ i ] <= pivot : NEW_LINE INDENT nums [ left ] , nums [ i ] = nums [ i ] , nums [ left ] NEW_LINE left += 1 NEW_LINE DEDENT DEDENT nums [ left ] , nums [ end ] = nums [ end ] , nums [ left ] NEW_LINE if left == k : NEW_LINE INDENT return nums [ left ] NEW_LINE DEDENT elif left < k : NEW_LINE INDENT return self . quickSelection ( nums , left + 1 , end , k ) NEW_LINE DEDENT else : NEW_LINE INDENT return self . quickSelection ( nums , start , left - 1 , k ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "aizu_p00622_A", "sol": 0, "python_code": "while True :\n    in1 = list ( input ( ) )\n    if in1 [ 0 ] == '-' : break\n    in2 = list ( input ( ) )\n    out = list ( input ( ) )\n    k = in2.pop ( 0 )\n    ans , f = '' , True\n    while len ( in1 ) or len ( in2 ) :\n        if len ( out ) and out [ 0 ] == k :\n            k = in1.pop ( 0 )\n            del out [ 0 ]\n        else :\n            ans += k\n            if len ( in2 ) : k = in2.pop ( 0 )\n            else :\n                f = False\n                break\n    if f : ans += k\n    print ( ans )\n", "python_code_tokenized": "while True : NEW_LINE INDENT in1 = list ( input ( ) ) NEW_LINE if in1 [ 0 ] == ' - ' : break NEW_LINE in2 = list ( input ( ) ) NEW_LINE out = list ( input ( ) ) NEW_LINE k = in2 . pop ( 0 ) NEW_LINE ans , f = ' ' , True NEW_LINE while len ( in1 ) or len ( in2 ) : NEW_LINE INDENT if len ( out ) and out [ 0 ] == k : NEW_LINE INDENT k = in1 . pop ( 0 ) NEW_LINE del out [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += k NEW_LINE if len ( in2 ) : k = in2 . pop ( 0 ) NEW_LINE else : NEW_LINE INDENT f = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if f : ans += k NEW_LINE print ( ans ) NEW_LINE DEDENT"}
{"id": "codeforces_352_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = [ int ( x ) for x in input ( ).split ( ) ]\ncnt5 = 0\ncnt0 = 0\nfor i in range ( n ) :\n    if a [ i ] == 5 :\n        cnt5 += 1\n    if a [ i ] == 0 :\n        cnt0 += 1\nif cnt0 > 0 and cnt5 < 9 :\n    print ( '0' )\nelif cnt0 == 0 :\n    print ( '-1' )\nelse :\n    for i in range ( cnt5 // 9 ) :\n        print ( '555555555' , end = \"\" )\n    for i in range ( cnt0 ) :\n        print ( '0' , end = \"\" )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE cnt5 = 0 NEW_LINE cnt0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 5 : NEW_LINE INDENT cnt5 += 1 NEW_LINE DEDENT if a [ i ] == 0 : NEW_LINE INDENT cnt0 += 1 NEW_LINE DEDENT DEDENT if cnt0 > 0 and cnt5 < 9 : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT elif cnt0 == 0 : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( cnt5 // 9 ) : NEW_LINE INDENT print ( '555555555' , end = \" \" ) NEW_LINE DEDENT for i in range ( cnt0 ) : NEW_LINE INDENT print ( '0' , end = \" \" ) NEW_LINE DEDENT DEDENT"}
{"id": "projecteuler_p031_A", "sol": 0, "python_code": "def compute ( ) :\n    TOTAL = 200\n    ways = [ 1 ] + [ 0 ] * TOTAL\n    for coin in [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] :\n        for i in range ( len ( ways ) - coin ) :\n            ways [ i + coin ] += ways [ i ]\n    return str ( ways [ - 1 ] )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT TOTAL = 200 NEW_LINE ways = [ 1 ] + [ 0 ] * TOTAL NEW_LINE for coin in [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] : NEW_LINE INDENT for i in range ( len ( ways ) - coin ) : NEW_LINE INDENT ways [ i + coin ] += ways [ i ] NEW_LINE DEDENT DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2576_A", "sol": 0, "python_code": "def makePalindrome ( n , odd ) :\n    res = n ;\n    if ( odd ) :\n        n = int ( n / 10 ) ;\n    while ( n > 0 ) :\n        res = 10 * res + n % 10 ;\n        n = int ( n / 10 ) ;\n    return res ;\ndef isPalindrome ( n , base ) :\n    reversed = 0 ;\n    temp = n ;\n    while ( temp > 0 ) :\n        reversed = reversed * base + temp % base ;\n        temp = int ( temp / base ) ;\n    return reversed == n ;\ndef sumPalindrome ( n , k ) :\n    sum = 0 ;\n    i = 1 ;\n    p = makePalindrome ( i , True ) ;\n    while ( p < n ) :\n        if ( isPalindrome ( p , k ) ) :\n            sum += p ;\n        i += 1 ;\n        p = makePalindrome ( i , True ) ;\n    i = 1 ;\n    p = makePalindrome ( i , False ) ;\n    while ( p < n ) :\n        if ( isPalindrome ( p , k ) ) :\n            sum += p ;\n        i += 1 ;\n        p = makePalindrome ( i , False ) ;\n    print ( \"Total sum is\" , sum ) ;\nn = 1000000 ;\nk = 2 ;\nsumPalindrome ( n , k ) ;\n", "python_code_tokenized": "def makePalindrome ( n , odd ) : NEW_LINE INDENT res = n ; NEW_LINE if ( odd ) : NEW_LINE INDENT n = int ( n / 10 ) ; NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT res = 10 * res + n % 10 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def isPalindrome ( n , base ) : NEW_LINE INDENT reversed = 0 ; NEW_LINE temp = n ; NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT reversed = reversed * base + temp % base ; NEW_LINE temp = int ( temp / base ) ; NEW_LINE DEDENT return reversed == n ; NEW_LINE DEDENT def sumPalindrome ( n , k ) : NEW_LINE INDENT sum = 0 ; NEW_LINE i = 1 ; NEW_LINE p = makePalindrome ( i , True ) ; NEW_LINE while ( p < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p ; NEW_LINE DEDENT i += 1 ; NEW_LINE p = makePalindrome ( i , True ) ; NEW_LINE DEDENT i = 1 ; NEW_LINE p = makePalindrome ( i , False ) ; NEW_LINE while ( p < n ) : NEW_LINE INDENT if ( isPalindrome ( p , k ) ) : NEW_LINE INDENT sum += p ; NEW_LINE DEDENT i += 1 ; NEW_LINE p = makePalindrome ( i , False ) ; NEW_LINE DEDENT print ( \" Total \u2581 sum \u2581 is \" , sum ) ; NEW_LINE DEDENT n = 1000000 ; NEW_LINE k = 2 ; NEW_LINE sumPalindrome ( n , k ) ; NEW_LINE"}
{"id": "geeksforgeeks_122_A", "sol": 0, "python_code": "N = 1000001\nc = 0\nn = 0\nm = 0\na = 0\nb = 0\ndef dfs ( a , b , v , vis ) :\n    global c\n    vis [ a ] = 1\n    c += 1\n    for i in v [ a ] :\n        if ( vis [ i ] == 0 and i != b ) :\n            dfs ( i , b , v , vis )\ndef Calculate ( v ) :\n    global c\n    vis = [ 0 for i in range ( n + 1 ) ]\n    c = 0\n    dfs ( a , b , v , vis )\n    ans1 = n - c - 1\n    vis = [ 0 for i in range ( len ( vis ) ) ]\n    c = 0\n    dfs ( b , a , v , vis )\n    ans2 = n - c - 1\n    print ( ans1 * ans2 )\nif __name__ == '__main__' :\n    n = 7\n    m = 7\n    a = 3\n    b = 5\n    edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 4 ] , [ 4 , 5 ] , [ 5 , 6 ] , [ 6 , 7 ] , [ 7 , 5 ] ]\n    v = [ [ ] for i in range ( n + 1 ) ]\n    for i in range ( m ) :\n        v [ edges [ i ] [ 0 ] ].append ( edges [ i ] [ 1 ] )\n        v [ edges [ i ] [ 1 ] ].append ( edges [ i ] [ 0 ] )\n    Calculate ( v )\n", "python_code_tokenized": "N = 1000001 NEW_LINE c = 0 NEW_LINE n = 0 NEW_LINE m = 0 NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE def dfs ( a , b , v , vis ) : NEW_LINE INDENT global c NEW_LINE vis [ a ] = 1 NEW_LINE c += 1 NEW_LINE for i in v [ a ] : NEW_LINE INDENT if ( vis [ i ] == 0 and i != b ) : NEW_LINE INDENT dfs ( i , b , v , vis ) NEW_LINE DEDENT DEDENT DEDENT def Calculate ( v ) : NEW_LINE INDENT global c NEW_LINE vis = [ 0 for i in range ( n + 1 ) ] NEW_LINE c = 0 NEW_LINE dfs ( a , b , v , vis ) NEW_LINE ans1 = n - c - 1 NEW_LINE vis = [ 0 for i in range ( len ( vis ) ) ] NEW_LINE c = 0 NEW_LINE dfs ( b , a , v , vis ) NEW_LINE ans2 = n - c - 1 NEW_LINE print ( ans1 * ans2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE m = 7 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 4 ] , [ 4 , 5 ] , [ 5 , 6 ] , [ 6 , 7 ] , [ 7 , 5 ] ] NEW_LINE v = [ [ ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT v [ edges [ i ] [ 0 ] ] . append ( edges [ i ] [ 1 ] ) NEW_LINE v [ edges [ i ] [ 1 ] ] . append ( edges [ i ] [ 0 ] ) NEW_LINE DEDENT Calculate ( v ) NEW_LINE DEDENT"}
{"id": "leetcode_547_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def findCircleNum ( self , M ) :\n        visited = [ 0 ] * len ( M )\n        count = 0\n        for i in range ( len ( M ) ) :\n            if visited [ i ] == 0 :\n                self.dfs ( M , visited , i )\n                count += 1\n        return count\n    def dfs ( self , M , visited , i ) :\n        for j in range ( len ( M ) ) :\n            if M [ i ] [ j ] == 1 and visited [ j ] == 0 :\n                visited [ j ] = 1\n                self.dfs ( M , visited , j )\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def findCircleNum ( self , M ) : NEW_LINE INDENT visited = [ 0 ] * len ( M ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( M ) ) : NEW_LINE INDENT if visited [ i ] == 0 : NEW_LINE INDENT self . dfs ( M , visited , i ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def dfs ( self , M , visited , i ) : NEW_LINE INDENT for j in range ( len ( M ) ) : NEW_LINE INDENT if M [ i ] [ j ] == 1 and visited [ j ] == 0 : NEW_LINE INDENT visited [ j ] = 1 NEW_LINE self . dfs ( M , visited , j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_340_A", "sol": 0, "python_code": "def nCr ( n , r ) :\n    return ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) )\ndef fact ( n ) :\n    res = 1\n    for i in range ( 2 , n + 1 ) :\n        res = res * i\n    return res\nn = 5\nr = 3\nprint ( int ( nCr ( n , r ) ) )\n", "python_code_tokenized": "def nCr ( n , r ) : NEW_LINE INDENT return ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE r = 3 NEW_LINE print ( int ( nCr ( n , r ) ) ) NEW_LINE"}
{"id": "aizu_p00036_A", "sol": 0, "python_code": "if __name__ == '__main__' :\n    while True :\n        try :\n            A = [ ]\n            for i in range ( 8 ) :\n                tmp = list ( map ( int , input ( ) ) )\n                if tmp.count ( 1 ) > 0 :\n                    A.append ( tmp )\n            if len ( A ) == 1 :\n                print ( \"C\" )\n            elif len ( A ) == 4 :\n                print ( \"B\" )\n            else :\n                if len ( A ) == 2 :\n                    if A [ 0 ].index ( 1 ) < A [ 1 ].index ( 1 ) :\n                        print ( \"E\" )\n                    elif A [ 0 ].index ( 1 ) > A [ 1 ].index ( 1 ) :\n                        print ( \"G\" )\n                    else :\n                        print ( \"A\" )\n                elif len ( A ) == 3 :\n                    if A [ 0 ].index ( 1 ) < A [ 2 ].index ( 1 ) :\n                        print ( \"F\" )\n                    else :\n                        print ( \"D\" )\n            input ( )\n        except EOFError :\n            break\n", "python_code_tokenized": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT A = [ ] NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT tmp = list ( map ( int , input ( ) ) ) NEW_LINE if tmp . count ( 1 ) > 0 : NEW_LINE INDENT A . append ( tmp ) NEW_LINE DEDENT DEDENT if len ( A ) == 1 : NEW_LINE INDENT print ( \" C \" ) NEW_LINE DEDENT elif len ( A ) == 4 : NEW_LINE INDENT print ( \" B \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( A ) == 2 : NEW_LINE INDENT if A [ 0 ] . index ( 1 ) < A [ 1 ] . index ( 1 ) : NEW_LINE INDENT print ( \" E \" ) NEW_LINE DEDENT elif A [ 0 ] . index ( 1 ) > A [ 1 ] . index ( 1 ) : NEW_LINE INDENT print ( \" G \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" A \" ) NEW_LINE DEDENT DEDENT elif len ( A ) == 3 : NEW_LINE INDENT if A [ 0 ] . index ( 1 ) < A [ 2 ] . index ( 1 ) : NEW_LINE INDENT print ( \" F \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" D \" ) NEW_LINE DEDENT DEDENT DEDENT input ( ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "codeforces_688_B", "sol": 0, "python_code": "n = input ( )\nprint ( n + n [ - 1 : : - 1 ] )\n", "python_code_tokenized": "n = input ( ) NEW_LINE print ( n + n [ - 1 : : - 1 ] ) NEW_LINE"}
{"id": "geeksforgeeks_2814_A", "sol": 0, "python_code": "def minChanges ( str , n ) :\n    count , zeros , ones = 0 , 0 , 0\n    if ( ord ( str [ 0 ] ) != ord ( '1' ) ) :\n        count += 1\n        ones += 1\n    for i in range ( 1 , n ) :\n        if ( ord ( str [ i ] ) == ord ( '0' ) ) :\n            zeros += 1\n        else :\n            ones += 1\n        if ( zeros > ones ) :\n            zeros -= 1\n            ones += 1\n            count += 1\n    return count\nif __name__ == '__main__' :\n    str = \"0000\"\n    n = len ( str )\n    print ( minChanges ( str , n ) )\n", "python_code_tokenized": "def minChanges ( str , n ) : NEW_LINE INDENT count , zeros , ones = 0 , 0 , 0 NEW_LINE if ( ord ( str [ 0 ] ) != ord ( '1' ) ) : NEW_LINE INDENT count += 1 NEW_LINE ones += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( ord ( str [ i ] ) == ord ( '0' ) ) : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT if ( zeros > ones ) : NEW_LINE INDENT zeros -= 1 NEW_LINE ones += 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"0000\" NEW_LINE n = len ( str ) NEW_LINE print ( minChanges ( str , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_546_A", "sol": 0, "python_code": "k , n , w = map ( int , input ( ).strip ( ).split ( ) )\nsum = 0\nfor i in range ( 1 , w + 1 ) :\n    sum += k * i\nif sum <= n :\n    print ( 0 )\nelse :\n    print ( sum - n )\n", "python_code_tokenized": "k , n , w = map ( int , input ( ) . strip ( ) . split ( ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , w + 1 ) : NEW_LINE INDENT sum += k * i NEW_LINE DEDENT if sum <= n : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sum - n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3712_A", "sol": 0, "python_code": "def findExtra ( arr1 , arr2 , n ) :\n    for i in range ( 0 , n ) :\n        if ( arr1 [ i ] != arr2 [ i ] ) :\n            return i\n    return n\narr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ]\narr2 = [ 2 , 4 , 6 , 8 , 10 , 12 ]\nn = len ( arr2 )\nprint ( findExtra ( arr1 , arr2 , n ) )\n", "python_code_tokenized": "def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT arr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ] NEW_LINE arr2 = [ 2 , 4 , 6 , 8 , 10 , 12 ] NEW_LINE n = len ( arr2 ) NEW_LINE print ( findExtra ( arr1 , arr2 , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_619_A", "sol": 0, "python_code": "def countSubarray ( arr , n , k ) :\n    count = 0\n    for i in range ( 0 , n ) :\n        sum = 0 ;\n        for j in range ( i , n ) :\n            if ( sum + arr [ j ] < k ) :\n                sum = arr [ j ] + sum\n                count += 1\n            else :\n                break\n    return count ;\narray = [ 1 , 11 , 2 , 3 , 15 ]\nk = 10\nsize = len ( array )\ncount = countSubarray ( array , size , k ) ;\nprint ( count )\n", "python_code_tokenized": "def countSubarray ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( sum + arr [ j ] < k ) : NEW_LINE INDENT sum = arr [ j ] + sum NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT array = [ 1 , 11 , 2 , 3 , 15 ] NEW_LINE k = 10 NEW_LINE size = len ( array ) NEW_LINE count = countSubarray ( array , size , k ) ; NEW_LINE print ( count ) NEW_LINE"}
{"id": "geeksforgeeks_3700_A", "sol": 0, "python_code": "def polygonArea ( X , Y , n ) :\n    area = 0.0\n    j = n - 1\n    for i in range ( 0 , n ) :\n        area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] )\n        j = i\n    return int ( abs ( area / 2.0 ) )\nX = [ 0 , 2 , 4 ]\nY = [ 1 , 3 , 7 ]\nn = len ( X )\nprint ( polygonArea ( X , Y , n ) )\n", "python_code_tokenized": "def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return int ( abs ( area / 2.0 ) ) NEW_LINE DEDENT X = [ 0 , 2 , 4 ] NEW_LINE Y = [ 1 , 3 , 7 ] NEW_LINE n = len ( X ) NEW_LINE print ( polygonArea ( X , Y , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_812_A", "sol": 0, "python_code": "def polygonArea ( X , Y , n ) :\n    area = 0.0\n    j = n - 1\n    for i in range ( 0 , n ) :\n        area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] )\n        j = i\n    return abs ( area // 2.0 )\nX = [ 0 , 2 , 4 ]\nY = [ 1 , 3 , 7 ]\nn = len ( X )\nprint ( polygonArea ( X , Y , n ) )\n", "python_code_tokenized": "def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return abs ( area // 2.0 ) NEW_LINE DEDENT X = [ 0 , 2 , 4 ] NEW_LINE Y = [ 1 , 3 , 7 ] NEW_LINE n = len ( X ) NEW_LINE print ( polygonArea ( X , Y , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_795_A", "sol": 0, "python_code": "def countDigits ( n ) :\n    count = 0\n    while ( n > 0 ) :\n        count += 1\n        n //= 10\n    return count\ndef getDistinct ( d , count ) :\n    num = 0\n    count = pow ( 10 , count - 1 )\n    while ( count > 0 ) :\n        num += ( count * d )\n        count //= 10\n    return num\ndef findCount ( L , R ) :\n    count = 0\n    countDigitsL = countDigits ( L )\n    countDigitsR = countDigits ( R )\n    firstDigitL = ( L // pow ( 10 , countDigitsL - 1 ) )\n    firstDigitR = ( R // pow ( 10 , countDigitsR - 1 ) )\n    if ( countDigitsL < countDigitsR ) :\n        count += ( 9 * ( countDigitsR - countDigitsL - 1 ) )\n        if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) :\n            count += ( 9 - firstDigitL + 1 )\n        else :\n            count += ( 9 - firstDigitL )\n        if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) :\n            count += firstDigitR\n        else :\n            count += ( firstDigitR - 1 )\n    else :\n        if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) :\n            count += ( 9 - firstDigitL + 1 )\n        else :\n            count += ( 9 - firstDigitL )\n        if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) :\n            count -= ( 9 - firstDigitR )\n        else :\n            count -= ( 9 - firstDigitR + 1 )\n    return count\nL = 10\nR = 50\nprint ( findCount ( L , R ) )\n", "python_code_tokenized": "def countDigits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n //= 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def getDistinct ( d , count ) : NEW_LINE INDENT num = 0 NEW_LINE count = pow ( 10 , count - 1 ) NEW_LINE while ( count > 0 ) : NEW_LINE INDENT num += ( count * d ) NEW_LINE count //= 10 NEW_LINE DEDENT return num NEW_LINE DEDENT def findCount ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE countDigitsL = countDigits ( L ) NEW_LINE countDigitsR = countDigits ( R ) NEW_LINE firstDigitL = ( L // pow ( 10 , countDigitsL - 1 ) ) NEW_LINE firstDigitR = ( R // pow ( 10 , countDigitsR - 1 ) ) NEW_LINE if ( countDigitsL < countDigitsR ) : NEW_LINE INDENT count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) NEW_LINE if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count += firstDigitR NEW_LINE DEDENT else : NEW_LINE INDENT count += ( firstDigitR - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) : NEW_LINE INDENT count += ( 9 - firstDigitL + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT count += ( 9 - firstDigitL ) NEW_LINE DEDENT if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) : NEW_LINE INDENT count -= ( 9 - firstDigitR ) NEW_LINE DEDENT else : NEW_LINE INDENT count -= ( 9 - firstDigitR + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT L = 10 NEW_LINE R = 50 NEW_LINE print ( findCount ( L , R ) ) NEW_LINE"}
{"id": "geeksforgeeks_5203_A", "sol": 0, "python_code": "import math as mt\ndef countWays ( arr , n ) :\n    max_val = 0\n    for i in range ( n ) :\n        max_val = max ( max_val , arr [ i ] )\n    freq = [ 0 for i in range ( max_val + 1 ) ]\n    for i in range ( n ) :\n        freq [ arr [ i ] ] += 1\n    ans = 0\n    ans += ( freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) // 6 )\n    for i in range ( 1 , max_val + 1 ) :\n        ans += ( freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) // 2 )\n    for i in range ( 1 , ( max_val + 1 ) // 2 ) :\n        ans += ( freq [ i ] * ( freq [ i ] - 1 ) // 2 * freq [ 2 * i ] )\n    for i in range ( 1 , max_val + 1 ) :\n        for j in range ( i + 1 , max_val - i + 1 ) :\n            ans += freq [ i ] * freq [ j ] * freq [ i + j ]\n    return ans\narr = [ 1 , 2 , 3 , 4 , 5 ]\nn = len ( arr )\nprint ( countWays ( arr , n ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def countWays ( arr , n ) : NEW_LINE INDENT max_val = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_val = max ( max_val , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 for i in range ( max_val + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE ans += ( freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) // 6 ) NEW_LINE for i in range ( 1 , max_val + 1 ) : NEW_LINE INDENT ans += ( freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) // 2 ) NEW_LINE DEDENT for i in range ( 1 , ( max_val + 1 ) // 2 ) : NEW_LINE INDENT ans += ( freq [ i ] * ( freq [ i ] - 1 ) // 2 * freq [ 2 * i ] ) NEW_LINE DEDENT for i in range ( 1 , max_val + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , max_val - i + 1 ) : NEW_LINE INDENT ans += freq [ i ] * freq [ j ] * freq [ i + j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countWays ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4680_A", "sol": 0, "python_code": "from math import floor , log2\ndef minAbsDiff ( n ) :\n    left = pow ( 2 , floor ( log2 ( n ) ) )\n    right = left * 2\n    return min ( ( n - left ) , ( right - n ) )\nif __name__ == \"__main__\" :\n    n = 15\n    print ( minAbsDiff ( n ) )\n", "python_code_tokenized": "from math import floor , log2 NEW_LINE def minAbsDiff ( n ) : NEW_LINE INDENT left = pow ( 2 , floor ( log2 ( n ) ) ) NEW_LINE right = left * 2 NEW_LINE return min ( ( n - left ) , ( right - n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 15 NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT"}
{"id": "leetcode_400_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def findNthDigit ( self , n ) :\n        count = 9\n        start = 1\n        curr_len = 1\n        while n > curr_len * count :\n            n -= curr_len * count\n            curr_len += 1\n            count *= 10\n            start *= 10\n        start += ( n - 1 ) / curr_len\n        s = str ( start )\n        return int ( s [ ( n - 1 ) % curr_len ] )\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def findNthDigit ( self , n ) : NEW_LINE INDENT count = 9 NEW_LINE start = 1 NEW_LINE curr_len = 1 NEW_LINE while n > curr_len * count : NEW_LINE INDENT n -= curr_len * count NEW_LINE curr_len += 1 NEW_LINE count *= 10 NEW_LINE start *= 10 NEW_LINE DEDENT start += ( n - 1 ) / curr_len NEW_LINE s = str ( start ) NEW_LINE return int ( s [ ( n - 1 ) % curr_len ] ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_706_B", "sol": 0, "python_code": "import bisect\nn = int ( input ( ) )\nprices = sorted ( [ int ( x ) for x in input ( ).split ( ) ] )\nfor i in range ( int ( input ( ) ) ) :\n    print ( bisect.bisect_right ( prices , int ( input ( ) ) ) )\n", "python_code_tokenized": "import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE prices = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( bisect . bisect_right ( prices , int ( input ( ) ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4848_A", "sol": 0, "python_code": "def Circumference ( l , w ) :\n    return ( 2 * ( l + w ) )\nl = 8\nw = 4\nc = Circumference ( l , w )\nprint ( \"Circumference of a\" + \" rectangle is % d\" % ( c ) )\n", "python_code_tokenized": "def Circumference ( l , w ) : NEW_LINE INDENT return ( 2 * ( l + w ) ) NEW_LINE DEDENT l = 8 NEW_LINE w = 4 NEW_LINE c = Circumference ( l , w ) NEW_LINE print ( \" Circumference \u2581 of \u2581 a \" + \" \u2581 rectangle \u2581 is \u2581 % \u2581 d \" % ( c ) ) NEW_LINE"}
{"id": "atcoder_ABC099_D", "sol": 0, "python_code": "import collections\nINF = 10 ** 10\nN , C = map ( int , input ( ).split ( ) )\nd = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( C ) ]\nc = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( N ) ]\nlc = [ [ ] , [ ] , [ ] ]\nfor i in range ( N ) :\n    for j in range ( N ) :\n        lc [ ( i + j ) % 3 ].append ( c [ i ] [ j ] )\nclc = [ collections.Counter ( lc [ i ] ) for i in range ( 3 ) ]\ndef iwakan ( clist , color ) :\n    global C\n    ret = 0\n    for i in range ( C ) :\n        ret += clist [ i + 1 ] * d [ i ] [ color ]\n    return ret\nres = INF\nfor i in range ( C ) :\n    for j in range ( C ) :\n        for k in range ( C ) :\n            if i == j or i == k or j == k :\n                continue\n            res = min ( res , iwakan ( clc [ 0 ] , i ) + iwakan ( clc [ 1 ] , j ) + iwakan ( clc [ 2 ] , k ) )\nprint ( res )\n", "python_code_tokenized": "import collections NEW_LINE INF = 10 ** 10 NEW_LINE N , C = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( C ) ] NEW_LINE c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE lc = [ [ ] , [ ] , [ ] ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT lc [ ( i + j ) % 3 ] . append ( c [ i ] [ j ] ) NEW_LINE DEDENT DEDENT clc = [ collections . Counter ( lc [ i ] ) for i in range ( 3 ) ] NEW_LINE def iwakan ( clist , color ) : NEW_LINE INDENT global C NEW_LINE ret = 0 NEW_LINE for i in range ( C ) : NEW_LINE INDENT ret += clist [ i + 1 ] * d [ i ] [ color ] NEW_LINE DEDENT return ret NEW_LINE DEDENT res = INF NEW_LINE for i in range ( C ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT for k in range ( C ) : NEW_LINE INDENT if i == j or i == k or j == k : NEW_LINE INDENT continue NEW_LINE DEDENT res = min ( res , iwakan ( clc [ 0 ] , i ) + iwakan ( clc [ 1 ] , j ) + iwakan ( clc [ 2 ] , k ) ) NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE"}
{"id": "geeksforgeeks_4294_A", "sol": 0, "python_code": "def print_asterisk ( asterisk ) :\n    if ( asterisk == 0 ) :\n        return ;\n    print ( \"*\" , end = \" \" ) ;\n    print_asterisk ( asterisk - 1 ) ;\ndef pattern_upper ( n , num ) :\n    if ( n == 0 ) :\n        return ;\n    print_asterisk ( n ) ;\n    print ( ) ;\n    pattern_upper ( n - 1 , num ) ;\ndef pattern_lower ( n , num ) :\n    if ( n == 0 ) :\n        return ;\n    print_asterisk ( num - n + 1 ) ;\n    print ( ) ;\n    pattern_lower ( n - 1 , num ) ;\ndef pattern ( n , num ) :\n    pattern_upper ( n , num ) ;\n    pattern_lower ( n - 1 , num ) ;\nif __name__ == '__main__' :\n    n = 5 ;\n    pattern ( n , n ) ;\n", "python_code_tokenized": "def print_asterisk ( asterisk ) : NEW_LINE INDENT if ( asterisk == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" * \" , end = \" \u2581 \" ) ; NEW_LINE print_asterisk ( asterisk - 1 ) ; NEW_LINE DEDENT def pattern_upper ( n , num ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print_asterisk ( n ) ; NEW_LINE print ( ) ; NEW_LINE pattern_upper ( n - 1 , num ) ; NEW_LINE DEDENT def pattern_lower ( n , num ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print_asterisk ( num - n + 1 ) ; NEW_LINE print ( ) ; NEW_LINE pattern_lower ( n - 1 , num ) ; NEW_LINE DEDENT def pattern ( n , num ) : NEW_LINE INDENT pattern_upper ( n , num ) ; NEW_LINE pattern_lower ( n - 1 , num ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE pattern ( n , n ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4295_A", "sol": 0, "python_code": "def print_asterisk ( asterisk ) :\n    if ( asterisk == 0 ) :\n        return ;\n    print ( \"* \" , end = \"\" ) ;\n    print_asterisk ( asterisk - 1 ) ;\ndef print_space ( space ) :\n    if ( space == 0 ) :\n        return ;\n    print ( \"\" , end = \"\" ) ;\n    print ( \"\" , end = \"\" ) ;\n    print_space ( space - 1 ) ;\ndef pattern_upper ( n , num ) :\n    if ( n == 0 ) :\n        return ;\n    print_asterisk ( n ) ;\n    print_space ( 2 * ( num - n ) + 1 ) ;\n    print_asterisk ( n ) ;\n    print ( ) ;\n    pattern_upper ( n - 1 , num ) ;\ndef pattern_lower ( n , num ) :\n    if ( n == 0 ) :\n        return ;\n    print_asterisk ( num - n + 1 ) ;\n    print_space ( 2 * n - 1 ) ;\n    print_asterisk ( num - n + 1 ) ;\n    print ( ) ;\n    pattern_lower ( n - 1 , num ) ;\ndef pattern ( n , num ) :\n    pattern_upper ( n , num ) ;\n    pattern_lower ( n - 1 , num ) ;\nif __name__ == '__main__' :\n    n = 5 ;\n    pattern ( n , n ) ;\n", "python_code_tokenized": "def print_asterisk ( asterisk ) : NEW_LINE INDENT if ( asterisk == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" * \u2581 \" , end = \" \" ) ; NEW_LINE print_asterisk ( asterisk - 1 ) ; NEW_LINE DEDENT def print_space ( space ) : NEW_LINE INDENT if ( space == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" \u2581 \" , end = \" \" ) ; NEW_LINE print ( \" \u2581 \" , end = \" \" ) ; NEW_LINE print_space ( space - 1 ) ; NEW_LINE DEDENT def pattern_upper ( n , num ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print_asterisk ( n ) ; NEW_LINE print_space ( 2 * ( num - n ) + 1 ) ; NEW_LINE print_asterisk ( n ) ; NEW_LINE print ( ) ; NEW_LINE pattern_upper ( n - 1 , num ) ; NEW_LINE DEDENT def pattern_lower ( n , num ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print_asterisk ( num - n + 1 ) ; NEW_LINE print_space ( 2 * n - 1 ) ; NEW_LINE print_asterisk ( num - n + 1 ) ; NEW_LINE print ( ) ; NEW_LINE pattern_lower ( n - 1 , num ) ; NEW_LINE DEDENT def pattern ( n , num ) : NEW_LINE INDENT pattern_upper ( n , num ) ; NEW_LINE pattern_lower ( n - 1 , num ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE pattern ( n , n ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4296_A", "sol": 0, "python_code": "def print_asterisk ( asterisk ) :\n    if ( asterisk == 0 ) :\n        return ;\n    print ( \"* \" , end = \"\" ) ;\n    print_asterisk ( asterisk - 1 ) ;\ndef print_space ( space ) :\n    if ( space == 0 ) :\n        return ;\n    print ( \"\" , end = \"\" ) ;\n    print ( \"\" , end = \"\" ) ;\n    print_space ( space - 1 ) ;\ndef pattern_upper ( n , num ) :\n    if ( n == 0 ) :\n        return ;\n    print_asterisk ( num - n + 1 ) ;\n    print_space ( 2 * n - 1 ) ;\n    print_asterisk ( num - n + 1 ) ;\n    print ( ) ;\n    pattern_upper ( n - 1 , num ) ;\ndef pattern_lower ( n , num ) :\n    if ( n == 0 ) :\n        return ;\n    print_asterisk ( n ) ;\n    print_space ( 2 * ( num - n ) + 1 ) ;\n    print_asterisk ( n ) ;\n    print ( ) ;\n    pattern_lower ( n - 1 , num ) ;\ndef pattern ( n , num ) :\n    pattern_upper ( n , num ) ;\n    pattern_lower ( n - 1 , num ) ;\nif __name__ == '__main__' :\n    n = 5 ;\n    pattern ( n , n ) ;\n", "python_code_tokenized": "def print_asterisk ( asterisk ) : NEW_LINE INDENT if ( asterisk == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" * \u2581 \" , end = \" \" ) ; NEW_LINE print_asterisk ( asterisk - 1 ) ; NEW_LINE DEDENT def print_space ( space ) : NEW_LINE INDENT if ( space == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( \" \u2581 \" , end = \" \" ) ; NEW_LINE print ( \" \u2581 \" , end = \" \" ) ; NEW_LINE print_space ( space - 1 ) ; NEW_LINE DEDENT def pattern_upper ( n , num ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print_asterisk ( num - n + 1 ) ; NEW_LINE print_space ( 2 * n - 1 ) ; NEW_LINE print_asterisk ( num - n + 1 ) ; NEW_LINE print ( ) ; NEW_LINE pattern_upper ( n - 1 , num ) ; NEW_LINE DEDENT def pattern_lower ( n , num ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print_asterisk ( n ) ; NEW_LINE print_space ( 2 * ( num - n ) + 1 ) ; NEW_LINE print_asterisk ( n ) ; NEW_LINE print ( ) ; NEW_LINE pattern_lower ( n - 1 , num ) ; NEW_LINE DEDENT def pattern ( n , num ) : NEW_LINE INDENT pattern_upper ( n , num ) ; NEW_LINE pattern_lower ( n - 1 , num ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE pattern ( n , n ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_60_A", "sol": 0, "python_code": "import sys\nINT_MAX = sys.maxsize ;\nINT_MIN = - ( sys.maxsize - 1 )\ndef minimumAdjacentDifference ( a , n , k ) :\n    minDiff = INT_MAX ;\n    for i in range ( 1 << n ) :\n        cnt = bin ( i ).count ( '1' ) ;\n        if ( cnt == n - k ) :\n            temp = [ ] ;\n            for j in range ( n ) :\n                if ( ( i & ( 1 << j ) ) != 0 ) :\n                    temp.append ( a [ j ] ) ;\n            maxDiff = INT_MIN ;\n            for j in range ( len ( temp ) - 1 ) :\n                maxDiff = max ( maxDiff , temp [ j + 1 ] - temp [ j ] ) ;\n            minDiff = min ( minDiff , maxDiff ) ;\n    return minDiff ;\nif __name__ == \"__main__\" :\n    n = 5 ;\n    k = 2 ;\n    a = [ 3 , 7 , 8 , 10 , 14 ] ;\n    print ( minimumAdjacentDifference ( a , n , k ) ) ;\n", "python_code_tokenized": "import sys NEW_LINE INT_MAX = sys . maxsize ; NEW_LINE INT_MIN = - ( sys . maxsize - 1 ) NEW_LINE def minimumAdjacentDifference ( a , n , k ) : NEW_LINE INDENT minDiff = INT_MAX ; NEW_LINE for i in range ( 1 << n ) : NEW_LINE INDENT cnt = bin ( i ) . count ( '1' ) ; NEW_LINE if ( cnt == n - k ) : NEW_LINE INDENT temp = [ ] ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( i & ( 1 << j ) ) != 0 ) : NEW_LINE INDENT temp . append ( a [ j ] ) ; NEW_LINE DEDENT DEDENT maxDiff = INT_MIN ; NEW_LINE for j in range ( len ( temp ) - 1 ) : NEW_LINE INDENT maxDiff = max ( maxDiff , temp [ j + 1 ] - temp [ j ] ) ; NEW_LINE DEDENT minDiff = min ( minDiff , maxDiff ) ; NEW_LINE DEDENT DEDENT return minDiff ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE k = 2 ; NEW_LINE a = [ 3 , 7 , 8 , 10 , 14 ] ; NEW_LINE print ( minimumAdjacentDifference ( a , n , k ) ) ; NEW_LINE DEDENT"}
{"id": "leetcode_876_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def middleNode ( self , head ) :\n        fast = slow = head\n        while fast and fast.next :\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def middleNode ( self , head ) : NEW_LINE INDENT fast = slow = head NEW_LINE while fast and fast . next : NEW_LINE INDENT slow = slow . next NEW_LINE fast = fast . next . next NEW_LINE DEDENT return slow NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_586_B", "sol": 0, "python_code": "n = int ( input ( ) )\nhor1 = [ int ( read ) for read in input ( ).split ( ) ]\nhor2 = [ int ( read ) for read in input ( ).split ( ) ]\nvert = [ int ( read ) for read in input ( ).split ( ) ]\npref1 = [ 0 ] * ( n )\npref2 = [ 0 ] * ( n )\nfor i in range ( 1 , n ) :\n    pref1 [ i ] = pref1 [ i - 1 ] + hor1 [ i - 1 ]\n    pref2 [ i ] = pref2 [ i - 1 ] + hor2 [ i - 1 ]\nmini = 10 ** 9\nprev = 10 ** 9\nans = set ( )\nfor i in range ( n ) :\n    x = pref1 [ i ] + ( pref2 [ n - 1 ] - pref2 [ i ] ) + vert [ i ]\n    if x <= mini :\n        prev = mini\n        mini = x\n    elif x < prev :\n        prev = x\nprint ( mini + prev )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE hor1 = [ int ( read ) for read in input ( ) . split ( ) ] NEW_LINE hor2 = [ int ( read ) for read in input ( ) . split ( ) ] NEW_LINE vert = [ int ( read ) for read in input ( ) . split ( ) ] NEW_LINE pref1 = [ 0 ] * ( n ) NEW_LINE pref2 = [ 0 ] * ( n ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pref1 [ i ] = pref1 [ i - 1 ] + hor1 [ i - 1 ] NEW_LINE pref2 [ i ] = pref2 [ i - 1 ] + hor2 [ i - 1 ] NEW_LINE DEDENT mini = 10 ** 9 NEW_LINE prev = 10 ** 9 NEW_LINE ans = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = pref1 [ i ] + ( pref2 [ n - 1 ] - pref2 [ i ] ) + vert [ i ] NEW_LINE if x <= mini : NEW_LINE INDENT prev = mini NEW_LINE mini = x NEW_LINE DEDENT elif x < prev : NEW_LINE INDENT prev = x NEW_LINE DEDENT DEDENT print ( mini + prev ) NEW_LINE"}
{"id": "codeforces_1140_B", "sol": 0, "python_code": "from collections import deque\nfrom math import *\nimport sys\nimport random\nfrom bisect import *\nfrom functools import reduce\nfrom sys import stdin\nimport copy\nfor _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    s = input ( )\n    ans = 0\n    left , right = 0 , 0\n    i = 0\n    while i < n and s [ i ] != '>' :\n        i += 1\n    j = n - 1\n    while j >= 0 and s [ j ] != '<' :\n        j -= 1\n    print ( min ( i , n - j - 1 ) )\n", "python_code_tokenized": "from collections import deque NEW_LINE from math import * NEW_LINE import sys NEW_LINE import random NEW_LINE from bisect import * NEW_LINE from functools import reduce NEW_LINE from sys import stdin NEW_LINE import copy NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE left , right = 0 , 0 NEW_LINE i = 0 NEW_LINE while i < n and s [ i ] != ' > ' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT j = n - 1 NEW_LINE while j >= 0 and s [ j ] != ' < ' : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT print ( min ( i , n - j - 1 ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02389_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\nprint ( a * b , ( a + b ) * 2 )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a * b , ( a + b ) * 2 ) NEW_LINE"}
{"id": "geeksforgeeks_4165_A", "sol": 0, "python_code": "from queue import PriorityQueue\nMAX_CHAR = 26\ndef minStringValue ( str , k ) :\n    l = len ( str )\n    if ( k >= l ) :\n        return 0\n    frequency = [ 0 ] * MAX_CHAR\n    for i in range ( 0 , l ) :\n        frequency [ ord ( str [ i ] ) - 97 ] += 1\n    q = PriorityQueue ( )\n    for i in range ( 0 , MAX_CHAR ) :\n        q.put ( - frequency [ i ] )\n    while ( k > 0 ) :\n        temp = q.get ( )\n        temp = temp + 1\n        q.put ( temp , temp )\n        k = k - 1\n    result = 0 ;\n    while not q.empty ( ) :\n        temp = q.get ( )\n        temp = temp * ( - 1 )\n        result += temp * temp\n    return result\nif __name__ == \"__main__\" :\n    str = \"abbccc\"\n    k = 2\n    print ( minStringValue ( str , k ) )\n    str = \"aaab\"\n    k = 2\n    print ( minStringValue ( str , k ) )\n", "python_code_tokenized": "from queue import PriorityQueue NEW_LINE MAX_CHAR = 26 NEW_LINE def minStringValue ( str , k ) : NEW_LINE INDENT l = len ( str ) NEW_LINE if ( k >= l ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT frequency = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT frequency [ ord ( str [ i ] ) - 97 ] += 1 NEW_LINE DEDENT q = PriorityQueue ( ) NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT q . put ( - frequency [ i ] ) NEW_LINE DEDENT while ( k > 0 ) : NEW_LINE INDENT temp = q . get ( ) NEW_LINE temp = temp + 1 NEW_LINE q . put ( temp , temp ) NEW_LINE k = k - 1 NEW_LINE DEDENT result = 0 ; NEW_LINE while not q . empty ( ) : NEW_LINE INDENT temp = q . get ( ) NEW_LINE temp = temp * ( - 1 ) NEW_LINE result += temp * temp NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" abbccc \" NEW_LINE k = 2 NEW_LINE print ( minStringValue ( str , k ) ) NEW_LINE str = \" aaab \" NEW_LINE k = 2 NEW_LINE print ( minStringValue ( str , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2695_A", "sol": 0, "python_code": "import math\ndef evenDecimalValue ( str , n ) :\n    result = 0\n    for i in range ( 0 , n ) :\n        for j in range ( i , n ) :\n            decimalValue = 0 ;\n            powerOf2 = 1 ;\n            for k in range ( i , j + 1 ) :\n                decimalValue += ( ( int ( str [ k ] ) - 0 ) * powerOf2 )\n                powerOf2 *= 2\n            if ( decimalValue % 2 == 0 ) :\n                result += 1\n    return result\nstr = \"10010\"\nn = 5\nprint ( evenDecimalValue ( str , n ) )\n", "python_code_tokenized": "import math NEW_LINE def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimalValue = 0 ; NEW_LINE powerOf2 = 1 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimalValue += ( ( int ( str [ k ] ) - 0 ) * powerOf2 ) NEW_LINE powerOf2 *= 2 NEW_LINE DEDENT if ( decimalValue % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT str = \"10010\" NEW_LINE n = 5 NEW_LINE print ( evenDecimalValue ( str , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3727_A", "sol": 0, "python_code": "def getOddOccurrence ( arr , size ) :\n    Hash = dict ( )\n    for i in range ( size ) :\n        Hash [ arr [ i ] ] = Hash.get ( arr [ i ] , 0 ) + 1 ;\n    for i in Hash :\n        if ( Hash [ i ] % 2 != 0 ) :\n            return i\n    return - 1\narr = [ 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 ]\nn = len ( arr )\nprint ( getOddOccurrence ( arr , n ) )\n", "python_code_tokenized": "def getOddOccurrence ( arr , size ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 ; NEW_LINE DEDENT for i in Hash : NEW_LINE INDENT if ( Hash [ i ] % 2 != 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getOddOccurrence ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_560_B", "sol": 0, "python_code": "import collections\nimport heapq\nimport sys\nimport math\nimport itertools\nimport bisect\nfrom io import BytesIO , IOBase\nimport os\ndef values ( ) : return tuple ( map ( int , sys.stdin.readline ( ).split ( ) ) )\ndef inlst ( ) : return [ int ( i ) for i in sys.stdin.readline ( ).split ( ) ]\ndef inp ( ) : return int ( sys.stdin.readline ( ) )\ndef inpstr ( ) : return sys.stdin.readline ( ).strip ( )\ndef words ( ) : return [ i for i in sys.stdin.readline ( ).split ( ) ]\ndef chars ( ) : return list ( sys.stdin.readline ( ).strip ( ) )\ndef solve ( ) :\n    a1 , b1 = sorted ( values ( ) )\n    a2 , b2 = sorted ( values ( ) )\n    a3 , b3 = sorted ( values ( ) )\n    if a1 >= a2 + a3 and b1 >= max ( b2 , b3 ) : print ( \"YES\" ) ; return\n    if b1 >= a2 + a3 and a1 >= max ( b2 , b3 ) : print ( \"YES\" ) ; return\n    if b1 >= b2 + b3 and a1 >= max ( a2 , a3 ) : print ( \"YES\" ) ; return\n    if a1 >= b2 + b3 and b1 >= max ( a2 , a3 ) : print ( \"YES\" ) ; return\n    if b1 >= b2 + a3 and a1 >= max ( a2 , b3 ) : print ( \"YES\" ) ; return\n    if a1 >= b2 + a3 and b1 >= max ( a2 , b3 ) : print ( \"YES\" ) ; return\n    if b1 >= a2 + b3 and a1 >= max ( b2 , a3 ) : print ( \"YES\" ) ; return\n    if a1 >= a2 + b3 and b1 >= max ( b2 , a3 ) : print ( \"YES\" ) ; return\n    print ( \"NO\" )\nif __name__ == \"__main__\" :\n    solve ( )\n", "python_code_tokenized": "import collections NEW_LINE import heapq NEW_LINE import sys NEW_LINE import math NEW_LINE import itertools NEW_LINE import bisect NEW_LINE from io import BytesIO , IOBase NEW_LINE import os NEW_LINE def values ( ) : return tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def inlst ( ) : return [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def inp ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def inpstr ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def words ( ) : return [ i for i in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def chars ( ) : return list ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE def solve ( ) : NEW_LINE INDENT a1 , b1 = sorted ( values ( ) ) NEW_LINE a2 , b2 = sorted ( values ( ) ) NEW_LINE a3 , b3 = sorted ( values ( ) ) NEW_LINE if a1 >= a2 + a3 and b1 >= max ( b2 , b3 ) : print ( \" YES \" ) ; return NEW_LINE if b1 >= a2 + a3 and a1 >= max ( b2 , b3 ) : print ( \" YES \" ) ; return NEW_LINE if b1 >= b2 + b3 and a1 >= max ( a2 , a3 ) : print ( \" YES \" ) ; return NEW_LINE if a1 >= b2 + b3 and b1 >= max ( a2 , a3 ) : print ( \" YES \" ) ; return NEW_LINE if b1 >= b2 + a3 and a1 >= max ( a2 , b3 ) : print ( \" YES \" ) ; return NEW_LINE if a1 >= b2 + a3 and b1 >= max ( a2 , b3 ) : print ( \" YES \" ) ; return NEW_LINE if b1 >= a2 + b3 and a1 >= max ( b2 , a3 ) : print ( \" YES \" ) ; return NEW_LINE if a1 >= a2 + b3 and b1 >= max ( b2 , a3 ) : print ( \" YES \" ) ; return NEW_LINE print ( \" NO \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_233_A", "sol": 0, "python_code": "def digSum ( n ) :\n    sum = 0 ;\n    rem = 0 ;\n    while ( n ) :\n        rem = n % 10 ;\n        sum = sum + rem ;\n        n = int ( n / 10 ) ;\n    return sum ;\ndef findX ( n ) :\n    for i in range ( n + 1 ) :\n        if ( i + digSum ( i ) == n ) :\n            return i ;\n    return - 1 ;\nn = 43 ;\nprint ( \"x = \" , findX ( n ) ) ;\n", "python_code_tokenized": "def digSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE rem = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT rem = n % 10 ; NEW_LINE sum = sum + rem ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def findX ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( i + digSum ( i ) == n ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT n = 43 ; NEW_LINE print ( \" x \u2581 = \u2581 \" , findX ( n ) ) ; NEW_LINE"}
{"id": "projecteuler_p072_A", "sol": 0, "python_code": "import eulerlib , itertools\ndef compute ( ) :\n    totients = eulerlib.list_totients ( 10 ** 6 )\n    ans = sum ( itertools.islice ( totients , 2 , None ) )\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 6 ) NEW_LINE ans = sum ( itertools . islice ( totients , 2 , None ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1765_A", "sol": 0, "python_code": "if __name__ == '__main__' :\n    a = 10\n    b = 5\n    if b > 0 :\n        while b > 0 :\n            a = a + 1\n            b = b - 1\n    if b < 0 :\n        while b < 0 :\n            a = a - 1\n            b = b + 1\n    print ( \"Sum is: \" , a )\n", "python_code_tokenized": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 5 NEW_LINE if b > 0 : NEW_LINE INDENT while b > 0 : NEW_LINE INDENT a = a + 1 NEW_LINE b = b - 1 NEW_LINE DEDENT DEDENT if b < 0 : NEW_LINE INDENT while b < 0 : NEW_LINE INDENT a = a - 1 NEW_LINE b = b + 1 NEW_LINE DEDENT DEDENT print ( \" Sum \u2581 is : \u2581 \" , a ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1904_A", "sol": 0, "python_code": "def countStrings ( n ) :\n    a = [ 0 for i in range ( n ) ]\n    b = [ 0 for i in range ( n ) ]\n    a [ 0 ] = b [ 0 ] = 1\n    for i in range ( 1 , n ) :\n        a [ i ] = a [ i - 1 ] + b [ i - 1 ]\n        b [ i ] = a [ i - 1 ]\n    return a [ n - 1 ] + b [ n - 1 ]\nprint ( countStrings ( 3 ) )\n", "python_code_tokenized": "def countStrings ( n ) : NEW_LINE INDENT a = [ 0 for i in range ( n ) ] NEW_LINE b = [ 0 for i in range ( n ) ] NEW_LINE a [ 0 ] = b [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEW_LINE b [ i ] = a [ i - 1 ] NEW_LINE DEDENT return a [ n - 1 ] + b [ n - 1 ] NEW_LINE DEDENT print ( countStrings ( 3 ) ) NEW_LINE"}
{"id": "geeksforgeeks_1633_A", "sol": 0, "python_code": "def print1 ( a , n ) :\n    for i in range ( 0 , n + 1 ) :\n        print ( a [ i ] , end = \"\" )\n    print ( \"\" )\ndef sort ( a , n ) :\n    for i in range ( n , 0 , - 1 ) :\n        for j in range ( n , n - i , - 1 ) :\n            if ( a [ j ] > a [ j - 1 ] ) :\n                a [ j ] , a [ j - 1 ] = a [ j - 1 ] , a [ j ]\n    print1 ( a , n )\nn = 7\na = [ 2 , 4 , 3 , 2 , 4 , 5 , 3 ]\nsort ( a , n - 1 )\n", "python_code_tokenized": "def print1 ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT def sort ( a , n ) : NEW_LINE INDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT for j in range ( n , n - i , - 1 ) : NEW_LINE INDENT if ( a [ j ] > a [ j - 1 ] ) : NEW_LINE INDENT a [ j ] , a [ j - 1 ] = a [ j - 1 ] , a [ j ] NEW_LINE DEDENT DEDENT DEDENT print1 ( a , n ) NEW_LINE DEDENT n = 7 NEW_LINE a = [ 2 , 4 , 3 , 2 , 4 , 5 , 3 ] NEW_LINE sort ( a , n - 1 ) NEW_LINE"}
{"id": "leetcode_206_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def reverseList ( self , head ) :\n        if head is None or head.next is None :\n            return head\n        p = self.reverseList ( head.next )\n        head.next.next = head\n        head.next = None\n        return p\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def reverseList ( self , head ) : NEW_LINE INDENT if head is None or head . next is None : NEW_LINE INDENT return head NEW_LINE DEDENT p = self . reverseList ( head . next ) NEW_LINE head . next . next = head NEW_LINE head . next = None NEW_LINE return p NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00586_A", "sol": 0, "python_code": "import sys\nval = [ ]\nresult = [ ]\ncount = 0\nfor line in sys.stdin :\n    if line != '\\n' :\n        for word in line.split ( ) :\n            val.append ( int ( word ) )\n        result.append ( sum ( val ) )\n        val = [ ]\n        count = count + 1\n    else :\n        break\nfor x in result :\n    print ( x )\n", "python_code_tokenized": "import sys NEW_LINE val = [ ] NEW_LINE result = [ ] NEW_LINE count = 0 NEW_LINE for line in sys . stdin : NEW_LINE INDENT if line != ' \\n ' : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT val . append ( int ( word ) ) NEW_LINE DEDENT result . append ( sum ( val ) ) NEW_LINE val = [ ] NEW_LINE count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for x in result : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4111_A", "sol": 0, "python_code": "N = 2 ;\ndef isVowel ( ch ) :\n    return ( ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u' ) ;\ndef countVowels ( string , l , r ) :\n    cnt = 0 ;\n    for i in range ( l , r + 1 ) :\n        if ( isVowel ( string [ i ] ) ) :\n            cnt += 1 ;\n    return cnt ;\ndef performQueries ( string , queries , q ) :\n    for i in range ( q ) :\n        print ( countVowels ( string , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ;\nif __name__ == \"__main__\" :\n    string = \"geeksforgeeks\" ;\n    queries = [ [ 1 , 3 ] , [ 2 , 4 ] , [ 1 , 9 ] ] ;\n    q = len ( queries )\n    performQueries ( string , queries , q ) ;\n", "python_code_tokenized": "N = 2 ; NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT return ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) ; NEW_LINE DEDENT def countVowels ( string , l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT def performQueries ( string , queries , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT print ( countVowels ( string , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE queries = [ [ 1 , 3 ] , [ 2 , 4 ] , [ 1 , 9 ] ] ; NEW_LINE q = len ( queries ) NEW_LINE performQueries ( string , queries , q ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3158_A", "sol": 0, "python_code": "def FindPoints ( n ) :\n    v = [ ] ;\n    v.append ( [ 0 , 0 ] ) ;\n    v.append ( [ 0 , n ] ) ;\n    v.append ( [ n , 0 ] ) ;\n    v.append ( [ n , n ] ) ;\n    if ( n % 2 == 0 ) :\n        v.append ( [ n // 2 , n // 2 ] ) ;\n    return v ;\nif __name__ == \"__main__\" :\n    N = 8 ;\n    v = FindPoints ( N ) ;\n    for element in v :\n        print ( \"(\" , element [ 0 ] , \",\" , element [ 1 ] , \")\" , end = \" \" ) ;\n", "python_code_tokenized": "def FindPoints ( n ) : NEW_LINE INDENT v = [ ] ; NEW_LINE v . append ( [ 0 , 0 ] ) ; NEW_LINE v . append ( [ 0 , n ] ) ; NEW_LINE v . append ( [ n , 0 ] ) ; NEW_LINE v . append ( [ n , n ] ) ; NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT v . append ( [ n // 2 , n // 2 ] ) ; NEW_LINE DEDENT return v ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 8 ; NEW_LINE v = FindPoints ( N ) ; NEW_LINE for element in v : NEW_LINE INDENT print ( \" ( \" , element [ 0 ] , \" , \" , element [ 1 ] , \" ) \" , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2532_A", "sol": 0, "python_code": "def countMoves ( n ) :\n    ct = 0\n    for i in range ( 1 , n + 1 ) :\n        ct += i * ( n - i )\n    ct += n\n    return ct\nif __name__ == \"__main__\" :\n    n = 3\n    print ( countMoves ( n ) )\n", "python_code_tokenized": "def countMoves ( n ) : NEW_LINE INDENT ct = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ct += i * ( n - i ) NEW_LINE DEDENT ct += n NEW_LINE return ct NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( countMoves ( n ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00080_A", "sol": 0, "python_code": "def san ( x ) :\n    y = q / 2\n    while True :\n        y = y - ( y ** 3 - x ) / ( 3 * y ** 2 )\n        if abs ( y ** 3 - x ) < 0.00001 * x :\n            break\n    print ( f'{y:.6f}' )\nwhile True :\n    q = int ( input ( ) )\n    if q == - 1 :\n        break\n    san ( q )\n", "python_code_tokenized": "def san ( x ) : NEW_LINE INDENT y = q / 2 NEW_LINE while True : NEW_LINE INDENT y = y - ( y ** 3 - x ) / ( 3 * y ** 2 ) NEW_LINE if abs ( y ** 3 - x ) < 0.00001 * x : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( f ' { y : .6f } ' ) NEW_LINE DEDENT while True : NEW_LINE INDENT q = int ( input ( ) ) NEW_LINE if q == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT san ( q ) NEW_LINE DEDENT"}
{"id": "aizu_p00490_A", "sol": 0, "python_code": "n = int ( input ( ) )\na , b = map ( int , input ( ).split ( ) )\nc = int ( input ( ) )\ntopping = [ ]\nfor _ in range ( n ) :\n    d = int ( input ( ) )\n    topping.append ( d )\ntopping.sort ( reverse = True )\nans = c // a\ntotal = c\nfor i , t in enumerate ( topping ) :\n    total += t\n    cal = total // ( a + ( i + 1 ) * b )\n    if ans <= cal :\n        ans = cal\n    else :\n        break\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = int ( input ( ) ) NEW_LINE topping = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT d = int ( input ( ) ) NEW_LINE topping . append ( d ) NEW_LINE DEDENT topping . sort ( reverse = True ) NEW_LINE ans = c // a NEW_LINE total = c NEW_LINE for i , t in enumerate ( topping ) : NEW_LINE INDENT total += t NEW_LINE cal = total // ( a + ( i + 1 ) * b ) NEW_LINE if ans <= cal : NEW_LINE INDENT ans = cal NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_5249_A", "sol": 0, "python_code": "def index ( st , ch ) :\n    for i in range ( len ( st ) ) :\n        if ( st [ i ] == ch ) :\n            return i ;\n    return - 1\ndef printNumbers ( n , d ) :\n    st = \"\" + str ( d )\n    ch = st [ 0 ]\n    for i in range ( 0 , n + 1 , 1 ) :\n        st = \"\"\n        st = st + str ( i )\n        if ( i == d or index ( st , ch ) >= 0 ) :\n            print ( i , end = \" \" )\nif __name__ == '__main__' :\n    n = 100\n    d = 5\n    printNumbers ( n , d )\n", "python_code_tokenized": "def index ( st , ch ) : NEW_LINE INDENT for i in range ( len ( st ) ) : NEW_LINE INDENT if ( st [ i ] == ch ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def printNumbers ( n , d ) : NEW_LINE INDENT st = \" \" + str ( d ) NEW_LINE ch = st [ 0 ] NEW_LINE for i in range ( 0 , n + 1 , 1 ) : NEW_LINE INDENT st = \" \" NEW_LINE st = st + str ( i ) NEW_LINE if ( i == d or index ( st , ch ) >= 0 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 100 NEW_LINE d = 5 NEW_LINE printNumbers ( n , d ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_302_A", "sol": 0, "python_code": "def getTotalNumberOfSequences ( m , n ) :\n    if m < n :\n        return 0\n    if n == 0 :\n        return 1\n    res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) )\n    return res\nif __name__ == '__main__' :\n    m = 10\n    n = 4\n    print ( 'Total number of possible sequences:' , getTotalNumberOfSequences ( m , n ) )\n", "python_code_tokenized": "def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT if m < n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) ) NEW_LINE return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 10 NEW_LINE n = 4 NEW_LINE print ( ' Total \u2581 number \u2581 of \u2581 possible \u2581 sequences : ' , getTotalNumberOfSequences ( m , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_907_B", "sol": 0, "python_code": "field = [ [ [ 0 ] * 3 , [ 0 ] * 3 , [ 0 ] * 3 ] , [ [ 0 ] * 3 , [ 0 ] * 3 , [ 0 ] * 3 ] , [ [ 0 ] * 3 , [ 0 ] * 3 , [ 0 ] * 3 ] ]\nfor i in range ( 3 ) :\n    for j in range ( 3 ) :\n        for k , line in enumerate ( input ( ).split ( ) ) :\n            field [ i ] [ k ] [ j ] = list ( line )\n    if i != 2 :\n        input ( )\nx , y = map ( lambda x : ( int ( x ) - 1 ) % 3 , input ( ).split ( ) )\nanywhere = True\nfor i in range ( 3 ) :\n    for j in range ( 3 ) :\n        if field [ x ] [ y ] [ i ] [ j ] == '.' :\n            field [ x ] [ y ] [ i ] [ j ] = '!'\n            anywhere = False\nfor i1 in range ( 3 ) :\n    for i in range ( 3 ) :\n        for j1 in range ( 3 ) :\n            for j in range ( 3 ) :\n                if field [ i1 ] [ j1 ] [ i ] [ j ] == '.' and anywhere :\n                    print ( '!' , end = '' )\n                else :\n                    print ( field [ i1 ] [ j1 ] [ i ] [ j ] , end = '' )\n            print ( '' , end = '' )\n        print ( )\n    print ( )\n", "python_code_tokenized": "field = [ [ [ 0 ] * 3 , [ 0 ] * 3 , [ 0 ] * 3 ] , [ [ 0 ] * 3 , [ 0 ] * 3 , [ 0 ] * 3 ] , [ [ 0 ] * 3 , [ 0 ] * 3 , [ 0 ] * 3 ] ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT for k , line in enumerate ( input ( ) . split ( ) ) : NEW_LINE INDENT field [ i ] [ k ] [ j ] = list ( line ) NEW_LINE DEDENT DEDENT if i != 2 : NEW_LINE INDENT input ( ) NEW_LINE DEDENT DEDENT x , y = map ( lambda x : ( int ( x ) - 1 ) % 3 , input ( ) . split ( ) ) NEW_LINE anywhere = True NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if field [ x ] [ y ] [ i ] [ j ] == ' . ' : NEW_LINE INDENT field [ x ] [ y ] [ i ] [ j ] = ' ! ' NEW_LINE anywhere = False NEW_LINE DEDENT DEDENT DEDENT for i1 in range ( 3 ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT for j1 in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if field [ i1 ] [ j1 ] [ i ] [ j ] == ' . ' and anywhere : NEW_LINE INDENT print ( ' ! ' , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( field [ i1 ] [ j1 ] [ i ] [ j ] , end = ' ' ) NEW_LINE DEDENT DEDENT print ( ' \u2581 ' , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"id": "codeforces_570_A", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\na = [ ]\nw = [ ]\nfor i in range ( m ) :\n    a = list ( map ( int , input ( ).split ( ) ) )\n    w.append ( a.index ( max ( a ) ) + 1 )\nbset = set ( w )\nmpst_common = None\nqty = 0\nfor item in bset :\n    q = w.count ( item )\n    if q > qty :\n        qty = q\n        mpst_common = item\nprint ( mpst_common )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE w = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE w . append ( a . index ( max ( a ) ) + 1 ) NEW_LINE DEDENT bset = set ( w ) NEW_LINE mpst_common = None NEW_LINE qty = 0 NEW_LINE for item in bset : NEW_LINE INDENT q = w . count ( item ) NEW_LINE if q > qty : NEW_LINE INDENT qty = q NEW_LINE mpst_common = item NEW_LINE DEDENT DEDENT print ( mpst_common ) NEW_LINE"}
{"id": "atcoder_ABC080_C", "sol": 0, "python_code": "N = int ( input ( ) )\nlst_F = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( N ) ]\nlst_P = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( N ) ]\nn_timetable = 10\nlst_joisino = [ None ] * n_timetable\ndef score ( src , F , P ) :\n    cnt = 0\n    for i , j in zip ( src , F ) :\n        if i == j == 1 :\n            cnt += 1\n    return P [ cnt ]\ndef dfs ( pos ) :\n    if pos == n_timetable :\n        ret = 0\n        for i in range ( N ) :\n            if lst_joisino == [ 0 ] * n_timetable :\n                return - float ( \"INF\" )\n            p = score ( lst_joisino , lst_F [ i ] , lst_P [ i ] )\n            ret += p\n        return ret\n    lst_joisino [ pos ] = 0\n    ret0 = dfs ( pos + 1 )\n    lst_joisino [ pos ] = 1\n    ret1 = dfs ( pos + 1 )\n    return max ( ret0 , ret1 )\nprint ( dfs ( 0 ) )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE lst_F = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE lst_P = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE n_timetable = 10 NEW_LINE lst_joisino = [ None ] * n_timetable NEW_LINE def score ( src , F , P ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i , j in zip ( src , F ) : NEW_LINE INDENT if i == j == 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return P [ cnt ] NEW_LINE DEDENT def dfs ( pos ) : NEW_LINE INDENT if pos == n_timetable : NEW_LINE INDENT ret = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if lst_joisino == [ 0 ] * n_timetable : NEW_LINE INDENT return - float ( \" INF \" ) NEW_LINE DEDENT p = score ( lst_joisino , lst_F [ i ] , lst_P [ i ] ) NEW_LINE ret += p NEW_LINE DEDENT return ret NEW_LINE DEDENT lst_joisino [ pos ] = 0 NEW_LINE ret0 = dfs ( pos + 1 ) NEW_LINE lst_joisino [ pos ] = 1 NEW_LINE ret1 = dfs ( pos + 1 ) NEW_LINE return max ( ret0 , ret1 ) NEW_LINE DEDENT print ( dfs ( 0 ) ) NEW_LINE"}
{"id": "codeforces_102_B", "sol": 0, "python_code": "import math\ndef sum_digit ( n ) :\n    sum = 0\n    for i in n :\n        sum += int ( i )\n    return str ( sum )\nn = input ( )\nresult = 0\nwhile ( len ( n ) > 1 ) :\n    n = sum_digit ( n )\n    result += 1\nprint ( result )\n", "python_code_tokenized": "import math NEW_LINE def sum_digit ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in n : NEW_LINE INDENT sum += int ( i ) NEW_LINE DEDENT return str ( sum ) NEW_LINE DEDENT n = input ( ) NEW_LINE result = 0 NEW_LINE while ( len ( n ) > 1 ) : NEW_LINE INDENT n = sum_digit ( n ) NEW_LINE result += 1 NEW_LINE DEDENT print ( result ) NEW_LINE"}
{"id": "aizu_p02317_A", "sol": 0, "python_code": "import bisect\nn = int ( input ( ) )\nseq = [ int ( input ( ) ) for _ in range ( n ) ]\ndp = [ seq [ 0 ] ]\nfor num in seq :\n    if num > dp [ - 1 ] :\n        dp.append ( num )\n    else :\n        dp [ bisect.bisect_left ( dp , num ) ] = num\nprint ( len ( dp ) )\n", "python_code_tokenized": "import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE seq = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE dp = [ seq [ 0 ] ] NEW_LINE for num in seq : NEW_LINE INDENT if num > dp [ - 1 ] : NEW_LINE INDENT dp . append ( num ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ bisect . bisect_left ( dp , num ) ] = num NEW_LINE DEDENT DEDENT print ( len ( dp ) ) NEW_LINE"}
{"id": "aizu_p00066_A", "sol": 0, "python_code": "def judge_aux ( t , k ) :\n    found = False\n    for i in range ( 3 ) :\n        if t [ i ] == list ( k * 3 ) :\n            found = True\n            break\n    if found :\n        return ( k )\n    found = False\n    for j in range ( 3 ) :\n        if t [ 0 ] [ j ] == t [ 1 ] [ j ] == t [ 2 ] [ j ] == k :\n            found = True\n            break\n    if found :\n        return ( k )\n    if t [ 0 ] [ 0 ] == t [ 1 ] [ 1 ] == t [ 2 ] [ 2 ] == k :\n        return ( k )\n    if t [ 0 ] [ 2 ] == t [ 1 ] [ 1 ] == t [ 2 ] [ 0 ] == k :\n        return ( k )\ndef judge ( t ) :\n    if judge_aux ( t , \"o\" ) :\n        return ( \"o\" )\n    elif judge_aux ( t , \"x\" ) :\n        return ( \"x\" )\n    else :\n        return ( \"d\" )\nwhile True :\n    try :\n        s = list ( input ( ).strip ( ) )\n        t = [ [ s [ 3 * i + j ] for j in range ( 3 ) ] for i in range ( 3 ) ]\n        print ( judge ( t ) )\n    except EOFError :\n        break\n", "python_code_tokenized": "def judge_aux ( t , k ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if t [ i ] == list ( k * 3 ) : NEW_LINE INDENT found = True NEW_LINE break NEW_LINE DEDENT DEDENT if found : NEW_LINE INDENT return ( k ) NEW_LINE DEDENT found = False NEW_LINE for j in range ( 3 ) : NEW_LINE INDENT if t [ 0 ] [ j ] == t [ 1 ] [ j ] == t [ 2 ] [ j ] == k : NEW_LINE INDENT found = True NEW_LINE break NEW_LINE DEDENT DEDENT if found : NEW_LINE INDENT return ( k ) NEW_LINE DEDENT if t [ 0 ] [ 0 ] == t [ 1 ] [ 1 ] == t [ 2 ] [ 2 ] == k : NEW_LINE INDENT return ( k ) NEW_LINE DEDENT if t [ 0 ] [ 2 ] == t [ 1 ] [ 1 ] == t [ 2 ] [ 0 ] == k : NEW_LINE INDENT return ( k ) NEW_LINE DEDENT DEDENT def judge ( t ) : NEW_LINE INDENT if judge_aux ( t , \" o \" ) : NEW_LINE INDENT return ( \" o \" ) NEW_LINE DEDENT elif judge_aux ( t , \" x \" ) : NEW_LINE INDENT return ( \" x \" ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( \" d \" ) NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT s = list ( input ( ) . strip ( ) ) NEW_LINE t = [ [ s [ 3 * i + j ] for j in range ( 3 ) ] for i in range ( 3 ) ] NEW_LINE print ( judge ( t ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_AGC023_C", "sol": 0, "python_code": "n = int ( input ( ) )\np = 10 ** 9 + 7\ndef fact ( n ) :\n    n_ = 1\n    yield n_\n    for i in range ( 1 , n + 1 ) :\n        n_ = ( n_ * i ) % p\n        yield n_\ndef invfact ( n , f , p ) :\n    m = pow ( f [ n ] , p - 2 , p )\n    yield m\n    for i in range ( n , 0 , - 1 ) :\n        m = m * i % p\n        yield m\nans = 0\nm = n - 1\nf = list ( fact ( m ) )\nrf = list ( invfact ( m , f , p ) )\nrf.reverse ( )\nperm = 0\nfor k in range ( ( n + 1 ) // 2 , n ) :\n    perm_ = f [ k - 1 ] * rf [ 2 * k - n ] % p * f [ k ] % p\n    ans += ( perm_ - perm ) % p * k % p\n    ans %= p\n    perm = perm_\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE p = 10 ** 9 + 7 NEW_LINE def fact ( n ) : NEW_LINE INDENT n_ = 1 NEW_LINE yield n_ NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT n_ = ( n_ * i ) % p NEW_LINE yield n_ NEW_LINE DEDENT DEDENT def invfact ( n , f , p ) : NEW_LINE INDENT m = pow ( f [ n ] , p - 2 , p ) NEW_LINE yield m NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT m = m * i % p NEW_LINE yield m NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE m = n - 1 NEW_LINE f = list ( fact ( m ) ) NEW_LINE rf = list ( invfact ( m , f , p ) ) NEW_LINE rf . reverse ( ) NEW_LINE perm = 0 NEW_LINE for k in range ( ( n + 1 ) // 2 , n ) : NEW_LINE INDENT perm_ = f [ k - 1 ] * rf [ 2 * k - n ] % p * f [ k ] % p NEW_LINE ans += ( perm_ - perm ) % p * k % p NEW_LINE ans %= p NEW_LINE perm = perm_ NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_1370_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor test in range ( t ) :\n    n = int ( input ( ) )\n    if n <= 3 :\n        gcd = 1\n    else :\n        if n % 2 == 0 :\n            gcd = int ( n / 2 )\n        else :\n            gcd = int ( ( n - 1 ) / 2 )\n    print ( gcd )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for test in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n <= 3 : NEW_LINE INDENT gcd = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT gcd = int ( n / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT gcd = int ( ( n - 1 ) / 2 ) NEW_LINE DEDENT DEDENT print ( gcd ) NEW_LINE DEDENT"}
{"id": "aizu_p00531_A", "sol": 0, "python_code": "A , B , C , D , P = [ int ( input ( ) ) for i in range ( 5 ) ]\nprint ( min ( A * P , B + ( ( P - C if P > C else 0 ) * D ) ) )\n", "python_code_tokenized": "A , B , C , D , P = [ int ( input ( ) ) for i in range ( 5 ) ] NEW_LINE print ( min ( A * P , B + ( ( P - C if P > C else 0 ) * D ) ) ) NEW_LINE"}
{"id": "codeforces_1029_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = [ 0 ] + list ( map ( int , input ( ).split ( ) ) )\nl = 1\nans = 1\nfor i in range ( n ) :\n    if a [ i + 1 ] <= a [ i ] * 2 :\n        ans += 1\n        l = max ( l , ans )\n    else :\n        ans = 1\nprint ( l )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = 1 NEW_LINE ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i + 1 ] <= a [ i ] * 2 : NEW_LINE INDENT ans += 1 NEW_LINE l = max ( l , ans ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT DEDENT print ( l ) NEW_LINE"}
{"id": "geeksforgeeks_3363_A", "sol": 0, "python_code": "MAX = 26\ndef printAnagramAndChanges ( x , y ) :\n    x = list ( x )\n    y = list ( y )\n    countx , county = [ 0 ] * MAX , [ 0 ] * MAX\n    ctrx , ctry = [ 0 ] * MAX , [ 0 ] * MAX\n    change = 0\n    l = len ( x )\n    for i in range ( l ) :\n        countx [ ord ( x [ i ] ) - ord ( 'A' ) ] += 1\n        county [ ord ( y [ i ] ) - ord ( 'A' ) ] += 1\n    for i in range ( MAX ) :\n        if countx [ i ] > county [ i ] :\n            ctrx [ i ] += ( countx [ i ] - county [ i ] )\n        elif countx [ i ] < county [ i ] :\n            ctry [ i ] += ( county [ i ] - countx [ i ] )\n        change += abs ( county [ i ] - countx [ i ] )\n    for i in range ( l ) :\n        if ctrx [ ord ( x [ i ] ) - ord ( 'A' ) ] == 0 :\n            continue\n        j = 0\n        for j in range ( MAX ) :\n            if ctry [ j ] > 0 :\n                break\n        if countx [ ord ( x [ i ] ) - ord ( 'A' ) ] == ctrx [ ord ( x [ i ] ) - ord ( 'A' ) ] or ord ( x [ i ] ) - ord ( 'A' ) > j :\n            countx [ ord ( x [ i ] ) - ord ( 'A' ) ] -= 1\n            ctrx [ ord ( x [ i ] ) - ord ( 'A' ) ] -= 1\n            ctry [ j ] -= 1\n            x [ i ] = chr ( ord ( 'A' ) + j )\n        else :\n            countx [ ord ( x [ i ] ) - ord ( 'A' ) ] -= 1\n    print ( \"Anagram :\" , ''.join ( x ) )\n    print ( \"Number of changes made :\" , change // 2 )\nif __name__ == \"__main__\" :\n    x = \"CDBABC\"\n    y = \"ADCABD\"\n    printAnagramAndChanges ( x , y )\n", "python_code_tokenized": "MAX = 26 NEW_LINE def printAnagramAndChanges ( x , y ) : NEW_LINE INDENT x = list ( x ) NEW_LINE y = list ( y ) NEW_LINE countx , county = [ 0 ] * MAX , [ 0 ] * MAX NEW_LINE ctrx , ctry = [ 0 ] * MAX , [ 0 ] * MAX NEW_LINE change = 0 NEW_LINE l = len ( x ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT countx [ ord ( x [ i ] ) - ord ( ' A ' ) ] += 1 NEW_LINE county [ ord ( y [ i ] ) - ord ( ' A ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT if countx [ i ] > county [ i ] : NEW_LINE INDENT ctrx [ i ] += ( countx [ i ] - county [ i ] ) NEW_LINE DEDENT elif countx [ i ] < county [ i ] : NEW_LINE INDENT ctry [ i ] += ( county [ i ] - countx [ i ] ) NEW_LINE DEDENT change += abs ( county [ i ] - countx [ i ] ) NEW_LINE DEDENT for i in range ( l ) : NEW_LINE INDENT if ctrx [ ord ( x [ i ] ) - ord ( ' A ' ) ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT j = 0 NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT if ctry [ j ] > 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if countx [ ord ( x [ i ] ) - ord ( ' A ' ) ] == ctrx [ ord ( x [ i ] ) - ord ( ' A ' ) ] or ord ( x [ i ] ) - ord ( ' A ' ) > j : NEW_LINE INDENT countx [ ord ( x [ i ] ) - ord ( ' A ' ) ] -= 1 NEW_LINE ctrx [ ord ( x [ i ] ) - ord ( ' A ' ) ] -= 1 NEW_LINE ctry [ j ] -= 1 NEW_LINE x [ i ] = chr ( ord ( ' A ' ) + j ) NEW_LINE DEDENT else : NEW_LINE INDENT countx [ ord ( x [ i ] ) - ord ( ' A ' ) ] -= 1 NEW_LINE DEDENT DEDENT print ( \" Anagram \u2581 : \" , ' ' . join ( x ) ) NEW_LINE print ( \" Number \u2581 of \u2581 changes \u2581 made \u2581 : \" , change // 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = \" CDBABC \" NEW_LINE y = \" ADCABD \" NEW_LINE printAnagramAndChanges ( x , y ) NEW_LINE DEDENT"}
{"id": "aizu_p01615_A", "sol": 0, "python_code": "from heapq import heappush , heappop\nn , m = map ( int , input ( ).split ( ) )\nedges = [ [ ] for _ in range ( n ) ]\nfor _ in range ( m ) :\n    a , b , c = map ( int , input ( ).split ( ) )\n    edges [ a ].append ( ( b , c ) )\ndist = [ 0 ] * n\nque = [ ]\nheappush ( que , ( 0 , 0 ) )\nwhile que :\n    total , node = heappop ( que )\n    total *= - 1\n    for to , cost in edges [ node ] :\n        if dist [ to ] < total + cost :\n            dist [ to ] = total + cost\n            heappush ( que , ( - ( total + cost ) , to ) )\nprint ( dist [ n - 1 ] )\n", "python_code_tokenized": "from heapq import heappush , heappop NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE edges = [ [ ] for _ in range ( n ) ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE edges [ a ] . append ( ( b , c ) ) NEW_LINE DEDENT dist = [ 0 ] * n NEW_LINE que = [ ] NEW_LINE heappush ( que , ( 0 , 0 ) ) NEW_LINE while que : NEW_LINE INDENT total , node = heappop ( que ) NEW_LINE total *= - 1 NEW_LINE for to , cost in edges [ node ] : NEW_LINE INDENT if dist [ to ] < total + cost : NEW_LINE INDENT dist [ to ] = total + cost NEW_LINE heappush ( que , ( - ( total + cost ) , to ) ) NEW_LINE DEDENT DEDENT DEDENT print ( dist [ n - 1 ] ) NEW_LINE"}
{"id": "geeksforgeeks_1400_A", "sol": 0, "python_code": "def printArr ( arr , n ) :\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" ) ;\ndef findArray ( n , k , s ) :\n    vis = [ 0 ] * n ;\n    cnt = 0 ;\n    arr = [ 0 ] * n ;\n    i = 0 ;\n    while ( i < n and cnt < k ) :\n        arr [ i ] = s ;\n        vis [ i ] = 1 ;\n        cnt += 1 ;\n        i += 2 ;\n    val = s ;\n    if ( s % 2 == 0 ) :\n        val += 1 ;\n    else :\n        val = val + 2 ;\n    for i in range ( n ) :\n        if ( vis [ i ] == 0 ) :\n            arr [ i ] = val ;\n    printArr ( arr , n ) ;\nif __name__ == \"__main__\" :\n    n = 8 ; k = 3 ; s = 12 ;\n    findArray ( n , k , s ) ;\n", "python_code_tokenized": "def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT def findArray ( n , k , s ) : NEW_LINE INDENT vis = [ 0 ] * n ; NEW_LINE cnt = 0 ; NEW_LINE arr = [ 0 ] * n ; NEW_LINE i = 0 ; NEW_LINE while ( i < n and cnt < k ) : NEW_LINE INDENT arr [ i ] = s ; NEW_LINE vis [ i ] = 1 ; NEW_LINE cnt += 1 ; NEW_LINE i += 2 ; NEW_LINE DEDENT val = s ; NEW_LINE if ( s % 2 == 0 ) : NEW_LINE INDENT val += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT val = val + 2 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] = val ; NEW_LINE DEDENT DEDENT printArr ( arr , n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 ; k = 3 ; s = 12 ; NEW_LINE findArray ( n , k , s ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5135_A", "sol": 0, "python_code": "import math as mt\nif __name__ == '__main__' :\n    n = 7\n    i , j = 0 , 0\n    while ( i < n ) :\n        if ( j == n + i ) :\n            j = - 1\n            i += 1\n            print ( )\n        elif ( ( i + j ) >= n - 1 ) :\n            print ( \"*\" , end = \"\" )\n        else :\n            print ( end = \"\" )\n        j += 1\n    for k in range ( 3 ) :\n        for l in range ( n - 1 + i ) :\n            if ( l <= 2 or ( l <= n - 1 + i and l >= n - 4 + i ) ) :\n                print ( \"*\" , end = \"\" )\n            else :\n                print ( end = \"\" )\n        print ( )\n", "python_code_tokenized": "import math as mt NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE i , j = 0 , 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( j == n + i ) : NEW_LINE INDENT j = - 1 NEW_LINE i += 1 NEW_LINE print ( ) NEW_LINE DEDENT elif ( ( i + j ) >= n - 1 ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end = \" \u2581 \" ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT for k in range ( 3 ) : NEW_LINE INDENT for l in range ( n - 1 + i ) : NEW_LINE INDENT if ( l <= 2 or ( l <= n - 1 + i and l >= n - 4 + i ) ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_AGC025_A", "sol": 0, "python_code": "from collections import defaultdict , deque\nimport sys , heapq , bisect , math , itertools , string , queue , datetime\nsys.setrecursionlimit ( 10 ** 8 )\nINF = float ( 'inf' )\nmod = 10 ** 9 + 7\ndef inpl ( ) : return list ( map ( int , input ( ).split ( ) ) )\ndef inpls ( ) : return list ( input ( ).split ( ) )\nN = int ( input ( ) )\ndef dsum ( x ) :\n    return sum ( map ( int , list ( str ( x ) ) ) )\nans = INF\nfor a in range ( 1 , N ) :\n    b = N - a\n    ans = min ( ans , dsum ( a ) + dsum ( b ) )\nprint ( ans )\n", "python_code_tokenized": "from collections import defaultdict , deque NEW_LINE import sys , heapq , bisect , math , itertools , string , queue , datetime NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def inpls ( ) : return list ( input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE def dsum ( x ) : NEW_LINE INDENT return sum ( map ( int , list ( str ( x ) ) ) ) NEW_LINE DEDENT ans = INF NEW_LINE for a in range ( 1 , N ) : NEW_LINE INDENT b = N - a NEW_LINE ans = min ( ans , dsum ( a ) + dsum ( b ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_1461_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor test in range ( t ) :\n    n , m = map ( int , input ( ).split ( ) )\n    mat = [ ]\n    cnt = 1\n    for i in range ( n ) :\n        s = input ( )\n        temp = [ ]\n        for j in range ( m ) :\n            if s [ j ] == '*' :\n                temp.append ( cnt )\n                cnt += 1\n            else :\n                temp.append ( 0 )\n        mat.append ( temp )\n    ans = 0\n    for i in range ( n ) :\n        for j in range ( m ) :\n            spruce = 0\n            for k in range ( n ) :\n                if mat [ i ] [ j ] != 0 :\n                    if j - k >= 0 and j + k < m and i + k < n and mat [ i + k ] [ j + k ] - mat [ i + k ] [ j - k ] + 1 == ( 2 * k ) + 1 :\n                        spruce += 1\n                    else :\n                        break\n            ans += spruce\n    print ( ans )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for test in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE mat = [ ] NEW_LINE cnt = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE temp = [ ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT if s [ j ] == ' * ' : NEW_LINE INDENT temp . append ( cnt ) NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp . append ( 0 ) NEW_LINE DEDENT DEDENT mat . append ( temp ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT spruce = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] != 0 : NEW_LINE INDENT if j - k >= 0 and j + k < m and i + k < n and mat [ i + k ] [ j + k ] - mat [ i + k ] [ j - k ] + 1 == ( 2 * k ) + 1 : NEW_LINE INDENT spruce += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT ans += spruce NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "codeforces_252_A", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nn = int ( input ( ) )\nw = list ( map ( int , input ( ).split ( ) ) )\nc = max ( w )\nfor i in range ( n ) :\n    s = w [ i ]\n    for j in range ( i + 1 , n ) :\n        s ^= w [ j ]\n        if s > c :\n            c = s\nprint ( c )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = max ( w ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = w [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT s ^= w [ j ] NEW_LINE if s > c : NEW_LINE INDENT c = s NEW_LINE DEDENT DEDENT DEDENT print ( c ) NEW_LINE"}
{"id": "aizu_p00143_A", "sol": 0, "python_code": "def side ( a , b , c ) :\n    return ( c [ 1 ] - a [ 1 ] ) * ( b [ 0 ] - a [ 0 ] ) - ( b [ 1 ] - a [ 1 ] ) * ( c [ 0 ] - a [ 0 ] ) > 0\ndef isInner ( x ) : return ( side ( p0 , p1 , x ) == side ( p1 , p2 , x ) == side ( p2 , p0 , x ) )\nfor _ in [ 0 ] * input ( ) :\n    P = map ( int , raw_input ( ).split ( ) )\n    p0 = P [ 0 : 2 ]\n    p1 = P [ 2 : 4 ]\n    p2 = P [ 4 : 6 ]\n    x1 = P [ 6 : 8 ]\n    x2 = P [ 8 : ]\n    print [ 'NG' , 'OK' ] [ isInner ( x1 ) != isInner ( x2 ) ]\n", "python_code_tokenized": "def side ( a , b , c ) : NEW_LINE INDENT return ( c [ 1 ] - a [ 1 ] ) * ( b [ 0 ] - a [ 0 ] ) - ( b [ 1 ] - a [ 1 ] ) * ( c [ 0 ] - a [ 0 ] ) > 0 NEW_LINE DEDENT def isInner ( x ) : return ( side ( p0 , p1 , x ) == side ( p1 , p2 , x ) == side ( p2 , p0 , x ) ) NEW_LINE for _ in [ 0 ] * input ( ) : NEW_LINE INDENT P = map ( int , raw_input ( ) . split ( ) ) NEW_LINE p0 = P [ 0 : 2 ] NEW_LINE p1 = P [ 2 : 4 ] NEW_LINE p2 = P [ 4 : 6 ] NEW_LINE x1 = P [ 6 : 8 ] NEW_LINE x2 = P [ 8 : ] NEW_LINE print [ ' NG ' , ' OK ' ] [ isInner ( x1 ) != isInner ( x2 ) ] NEW_LINE DEDENT"}
{"id": "codejam_10_13", "sol": 0, "python_code": "import sys\nimport math\nphi = 0.5 * ( 1.0 + math.sqrt ( 5.0 ) )\ndef countWinners ( minA , maxA , minB , maxB ) :\n    result = 0\n    numberOfBs = maxB - minB + 1\n    for A in range ( minA , maxA + 1 ) :\n        minLosingB = math.ceil ( A / phi )\n        maxLosingB = math.floor ( A * phi )\n        loosers = min ( maxB , maxLosingB ) - max ( minB , minLosingB ) + 1\n        if loosers < 0 :\n            loosers = 0\n        result += numberOfBs - loosers\n    return result\ndef invalidInput ( ) :\n    sys.exit ( 'Invalid input' )\nfirstLine = next ( sys.stdin )\nnumbers = [ int ( s ) for s in firstLine.split ( ) ]\nif len ( numbers ) != 1 :\n    invalidInput ( )\nT = numbers [ 0 ]\nfor caseNumber in range ( 1 , T + 1 ) :\n    thisLine = next ( sys.stdin )\n    numbers = [ int ( s ) for s in thisLine.split ( ) ]\n    if len ( numbers ) != 4 :\n        invalidInput ( )\n    ( minA , maxA , minB , maxB ) = tuple ( numbers )\n    assert ( 1 <= minA <= maxA <= 10 ** 6 )\n    assert ( 1 <= minB <= maxB <= 10 ** 6 )\n    result = countWinners ( minA , maxA , minB , maxB )\n    print ( 'Case #{0}: {1}'.format ( caseNumber , result ) )\n", "python_code_tokenized": "import sys NEW_LINE import math NEW_LINE phi = 0.5 * ( 1.0 + math . sqrt ( 5.0 ) ) NEW_LINE def countWinners ( minA , maxA , minB , maxB ) : NEW_LINE INDENT result = 0 NEW_LINE numberOfBs = maxB - minB + 1 NEW_LINE for A in range ( minA , maxA + 1 ) : NEW_LINE INDENT minLosingB = math . ceil ( A / phi ) NEW_LINE maxLosingB = math . floor ( A * phi ) NEW_LINE loosers = min ( maxB , maxLosingB ) - max ( minB , minLosingB ) + 1 NEW_LINE if loosers < 0 : NEW_LINE INDENT loosers = 0 NEW_LINE DEDENT result += numberOfBs - loosers NEW_LINE DEDENT return result NEW_LINE DEDENT def invalidInput ( ) : NEW_LINE INDENT sys . exit ( ' Invalid \u2581 input ' ) NEW_LINE DEDENT firstLine = next ( sys . stdin ) NEW_LINE numbers = [ int ( s ) for s in firstLine . split ( ) ] NEW_LINE if len ( numbers ) != 1 : NEW_LINE INDENT invalidInput ( ) NEW_LINE DEDENT T = numbers [ 0 ] NEW_LINE for caseNumber in range ( 1 , T + 1 ) : NEW_LINE INDENT thisLine = next ( sys . stdin ) NEW_LINE numbers = [ int ( s ) for s in thisLine . split ( ) ] NEW_LINE if len ( numbers ) != 4 : NEW_LINE INDENT invalidInput ( ) NEW_LINE DEDENT ( minA , maxA , minB , maxB ) = tuple ( numbers ) NEW_LINE assert ( 1 <= minA <= maxA <= 10 ** 6 ) NEW_LINE assert ( 1 <= minB <= maxB <= 10 ** 6 ) NEW_LINE result = countWinners ( minA , maxA , minB , maxB ) NEW_LINE print ( ' Case \u2581 # { 0 } : \u2581 { 1 } ' . format ( caseNumber , result ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02150_A", "sol": 0, "python_code": "a , b , x = [ int ( i ) for i in input ( ).split ( ) ]\nd = a - b\nn = max ( 0 , ( x - b ) ) // d\nans = x + n * b\nprint ( ans % 1000000007 )\n", "python_code_tokenized": "a , b , x = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE d = a - b NEW_LINE n = max ( 0 , ( x - b ) ) // d NEW_LINE ans = x + n * b NEW_LINE print ( ans % 1000000007 ) NEW_LINE"}
{"id": "aizu_p02453_A", "sol": 0, "python_code": "from bisect import bisect_left\nn = int ( input ( ) )\nA = tuple ( map ( int , input ( ).split ( ) ) )\nq = int ( input ( ) )\nfor _ in range ( q ) :\n    k = int ( input ( ) )\n    print ( bisect_left ( A , k ) )\n", "python_code_tokenized": "from bisect import bisect_left NEW_LINE n = int ( input ( ) ) NEW_LINE A = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT k = int ( input ( ) ) NEW_LINE print ( bisect_left ( A , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4394_A", "sol": 0, "python_code": "def printSeriesSum ( N ) :\n    sum = 0 ;\n    a = 1 ;\n    cnt = 0 ;\n    flag = True ;\n    sum += a ;\n    while ( cnt < N ) :\n        nextElement = None ;\n        if ( flag ) :\n            nextElement = a * 2 ;\n            sum += nextElement ;\n            flag = not flag ;\n        else :\n            nextElement = a * ( 3 / 2 ) ;\n            sum += nextElement ;\n            flag = not flag ;\n        a = nextElement ;\n        cnt += 1\n    print ( sum ) ;\nif __name__ == \"__main__\" :\n    N = 8 ;\n    printSeriesSum ( N ) ;\n", "python_code_tokenized": "def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE a = 1 ; NEW_LINE cnt = 0 ; NEW_LINE flag = True ; NEW_LINE sum += a ; NEW_LINE while ( cnt < N ) : NEW_LINE INDENT nextElement = None ; NEW_LINE if ( flag ) : NEW_LINE INDENT nextElement = a * 2 ; NEW_LINE sum += nextElement ; NEW_LINE flag = not flag ; NEW_LINE DEDENT else : NEW_LINE INDENT nextElement = a * ( 3 / 2 ) ; NEW_LINE sum += nextElement ; NEW_LINE flag = not flag ; NEW_LINE DEDENT a = nextElement ; NEW_LINE cnt += 1 NEW_LINE DEDENT print ( sum ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 8 ; NEW_LINE printSeriesSum ( N ) ; NEW_LINE DEDENT"}
{"id": "aizu_p01552_A", "sol": 0, "python_code": "from collections import defaultdict\nd = defaultdict ( lambda : \"no such property\" )\ncheck , * yaml = list ( open ( 0 ) )\nbefore = [ ]\nbeforei = [ ]\nka = defaultdict ( lambda : - 1 )\nbv = - 1\nfor y in yaml :\n    y = y.split ( \":\" )\n    vacant = y [ 0 ].count ( \"\" )\n    if bv >= vacant :\n        for num , b in enumerate ( beforei ) :\n            if b == vacant :\n                break\n        before = before [ : num ]\n        beforei = beforei [ : num ]\n    bv = vacant\n    before.append ( y [ 0 ].strip ( \"\" ) )\n    beforei.append ( bv )\n    x = y [ 1 ] [ 1 : - 1 ]\n    d [ tuple ( before ) ] = \"object\" if x == \"\" else \"string \\\"\"+x+\" \\ \"\"\nans = tuple ( check.strip ( \"\\n\" ).split ( \".\" ) [ 1 : ] )\nprint ( d [ ans ] )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE d = defaultdict ( lambda : \" no \u2581 such \u2581 property \" ) NEW_LINE check , * yaml = list ( open ( 0 ) ) NEW_LINE before = [ ] NEW_LINE beforei = [ ] NEW_LINE ka = defaultdict ( lambda : - 1 ) NEW_LINE bv = - 1 NEW_LINE for y in yaml : NEW_LINE INDENT y = y . split ( \" : \" ) NEW_LINE vacant = y [ 0 ] . count ( \" \u2581 \" ) NEW_LINE if bv >= vacant : NEW_LINE INDENT for num , b in enumerate ( beforei ) : NEW_LINE INDENT if b == vacant : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT before = before [ : num ] NEW_LINE beforei = beforei [ : num ] NEW_LINE DEDENT bv = vacant NEW_LINE before . append ( y [ 0 ] . strip ( \" \u2581 \" ) ) NEW_LINE beforei . append ( bv ) NEW_LINE x = y [ 1 ] [ 1 : - 1 ] NEW_LINE d [ tuple ( before ) ] = \" object \" if x == \" \" else \" string \u2581 \\ \" \" + x + \" \\ \" \" NEW_LINE DEDENT ans = tuple ( check . strip ( \" \\n \" ) . split ( \" . \" ) [ 1 : ] ) NEW_LINE print ( d [ ans ] ) NEW_LINE"}
{"id": "codeforces_789_B", "sol": 0, "python_code": "R = lambda : list ( map ( int , input ( ).split ( ) ) )\nb , q , i , m = R ( )\na = set ( R ( ) )\nc = 0\nfor _ in range ( 99 ) :\n    if abs ( b ) > i : break\n    if b not in a : c += 1\n    b *= q\nprint ( c if c < 32 else 'inf' )\n", "python_code_tokenized": "R = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b , q , i , m = R ( ) NEW_LINE a = set ( R ( ) ) NEW_LINE c = 0 NEW_LINE for _ in range ( 99 ) : NEW_LINE INDENT if abs ( b ) > i : break NEW_LINE if b not in a : c += 1 NEW_LINE b *= q NEW_LINE DEDENT print ( c if c < 32 else ' inf ' ) NEW_LINE"}
{"id": "atcoder_ABC108_A", "sol": 0, "python_code": "K = int ( input ( ) )\nodd = ( K + 1 ) // 2\neven = K - odd\nprint ( odd * even )\n", "python_code_tokenized": "K = int ( input ( ) ) NEW_LINE odd = ( K + 1 ) // 2 NEW_LINE even = K - odd NEW_LINE print ( odd * even ) NEW_LINE"}
{"id": "geeksforgeeks_218_A", "sol": 0, "python_code": "target = 93\narr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ]\nlength = len ( arr )\ntotalCount = 0\nfor i in range ( length - 2 ) :\n    if target % arr [ i ] == 0 :\n        for j in range ( i + 1 , length - 1 ) :\n            if target % ( arr [ i ] * arr [ j ] ) == 0 :\n                toFind = target // ( arr [ i ] * arr [ j ] )\n                for k in range ( j + 1 , length ) :\n                    if arr [ k ] == toFind :\n                        totalCount += 1\nprint ( 'Total number of triplets found: ' , totalCount )\n", "python_code_tokenized": "target = 93 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ] NEW_LINE length = len ( arr ) NEW_LINE totalCount = 0 NEW_LINE for i in range ( length - 2 ) : NEW_LINE INDENT if target % arr [ i ] == 0 : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if target % ( arr [ i ] * arr [ j ] ) == 0 : NEW_LINE INDENT toFind = target // ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if arr [ k ] == toFind : NEW_LINE INDENT totalCount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( ' Total \u2581 number \u2581 of \u2581 triplets \u2581 found : \u2581 ' , totalCount ) NEW_LINE"}
{"id": "geeksforgeeks_881_A", "sol": 0, "python_code": "def findParity ( x ) :\n    y = x ^ ( x >> 1 ) ;\n    y = y ^ ( y >> 2 ) ;\n    y = y ^ ( y >> 4 ) ;\n    y = y ^ ( y >> 8 ) ;\n    y = y ^ ( y >> 16 ) ;\n    if ( y & 1 ) :\n        return 1 ;\n    return 0 ;\nif ( findParity ( 9 ) == 0 ) :\n    print ( \"Even Parity\" ) ;\nelse :\n    print ( \"Odd Parity\\n\" ) ;\nif ( findParity ( 13 ) == 0 ) :\n    print ( \"Even Parity\" ) ;\nelse :\n    print ( \"Odd Parity\" ) ;\n", "python_code_tokenized": "def findParity ( x ) : NEW_LINE INDENT y = x ^ ( x >> 1 ) ; NEW_LINE y = y ^ ( y >> 2 ) ; NEW_LINE y = y ^ ( y >> 4 ) ; NEW_LINE y = y ^ ( y >> 8 ) ; NEW_LINE y = y ^ ( y >> 16 ) ; NEW_LINE if ( y & 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT if ( findParity ( 9 ) == 0 ) : NEW_LINE INDENT print ( \" Even \u2581 Parity \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Odd \u2581 Parity \\n \" ) ; NEW_LINE DEDENT if ( findParity ( 13 ) == 0 ) : NEW_LINE INDENT print ( \" Even \u2581 Parity \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Odd \u2581 Parity \" ) ; NEW_LINE DEDENT"}
{"id": "codeforces_71_B", "sol": 0, "python_code": "n , k , t = map ( int , input ( ).split ( ) )\nt = ( n * k * t ) // 100\nfor i in range ( n ) : print ( min ( max ( 0 , t - i * k ) , k ) , end = ' ' )\n", "python_code_tokenized": "n , k , t = map ( int , input ( ) . split ( ) ) NEW_LINE t = ( n * k * t ) // 100 NEW_LINE for i in range ( n ) : print ( min ( max ( 0 , t - i * k ) , k ) , end = ' \u2581 ' ) NEW_LINE"}
{"id": "geeksforgeeks_436_A", "sol": 0, "python_code": "def CountPairs ( n ) :\n    k = n\n    imin = 1\n    ans = 0\n    while ( imin <= n ) :\n        imax = n / k\n        ans += k * ( imax - imin + 1 )\n        imin = imax + 1\n        k = n / imin\n    return ans\nprint ( CountPairs ( 1 ) )\nprint ( CountPairs ( 2 ) )\nprint ( CountPairs ( 3 ) )\n", "python_code_tokenized": "def CountPairs ( n ) : NEW_LINE INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while ( imin <= n ) : NEW_LINE INDENT imax = n / k NEW_LINE ans += k * ( imax - imin + 1 ) NEW_LINE imin = imax + 1 NEW_LINE k = n / imin NEW_LINE DEDENT return ans NEW_LINE DEDENT print ( CountPairs ( 1 ) ) NEW_LINE print ( CountPairs ( 2 ) ) NEW_LINE print ( CountPairs ( 3 ) ) NEW_LINE"}
{"id": "aizu_p01638_A", "sol": 0, "python_code": "from math import pi , cos , sin\nr , _x , _y , n = map ( int , input ( ).split ( ) )\n_m = list ( map ( int , input ( ).split ( ) ) )\nx , y = _x / r , _y / r\nm = sum ( _m )\nt = [ 0.0 ] * ( n + 1 )\n_t = 0\na = [ ]\nfor i in range ( n ) :\n    _t += _m [ i ] / m * 2 * pi\n    t [ i + 1 ] = _t\n    a.append ( int ( ( 1 + ( ( sin ( t [ i ] ) * y - cos ( t [ i ] ) * x ) + ( x * cos ( t [ i + 1 ] ) - y * sin ( t [ i + 1 ] ) ) ) / ( t [ i + 1 ] - t [ i ] ) ) * 100 ) )\nprint ( * a )\n", "python_code_tokenized": "from math import pi , cos , sin NEW_LINE r , _x , _y , n = map ( int , input ( ) . split ( ) ) NEW_LINE _m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x , y = _x / r , _y / r NEW_LINE m = sum ( _m ) NEW_LINE t = [ 0.0 ] * ( n + 1 ) NEW_LINE _t = 0 NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT _t += _m [ i ] / m * 2 * pi NEW_LINE t [ i + 1 ] = _t NEW_LINE a . append ( int ( ( 1 + ( ( sin ( t [ i ] ) * y - cos ( t [ i ] ) * x ) + ( x * cos ( t [ i + 1 ] ) - y * sin ( t [ i + 1 ] ) ) ) / ( t [ i + 1 ] - t [ i ] ) ) * 100 ) ) NEW_LINE DEDENT print ( * a ) NEW_LINE"}
{"id": "geeksforgeeks_3697_A", "sol": 0, "python_code": "def maxXOR ( arr , n ) :\n    xorArr = 0\n    for i in range ( n ) :\n        xorArr ^= arr [ i ]\n    ans = 0\n    for i in range ( n ) :\n        ans = max ( ans , ( xorArr ^ arr [ i ] ) )\n    return ans\narr = [ 1 , 1 , 3 ]\nn = len ( arr )\nprint ( maxXOR ( arr , n ) )\n", "python_code_tokenized": "def maxXOR ( arr , n ) : NEW_LINE INDENT xorArr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , ( xorArr ^ arr [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 1 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxXOR ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1721_A", "sol": 0, "python_code": "def center_nonadecagon_num ( n ) :\n    return ( 19 * n * n - 19 * n + 2 ) // 2\nif __name__ == '__main__' :\n    n = 2\n    print ( n , \"nd centered nonadecagonal \" + \"number : \" , center_nonadecagon_num ( n ) )\n    n = 7\n    print ( n , \"nd centered nonadecagonal \" + \"number : \" , center_nonadecagon_num ( n ) )\n", "python_code_tokenized": "def center_nonadecagon_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 19 * n + 2 ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , \" nd \u2581 centered \u2581 nonadecagonal \u2581 \" + \" number \u2581 : \u2581 \" , center_nonadecagon_num ( n ) ) NEW_LINE n = 7 NEW_LINE print ( n , \" nd \u2581 centered \u2581 nonadecagonal \u2581 \" + \" number \u2581 : \u2581 \" , center_nonadecagon_num ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4255_A", "sol": 0, "python_code": "def remove_row_col ( arr , n , x ) :\n    for i in range ( x , n ) :\n        for j in range ( x , n ) :\n            print ( arr [ i ] [ j ] , end = \" \" )\n        print ( )\nif __name__ == \"__main__\" :\n    n = 3\n    MAX = 50\n    arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ]\n    x = 1\n    remove_row_col ( arr , n , x )\n", "python_code_tokenized": "def remove_row_col ( arr , n , x ) : NEW_LINE INDENT for i in range ( x , n ) : NEW_LINE INDENT for j in range ( x , n ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE MAX = 50 NEW_LINE arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE x = 1 NEW_LINE remove_row_col ( arr , n , x ) NEW_LINE DEDENT"}
{"id": "codeforces_1388_A", "sol": 0, "python_code": "for i in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    if ( n <= 30 ) :\n        print ( \"NO\" )\n    else :\n        print ( \"YES\" )\n        if ( n == 40 or n == 36 or n == 44 ) :\n            print ( \"6 10 15 \" , n - 31 )\n        else :\n            print ( \"6 10 14\" , n - 30 )\n", "python_code_tokenized": "for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if ( n <= 30 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE if ( n == 40 or n == 36 or n == 44 ) : NEW_LINE INDENT print ( \"6 \u2581 10 \u2581 15 \u2581 \" , n - 31 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"6 \u2581 10 \u2581 14\" , n - 30 ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "codeforces_1198_A", "sol": 0, "python_code": "def solve ( ) :\n    n , i = map ( int , input ( ).split ( ) )\n    ns = sorted ( [ * map ( int , input ( ).split ( ) ) ] )\n    k = 1 << ( i * 8 // n )\n    lis = [ ]\n    for i in range ( n - 1 ) :\n        if ns [ i ] != ns [ i + 1 ] : lis.append ( i + 1 )\n    lis.append ( n )\n    print ( 0 if len ( lis ) <= k else n - max ( lis [ i + k ] - lis [ i ] for i in range ( len ( lis ) - k ) ) )\nsolve ( )\n", "python_code_tokenized": "def solve ( ) : NEW_LINE INDENT n , i = map ( int , input ( ) . split ( ) ) NEW_LINE ns = sorted ( [ * map ( int , input ( ) . split ( ) ) ] ) NEW_LINE k = 1 << ( i * 8 // n ) NEW_LINE lis = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ns [ i ] != ns [ i + 1 ] : lis . append ( i + 1 ) NEW_LINE DEDENT lis . append ( n ) NEW_LINE print ( 0 if len ( lis ) <= k else n - max ( lis [ i + k ] - lis [ i ] for i in range ( len ( lis ) - k ) ) ) NEW_LINE DEDENT solve ( ) NEW_LINE"}
{"id": "geeksforgeeks_1233_A", "sol": 0, "python_code": "import math\ndef surface_area_octahedron ( side ) :\n    return ( 2 * ( math.sqrt ( 3 ) ) * ( side * side ) )\nside = 7\nprint ( \"Surface area of octahedron =\" , surface_area_octahedron ( side ) )\n", "python_code_tokenized": "import math NEW_LINE def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT side = 7 NEW_LINE print ( \" Surface \u2581 area \u2581 of \u2581 octahedron \u2581 = \" , surface_area_octahedron ( side ) ) NEW_LINE"}
{"id": "geeksforgeeks_1755_A", "sol": 0, "python_code": "def powerfulIntegers ( x , y , bound ) :\n    s = set ( )\n    powersOfY = [ ]\n    powersOfY.append ( 1 )\n    i = y\n    while i < bound :\n        powersOfY.append ( i )\n        i *= y\n    i = 0\n    while ( True ) :\n        xPowI = pow ( x , i )\n        if ( xPowI >= bound ) :\n            break\n        for j in powersOfY :\n            num = xPowI + j\n            if ( num <= bound ) :\n                s.add ( num )\n            else :\n                break\n        i += 1\n    for itr in s :\n        print ( itr , end = \" \" )\nif __name__ == \"__main__\" :\n    x = 2\n    y = 3\n    bound = 10\n    powerfulIntegers ( x , y , bound )\n", "python_code_tokenized": "def powerfulIntegers ( x , y , bound ) : NEW_LINE INDENT s = set ( ) NEW_LINE powersOfY = [ ] NEW_LINE powersOfY . append ( 1 ) NEW_LINE i = y NEW_LINE while i < bound : NEW_LINE INDENT powersOfY . append ( i ) NEW_LINE i *= y NEW_LINE DEDENT i = 0 NEW_LINE while ( True ) : NEW_LINE INDENT xPowI = pow ( x , i ) NEW_LINE if ( xPowI >= bound ) : NEW_LINE INDENT break NEW_LINE DEDENT for j in powersOfY : NEW_LINE INDENT num = xPowI + j NEW_LINE if ( num <= bound ) : NEW_LINE INDENT s . add ( num ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for itr in s : NEW_LINE INDENT print ( itr , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 2 NEW_LINE y = 3 NEW_LINE bound = 10 NEW_LINE powerfulIntegers ( x , y , bound ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC132_B", "sol": 0, "python_code": "n = int ( input ( ) )\nP = list ( map ( int , input ( ).split ( ) ) )\ncount = 0\nfor i in range ( 1 , len ( P ) ) :\n    if P [ i ] != max ( P [ i - 1 : i + 2 ] ) and P [ i ] != min ( P [ i - 1 : i + 2 ] ) :\n        count += 1\nprint ( count )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE P = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , len ( P ) ) : NEW_LINE INDENT if P [ i ] != max ( P [ i - 1 : i + 2 ] ) and P [ i ] != min ( P [ i - 1 : i + 2 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"}
{"id": "geeksforgeeks_4408_A", "sol": 0, "python_code": "def sum_of_series ( n ) :\n    result = 0\n    if ( n % 2 == 0 ) :\n        result = - ( n * ( n + 1 ) ) // 2\n    else :\n        result = ( n * ( n + 1 ) ) // 2\n    return result\nif __name__ == \"__main__\" :\n    n = 3\n    print ( sum_of_series ( n ) )\n    n = 10\n    print ( sum_of_series ( n ) )\n", "python_code_tokenized": "def sum_of_series ( n ) : NEW_LINE INDENT result = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT result = - ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT result = ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( sum_of_series ( n ) ) NEW_LINE n = 10 NEW_LINE print ( sum_of_series ( n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1041_B", "sol": 0, "python_code": "import math\nimport sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\na , b , x , y = map ( int , input ( ).split ( ) )\ng = math.gcd ( x , y )\nx //= g\ny //= g\nans = min ( a // x , b // y )\nprint ( ans )\n", "python_code_tokenized": "import math NEW_LINE import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE a , b , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE g = math . gcd ( x , y ) NEW_LINE x //= g NEW_LINE y //= g NEW_LINE ans = min ( a // x , b // y ) NEW_LINE print ( ans ) NEW_LINE"}
{"id": "codeforces_1380_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    s = input ( )\n    a = s.count ( 'S' )\n    b = s.count ( 'P' )\n    c = s.count ( 'R' )\n    x = max ( a , b , c )\n    if a == x :\n        print ( 'R' * len ( s ) )\n    elif b == x :\n        print ( 'S' * len ( s ) )\n    else :\n        print ( 'P' * len ( s ) )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = s . count ( ' S ' ) NEW_LINE b = s . count ( ' P ' ) NEW_LINE c = s . count ( ' R ' ) NEW_LINE x = max ( a , b , c ) NEW_LINE if a == x : NEW_LINE INDENT print ( ' R ' * len ( s ) ) NEW_LINE DEDENT elif b == x : NEW_LINE INDENT print ( ' S ' * len ( s ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' P ' * len ( s ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1216_A", "sol": 0, "python_code": "import math\ndef areaCircle ( b ) :\n    area = math.pi * b * b\n    return area\na = 10\nb = 8\nprint ( areaCircle ( b ) )\n", "python_code_tokenized": "import math NEW_LINE def areaCircle ( b ) : NEW_LINE INDENT area = math . pi * b * b NEW_LINE return area NEW_LINE DEDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( areaCircle ( b ) ) NEW_LINE"}
{"id": "geeksforgeeks_2524_A", "sol": 0, "python_code": "def FindMinNumber ( arr , n , k ) :\n    i = 0\n    j = 0\n    min_num = 10 ** 9\n    found = False\n    Sum = 0\n    while ( i < n ) :\n        Sum = Sum + arr [ i ]\n        if ( Sum == k ) :\n            min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) )\n            found = True\n        elif ( Sum > k ) :\n            while ( Sum > k ) :\n                Sum = Sum - arr [ j ]\n                j += 1\n            if ( Sum == k ) :\n                min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) )\n                found = True\n        i += 1\n    if ( found ) :\n        return min_num\n    return - 1\narr = [ 1 , 3 , 2 , 5 , 6 ]\nn = len ( arr )\nk = 5\nprint ( FindMinNumber ( arr , n , k ) )\n", "python_code_tokenized": "def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE min_num = 10 ** 9 NEW_LINE found = False NEW_LINE Sum = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE if ( Sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT elif ( Sum > k ) : NEW_LINE INDENT while ( Sum > k ) : NEW_LINE INDENT Sum = Sum - arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( Sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( found ) : NEW_LINE INDENT return min_num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( FindMinNumber ( arr , n , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_4127_A", "sol": 0, "python_code": "def findEqualPoint ( arr , n ) :\n    distArr = [ 0 ] * n\n    i = 0\n    di = 0\n    while ( i < n ) :\n        distArr [ di ] = i\n        di += 1\n        i += 1\n        while ( i < n and arr [ i ] == arr [ i - 1 ] ) :\n            i += 1\n    return distArr [ di >> 1 ] if ( di & 1 ) else - 1\narr = [ 1 , 2 , 3 , 4 , 4 , 5 , 6 , 6 , 6 , 7 ]\nn = len ( arr )\nindex = findEqualPoint ( arr , n )\nif ( index != - 1 ) :\n    print ( \"Equal Point = \" , arr [ index ] )\nelse :\n    print ( \"Equal Point does \" + \"not exists\" )\n", "python_code_tokenized": "def findEqualPoint ( arr , n ) : NEW_LINE INDENT distArr = [ 0 ] * n NEW_LINE i = 0 NEW_LINE di = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT distArr [ di ] = i NEW_LINE di += 1 NEW_LINE i += 1 NEW_LINE while ( i < n and arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return distArr [ di >> 1 ] if ( di & 1 ) else - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 4 , 5 , 6 , 6 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE index = findEqualPoint ( arr , n ) NEW_LINE if ( index != - 1 ) : NEW_LINE INDENT print ( \" Equal \u2581 Point \u2581 = \u2581 \" , arr [ index ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Equal \u2581 Point \u2581 does \u2581 \" + \" not \u2581 exists \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1679_A", "sol": 0, "python_code": "def findevenPair ( A , N ) :\n    count = 0\n    for i in range ( 0 , N ) :\n        if ( A [ i ] % 2 != 0 ) :\n            count += 1\n    oddCount = count * ( count - 1 ) / 2\n    return ( int ) ( ( N * ( N - 1 ) / 2 ) - oddCount )\na = [ 5 , 1 , 3 , 2 ]\nn = len ( a )\nprint ( findevenPair ( a , n ) )\n", "python_code_tokenized": "def findevenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT oddCount = count * ( count - 1 ) / 2 NEW_LINE return ( int ) ( ( N * ( N - 1 ) / 2 ) - oddCount ) NEW_LINE DEDENT a = [ 5 , 1 , 3 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( findevenPair ( a , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_5163_A", "sol": 0, "python_code": "def fact ( n ) :\n    f = 1\n    while n >= 1 :\n        f = f * n\n        n = n - 1\n    return f\ndef findSmallerInRight ( st , low , high ) :\n    countRight = 0\n    i = low + 1\n    while i <= high :\n        if st [ i ] < st [ low ] :\n            countRight = countRight + 1\n        i = i + 1\n    return countRight\ndef findRank ( st ) :\n    ln = len ( st )\n    mul = fact ( ln )\n    rank = 1\n    i = 0\n    while i < ln :\n        mul = mul / ( ln - i )\n        countRight = findSmallerInRight ( st , i , ln - 1 )\n        rank = rank + countRight * mul\n        i = i + 1\n    return rank\nst = \"string\"\nprint ( findRank ( st ) )\n", "python_code_tokenized": "def fact ( n ) : NEW_LINE INDENT f = 1 NEW_LINE while n >= 1 : NEW_LINE INDENT f = f * n NEW_LINE n = n - 1 NEW_LINE DEDENT return f NEW_LINE DEDENT def findSmallerInRight ( st , low , high ) : NEW_LINE INDENT countRight = 0 NEW_LINE i = low + 1 NEW_LINE while i <= high : NEW_LINE INDENT if st [ i ] < st [ low ] : NEW_LINE INDENT countRight = countRight + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return countRight NEW_LINE DEDENT def findRank ( st ) : NEW_LINE INDENT ln = len ( st ) NEW_LINE mul = fact ( ln ) NEW_LINE rank = 1 NEW_LINE i = 0 NEW_LINE while i < ln : NEW_LINE INDENT mul = mul / ( ln - i ) NEW_LINE countRight = findSmallerInRight ( st , i , ln - 1 ) NEW_LINE rank = rank + countRight * mul NEW_LINE i = i + 1 NEW_LINE DEDENT return rank NEW_LINE DEDENT st = \" string \" NEW_LINE print ( findRank ( st ) ) NEW_LINE"}
{"id": "codeforces_842_B", "sol": 0, "python_code": "data = input ( ).split ( \" \" )\nr = int ( data [ 0 ] )\nd = int ( data [ 1 ] )\nn = int ( input ( ) )\ni = 1\ncounter = 0\nwhile i <= n :\n    row = input ( ).split ( \" \" )\n    x = int ( row [ 0 ] )\n    y = int ( row [ 1 ] )\n    rc = int ( row [ 2 ] )\n    dc = ( x ** 2 + y ** 2 ) ** 0.5\n    if dc + rc <= r and dc - rc >= r - d :\n        counter += 1\n    i += 1\nprint ( counter )\n", "python_code_tokenized": "data = input ( ) . split ( \" \u2581 \" ) NEW_LINE r = int ( data [ 0 ] ) NEW_LINE d = int ( data [ 1 ] ) NEW_LINE n = int ( input ( ) ) NEW_LINE i = 1 NEW_LINE counter = 0 NEW_LINE while i <= n : NEW_LINE INDENT row = input ( ) . split ( \" \u2581 \" ) NEW_LINE x = int ( row [ 0 ] ) NEW_LINE y = int ( row [ 1 ] ) NEW_LINE rc = int ( row [ 2 ] ) NEW_LINE dc = ( x ** 2 + y ** 2 ) ** 0.5 NEW_LINE if dc + rc <= r and dc - rc >= r - d : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( counter ) NEW_LINE"}
{"id": "aizu_p00436_A", "sol": 0, "python_code": "import sys\nfrom sys import stdin\nfrom itertools import chain\ninput = stdin.readline\ndef flatten ( listOfLists ) :\n    return chain.from_iterable ( listOfLists )\ndef cut ( k ) :\n    global cards\n    yellow = cards [ : k ]\n    blue = cards [ k : ]\n    cards = blue + yellow\ndef shuffle ( ) :\n    global cards\n    yellow = cards [ : N ]\n    blue = cards [ N : ]\n    temp = [ [ y , b ] for y , b in zip ( yellow , blue ) ]\n    cards = list ( flatten ( temp ) )\ncards = [ ]\nN = 0\ndef main ( args ) :\n    global N\n    global cards\n    n = int ( input ( ) )\n    N = n\n    m = int ( input ( ) )\n    cards = [ x for x in range ( 1 , ( 2 * n ) + 1 ) ]\n    for _ in range ( m ) :\n        op = int ( input ( ) )\n        if op == 0 :\n            shuffle ( )\n        else :\n            cut ( op )\n    print ( '\\n'.join ( map ( str , cards ) ) )\nif __name__ == '__main__' :\n    main ( sys.argv [ 1 : ] )\n", "python_code_tokenized": "import sys NEW_LINE from sys import stdin NEW_LINE from itertools import chain NEW_LINE input = stdin . readline NEW_LINE def flatten ( listOfLists ) : NEW_LINE INDENT return chain . from_iterable ( listOfLists ) NEW_LINE DEDENT def cut ( k ) : NEW_LINE INDENT global cards NEW_LINE yellow = cards [ : k ] NEW_LINE blue = cards [ k : ] NEW_LINE cards = blue + yellow NEW_LINE DEDENT def shuffle ( ) : NEW_LINE INDENT global cards NEW_LINE yellow = cards [ : N ] NEW_LINE blue = cards [ N : ] NEW_LINE temp = [ [ y , b ] for y , b in zip ( yellow , blue ) ] NEW_LINE cards = list ( flatten ( temp ) ) NEW_LINE DEDENT cards = [ ] NEW_LINE N = 0 NEW_LINE def main ( args ) : NEW_LINE INDENT global N NEW_LINE global cards NEW_LINE n = int ( input ( ) ) NEW_LINE N = n NEW_LINE m = int ( input ( ) ) NEW_LINE cards = [ x for x in range ( 1 , ( 2 * n ) + 1 ) ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT op = int ( input ( ) ) NEW_LINE if op == 0 : NEW_LINE INDENT shuffle ( ) NEW_LINE DEDENT else : NEW_LINE INDENT cut ( op ) NEW_LINE DEDENT DEDENT print ( ' \\n ' . join ( map ( str , cards ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_243_A", "sol": 0, "python_code": "from math import log2\ndef givesum ( A , n ) :\n    max_element = max ( A )\n    maxBit = int ( log2 ( max_element ) ) + 1\n    totalSubarrays = n * ( n + 1 ) // 2\n    s = 0\n    for i in range ( maxBit ) :\n        c1 = 0\n        vec = [ ]\n        sum = 0\n        for j in range ( n ) :\n            a = A [ j ] >> i\n            if ( not ( a & 1 ) ) :\n                vec.append ( j )\n        cntSubarrNotSet = 0\n        cnt = 1\n        for j in range ( 1 , len ( vec ) ) :\n            if ( vec [ j ] - vec [ j - 1 ] == 1 ) :\n                cnt += 1\n            else :\n                cntSubarrNotSet += cnt * ( cnt + 1 ) // 2\n                cnt = 1\n        cntSubarrNotSet += cnt * ( cnt + 1 ) // 2\n        if len ( vec ) == 0 :\n            cntSubarrNotSet = 0\n        cntSubarrIthSet = totalSubarrays - cntSubarrNotSet\n        s += cntSubarrIthSet * pow ( 2 , i )\n    return s\nif __name__ == \"__main__\" :\n    A = [ 1 , 2 , 3 , 4 , 5 ]\n    n = len ( A )\n    print ( givesum ( A , n ) )\n", "python_code_tokenized": "from math import log2 NEW_LINE def givesum ( A , n ) : NEW_LINE INDENT max_element = max ( A ) NEW_LINE maxBit = int ( log2 ( max_element ) ) + 1 NEW_LINE totalSubarrays = n * ( n + 1 ) // 2 NEW_LINE s = 0 NEW_LINE for i in range ( maxBit ) : NEW_LINE INDENT c1 = 0 NEW_LINE vec = [ ] NEW_LINE sum = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT a = A [ j ] >> i NEW_LINE if ( not ( a & 1 ) ) : NEW_LINE INDENT vec . append ( j ) NEW_LINE DEDENT DEDENT cntSubarrNotSet = 0 NEW_LINE cnt = 1 NEW_LINE for j in range ( 1 , len ( vec ) ) : NEW_LINE INDENT if ( vec [ j ] - vec [ j - 1 ] == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntSubarrNotSet += cnt * ( cnt + 1 ) // 2 NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT cntSubarrNotSet += cnt * ( cnt + 1 ) // 2 NEW_LINE if len ( vec ) == 0 : NEW_LINE INDENT cntSubarrNotSet = 0 NEW_LINE DEDENT cntSubarrIthSet = totalSubarrays - cntSubarrNotSet NEW_LINE s += cntSubarrIthSet * pow ( 2 , i ) NEW_LINE DEDENT return s NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE print ( givesum ( A , n ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00979_A", "sol": 0, "python_code": "from sys import stdin , stdout\nimport math\nn = int ( stdin.readline ( ).strip ( ) )\nreserved = 1\nmaxspeed = 1\nwhile True :\n    if reserved + maxspeed * 3 > n :\n        break\n    maxspeed *= 3\n    reserved += maxspeed * 2\nans = 1\nn -= 1\ni = 3\nwhile i < maxspeed :\n    ans += 2\n    n -= i * 2\n    i *= 3\nn -= maxspeed\ni = maxspeed\nwhile i :\n    ans += n // i\n    n -= n // i * i\n    i //= 3\nstdout.writelines ( str ( ans + 1 ) + '\\n' )\n", "python_code_tokenized": "from sys import stdin , stdout NEW_LINE import math NEW_LINE n = int ( stdin . readline ( ) . strip ( ) ) NEW_LINE reserved = 1 NEW_LINE maxspeed = 1 NEW_LINE while True : NEW_LINE INDENT if reserved + maxspeed * 3 > n : NEW_LINE INDENT break NEW_LINE DEDENT maxspeed *= 3 NEW_LINE reserved += maxspeed * 2 NEW_LINE DEDENT ans = 1 NEW_LINE n -= 1 NEW_LINE i = 3 NEW_LINE while i < maxspeed : NEW_LINE INDENT ans += 2 NEW_LINE n -= i * 2 NEW_LINE i *= 3 NEW_LINE DEDENT n -= maxspeed NEW_LINE i = maxspeed NEW_LINE while i : NEW_LINE INDENT ans += n // i NEW_LINE n -= n // i * i NEW_LINE i //= 3 NEW_LINE DEDENT stdout . writelines ( str ( ans + 1 ) + ' \\n ' ) NEW_LINE"}
{"id": "aizu_p00992_A", "sol": 0, "python_code": "n = int ( input ( ) )\nans = 1\nh = [ 0 ] * 126\nfor i in range ( n ) :\n    v = int ( input ( ) )\n    if v <= 125 : h [ v ] += 1\n    ans += v\ns = 0\nfor i in range ( 1 , 126 ) :\n    s += h [ i - 1 ]\n    if n > s + 4 * i : ans -= n - ( s + 4 * i )\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE ans = 1 NEW_LINE h = [ 0 ] * 126 NEW_LINE for i in range ( n ) : NEW_LINE INDENT v = int ( input ( ) ) NEW_LINE if v <= 125 : h [ v ] += 1 NEW_LINE ans += v NEW_LINE DEDENT s = 0 NEW_LINE for i in range ( 1 , 126 ) : NEW_LINE INDENT s += h [ i - 1 ] NEW_LINE if n > s + 4 * i : ans -= n - ( s + 4 * i ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "projecteuler_p068_A", "sol": 0, "python_code": "import eulerlib\ndef compute ( ) :\n    state = list ( range ( 1 , 11 ) )\n    max = None\n    while True :\n        sum = state [ 0 ] + state [ 5 ] + state [ 6 ]\n        if state [ 1 ] + state [ 6 ] + state [ 7 ] == sum and state [ 2 ] + state [ 7 ] + state [ 8 ] == sum and state [ 3 ] + state [ 8 ] + state [ 9 ] == sum and state [ 4 ] + state [ 9 ] + state [ 5 ] == sum :\n            minouterindex = 0\n            minouter = state [ 0 ]\n            for i in range ( 1 , 5 ) :\n                if state [ i ] < minouter :\n                    minouterindex = i\n                    minouter = state [ i ]\n            s = \"\"\n            for i in range ( 5 ) :\n                s += str ( state [ ( minouterindex + i ) % 5 ] )\n                s += str ( state [ ( minouterindex + i ) % 5 + 5 ] )\n                s += str ( state [ ( minouterindex + i + 1 ) % 5 + 5 ] )\n            if len ( s ) == 16 and ( max is None or s > max ) :\n                max = s\n        if not eulerlib.next_permutation ( state ) :\n            break\n    assert max is not None\n    return max\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT state = list ( range ( 1 , 11 ) ) NEW_LINE max = None NEW_LINE while True : NEW_LINE INDENT sum = state [ 0 ] + state [ 5 ] + state [ 6 ] NEW_LINE if state [ 1 ] + state [ 6 ] + state [ 7 ] == sum and state [ 2 ] + state [ 7 ] + state [ 8 ] == sum and state [ 3 ] + state [ 8 ] + state [ 9 ] == sum and state [ 4 ] + state [ 9 ] + state [ 5 ] == sum : NEW_LINE INDENT minouterindex = 0 NEW_LINE minouter = state [ 0 ] NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT if state [ i ] < minouter : NEW_LINE INDENT minouterindex = i NEW_LINE minouter = state [ i ] NEW_LINE DEDENT DEDENT s = \" \" NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT s += str ( state [ ( minouterindex + i ) % 5 ] ) NEW_LINE s += str ( state [ ( minouterindex + i ) % 5 + 5 ] ) NEW_LINE s += str ( state [ ( minouterindex + i + 1 ) % 5 + 5 ] ) NEW_LINE DEDENT if len ( s ) == 16 and ( max is None or s > max ) : NEW_LINE INDENT max = s NEW_LINE DEDENT DEDENT if not eulerlib . next_permutation ( state ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT assert max is not None NEW_LINE return max NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1658_A", "sol": 0, "python_code": "def minOps ( arr , n , k ) :\n    max1 = max ( arr )\n    res = 0\n    for i in range ( 0 , n ) :\n        if ( ( max1 - arr [ i ] ) % k != 0 ) :\n            return - 1\n        else :\n            res += ( max1 - arr [ i ] ) / k\n    return int ( res )\narr = [ 21 , 33 , 9 , 45 , 63 ]\nn = len ( arr )\nk = 6\nprint ( minOps ( arr , n , k ) )\n", "python_code_tokenized": "def minOps ( arr , n , k ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( max1 - arr [ i ] ) % k != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( max1 - arr [ i ] ) / k NEW_LINE DEDENT DEDENT return int ( res ) NEW_LINE DEDENT arr = [ 21 , 33 , 9 , 45 , 63 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( minOps ( arr , n , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_754_A", "sol": 0, "python_code": "def pairwiseDifference ( arr , n ) :\n    for i in range ( n - 1 ) :\n        diff = abs ( arr [ i ] - arr [ i + 1 ] )\n        print ( diff , end = \" \" )\nif __name__ == \"__main__\" :\n    arr = [ 4 , 10 , 15 , 5 , 6 ]\n    n = len ( arr )\n    pairwiseDifference ( arr , n )\n", "python_code_tokenized": "def pairwiseDifference ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE print ( diff , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 10 , 15 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE pairwiseDifference ( arr , n ) NEW_LINE DEDENT"}
{"id": "projecteuler_p036_A", "sol": 0, "python_code": "def compute ( ) :\n    ans = sum ( i for i in range ( 1000000 ) if is_decimal_binary_palindrome ( i ) )\n    return str ( ans )\ndef is_decimal_binary_palindrome ( n ) :\n    s = str ( n )\n    if s != s [ : : - 1 ] :\n        return False\n    t = bin ( n ) [ 2 : ]\n    return t == t [ : : - 1 ]\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1000000 ) if is_decimal_binary_palindrome ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def is_decimal_binary_palindrome ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE if s != s [ : : - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT t = bin ( n ) [ 2 : ] NEW_LINE return t == t [ : : - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_239_A", "sol": 0, "python_code": "y , k , n = map ( int , input ( ).split ( ) )\na = [ ]\nfor i in range ( ( y // k ) + 1 , ( n // k ) + 1 ) :\n    a.append ( i * k - y )\nif len ( a ) == 0 :\n    print ( - 1 )\nelse :\n    b = ' '.join ( [ str ( elem ) for elem in a ] )\n    print ( b )\n", "python_code_tokenized": "y , k , n = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( ( y // k ) + 1 , ( n // k ) + 1 ) : NEW_LINE INDENT a . append ( i * k - y ) NEW_LINE DEDENT if len ( a ) == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ' \u2581 ' . join ( [ str ( elem ) for elem in a ] ) NEW_LINE print ( b ) NEW_LINE DEDENT"}
{"id": "aizu_p00483_A", "sol": 0, "python_code": "M , N = map ( int , input ( ).split ( ) )\nK = int ( input ( ) )\nP = [ '_' * ( N + 1 ) for _ in range ( M + 1 ) ]\nfor mi in range ( 1 , M + 1 ) :\n    P [ mi ] = '_' + input ( )\nJ = [ [ 0 for _ in range ( N + 1 ) ] for _ in range ( M + 1 ) ]\nO = [ [ 0 for _ in range ( N + 1 ) ] for _ in range ( M + 1 ) ]\nI = [ [ 0 for _ in range ( N + 1 ) ] for _ in range ( M + 1 ) ]\nfor i in range ( 1 , M + 1 ) :\n    ji , oi , ii = 0 , 0 , 0\n    for j in range ( 1 , N + 1 ) :\n        ji += P [ i ] [ j ] == 'J'\n        oi += P [ i ] [ j ] == 'O'\n        ii += P [ i ] [ j ] == 'I'\n        J [ i ] [ j ] = J [ i - 1 ] [ j ] + ji\n        O [ i ] [ j ] = O [ i - 1 ] [ j ] + oi\n        I [ i ] [ j ] = I [ i - 1 ] [ j ] + ii\ndef cum ( mat , a , b , c , d ) :\n    a -= 1\n    b -= 1\n    return mat [ a ] [ b ] + mat [ c ] [ d ] - mat [ a ] [ d ] - mat [ c ] [ b ]\nfor k in range ( K ) :\n    a , b , c , d = map ( int , input ( ).split ( ) )\n    j = cum ( J , a , b , c , d )\n    o = cum ( O , a , b , c , d )\n    i = cum ( I , a , b , c , d )\n    print ( j , o , i )\n", "python_code_tokenized": "M , N = map ( int , input ( ) . split ( ) ) NEW_LINE K = int ( input ( ) ) NEW_LINE P = [ ' _ ' * ( N + 1 ) for _ in range ( M + 1 ) ] NEW_LINE for mi in range ( 1 , M + 1 ) : NEW_LINE INDENT P [ mi ] = ' _ ' + input ( ) NEW_LINE DEDENT J = [ [ 0 for _ in range ( N + 1 ) ] for _ in range ( M + 1 ) ] NEW_LINE O = [ [ 0 for _ in range ( N + 1 ) ] for _ in range ( M + 1 ) ] NEW_LINE I = [ [ 0 for _ in range ( N + 1 ) ] for _ in range ( M + 1 ) ] NEW_LINE for i in range ( 1 , M + 1 ) : NEW_LINE INDENT ji , oi , ii = 0 , 0 , 0 NEW_LINE for j in range ( 1 , N + 1 ) : NEW_LINE INDENT ji += P [ i ] [ j ] == ' J ' NEW_LINE oi += P [ i ] [ j ] == ' O ' NEW_LINE ii += P [ i ] [ j ] == ' I ' NEW_LINE J [ i ] [ j ] = J [ i - 1 ] [ j ] + ji NEW_LINE O [ i ] [ j ] = O [ i - 1 ] [ j ] + oi NEW_LINE I [ i ] [ j ] = I [ i - 1 ] [ j ] + ii NEW_LINE DEDENT DEDENT def cum ( mat , a , b , c , d ) : NEW_LINE INDENT a -= 1 NEW_LINE b -= 1 NEW_LINE return mat [ a ] [ b ] + mat [ c ] [ d ] - mat [ a ] [ d ] - mat [ c ] [ b ] NEW_LINE DEDENT for k in range ( K ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE j = cum ( J , a , b , c , d ) NEW_LINE o = cum ( O , a , b , c , d ) NEW_LINE i = cum ( I , a , b , c , d ) NEW_LINE print ( j , o , i ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1769_A", "sol": 0, "python_code": "def findWater ( i , j , X ) :\n    if ( j > i ) :\n        print ( \"Incorrect Input\" ) ;\n        return ;\n    glass = [ 0 ] * int ( i * ( i + 1 ) / 2 ) ;\n    index = 0 ;\n    glass [ index ] = X ;\n    for row in range ( 1 , i ) :\n        for col in range ( 1 , row + 1 ) :\n            X = glass [ index ] ;\n            glass [ index ] = 1.0 if ( X >= 1.0 ) else X ;\n            X = ( X - 1 ) if ( X >= 1.0 ) else 0.0 ;\n            glass [ index + row ] += ( X / 2 ) ;\n            glass [ index + row + 1 ] += ( X / 2 ) ;\n            index += 1 ;\n    return glass [ int ( i * ( i - 1 ) / 2 + j - 1 ) ] ;\nif __name__ == \"__main__\" :\n    i = 2 ;\n    j = 2 ;\n    X = 2.0 ;\n    res = repr ( findWater ( i , j , X ) ) ;\n    print ( \"Amount of water in jth glass of ith row is:\" , res.ljust ( 8 , '0' ) ) ;\n", "python_code_tokenized": "def findWater ( i , j , X ) : NEW_LINE INDENT if ( j > i ) : NEW_LINE INDENT print ( \" Incorrect \u2581 Input \" ) ; NEW_LINE return ; NEW_LINE DEDENT glass = [ 0 ] * int ( i * ( i + 1 ) / 2 ) ; NEW_LINE index = 0 ; NEW_LINE glass [ index ] = X ; NEW_LINE for row in range ( 1 , i ) : NEW_LINE INDENT for col in range ( 1 , row + 1 ) : NEW_LINE INDENT X = glass [ index ] ; NEW_LINE glass [ index ] = 1.0 if ( X >= 1.0 ) else X ; NEW_LINE X = ( X - 1 ) if ( X >= 1.0 ) else 0.0 ; NEW_LINE glass [ index + row ] += ( X / 2 ) ; NEW_LINE glass [ index + row + 1 ] += ( X / 2 ) ; NEW_LINE index += 1 ; NEW_LINE DEDENT DEDENT return glass [ int ( i * ( i - 1 ) / 2 + j - 1 ) ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT i = 2 ; NEW_LINE j = 2 ; NEW_LINE X = 2.0 ; NEW_LINE res = repr ( findWater ( i , j , X ) ) ; NEW_LINE print ( \" Amount \u2581 of \u2581 water \u2581 in \u2581 jth \u2581 glass \u2581 of \u2581 ith \u2581 row \u2581 is : \" , res . ljust ( 8 , '0' ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_545_B", "sol": 0, "python_code": "s1 , s2 = input ( ) , input ( )\ns = ''\ncounter = 0\nfor c1 , c2 in zip ( s1 , s2 ) :\n    if c1 == c2 :\n        s += c1\n    else :\n        s += c2 if counter else c1\n        counter += 1 if counter else - 1\nprint ( [ s , 'impossible' ] [ counter != 0 ] )\n", "python_code_tokenized": "s1 , s2 = input ( ) , input ( ) NEW_LINE s = ' ' NEW_LINE counter = 0 NEW_LINE for c1 , c2 in zip ( s1 , s2 ) : NEW_LINE INDENT if c1 == c2 : NEW_LINE INDENT s += c1 NEW_LINE DEDENT else : NEW_LINE INDENT s += c2 if counter else c1 NEW_LINE counter += 1 if counter else - 1 NEW_LINE DEDENT DEDENT print ( [ s , ' impossible ' ] [ counter != 0 ] ) NEW_LINE"}
{"id": "aizu_p01985_A", "sol": 0, "python_code": "from collections import defaultdict\nimport sys\nsys.setrecursionlimit ( 1000000 )\ndef dfs ( graph , visited , x , c ) :\n    visited [ x ] = c\n    for nx in graph [ x ] :\n        if visited [ nx ] == c :\n            return False\n        if visited [ nx ] == 0 and not dfs ( graph , visited , nx , - c ) :\n            return False\n    return True\nwhile True :\n    n , m = list ( map ( int , input ( ).split ( ) ) )\n    if n == 0 :\n        break\n    graph = defaultdict ( list )\n    visited = [ 0 for i in range ( n + 1 ) ]\n    for i in range ( m ) :\n        u , v = list ( map ( int , input ( ).split ( ) ) )\n        graph [ u ].append ( v )\n        graph [ v ].append ( u )\n    f = dfs ( graph , visited , 1 , 1 )\n    if f == False :\n        print ( 0 )\n    else :\n        ans1 , ans2 = 0 , 0\n        for i in range ( 1 , n + 1 ) :\n            if visited [ i ] > 0 :\n                ans1 += 1\n            elif visited [ i ] < 0 :\n                ans2 += 1\n        ans = set ( )\n        if ans1 % 2 == 0 :\n            ans.add ( ans1 // 2 )\n        if ans2 % 2 == 0 :\n            ans.add ( ans2 // 2 )\n        print ( len ( ans ) )\n        for e in sorted ( ans ) :\n            print ( e )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 1000000 ) NEW_LINE def dfs ( graph , visited , x , c ) : NEW_LINE INDENT visited [ x ] = c NEW_LINE for nx in graph [ x ] : NEW_LINE INDENT if visited [ nx ] == c : NEW_LINE INDENT return False NEW_LINE DEDENT if visited [ nx ] == 0 and not dfs ( graph , visited , nx , - c ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT while True : NEW_LINE INDENT n , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT graph = defaultdict ( list ) NEW_LINE visited = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT u , v = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE graph [ u ] . append ( v ) NEW_LINE graph [ v ] . append ( u ) NEW_LINE DEDENT f = dfs ( graph , visited , 1 , 1 ) NEW_LINE if f == False : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans1 , ans2 = 0 , 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if visited [ i ] > 0 : NEW_LINE INDENT ans1 += 1 NEW_LINE DEDENT elif visited [ i ] < 0 : NEW_LINE INDENT ans2 += 1 NEW_LINE DEDENT DEDENT ans = set ( ) NEW_LINE if ans1 % 2 == 0 : NEW_LINE INDENT ans . add ( ans1 // 2 ) NEW_LINE DEDENT if ans2 % 2 == 0 : NEW_LINE INDENT ans . add ( ans2 // 2 ) NEW_LINE DEDENT print ( len ( ans ) ) NEW_LINE for e in sorted ( ans ) : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "codeforces_749_B", "sol": 0, "python_code": "ax , ay = map ( int , input ( ).split ( ) )\nbx , by = map ( int , input ( ).split ( ) )\ncx , cy = map ( int , input ( ).split ( ) )\nprint ( 3 )\nprint ( bx + cx - ax , by + cy - ay )\nprint ( cx + ax - bx , cy + ay - by )\nprint ( bx + ax - cx , by + ay - cy )\n", "python_code_tokenized": "ax , ay = map ( int , input ( ) . split ( ) ) NEW_LINE bx , by = map ( int , input ( ) . split ( ) ) NEW_LINE cx , cy = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 3 ) NEW_LINE print ( bx + cx - ax , by + cy - ay ) NEW_LINE print ( cx + ax - bx , cy + ay - by ) NEW_LINE print ( bx + ax - cx , by + ay - cy ) NEW_LINE"}
{"id": "aizu_p00032_A", "sol": 0, "python_code": "import sys\nrhombus = rectangle = 0\nfor line in sys.stdin :\n    a , b , c = map ( int , line.split ( \",\" ) )\n    if c ** 2 == a ** 2 + b ** 2 :\n        rectangle += 1\n    elif a == b :\n        rhombus += 1\nprint ( rectangle )\nprint ( rhombus )\n", "python_code_tokenized": "import sys NEW_LINE rhombus = rectangle = 0 NEW_LINE for line in sys . stdin : NEW_LINE INDENT a , b , c = map ( int , line . split ( \" , \" ) ) NEW_LINE if c ** 2 == a ** 2 + b ** 2 : NEW_LINE INDENT rectangle += 1 NEW_LINE DEDENT elif a == b : NEW_LINE INDENT rhombus += 1 NEW_LINE DEDENT DEDENT print ( rectangle ) NEW_LINE print ( rhombus ) NEW_LINE"}
{"id": "atcoder_ARC102_C", "sol": 0, "python_code": "K , N = map ( int , input ( ).split ( ) )\nmod = 998244353\ndef inved ( a ) :\n    x , y , u , v , k , l = 1 , 0 , 0 , 1 , a , mod\n    while l != 0 :\n        x , y , u , v = u , v , x - u * ( k // l ) , y - v * ( k // l )\n        k , l = l , k % l\n    return x % mod\nX = [ 0 for i in range ( 2 * K - 1 ) ]\nfrac = [ 1 ]\nfor i in range ( N + K ) :\n    frac.append ( ( ( i + 1 ) * frac [ i ] ) % mod )\ninvf = [ ]\nfor i in range ( N + K + 1 ) :\n    invf.append ( inved ( frac [ i ] ) )\nfor k in range ( 2 , K + 2 ) :\n    S = 0\n    sign = 1\n    l = k // 2\n    for m in range ( min ( l + 1 , N // 2 + 1 ) ) :\n        prod = ( sign * ( frac [ l ] * frac [ N + K - 2 * m - 1 ] ) ) % mod\n        prod *= ( invf [ m ] * invf [ l - m ] ) % mod\n        prod %= mod\n        prod *= ( invf [ N - 2 * m ] * invf [ K - 1 ] ) % mod\n        prod %= mod\n        S += prod\n        S %= mod\n        sign *= - 1\n    X [ k - 2 ] , X [ 2 * K - k ] = S , S\nfor i in range ( 2 * K - 1 ) :\n    print ( X [ i ] )\n", "python_code_tokenized": "K , N = map ( int , input ( ) . split ( ) ) NEW_LINE mod = 998244353 NEW_LINE def inved ( a ) : NEW_LINE INDENT x , y , u , v , k , l = 1 , 0 , 0 , 1 , a , mod NEW_LINE while l != 0 : NEW_LINE INDENT x , y , u , v = u , v , x - u * ( k // l ) , y - v * ( k // l ) NEW_LINE k , l = l , k % l NEW_LINE DEDENT return x % mod NEW_LINE DEDENT X = [ 0 for i in range ( 2 * K - 1 ) ] NEW_LINE frac = [ 1 ] NEW_LINE for i in range ( N + K ) : NEW_LINE INDENT frac . append ( ( ( i + 1 ) * frac [ i ] ) % mod ) NEW_LINE DEDENT invf = [ ] NEW_LINE for i in range ( N + K + 1 ) : NEW_LINE INDENT invf . append ( inved ( frac [ i ] ) ) NEW_LINE DEDENT for k in range ( 2 , K + 2 ) : NEW_LINE INDENT S = 0 NEW_LINE sign = 1 NEW_LINE l = k // 2 NEW_LINE for m in range ( min ( l + 1 , N // 2 + 1 ) ) : NEW_LINE INDENT prod = ( sign * ( frac [ l ] * frac [ N + K - 2 * m - 1 ] ) ) % mod NEW_LINE prod *= ( invf [ m ] * invf [ l - m ] ) % mod NEW_LINE prod %= mod NEW_LINE prod *= ( invf [ N - 2 * m ] * invf [ K - 1 ] ) % mod NEW_LINE prod %= mod NEW_LINE S += prod NEW_LINE S %= mod NEW_LINE sign *= - 1 NEW_LINE DEDENT X [ k - 2 ] , X [ 2 * K - k ] = S , S NEW_LINE DEDENT for i in range ( 2 * K - 1 ) : NEW_LINE INDENT print ( X [ i ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2626_A", "sol": 0, "python_code": "def calculateSum ( n , k ) :\n    res = 1\n    MOD = 1000000007\n    while k > 0 :\n        if ( k & 1 ) == 1 :\n            res = ( res * n ) % MOD\n        k = k // 2\n        n = ( n * n ) % MOD\n    return res\nn = 4\nk = 3\nprint ( calculateSum ( n , k ) )\n", "python_code_tokenized": "def calculateSum ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE while k > 0 : NEW_LINE INDENT if ( k & 1 ) == 1 : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT k = k // 2 NEW_LINE n = ( n * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( calculateSum ( n , k ) ) NEW_LINE"}
{"id": "codeforces_243_A", "sol": 0, "python_code": "from math import inf\nfrom collections import *\nimport math , os , sys , heapq , bisect , random\nfrom functools import lru_cache\nfrom itertools import *\ndef inp ( ) : return sys.stdin.readline ( ).rstrip ( \"\\n\" )\ndef out ( var ) : sys.stdout.write ( str ( var ) )\ndef inpu ( ) : return int ( inp ( ) )\ndef lis ( ) : return list ( map ( int , inp ( ).split ( ) ) )\ndef stringlis ( ) : return list ( map ( str , inp ( ).split ( ) ) )\ndef sep ( ) : return map ( int , inp ( ).split ( ) )\ndef strsep ( ) : return map ( str , inp ( ).split ( ) )\ndef fsep ( ) : return map ( float , inp ( ).split ( ) )\nM , M1 = 1000000007 , 998244353\ndef main ( ) :\n    how_much_noob_I_am = 1\n    for __ in range ( how_much_noob_I_am ) :\n        n = inpu ( )\n        arr = lis ( )\n        s = set ( )\n        p = set ( )\n        for i in range ( n ) :\n            q = set ( )\n            for j in p :\n                q.add ( j | arr [ i ] )\n            q.add ( arr [ i ] )\n            p = q\n            for k in p :\n                s.add ( k )\n        print ( len ( s ) )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "from math import inf NEW_LINE from collections import * NEW_LINE import math , os , sys , heapq , bisect , random NEW_LINE from functools import lru_cache NEW_LINE from itertools import * NEW_LINE def inp ( ) : return sys . stdin . readline ( ) . rstrip ( \" \\n \" ) NEW_LINE def out ( var ) : sys . stdout . write ( str ( var ) ) NEW_LINE def inpu ( ) : return int ( inp ( ) ) NEW_LINE def lis ( ) : return list ( map ( int , inp ( ) . split ( ) ) ) NEW_LINE def stringlis ( ) : return list ( map ( str , inp ( ) . split ( ) ) ) NEW_LINE def sep ( ) : return map ( int , inp ( ) . split ( ) ) NEW_LINE def strsep ( ) : return map ( str , inp ( ) . split ( ) ) NEW_LINE def fsep ( ) : return map ( float , inp ( ) . split ( ) ) NEW_LINE M , M1 = 1000000007 , 998244353 NEW_LINE def main ( ) : NEW_LINE INDENT how_much_noob_I_am = 1 NEW_LINE for __ in range ( how_much_noob_I_am ) : NEW_LINE INDENT n = inpu ( ) NEW_LINE arr = lis ( ) NEW_LINE s = set ( ) NEW_LINE p = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT q = set ( ) NEW_LINE for j in p : NEW_LINE INDENT q . add ( j | arr [ i ] ) NEW_LINE DEDENT q . add ( arr [ i ] ) NEW_LINE p = q NEW_LINE for k in p : NEW_LINE INDENT s . add ( k ) NEW_LINE DEDENT DEDENT print ( len ( s ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "aizu_p00639_A", "sol": 0, "python_code": "EPS = 1e-7\nwhile True :\n    d = float ( input ( ) )\n    if d == 0 : break\n    px , py , vx , vy = map ( float , input ( ).split ( ) )\n    ans = d + 1\n    dp = ( px * px + py * py ) ** 0.5\n    dv = ( vx * vx + vy * vy ) ** 0.5\n    x = ( px * vx + py * vy ) / ( dp * dv )\n    if abs ( x + 1 ) <= EPS : ans = dp\n    elif abs ( 1 - x ) <= EPS : ans = 2 - dp\n    print ( ans if abs ( ans - d ) <= EPS or ans <= d else \"impossible\" )\n", "python_code_tokenized": "EPS = 1e-7 NEW_LINE while True : NEW_LINE INDENT d = float ( input ( ) ) NEW_LINE if d == 0 : break NEW_LINE px , py , vx , vy = map ( float , input ( ) . split ( ) ) NEW_LINE ans = d + 1 NEW_LINE dp = ( px * px + py * py ) ** 0.5 NEW_LINE dv = ( vx * vx + vy * vy ) ** 0.5 NEW_LINE x = ( px * vx + py * vy ) / ( dp * dv ) NEW_LINE if abs ( x + 1 ) <= EPS : ans = dp NEW_LINE elif abs ( 1 - x ) <= EPS : ans = 2 - dp NEW_LINE print ( ans if abs ( ans - d ) <= EPS or ans <= d else \" impossible \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2428_A", "sol": 0, "python_code": "def divisibleby37 ( n ) :\n    l = len ( n )\n    if ( n == 0 ) :\n        return True\n    if ( l % 3 == 1 ) :\n        n = \"00\" + n\n        l += 2\n    elif ( l % 3 == 2 ) :\n        n = \"0\" + n\n        l += 1\n    gSum = 0\n    while ( l != 0 ) :\n        group = int ( n [ l - 3 : l ] )\n        l = l - 3\n        gSum = gSum + group\n    if ( gSum >= 1000 ) :\n        return ( divisibleby37 ( str ( gSum ) ) )\n    else :\n        return ( gSum % 37 == 0 )\nprint ( divisibleby37 ( \"8955795758\" ) )\n", "python_code_tokenized": "def divisibleby37 ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( l % 3 == 1 ) : NEW_LINE INDENT n = \"00\" + n NEW_LINE l += 2 NEW_LINE DEDENT elif ( l % 3 == 2 ) : NEW_LINE INDENT n = \"0\" + n NEW_LINE l += 1 NEW_LINE DEDENT gSum = 0 NEW_LINE while ( l != 0 ) : NEW_LINE INDENT group = int ( n [ l - 3 : l ] ) NEW_LINE l = l - 3 NEW_LINE gSum = gSum + group NEW_LINE DEDENT if ( gSum >= 1000 ) : NEW_LINE INDENT return ( divisibleby37 ( str ( gSum ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( gSum % 37 == 0 ) NEW_LINE DEDENT DEDENT print ( divisibleby37 ( \"8955795758\" ) ) NEW_LINE"}
{"id": "codeforces_796_B", "sol": 0, "python_code": "inl = lambda : list ( map ( int , input ( ).split ( ) ) )\nn , m , k = inl ( )\nh = set ( inl ( ) )\nb = 1\nif b not in h :\n    for _ in range ( k ) :\n        u , v = inl ( )\n        if b == u or b == v :\n            b = u if b == v else v\n            if { u , v } & h :\n                break\nprint ( b )\n", "python_code_tokenized": "inl = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE n , m , k = inl ( ) NEW_LINE h = set ( inl ( ) ) NEW_LINE b = 1 NEW_LINE if b not in h : NEW_LINE INDENT for _ in range ( k ) : NEW_LINE INDENT u , v = inl ( ) NEW_LINE if b == u or b == v : NEW_LINE INDENT b = u if b == v else v NEW_LINE if { u , v } & h : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( b ) NEW_LINE"}
{"id": "geeksforgeeks_844_A", "sol": 0, "python_code": "from math import gcd\ndef startingPoint ( Length , Speed1 , Speed2 ) :\n    result1 = 0\n    result2 = 0\n    time1 = Length // Speed1\n    time2 = Length // Speed2\n    result1 = gcd ( time1 , time2 )\n    result2 = time1 * time2 // ( result1 )\n    return result2\ndef firstTime ( Length , Speed1 , Speed2 ) :\n    result = 0\n    relativeSpeed = abs ( Speed1 - Speed2 )\n    result = Length / relativeSpeed\n    return result\nif __name__ == \"__main__\" :\n    L = 30\n    S1 = 5\n    S2 = 2\n    first_Time = firstTime ( L , S1 , S2 )\n    starting_Point = startingPoint ( L , S1 , S2 )\n    print ( \"Met first time after\" , first_Time , \"hrs\" )\n    print ( \"Met at starting point after\" , starting_Point , \"hrs\" )\n", "python_code_tokenized": "from math import gcd NEW_LINE def startingPoint ( Length , Speed1 , Speed2 ) : NEW_LINE INDENT result1 = 0 NEW_LINE result2 = 0 NEW_LINE time1 = Length // Speed1 NEW_LINE time2 = Length // Speed2 NEW_LINE result1 = gcd ( time1 , time2 ) NEW_LINE result2 = time1 * time2 // ( result1 ) NEW_LINE return result2 NEW_LINE DEDENT def firstTime ( Length , Speed1 , Speed2 ) : NEW_LINE INDENT result = 0 NEW_LINE relativeSpeed = abs ( Speed1 - Speed2 ) NEW_LINE result = Length / relativeSpeed NEW_LINE return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 30 NEW_LINE S1 = 5 NEW_LINE S2 = 2 NEW_LINE first_Time = firstTime ( L , S1 , S2 ) NEW_LINE starting_Point = startingPoint ( L , S1 , S2 ) NEW_LINE print ( \" Met \u2581 first \u2581 time \u2581 after \" , first_Time , \" hrs \" ) NEW_LINE print ( \" Met \u2581 at \u2581 starting \u2581 point \u2581 after \" , starting_Point , \" hrs \" ) NEW_LINE DEDENT"}
{"id": "aizu_p01378_A", "sol": 0, "python_code": "s = input ( )\ni = s.index ( \"i\" )\ns , t = \".\" + s [ : i ] [ : : - 1 ] , \".\" + s [ i + 3 : ]\ns = s.translate ( str.maketrans ( \"(){}[]\" , \")(}{][\" ) )\nl = [ [ 0 for _ in range ( len ( s ) ) ] for _ in range ( len ( t ) ) ]\nfor i in range ( 1 , len ( t ) ) :\n    for j in range ( 1 , len ( s ) ) :\n        if t [ i ] == s [ j ] : l [ i ] [ j ] = l [ i - 1 ] [ j - 1 ] + 1\n        else : l [ i ] [ j ] = max ( l [ i - 1 ] [ j ] , l [ i ] [ j - 1 ] )\nprint ( 3 + 2 * l [ - 1 ] [ - 1 ] )\n", "python_code_tokenized": "s = input ( ) NEW_LINE i = s . index ( \" i \" ) NEW_LINE s , t = \" . \" + s [ : i ] [ : : - 1 ] , \" . \" + s [ i + 3 : ] NEW_LINE s = s . translate ( str . maketrans ( \" ( ) { } [ ] \" , \" ) ( } { ] [ \" ) ) NEW_LINE l = [ [ 0 for _ in range ( len ( s ) ) ] for _ in range ( len ( t ) ) ] NEW_LINE for i in range ( 1 , len ( t ) ) : NEW_LINE INDENT for j in range ( 1 , len ( s ) ) : NEW_LINE INDENT if t [ i ] == s [ j ] : l [ i ] [ j ] = l [ i - 1 ] [ j - 1 ] + 1 NEW_LINE else : l [ i ] [ j ] = max ( l [ i - 1 ] [ j ] , l [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT print ( 3 + 2 * l [ - 1 ] [ - 1 ] ) NEW_LINE"}
{"id": "geeksforgeeks_4316_A", "sol": 0, "python_code": "if __name__ == '__main__' :\n    space = 4\n    prt = '$'\n    for i in range ( 1 , 6 ) :\n        for sp in range ( space , 0 , - 1 ) :\n            print ( end = \"\" )\n        for j in range ( 1 , i + 1 ) :\n            print ( prt , end = \"\" )\n        for k in range ( 1 , i ) :\n            if ( i == 1 ) :\n                continue\n            print ( prt , end = \"\" )\n        print ( )\n        space -= 1\n    space = 1\n    for i in range ( 4 , 0 , - 1 ) :\n        for sp in range ( space , 0 , - 1 ) :\n            print ( end = \"\" )\n        for j in range ( 1 , i + 1 ) :\n            print ( prt , end = \"\" )\n        for k in range ( 1 , i ) :\n            print ( prt , end = \"\" )\n        space += 1\n        print ( )\n    space = 3\n    for i in range ( 2 , 6 ) :\n        if ( ( i % 2 ) != 0 ) :\n            for sp in range ( space , 0 , - 1 ) :\n                print ( \"\" , end = \"\" )\n            for j in range ( 1 , i + 1 ) :\n                print ( prt , end = \"\" )\n        if ( ( i % 2 ) != 0 ) :\n            print ( )\n            space -= 1\n", "python_code_tokenized": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT space = 4 NEW_LINE prt = ' $ ' NEW_LINE for i in range ( 1 , 6 ) : NEW_LINE INDENT for sp in range ( space , 0 , - 1 ) : NEW_LINE INDENT print ( end = \" \u2581 \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT for k in range ( 1 , i ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT print ( prt , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE space -= 1 NEW_LINE DEDENT space = 1 NEW_LINE for i in range ( 4 , 0 , - 1 ) : NEW_LINE INDENT for sp in range ( space , 0 , - 1 ) : NEW_LINE INDENT print ( end = \" \u2581 \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT space += 1 NEW_LINE print ( ) NEW_LINE DEDENT space = 3 NEW_LINE for i in range ( 2 , 6 ) : NEW_LINE INDENT if ( ( i % 2 ) != 0 ) : NEW_LINE INDENT for sp in range ( space , 0 , - 1 ) : NEW_LINE INDENT print ( \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT DEDENT if ( ( i % 2 ) != 0 ) : NEW_LINE INDENT print ( ) NEW_LINE space -= 1 NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_4559_A", "sol": 0, "python_code": "import math\ndef isPowerful ( n ) :\n    while ( n % 2 == 0 ) :\n        power = 0\n        while ( n % 2 == 0 ) :\n            n = n // 2\n            power = power + 1\n        if ( power == 1 ) :\n            return False\n    for factor in range ( 3 , int ( math.sqrt ( n ) ) + 1 , 2 ) :\n        power = 0\n        while ( n % factor == 0 ) :\n            n = n // factor\n            power = power + 1\n        if ( power == 1 ) :\n            return false\n    return ( n == 1 )\nprint ( \"YES\" if isPowerful ( 20 ) else \"NO\" )\nprint ( \"YES\" if isPowerful ( 27 ) else \"NO\" )\n", "python_code_tokenized": "import math NEW_LINE def isPowerful ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE power = power + 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for factor in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % factor == 0 ) : NEW_LINE INDENT n = n // factor NEW_LINE power = power + 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT return ( n == 1 ) NEW_LINE DEDENT print ( \" YES \" if isPowerful ( 20 ) else \" NO \" ) NEW_LINE print ( \" YES \" if isPowerful ( 27 ) else \" NO \" ) NEW_LINE"}
{"id": "aizu_p00630_A", "sol": 0, "python_code": "while True :\n    a , b = input ( ).split ( )\n    if b == 'X' :\n        break\n    if '_' in a :\n        ans = a.split ( '_' )\n    else :\n        ans = [ ]\n        j = 0\n        for i in range ( 1 , len ( a ) ) :\n            if a [ i ].isupper ( ) :\n                ans.append ( a [ j : i ] )\n                j = i\n        ans.append ( a [ j : ] )\n    if b == 'D' :\n        ans = '_'.join ( map ( str.lower , ans ) )\n    else :\n        ans = ''.join ( map ( str.capitalize , ans ) )\n        if b == 'L' :\n            ans = ans [ 0 ].lower ( ) + ans [ 1 : ]\n    print ( ans )\n", "python_code_tokenized": "while True : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE if b == ' X ' : NEW_LINE INDENT break NEW_LINE DEDENT if ' _ ' in a : NEW_LINE INDENT ans = a . split ( ' _ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = [ ] NEW_LINE j = 0 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT if a [ i ] . isupper ( ) : NEW_LINE INDENT ans . append ( a [ j : i ] ) NEW_LINE j = i NEW_LINE DEDENT DEDENT ans . append ( a [ j : ] ) NEW_LINE DEDENT if b == ' D ' : NEW_LINE INDENT ans = ' _ ' . join ( map ( str . lower , ans ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ' ' . join ( map ( str . capitalize , ans ) ) NEW_LINE if b == ' L ' : NEW_LINE INDENT ans = ans [ 0 ] . lower ( ) + ans [ 1 : ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3685_A", "sol": 0, "python_code": "import math\ndef area_of_regular_polygon ( n , len ) :\n    P = ( len * n ) ;\n    A = len / ( 2 * math.tan ( ( 180 / n ) * 3.14159 / 180 ) )\n    area = ( P * A ) / 2\n    return area\ndef area_of_triangle_inscribed ( n , len ) :\n    area = area_of_regular_polygon ( n , len )\n    triangle = area / n\n    ins_tri = ( triangle * 3 ) ;\n    return ins_tri\nn = 6\nlen = 10\nprint ( round ( area_of_triangle_inscribed ( n , len ) , 3 ) )\n", "python_code_tokenized": "import math NEW_LINE def area_of_regular_polygon ( n , len ) : NEW_LINE INDENT P = ( len * n ) ; NEW_LINE A = len / ( 2 * math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE area = ( P * A ) / 2 NEW_LINE return area NEW_LINE DEDENT def area_of_triangle_inscribed ( n , len ) : NEW_LINE INDENT area = area_of_regular_polygon ( n , len ) NEW_LINE triangle = area / n NEW_LINE ins_tri = ( triangle * 3 ) ; NEW_LINE return ins_tri NEW_LINE DEDENT n = 6 NEW_LINE len = 10 NEW_LINE print ( round ( area_of_triangle_inscribed ( n , len ) , 3 ) ) NEW_LINE"}
{"id": "geeksforgeeks_3698_A", "sol": 0, "python_code": "if __name__ == \"__main__\" :\n    x1 , x2 , x3 = 1 , 3 , 6\n    y1 , y2 , y3 = 2 , - 4 , - 7\n    x = round ( ( x1 + x2 + x3 ) / 3 , 2 )\n    y = round ( ( y1 + y2 + y3 ) / 3 , 2 )\n    print ( \"Centroid =\",\"(\" , x , \",\" , y , \")\" )\n", "python_code_tokenized": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x1 , x2 , x3 = 1 , 3 , 6 NEW_LINE y1 , y2 , y3 = 2 , - 4 , - 7 NEW_LINE x = round ( ( x1 + x2 + x3 ) / 3 , 2 ) NEW_LINE y = round ( ( y1 + y2 + y3 ) / 3 , 2 ) NEW_LINE print ( \" Centroid \u2581 = \" , \" ( \" , x , \" , \" , y , \" ) \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4371_A", "sol": 0, "python_code": "def reverseArray ( arr , n ) :\n    for i in range ( n // 2 ) :\n        arr [ i ] , arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] = arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] , arr [ i ]\narr = [ 5 , 3 , 7 , 2 , 1 , 6 ]\nn = len ( arr )\nreverseArray ( arr , n )\nfor i in range ( n ) :\n    print ( arr [ i ] , end = \" \" )\n", "python_code_tokenized": "def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( n // 2 ) : NEW_LINE INDENT arr [ i ] , arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] = arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_389_A", "sol": 0, "python_code": "def smallestString ( N , A ) :\n    ch = 'a'\n    S = \"\"\n    if ( N < 1 or A [ 0 ] != 1 ) :\n        S = \"-1\"\n        return S\n    S += str ( ch )\n    ch = chr ( ord ( ch ) + 1 )\n    for i in range ( 1 , N ) :\n        diff = A [ i ] - A [ i - 1 ]\n        if ( diff > 1 or diff < 0 or A [ i ] > 26 ) :\n            S = \"-1\"\n            return S\n        elif ( diff == 0 ) :\n            S += 'a'\n        else :\n            S += ch\n            ch = chr ( ord ( ch ) + 1 )\n    return S\narr = [ 1 , 1 , 2 , 3 , 3 ]\nn = len ( arr )\nprint ( smallestString ( n , arr ) )\n", "python_code_tokenized": "def smallestString ( N , A ) : NEW_LINE INDENT ch = ' a ' NEW_LINE S = \" \" NEW_LINE if ( N < 1 or A [ 0 ] != 1 ) : NEW_LINE INDENT S = \" - 1\" NEW_LINE return S NEW_LINE DEDENT S += str ( ch ) NEW_LINE ch = chr ( ord ( ch ) + 1 ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT diff = A [ i ] - A [ i - 1 ] NEW_LINE if ( diff > 1 or diff < 0 or A [ i ] > 26 ) : NEW_LINE INDENT S = \" - 1\" NEW_LINE return S NEW_LINE DEDENT elif ( diff == 0 ) : NEW_LINE INDENT S += ' a ' NEW_LINE DEDENT else : NEW_LINE INDENT S += ch NEW_LINE ch = chr ( ord ( ch ) + 1 ) NEW_LINE DEDENT DEDENT return S NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( smallestString ( n , arr ) ) NEW_LINE"}
{"id": "aizu_p01473_A", "sol": 0, "python_code": "from collections import Counter\nimport math\ns = input ( )\ndic = Counter ( s )\nn_odd = 0\nfor c in dic :\n    if dic [ c ] & 1 :\n        n_odd += 1\n        if n_odd > 1 :\n            print ( 0 )\n            exit ( )\n        dic [ c ] -= 1\nans = math.factorial ( len ( s ) // 2 )\nfor num in dic.values ( ) :\n    ans //= math.factorial ( num // 2 )\nprint ( ans )\n", "python_code_tokenized": "from collections import Counter NEW_LINE import math NEW_LINE s = input ( ) NEW_LINE dic = Counter ( s ) NEW_LINE n_odd = 0 NEW_LINE for c in dic : NEW_LINE INDENT if dic [ c ] & 1 : NEW_LINE INDENT n_odd += 1 NEW_LINE if n_odd > 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT dic [ c ] -= 1 NEW_LINE DEDENT DEDENT ans = math . factorial ( len ( s ) // 2 ) NEW_LINE for num in dic . values ( ) : NEW_LINE INDENT ans //= math . factorial ( num // 2 ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_622_A", "sol": 0, "python_code": "def k_sum ( a , n , k ) :\n    r , sum = 0 , 0 ;\n    ans = 0 ;\n    for l in range ( n ) :\n        while ( sum < k ) :\n            if ( r == n ) :\n                break ;\n            else :\n                sum += a [ r ] ;\n                r += 1 ;\n        if ( sum < k ) :\n            break ;\n        ans += n - r + 1 ;\n        sum -= a [ l ] ;\n    return ans ;\na = [ 6 , 1 , 2 , 7 ] ; k = 10 ;\nn = len ( a ) ;\nprint ( k_sum ( a , n , k ) ) ;\n", "python_code_tokenized": "def k_sum ( a , n , k ) : NEW_LINE INDENT r , sum = 0 , 0 ; NEW_LINE ans = 0 ; NEW_LINE for l in range ( n ) : NEW_LINE INDENT while ( sum < k ) : NEW_LINE INDENT if ( r == n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT else : NEW_LINE INDENT sum += a [ r ] ; NEW_LINE r += 1 ; NEW_LINE DEDENT DEDENT if ( sum < k ) : NEW_LINE INDENT break ; NEW_LINE DEDENT ans += n - r + 1 ; NEW_LINE sum -= a [ l ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT a = [ 6 , 1 , 2 , 7 ] ; k = 10 ; NEW_LINE n = len ( a ) ; NEW_LINE print ( k_sum ( a , n , k ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_4160_A", "sol": 0, "python_code": "def findLastIndex ( str , x ) :\n    for i in range ( len ( str ) - 1 , - 1 , - 1 ) :\n        if ( str [ i ] == x ) :\n            return i\n    return - 1\nstr = \"geeksforgeeks\"\nx = 'e'\nindex = findLastIndex ( str , x )\nif ( index == - 1 ) :\n    print ( \"Character not found\" )\nelse :\n    print ( \"Last index is \" , index )\n", "python_code_tokenized": "def findLastIndex ( str , x ) : NEW_LINE INDENT for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE x = ' e ' NEW_LINE index = findLastIndex ( str , x ) NEW_LINE if ( index == - 1 ) : NEW_LINE INDENT print ( \" Character \u2581 not \u2581 found \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Last \u2581 index \u2581 is \u2581 \" , index ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4159_A", "sol": 0, "python_code": "def findLastIndex ( str , x ) :\n    index = - 1\n    for i in range ( 0 , len ( str ) ) :\n        if str [ i ] == x :\n            index = i\n    return index\nstr = \"geeksforgeeks\"\nx = 'e'\nindex = findLastIndex ( str , x )\nif index == - 1 :\n    print ( \"Character not found\" )\nelse :\n    print ( 'Last index is' , index )\n", "python_code_tokenized": "def findLastIndex ( str , x ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if str [ i ] == x : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE x = ' e ' NEW_LINE index = findLastIndex ( str , x ) NEW_LINE if index == - 1 : NEW_LINE INDENT print ( \" Character \u2581 not \u2581 found \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Last \u2581 index \u2581 is ' , index ) NEW_LINE DEDENT"}
{"id": "codeforces_1428_B", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nfor _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    s = input ( ) [ : - 1 ]\n    c1 , c2 , d , e = 0 , 0 , 0 , 0\n    for i in range ( n - 1 ) :\n        if s [ i ] == '-' :\n            if d == 0 :\n                e += 2\n            else :\n                e += 1\n            d = 1\n        elif s [ i ] == '>' :\n            c1 = 1\n            d = 0\n        else :\n            c2 = 1\n            d = 0\n    if s [ - 1 ] == '-' :\n        e += 2\n        if s [ - 2 ] == '-' :\n            e -= 1\n        if s [ 0 ] == '-' :\n            e -= 1\n    elif s [ - 1 ] == '>' :\n        c1 = 1\n    else :\n        c2 = 1\n    if c1 == 0 or c2 == 0 :\n        print ( n )\n    else :\n        print ( e )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) [ : - 1 ] NEW_LINE c1 , c2 , d , e = 0 , 0 , 0 , 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] == ' - ' : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT e += 2 NEW_LINE DEDENT else : NEW_LINE INDENT e += 1 NEW_LINE DEDENT d = 1 NEW_LINE DEDENT elif s [ i ] == ' > ' : NEW_LINE INDENT c1 = 1 NEW_LINE d = 0 NEW_LINE DEDENT else : NEW_LINE INDENT c2 = 1 NEW_LINE d = 0 NEW_LINE DEDENT DEDENT if s [ - 1 ] == ' - ' : NEW_LINE INDENT e += 2 NEW_LINE if s [ - 2 ] == ' - ' : NEW_LINE INDENT e -= 1 NEW_LINE DEDENT if s [ 0 ] == ' - ' : NEW_LINE INDENT e -= 1 NEW_LINE DEDENT DEDENT elif s [ - 1 ] == ' > ' : NEW_LINE INDENT c1 = 1 NEW_LINE DEDENT else : NEW_LINE INDENT c2 = 1 NEW_LINE DEDENT if c1 == 0 or c2 == 0 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_5049_A", "sol": 0, "python_code": "bin = [ \"000\" , \"001\" , \"010\" , \"011\" , \"100\" , \"101\" , \"110\" , \"111\" ] ;\ndef maxFreq ( s ) :\n    binary = \"\" ;\n    for i in range ( len ( s ) ) :\n        binary += bin [ ord ( s [ i ] ) - ord ( '0' ) ] ;\n    binary = binary [ 0 : len ( binary ) - 1 ] ;\n    count = 1 ; prev = - 1 ; j = 0 ;\n    for i in range ( len ( binary ) - 1 , - 1 , - 1 ) :\n        if ( binary [ i ] == '1' ) :\n            count = max ( count , j - prev ) ;\n            prev = j ;\n        j += 1 ;\n    return count ;\nif __name__ == \"__main__\" :\n    octal = \"13\" ;\n    print ( maxFreq ( octal ) ) ;\n", "python_code_tokenized": "bin = [ \"000\" , \"001\" , \"010\" , \"011\" , \"100\" , \"101\" , \"110\" , \"111\" ] ; NEW_LINE def maxFreq ( s ) : NEW_LINE INDENT binary = \" \" ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT binary += bin [ ord ( s [ i ] ) - ord ( '0' ) ] ; NEW_LINE DEDENT binary = binary [ 0 : len ( binary ) - 1 ] ; NEW_LINE count = 1 ; prev = - 1 ; j = 0 ; NEW_LINE for i in range ( len ( binary ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( binary [ i ] == '1' ) : NEW_LINE INDENT count = max ( count , j - prev ) ; NEW_LINE prev = j ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT octal = \"13\" ; NEW_LINE print ( maxFreq ( octal ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3140_A", "sol": 0, "python_code": "def arraySortedOrNot ( arr ) :\n    n = len ( arr )\n    if n == 1 or n == 0 :\n        return True\n    return arr [ 0 ] <= arr [ 1 ] and arraySortedOrNot ( arr [ 1 : ] )\narr = [ 20 , 23 , 23 , 45 , 78 , 88 ]\nif arraySortedOrNot ( arr ) : print ( \"Yes\" )\nelse : print ( \"No\" )\n", "python_code_tokenized": "def arraySortedOrNot ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE if n == 1 or n == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return arr [ 0 ] <= arr [ 1 ] and arraySortedOrNot ( arr [ 1 : ] ) NEW_LINE DEDENT arr = [ 20 , 23 , 23 , 45 , 78 , 88 ] NEW_LINE if arraySortedOrNot ( arr ) : print ( \" Yes \" ) NEW_LINE else : print ( \" No \" ) NEW_LINE"}
{"id": "geeksforgeeks_3491_A", "sol": 0, "python_code": "def items ( n , a ) :\n    a.sort ( )\n    z = a [ n - 1 ]\n    x = 1\n    s = 0\n    for i in range ( 0 , n - 1 ) :\n        s += a [ i ]\n        if ( s <= z ) :\n            x += 1\n        else :\n            break\n    return x\nn = 5\na = [ 5 , 3 , 1 , 5 , 6 ]\nprint ( items ( n , a ) )\n", "python_code_tokenized": "def items ( n , a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE z = a [ n - 1 ] NEW_LINE x = 1 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT s += a [ i ] NEW_LINE if ( s <= z ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT n = 5 NEW_LINE a = [ 5 , 3 , 1 , 5 , 6 ] NEW_LINE print ( items ( n , a ) ) NEW_LINE"}
{"id": "atcoder_ARC084_B", "sol": 0, "python_code": "from collections import deque\nK = int ( input ( ) )\nd = { 1 : 1 }\nq = deque ( )\nq.append ( [ 1 , 1 ] )\nwhile q :\n    a , c = q.popleft ( )\n    a_ = ( a * 10 ) % K\n    if ( a_ not in d or c < d [ a_ ] ) :\n        d [ a_ ] = c\n        q.appendleft ( [ a_ , c ] )\n    b_ = ( a + 1 ) % K\n    if ( b_ not in d or c < d [ b_ ] ) :\n        d [ b_ ] = c + 1\n        q.append ( [ b_ , c + 1 ] )\nprint ( d [ 0 ] )\n", "python_code_tokenized": "from collections import deque NEW_LINE K = int ( input ( ) ) NEW_LINE d = { 1 : 1 } NEW_LINE q = deque ( ) NEW_LINE q . append ( [ 1 , 1 ] ) NEW_LINE while q : NEW_LINE INDENT a , c = q . popleft ( ) NEW_LINE a_ = ( a * 10 ) % K NEW_LINE if ( a_ not in d or c < d [ a_ ] ) : NEW_LINE INDENT d [ a_ ] = c NEW_LINE q . appendleft ( [ a_ , c ] ) NEW_LINE DEDENT b_ = ( a + 1 ) % K NEW_LINE if ( b_ not in d or c < d [ b_ ] ) : NEW_LINE INDENT d [ b_ ] = c + 1 NEW_LINE q . append ( [ b_ , c + 1 ] ) NEW_LINE DEDENT DEDENT print ( d [ 0 ] ) NEW_LINE"}
{"id": "geeksforgeeks_459_A", "sol": 0, "python_code": "def numberOfPaths ( p , q ) :\n    dp = [ 1 for i in range ( q ) ]\n    for i in range ( p - 1 ) :\n        for j in range ( 1 , q ) :\n            dp [ j ] += dp [ j - 1 ]\n    return dp [ q - 1 ]\nprint ( numberOfPaths ( 3 , 3 ) )\n", "python_code_tokenized": "def numberOfPaths ( p , q ) : NEW_LINE INDENT dp = [ 1 for i in range ( q ) ] NEW_LINE for i in range ( p - 1 ) : NEW_LINE INDENT for j in range ( 1 , q ) : NEW_LINE INDENT dp [ j ] += dp [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ q - 1 ] NEW_LINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) NEW_LINE"}
{"id": "projecteuler_p146_A", "sol": 0, "python_code": "import eulerlib\ndef compute ( ) :\n    LIMIT = 150000000\n    INCREMENTS = [ 1 , 3 , 7 , 9 , 13 , 27 ]\n    NON_INCREMENTS = set ( range ( INCREMENTS [ - 1 ] ) ) - set ( INCREMENTS )\n    maxnumber = LIMIT ** 2 + INCREMENTS [ - 1 ]\n    primes = eulerlib.list_primes ( eulerlib.sqrt ( maxnumber ) )\n    def has_consecutive_primes ( n ) :\n        n2 = n ** 2\n        temp = [ ( n2 + k ) for k in INCREMENTS ]\n        if any ( ( x != p and x % p == 0 ) for p in primes for x in temp ) :\n            return False\n        return all ( ( not is_prime ( n2 + k ) ) for k in NON_INCREMENTS )\n    def is_prime ( n ) :\n        end = eulerlib.sqrt ( n )\n        for p in primes :\n            if p > end :\n                break\n            if n % p == 0 :\n                return False\n        return True\n    ans = sum ( n for n in range ( 0 , LIMIT , 10 ) if has_consecutive_primes ( n ) )\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 150000000 NEW_LINE INCREMENTS = [ 1 , 3 , 7 , 9 , 13 , 27 ] NEW_LINE NON_INCREMENTS = set ( range ( INCREMENTS [ - 1 ] ) ) - set ( INCREMENTS ) NEW_LINE maxnumber = LIMIT ** 2 + INCREMENTS [ - 1 ] NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( maxnumber ) ) NEW_LINE def has_consecutive_primes ( n ) : NEW_LINE INDENT n2 = n ** 2 NEW_LINE temp = [ ( n2 + k ) for k in INCREMENTS ] NEW_LINE if any ( ( x != p and x % p == 0 ) for p in primes for x in temp ) : NEW_LINE INDENT return False NEW_LINE DEDENT return all ( ( not is_prime ( n2 + k ) ) for k in NON_INCREMENTS ) NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT end = eulerlib . sqrt ( n ) NEW_LINE for p in primes : NEW_LINE INDENT if p > end : NEW_LINE INDENT break NEW_LINE DEDENT if n % p == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT ans = sum ( n for n in range ( 0 , LIMIT , 10 ) if has_consecutive_primes ( n ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1433_B", "sol": 0, "python_code": "if __name__ == \"__main__\" :\n    for _ in range ( int ( input ( ) ) ) :\n        n = int ( input ( ) )\n        bookshelf = list ( map ( int , input ( ).split ( ) ) )\n        l , r = 0 , n - 1\n        idxOneL , idxOneR = None , None\n        while l <= r :\n            if idxOneL != None and idxOneR != None :\n                print ( bookshelf [ idxOneL : idxOneR ].count ( 0 ) )\n                break\n            if idxOneL == None :\n                if bookshelf [ l ] == 1 :\n                    idxOneL = l\n                else :\n                    l += 1\n            if idxOneR == None :\n                if bookshelf [ r ] == 1 :\n                    idxOneR = r\n                else :\n                    r -= 1\n", "python_code_tokenized": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE bookshelf = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l , r = 0 , n - 1 NEW_LINE idxOneL , idxOneR = None , None NEW_LINE while l <= r : NEW_LINE INDENT if idxOneL != None and idxOneR != None : NEW_LINE INDENT print ( bookshelf [ idxOneL : idxOneR ] . count ( 0 ) ) NEW_LINE break NEW_LINE DEDENT if idxOneL == None : NEW_LINE INDENT if bookshelf [ l ] == 1 : NEW_LINE INDENT idxOneL = l NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT if idxOneR == None : NEW_LINE INDENT if bookshelf [ r ] == 1 : NEW_LINE INDENT idxOneR = r NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT"}
{"id": "codeforces_606_A", "sol": 0, "python_code": "l1 = list ( map ( int , input ( ).split ( ) ) )\nl2 = list ( map ( int , input ( ).split ( ) ) )\nspp = 0\nspn = 0\nspn = max ( l2 [ 0 ] - l1 [ 0 ] , 0 ) + max ( l2 [ 1 ] - l1 [ 1 ] , 0 ) + max ( l2 [ 2 ] - l1 [ 2 ] , 0 )\nspp = int ( max ( ( l1 [ 0 ] - l2 [ 0 ] ) / 2 , 0 ) ) + int ( max ( ( l1 [ 1 ] - l2 [ 1 ] ) / 2 , 0 ) ) + int ( max ( ( l1 [ 2 ] - l2 [ 2 ] ) / 2 , 0 ) )\nif spp >= spn :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "l1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l2 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE spp = 0 NEW_LINE spn = 0 NEW_LINE spn = max ( l2 [ 0 ] - l1 [ 0 ] , 0 ) + max ( l2 [ 1 ] - l1 [ 1 ] , 0 ) + max ( l2 [ 2 ] - l1 [ 2 ] , 0 ) NEW_LINE spp = int ( max ( ( l1 [ 0 ] - l2 [ 0 ] ) / 2 , 0 ) ) + int ( max ( ( l1 [ 1 ] - l2 [ 1 ] ) / 2 , 0 ) ) + int ( max ( ( l1 [ 2 ] - l2 [ 2 ] ) / 2 , 0 ) ) NEW_LINE if spp >= spn : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4118_A", "sol": 0, "python_code": "def check ( s ) :\n    freq = [ 0 ] * 26\n    n = len ( s )\n    for i in range ( n ) :\n        freq [ ord ( s [ i ] ) - 97 ] += 1\n    for i in range ( 26 ) :\n        if ( freq [ i ] % 2 == 1 ) :\n            return False\n    return True\ns = \"abaccaba\"\nif ( check ( s ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" abaccaba \" NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1939_A", "sol": 0, "python_code": "def check ( s ) :\n    n = len ( s )\n    for i in range ( n - 1 ) :\n        if ( s [ i ] > s [ i + 1 ] ) :\n            return True\n    return False\nif __name__ == '__main__' :\n    s = \"geeksforgeeks\"\n    if ( check ( s ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def check ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2874_A", "sol": 0, "python_code": "def isAlphabaticOrder ( s ) :\n    n = len ( s )\n    for i in range ( 1 , n ) :\n        if ( s [ i ] < s [ i - 1 ] ) :\n            return False\n    return True\nif __name__ == \"__main__\" :\n    s = \"aabbbcc\"\n    if ( isAlphabaticOrder ( s ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] < s [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aabbbcc \" NEW_LINE if ( isAlphabaticOrder ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3216_A", "sol": 0, "python_code": "def findFrequencyUtil ( arr , low , high , freq ) :\n    if ( arr [ low ] == arr [ high ] ) :\n        freq [ arr [ low ] ] += high - low + 1\n    else :\n        mid = int ( ( low + high ) / 2 )\n        findFrequencyUtil ( arr , low , mid , freq )\n        findFrequencyUtil ( arr , mid + 1 , high , freq )\ndef findFrequency ( arr , n ) :\n    freq = [ 0 for i in range ( n - 1 + 1 ) ]\n    findFrequencyUtil ( arr , 0 , n - 1 , freq )\n    for i in range ( 0 , arr [ n - 1 ] + 1 , 1 ) :\n        if ( freq [ i ] != 0 ) :\n            print ( \"Element\" , i , \"occurs\" , freq [ i ] , \"times\" )\nif __name__ == '__main__' :\n    arr = [ 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 8 , 9 , 9 , 10 ]\n    n = len ( arr )\n    findFrequency ( arr , n )\n", "python_code_tokenized": "def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE findFrequencyUtil ( arr , low , mid , freq ) NEW_LINE findFrequencyUtil ( arr , mid + 1 , high , freq ) NEW_LINE DEDENT DEDENT def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( n - 1 + 1 ) ] NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , freq ) NEW_LINE for i in range ( 0 , arr [ n - 1 ] + 1 , 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT print ( \" Element \" , i , \" occurs \" , freq [ i ] , \" times \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 8 , 9 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE findFrequency ( arr , n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2188_A", "sol": 0, "python_code": "def countPairs ( a , b , n , m ) :\n    cnt = 0\n    s = dict ( )\n    for i in range ( n ) :\n        for j in range ( m ) :\n            sum = a [ i ] + b [ j ]\n            if ( sum not in s.keys ( ) ) :\n                cnt += 1\n                s [ sum ] = 1\n    return cnt\na = [ 12 , 2 , 7 ]\nn = len ( a )\nb = [ 4 , 3 , 8 ]\nm = len ( b )\nprint ( countPairs ( a , b , n , m ) )\n", "python_code_tokenized": "def countPairs ( a , b , n , m ) : NEW_LINE INDENT cnt = 0 NEW_LINE s = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT sum = a [ i ] + b [ j ] NEW_LINE if ( sum not in s . keys ( ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE s [ sum ] = 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT a = [ 12 , 2 , 7 ] NEW_LINE n = len ( a ) NEW_LINE b = [ 4 , 3 , 8 ] NEW_LINE m = len ( b ) NEW_LINE print ( countPairs ( a , b , n , m ) ) NEW_LINE"}
{"id": "codeforces_1196_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n , k = map ( int , input ( ).split ( ) )\n    arr = list ( map ( int , input ( ).split ( ) ) )\n    count = sum ( x % 2 for x in arr )\n    if count < k or count % 2 != k % 2 :\n        print ( \"NO\" )\n    else :\n        print ( \"YES\" )\n        i = 0\n        while k > 1 :\n            if arr [ i ] % 2 :\n                print ( i + 1 , end = \" \" )\n                k -= 1\n            i += 1\n        print ( n )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = sum ( x % 2 for x in arr ) NEW_LINE if count < k or count % 2 != k % 2 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE i = 0 NEW_LINE while k > 1 : NEW_LINE INDENT if arr [ i ] % 2 : NEW_LINE INDENT print ( i + 1 , end = \" \u2581 \" ) NEW_LINE k -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( n ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_195_B", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nprint ( * ( ( m + 1 ) // 2 + ( 1 - 2 * ( ( m - 1 + i % m ) % 2 ) ) * ( ( 1 + i % m ) // 2 ) for i in range ( n ) ) , sep = '\\n' )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( * ( ( m + 1 ) // 2 + ( 1 - 2 * ( ( m - 1 + i % m ) % 2 ) ) * ( ( 1 + i % m ) // 2 ) for i in range ( n ) ) , sep = ' \\n ' ) NEW_LINE"}
{"id": "codeforces_1603_B", "sol": 0, "python_code": "import math , sys\nfrom collections import defaultdict , deque\nimport bisect as bi\ndef yes ( ) : print ( 'YES' )\ndef no ( ) : print ( 'NO' )\ndef I ( ) : return ( int ( sys.stdin.readline ( ) ) )\ndef In ( ) : return ( map ( int , sys.stdin.readline ( ).split ( ) ) )\ndef Sn ( ) : return sys.stdin.readline ( ).strip ( )\ndef dict ( a ) :\n    d = { }\n    for x in a :\n        if d.get ( x , - 1 ) != - 1 :\n            d [ x ] += 1\n        else :\n            d [ x ] = 1\n    return d\ndef find_gt ( a , x ) :\n    i = bi.bisect_left ( a , x )\n    if i != len ( a ) :\n        return i\n    else :\n        return - 1\ndef main ( ) :\n    try :\n        a , b = In ( )\n        if a > b :\n            print ( a + b )\n        else :\n            print ( b - ( b % a ) // 2 )\n    except :\n        pass\nM = 998244353\nP = 1000000007\nif __name__ == '__main__' :\n    for _ in range ( I ( ) ) : main ( )\n", "python_code_tokenized": "import math , sys NEW_LINE from collections import defaultdict , deque NEW_LINE import bisect as bi NEW_LINE def yes ( ) : print ( ' YES ' ) NEW_LINE def no ( ) : print ( ' NO ' ) NEW_LINE def I ( ) : return ( int ( sys . stdin . readline ( ) ) ) NEW_LINE def In ( ) : return ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def Sn ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def dict ( a ) : NEW_LINE INDENT d = { } NEW_LINE for x in a : NEW_LINE INDENT if d . get ( x , - 1 ) != - 1 : NEW_LINE INDENT d [ x ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ x ] = 1 NEW_LINE DEDENT DEDENT return d NEW_LINE DEDENT def find_gt ( a , x ) : NEW_LINE INDENT i = bi . bisect_left ( a , x ) NEW_LINE if i != len ( a ) : NEW_LINE INDENT return i NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT try : NEW_LINE INDENT a , b = In ( ) NEW_LINE if a > b : NEW_LINE INDENT print ( a + b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b - ( b % a ) // 2 ) NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT M = 998244353 NEW_LINE P = 1000000007 NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT for _ in range ( I ( ) ) : main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3458_A", "sol": 0, "python_code": "def minInt ( str1 ) :\n    for i in range ( len ( str1 ) ) :\n        if ( str1 [ i ] >= 5 ) :\n            str1 [ i ] = ( 9 - str1 [ i ] )\n    if ( str1 [ 0 ] == 0 ) :\n        str1 [ 0 ] = 9\n    temp = \"\"\n    for i in str1 :\n        temp += str ( i )\n    return temp\nstr1 = \"589\"\nstr1 = [ int ( i ) for i in str1 ]\nprint ( minInt ( str1 ) )\n", "python_code_tokenized": "def minInt ( str1 ) : NEW_LINE INDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] >= 5 ) : NEW_LINE INDENT str1 [ i ] = ( 9 - str1 [ i ] ) NEW_LINE DEDENT DEDENT if ( str1 [ 0 ] == 0 ) : NEW_LINE INDENT str1 [ 0 ] = 9 NEW_LINE DEDENT temp = \" \" NEW_LINE for i in str1 : NEW_LINE INDENT temp += str ( i ) NEW_LINE DEDENT return temp NEW_LINE DEDENT str1 = \"589\" NEW_LINE str1 = [ int ( i ) for i in str1 ] NEW_LINE print ( minInt ( str1 ) ) NEW_LINE"}
{"id": "geeksforgeeks_1979_A", "sol": 0, "python_code": "def xorGivenSetBits ( arr , n , k ) :\n    v = [ ]\n    for i in range ( 0 , n , 1 ) :\n        if ( bin ( arr [ i ] ).count ( '1' ) == k ) :\n            v.append ( arr [ i ] )\n    result = v [ 0 ]\n    for i in range ( 1 , len ( v ) , 1 ) :\n        result = result ^ v [ i ]\n    return result\nif __name__ == '__main__' :\n    arr = [ 2 , 13 , 1 , 19 , 7 ]\n    n = len ( arr )\n    k = 3\n    print ( xorGivenSetBits ( arr , n , k ) )\n", "python_code_tokenized": "def xorGivenSetBits ( arr , n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) == k ) : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT result = v [ 0 ] NEW_LINE for i in range ( 1 , len ( v ) , 1 ) : NEW_LINE INDENT result = result ^ v [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 13 , 1 , 19 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( xorGivenSetBits ( arr , n , k ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC162_B", "sol": 0, "python_code": "N = int ( input ( ) )\nL_prime = [ j for j in range ( 1 , N + 1 ) if j % 3 != 0 and j % 5 != 0 ]\nprint ( sum ( L_prime ) )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE L_prime = [ j for j in range ( 1 , N + 1 ) if j % 3 != 0 and j % 5 != 0 ] NEW_LINE print ( sum ( L_prime ) ) NEW_LINE"}
{"id": "geeksforgeeks_3650_A", "sol": 0, "python_code": "def getmax ( arr , n , x ) :\n    s = 0\n    for i in range ( n ) :\n        s = s + arr [ i ]\n    print ( min ( s , x ) )\nif __name__ == '__main__' :\n    arr = [ 1 , 2 , 3 , 4 ]\n    x = 5\n    arr_size = len ( arr )\n    getmax ( arr , arr_size , x )\n", "python_code_tokenized": "def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4265_A", "sol": 0, "python_code": "isPrime = [ 1 ] * 100005\ndef sieveOfEratostheneses ( ) :\n    isPrime [ 1 ] = False\n    i = 2\n    while i * i < 100005 :\n        if ( isPrime [ i ] ) :\n            j = 2 * i\n            while j < 100005 :\n                isPrime [ j ] = False\n                j += i\n        i += 1\n    return\ndef findPrime ( n ) :\n    num = n + 1\n    while ( num ) :\n        if isPrime [ num ] :\n            return num\n        num += 1\n    return 0\ndef minNumber ( arr ) :\n    sieveOfEratostheneses ( )\n    s = 0\n    for i in range ( 0 , len ( arr ) ) :\n        s += arr [ i ]\n    if isPrime [ s ] == True :\n        return 0\n    num = findPrime ( s )\n    return num - s\narr = [ 2 , 4 , 6 , 8 , 12 ]\nprint ( minNumber ( arr ) )\n", "python_code_tokenized": "isPrime = [ 1 ] * 100005 NEW_LINE def sieveOfEratostheneses ( ) : NEW_LINE INDENT isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i < 100005 : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT j = 2 * i NEW_LINE while j < 100005 : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num ) : NEW_LINE INDENT if isPrime [ num ] : NEW_LINE INDENT return num NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr ) : NEW_LINE INDENT sieveOfEratostheneses ( ) NEW_LINE s = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT if isPrime [ s ] == True : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( s ) NEW_LINE return num - s NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE print ( minNumber ( arr ) ) NEW_LINE"}
{"id": "codeforces_887_A", "sol": 0, "python_code": "s = input ( )\nif s [ 0 ] == '0' :\n    c = 0\n    for i in s :\n        if i == '0' :\n            c += 1\n        if i == '1' :\n            break\n    s = s [ c : ]\na = s.count ( '0' )\nb = s.count ( '1' )\nif b == 1 and a == 6 and s.count ( '1000000' ) == 0 :\n    print ( 'no' )\nelif b >= 1 and a >= 6 :\n    print ( 'yes' )\nelse :\n    print ( 'no' )\n", "python_code_tokenized": "s = input ( ) NEW_LINE if s [ 0 ] == '0' : NEW_LINE INDENT c = 0 NEW_LINE for i in s : NEW_LINE INDENT if i == '0' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if i == '1' : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT s = s [ c : ] NEW_LINE DEDENT a = s . count ( '0' ) NEW_LINE b = s . count ( '1' ) NEW_LINE if b == 1 and a == 6 and s . count ( '1000000' ) == 0 : NEW_LINE INDENT print ( ' no ' ) NEW_LINE DEDENT elif b >= 1 and a >= 6 : NEW_LINE INDENT print ( ' yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' no ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3229_A", "sol": 0, "python_code": "def maxEvenLenSum ( arr , n ) :\n    if ( n < 2 ) :\n        return 0\n    dp = [ 0 for i in range ( n ) ]\n    dp [ n - 1 ] = 0\n    dp [ n - 2 ] = arr [ n - 2 ] + arr [ n - 1 ]\n    for i in range ( n - 3 , - 1 , - 1 ) :\n        dp [ i ] = arr [ i ] + arr [ i + 1 ]\n        if ( dp [ i + 2 ] > 0 ) :\n            dp [ i ] += dp [ i + 2 ]\n    maxSum = max ( dp )\n    return maxSum\narr = [ 8 , 9 , - 8 , 9 , 10 ]\nn = len ( arr )\nprint ( maxEvenLenSum ( arr , n ) )\n", "python_code_tokenized": "def maxEvenLenSum ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ 0 for i in range ( n ) ] NEW_LINE dp [ n - 1 ] = 0 NEW_LINE dp [ n - 2 ] = arr [ n - 2 ] + arr [ n - 1 ] NEW_LINE for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] = arr [ i ] + arr [ i + 1 ] NEW_LINE if ( dp [ i + 2 ] > 0 ) : NEW_LINE INDENT dp [ i ] += dp [ i + 2 ] NEW_LINE DEDENT DEDENT maxSum = max ( dp ) NEW_LINE return maxSum NEW_LINE DEDENT arr = [ 8 , 9 , - 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxEvenLenSum ( arr , n ) ) NEW_LINE"}
{"id": "aizu_p00085_A", "sol": 0, "python_code": "while 1 :\n    n , m = map ( int , input ( ).split ( ) )\n    if n == m == 0 : break\n    a = m - 1\n    while a < ( m - 1 ) * n :\n        a = int ( m * a / ( m - 1 ) + 1 )\n    print ( n * m - a )\n", "python_code_tokenized": "while 1 : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == m == 0 : break NEW_LINE a = m - 1 NEW_LINE while a < ( m - 1 ) * n : NEW_LINE INDENT a = int ( m * a / ( m - 1 ) + 1 ) NEW_LINE DEDENT print ( n * m - a ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_771_A", "sol": 0, "python_code": "def countDivisors ( N , a , b ) :\n    count1 = N // a\n    count2 = N // b\n    count3 = ( N // ( a * b ) )\n    return count1 + count2 - count3\nN = 1000\na = 3\nb = 4\nprint ( countDivisors ( N , a , b ) )\n", "python_code_tokenized": "def countDivisors ( N , a , b ) : NEW_LINE INDENT count1 = N // a NEW_LINE count2 = N // b NEW_LINE count3 = ( N // ( a * b ) ) NEW_LINE return count1 + count2 - count3 NEW_LINE DEDENT N = 1000 NEW_LINE a = 3 NEW_LINE b = 4 NEW_LINE print ( countDivisors ( N , a , b ) ) NEW_LINE"}
{"id": "codeforces_1190_B", "sol": 0, "python_code": "from collections import defaultdict\nimport sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\nn = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nif n == 1 :\n    ans = \"sjfnb\" if a [ 0 ] % 2 else \"cslnb\"\nelse :\n    cnt = defaultdict ( lambda : 0 )\n    u = [ ]\n    for i in a :\n        if cnt [ i ] :\n            u.append ( i )\n        cnt [ i ] += 1\n    if len ( u ) > 1 :\n        ans = \"cslnb\"\n    elif len ( u ) == 1 and ( not u [ 0 ] or u [ 0 ] - 1 in set ( a ) ) :\n        ans = \"cslnb\"\n    else :\n        s = sum ( a ) - ( n * ( n - 1 ) // 2 )\n        ans = \"sjfnb\" if s % 2 else \"cslnb\"\nprint ( ans )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT ans = \" sjfnb \" if a [ 0 ] % 2 else \" cslnb \" NEW_LINE DEDENT else : NEW_LINE INDENT cnt = defaultdict ( lambda : 0 ) NEW_LINE u = [ ] NEW_LINE for i in a : NEW_LINE INDENT if cnt [ i ] : NEW_LINE INDENT u . append ( i ) NEW_LINE DEDENT cnt [ i ] += 1 NEW_LINE DEDENT if len ( u ) > 1 : NEW_LINE INDENT ans = \" cslnb \" NEW_LINE DEDENT elif len ( u ) == 1 and ( not u [ 0 ] or u [ 0 ] - 1 in set ( a ) ) : NEW_LINE INDENT ans = \" cslnb \" NEW_LINE DEDENT else : NEW_LINE INDENT s = sum ( a ) - ( n * ( n - 1 ) // 2 ) NEW_LINE ans = \" sjfnb \" if s % 2 else \" cslnb \" NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "aizu_p00088_A", "sol": 0, "python_code": "L = { \"\" : \"101\",\"'\" : \"000000\",\",\" : \"000011\",\"-\" : \"10010001\",\".\" : \"010001\",\"?\" : \"000001\",\"A\" : \"100101\",\"B\" : \"10011010\",\"C\" : \"0101\",\"D\" : \"0001\",\"E\" : \"110\",\"F\" : \"01001\",\"G\" : \"10011011\",\"H\" : \"010000\",\"I\" : \"0111\",\"J\" : \"10011000\",\"K\" : \"0110\",\"L\" : \"00100\",\"M\" : \"10011001\",\"N\" : \"10011110\",\"O\" : \"00101\",\"P\" : \"111\",\"Q\" : \"10011111\",\"R\" : \"1000\",\"S\" : \"00110\",\"T\" : \"00111\",\"U\" : \"10011100\",\"V\" : \"10011101\",\"W\" : \"000010\",\"X\" : \"10010010\",\"Y\" : \"10010011\",\"Z\" : \"10010000\" }\nM = { \"00000\" : \"A\",\"00001\" : \"B\",\"00010\" : \"C\",\"00011\" : \"D\",\"00100\" : \"E\",\"00101\" : \"F\",\"00110\" : \"G\",\"00111\" : \"H\",\"01000\" : \"I\",\"01001\" : \"J\",\"01010\" : \"K\",\"01011\" : \"L\",\"01100\" : \"M\",\"01101\" : \"N\",\"01110\" : \"O\",\"01111\" : \"P\",\"10000\" : \"Q\",\"10001\" : \"R\",\"10010\" : \"S\",\"10011\" : \"T\",\"10100\" : \"U\",\"10101\" : \"V\",\"10110\" : \"W\",\"10111\" : \"X\",\"11000\" : \"Y\",\"11001\" : \"Z\",\"11010\" : \"\",\"11011\" : \".\",\"11100\" : \",\",\"11101\" : \"-\",\"11110\" : \"'\",\"11111\" : \"?\" }\nwhile True :\n    try :\n        s = input ( )\n    except :\n        break\n    t = \"\"\n    for i in s :\n        t += L [ i ]\n    t += \"0\" * ( ( - len ( t ) ) % 5 )\n    o = \"\"\n    for i in range ( len ( t ) // 5 ) :\n        u = t [ i * 5 : i * 5 + 5 ]\n        o += M [ u ]\n    print ( o )\n", "python_code_tokenized": "L = { \" \u2581 \" : \"101\" , \" ' \" : \"000000\" , \" , \" : \"000011\" , \" - \" : \"10010001\" , \" . \" : \"010001\" , \" ? \" : \"000001\" , \" A \" : \"100101\" , \" B \" : \"10011010\" , \" C \" : \"0101\" , \" D \" : \"0001\" , \" E \" : \"110\" , \" F \" : \"01001\" , \" G \" : \"10011011\" , \" H \" : \"010000\" , \" I \" : \"0111\" , \" J \" : \"10011000\" , \" K \" : \"0110\" , \" L \" : \"00100\" , \" M \" : \"10011001\" , \" N \" : \"10011110\" , \" O \" : \"00101\" , \" P \" : \"111\" , \" Q \" : \"10011111\" , \" R \" : \"1000\" , \" S \" : \"00110\" , \" T \" : \"00111\" , \" U \" : \"10011100\" , \" V \" : \"10011101\" , \" W \" : \"000010\" , \" X \" : \"10010010\" , \" Y \" : \"10010011\" , \" Z \" : \"10010000\" } NEW_LINE M = { \"00000\" : \" A \" , \"00001\" : \" B \" , \"00010\" : \" C \" , \"00011\" : \" D \" , \"00100\" : \" E \" , \"00101\" : \" F \" , \"00110\" : \" G \" , \"00111\" : \" H \" , \"01000\" : \" I \" , \"01001\" : \" J \" , \"01010\" : \" K \" , \"01011\" : \" L \" , \"01100\" : \" M \" , \"01101\" : \" N \" , \"01110\" : \" O \" , \"01111\" : \" P \" , \"10000\" : \" Q \" , \"10001\" : \" R \" , \"10010\" : \" S \" , \"10011\" : \" T \" , \"10100\" : \" U \" , \"10101\" : \" V \" , \"10110\" : \" W \" , \"10111\" : \" X \" , \"11000\" : \" Y \" , \"11001\" : \" Z \" , \"11010\" : \" \u2581 \" , \"11011\" : \" . \" , \"11100\" : \" , \" , \"11101\" : \" - \" , \"11110\" : \" ' \" , \"11111\" : \" ? \" } NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT s = input ( ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT t = \" \" NEW_LINE for i in s : NEW_LINE INDENT t += L [ i ] NEW_LINE DEDENT t += \"0\" * ( ( - len ( t ) ) % 5 ) NEW_LINE o = \" \" NEW_LINE for i in range ( len ( t ) // 5 ) : NEW_LINE INDENT u = t [ i * 5 : i * 5 + 5 ] NEW_LINE o += M [ u ] NEW_LINE DEDENT print ( o ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1170_A", "sol": 0, "python_code": "def isDivisibleby17 ( n ) :\n    if ( n == 0 or n == 17 ) :\n        return True\n    if ( n < 17 ) :\n        return False\n    return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) )\nn = 35\nif ( isDivisibleby17 ( n ) ) :\n    print ( n , \"is divisible by 17\" )\nelse :\n    print ( n , \"is not divisible by 17\" )\n", "python_code_tokenized": "def isDivisibleby17 ( n ) : NEW_LINE INDENT if ( n == 0 or n == 17 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n < 17 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) NEW_LINE DEDENT n = 35 NEW_LINE if ( isDivisibleby17 ( n ) ) : NEW_LINE INDENT print ( n , \" is \u2581 divisible \u2581 by \u2581 17\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , \" is \u2581 not \u2581 divisible \u2581 by \u2581 17\" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2559_A", "sol": 0, "python_code": "def reVal ( num ) :\n    if ( num >= 0 and num <= 9 ) :\n        return chr ( num + ord ( '0' ) ) ;\n    else :\n        return chr ( num - 10 + ord ( 'A' ) ) ;\ndef strev ( str ) :\n    len = len ( str ) ;\n    for i in range ( int ( len / 2 ) ) :\n        temp = str [ i ] ;\n        str [ i ] = str [ len - i - 1 ] ;\n        str [ len - i - 1 ] = temp ;\ndef fromDeci ( res , base , inputNum ) :\n    index = 0 ;\n    while ( inputNum > 0 ) :\n        res += reVal ( inputNum % base ) ;\n        inputNum = int ( inputNum / base ) ;\n    res = res [ : : - 1 ] ;\n    return res ;\ninputNum = 282 ;\nbase = 16 ;\nres = \"\" ;\nprint ( \"Equivalent of\" , inputNum , \"in base\" , base , \"is\" , fromDeci ( res , base , inputNum ) ) ;\n", "python_code_tokenized": "def reVal ( num ) : NEW_LINE INDENT if ( num >= 0 and num <= 9 ) : NEW_LINE INDENT return chr ( num + ord ( '0' ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return chr ( num - 10 + ord ( ' A ' ) ) ; NEW_LINE DEDENT DEDENT def strev ( str ) : NEW_LINE INDENT len = len ( str ) ; NEW_LINE for i in range ( int ( len / 2 ) ) : NEW_LINE INDENT temp = str [ i ] ; NEW_LINE str [ i ] = str [ len - i - 1 ] ; NEW_LINE str [ len - i - 1 ] = temp ; NEW_LINE DEDENT DEDENT def fromDeci ( res , base , inputNum ) : NEW_LINE INDENT index = 0 ; NEW_LINE while ( inputNum > 0 ) : NEW_LINE INDENT res += reVal ( inputNum % base ) ; NEW_LINE inputNum = int ( inputNum / base ) ; NEW_LINE DEDENT res = res [ : : - 1 ] ; NEW_LINE return res ; NEW_LINE DEDENT inputNum = 282 ; NEW_LINE base = 16 ; NEW_LINE res = \" \" ; NEW_LINE print ( \" Equivalent \u2581 of \" , inputNum , \" in \u2581 base \" , base , \" is \" , fromDeci ( res , base , inputNum ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_4015_A", "sol": 0, "python_code": "def getMedian ( arr1 , arr2 , n ) :\n    if n == 0 :\n        return - 1\n    elif n == 1 :\n        return ( arr1 [ 0 ] + arr2 [ 1 ] ) / 2\n    elif n == 2 :\n        return ( max ( arr1 [ 0 ] , arr2 [ 0 ] ) + min ( arr1 [ 1 ] , arr2 [ 1 ] ) ) / 2\n    else :\n        m1 = median ( arr1 , n )\n        m2 = median ( arr2 , n )\n        if m1 > m2 :\n            if n % 2 == 0 :\n                return getMedian ( arr1 [ : int ( n / 2 ) + 1 ] , arr2 [ int ( n / 2 ) - 1 : ] , int ( n / 2 ) + 1 )\n            else :\n                return getMedian ( arr1 [ : int ( n / 2 ) + 1 ] , arr2 [ int ( n / 2 ) : ] , int ( n / 2 ) + 1 )\n        else :\n            if n % 2 == 0 :\n                return getMedian ( arr1 [ int ( n / 2 - 1 ) : ] , arr2 [ : int ( n / 2 + 1 ) ] , int ( n / 2 ) + 1 )\n            else :\n                return getMedian ( arr1 [ int ( n / 2 ) : ] , arr2 [ 0 : int ( n / 2 ) + 1 ] , int ( n / 2 ) + 1 )\ndef median ( arr , n ) :\n    if n % 2 == 0 :\n        return ( arr [ int ( n / 2 ) ] + arr [ int ( n / 2 ) - 1 ] ) / 2\n    else :\n        return arr [ int ( n / 2 ) ]\narr1 = [ 1 , 2 , 3 , 6 ]\narr2 = [ 4 , 6 , 8 , 10 ]\nn = len ( arr1 )\nprint ( int ( getMedian ( arr1 , arr2 , n ) ) )\n", "python_code_tokenized": "def getMedian ( arr1 , arr2 , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT return ( arr1 [ 0 ] + arr2 [ 1 ] ) / 2 NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT return ( max ( arr1 [ 0 ] , arr2 [ 0 ] ) + min ( arr1 [ 1 ] , arr2 [ 1 ] ) ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT m1 = median ( arr1 , n ) NEW_LINE m2 = median ( arr2 , n ) NEW_LINE if m1 > m2 : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return getMedian ( arr1 [ : int ( n / 2 ) + 1 ] , arr2 [ int ( n / 2 ) - 1 : ] , int ( n / 2 ) + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return getMedian ( arr1 [ : int ( n / 2 ) + 1 ] , arr2 [ int ( n / 2 ) : ] , int ( n / 2 ) + 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return getMedian ( arr1 [ int ( n / 2 - 1 ) : ] , arr2 [ : int ( n / 2 + 1 ) ] , int ( n / 2 ) + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return getMedian ( arr1 [ int ( n / 2 ) : ] , arr2 [ 0 : int ( n / 2 ) + 1 ] , int ( n / 2 ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def median ( arr , n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return ( arr [ int ( n / 2 ) ] + arr [ int ( n / 2 ) - 1 ] ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ int ( n / 2 ) ] NEW_LINE DEDENT DEDENT arr1 = [ 1 , 2 , 3 , 6 ] NEW_LINE arr2 = [ 4 , 6 , 8 , 10 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( int ( getMedian ( arr1 , arr2 , n ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_1989_A", "sol": 0, "python_code": "from math import gcd\ndef getMinNum ( N ) :\n    lcm = 1 ;\n    for i in range ( 2 , N + 1 ) :\n        lcm = ( ( i * lcm ) // ( gcd ( i , lcm ) ) ) ;\n    return ( lcm + 1 ) ;\nif __name__ == \"__main__\" :\n    N = 5 ;\n    print ( getMinNum ( N ) ) ;\n", "python_code_tokenized": "from math import gcd NEW_LINE def getMinNum ( N ) : NEW_LINE INDENT lcm = 1 ; NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT lcm = ( ( i * lcm ) // ( gcd ( i , lcm ) ) ) ; NEW_LINE DEDENT return ( lcm + 1 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 ; NEW_LINE print ( getMinNum ( N ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2730_A", "sol": 0, "python_code": "def isBinary ( n ) :\n    while n != 0 :\n        temp = n % 10\n        if temp != 0 and temp != 1 :\n            return False\n        n = n // 10\n    return True\ndef formBinaryStr ( n , a ) :\n    flag = True\n    s = \"\"\n    for i in range ( 0 , n ) :\n        if isBinary ( a [ i ] ) == True :\n            s += str ( a [ i ] )\n        else :\n            flag = False\n            break\n    if flag == True :\n        print ( s )\n    else :\n        cout << \"-1\\n\"\nif __name__ == \"__main__\" :\n    a = [ 10 , 1 , 0 , 11 , 10 ]\n    N = len ( a )\n    formBinaryStr ( N , a )\n", "python_code_tokenized": "def isBinary ( n ) : NEW_LINE INDENT while n != 0 : NEW_LINE INDENT temp = n % 10 NEW_LINE if temp != 0 and temp != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def formBinaryStr ( n , a ) : NEW_LINE INDENT flag = True NEW_LINE s = \" \" NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if isBinary ( a [ i ] ) == True : NEW_LINE INDENT s += str ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag == True : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT cout << \" - 1 \\n \" NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 10 , 1 , 0 , 11 , 10 ] NEW_LINE N = len ( a ) NEW_LINE formBinaryStr ( N , a ) NEW_LINE DEDENT"}
{"id": "codeforces_1179_B", "sol": 0, "python_code": "import sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\ndef print ( u , v ) :\n    sys.stdout.write ( \"%d %d\\n\" % ( u , v ) )\nn , m = map ( int , input ( ).split ( ) )\nans = [ ]\nfor i in range ( n // 2 ) :\n    u , v = i + 1 , n - i\n    for j in range ( m ) :\n        ans.append ( ( u , j + 1 ) )\n        ans.append ( ( v , m - j ) )\nif n % 2 :\n    u = n // 2 + 1\n    for i in range ( m // 2 ) :\n        ans.append ( ( u , i + 1 ) )\n        ans.append ( ( u , m - i ) )\n    if m % 2 :\n        v = m // 2 + 1\n        ans.append ( ( u , v ) )\nfor u , v in ans :\n    print ( u , v )\n", "python_code_tokenized": "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE def print ( u , v ) : NEW_LINE INDENT sys . stdout . write ( \" % d \u2581 % d \\n \" % ( u , v ) ) NEW_LINE DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT u , v = i + 1 , n - i NEW_LINE for j in range ( m ) : NEW_LINE INDENT ans . append ( ( u , j + 1 ) ) NEW_LINE ans . append ( ( v , m - j ) ) NEW_LINE DEDENT DEDENT if n % 2 : NEW_LINE INDENT u = n // 2 + 1 NEW_LINE for i in range ( m // 2 ) : NEW_LINE INDENT ans . append ( ( u , i + 1 ) ) NEW_LINE ans . append ( ( u , m - i ) ) NEW_LINE DEDENT if m % 2 : NEW_LINE INDENT v = m // 2 + 1 NEW_LINE ans . append ( ( u , v ) ) NEW_LINE DEDENT DEDENT for u , v in ans : NEW_LINE INDENT print ( u , v ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1073_A", "sol": 0, "python_code": "def isPalindrome ( num ) :\n    reverse_num = 0\n    temp = num\n    while ( temp != 0 ) :\n        remainder = temp % 10\n        reverse_num = reverse_num * 10 + remainder\n        temp = int ( temp / 10 )\n    if ( reverse_num == num ) :\n        return True\n    return False\ndef isOddLength ( num ) :\n    count = 0\n    while ( num > 0 ) :\n        num = int ( num / 10 )\n        count += 1\n    if ( count % 2 != 0 ) :\n        return True\n    return False\ndef sumOfAllPalindrome ( L , R ) :\n    sum = 0\n    if ( L <= R ) :\n        for i in range ( L , R + 1 , 1 ) :\n            if ( isPalindrome ( i ) and isOddLength ( i ) ) :\n                sum += i\n    return sum\nif __name__ == '__main__' :\n    L = 110\n    R = 1130\n    print ( sumOfAllPalindrome ( L , R ) )\n", "python_code_tokenized": "def isPalindrome ( num ) : NEW_LINE INDENT reverse_num = 0 NEW_LINE temp = num NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT remainder = temp % 10 NEW_LINE reverse_num = reverse_num * 10 + remainder NEW_LINE temp = int ( temp / 10 ) NEW_LINE DEDENT if ( reverse_num == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isOddLength ( num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT num = int ( num / 10 ) NEW_LINE count += 1 NEW_LINE DEDENT if ( count % 2 != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def sumOfAllPalindrome ( L , R ) : NEW_LINE INDENT sum = 0 NEW_LINE if ( L <= R ) : NEW_LINE INDENT for i in range ( L , R + 1 , 1 ) : NEW_LINE INDENT if ( isPalindrome ( i ) and isOddLength ( i ) ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 110 NEW_LINE R = 1130 NEW_LINE print ( sumOfAllPalindrome ( L , R ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4724_A", "sol": 0, "python_code": "def solve ( A , B ) :\n    count = 0\n    for i in range ( 0 , 32 ) :\n        if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) :\n            count = count + 1\n    print ( \"Number of different bits :\" , count )\nA = 12\nB = 15\nsolve ( A , B )\n", "python_code_tokenized": "def solve ( A , B ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT print ( \" Number \u2581 of \u2581 different \u2581 bits \u2581 : \" , count ) NEW_LINE DEDENT A = 12 NEW_LINE B = 15 NEW_LINE solve ( A , B ) NEW_LINE"}
{"id": "geeksforgeeks_4730_A", "sol": 0, "python_code": "def printUnique ( l , r ) :\n    for i in range ( l , r + 1 ) :\n        num = i ;\n        visited = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;\n        while ( num ) :\n            if visited [ num % 10 ] == 1 :\n                break ;\n            visited [ num % 10 ] = 1 ;\n            num = ( int ) ( num / 10 ) ;\n        if num == 0 :\n            print ( i , end = \" \" ) ;\nl = 1 ;\nr = 20 ;\nprintUnique ( l , r ) ;\n", "python_code_tokenized": "def printUnique ( l , r ) : NEW_LINE INDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT num = i ; NEW_LINE visited = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; NEW_LINE while ( num ) : NEW_LINE INDENT if visited [ num % 10 ] == 1 : NEW_LINE INDENT break ; NEW_LINE DEDENT visited [ num % 10 ] = 1 ; NEW_LINE num = ( int ) ( num / 10 ) ; NEW_LINE DEDENT if num == 0 : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT DEDENT l = 1 ; NEW_LINE r = 20 ; NEW_LINE printUnique ( l , r ) ; NEW_LINE"}
{"id": "codeforces_967_B", "sol": 0, "python_code": "def watering ( ) :\n    n , a , b = map ( int , input ( ).split ( ) )\n    s = list ( map ( int , input ( ).split ( ) ) )\n    volume = s [ 0 ] * ( a / b - 1 )\n    rest_holes_sum = sum ( s [ 1 : ] )\n    k = 0\n    delta = volume - rest_holes_sum\n    s_rest = sorted ( s [ 1 : ] , reverse = True )\n    while delta < 0 :\n        delta += s_rest [ k ]\n        k += 1\n    print ( k )\nwatering ( )\n", "python_code_tokenized": "def watering ( ) : NEW_LINE INDENT n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE volume = s [ 0 ] * ( a / b - 1 ) NEW_LINE rest_holes_sum = sum ( s [ 1 : ] ) NEW_LINE k = 0 NEW_LINE delta = volume - rest_holes_sum NEW_LINE s_rest = sorted ( s [ 1 : ] , reverse = True ) NEW_LINE while delta < 0 : NEW_LINE INDENT delta += s_rest [ k ] NEW_LINE k += 1 NEW_LINE DEDENT print ( k ) NEW_LINE DEDENT watering ( ) NEW_LINE"}
{"id": "codeforces_1511_B", "sol": 0, "python_code": "for t in range ( int ( input ( ) ) ) :\n    a , b , c = map ( int , input ( ).split ( ) )\n    print ( \"1\" + \"0\" * ( a - 1 ) , \"1\" * ( b - c + 1 ) + \"0\" * ( c - 1 ) )\n", "python_code_tokenized": "for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( \"1\" + \"0\" * ( a - 1 ) , \"1\" * ( b - c + 1 ) + \"0\" * ( c - 1 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2523_A", "sol": 0, "python_code": "def findMin ( arr , n ) :\n    ans = 1\n    for i in range ( n ) :\n        j = i + 1\n        while ( j < n and arr [ j ] >= arr [ j - 1 ] ) :\n            j += 1\n        ans = max ( ans , j - i )\n        i = j - 1\n    return n - ans\narr = [ 3 , 2 , 1 ]\nn = len ( arr )\nprint ( findMin ( arr , n ) )\n", "python_code_tokenized": "def findMin ( arr , n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans = max ( ans , j - i ) NEW_LINE i = j - 1 NEW_LINE DEDENT return n - ans NEW_LINE DEDENT arr = [ 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMin ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3439_A", "sol": 0, "python_code": "def printCollatz ( n ) :\n    while n != 1 :\n        print ( n , end = ' ' )\n        if n & 1 :\n            n = 3 * n + 1\n        else :\n            n = n // 2\n    print ( n )\nprintCollatz ( 6 )\n", "python_code_tokenized": "def printCollatz ( n ) : NEW_LINE INDENT while n != 1 : NEW_LINE INDENT print ( n , end = ' \u2581 ' ) NEW_LINE if n & 1 : NEW_LINE INDENT n = 3 * n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE DEDENT printCollatz ( 6 ) NEW_LINE"}
{"id": "geeksforgeeks_1331_A", "sol": 0, "python_code": "def printAsMaximalPrimeSum ( n ) :\n    if ( n % 2 == 1 ) :\n        print ( \"3 \" , end = \"\" )\n        n -= 3\n    while ( n > 0 ) :\n        print ( \"2 \" , end = \"\" )\n        n -= 2\nn = 5\nprintAsMaximalPrimeSum ( n )\n", "python_code_tokenized": "def printAsMaximalPrimeSum ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT print ( \"3 \u2581 \" , end = \" \" ) NEW_LINE n -= 3 NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT print ( \"2 \u2581 \" , end = \" \" ) NEW_LINE n -= 2 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE printAsMaximalPrimeSum ( n ) NEW_LINE"}
{"id": "geeksforgeeks_4547_A", "sol": 0, "python_code": "def printPattern ( n ) :\n    if ( n == 0 or n < 0 ) :\n        print ( n , end = \", \" )\n        return\n    print ( n , end = \", \" )\n    printPattern ( n - 5 )\n    print ( n , end = \", \" )\nn = 16\nprintPattern ( n )\n", "python_code_tokenized": "def printPattern ( n ) : NEW_LINE INDENT if ( n == 0 or n < 0 ) : NEW_LINE INDENT print ( n , end = \" , \u2581 \" ) NEW_LINE return NEW_LINE DEDENT print ( n , end = \" , \u2581 \" ) NEW_LINE printPattern ( n - 5 ) NEW_LINE print ( n , end = \" , \u2581 \" ) NEW_LINE DEDENT n = 16 NEW_LINE printPattern ( n ) NEW_LINE"}
{"id": "geeksforgeeks_2790_A", "sol": 0, "python_code": "def floorSqrt ( x ) :\n    if ( x == 0 or x == 1 ) :\n        return x\n    i = 1 ; result = 1\n    while ( result <= x ) :\n        i += 1\n        result = i * i\n    return i - 1\nx = 11\nprint ( floorSqrt ( x ) )\n", "python_code_tokenized": "def floorSqrt ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT i = 1 ; result = 1 NEW_LINE while ( result <= x ) : NEW_LINE INDENT i += 1 NEW_LINE result = i * i NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT x = 11 NEW_LINE print ( floorSqrt ( x ) ) NEW_LINE"}
{"id": "codeforces_239_B", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\na = [ - 1 ] + [ ord ( c ) - ord ( '0' ) for c in input ( ) ] + [ - 1 ]\nfor _ in range ( k ) :\n    L , R = map ( int , input ( ).split ( ) )\n    b = [ - 1 ] + a [ L : R + 1 ] + [ - 1 ]\n    ans , dp , p = [ 0 ] * 10 , 1 , 1\n    c = b [ p ]\n    while c != - 1 :\n        if c == 12 :\n            p -= 1\n            dp = - 1\n            if b [ p ] == 12 or b [ p ] == 14 : b.pop ( p + 1 )\n        elif c == 14 :\n            dp = 1\n            if b [ p + 1 ] == 12 or b [ p + 1 ] == 14 :\n                b.pop ( p )\n            else :\n                p += 1\n        else :\n            if c == 0 :\n                b.pop ( p )\n            else :\n                b [ p ] -= 1\n            p += dp\n            if c == 0 and dp == 1 : p -= 1\n            ans [ c ] += 1\n        c = b [ p ]\n    print ( * ans )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ - 1 ] + [ ord ( c ) - ord ( '0' ) for c in input ( ) ] + [ - 1 ] NEW_LINE for _ in range ( k ) : NEW_LINE INDENT L , R = map ( int , input ( ) . split ( ) ) NEW_LINE b = [ - 1 ] + a [ L : R + 1 ] + [ - 1 ] NEW_LINE ans , dp , p = [ 0 ] * 10 , 1 , 1 NEW_LINE c = b [ p ] NEW_LINE while c != - 1 : NEW_LINE INDENT if c == 12 : NEW_LINE INDENT p -= 1 NEW_LINE dp = - 1 NEW_LINE if b [ p ] == 12 or b [ p ] == 14 : b . pop ( p + 1 ) NEW_LINE DEDENT elif c == 14 : NEW_LINE INDENT dp = 1 NEW_LINE if b [ p + 1 ] == 12 or b [ p + 1 ] == 14 : NEW_LINE INDENT b . pop ( p ) NEW_LINE DEDENT else : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if c == 0 : NEW_LINE INDENT b . pop ( p ) NEW_LINE DEDENT else : NEW_LINE INDENT b [ p ] -= 1 NEW_LINE DEDENT p += dp NEW_LINE if c == 0 and dp == 1 : p -= 1 NEW_LINE ans [ c ] += 1 NEW_LINE DEDENT c = b [ p ] NEW_LINE DEDENT print ( * ans ) NEW_LINE DEDENT"}
{"id": "aizu_p02283_A", "sol": 0, "python_code": "import sys\nclass Node :\n    __slots__ = [ 'key' , 'left' , 'right' ]\n    def __init__ ( self , key ) :\n        self.key = key\n        self.left = self.right = None\nclass BST :\n    __slots__ = [ 'root' ]\n    def __init__ ( self ) :\n        self.root = None\n    def insert ( self , key ) :\n        x , y = self.root , None\n        while x != None : x , y = x.left if key < x.key else x.right , x\n        if y == None : self.root = Node ( key )\n        elif key < y.key : y.left = Node ( key )\n        else : y.right = Node ( key )\n    def print_tree ( self ) :\n        def inorder ( node ) :\n            return inorder ( node.left ) + f' {node.key}' + inorder ( node.right ) if node else ''\n        def preorder ( node ) :\n            return f' {node.key}' + preorder ( node.left ) + preorder ( node.right ) if node else ''\n        print ( inorder ( self.root ) )\n        print ( preorder ( self.root ) )\ntree = BST ( )\ninput ( )\nfor e in sys.stdin :\n    if e [ 0 ] == 'i' : tree.insert ( int ( e [ 7 : ] ) )\n    else : tree.print_tree ( )\n", "python_code_tokenized": "import sys NEW_LINE class Node : NEW_LINE INDENT __slots__ = [ ' key ' , ' left ' , ' right ' ] NEW_LINE def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT class BST : NEW_LINE INDENT __slots__ = [ ' root ' ] NEW_LINE def __init__ ( self ) : NEW_LINE INDENT self . root = None NEW_LINE DEDENT def insert ( self , key ) : NEW_LINE INDENT x , y = self . root , None NEW_LINE while x != None : x , y = x . left if key < x . key else x . right , x NEW_LINE if y == None : self . root = Node ( key ) NEW_LINE elif key < y . key : y . left = Node ( key ) NEW_LINE else : y . right = Node ( key ) NEW_LINE DEDENT def print_tree ( self ) : NEW_LINE INDENT def inorder ( node ) : NEW_LINE INDENT return inorder ( node . left ) + f ' \u2581 { node . key } ' + inorder ( node . right ) if node else ' ' NEW_LINE DEDENT def preorder ( node ) : NEW_LINE INDENT return f ' \u2581 { node . key } ' + preorder ( node . left ) + preorder ( node . right ) if node else ' ' NEW_LINE DEDENT print ( inorder ( self . root ) ) NEW_LINE print ( preorder ( self . root ) ) NEW_LINE DEDENT DEDENT tree = BST ( ) NEW_LINE input ( ) NEW_LINE for e in sys . stdin : NEW_LINE INDENT if e [ 0 ] == ' i ' : tree . insert ( int ( e [ 7 : ] ) ) NEW_LINE else : tree . print_tree ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4780_A", "sol": 0, "python_code": "def turnOffK ( n , k ) :\n    if ( k <= 0 ) :\n        return n\n    return ( n & ~ ( 1 << ( k - 1 ) ) )\nn = 15\nk = 4\nprint ( turnOffK ( n , k ) )\n", "python_code_tokenized": "def turnOffK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n & ~ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( turnOffK ( n , k ) ) NEW_LINE"}
{"id": "aizu_p02418_A", "sol": 0, "python_code": "s = input ( )\np = input ( )\njudge = 0\nfor i in range ( 0 , len ( s ) ) :\n    s_double = s + s\n    if p in s_double :\n        judge += 1\nif judge != 0 :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "s = input ( ) NEW_LINE p = input ( ) NEW_LINE judge = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT s_double = s + s NEW_LINE if p in s_double : NEW_LINE INDENT judge += 1 NEW_LINE DEDENT DEDENT if judge != 0 : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5217_A", "sol": 0, "python_code": "def printCombination ( n ) :\n    for i in range ( 1 , n ) :\n        if ( i % 3 != 0 ) :\n            for j in range ( 1 , n ) :\n                if ( j % 3 != 0 ) :\n                    for k in range ( 1 , n ) :\n                        if ( k % 3 != 0 and ( i + j + k ) == n ) :\n                            print ( i , j , k ) ;\n                            return ;\nn = 233 ;\nprintCombination ( n ) ;\n", "python_code_tokenized": "def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 ) : NEW_LINE INDENT for k in range ( 1 , n ) : NEW_LINE INDENT if ( k % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT print ( i , j , k ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT n = 233 ; NEW_LINE printCombination ( n ) ; NEW_LINE"}
{"id": "geeksforgeeks_1130_A", "sol": 0, "python_code": "def countIntegralSolutions ( n ) :\n    result = 0\n    for i in range ( n + 1 ) :\n        for j in range ( n + 1 ) :\n            for k in range ( n + 1 ) :\n                if i + j + k == n :\n                    result += 1\n    return result\nn = 3\nprint ( countIntegralSolutions ( n ) )\n", "python_code_tokenized": "def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT if i + j + k == n : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE"}
{"id": "atcoder_ABC173_B", "sol": 0, "python_code": "n = int ( input ( ) )\nac = 0\nwa = 0\ntle = 0\nre = 0\nfor i in range ( n ) :\n    w = input ( )\n    if ( w == 'AC' ) :\n        ac += 1\n    elif ( w == 'WA' ) :\n        wa += 1\n    elif ( w == 'TLE' ) :\n        tle += 1\n    elif ( w == 'RE' ) :\n        re += 1\nprint ( 'AC x ' + str ( ac ) )\nprint ( 'WA x ' + str ( wa ) )\nprint ( 'TLE x ' + str ( tle ) )\nprint ( 'RE x ' + str ( re ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE ac = 0 NEW_LINE wa = 0 NEW_LINE tle = 0 NEW_LINE re = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT w = input ( ) NEW_LINE if ( w == ' AC ' ) : NEW_LINE INDENT ac += 1 NEW_LINE DEDENT elif ( w == ' WA ' ) : NEW_LINE INDENT wa += 1 NEW_LINE DEDENT elif ( w == ' TLE ' ) : NEW_LINE INDENT tle += 1 NEW_LINE DEDENT elif ( w == ' RE ' ) : NEW_LINE INDENT re += 1 NEW_LINE DEDENT DEDENT print ( ' AC \u2581 x \u2581 ' + str ( ac ) ) NEW_LINE print ( ' WA \u2581 x \u2581 ' + str ( wa ) ) NEW_LINE print ( ' TLE \u2581 x \u2581 ' + str ( tle ) ) NEW_LINE print ( ' RE \u2581 x \u2581 ' + str ( re ) ) NEW_LINE"}
{"id": "geeksforgeeks_3886_A", "sol": 0, "python_code": "def countStaircases ( N ) :\n    memo = [ [ 0 for x in range ( N + 5 ) ] for y in range ( N + 5 ) ]\n    for i in range ( N + 1 ) :\n        for j in range ( N + 1 ) :\n            memo [ i ] [ j ] = 0\n    memo [ 3 ] [ 2 ] = memo [ 4 ] [ 2 ] = 1\n    for i in range ( 5 , N + 1 ) :\n        for j in range ( 2 , i + 1 ) :\n            if ( j == 2 ) :\n                memo [ i ] [ j ] = memo [ i - j ] [ j ] + 1\n            else :\n                memo [ i ] [ j ] = ( memo [ i - j ] [ j ] + memo [ i - j ] [ j - 1 ] )\n    answer = 0\n    for i in range ( 1 , N + 1 ) :\n        answer = answer + memo [ N ] [ i ]\n    return answer\nif __name__ == \"__main__\" :\n    N = 7\n    print ( countStaircases ( N ) )\n", "python_code_tokenized": "def countStaircases ( N ) : NEW_LINE INDENT memo = [ [ 0 for x in range ( N + 5 ) ] for y in range ( N + 5 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT memo [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT memo [ 3 ] [ 2 ] = memo [ 4 ] [ 2 ] = 1 NEW_LINE for i in range ( 5 , N + 1 ) : NEW_LINE INDENT for j in range ( 2 , i + 1 ) : NEW_LINE INDENT if ( j == 2 ) : NEW_LINE INDENT memo [ i ] [ j ] = memo [ i - j ] [ j ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT memo [ i ] [ j ] = ( memo [ i - j ] [ j ] + memo [ i - j ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT answer = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT answer = answer + memo [ N ] [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 7 NEW_LINE print ( countStaircases ( N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1488_A", "sol": 0, "python_code": "MAX = 10000\nMAX_ELEMENT = 50\ndp = [ [ [ - 1 for i in range ( MAX ) ] for j in range ( MAX_ELEMENT ) ] for k in range ( MAX_ELEMENT ) ]\ndef Max_Xor ( arr , i , j , mask , n ) :\n    if ( i >= n ) :\n        if ( j == 0 ) :\n            return mask\n        else :\n            return 0\n    if ( dp [ i ] [ j ] [ mask ] != - 1 ) :\n        return dp [ i ] [ j ] [ mask ]\n    ans = 0\n    if ( j > 0 ) :\n        ans = Max_Xor ( arr , i + 1 , j - 1 , mask ^ arr [ i ] , n )\n    ans = max ( ans , Max_Xor ( arr , i + 1 , j , mask , n ) )\n    dp [ i ] [ j ] [ mask ] = ans\n    return ans\narr = [ 2 , 5 , 4 , 1 , 3 , 7 , 6 , 8 ]\nn = len ( arr )\nk = 3\nprint ( Max_Xor ( arr , 0 , k , 0 , n ) )\n", "python_code_tokenized": "MAX = 10000 NEW_LINE MAX_ELEMENT = 50 NEW_LINE dp = [ [ [ - 1 for i in range ( MAX ) ] for j in range ( MAX_ELEMENT ) ] for k in range ( MAX_ELEMENT ) ] NEW_LINE def Max_Xor ( arr , i , j , mask , n ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT return mask NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ i ] [ j ] [ mask ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ mask ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( j > 0 ) : NEW_LINE INDENT ans = Max_Xor ( arr , i + 1 , j - 1 , mask ^ arr [ i ] , n ) NEW_LINE DEDENT ans = max ( ans , Max_Xor ( arr , i + 1 , j , mask , n ) ) NEW_LINE dp [ i ] [ j ] [ mask ] = ans NEW_LINE return ans NEW_LINE DEDENT arr = [ 2 , 5 , 4 , 1 , 3 , 7 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( Max_Xor ( arr , 0 , k , 0 , n ) ) NEW_LINE"}
{"id": "atcoder_ABC177_B", "sol": 0, "python_code": "s = input ( )\nr = input ( )\nn = len ( s )\nnn = len ( r )\nm = 0\nc = 0\nx = 0\nfor i in range ( n - nn + 1 ) :\n    t = s [ i : i + nn ]\n    c = 0\n    for j in range ( nn ) :\n        if ( t [ j ] == r [ j ] ) :\n            c += 1\n    m = max ( m , c )\nprint ( nn - m )\n", "python_code_tokenized": "s = input ( ) NEW_LINE r = input ( ) NEW_LINE n = len ( s ) NEW_LINE nn = len ( r ) NEW_LINE m = 0 NEW_LINE c = 0 NEW_LINE x = 0 NEW_LINE for i in range ( n - nn + 1 ) : NEW_LINE INDENT t = s [ i : i + nn ] NEW_LINE c = 0 NEW_LINE for j in range ( nn ) : NEW_LINE INDENT if ( t [ j ] == r [ j ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT m = max ( m , c ) NEW_LINE DEDENT print ( nn - m ) NEW_LINE"}
{"id": "geeksforgeeks_4277_A", "sol": 0, "python_code": "import math\ndef isDvisibleBy12 ( num ) :\n    if ( len ( num ) >= 3 ) :\n        d1 = int ( num [ len ( num ) - 1 ] ) ;\n        if ( d1 % 2 != 0 ) :\n            return False\n        d2 = int ( num [ len ( num ) - 2 ] )\n        sum = 0\n        for i in range ( 0 , len ( num ) ) :\n            sum += int ( num [ i ] )\n        return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 )\n    else :\n        number = int ( num )\n        return ( number % 12 == 0 )\nnum = \"12244824607284961224\"\nif ( isDvisibleBy12 ( num ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "import math NEW_LINE def isDvisibleBy12 ( num ) : NEW_LINE INDENT if ( len ( num ) >= 3 ) : NEW_LINE INDENT d1 = int ( num [ len ( num ) - 1 ] ) ; NEW_LINE if ( d1 % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d2 = int ( num [ len ( num ) - 2 ] ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT sum += int ( num [ i ] ) NEW_LINE DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT number = int ( num ) NEW_LINE return ( number % 12 == 0 ) NEW_LINE DEDENT DEDENT num = \"12244824607284961224\" NEW_LINE if ( isDvisibleBy12 ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3932_A", "sol": 0, "python_code": "def longLenStrictBitonicSub ( arr , n ) :\n    inc , dcr = dict ( ) , dict ( )\n    len_inc , len_dcr = [ 0 ] * n , [ 0 ] * n\n    longLen = 0\n    for i in range ( n ) :\n        len = 0\n        if inc.get ( arr [ i ] - 1 ) in inc.values ( ) :\n            len = inc.get ( arr [ i ] - 1 )\n        inc [ arr [ i ] ] = len_inc [ i ] = len + 1\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        len = 0\n        if dcr.get ( arr [ i ] - 1 ) in dcr.values ( ) :\n            len = dcr.get ( arr [ i ] - 1 )\n        dcr [ arr [ i ] ] = len_dcr [ i ] = len + 1\n    for i in range ( n ) :\n        if longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) :\n            longLen = len_inc [ i ] + len_dcr [ i ] - 1\n    return longLen\nif __name__ == \"__main__\" :\n    arr = [ 1 , 5 , 2 , 3 , 4 , 5 , 3 , 2 ]\n    n = len ( arr )\n    print ( \"Longest length strict bitonic subsequence =\" , longLenStrictBitonicSub ( arr , n ) )\n", "python_code_tokenized": "def longLenStrictBitonicSub ( arr , n ) : NEW_LINE INDENT inc , dcr = dict ( ) , dict ( ) NEW_LINE len_inc , len_dcr = [ 0 ] * n , [ 0 ] * n NEW_LINE longLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len = 0 NEW_LINE if inc . get ( arr [ i ] - 1 ) in inc . values ( ) : NEW_LINE INDENT len = inc . get ( arr [ i ] - 1 ) NEW_LINE DEDENT inc [ arr [ i ] ] = len_inc [ i ] = len + 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT len = 0 NEW_LINE if dcr . get ( arr [ i ] - 1 ) in dcr . values ( ) : NEW_LINE INDENT len = dcr . get ( arr [ i ] - 1 ) NEW_LINE DEDENT dcr [ arr [ i ] ] = len_dcr [ i ] = len + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) : NEW_LINE INDENT longLen = len_inc [ i ] + len_dcr [ i ] - 1 NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 2 , 3 , 4 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Longest \u2581 length \u2581 strict \u2581 bitonic \u2581 subsequence \u2581 = \" , longLenStrictBitonicSub ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_49_A", "sol": 0, "python_code": "import math as mt\ndef sumDivisorsOfDivisors ( n ) :\n    mp = dict ( )\n    for j in range ( 2 , mt.ceil ( mt.sqrt ( n ) ) ) :\n        count = 0\n        while ( n % j == 0 ) :\n            n //= j\n            count += 1\n        if ( count ) :\n            mp [ j ] = count\n    if ( n != 1 ) :\n        mp [ n ] = 1\n    ans = 1\n    for it in mp :\n        pw = 1\n        summ = 0\n        for i in range ( mp [ it ] + 1 , 0 , - 1 ) :\n            summ += ( i * pw )\n            pw *= it\n        ans *= summ\n    return ans\nn = 10\nprint ( sumDivisorsOfDivisors ( n ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def sumDivisorsOfDivisors ( n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for j in range ( 2 , mt . ceil ( mt . sqrt ( n ) ) ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % j == 0 ) : NEW_LINE INDENT n //= j NEW_LINE count += 1 NEW_LINE DEDENT if ( count ) : NEW_LINE INDENT mp [ j ] = count NEW_LINE DEDENT DEDENT if ( n != 1 ) : NEW_LINE INDENT mp [ n ] = 1 NEW_LINE DEDENT ans = 1 NEW_LINE for it in mp : NEW_LINE INDENT pw = 1 NEW_LINE summ = 0 NEW_LINE for i in range ( mp [ it ] + 1 , 0 , - 1 ) : NEW_LINE INDENT summ += ( i * pw ) NEW_LINE pw *= it NEW_LINE DEDENT ans *= summ NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 10 NEW_LINE print ( sumDivisorsOfDivisors ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_891_A", "sol": 0, "python_code": "def checkIfPowerIsolated ( num ) :\n    input1 = num ;\n    count = 0 ;\n    factor = [ 0 ] * ( num + 1 ) ;\n    if ( num % 2 == 0 ) :\n        while ( num % 2 == 0 ) :\n            count += 1 ;\n            num //= 2 ;\n        factor [ 2 ] = count ;\n    i = 3 ;\n    while ( i * i <= num ) :\n        count = 0 ;\n        while ( num % i == 0 ) :\n            count += 1 ;\n            num //= i ;\n        if ( count > 0 ) :\n            factor [ i ] = count ;\n        i += 2 ;\n    if ( num > 1 ) :\n        factor [ num ] = 1 ;\n    product = 1 ;\n    for i in range ( 0 , len ( factor ) ) :\n        if ( factor [ i ] > 0 ) :\n            product = product * factor [ i ] * i ;\n    if ( product == input1 ) :\n        print ( \"Power-isolated Integer\" ) ;\n    else :\n        print ( \"Not a Power-isolated Integer\" ) ;\ncheckIfPowerIsolated ( 12 ) ;\ncheckIfPowerIsolated ( 18 ) ;\ncheckIfPowerIsolated ( 35 ) ;\n", "python_code_tokenized": "def checkIfPowerIsolated ( num ) : NEW_LINE INDENT input1 = num ; NEW_LINE count = 0 ; NEW_LINE factor = [ 0 ] * ( num + 1 ) ; NEW_LINE if ( num % 2 == 0 ) : NEW_LINE INDENT while ( num % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE num //= 2 ; NEW_LINE DEDENT factor [ 2 ] = count ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i <= num ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( num % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE num //= i ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT factor [ i ] = count ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT factor [ num ] = 1 ; NEW_LINE DEDENT product = 1 ; NEW_LINE for i in range ( 0 , len ( factor ) ) : NEW_LINE INDENT if ( factor [ i ] > 0 ) : NEW_LINE INDENT product = product * factor [ i ] * i ; NEW_LINE DEDENT DEDENT if ( product == input1 ) : NEW_LINE INDENT print ( \" Power - isolated \u2581 Integer \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 a \u2581 Power - isolated \u2581 Integer \" ) ; NEW_LINE DEDENT DEDENT checkIfPowerIsolated ( 12 ) ; NEW_LINE checkIfPowerIsolated ( 18 ) ; NEW_LINE checkIfPowerIsolated ( 35 ) ; NEW_LINE"}
{"id": "geeksforgeeks_4168_A", "sol": 0, "python_code": "def countSubstr ( str , n , x , y ) :\n    tot_count = 0\n    count_x = 0\n    for i in range ( n ) :\n        if str [ i ] == x :\n            count_x += 1\n        if str [ i ] == y :\n            tot_count += count_x\n    return tot_count\nstr = 'abbcaceghcak'\nn = len ( str )\nx , y = 'a' , 'c'\nprint ( 'Count =' , countSubstr ( str , n , x , y ) )\n", "python_code_tokenized": "def countSubstr ( str , n , x , y ) : NEW_LINE INDENT tot_count = 0 NEW_LINE count_x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] == x : NEW_LINE INDENT count_x += 1 NEW_LINE DEDENT if str [ i ] == y : NEW_LINE INDENT tot_count += count_x NEW_LINE DEDENT DEDENT return tot_count NEW_LINE DEDENT str = ' abbcaceghcak ' NEW_LINE n = len ( str ) NEW_LINE x , y = ' a ' , ' c ' NEW_LINE print ( ' Count \u2581 = ' , countSubstr ( str , n , x , y ) ) NEW_LINE"}
{"id": "codeforces_134_A", "sol": 0, "python_code": "import os , sys , io , math\nfrom tokenize import Triple\nfrom array import array\nfrom math import *\nI = lambda : [ * map ( int , sys.stdin.readline ( ).split ( ) ) ]\nIS = lambda : input ( )\nIN = lambda : int ( input ( ) )\nIF = lambda : float ( input ( ) )\nn = IN ( )\nl = I ( )\nc = 0\nr = [ ]\ns = sum ( l )\nfor i in range ( n ) :\n    if ( s - l [ i ] ) / ( n - 1 ) == l [ i ] :\n        c += 1\n        r.append ( i + 1 )\nprint ( c )\nprint ( * r )\n", "python_code_tokenized": "import os , sys , io , math NEW_LINE from tokenize import Triple NEW_LINE from array import array NEW_LINE from math import * NEW_LINE I = lambda : [ * map ( int , sys . stdin . readline ( ) . split ( ) ) ] NEW_LINE IS = lambda : input ( ) NEW_LINE IN = lambda : int ( input ( ) ) NEW_LINE IF = lambda : float ( input ( ) ) NEW_LINE n = IN ( ) NEW_LINE l = I ( ) NEW_LINE c = 0 NEW_LINE r = [ ] NEW_LINE s = sum ( l ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s - l [ i ] ) / ( n - 1 ) == l [ i ] : NEW_LINE INDENT c += 1 NEW_LINE r . append ( i + 1 ) NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE print ( * r ) NEW_LINE"}
{"id": "geeksforgeeks_3796_A", "sol": 0, "python_code": "def minimumSubarrays ( ar , n ) :\n    se = [ ]\n    cnt = 1 ;\n    for i in range ( n ) :\n        if se.count ( ar [ i ] ) == 0 :\n            se.append ( ar [ i ] )\n        else :\n            cnt += 1\n            se.clear ( )\n            se.append ( ar [ i ] )\n    return cnt\nar = [ 1 , 2 , 1 , 3 , 4 , 2 , 4 , 4 , 4 ]\nn = len ( ar )\nprint ( minimumSubarrays ( ar , n ) )\n", "python_code_tokenized": "def minimumSubarrays ( ar , n ) : NEW_LINE INDENT se = [ ] NEW_LINE cnt = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if se . count ( ar [ i ] ) == 0 : NEW_LINE INDENT se . append ( ar [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE se . clear ( ) NEW_LINE se . append ( ar [ i ] ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT ar = [ 1 , 2 , 1 , 3 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE n = len ( ar ) NEW_LINE print ( minimumSubarrays ( ar , n ) ) NEW_LINE"}
{"id": "codeforces_1368_B", "sol": 0, "python_code": "import math\nk = int ( input ( ) )\ndef find_sol ( n ) :\n    result = 1\n    a = 0\n    b = 0\n    if n % 10 == 0 :\n        result *= ( n // 10 ) ** 10\n        a = 10\n        b = 0\n    else :\n        x = math.floor ( n / 10 )\n        y = math.ceil ( n / 10 )\n        b = n - 10 * x\n        a = 10 * y - n\n        result *= ( x ** a ) * ( y ** b )\n    return ( result , a , b )\nguess = int ( 10 * k ** 0.1 )\nwhile find_sol ( guess ) [ 0 ] < k :\n    guess += 1\na , b = find_sol ( guess ) [ 1 : ]\nx = math.floor ( guess / 10 )\ny = math.ceil ( guess / 10 )\nword = 'codeforces'\nans = ''\nfor i in range ( a ) :\n    ans += word [ i ] * x\nfor j in range ( a , a + b ) :\n    ans += word [ j ] * y\nprint ( ans )\n", "python_code_tokenized": "import math NEW_LINE k = int ( input ( ) ) NEW_LINE def find_sol ( n ) : NEW_LINE INDENT result = 1 NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE if n % 10 == 0 : NEW_LINE INDENT result *= ( n // 10 ) ** 10 NEW_LINE a = 10 NEW_LINE b = 0 NEW_LINE DEDENT else : NEW_LINE INDENT x = math . floor ( n / 10 ) NEW_LINE y = math . ceil ( n / 10 ) NEW_LINE b = n - 10 * x NEW_LINE a = 10 * y - n NEW_LINE result *= ( x ** a ) * ( y ** b ) NEW_LINE DEDENT return ( result , a , b ) NEW_LINE DEDENT guess = int ( 10 * k ** 0.1 ) NEW_LINE while find_sol ( guess ) [ 0 ] < k : NEW_LINE INDENT guess += 1 NEW_LINE DEDENT a , b = find_sol ( guess ) [ 1 : ] NEW_LINE x = math . floor ( guess / 10 ) NEW_LINE y = math . ceil ( guess / 10 ) NEW_LINE word = ' codeforces ' NEW_LINE ans = ' ' NEW_LINE for i in range ( a ) : NEW_LINE INDENT ans += word [ i ] * x NEW_LINE DEDENT for j in range ( a , a + b ) : NEW_LINE INDENT ans += word [ j ] * y NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_4119_A", "sol": 0, "python_code": "import math as mt\ndef isPrime ( n ) :\n    i = 2\n    if ( n == 1 ) :\n        return False\n    for i in range ( 2 , mt.ceil ( mt.sqrt ( n ) ) ) :\n        if ( n % i == 0 ) :\n            return False\n    return True\ndef check_frequency ( s ) :\n    m = dict ( )\n    for i in range ( len ( s ) ) :\n        if s [ i ] in m.keys ( ) :\n            m [ s [ i ] ] += 1\n        else :\n            m [ s [ i ] ] = 1\n    for ch in m :\n        if m [ ch ] > 0 and isPrime ( m [ ch ] ) == False :\n            return False\n    return True\ns = \"geeksforgeeks\"\nif ( check_frequency ( s ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "import math as mt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , mt . ceil ( mt . sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check_frequency ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in m . keys ( ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT for ch in m : NEW_LINE INDENT if m [ ch ] > 0 and isPrime ( m [ ch ] ) == False : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE if ( check_frequency ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "codeforces_382_A", "sol": 0, "python_code": "x , y = input ( ).split ( '|' )\nz = list ( input ( ) )\nfor i in range ( len ( z ) ) :\n    if len ( x ) >= len ( y ) and len ( z ) != 0 :\n        y += z.pop ( 0 )\n    elif len ( y ) >= len ( x ) and len ( z ) != 0 :\n        x += z.pop ( 0 )\n    else :\n        f = 'Impossible'\n        break\nif len ( x ) == len ( y ) and len ( z ) % 2 == 0 :\n    if len ( z ) != 0 :\n        r = len ( z ) // 2\n        x = x + str ( z [ : r ] )\n        y = y + str ( z [ r : ] )\n        f = f'{x}|{y}'\n    else :\n        f = f'{x}|{y}'\nelse : f = 'Impossible'\nprint ( f )\n", "python_code_tokenized": "x , y = input ( ) . split ( ' | ' ) NEW_LINE z = list ( input ( ) ) NEW_LINE for i in range ( len ( z ) ) : NEW_LINE INDENT if len ( x ) >= len ( y ) and len ( z ) != 0 : NEW_LINE INDENT y += z . pop ( 0 ) NEW_LINE DEDENT elif len ( y ) >= len ( x ) and len ( z ) != 0 : NEW_LINE INDENT x += z . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT f = ' Impossible ' NEW_LINE break NEW_LINE DEDENT DEDENT if len ( x ) == len ( y ) and len ( z ) % 2 == 0 : NEW_LINE INDENT if len ( z ) != 0 : NEW_LINE INDENT r = len ( z ) // 2 NEW_LINE x = x + str ( z [ : r ] ) NEW_LINE y = y + str ( z [ r : ] ) NEW_LINE f = f ' { x } | { y } ' NEW_LINE DEDENT else : NEW_LINE INDENT f = f ' { x } | { y } ' NEW_LINE DEDENT DEDENT else : f = ' Impossible ' NEW_LINE print ( f ) NEW_LINE"}
{"id": "codeforces_624_B", "sol": 0, "python_code": "n = int ( input ( ) )\nl = [ int ( i ) for i in input ( ).split ( ) ]\nl.sort ( reverse = True )\nfor i in range ( 1 , n ) :\n    if l [ i ] >= l [ i - 1 ] :\n        if l [ i - 1 ] == 0 :\n            l [ i ] = 0\n        else :\n            l [ i ] = l [ i - 1 ] - 1\n    else :\n        l [ i ] = l [ i ]\nprint ( sum ( l ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE l = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE l . sort ( reverse = True ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if l [ i ] >= l [ i - 1 ] : NEW_LINE INDENT if l [ i - 1 ] == 0 : NEW_LINE INDENT l [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT l [ i ] = l [ i - 1 ] - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT l [ i ] = l [ i ] NEW_LINE DEDENT DEDENT print ( sum ( l ) ) NEW_LINE"}
{"id": "codejam_14_33", "sol": 0, "python_code": "import sys\niFile = open ( sys.argv [ 1 ] , \"r\" )\nsize = int ( iFile.readline ( ).strip ( ) )\nfor i in range ( size ) :\n    line = iFile.readline ( ).strip ( ).split ( )\n    N = int ( line [ 0 ] )\n    M = int ( line [ 1 ] )\n    K = int ( line [ 2 ] )\n    stones = 0\n    if K <= 4 :\n        stones = K\n    elif min ( N , M ) <= 2 :\n        stones = K\n    elif min ( N , M ) == 3 :\n        enclosed = int ( ( K - 2 ) / 3 )\n        enclosed = min ( enclosed , max ( N , M ) - 2 )\n        stones = K - enclosed\n    else :\n        if K < 8 :\n            enclosed = 1\n        elif K < 10 :\n            enclosed = 2\n        elif K < 12 :\n            enclosed = 3\n        elif K < 14 or max ( N , M ) == 4 :\n            enclosed = 4\n        elif K < 16 :\n            enclosed = 5\n        else :\n            enclosed = 6\n        stones = K - enclosed\n    output = str ( stones )\n    print ( \"Case #\" + str ( i + 1 ) + \": \" + output )\n", "python_code_tokenized": "import sys NEW_LINE iFile = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE size = int ( iFile . readline ( ) . strip ( ) ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT line = iFile . readline ( ) . strip ( ) . split ( ) NEW_LINE N = int ( line [ 0 ] ) NEW_LINE M = int ( line [ 1 ] ) NEW_LINE K = int ( line [ 2 ] ) NEW_LINE stones = 0 NEW_LINE if K <= 4 : NEW_LINE INDENT stones = K NEW_LINE DEDENT elif min ( N , M ) <= 2 : NEW_LINE INDENT stones = K NEW_LINE DEDENT elif min ( N , M ) == 3 : NEW_LINE INDENT enclosed = int ( ( K - 2 ) / 3 ) NEW_LINE enclosed = min ( enclosed , max ( N , M ) - 2 ) NEW_LINE stones = K - enclosed NEW_LINE DEDENT else : NEW_LINE INDENT if K < 8 : NEW_LINE INDENT enclosed = 1 NEW_LINE DEDENT elif K < 10 : NEW_LINE INDENT enclosed = 2 NEW_LINE DEDENT elif K < 12 : NEW_LINE INDENT enclosed = 3 NEW_LINE DEDENT elif K < 14 or max ( N , M ) == 4 : NEW_LINE INDENT enclosed = 4 NEW_LINE DEDENT elif K < 16 : NEW_LINE INDENT enclosed = 5 NEW_LINE DEDENT else : NEW_LINE INDENT enclosed = 6 NEW_LINE DEDENT stones = K - enclosed NEW_LINE DEDENT output = str ( stones ) NEW_LINE print ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \u2581 \" + output ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_241_A", "sol": 0, "python_code": "def numOfsubarrays ( arr , n ) :\n    count = 0\n    for i in range ( n ) :\n        product = arr [ i ]\n        sum = arr [ i ]\n        for j in range ( i + 1 , n ) :\n            if ( product == sum ) :\n                count += 1\n            product *= arr [ j ]\n            sum += arr [ j ]\n        if ( product == sum ) :\n            count += 1\n    return count\narr = [ 1 , 3 , 2 ]\nn = len ( arr )\nprint ( numOfsubarrays ( arr , n ) )\n", "python_code_tokenized": "def numOfsubarrays ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = arr [ i ] NEW_LINE sum = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( product == sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT product *= arr [ j ] NEW_LINE sum += arr [ j ] NEW_LINE DEDENT if ( product == sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( numOfsubarrays ( arr , n ) ) NEW_LINE"}
{"id": "atcoder_ABC144_E", "sol": 0, "python_code": "from sys import stdin\nimport numpy as np\ndef main ( ) :\n    readline = stdin.readline\n    n , k = map ( int , readline ( ).split ( ) )\n    A = np.array ( list ( map ( int , readline ( ).split ( ) ) ) , dtype = np.int64 )\n    A = np.sort ( A ) [ : : - 1 ]\n    F = np.array ( list ( map ( int , readline ( ).split ( ) ) ) , dtype = np.int64 )\n    F = np.sort ( F )\n    l = - 1\n    r = 10 ** 12\n    while l < r - 1 :\n        x = ( l + r ) // 2\n        A_after = np.minimum ( x // F , A )\n        cnt = ( A - A_after ).sum ( )\n        if cnt <= k : r = x\n        else : l = x\n    print ( r )\nif __name__ == \"__main__\" :\n    main ( )\n", "python_code_tokenized": "from sys import stdin NEW_LINE import numpy as np NEW_LINE def main ( ) : NEW_LINE INDENT readline = stdin . readline NEW_LINE n , k = map ( int , readline ( ) . split ( ) ) NEW_LINE A = np . array ( list ( map ( int , readline ( ) . split ( ) ) ) , dtype = np . int64 ) NEW_LINE A = np . sort ( A ) [ : : - 1 ] NEW_LINE F = np . array ( list ( map ( int , readline ( ) . split ( ) ) ) , dtype = np . int64 ) NEW_LINE F = np . sort ( F ) NEW_LINE l = - 1 NEW_LINE r = 10 ** 12 NEW_LINE while l < r - 1 : NEW_LINE INDENT x = ( l + r ) // 2 NEW_LINE A_after = np . minimum ( x // F , A ) NEW_LINE cnt = ( A - A_after ) . sum ( ) NEW_LINE if cnt <= k : r = x NEW_LINE else : l = x NEW_LINE DEDENT print ( r ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC020_C", "sol": 0, "python_code": "import sys\nreadline = sys.stdin.readline\nN = int ( readline ( ) )\nA = list ( map ( int , readline ( ).split ( ) ) )\nS = sum ( A )\nbits = 1\nfor a in A :\n    bits |= bits << a\nans = ( S + 1 ) // 2\nbits >>= ans\nwhile True :\n    if bits & 1 :\n        print ( ans )\n        exit ( )\n    bits >>= 1\n    ans += 1\n", "python_code_tokenized": "import sys NEW_LINE readline = sys . stdin . readline NEW_LINE N = int ( readline ( ) ) NEW_LINE A = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE S = sum ( A ) NEW_LINE bits = 1 NEW_LINE for a in A : NEW_LINE INDENT bits |= bits << a NEW_LINE DEDENT ans = ( S + 1 ) // 2 NEW_LINE bits >>= ans NEW_LINE while True : NEW_LINE INDENT if bits & 1 : NEW_LINE INDENT print ( ans ) NEW_LINE exit ( ) NEW_LINE DEDENT bits >>= 1 NEW_LINE ans += 1 NEW_LINE DEDENT"}
{"id": "aizu_p01694_A", "sol": 0, "python_code": "while True :\n    n = int ( input ( ) )\n    if n == 0 :\n        break\n    f = list ( input ( ).split ( ) )\n    is_on = False\n    left_up = False\n    right_up = False\n    ans = 0\n    for i in range ( n ) :\n        if f [ i ] == \"lu\" :\n            left_up = True\n        elif f [ i ] == \"ld\" :\n            left_up = False\n        elif f [ i ] == \"ru\" :\n            right_up = True\n        else :\n            right_up = False\n        if left_up and right_up and not is_on :\n            is_on = True\n            ans += 1\n        elif not left_up and not right_up and is_on :\n            is_on = False\n            ans += 1\n    print ( ans )\n", "python_code_tokenized": "while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT f = list ( input ( ) . split ( ) ) NEW_LINE is_on = False NEW_LINE left_up = False NEW_LINE right_up = False NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if f [ i ] == \" lu \" : NEW_LINE INDENT left_up = True NEW_LINE DEDENT elif f [ i ] == \" ld \" : NEW_LINE INDENT left_up = False NEW_LINE DEDENT elif f [ i ] == \" ru \" : NEW_LINE INDENT right_up = True NEW_LINE DEDENT else : NEW_LINE INDENT right_up = False NEW_LINE DEDENT if left_up and right_up and not is_on : NEW_LINE INDENT is_on = True NEW_LINE ans += 1 NEW_LINE DEDENT elif not left_up and not right_up and is_on : NEW_LINE INDENT is_on = False NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "codeforces_1472_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor test in range ( t ) :\n    w , h , n = map ( int , input ( ).split ( ) )\n    w_first = w\n    h_first = h\n    if n == 1 :\n        print ( 'YES' )\n    elif w % 2 == 1 and h % 2 == 1 :\n        print ( 'NO' )\n    else :\n        if w % 2 == 0 and h % 2 == 1 :\n            count = 0\n            while w % 2 == 0 :\n                w /= 2\n                count += 1\n            if w == 1 :\n                num = w_first\n            else :\n                num = 2 ** count\n        elif h % 2 == 0 and w % 2 == 1 :\n            count = 0\n            while h % 2 == 0 :\n                h /= 2\n                count += 1\n            if h == 1 :\n                num = h_first\n            else :\n                num = 2 ** count\n        elif h % 2 == 0 and w % 2 == 0 :\n            num = 0\n            count = 0\n            while w % 2 == 0 :\n                w /= 2\n                count += 1\n            if w == 1 :\n                num1 = w_first\n            else :\n                num1 = 2 ** count\n            count = 0\n            while h % 2 == 0 :\n                h /= 2\n                count += 1\n            if h == 1 :\n                num2 = h_first\n            else :\n                num2 = 2 ** count\n            num = num1 * num2\n        if num >= n :\n            print ( 'YES' )\n        else :\n            print ( 'NO' )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for test in range ( t ) : NEW_LINE INDENT w , h , n = map ( int , input ( ) . split ( ) ) NEW_LINE w_first = w NEW_LINE h_first = h NEW_LINE if n == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT elif w % 2 == 1 and h % 2 == 1 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if w % 2 == 0 and h % 2 == 1 : NEW_LINE INDENT count = 0 NEW_LINE while w % 2 == 0 : NEW_LINE INDENT w /= 2 NEW_LINE count += 1 NEW_LINE DEDENT if w == 1 : NEW_LINE INDENT num = w_first NEW_LINE DEDENT else : NEW_LINE INDENT num = 2 ** count NEW_LINE DEDENT DEDENT elif h % 2 == 0 and w % 2 == 1 : NEW_LINE INDENT count = 0 NEW_LINE while h % 2 == 0 : NEW_LINE INDENT h /= 2 NEW_LINE count += 1 NEW_LINE DEDENT if h == 1 : NEW_LINE INDENT num = h_first NEW_LINE DEDENT else : NEW_LINE INDENT num = 2 ** count NEW_LINE DEDENT DEDENT elif h % 2 == 0 and w % 2 == 0 : NEW_LINE INDENT num = 0 NEW_LINE count = 0 NEW_LINE while w % 2 == 0 : NEW_LINE INDENT w /= 2 NEW_LINE count += 1 NEW_LINE DEDENT if w == 1 : NEW_LINE INDENT num1 = w_first NEW_LINE DEDENT else : NEW_LINE INDENT num1 = 2 ** count NEW_LINE DEDENT count = 0 NEW_LINE while h % 2 == 0 : NEW_LINE INDENT h /= 2 NEW_LINE count += 1 NEW_LINE DEDENT if h == 1 : NEW_LINE INDENT num2 = h_first NEW_LINE DEDENT else : NEW_LINE INDENT num2 = 2 ** count NEW_LINE DEDENT num = num1 * num2 NEW_LINE DEDENT if num >= n : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_3714_A", "sol": 0, "python_code": "def find_extra_element_index ( arrA , arrB ) :\n    extra_element = sum ( arrA ) - sum ( arrB )\n    return arrA.index ( extra_element )\narrA = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ]\narrB = [ 2 , 4 , 6 , 8 , 10 , 12 ]\nprint ( find_extra_element_index ( arrA , arrB ) )\n", "python_code_tokenized": "def find_extra_element_index ( arrA , arrB ) : NEW_LINE INDENT extra_element = sum ( arrA ) - sum ( arrB ) NEW_LINE return arrA . index ( extra_element ) NEW_LINE DEDENT arrA = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ] NEW_LINE arrB = [ 2 , 4 , 6 , 8 , 10 , 12 ] NEW_LINE print ( find_extra_element_index ( arrA , arrB ) ) NEW_LINE"}
{"id": "geeksforgeeks_1463_A", "sol": 0, "python_code": "def getLongestSeq ( a , n ) :\n    maxIdx = 0\n    maxLen = 0\n    currLen = 0\n    currIdx = 0\n    for k in range ( n ) :\n        if a [ k ] > 0 :\n            currLen += 1\n            if currLen == 1 :\n                currIdx = k\n        else :\n            if currLen > maxLen :\n                maxLen = currLen\n                maxIdx = currIdx\n            currLen = 0\n    if maxLen > 0 :\n        print ( 'Index : ' , maxIdx , ',Length : ' , maxLen , )\n    else :\n        print ( \"No positive sequence detected.\" )\narr = [ 1 , 2 , - 3 , 2 , 3 , 4 , - 6 , 1 , 2 , 3 , 4 , 5 , - 8 , 5 , 6 ]\nn = len ( arr )\ngetLongestSeq ( arr , n )\n", "python_code_tokenized": "def getLongestSeq ( a , n ) : NEW_LINE INDENT maxIdx = 0 NEW_LINE maxLen = 0 NEW_LINE currLen = 0 NEW_LINE currIdx = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if a [ k ] > 0 : NEW_LINE INDENT currLen += 1 NEW_LINE if currLen == 1 : NEW_LINE INDENT currIdx = k NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if currLen > maxLen : NEW_LINE INDENT maxLen = currLen NEW_LINE maxIdx = currIdx NEW_LINE DEDENT currLen = 0 NEW_LINE DEDENT DEDENT if maxLen > 0 : NEW_LINE INDENT print ( ' Index \u2581 : \u2581 ' , maxIdx , ' , Length \u2581 : \u2581 ' , maxLen , ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 positive \u2581 sequence \u2581 detected . \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , - 3 , 2 , 3 , 4 , - 6 , 1 , 2 , 3 , 4 , 5 , - 8 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE getLongestSeq ( arr , n ) NEW_LINE"}
{"id": "aizu_p00281_A", "sol": 0, "python_code": "while 1 :\n    try : n , m = map ( int , input ( ).split ( ) ) ;\n    except : break\n    rs = [ ]\n    while 1 :\n        line = input ( )\n        if line == \"0 0 0\" : break\n        s , t , e = map ( int , line.split ( ) )\n        rs.append ( ( s - 1 , t - 1 , e ) )\n    l = int ( input ( ) )\n    b = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( l ) ]\n    c = [ [ 0 ] * n for _ in range ( l ) ]\n    for s , t , e in rs :\n        for i in range ( l ) :\n            c [ i ] [ s ] += b [ i ] [ t ] * e\n    for i in range ( l ) :\n        print ( \" \".join ( str ( x ) for x in c [ i ] ) )\n", "python_code_tokenized": "while 1 : NEW_LINE INDENT try : n , m = map ( int , input ( ) . split ( ) ) ; NEW_LINE except : break NEW_LINE rs = [ ] NEW_LINE while 1 : NEW_LINE INDENT line = input ( ) NEW_LINE if line == \"0 \u2581 0 \u2581 0\" : break NEW_LINE s , t , e = map ( int , line . split ( ) ) NEW_LINE rs . append ( ( s - 1 , t - 1 , e ) ) NEW_LINE DEDENT l = int ( input ( ) ) NEW_LINE b = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( l ) ] NEW_LINE c = [ [ 0 ] * n for _ in range ( l ) ] NEW_LINE for s , t , e in rs : NEW_LINE INDENT for i in range ( l ) : NEW_LINE INDENT c [ i ] [ s ] += b [ i ] [ t ] * e NEW_LINE DEDENT DEDENT for i in range ( l ) : NEW_LINE INDENT print ( \" \u2581 \" . join ( str ( x ) for x in c [ i ] ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_5010_A", "sol": 0, "python_code": "def sum ( n ) :\n    i = 1\n    s = 0.0\n    for i in range ( 1 , n + 1 ) :\n        s = s + 1 / i ;\n    return s ;\nn = 5\nprint ( \"Sum is\" , round ( sum ( n ) , 6 ) )\n", "python_code_tokenized": "def sum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum \u2581 is \" , round ( sum ( n ) , 6 ) ) NEW_LINE"}
{"id": "atcoder_AGC027_B", "sol": 0, "python_code": "import array\nfrom bisect import *\nfrom collections import *\nimport fractions\nimport heapq\nfrom itertools import *\nimport math\nimport random\nimport re\nimport string\nimport sys\nN , X = map ( int , input ( ).split ( ) )\nXs = list ( map ( int , input ( ).split ( ) ) )\nYs = Xs [ : : - 1 ]\nY_sum = [ 0 ] * N\nY_sum [ 0 ] = Ys [ 0 ]\nfor i in range ( 1 , N ) :\n    Y_sum [ i ] = Y_sum [ i - 1 ] + Ys [ i ]\nans = 1e100\nfor rep_num in range ( 1 , N + 1 ) :\n    local_ans = X * rep_num\n    local_ans += 5 * Y_sum [ rep_num - 1 ]\n    i = 2 * rep_num - 1\n    n = 1\n    while i <= N - 1 :\n        local_ans += ( 2 * n + 3 ) * ( Y_sum [ i ] - Y_sum [ i - rep_num ] )\n        n += 1\n        i += rep_num\n    local_ans += ( 2 * n + 3 ) * ( Y_sum [ N - 1 ] - Y_sum [ i - rep_num ] )\n    ans = min ( ans , local_ans )\nprint ( ans + N * X )\n", "python_code_tokenized": "import array NEW_LINE from bisect import * NEW_LINE from collections import * NEW_LINE import fractions NEW_LINE import heapq NEW_LINE from itertools import * NEW_LINE import math NEW_LINE import random NEW_LINE import re NEW_LINE import string NEW_LINE import sys NEW_LINE N , X = map ( int , input ( ) . split ( ) ) NEW_LINE Xs = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Ys = Xs [ : : - 1 ] NEW_LINE Y_sum = [ 0 ] * N NEW_LINE Y_sum [ 0 ] = Ys [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT Y_sum [ i ] = Y_sum [ i - 1 ] + Ys [ i ] NEW_LINE DEDENT ans = 1e100 NEW_LINE for rep_num in range ( 1 , N + 1 ) : NEW_LINE INDENT local_ans = X * rep_num NEW_LINE local_ans += 5 * Y_sum [ rep_num - 1 ] NEW_LINE i = 2 * rep_num - 1 NEW_LINE n = 1 NEW_LINE while i <= N - 1 : NEW_LINE INDENT local_ans += ( 2 * n + 3 ) * ( Y_sum [ i ] - Y_sum [ i - rep_num ] ) NEW_LINE n += 1 NEW_LINE i += rep_num NEW_LINE DEDENT local_ans += ( 2 * n + 3 ) * ( Y_sum [ N - 1 ] - Y_sum [ i - rep_num ] ) NEW_LINE ans = min ( ans , local_ans ) NEW_LINE DEDENT print ( ans + N * X ) NEW_LINE"}
{"id": "geeksforgeeks_2623_A", "sol": 0, "python_code": "def findNthTerm ( N ) :\n    ans = 0 ;\n    if ( N % 2 == 0 ) :\n        ans = ( N // 2 ) * 6 + ( N // 2 ) * 2 ;\n    else :\n        ans = ( N // 2 + 1 ) * 6 + ( N // 2 ) * 2 ;\n    print ( ans ) ;\nif __name__ == '__main__' :\n    N = 3 ;\n    findNthTerm ( N ) ;\n", "python_code_tokenized": "def findNthTerm ( N ) : NEW_LINE INDENT ans = 0 ; NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT ans = ( N // 2 ) * 6 + ( N // 2 ) * 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N // 2 + 1 ) * 6 + ( N // 2 ) * 2 ; NEW_LINE DEDENT print ( ans ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 ; NEW_LINE findNthTerm ( N ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3793_A", "sol": 0, "python_code": "from collections import deque\ndef minimumMulitplications ( start , end , a , n ) :\n    ans = [ - 1 for i in range ( 100001 ) ]\n    mod = 100000\n    q = deque ( )\n    q.append ( start % mod )\n    ans [ start ] = 0\n    while ( len ( q ) > 0 ) :\n        top = q.popleft ( )\n        if ( top == end ) :\n            return ans [ end ]\n        for i in range ( n ) :\n            pushed = top * a [ i ]\n            pushed = pushed % mod\n            if ( ans [ pushed ] == - 1 ) :\n                ans [ pushed ] = ans [ top ] + 1\n                q.append ( pushed )\n    return - 1\nstart = 7\nend = 66175\na = [ 3 , 4 , 65 ]\nn = len ( a )\nprint ( minimumMulitplications ( start , end , a , n ) )\n", "python_code_tokenized": "from collections import deque NEW_LINE def minimumMulitplications ( start , end , a , n ) : NEW_LINE INDENT ans = [ - 1 for i in range ( 100001 ) ] NEW_LINE mod = 100000 NEW_LINE q = deque ( ) NEW_LINE q . append ( start % mod ) NEW_LINE ans [ start ] = 0 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT top = q . popleft ( ) NEW_LINE if ( top == end ) : NEW_LINE INDENT return ans [ end ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT pushed = top * a [ i ] NEW_LINE pushed = pushed % mod NEW_LINE if ( ans [ pushed ] == - 1 ) : NEW_LINE INDENT ans [ pushed ] = ans [ top ] + 1 NEW_LINE q . append ( pushed ) NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT start = 7 NEW_LINE end = 66175 NEW_LINE a = [ 3 , 4 , 65 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumMulitplications ( start , end , a , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_5133_A", "sol": 0, "python_code": "def countEvenOdd ( num , n ) :\n    even_count = 0 ;\n    odd_count = 0 ;\n    num = list ( str ( num ) )\n    for i in num :\n        if i in ( '0' , '2' , '4' , '6' , '8' ) :\n            even_count += 1\n        else :\n            odd_count += 1\n    print ( \"Even count : \" , even_count ) ;\n    print ( \"Odd count : \" , odd_count ) ;\n    if ( even_count % 2 == 0 and odd_count % 2 != 0 ) :\n        return 1 ;\n    else :\n        return 0 ;\nnum = ( 1 , 2 , 3 ) ;\nn = len ( num ) ;\nt = countEvenOdd ( num , n ) ;\nif t == 1 :\n    print ( \"YES\" ) ;\nelse :\n    print ( \"NO\" ) ;\n", "python_code_tokenized": "def countEvenOdd ( num , n ) : NEW_LINE INDENT even_count = 0 ; NEW_LINE odd_count = 0 ; NEW_LINE num = list ( str ( num ) ) NEW_LINE for i in num : NEW_LINE INDENT if i in ( '0' , '2' , '4' , '6' , '8' ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT DEDENT print ( \" Even \u2581 count \u2581 : \u2581 \" , even_count ) ; NEW_LINE print ( \" Odd \u2581 count \u2581 : \u2581 \" , odd_count ) ; NEW_LINE if ( even_count % 2 == 0 and odd_count % 2 != 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT num = ( 1 , 2 , 3 ) ; NEW_LINE n = len ( num ) ; NEW_LINE t = countEvenOdd ( num , n ) ; NEW_LINE if t == 1 : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1165_B", "sol": 0, "python_code": "n = int ( input ( ) )\narr = list ( sorted ( map ( int , input ( ).split ( ) ) ) )\ni = 0\nk = 1\nans = 0\nwhile i < n :\n    while i < n and arr [ i ] < k :\n        i += 1\n    if i == n :\n        k -= 1\n    k += 1\n    i += 1\nprint ( k - 1 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE arr = list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE i = 0 NEW_LINE k = 1 NEW_LINE ans = 0 NEW_LINE while i < n : NEW_LINE INDENT while i < n and arr [ i ] < k : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == n : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT k += 1 NEW_LINE i += 1 NEW_LINE DEDENT print ( k - 1 ) NEW_LINE"}
{"id": "codeforces_678_A", "sol": 0, "python_code": "vamshi , z = map ( int , input ( ).split ( ) )\nprint ( ( vamshi // z + 1 ) * z )\n", "python_code_tokenized": "vamshi , z = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( vamshi // z + 1 ) * z ) NEW_LINE"}
{"id": "atcoder_ABC148_C", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\na , b = ( int ( x ) for x in input ( ).split ( ) )\nmin_ = min ( [ a , b ] )\nret = a * b\nfor i in reversed ( range ( 1 , min_ + 1 ) ) :\n    if a % i == 0 and b % i == 0 :\n        ret = int ( a * b / i )\n        break\nprint ( ret )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE a , b = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE min_ = min ( [ a , b ] ) NEW_LINE ret = a * b NEW_LINE for i in reversed ( range ( 1 , min_ + 1 ) ) : NEW_LINE INDENT if a % i == 0 and b % i == 0 : NEW_LINE INDENT ret = int ( a * b / i ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( ret ) NEW_LINE"}
{"id": "geeksforgeeks_2600_A", "sol": 0, "python_code": "power = [ 0 ] * 31\npre = [ 0 ] * 31\ndef PowerOfTwo ( ) :\n    x = 1\n    for i in range ( 31 ) :\n        power [ i ] = x\n        x *= 2\n    pre [ 0 ] = 1\n    for i in range ( 1 , 31 ) :\n        pre [ i ] = pre [ i - 1 ] + power [ i ]\ndef Sum ( n ) :\n    ans = n * ( n + 1 ) // 2\n    for i in range ( 31 ) :\n        if ( power [ i ] > n ) :\n            ans -= 2 * pre [ i - 1 ]\n            break\n    return ans\nif __name__ == \"__main__\" :\n    PowerOfTwo ( )\n    n = 4\n    print ( Sum ( n ) )\n", "python_code_tokenized": "power = [ 0 ] * 31 NEW_LINE pre = [ 0 ] * 31 NEW_LINE def PowerOfTwo ( ) : NEW_LINE INDENT x = 1 NEW_LINE for i in range ( 31 ) : NEW_LINE INDENT power [ i ] = x NEW_LINE x *= 2 NEW_LINE DEDENT pre [ 0 ] = 1 NEW_LINE for i in range ( 1 , 31 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + power [ i ] NEW_LINE DEDENT DEDENT def Sum ( n ) : NEW_LINE INDENT ans = n * ( n + 1 ) // 2 NEW_LINE for i in range ( 31 ) : NEW_LINE INDENT if ( power [ i ] > n ) : NEW_LINE INDENT ans -= 2 * pre [ i - 1 ] NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT PowerOfTwo ( ) NEW_LINE n = 4 NEW_LINE print ( Sum ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_298_A", "sol": 0, "python_code": "MOD = 1000000007\ndef solve ( test ) :\n    size = len ( test )\n    total = 0\n    for i in range ( 9 ) :\n        x = i\n        y = i + 1\n        newtest = \"\"\n        for j in range ( size ) :\n            if ( ord ( test [ j ] ) == x + 48 or ord ( test [ j ] ) == y + 48 ) :\n                newtest += test [ j ]\n        if ( len ( newtest ) > 0 ) :\n            size1 = len ( newtest )\n            prefix = [ 0 for i in range ( size1 ) ]\n            for j in range ( size1 ) :\n                if ( ord ( newtest [ j ] ) == y + 48 ) :\n                    prefix [ j ] += 1\n            for j in range ( 1 , size1 ) :\n                prefix [ j ] += prefix [ j - 1 ]\n            count = 0\n            firstcount = 0\n            ss = 0\n            prev = 0\n            for j in range ( size1 ) :\n                if ( ord ( newtest [ j ] ) == x + 48 ) :\n                    count += 1\n                    firstcount += 1\n                else :\n                    ss += count * count\n                    pairsum = ( firstcount * firstcount - ss ) // 2\n                    temp = pairsum\n                    pairsum -= prev\n                    prev = temp\n                    secondway = prefix [ size1 - 1 ]\n                    if ( j != 0 ) :\n                        secondway -= prefix [ j - 1 ]\n                    answer = count * ( count - 1 ) * secondway * ( secondway - 1 )\n                    answer //= 4\n                    answer += ( pairsum * secondway * ( secondway - 1 ) ) // 2\n                    total += answer\n                    count = 0\n    return total\ntest = \"13134422\"\nprint ( solve ( test ) )\n", "python_code_tokenized": "MOD = 1000000007 NEW_LINE def solve ( test ) : NEW_LINE INDENT size = len ( test ) NEW_LINE total = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT x = i NEW_LINE y = i + 1 NEW_LINE newtest = \" \" NEW_LINE for j in range ( size ) : NEW_LINE INDENT if ( ord ( test [ j ] ) == x + 48 or ord ( test [ j ] ) == y + 48 ) : NEW_LINE INDENT newtest += test [ j ] NEW_LINE DEDENT DEDENT if ( len ( newtest ) > 0 ) : NEW_LINE INDENT size1 = len ( newtest ) NEW_LINE prefix = [ 0 for i in range ( size1 ) ] NEW_LINE for j in range ( size1 ) : NEW_LINE INDENT if ( ord ( newtest [ j ] ) == y + 48 ) : NEW_LINE INDENT prefix [ j ] += 1 NEW_LINE DEDENT DEDENT for j in range ( 1 , size1 ) : NEW_LINE INDENT prefix [ j ] += prefix [ j - 1 ] NEW_LINE DEDENT count = 0 NEW_LINE firstcount = 0 NEW_LINE ss = 0 NEW_LINE prev = 0 NEW_LINE for j in range ( size1 ) : NEW_LINE INDENT if ( ord ( newtest [ j ] ) == x + 48 ) : NEW_LINE INDENT count += 1 NEW_LINE firstcount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ss += count * count NEW_LINE pairsum = ( firstcount * firstcount - ss ) // 2 NEW_LINE temp = pairsum NEW_LINE pairsum -= prev NEW_LINE prev = temp NEW_LINE secondway = prefix [ size1 - 1 ] NEW_LINE if ( j != 0 ) : NEW_LINE INDENT secondway -= prefix [ j - 1 ] NEW_LINE DEDENT answer = count * ( count - 1 ) * secondway * ( secondway - 1 ) NEW_LINE answer //= 4 NEW_LINE answer += ( pairsum * secondway * ( secondway - 1 ) ) // 2 NEW_LINE total += answer NEW_LINE count = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT return total NEW_LINE DEDENT test = \"13134422\" NEW_LINE print ( solve ( test ) ) NEW_LINE"}
{"id": "geeksforgeeks_3768_A", "sol": 0, "python_code": "def minReplace ( a : list , n ) -> int :\n    te = dict ( )\n    to = dict ( )\n    for i in range ( n ) :\n        if i % 2 == 0 :\n            if a [ i ] not in te :\n                te [ a [ i ] ] = 1\n            else :\n                te [ a [ i ] ] += 1\n        else :\n            if a [ i ] not in to :\n                to [ a [ i ] ] = 1\n            else :\n                to [ a [ i ] ] += 1\n    me = - 1\n    mo = - 1\n    ce = - 1\n    co = - 1\n    for it in te :\n        if te [ it ] > ce :\n            ce = te [ it ]\n            me = it\n    for it in to :\n        if to [ it ] > co :\n            co = to [ it ]\n            mo = it\n    res = 0\n    for i in range ( n ) :\n        if i % 2 == 0 :\n            if a [ i ] != me :\n                res += 1\n        else :\n            if a [ i ] != mo :\n                res += 1\n    return res\nif __name__ == \"__main__\" :\n    n = 4\n    a = [ 3 , 1 , 3 , 2 ]\n    print ( minReplace ( a , n ) )\n", "python_code_tokenized": "def minReplace ( a : list , n ) -> int : NEW_LINE INDENT te = dict ( ) NEW_LINE to = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT if a [ i ] not in te : NEW_LINE INDENT te [ a [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT te [ a [ i ] ] += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ i ] not in to : NEW_LINE INDENT to [ a [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT to [ a [ i ] ] += 1 NEW_LINE DEDENT DEDENT DEDENT me = - 1 NEW_LINE mo = - 1 NEW_LINE ce = - 1 NEW_LINE co = - 1 NEW_LINE for it in te : NEW_LINE INDENT if te [ it ] > ce : NEW_LINE INDENT ce = te [ it ] NEW_LINE me = it NEW_LINE DEDENT DEDENT for it in to : NEW_LINE INDENT if to [ it ] > co : NEW_LINE INDENT co = to [ it ] NEW_LINE mo = it NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT if a [ i ] != me : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ i ] != mo : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE a = [ 3 , 1 , 3 , 2 ] NEW_LINE print ( minReplace ( a , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_894_A", "sol": 0, "python_code": "S = input ( )\ntotalQ = S.count ( \"Q\" )\nCQ = 0\nCQAQ = 0\nfor i in S :\n    if i == \"Q\" :\n        CQ += 1\n    elif i == \"A\" :\n        CQAQ += CQ * ( totalQ - CQ )\nprint ( CQAQ )\n", "python_code_tokenized": "S = input ( ) NEW_LINE totalQ = S . count ( \" Q \" ) NEW_LINE CQ = 0 NEW_LINE CQAQ = 0 NEW_LINE for i in S : NEW_LINE INDENT if i == \" Q \" : NEW_LINE INDENT CQ += 1 NEW_LINE DEDENT elif i == \" A \" : NEW_LINE INDENT CQAQ += CQ * ( totalQ - CQ ) NEW_LINE DEDENT DEDENT print ( CQAQ ) NEW_LINE"}
{"id": "geeksforgeeks_1596_A", "sol": 0, "python_code": "def findMaximum ( arr , low , high ) :\n    if low == high :\n        return arr [ low ]\n    if high == low + 1 and arr [ low ] >= arr [ high ] :\n        return arr [ low ] ;\n    if high == low + 1 and arr [ low ] < arr [ high ] :\n        return arr [ high ]\n    mid = ( low + high ) // 2\n    if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] :\n        return arr [ mid ]\n    if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] :\n        return findMaximum ( arr , low , mid - 1 )\n    else :\n        return findMaximum ( arr , mid + 1 , high )\narr = [ 1 , 3 , 50 , 10 , 9 , 7 , 6 ]\nn = len ( arr )\nprint ( \"The maximum element is %d\" % findMaximum ( arr , 0 , n - 1 ) )\n", "python_code_tokenized": "def findMaximum ( arr , low , high ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if high == low + 1 and arr [ low ] >= arr [ high ] : NEW_LINE INDENT return arr [ low ] ; NEW_LINE DEDENT if high == low + 1 and arr [ low ] < arr [ high ] : NEW_LINE INDENT return arr [ high ] NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return findMaximum ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findMaximum ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 50 , 10 , 9 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" The \u2581 maximum \u2581 element \u2581 is \u2581 % d \" % findMaximum ( arr , 0 , n - 1 ) ) NEW_LINE"}
{"id": "codeforces_1242_A", "sol": 0, "python_code": "n = int ( input ( ) )\ncount = 1\ndivisor = n\nfor i in range ( 2 , n + 1 ) :\n    if i * i > n :\n        break\n    if n % i == 0 :\n        while n % i == 0 :\n            n //= i\n        if n == 1 :\n            print ( i )\n        else :\n            print ( 1 )\n        exit ( 0 )\nprint ( n )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE count = 1 NEW_LINE divisor = n NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if n % i == 0 : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT n //= i NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT exit ( 0 ) NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE"}
{"id": "geeksforgeeks_1368_A", "sol": 0, "python_code": "def countMultiples ( n ) :\n    res = 0 ;\n    for i in range ( 1 , n + 1 ) :\n        if ( i % 3 == 0 or i % 7 == 0 ) :\n            res += 1 ;\n    return res ;\nprint ( \"Count =\" , countMultiples ( 25 ) ) ;\n", "python_code_tokenized": "def countMultiples ( n ) : NEW_LINE INDENT res = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 3 == 0 or i % 7 == 0 ) : NEW_LINE INDENT res += 1 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT print ( \" Count \u2581 = \" , countMultiples ( 25 ) ) ; NEW_LINE"}
{"id": "aizu_p02277_A", "sol": 0, "python_code": "def partition ( A , p , r ) :\n    q = p\n    for i in range ( p , r ) :\n        if A [ i ] [ 1 ] <= A [ r ] [ 1 ] :\n            A [ q ] , A [ i ] = A [ i ] , A [ q ]\n            q += 1\n    A [ q ] , A [ r ] = A [ r ] , A [ q ]\n    return q\ndef quicksort ( A , left , right ) :\n    if left < right :\n        q = partition ( A , left , right )\n        quicksort ( A , left , q - 1 )\n        quicksort ( A , q + 1 , right )\ndef check_stable ( A ) :\n    for i in range ( 1 , len ( A ) ) :\n        if A [ i - 1 ] [ 1 ] == A [ i ] [ 1 ] :\n            if A [ i - 1 ] [ 2 ] > A [ i ] [ 2 ] :\n                return \"Not stable\"\n    return \"Stable\"\nn = int ( input ( ) )\ndata = [ ]\nfor i in range ( n ) :\n    mark , num = map ( str , input ( ).split ( ) )\n    data += [ [ mark , int ( num ) , i ] ]\nquicksort ( data , 0 , len ( data ) - 1 )\nprint ( check_stable ( data ) )\nfor line in data :\n    print ( line [ 0 ] , line [ 1 ] )\n", "python_code_tokenized": "def partition ( A , p , r ) : NEW_LINE INDENT q = p NEW_LINE for i in range ( p , r ) : NEW_LINE INDENT if A [ i ] [ 1 ] <= A [ r ] [ 1 ] : NEW_LINE INDENT A [ q ] , A [ i ] = A [ i ] , A [ q ] NEW_LINE q += 1 NEW_LINE DEDENT DEDENT A [ q ] , A [ r ] = A [ r ] , A [ q ] NEW_LINE return q NEW_LINE DEDENT def quicksort ( A , left , right ) : NEW_LINE INDENT if left < right : NEW_LINE INDENT q = partition ( A , left , right ) NEW_LINE quicksort ( A , left , q - 1 ) NEW_LINE quicksort ( A , q + 1 , right ) NEW_LINE DEDENT DEDENT def check_stable ( A ) : NEW_LINE INDENT for i in range ( 1 , len ( A ) ) : NEW_LINE INDENT if A [ i - 1 ] [ 1 ] == A [ i ] [ 1 ] : NEW_LINE INDENT if A [ i - 1 ] [ 2 ] > A [ i ] [ 2 ] : NEW_LINE INDENT return \" Not \u2581 stable \" NEW_LINE DEDENT DEDENT DEDENT return \" Stable \" NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE data = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT mark , num = map ( str , input ( ) . split ( ) ) NEW_LINE data += [ [ mark , int ( num ) , i ] ] NEW_LINE DEDENT quicksort ( data , 0 , len ( data ) - 1 ) NEW_LINE print ( check_stable ( data ) ) NEW_LINE for line in data : NEW_LINE INDENT print ( line [ 0 ] , line [ 1 ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4678_A", "sol": 0, "python_code": "from math import *\ndef calculateSum ( n ) :\n    r1 , r2 = 2 , 3\n    a1 , a2 = 1 , 1\n    return ( a1 * ( pow ( r1 , n ) - 1 ) // ( r1 - 1 ) + a2 * ( pow ( r2 , n ) - 1 ) // ( r2 - 1 ) )\nif __name__ == \"__main__\" :\n    n = 4\n    print ( \"SUM = \" , calculateSum ( n ) )\n", "python_code_tokenized": "from math import * NEW_LINE def calculateSum ( n ) : NEW_LINE INDENT r1 , r2 = 2 , 3 NEW_LINE a1 , a2 = 1 , 1 NEW_LINE return ( a1 * ( pow ( r1 , n ) - 1 ) // ( r1 - 1 ) + a2 * ( pow ( r2 , n ) - 1 ) // ( r2 - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE print ( \" SUM \u2581 = \u2581 \" , calculateSum ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1841_A", "sol": 0, "python_code": "def countMaxSetBits ( left , right ) :\n    max_count = - 1\n    for i in range ( left , right + 1 ) :\n        temp = i\n        cnt = 0\n        while temp :\n            if temp & 1 :\n                cnt += 1\n            temp = temp >> 1\n        if cnt > max_count :\n            max_count = cnt\n            num = i\n    return num\nl = 1\nr = 5\nprint ( countMaxSetBits ( l , r ) )\nl = 1\nr = 10\nprint ( countMaxSetBits ( l , r ) )\n", "python_code_tokenized": "def countMaxSetBits ( left , right ) : NEW_LINE INDENT max_count = - 1 NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT temp = i NEW_LINE cnt = 0 NEW_LINE while temp : NEW_LINE INDENT if temp & 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT temp = temp >> 1 NEW_LINE DEDENT if cnt > max_count : NEW_LINE INDENT max_count = cnt NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT l = 1 NEW_LINE r = 5 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE l = 1 NEW_LINE r = 10 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE"}
{"id": "atcoder_ABC167_E", "sol": 0, "python_code": "n , m , k = map ( int , input ( ).split ( ) )\nmod = 998244353\nans = 0\ndef cmb ( n , r , p ) :\n    if ( r < 0 ) or ( n < r ) :\n        return 0\n    r = min ( r , n - r )\n    return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p\np = mod\nN = 10 ** 6\nfact = [ 1 , 1 ]\nfactinv = [ 1 , 1 ]\ninv = [ 0 , 1 ]\nfor i in range ( 2 , N + 1 ) :\n    fact.append ( ( fact [ - 1 ] * i ) % p )\n    inv.append ( ( - inv [ p % i ] * ( p // i ) ) % p )\n    factinv.append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % p )\nfor i in range ( 0 , k + 1 ) :\n    ans += m * pow ( m - 1 , n - 1 - i , mod ) * cmb ( n - 1 , i , p )\n    ans %= mod\nprint ( ans )\n", "python_code_tokenized": "n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE mod = 998244353 NEW_LINE ans = 0 NEW_LINE def cmb ( n , r , p ) : NEW_LINE INDENT if ( r < 0 ) or ( n < r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT r = min ( r , n - r ) NEW_LINE return fact [ n ] * factinv [ r ] * factinv [ n - r ] % p NEW_LINE DEDENT p = mod NEW_LINE N = 10 ** 6 NEW_LINE fact = [ 1 , 1 ] NEW_LINE factinv = [ 1 , 1 ] NEW_LINE inv = [ 0 , 1 ] NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT fact . append ( ( fact [ - 1 ] * i ) % p ) NEW_LINE inv . append ( ( - inv [ p % i ] * ( p // i ) ) % p ) NEW_LINE factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % p ) NEW_LINE DEDENT for i in range ( 0 , k + 1 ) : NEW_LINE INDENT ans += m * pow ( m - 1 , n - 1 - i , mod ) * cmb ( n - 1 , i , p ) NEW_LINE ans %= mod NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "atcoder_ABC046_A", "sol": 0, "python_code": "print ( len ( set ( map ( int , input ( ).split ( ) ) ) ) )\n", "python_code_tokenized": "print ( len ( set ( map ( int , input ( ) . split ( ) ) ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_711_A", "sol": 0, "python_code": "def MSBPosition ( N ) :\n    msb_p = - 1\n    while ( N ) :\n        N = N >> 1\n        msb_p += 1\n    return msb_p\ndef findBitwiseOR ( L , R ) :\n    res = 0\n    msb_p1 = MSBPosition ( L )\n    msb_p2 = MSBPosition ( R )\n    while ( msb_p1 == msb_p2 ) :\n        res_val = ( 1 << msb_p1 )\n        res += res_val\n        L -= res_val\n        R -= res_val\n        msb_p1 = MSBPosition ( L )\n        msb_p2 = MSBPosition ( R )\n    msb_p1 = max ( msb_p1 , msb_p2 )\n    for i in range ( msb_p1 , - 1 , - 1 ) :\n        res_val = ( 1 << i )\n        res += res_val\n    return res\nif __name__ == \"__main__\" :\n    L , R = 12 , 18\n    print ( findBitwiseOR ( L , R ) )\n", "python_code_tokenized": "def MSBPosition ( N ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( N ) : NEW_LINE INDENT N = N >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def findBitwiseOR ( L , R ) : NEW_LINE INDENT res = 0 NEW_LINE msb_p1 = MSBPosition ( L ) NEW_LINE msb_p2 = MSBPosition ( R ) NEW_LINE while ( msb_p1 == msb_p2 ) : NEW_LINE INDENT res_val = ( 1 << msb_p1 ) NEW_LINE res += res_val NEW_LINE L -= res_val NEW_LINE R -= res_val NEW_LINE msb_p1 = MSBPosition ( L ) NEW_LINE msb_p2 = MSBPosition ( R ) NEW_LINE DEDENT msb_p1 = max ( msb_p1 , msb_p2 ) NEW_LINE for i in range ( msb_p1 , - 1 , - 1 ) : NEW_LINE INDENT res_val = ( 1 << i ) NEW_LINE res += res_val NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L , R = 12 , 18 NEW_LINE print ( findBitwiseOR ( L , R ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1461_A", "sol": 0, "python_code": "t = int ( input ( ) )\nwhile t > 0 :\n    t -= 1\n    n , k = ( int ( _ ) for _ in input ( ).strip ( ).split ( '' ) )\n    c = [ ]\n    for i in range ( 1 , n + 1 ) :\n        if i % 3 == 1 :\n            c.append ( 'a' )\n        if i % 3 == 2 :\n            c.append ( 'b' )\n        if i % 3 == 0 :\n            c.append ( 'c' )\n    for i in c [ : - 1 ] :\n        print ( i , end = '' )\n    print ( c [ - 1 ] )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE n , k = ( int ( _ ) for _ in input ( ) . strip ( ) . split ( ' \u2581 ' ) ) NEW_LINE c = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 3 == 1 : NEW_LINE INDENT c . append ( ' a ' ) NEW_LINE DEDENT if i % 3 == 2 : NEW_LINE INDENT c . append ( ' b ' ) NEW_LINE DEDENT if i % 3 == 0 : NEW_LINE INDENT c . append ( ' c ' ) NEW_LINE DEDENT DEDENT for i in c [ : - 1 ] : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE DEDENT print ( c [ - 1 ] ) NEW_LINE DEDENT"}
{"id": "atcoder_ARC078_B", "sol": 0, "python_code": "from collections import deque\nN = int ( input ( ) )\nG = dict ( )\nfor i in range ( N ) :\n    G [ i + 1 ] = [ ]\nfor _ in range ( N - 1 ) :\n    a , b = map ( int , input ( ).split ( ) )\n    G [ a ].append ( b )\n    G [ b ].append ( a )\ndist_1 = [ N ] * ( N + 1 )\ndist_1 [ 1 ] = 0\nque = deque ( [ 1 ] )\nwhile len ( que ) > 0 :\n    a = que.popleft ( )\n    for b in G [ a ] :\n        if dist_1 [ b ] > dist_1 [ a ] + 1 :\n            dist_1 [ b ] = dist_1 [ a ] + 1\n            que.append ( b )\ndist_N = [ N ] * ( N + 1 )\ndist_N [ N ] = 0\nque = deque ( [ N ] )\nwhile len ( que ) > 0 :\n    a = que.popleft ( )\n    for b in G [ a ] :\n        if dist_N [ b ] > dist_N [ a ] + 1 :\n            dist_N [ b ] = dist_N [ a ] + 1\n            que.append ( b )\ncount_Fennec = 0\nfor i in range ( N ) :\n    if dist_1 [ i + 1 ] <= dist_N [ i + 1 ] :\n        count_Fennec += 1\nif count_Fennec > N - count_Fennec :\n    print ( 'Fennec' )\nelse :\n    print ( 'Snuke' )\n", "python_code_tokenized": "from collections import deque NEW_LINE N = int ( input ( ) ) NEW_LINE G = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT G [ i + 1 ] = [ ] NEW_LINE DEDENT for _ in range ( N - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE G [ a ] . append ( b ) NEW_LINE G [ b ] . append ( a ) NEW_LINE DEDENT dist_1 = [ N ] * ( N + 1 ) NEW_LINE dist_1 [ 1 ] = 0 NEW_LINE que = deque ( [ 1 ] ) NEW_LINE while len ( que ) > 0 : NEW_LINE INDENT a = que . popleft ( ) NEW_LINE for b in G [ a ] : NEW_LINE INDENT if dist_1 [ b ] > dist_1 [ a ] + 1 : NEW_LINE INDENT dist_1 [ b ] = dist_1 [ a ] + 1 NEW_LINE que . append ( b ) NEW_LINE DEDENT DEDENT DEDENT dist_N = [ N ] * ( N + 1 ) NEW_LINE dist_N [ N ] = 0 NEW_LINE que = deque ( [ N ] ) NEW_LINE while len ( que ) > 0 : NEW_LINE INDENT a = que . popleft ( ) NEW_LINE for b in G [ a ] : NEW_LINE INDENT if dist_N [ b ] > dist_N [ a ] + 1 : NEW_LINE INDENT dist_N [ b ] = dist_N [ a ] + 1 NEW_LINE que . append ( b ) NEW_LINE DEDENT DEDENT DEDENT count_Fennec = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if dist_1 [ i + 1 ] <= dist_N [ i + 1 ] : NEW_LINE INDENT count_Fennec += 1 NEW_LINE DEDENT DEDENT if count_Fennec > N - count_Fennec : NEW_LINE INDENT print ( ' Fennec ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Snuke ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1766_A", "sol": 0, "python_code": "def getSingle ( arr , n ) :\n    ones = 0\n    twos = 0\n    for i in range ( n ) :\n        twos = twos | ( ones & arr [ i ] )\n        ones = ones ^ arr [ i ]\n        common_bit_mask = ~ ( ones & twos )\n        ones &= common_bit_mask\n        twos &= common_bit_mask\n    return ones\narr = [ 3 , 3 , 2 , 3 ]\nn = len ( arr )\nprint ( \"The element with single occurrence is \" , getSingle ( arr , n ) )\n", "python_code_tokenized": "def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT arr = [ 3 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" The \u2581 element \u2581 with \u2581 single \u2581 occurrence \u2581 is \u2581 \" , getSingle ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3987_A", "sol": 0, "python_code": "def trailing_zeros ( N ) :\n    count_of_two = 0\n    count_of_five = 0\n    for i in range ( 1 , N + 1 , 1 ) :\n        val = i\n        while ( val % 2 == 0 and val > 0 ) :\n            val /= 2\n            count_of_two += i\n        while ( val % 5 == 0 and val > 0 ) :\n            val /= 5\n            count_of_five += i\n    ans = min ( count_of_two , count_of_five )\n    return ans\nif __name__ == '__main__' :\n    N = 12\n    print ( trailing_zeros ( N ) )\n", "python_code_tokenized": "def trailing_zeros ( N ) : NEW_LINE INDENT count_of_two = 0 NEW_LINE count_of_five = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT val = i NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val /= 2 NEW_LINE count_of_two += i NEW_LINE DEDENT while ( val % 5 == 0 and val > 0 ) : NEW_LINE INDENT val /= 5 NEW_LINE count_of_five += i NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE print ( trailing_zeros ( N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4490_A", "sol": 0, "python_code": "import math\ndef countUnsetBits ( n ) :\n    x = n\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    t = math.log ( x ^ n , 2 )\n    return math.floor ( t )\nn = 17\nprint ( countUnsetBits ( n ) )\n", "python_code_tokenized": "import math NEW_LINE def countUnsetBits ( n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE t = math . log ( x ^ n , 2 ) NEW_LINE return math . floor ( t ) NEW_LINE DEDENT n = 17 NEW_LINE print ( countUnsetBits ( n ) ) NEW_LINE"}
{"id": "aizu_p01602_A", "sol": 0, "python_code": "n = int ( input ( ) )\npos = 0\nflag = True\nfor _ in range ( n ) :\n    k , num = input ( ).split ( )\n    num = int ( num )\n    if k == \"(\" :\n        pos += num\n    else :\n        pos -= num\n    if pos < 0 :\n        flag = False\nif not flag or pos != 0 :\n    print ( \"NO\" )\nelse :\n    print ( \"YES\" )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE pos = 0 NEW_LINE flag = True NEW_LINE for _ in range ( n ) : NEW_LINE INDENT k , num = input ( ) . split ( ) NEW_LINE num = int ( num ) NEW_LINE if k == \" ( \" : NEW_LINE INDENT pos += num NEW_LINE DEDENT else : NEW_LINE INDENT pos -= num NEW_LINE DEDENT if pos < 0 : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT if not flag or pos != 0 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT"}
{"id": "leetcode_475_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def findRadius ( self , houses , heaters ) :\n        heaters = sorted ( heaters ) + [ float ( 'inf' ) ]\n        i = r = 0\n        for x in sorted ( houses ) :\n            while x >= sum ( heaters [ i : i + 2 ] ) / 2.:\n                i += 1\n            r = max ( r , abs ( heaters [ i ] - x ) )\n        return r\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def findRadius ( self , houses , heaters ) : NEW_LINE INDENT heaters = sorted ( heaters ) + [ float ( ' inf ' ) ] NEW_LINE i = r = 0 NEW_LINE for x in sorted ( houses ) : NEW_LINE INDENT while x >= sum ( heaters [ i : i + 2 ] ) / 2. : NEW_LINE INDENT i += 1 NEW_LINE DEDENT r = max ( r , abs ( heaters [ i ] - x ) ) NEW_LINE DEDENT return r NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2354_A", "sol": 0, "python_code": "def minBinary ( n ) :\n    digit = [ 0 for i in range ( 3 ) ]\n    len = 0\n    while ( n > 0 ) :\n        digit [ len ] = n % 10\n        len += 1\n        n //= 10\n    digit = digit [ : : - 1 ]\n    ans = 0\n    for i in range ( len ) :\n        ans = max ( ans , digit [ i ] )\n    print ( \"Minimum Number of binary strings needed:\" , ans )\n    for i in range ( 1 , ans + 1 , 1 ) :\n        num = 0\n        for j in range ( 0 , len , 1 ) :\n            if ( digit [ j ] > 0 ) :\n                num = num * 10 + 1\n                digit [ j ] -= 1\n            else :\n                num *= 10\n        print ( num , end = \" \" )\nif __name__ == '__main__' :\n    n = 564\n    minBinary ( n )\n", "python_code_tokenized": "def minBinary ( n ) : NEW_LINE INDENT digit = [ 0 for i in range ( 3 ) ] NEW_LINE len = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit [ len ] = n % 10 NEW_LINE len += 1 NEW_LINE n //= 10 NEW_LINE DEDENT digit = digit [ : : - 1 ] NEW_LINE ans = 0 NEW_LINE for i in range ( len ) : NEW_LINE INDENT ans = max ( ans , digit [ i ] ) NEW_LINE DEDENT print ( \" Minimum \u2581 Number \u2581 of \u2581 binary \u2581 strings \u2581 needed : \" , ans ) NEW_LINE for i in range ( 1 , ans + 1 , 1 ) : NEW_LINE INDENT num = 0 NEW_LINE for j in range ( 0 , len , 1 ) : NEW_LINE INDENT if ( digit [ j ] > 0 ) : NEW_LINE INDENT num = num * 10 + 1 NEW_LINE digit [ j ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT num *= 10 NEW_LINE DEDENT DEDENT print ( num , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 564 NEW_LINE minBinary ( n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4695_A", "sol": 0, "python_code": "def maxRectangles ( L , B , l , b ) :\n    horizontal , vertical = 0 , 0\n    if l <= L and b <= B :\n        columns = B // b\n        rows = L // l\n        horizontal = rows * columns\n    if l <= B and b <= L :\n        columns = L // b\n        rows = B // l\n        vertical = rows * columns\n    return max ( horizontal , vertical )\nif __name__ == \"__main__\" :\n    L , B , l , b = 10 , 7 , 4 , 3\n    print ( maxRectangles ( L , B , l , b ) )\n", "python_code_tokenized": "def maxRectangles ( L , B , l , b ) : NEW_LINE INDENT horizontal , vertical = 0 , 0 NEW_LINE if l <= L and b <= B : NEW_LINE INDENT columns = B // b NEW_LINE rows = L // l NEW_LINE horizontal = rows * columns NEW_LINE DEDENT if l <= B and b <= L : NEW_LINE INDENT columns = L // b NEW_LINE rows = B // l NEW_LINE vertical = rows * columns NEW_LINE DEDENT return max ( horizontal , vertical ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L , B , l , b = 10 , 7 , 4 , 3 NEW_LINE print ( maxRectangles ( L , B , l , b ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02474_A", "sol": 0, "python_code": "import sys\ndef main ( args ) :\n    A , B = map ( int , input ( ).split ( ) )\n    print ( A * B )\nif __name__ == '__main__' :\n    main ( sys.argv [ 1 : ] )\n", "python_code_tokenized": "import sys NEW_LINE def main ( args ) : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( A * B ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1995_A", "sol": 0, "python_code": "def SieveOfSundaram ( marked , nNew ) :\n    for i in range ( 1 , nNew + 1 ) :\n        for j in range ( i , nNew ) :\n            if i + j + 2 * i * j > nNew :\n                break\n            marked [ i + j + 2 * i * j ] = True\ndef countPrimePairs ( n ) :\n    nNew = ( n - 2 ) // 2\n    marked = [ False for i in range ( nNew + 1 ) ]\n    SieveOfSundaram ( marked , nNew )\n    count , prime_num = 0 , 0\n    for i in range ( 1 , nNew + 1 ) :\n        if ( marked [ i ] == False ) :\n            prime_num = 2 * i + 1\n            count = count + ( prime_num // 2 )\n    return count\nn = 12\nprint ( \"Number of prime pairs: \" , countPrimePairs ( n ) )\n", "python_code_tokenized": "def SieveOfSundaram ( marked , nNew ) : NEW_LINE INDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT for j in range ( i , nNew ) : NEW_LINE INDENT if i + j + 2 * i * j > nNew : NEW_LINE INDENT break NEW_LINE DEDENT marked [ i + j + 2 * i * j ] = True NEW_LINE DEDENT DEDENT DEDENT def countPrimePairs ( n ) : NEW_LINE INDENT nNew = ( n - 2 ) // 2 NEW_LINE marked = [ False for i in range ( nNew + 1 ) ] NEW_LINE SieveOfSundaram ( marked , nNew ) NEW_LINE count , prime_num = 0 , 0 NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT prime_num = 2 * i + 1 NEW_LINE count = count + ( prime_num // 2 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 12 NEW_LINE print ( \" Number \u2581 of \u2581 prime \u2581 pairs : \u2581 \" , countPrimePairs ( n ) ) NEW_LINE"}
{"id": "codeforces_334_A", "sol": 0, "python_code": "n = int ( input ( ) )\ni , j = 1 , n * n\nwhile i < j :\n    print ( i , j )\n    i += 1\n    j -= 1\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE i , j = 1 , n * n NEW_LINE while i < j : NEW_LINE INDENT print ( i , j ) NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT"}
{"id": "geeksforgeeks_130_A", "sol": 0, "python_code": "def nCrRangeSum ( n , r1 , r2 , p ) :\n    num = den = 1\n    sum = 0\n    if r1 == 0 :\n        sum += 1\n    for i in range ( r2 ) :\n        num = ( num * ( n - i ) ) % p\n        den = ( den * ( i + 1 ) ) % p\n        if ( i - r1 >= - 1 and ( i - r1 + 1 ) % 2 == 0 ) :\n            sum += ( num * pow ( den , p - 2 , p ) ) % p\n            sum %= p\n    return sum\ndef compute ( A , B ) :\n    c0A = c1A = c0B = c1B = 0\n    for c in A :\n        if c == '1' :\n            c1A += 1\n        elif c == '0' :\n            c0A += 1\n    for c in B :\n        if c == '1' :\n            c1B += 1\n        elif c == '0' :\n            c0B += 1\n    max1xor = min ( c0A , c1B ) + min ( c1A , c0B )\n    min1xor = N - min ( c0B , c0A ) - min ( c1A , c1B )\n    ans = nCrRangeSum ( N , min1xor , max1xor , 10 ** 9 + 7 )\n    return ans\nif __name__ == \"__main__\" :\n    N = 3\n    A = \"010\"\n    B = \"100\"\n    print ( compute ( A , B ) )\n", "python_code_tokenized": "def nCrRangeSum ( n , r1 , r2 , p ) : NEW_LINE INDENT num = den = 1 NEW_LINE sum = 0 NEW_LINE if r1 == 0 : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT for i in range ( r2 ) : NEW_LINE INDENT num = ( num * ( n - i ) ) % p NEW_LINE den = ( den * ( i + 1 ) ) % p NEW_LINE if ( i - r1 >= - 1 and ( i - r1 + 1 ) % 2 == 0 ) : NEW_LINE INDENT sum += ( num * pow ( den , p - 2 , p ) ) % p NEW_LINE sum %= p NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def compute ( A , B ) : NEW_LINE INDENT c0A = c1A = c0B = c1B = 0 NEW_LINE for c in A : NEW_LINE INDENT if c == '1' : NEW_LINE INDENT c1A += 1 NEW_LINE DEDENT elif c == '0' : NEW_LINE INDENT c0A += 1 NEW_LINE DEDENT DEDENT for c in B : NEW_LINE INDENT if c == '1' : NEW_LINE INDENT c1B += 1 NEW_LINE DEDENT elif c == '0' : NEW_LINE INDENT c0B += 1 NEW_LINE DEDENT DEDENT max1xor = min ( c0A , c1B ) + min ( c1A , c0B ) NEW_LINE min1xor = N - min ( c0B , c0A ) - min ( c1A , c1B ) NEW_LINE ans = nCrRangeSum ( N , min1xor , max1xor , 10 ** 9 + 7 ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE A = \"010\" NEW_LINE B = \"100\" NEW_LINE print ( compute ( A , B ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_704_A", "sol": 0, "python_code": "def Move ( a , x , b ) :\n    if ( ( ( ( b - a ) % x == 0 ) or ( ( b - a - 1 ) % x == 0 ) and a + 1 != b ) and b >= a ) :\n        return True\n    return False\nif __name__ == \"__main__\" :\n    a = 3\n    x = 2\n    b = 7\n    if ( Move ( a , x , b ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def Move ( a , x , b ) : NEW_LINE INDENT if ( ( ( ( b - a ) % x == 0 ) or ( ( b - a - 1 ) % x == 0 ) and a + 1 != b ) and b >= a ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE x = 2 NEW_LINE b = 7 NEW_LINE if ( Move ( a , x , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ARC086_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nma = max ( a )\nmai = a.index ( ma )\nmi = min ( a )\nmii = a.index ( mi )\nans = [ ]\nif abs ( ma ) >= abs ( mi ) :\n    for i in range ( n ) :\n        a [ i ] += ma\n        ans.append ( ( mai + 1 , i + 1 ) )\n    for i in range ( 1 , n ) :\n        a [ i ] += a [ i - 1 ]\n        ans.append ( ( i , i + 1 ) )\nelse :\n    for i in range ( n ) :\n        a [ i ] += mi\n        ans.append ( ( mii + 1 , i + 1 ) )\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        a [ i ] += a [ i + 1 ]\n        ans.append ( ( i + 2 , i + 1 ) )\nprint ( len ( ans ) )\nfor i in ans : print ( * i )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ma = max ( a ) NEW_LINE mai = a . index ( ma ) NEW_LINE mi = min ( a ) NEW_LINE mii = a . index ( mi ) NEW_LINE ans = [ ] NEW_LINE if abs ( ma ) >= abs ( mi ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] += ma NEW_LINE ans . append ( ( mai + 1 , i + 1 ) ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] += a [ i - 1 ] NEW_LINE ans . append ( ( i , i + 1 ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] += mi NEW_LINE ans . append ( ( mii + 1 , i + 1 ) ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] += a [ i + 1 ] NEW_LINE ans . append ( ( i + 2 , i + 1 ) ) NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE for i in ans : print ( * i ) NEW_LINE"}
{"id": "codeforces_357_B", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nd = { }\nfor i in range ( m ) :\n    nc = [ ]\n    c = [ ]\n    l = list ( map ( int , list ( input ( ).split ( ) ) ) )\n    for j in range ( 3 ) :\n        if l [ j ] not in d.keys ( ) :\n            nc.append ( l [ j ] )\n        else :\n            c.append ( l [ j ] )\n    d1 = { }\n    for u in c :\n        d1 [ u ] = d [ u ]\n    for b in nc :\n        for v in range ( 1 , 4 ) :\n            if v not in d1.values ( ) :\n                d [ b ] = v\n                d1 [ b ] = v\n                break\nfor i in sorted ( d.items ( ) ) :\n    print ( i [ 1 ] , end = \" \" )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE d = { } NEW_LINE for i in range ( m ) : NEW_LINE INDENT nc = [ ] NEW_LINE c = [ ] NEW_LINE l = list ( map ( int , list ( input ( ) . split ( ) ) ) ) NEW_LINE for j in range ( 3 ) : NEW_LINE INDENT if l [ j ] not in d . keys ( ) : NEW_LINE INDENT nc . append ( l [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT c . append ( l [ j ] ) NEW_LINE DEDENT DEDENT d1 = { } NEW_LINE for u in c : NEW_LINE INDENT d1 [ u ] = d [ u ] NEW_LINE DEDENT for b in nc : NEW_LINE INDENT for v in range ( 1 , 4 ) : NEW_LINE INDENT if v not in d1 . values ( ) : NEW_LINE INDENT d [ b ] = v NEW_LINE d1 [ b ] = v NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in sorted ( d . items ( ) ) : NEW_LINE INDENT print ( i [ 1 ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "codeforces_116_A", "sol": 0, "python_code": "k = 0\nu = 0\nfor _ in range ( int ( input ( ) ) ) :\n    a , b = map ( int , input ( ).split ( ) )\n    k -= a\n    k += b\n    if ( k > u ) : u = k\nprint ( u )\n", "python_code_tokenized": "k = 0 NEW_LINE u = 0 NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE k -= a NEW_LINE k += b NEW_LINE if ( k > u ) : u = k NEW_LINE DEDENT print ( u ) NEW_LINE"}
{"id": "codeforces_36_A", "sol": 0, "python_code": "rFile = open ( 'input.txt' , 'r' )\nn = int ( rFile.readline ( ) )\nline = rFile.readline ( )\nrFile.close ( )\nprev , dist , ans = - 1 , - 1 , 'YES'\nfor i in range ( n ) :\n    if line [ i ] == '1' and prev == - 1 :\n        prev = i\n    elif line [ i ] == '1' and dist == - 1 :\n        dist = i - prev - 1\n        prev = i\n    elif line [ i ] == '1' :\n        helper = i - prev - 1\n        if helper != dist :\n            ans = 'NO'\n            break\n        prev = i\nwFile = open ( \"output.txt\" , 'w' )\nwFile.write ( ans )\nwFile.close ( )\n", "python_code_tokenized": "rFile = open ( ' input . txt ' , ' r ' ) NEW_LINE n = int ( rFile . readline ( ) ) NEW_LINE line = rFile . readline ( ) NEW_LINE rFile . close ( ) NEW_LINE prev , dist , ans = - 1 , - 1 , ' YES ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT if line [ i ] == '1' and prev == - 1 : NEW_LINE INDENT prev = i NEW_LINE DEDENT elif line [ i ] == '1' and dist == - 1 : NEW_LINE INDENT dist = i - prev - 1 NEW_LINE prev = i NEW_LINE DEDENT elif line [ i ] == '1' : NEW_LINE INDENT helper = i - prev - 1 NEW_LINE if helper != dist : NEW_LINE INDENT ans = ' NO ' NEW_LINE break NEW_LINE DEDENT prev = i NEW_LINE DEDENT DEDENT wFile = open ( \" output . txt \" , ' w ' ) NEW_LINE wFile . write ( ans ) NEW_LINE wFile . close ( ) NEW_LINE"}
{"id": "geeksforgeeks_3526_A", "sol": 0, "python_code": "import math\ndef binomialCoeff ( n , k ) :\n    res = 1\n    if ( k > n - k ) :\n        k = n - k\n    for i in range ( 0 , k ) :\n        res = res * ( n - i )\n        res = res // ( i + 1 )\n    return res\ndef power ( x , y ) :\n    res = 1\n    while ( y > 0 ) :\n        if ( y & 1 ) :\n            res = res * x\n        y = y // 2\n        x = x * x\n    return res\ndef FindProbability ( n ) :\n    up = binomialCoeff ( 2 * n , n )\n    down = power ( 2 , 2 * n )\n    g = math.gcd ( up , down )\n    up = up // g\n    down = down // g\n    print ( up , \"/\" , down )\nN = 8\nFindProbability ( N )\n", "python_code_tokenized": "import math NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res // ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT y = y // 2 NEW_LINE x = x * x NEW_LINE DEDENT return res NEW_LINE DEDENT def FindProbability ( n ) : NEW_LINE INDENT up = binomialCoeff ( 2 * n , n ) NEW_LINE down = power ( 2 , 2 * n ) NEW_LINE g = math . gcd ( up , down ) NEW_LINE up = up // g NEW_LINE down = down // g NEW_LINE print ( up , \" / \" , down ) NEW_LINE DEDENT N = 8 NEW_LINE FindProbability ( N ) NEW_LINE"}
{"id": "geeksforgeeks_1207_A", "sol": 0, "python_code": "def findMod4 ( s , n ) :\n    if ( n == 1 ) :\n        k = ord ( s [ 0 ] ) - ord ( '0' )\n    else :\n        k = ( ( ord ( s [ n - 2 ] ) - ord ( '0' ) ) * 10 + ord ( s [ n - 1 ] ) - ord ( '0' ) )\n    return ( k % 4 )\nif __name__ == '__main__' :\n    s = \"81\"\n    n = len ( s )\n    print ( findMod4 ( s , n ) )\n", "python_code_tokenized": "def findMod4 ( s , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT k = ord ( s [ 0 ] ) - ord ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT k = ( ( ord ( s [ n - 2 ] ) - ord ( '0' ) ) * 10 + ord ( s [ n - 1 ] ) - ord ( '0' ) ) NEW_LINE DEDENT return ( k % 4 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"81\" NEW_LINE n = len ( s ) NEW_LINE print ( findMod4 ( s , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_121_B", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nt = list ( input ( ) )\ni , m = 0 , n // 2\nif k > m : k = m + ( ( m + k ) & 1 )\nwhile k and i < n - 1 :\n    if t [ i ] == '4' and t [ i + 1 ] == '7' :\n        k -= 1\n        if i & 1 == 0 : t [ i + 1 ] = '4'\n        else :\n            t [ i ] = '7'\n            i -= 2\n    i += 1\nprint ( ''.join ( t ) )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE t = list ( input ( ) ) NEW_LINE i , m = 0 , n // 2 NEW_LINE if k > m : k = m + ( ( m + k ) & 1 ) NEW_LINE while k and i < n - 1 : NEW_LINE INDENT if t [ i ] == '4' and t [ i + 1 ] == '7' : NEW_LINE INDENT k -= 1 NEW_LINE if i & 1 == 0 : t [ i + 1 ] = '4' NEW_LINE else : NEW_LINE INDENT t [ i ] = '7' NEW_LINE i -= 2 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( ' ' . join ( t ) ) NEW_LINE"}
{"id": "aizu_p00392_A", "sol": 0, "python_code": "from collections import defaultdict\ndef main ( ) :\n    def primes ( n ) :\n        is_prime = [ True ] * ( n + 1 )\n        is_prime [ 0 ] = is_prime [ 1 ] = False\n        for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) :\n            if is_prime [ i ] :\n                for j in range ( i * i , n + 1 , i ) :\n                    is_prime [ j ] = False\n        return [ i for i in range ( n + 1 ) if is_prime [ i ] ]\n    prime_list = primes ( 100000 )\n    solvers = [ [ ] for _ in range ( 100001 ) ]\n    for p in prime_list :\n        for i in range ( p , 100001 , p ) :\n            solvers [ i ].append ( p )\n    n = int ( input ( ) )\n    a_list = list ( map ( int , input ( ).split ( ) ) )\n    parent = [ i for i in range ( 100001 ) ]\n    def find ( x ) :\n        if x == parent [ x ] :\n            return x\n        parent [ x ] = find ( parent [ x ] )\n        return parent [ x ]\n    for i , v in enumerate ( a_list ) :\n        p_rep = find ( min ( solvers [ v ] ) )\n        for s in solvers [ v ] :\n            parent [ find ( s ) ] = p_rep\n        parent [ find ( v ) ] = p_rep\n    dic = defaultdict ( set )\n    for i , v in enumerate ( a_list ) :\n        dic [ find ( v ) ].add ( i )\n    a_list.sort ( )\n    for i , v in enumerate ( a_list ) :\n        if i not in dic [ find ( v ) ] :\n            print ( 0 )\n            break\n    else :\n        print ( 1 )\nmain ( )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE def main ( ) : NEW_LINE INDENT def primes ( n ) : NEW_LINE INDENT is_prime = [ True ] * ( n + 1 ) NEW_LINE is_prime [ 0 ] = is_prime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if is_prime [ i ] : NEW_LINE INDENT for j in range ( i * i , n + 1 , i ) : NEW_LINE INDENT is_prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT return [ i for i in range ( n + 1 ) if is_prime [ i ] ] NEW_LINE DEDENT prime_list = primes ( 100000 ) NEW_LINE solvers = [ [ ] for _ in range ( 100001 ) ] NEW_LINE for p in prime_list : NEW_LINE INDENT for i in range ( p , 100001 , p ) : NEW_LINE INDENT solvers [ i ] . append ( p ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE a_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE parent = [ i for i in range ( 100001 ) ] NEW_LINE def find ( x ) : NEW_LINE INDENT if x == parent [ x ] : NEW_LINE INDENT return x NEW_LINE DEDENT parent [ x ] = find ( parent [ x ] ) NEW_LINE return parent [ x ] NEW_LINE DEDENT for i , v in enumerate ( a_list ) : NEW_LINE INDENT p_rep = find ( min ( solvers [ v ] ) ) NEW_LINE for s in solvers [ v ] : NEW_LINE INDENT parent [ find ( s ) ] = p_rep NEW_LINE DEDENT parent [ find ( v ) ] = p_rep NEW_LINE DEDENT dic = defaultdict ( set ) NEW_LINE for i , v in enumerate ( a_list ) : NEW_LINE INDENT dic [ find ( v ) ] . add ( i ) NEW_LINE DEDENT a_list . sort ( ) NEW_LINE for i , v in enumerate ( a_list ) : NEW_LINE INDENT if i not in dic [ find ( v ) ] : NEW_LINE INDENT print ( 0 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_153_A", "sol": 0, "python_code": "from bisect import bisect as upper_bound\nfrom bisect import bisect_left as lower_bound\nfrom math import floor\nN = 1000005\nMAX = 10 ** 18\npowers = [ ]\nsquares = dict ( )\ns = dict ( )\ndef powersPrecomputation ( ) :\n    for i in range ( 2 , N ) :\n        squares [ i * i ] = 1\n        if ( i not in squares.keys ( ) ) :\n            continue\n        temp = i\n        while ( i * i <= ( MAX // temp ) ) :\n            temp *= ( i * i )\n            s [ temp ] = 1\n    for x in s :\n        powers.append ( x )\ndef calculateAnswer ( L , R ) :\n    powersPrecomputation ( )\n    perfectSquares = floor ( ( R ) ** (.5 ) ) - floor ( ( L - 1 ) ** (.5 ) )\n    high = upper_bound ( powers , R )\n    low = lower_bound ( powers , L )\n    perfectPowers = perfectSquares + ( high - low )\n    ans = ( R - L + 1 ) - perfectPowers\n    return ans\nL = 13\nR = 20\nprint ( calculateAnswer ( L , R ) )\n", "python_code_tokenized": "from bisect import bisect as upper_bound NEW_LINE from bisect import bisect_left as lower_bound NEW_LINE from math import floor NEW_LINE N = 1000005 NEW_LINE MAX = 10 ** 18 NEW_LINE powers = [ ] NEW_LINE squares = dict ( ) NEW_LINE s = dict ( ) NEW_LINE def powersPrecomputation ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT squares [ i * i ] = 1 NEW_LINE if ( i not in squares . keys ( ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = i NEW_LINE while ( i * i <= ( MAX // temp ) ) : NEW_LINE INDENT temp *= ( i * i ) NEW_LINE s [ temp ] = 1 NEW_LINE DEDENT DEDENT for x in s : NEW_LINE INDENT powers . append ( x ) NEW_LINE DEDENT DEDENT def calculateAnswer ( L , R ) : NEW_LINE INDENT powersPrecomputation ( ) NEW_LINE perfectSquares = floor ( ( R ) ** ( .5 ) ) - floor ( ( L - 1 ) ** ( .5 ) ) NEW_LINE high = upper_bound ( powers , R ) NEW_LINE low = lower_bound ( powers , L ) NEW_LINE perfectPowers = perfectSquares + ( high - low ) NEW_LINE ans = ( R - L + 1 ) - perfectPowers NEW_LINE return ans NEW_LINE DEDENT L = 13 NEW_LINE R = 20 NEW_LINE print ( calculateAnswer ( L , R ) ) NEW_LINE"}
{"id": "geeksforgeeks_981_A", "sol": 0, "python_code": "import sys\ndef knapSack ( W , wt , val , n ) :\n    maxratio = - sys.maxsize - 1 ;\n    maxindex = 0 ;\n    for i in range ( n ) :\n        if ( ( val [ i ] / wt [ i ] ) > maxratio ) :\n            maxratio = ( val [ i ] / wt [ i ] ) ;\n            maxindex = i ;\n    return ( W * maxratio ) ;\nval = [ 14 , 27 , 44 , 19 ] ;\nwt = [ 6 , 7 , 9 , 8 ] ;\nn = len ( val ) ;\nW = 50 ;\nprint ( knapSack ( W , wt , val , n ) ) ;\n", "python_code_tokenized": "import sys NEW_LINE def knapSack ( W , wt , val , n ) : NEW_LINE INDENT maxratio = - sys . maxsize - 1 ; NEW_LINE maxindex = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( val [ i ] / wt [ i ] ) > maxratio ) : NEW_LINE INDENT maxratio = ( val [ i ] / wt [ i ] ) ; NEW_LINE maxindex = i ; NEW_LINE DEDENT DEDENT return ( W * maxratio ) ; NEW_LINE DEDENT val = [ 14 , 27 , 44 , 19 ] ; NEW_LINE wt = [ 6 , 7 , 9 , 8 ] ; NEW_LINE n = len ( val ) ; NEW_LINE W = 50 ; NEW_LINE print ( knapSack ( W , wt , val , n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_982_A", "sol": 0, "python_code": "def maxWeight ( arr , n , w1_r , w2_r , i ) :\n    if i == n :\n        return 0\n    if dp [ i ] [ w1_r ] [ w2_r ] != - 1 :\n        return dp [ i ] [ w1_r ] [ w2_r ]\n    fill_w1 , fill_w2 , fill_none = 0 , 0 , 0\n    if w1_r >= arr [ i ] :\n        fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 )\n    if w2_r >= arr [ i ] :\n        fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 )\n    fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 )\n    dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) )\n    return dp [ i ] [ w1_r ] [ w2_r ]\nif __name__ == \"__main__\" :\n    arr = [ 8 , 2 , 3 ]\n    maxN , maxW = 31 , 31\n    dp = [ [ [ - 1 ] * maxW ] * maxW ] * maxN\n    n = len ( arr )\n    w1 , w2 = 10 , 3\n    print ( maxWeight ( arr , n , w1 , w2 , 0 ) )\n", "python_code_tokenized": "def maxWeight ( arr , n , w1_r , w2_r , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ i ] [ w1_r ] [ w2_r ] != - 1 : NEW_LINE INDENT return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT fill_w1 , fill_w2 , fill_none = 0 , 0 , 0 NEW_LINE if w1_r >= arr [ i ] : NEW_LINE INDENT fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) NEW_LINE DEDENT if w2_r >= arr [ i ] : NEW_LINE INDENT fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) NEW_LINE DEDENT fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) NEW_LINE dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) NEW_LINE return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 2 , 3 ] NEW_LINE maxN , maxW = 31 , 31 NEW_LINE dp = [ [ [ - 1 ] * maxW ] * maxW ] * maxN NEW_LINE n = len ( arr ) NEW_LINE w1 , w2 = 10 , 3 NEW_LINE print ( maxWeight ( arr , n , w1 , w2 , 0 ) ) NEW_LINE DEDENT"}
{"id": "codeforces_244_B", "sol": 0, "python_code": "list1 = [ ]\nfor x in range ( 0 , 10 ) :\n    for y in range ( 0 , 10 ) :\n        for i in range ( 1 , 10 ) :\n            for j in range ( 0 , ( 2 ** i ) + 1 ) :\n                bn = bin ( j )\n                bn = bn [ 2 : ]\n                c = bn.zfill ( i )\n                temp = c.replace ( \"0\" , str ( x ) )\n                res = temp.replace ( \"1\" , str ( y ) )\n                list1.append ( int ( res ) )\nlist1 = sorted ( list ( set ( list1 ) ) )\ninp1 = int ( input ( ) )\nans = - 1\nfor x in range ( len ( list1 ) ) :\n    if int ( list1 [ x ] ) <= inp1 :\n        ans += 1\n    else :\n        break\nprint ( ans )\n", "python_code_tokenized": "list1 = [ ] NEW_LINE for x in range ( 0 , 10 ) : NEW_LINE INDENT for y in range ( 0 , 10 ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( 0 , ( 2 ** i ) + 1 ) : NEW_LINE INDENT bn = bin ( j ) NEW_LINE bn = bn [ 2 : ] NEW_LINE c = bn . zfill ( i ) NEW_LINE temp = c . replace ( \"0\" , str ( x ) ) NEW_LINE res = temp . replace ( \"1\" , str ( y ) ) NEW_LINE list1 . append ( int ( res ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT list1 = sorted ( list ( set ( list1 ) ) ) NEW_LINE inp1 = int ( input ( ) ) NEW_LINE ans = - 1 NEW_LINE for x in range ( len ( list1 ) ) : NEW_LINE INDENT if int ( list1 [ x ] ) <= inp1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_225_A", "sol": 0, "python_code": "from math import sqrt\ndef countSteps ( n ) :\n    steps = 0 ;\n    while ( n ) :\n        largest = int ( sqrt ( n ) ) ;\n        n -= ( largest * largest ) ;\n        steps += 1 ;\n    return steps ;\nif __name__ == \"__main__\" :\n    n = 85 ;\n    print ( countSteps ( n ) ) ;\n", "python_code_tokenized": "from math import sqrt NEW_LINE def countSteps ( n ) : NEW_LINE INDENT steps = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT largest = int ( sqrt ( n ) ) ; NEW_LINE n -= ( largest * largest ) ; NEW_LINE steps += 1 ; NEW_LINE DEDENT return steps ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 85 ; NEW_LINE print ( countSteps ( n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4009_A", "sol": 0, "python_code": "def Add ( x , y ) :\n    while ( y != 0 ) :\n        carry = x & y\n        x = x ^ y\n        y = carry << 1\n    return x\nprint ( Add ( 15 , 32 ) )\n", "python_code_tokenized": "def Add ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( Add ( 15 , 32 ) ) NEW_LINE"}
{"id": "atcoder_ABC043_D", "sol": 0, "python_code": "s = input ( )\nfor w in range ( 2 , min ( [ 3 , len ( s ) ] ) + 1 ) :\n    for st in range ( 0 , len ( s ) - w + 1 ) :\n        if s [ st ] == s [ st + w - 1 ] :\n            print ( st + 1 , st + w )\n            exit ( )\nprint ( - 1 , - 1 )\n", "python_code_tokenized": "s = input ( ) NEW_LINE for w in range ( 2 , min ( [ 3 , len ( s ) ] ) + 1 ) : NEW_LINE INDENT for st in range ( 0 , len ( s ) - w + 1 ) : NEW_LINE INDENT if s [ st ] == s [ st + w - 1 ] : NEW_LINE INDENT print ( st + 1 , st + w ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( - 1 , - 1 ) NEW_LINE"}
{"id": "geeksforgeeks_3000_A", "sol": 0, "python_code": "def printPascal ( n ) :\n    for line in range ( 1 , n + 1 ) :\n        C = 1 ;\n        for i in range ( 1 , line + 1 ) :\n            print ( C , end = \"\" ) ;\n            C = int ( C * ( line - i ) / i ) ;\n        print ( \"\" ) ;\nn = 5 ;\nprintPascal ( n ) ;\n", "python_code_tokenized": "def printPascal ( n ) : NEW_LINE INDENT for line in range ( 1 , n + 1 ) : NEW_LINE INDENT C = 1 ; NEW_LINE for i in range ( 1 , line + 1 ) : NEW_LINE INDENT print ( C , end = \" \u2581 \" ) ; NEW_LINE C = int ( C * ( line - i ) / i ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE printPascal ( n ) ; NEW_LINE"}
{"id": "atcoder_ARC071_D", "sol": 0, "python_code": "MOD = 10 ** 9 + 7\nn = int ( input ( ) )\nif n == 1 :\n    print ( 1 )\nelse :\n    dp = [ 0 for _ in range ( n + 1 ) ]\n    dp [ 0 ] , dp [ 1 ] , dp [ 2 ] = 1 , 1 , 1\n    cum = [ 0 for _ in range ( n + 1 ) ]\n    cum [ 0 ] , cum [ 1 ] , cum [ 2 ] = 1 , 2 , 3\n    for i in range ( 3 , n + 1 ) :\n        dp [ i ] = ( dp [ i - 1 ] + cum [ i - 3 ] ) % MOD\n        cum [ i ] = ( cum [ i - 1 ] + dp [ i ] ) % MOD\n    ans = cum [ n - 2 ] * ( n - 1 ) * ( n - 1 ) + dp [ n - 1 ] * ( n - 1 ) + cum [ n - 2 ] * ( n - 1 ) + 1\n    print ( ans % MOD )\n", "python_code_tokenized": "MOD = 10 ** 9 + 7 NEW_LINE n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] , dp [ 1 ] , dp [ 2 ] = 1 , 1 , 1 NEW_LINE cum = [ 0 for _ in range ( n + 1 ) ] NEW_LINE cum [ 0 ] , cum [ 1 ] , cum [ 2 ] = 1 , 2 , 3 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + cum [ i - 3 ] ) % MOD NEW_LINE cum [ i ] = ( cum [ i - 1 ] + dp [ i ] ) % MOD NEW_LINE DEDENT ans = cum [ n - 2 ] * ( n - 1 ) * ( n - 1 ) + dp [ n - 1 ] * ( n - 1 ) + cum [ n - 2 ] * ( n - 1 ) + 1 NEW_LINE print ( ans % MOD ) NEW_LINE DEDENT"}
{"id": "atcoder_ABL_C", "sol": 0, "python_code": "from collections import deque\ndef main ( ) :\n    n , m = list ( map ( int , input ( ).split ( \" \" ) ) )\n    paired_dict = { i : [ ] for i in range ( n ) }\n    for _ in range ( m ) :\n        a , b = list ( map ( int , input ( ).split ( \" \" ) ) )\n        paired_dict [ a - 1 ].append ( b - 1 )\n        paired_dict [ b - 1 ].append ( a - 1 )\n    done_set = set ( [ ] )\n    que = deque ( [ a - 1 ] )\n    i = 0\n    ans = 0\n    while que :\n        x = que.popleft ( )\n        done_set.add ( x )\n        if x in paired_dict.keys ( ) :\n            for one in paired_dict [ x ] :\n                if one in done_set :\n                    continue\n                que.append ( one )\n                done_set.add ( one )\n        while ( not que ) and len ( done_set ) != n :\n            if i not in done_set :\n                que.append ( i )\n                ans += 1\n            i += 1\n            if n < i :\n                i = 0\n    print ( ans )\nif __name__ == \"__main__\" :\n    main ( )\n", "python_code_tokenized": "from collections import deque NEW_LINE def main ( ) : NEW_LINE INDENT n , m = list ( map ( int , input ( ) . split ( \" \u2581 \" ) ) ) NEW_LINE paired_dict = { i : [ ] for i in range ( n ) } NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b = list ( map ( int , input ( ) . split ( \" \u2581 \" ) ) ) NEW_LINE paired_dict [ a - 1 ] . append ( b - 1 ) NEW_LINE paired_dict [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT done_set = set ( [ ] ) NEW_LINE que = deque ( [ a - 1 ] ) NEW_LINE i = 0 NEW_LINE ans = 0 NEW_LINE while que : NEW_LINE INDENT x = que . popleft ( ) NEW_LINE done_set . add ( x ) NEW_LINE if x in paired_dict . keys ( ) : NEW_LINE INDENT for one in paired_dict [ x ] : NEW_LINE INDENT if one in done_set : NEW_LINE INDENT continue NEW_LINE DEDENT que . append ( one ) NEW_LINE done_set . add ( one ) NEW_LINE DEDENT DEDENT while ( not que ) and len ( done_set ) != n : NEW_LINE INDENT if i not in done_set : NEW_LINE INDENT que . append ( i ) NEW_LINE ans += 1 NEW_LINE DEDENT i += 1 NEW_LINE if n < i : NEW_LINE INDENT i = 0 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_369_A", "sol": 0, "python_code": "def maxProfit ( profitA , profitB , n ) :\n    preSum = [ 0 ] * n ;\n    preSum [ 0 ] = profitA [ 0 ] ;\n    for i in range ( 1 , n ) :\n        preSum [ i ] = preSum [ i - 1 ] + profitA [ i ] ;\n    suffSum = [ 0 ] * n ;\n    suffSum [ n - 1 ] = profitB [ n - 1 ] ;\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        suffSum [ i ] = suffSum [ i + 1 ] + profitB [ i ] ;\n    res = preSum [ n - 1 ] ;\n    for i in range ( 1 , n - 1 ) :\n        res = max ( res , preSum [ i ] + suffSum [ i + 1 ] ) ;\n    res = max ( res , suffSum [ 0 ] ) ;\n    return res ;\nif __name__ == \"__main__\" :\n    profitA = [ 2 , 3 , 2 ] ;\n    profitB = [ 10 , 30 , 40 ] ;\n    n = len ( profitA ) ;\n    print ( maxProfit ( profitA , profitB , n ) ) ;\n", "python_code_tokenized": "def maxProfit ( profitA , profitB , n ) : NEW_LINE INDENT preSum = [ 0 ] * n ; NEW_LINE preSum [ 0 ] = profitA [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT preSum [ i ] = preSum [ i - 1 ] + profitA [ i ] ; NEW_LINE DEDENT suffSum = [ 0 ] * n ; NEW_LINE suffSum [ n - 1 ] = profitB [ n - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffSum [ i ] = suffSum [ i + 1 ] + profitB [ i ] ; NEW_LINE DEDENT res = preSum [ n - 1 ] ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT res = max ( res , preSum [ i ] + suffSum [ i + 1 ] ) ; NEW_LINE DEDENT res = max ( res , suffSum [ 0 ] ) ; NEW_LINE return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT profitA = [ 2 , 3 , 2 ] ; NEW_LINE profitB = [ 10 , 30 , 40 ] ; NEW_LINE n = len ( profitA ) ; NEW_LINE print ( maxProfit ( profitA , profitB , n ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_879_A", "sol": 0, "python_code": "r = 0\nfor _ in [ 0 ] * int ( input ( ) ) :\n    s , d = map ( int , input ( ).split ( ) )\n    r = [ ( r - s + d ) // d * d + s , s ] [ r < s ]\nprint ( r )\n", "python_code_tokenized": "r = 0 NEW_LINE for _ in [ 0 ] * int ( input ( ) ) : NEW_LINE INDENT s , d = map ( int , input ( ) . split ( ) ) NEW_LINE r = [ ( r - s + d ) // d * d + s , s ] [ r < s ] NEW_LINE DEDENT print ( r ) NEW_LINE"}
{"id": "aizu_p00662_A", "sol": 0, "python_code": "while True :\n    n , k , f = [ 0 ] * 3 , [ 0 ] * 3 , [ 0 ] * 3\n    a = list ( map ( int , input ( ).split ( ) ) )\n    if sum ( a ) == 0 : break\n    for i in range ( 3 ) : n [ i ] += a [ i ] + a [ 3 + i ]\n    ans = 0\n    for i in range ( 3 ) :\n        if n [ i ] >= 3 : f [ i ] = 1\n        ans += n [ i ] // 3\n        n [ i ] %= 3\n        k [ n [ i ] ] += 1\n    if k [ 0 ] > 0 :\n        if k [ 2 ] == 2 :\n            i = 0\n            while n [ i ] : i += 1\n            if f [ i ] : ans += 1\n    elif k [ 1 ] > 0 : ans += 1\n    elif k [ 2 ] > 0 : ans += 2\n    print ( ans )\n", "python_code_tokenized": "while True : NEW_LINE INDENT n , k , f = [ 0 ] * 3 , [ 0 ] * 3 , [ 0 ] * 3 NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if sum ( a ) == 0 : break NEW_LINE for i in range ( 3 ) : n [ i ] += a [ i ] + a [ 3 + i ] NEW_LINE ans = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if n [ i ] >= 3 : f [ i ] = 1 NEW_LINE ans += n [ i ] // 3 NEW_LINE n [ i ] %= 3 NEW_LINE k [ n [ i ] ] += 1 NEW_LINE DEDENT if k [ 0 ] > 0 : NEW_LINE INDENT if k [ 2 ] == 2 : NEW_LINE INDENT i = 0 NEW_LINE while n [ i ] : i += 1 NEW_LINE if f [ i ] : ans += 1 NEW_LINE DEDENT DEDENT elif k [ 1 ] > 0 : ans += 1 NEW_LINE elif k [ 2 ] > 0 : ans += 2 NEW_LINE print ( ans ) NEW_LINE DEDENT"}
{"id": "codeforces_55_B", "sol": 0, "python_code": "from itertools import permutations\nnums = list ( map ( int , input ( ).split ( ) ) )\no = input ( ).split ( )\nprint ( min ( eval ( \"min(((a{0}b){1}c){2}d,(a{0}b){2}(c{1}d))\".format ( * o ) ) for a , b , c , d in permutations ( nums ) ) )\n", "python_code_tokenized": "from itertools import permutations NEW_LINE nums = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE o = input ( ) . split ( ) NEW_LINE print ( min ( eval ( \" min ( ( ( a { 0 } b ) {1 } c ) {2 } d , ( a { 0 } b ) {2 } ( c { 1 } d ) ) \" . format ( * o ) ) for a , b , c , d in permutations ( nums ) ) ) NEW_LINE"}
{"id": "codejam_15_11", "sol": 0, "python_code": "tc = int ( input ( ).strip ( ) )\nfor t in range ( tc ) :\n    n = int ( input ( ).strip ( ) )\n    v = list ( int ( x ) for x in input ( ).strip ( ).split ( ) )\n    a = sum ( max ( 0 , v [ i ] - v [ i + 1 ] ) for i in range ( n - 1 ) )\n    b = max ( max ( 0 , v [ i ] - v [ i + 1 ] ) for i in range ( n - 1 ) )\n    c = sum ( min ( b , v [ i ] ) for i in range ( n - 1 ) )\n    print ( \"Case #%d: %d %d\" % ( t + 1 , a , c ) )\n", "python_code_tokenized": "tc = int ( input ( ) . strip ( ) ) NEW_LINE for t in range ( tc ) : NEW_LINE INDENT n = int ( input ( ) . strip ( ) ) NEW_LINE v = list ( int ( x ) for x in input ( ) . strip ( ) . split ( ) ) NEW_LINE a = sum ( max ( 0 , v [ i ] - v [ i + 1 ] ) for i in range ( n - 1 ) ) NEW_LINE b = max ( max ( 0 , v [ i ] - v [ i + 1 ] ) for i in range ( n - 1 ) ) NEW_LINE c = sum ( min ( b , v [ i ] ) for i in range ( n - 1 ) ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 % d \u2581 % d \" % ( t + 1 , a , c ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02237_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = [ [ 0 for i in range ( n ) ] for j in range ( n ) ]\nfor i in range ( n ) :\n    info = [ int ( x ) for x in input ( ).split ( ) ]\n    for j in info [ 2 : ] :\n        a [ i ] [ j - 1 ] = 1\nfor v in a :\n    print ( * v )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT info = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE for j in info [ 2 : ] : NEW_LINE INDENT a [ i ] [ j - 1 ] = 1 NEW_LINE DEDENT DEDENT for v in a : NEW_LINE INDENT print ( * v ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2687_A", "sol": 0, "python_code": "def round ( n ) :\n    a = ( n // 10 ) * 10\n    b = a + 10\n    return ( b if n - a > b - n else a )\nn = 4722\nprint ( round ( n ) )\n", "python_code_tokenized": "def round ( n ) : NEW_LINE INDENT a = ( n // 10 ) * 10 NEW_LINE b = a + 10 NEW_LINE return ( b if n - a > b - n else a ) NEW_LINE DEDENT n = 4722 NEW_LINE print ( round ( n ) ) NEW_LINE"}
{"id": "aizu_p00399_A", "sol": 0, "python_code": "R , B , W , G = map ( int , input ( ).split ( ) )\nprint ( R + B + W + G )\n", "python_code_tokenized": "R , B , W , G = map ( int , input ( ) . split ( ) ) NEW_LINE print ( R + B + W + G ) NEW_LINE"}
{"id": "aizu_p01223_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n , a = int ( input ( ) ) , list ( map ( int , input ( ).split ( ) ) )\n    d = [ 0 , 0 ]\n    for i in range ( 1 , n ) : d = [ max ( a [ i ] - a [ i - 1 ] , d [ 0 ] ) , max ( a [ i - 1 ] - a [ i ] , d [ 1 ] ) ]\n    print ( * d )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , a = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = [ 0 , 0 ] NEW_LINE for i in range ( 1 , n ) : d = [ max ( a [ i ] - a [ i - 1 ] , d [ 0 ] ) , max ( a [ i - 1 ] - a [ i ] , d [ 1 ] ) ] NEW_LINE print ( * d ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4656_A", "sol": 0, "python_code": "def length ( str ) :\n    count = 0 ;\n    flag = False ;\n    length = len ( str ) - 1 ;\n    while ( length != 0 ) :\n        if ( str [ length ] == ' ' ) :\n            return count ;\n        else :\n            count += 1 ;\n        length -= 1 ;\n    return count ;\nstr = \"Geeks for Geeks\" ;\nprint ( \"The length of last word is\" , length ( str ) ) ;\n", "python_code_tokenized": "def length ( str ) : NEW_LINE INDENT count = 0 ; NEW_LINE flag = False ; NEW_LINE length = len ( str ) - 1 ; NEW_LINE while ( length != 0 ) : NEW_LINE INDENT if ( str [ length ] == ' \u2581 ' ) : NEW_LINE INDENT return count ; NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT length -= 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT str = \" Geeks \u2581 for \u2581 Geeks \" ; NEW_LINE print ( \" The \u2581 length \u2581 of \u2581 last \u2581 word \u2581 is \" , length ( str ) ) ; NEW_LINE"}
{"id": "aizu_p00495_A", "sol": 0, "python_code": "s = list ( map ( int , input ( ).split ( ) ) )\nif len ( s ) == 2 : c = s [ 0 ] ; d = s [ 1 ]\nelse : c = s [ 0 ] ; d = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nb = list ( map ( int , input ( ).split ( ) ) )\ne = 0 ; i = 0\nwhile i < d - e :\n    p = i ; q = 0\n    for j in range ( c ) :\n        if a [ j ] == b [ p ] : q += 1 ; p += 1\n    e = max ( e , q )\n    i += 1\nprint ( e )\n", "python_code_tokenized": "s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if len ( s ) == 2 : c = s [ 0 ] ; d = s [ 1 ] NEW_LINE else : c = s [ 0 ] ; d = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE e = 0 ; i = 0 NEW_LINE while i < d - e : NEW_LINE INDENT p = i ; q = 0 NEW_LINE for j in range ( c ) : NEW_LINE INDENT if a [ j ] == b [ p ] : q += 1 ; p += 1 NEW_LINE DEDENT e = max ( e , q ) NEW_LINE i += 1 NEW_LINE DEDENT print ( e ) NEW_LINE"}
{"id": "geeksforgeeks_1413_A", "sol": 0, "python_code": "import sys\ndef minXOR ( arr , n ) :\n    arr.sort ( )\n    minXor = int ( sys.float_info.max )\n    val = 0\n    for i in range ( 0 , n - 1 ) :\n        val = arr [ i ] ^ arr [ i + 1 ] ;\n        minXor = min ( minXor , val ) ;\n    return minXor\narr = [ 9 , 5 , 3 ]\nn = len ( arr )\nprint ( minXOR ( arr , n ) )\n", "python_code_tokenized": "import sys NEW_LINE def minXOR ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minXor = int ( sys . float_info . max ) NEW_LINE val = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] ; NEW_LINE minXor = min ( minXor , val ) ; NEW_LINE DEDENT return minXor NEW_LINE DEDENT arr = [ 9 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minXOR ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_652_A", "sol": 0, "python_code": "from math import ceil\nh1 , h2 = map ( int , input ( ).split ( ) )\na , b = map ( int , input ( ).split ( ) )\nh1 += 8 * a\nif h1 >= h2 :\n    k = 0\nelse :\n    delta = 12 * ( a - b )\n    if delta :\n        k = int ( ceil ( ( h2 - h1 ) / delta ) )\n        if k <= 0 :\n            k = - 1\n    else :\n        k = - 1\nprint ( k )\n", "python_code_tokenized": "from math import ceil NEW_LINE h1 , h2 = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE h1 += 8 * a NEW_LINE if h1 >= h2 : NEW_LINE INDENT k = 0 NEW_LINE DEDENT else : NEW_LINE INDENT delta = 12 * ( a - b ) NEW_LINE if delta : NEW_LINE INDENT k = int ( ceil ( ( h2 - h1 ) / delta ) ) NEW_LINE if k <= 0 : NEW_LINE INDENT k = - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT k = - 1 NEW_LINE DEDENT DEDENT print ( k ) NEW_LINE"}
{"id": "codeforces_1323_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    n , a = int ( input ( ) ) , [ int ( i ) for i in input ( ).split ( ) ] [ : 2 ]\n    res = list ( range ( 1 , len ( a ) + 1 ) ) if sum ( a ) & 1 == 0 else [ next ( ( i + 1 for i , e in enumerate ( a ) if e & 1 == 0 ) , - 1 ) ]\n    if res != [ - 1 ] :\n        print ( len ( res ) )\n    print ( * res )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , a = int ( input ( ) ) , [ int ( i ) for i in input ( ) . split ( ) ] [ : 2 ] NEW_LINE res = list ( range ( 1 , len ( a ) + 1 ) ) if sum ( a ) & 1 == 0 else [ next ( ( i + 1 for i , e in enumerate ( a ) if e & 1 == 0 ) , - 1 ) ] NEW_LINE if res != [ - 1 ] : NEW_LINE INDENT print ( len ( res ) ) NEW_LINE DEDENT print ( * res ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3246_A", "sol": 0, "python_code": "def steps ( cur , x , n ) :\n    if x == 0 :\n        return float ( 'inf' )\n    elif x > 0 :\n        return abs ( ( n - cur ) // x )\n    else :\n        return abs ( int ( ( cur - 1 ) / x ) )\ndef countSteps ( curx , cury , n , m , moves ) :\n    count = 0\n    k = len ( moves )\n    for i in range ( 0 , k ) :\n        x = moves [ i ] [ 0 ]\n        y = moves [ i ] [ 1 ]\n        stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) )\n        count += stepct\n        curx += stepct * x\n        cury += stepct * y\n    return count\nif __name__ == \"__main__\" :\n    n , m , x , y = 4 , 5 , 1 , 1\n    moves = [ [ 1 , 1 ] , [ 1 , 1 ] , [ 0 , - 2 ] ]\n    print ( countSteps ( x , y , n , m , moves ) )\n", "python_code_tokenized": "def steps ( cur , x , n ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT elif x > 0 : NEW_LINE INDENT return abs ( ( n - cur ) // x ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( int ( ( cur - 1 ) / x ) ) NEW_LINE DEDENT DEDENT def countSteps ( curx , cury , n , m , moves ) : NEW_LINE INDENT count = 0 NEW_LINE k = len ( moves ) NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT x = moves [ i ] [ 0 ] NEW_LINE y = moves [ i ] [ 1 ] NEW_LINE stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) NEW_LINE count += stepct NEW_LINE curx += stepct * x NEW_LINE cury += stepct * y NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m , x , y = 4 , 5 , 1 , 1 NEW_LINE moves = [ [ 1 , 1 ] , [ 1 , 1 ] , [ 0 , - 2 ] ] NEW_LINE print ( countSteps ( x , y , n , m , moves ) ) NEW_LINE DEDENT"}
{"id": "codeforces_222_B", "sol": 0, "python_code": "from sys import stdin\ninp = stdin.readline\nn , m , k = map ( int , inp ( ).split ( ) )\ntable = [ ]\nfor i in range ( n ) :\n    table.append ( list ( map ( int , inp ( ).split ( ) ) ) )\nrow_status = [ i for i in range ( n ) ]\ncol_status = [ i for i in range ( m ) ]\nans = [ ]\nwhile k :\n    k -= 1\n    op , x , y = inp ( ).split ( )\n    x = int ( x ) - 1\n    y = int ( y ) - 1\n    if op == \"r\" :\n        row_status [ x ] , row_status [ y ] = row_status [ y ] , row_status [ x ]\n    elif op == \"c\" :\n        col_status [ x ] , col_status [ y ] = col_status [ y ] , col_status [ x ]\n    else :\n        ans.append ( str ( table [ row_status [ x ] ] [ col_status [ y ] ] ) )\nprint ( \"\\n\".join ( ans ) )\n", "python_code_tokenized": "from sys import stdin NEW_LINE inp = stdin . readline NEW_LINE n , m , k = map ( int , inp ( ) . split ( ) ) NEW_LINE table = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT table . append ( list ( map ( int , inp ( ) . split ( ) ) ) ) NEW_LINE DEDENT row_status = [ i for i in range ( n ) ] NEW_LINE col_status = [ i for i in range ( m ) ] NEW_LINE ans = [ ] NEW_LINE while k : NEW_LINE INDENT k -= 1 NEW_LINE op , x , y = inp ( ) . split ( ) NEW_LINE x = int ( x ) - 1 NEW_LINE y = int ( y ) - 1 NEW_LINE if op == \" r \" : NEW_LINE INDENT row_status [ x ] , row_status [ y ] = row_status [ y ] , row_status [ x ] NEW_LINE DEDENT elif op == \" c \" : NEW_LINE INDENT col_status [ x ] , col_status [ y ] = col_status [ y ] , col_status [ x ] NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( str ( table [ row_status [ x ] ] [ col_status [ y ] ] ) ) NEW_LINE DEDENT DEDENT print ( \" \\n \" . join ( ans ) ) NEW_LINE"}
{"id": "geeksforgeeks_993_A", "sol": 0, "python_code": "def maxSubseq ( vec , n ) :\n    suffix = 0\n    i = n - 1\n    while ( i >= 0 ) :\n        if ( vec [ i ] == 1 ) :\n            suffix += 1\n            vec [ i ] = suffix\n        i -= 1\n    res = 0\n    zero = 0\n    for i in range ( 0 , n , 1 ) :\n        if ( vec [ i ] == 0 ) :\n            zero += 1\n        if ( vec [ i ] > 0 ) :\n            res = max ( res , zero + vec [ i ] )\n    return max ( res , zero )\nif __name__ == '__main__' :\n    input = [ 0 , 1 , 0 , 0 , 1 , 0 ]\n    n = len ( input )\n    print ( maxSubseq ( input , n ) )\n", "python_code_tokenized": "def maxSubseq ( vec , n ) : NEW_LINE INDENT suffix = 0 NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( vec [ i ] == 1 ) : NEW_LINE INDENT suffix += 1 NEW_LINE vec [ i ] = suffix NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT res = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( vec [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ( vec [ i ] > 0 ) : NEW_LINE INDENT res = max ( res , zero + vec [ i ] ) NEW_LINE DEDENT DEDENT return max ( res , zero ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input = [ 0 , 1 , 0 , 0 , 1 , 0 ] NEW_LINE n = len ( input ) NEW_LINE print ( maxSubseq ( input , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4212_A", "sol": 0, "python_code": "def primeOccurences ( arr , k ) :\n    map = { }\n    for val in arr :\n        freq = 0\n        if val in map :\n            freq = map [ val ]\n            freq += 1\n        else :\n            freq = 1\n        map [ val ] = freq\n    for entry in map :\n        value = map [ entry ]\n        if isPrime ( value ) and value >= k :\n            print ( entry )\ndef isPrime ( n ) :\n    if ( n > 2 and not n % 2 ) or n == 1 :\n        return False\n    for i in range ( 3 , int ( n ** 0.5 + 1 ) , 2 ) :\n        if not n % i :\n            return False\n    return True\narr = [ 11 , 11 , 11 , 23 , 11 , 37 , 37 , 51 , 51 , 51 , 51 , 51 ]\nk = 2\nprimeOccurences ( arr , k )\n", "python_code_tokenized": "def primeOccurences ( arr , k ) : NEW_LINE INDENT map = { } NEW_LINE for val in arr : NEW_LINE INDENT freq = 0 NEW_LINE if val in map : NEW_LINE INDENT freq = map [ val ] NEW_LINE freq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq = 1 NEW_LINE DEDENT map [ val ] = freq NEW_LINE DEDENT for entry in map : NEW_LINE INDENT value = map [ entry ] NEW_LINE if isPrime ( value ) and value >= k : NEW_LINE INDENT print ( entry ) NEW_LINE DEDENT DEDENT DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n > 2 and not n % 2 ) or n == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( n ** 0.5 + 1 ) , 2 ) : NEW_LINE INDENT if not n % i : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 11 , 11 , 11 , 23 , 11 , 37 , 37 , 51 , 51 , 51 , 51 , 51 ] NEW_LINE k = 2 NEW_LINE primeOccurences ( arr , k ) NEW_LINE"}
{"id": "geeksforgeeks_4184_A", "sol": 0, "python_code": "def calculate ( a , n ) :\n    ans = 0 ;\n    i = 0 ;\n    while ( i < n ) :\n        r = i + 1 ;\n        for j in range ( r , n ) :\n            if ( a [ i ] == a [ j ] ) :\n                r = r + 1 ;\n            else :\n                break ;\n        d = r - i ;\n        ans = ans + ( d * ( d + 1 ) / 2 ) ;\n        i = r - 1 ;\n        i = i + 1 ;\n    return int ( ans ) ;\na = [ 2 , 4 , 5 , 3 , 3 , 3 ] ;\nn = len ( a ) ;\nprint ( calculate ( a , n ) ) ;\n", "python_code_tokenized": "def calculate ( a , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT r = i + 1 ; NEW_LINE for j in range ( r , n ) : NEW_LINE INDENT if ( a [ i ] == a [ j ] ) : NEW_LINE INDENT r = r + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT d = r - i ; NEW_LINE ans = ans + ( d * ( d + 1 ) / 2 ) ; NEW_LINE i = r - 1 ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT return int ( ans ) ; NEW_LINE DEDENT a = [ 2 , 4 , 5 , 3 , 3 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( calculate ( a , n ) ) ; NEW_LINE"}
{"id": "aizu_p02033_A", "sol": 0, "python_code": "import bisect\nn , m = map ( int , input ( ).split ( ) )\npos = list ( map ( int , input ( ).split ( ) ) )\nq = int ( input ( ) )\nl = list ( map ( int , input ( ).split ( ) ) )\npos.append ( n + 1 )\nd = [ pos [ i + 1 ] - pos [ i ] - 1 for i in range ( m ) ]\nd.sort ( )\ns = [ 0 ] * ( m + 1 )\nfor i in range ( len ( d ) ) :\n    s [ i + 1 ] = s [ i ] + d [ i ]\nfor lim in l :\n    ok = n + 1\n    ng = 0\n    while abs ( ok - ng ) > 1 :\n        mid = ( ok + ng ) // 2\n        idx = bisect.bisect_left ( d , mid )\n        cost = ( s [ - 1 ] - s [ idx ] ) - ( m - idx ) * ( mid - 1 ) + ( pos [ 0 ] - 1 )\n        if cost <= lim :\n            ok = mid\n        else :\n            ng = mid\n    if ok <= n :\n        print ( ok )\n    else :\n        print ( - 1 )\n", "python_code_tokenized": "import bisect NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE pos = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE pos . append ( n + 1 ) NEW_LINE d = [ pos [ i + 1 ] - pos [ i ] - 1 for i in range ( m ) ] NEW_LINE d . sort ( ) NEW_LINE s = [ 0 ] * ( m + 1 ) NEW_LINE for i in range ( len ( d ) ) : NEW_LINE INDENT s [ i + 1 ] = s [ i ] + d [ i ] NEW_LINE DEDENT for lim in l : NEW_LINE INDENT ok = n + 1 NEW_LINE ng = 0 NEW_LINE while abs ( ok - ng ) > 1 : NEW_LINE INDENT mid = ( ok + ng ) // 2 NEW_LINE idx = bisect . bisect_left ( d , mid ) NEW_LINE cost = ( s [ - 1 ] - s [ idx ] ) - ( m - idx ) * ( mid - 1 ) + ( pos [ 0 ] - 1 ) NEW_LINE if cost <= lim : NEW_LINE INDENT ok = mid NEW_LINE DEDENT else : NEW_LINE INDENT ng = mid NEW_LINE DEDENT DEDENT if ok <= n : NEW_LINE INDENT print ( ok ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4859_A", "sol": 0, "python_code": "def minRange ( arr , n , k ) :\n    l = 0\n    r = n\n    for i in range ( n ) :\n        s = [ ]\n        for j in range ( i , n ) :\n            s.append ( arr [ j ] )\n            if ( len ( s ) == k ) :\n                if ( ( j - i ) < ( r - l ) ) :\n                    r = j\n                    l = i\n                break\n        if ( j == n ) :\n            break\n    if ( l == 0 and r == n ) :\n        print ( \"Invalid k\" )\n    else :\n        print ( l , r )\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 3 , 4 , 5 ]\n    n = len ( arr )\n    k = 3\n    minRange ( arr , n , k )\n", "python_code_tokenized": "def minRange ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT s . append ( arr [ j ] ) NEW_LINE if ( len ( s ) == k ) : NEW_LINE INDENT if ( ( j - i ) < ( r - l ) ) : NEW_LINE INDENT r = j NEW_LINE l = i NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT if ( j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( l == 0 and r == n ) : NEW_LINE INDENT print ( \" Invalid \u2581 k \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l , r ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE minRange ( arr , n , k ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_684_A", "sol": 0, "python_code": "def max_element ( a , n ) :\n    pre = [ 0 ] * n ;\n    pre [ 0 ] = a [ 0 ] ;\n    for i in range ( 1 , n ) :\n        pre [ i ] = max ( pre [ i - 1 ] , a [ i ] ) ;\n    suf = [ 0 ] * n ;\n    suf [ n - 1 ] = a [ n - 1 ] ;\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        suf [ i ] = max ( suf [ i + 1 ] , a [ i ] ) ;\n    for i in range ( n ) :\n        if ( i == 0 ) :\n            print ( suf [ i + 1 ] , end = \" \" ) ;\n        elif ( i == n - 1 ) :\n            print ( pre [ i - 1 ] , end = \" \" ) ;\n        else :\n            print ( max ( pre [ i - 1 ] , suf [ i + 1 ] ) , end = \" \" ) ;\nif __name__ == \"__main__\" :\n    a = [ 2 , 5 , 6 , 1 , 3 ] ;\n    n = len ( a ) ;\n    max_element ( a , n ) ;\n", "python_code_tokenized": "def max_element ( a , n ) : NEW_LINE INDENT pre = [ 0 ] * n ; NEW_LINE pre [ 0 ] = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = max ( pre [ i - 1 ] , a [ i ] ) ; NEW_LINE DEDENT suf = [ 0 ] * n ; NEW_LINE suf [ n - 1 ] = a [ n - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suf [ i ] = max ( suf [ i + 1 ] , a [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( suf [ i + 1 ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT elif ( i == n - 1 ) : NEW_LINE INDENT print ( pre [ i - 1 ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( pre [ i - 1 ] , suf [ i + 1 ] ) , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 5 , 6 , 1 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE max_element ( a , n ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4129_A", "sol": 0, "python_code": "def FindElement ( A , n ) :\n    for i in range ( 0 , n , 1 ) :\n        flag = 0\n        for j in range ( 0 , i , 1 ) :\n            if ( A [ j ] >= A [ i ] ) :\n                flag = 1\n                break\n        for j in range ( i + 1 , n , 1 ) :\n            if ( A [ j ] <= A [ i ] ) :\n                flag = 1\n                break\n        if ( flag == 0 ) :\n            return A [ i ]\n    return - 1\nif __name__ == '__main__' :\n    A = [ 4 , 3 , 2 , 5 , 8 , 6 , 7 ]\n    n = len ( A )\n    print ( FindElement ( A , n ) )\n", "python_code_tokenized": "def FindElement ( A , n ) : NEW_LINE INDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE for j in range ( 0 , i , 1 ) : NEW_LINE INDENT if ( A [ j ] >= A [ i ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT if ( A [ j ] <= A [ i ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT return A [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 4 , 3 , 2 , 5 , 8 , 6 , 7 ] NEW_LINE n = len ( A ) NEW_LINE print ( FindElement ( A , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1674_A", "sol": 0, "python_code": "def asPowerSum ( w , m ) :\n    while ( m > 0 ) :\n        if ( ( m - 1 ) % w == 0 ) :\n            m = ( m - 1 ) / w ;\n        elif ( ( m + 1 ) % w == 0 ) :\n            m = ( m + 1 ) / w ;\n        elif ( m % w == 0 ) :\n            m = m / w ;\n        else :\n            break ;\n    return ( m == 0 ) ;\nw = 3 ;\nm = 7 ;\nif ( asPowerSum ( w , m ) ) :\n    print ( \"Yes\" ) ;\nelse :\n    print ( \"No\" ) ;\n", "python_code_tokenized": "def asPowerSum ( w , m ) : NEW_LINE INDENT while ( m > 0 ) : NEW_LINE INDENT if ( ( m - 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m - 1 ) / w ; NEW_LINE DEDENT elif ( ( m + 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m + 1 ) / w ; NEW_LINE DEDENT elif ( m % w == 0 ) : NEW_LINE INDENT m = m / w ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return ( m == 0 ) ; NEW_LINE DEDENT w = 3 ; NEW_LINE m = 7 ; NEW_LINE if ( asPowerSum ( w , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4075_A", "sol": 0, "python_code": "from math import sqrt\ndef prime ( n ) :\n    if ( n == 1 ) :\n        return False\n    for i in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) :\n        if ( n % i == 0 ) :\n            return False\n    return True\ndef Min_Sum ( n ) :\n    if ( prime ( n ) ) :\n        return 1\n    if ( n % 2 == 0 ) :\n        return 2\n    else :\n        if ( prime ( n - 2 ) ) :\n            return 2\n        else :\n            return 3\nif __name__ == '__main__' :\n    n = 27\n    print ( Min_Sum ( n ) )\n", "python_code_tokenized": "from math import sqrt NEW_LINE def prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def Min_Sum ( n ) : NEW_LINE INDENT if ( prime ( n ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT if ( prime ( n - 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 27 NEW_LINE print ( Min_Sum ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_215_A", "sol": 0, "python_code": "from math import sqrt\nmod = 1000000007\ndef mult ( a , b ) :\n    return ( ( a % mod ) * ( b % mod ) ) % mod\ndef calculate_factors ( n ) :\n    cnt = 0\n    ans = 1\n    while ( n % 2 == 0 ) :\n        cnt += 1\n        n = n // 2\n    if ( cnt ) :\n        ans = mult ( ans , ( cnt + 1 ) )\n    for i in range ( 3 , int ( sqrt ( n ) ) , 2 ) :\n        cnt = 0\n        while ( n % i == 0 ) :\n            cnt += 1\n            n = n // i\n        if ( cnt ) :\n            ans = mult ( ans , ( cnt + 1 ) )\n    if ( n > 2 ) :\n        ans = mult ( ans , 2 )\n    return ans % mod\nif __name__ == '__main__' :\n    n = 19374857\n    mod = 17\n    print ( calculate_factors ( n ) )\n", "python_code_tokenized": "from math import sqrt NEW_LINE mod = 1000000007 NEW_LINE def mult ( a , b ) : NEW_LINE INDENT return ( ( a % mod ) * ( b % mod ) ) % mod NEW_LINE DEDENT def calculate_factors ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE ans = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT if ( cnt ) : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) , 2 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // i NEW_LINE DEDENT if ( cnt ) : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans = mult ( ans , 2 ) NEW_LINE DEDENT return ans % mod NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 19374857 NEW_LINE mod = 17 NEW_LINE print ( calculate_factors ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1376_A", "sol": 0, "python_code": "from math import sqrt\nMAX = 100000\nprime = [ True ] * ( MAX + 1 )\ndef SieveOfEratosthenes ( ) :\n    for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) :\n        if ( prime [ p ] == True ) :\n            for i in range ( p * p , MAX + 1 , p ) :\n                prime [ i ] = False ;\ndef smallestPrime ( d ) :\n    l = 10 ** ( d - 1 ) ;\n    r = ( 10 ** d ) - 1 ;\n    for i in range ( l , r + 1 ) :\n        if ( prime [ i ] ) :\n            return i ;\n    return - 1 ;\ndef largestPrime ( d ) :\n    l = 10 ** ( d - 1 ) ;\n    r = ( 10 ** d ) - 1 ;\n    for i in range ( r , l , - 1 ) :\n        if ( prime [ i ] ) :\n            return i ;\n    return - 1 ;\nif __name__ == \"__main__\" :\n    SieveOfEratosthenes ( ) ;\n    queries = [ 2 , 5 ] ;\n    q = len ( queries ) ;\n    for i in range ( q ) :\n        print ( smallestPrime ( queries [ i ] ) , \" \" , largestPrime ( queries [ i ] ) ) ;\n", "python_code_tokenized": "from math import sqrt NEW_LINE MAX = 100000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def smallestPrime ( d ) : NEW_LINE INDENT l = 10 ** ( d - 1 ) ; NEW_LINE r = ( 10 ** d ) - 1 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT def largestPrime ( d ) : NEW_LINE INDENT l = 10 ** ( d - 1 ) ; NEW_LINE r = ( 10 ** d ) - 1 ; NEW_LINE for i in range ( r , l , - 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) ; NEW_LINE queries = [ 2 , 5 ] ; NEW_LINE q = len ( queries ) ; NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( smallestPrime ( queries [ i ] ) , \" \u2581 \" , largestPrime ( queries [ i ] ) ) ; NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00277_A", "sol": 0, "python_code": "import sys\nf = sys.stdin\nn , r , l = map ( int , f.readline ( ).split ( ) )\nappearance = [ 0 ] * n\npoint = [ 0 ] * n\ntop = 0\npre_t = 0\nfor line in f :\n    d , t , x = map ( int , line.split ( ) )\n    d -= 1\n    appearance [ top ] += t - pre_t\n    pre_t = t\n    point [ d ] += x\n    if 0 < x and top != d :\n        if point [ top ] < point [ d ] :\n            top = d\n        elif point [ top ] == point [ d ] and d < top :\n            top = d\n    elif x < 0 and top == d :\n        top = point.index ( max ( point ) )\nappearance [ top ] += l - pre_t\nprint ( 1 + appearance.index ( max ( appearance ) ) )\n", "python_code_tokenized": "import sys NEW_LINE f = sys . stdin NEW_LINE n , r , l = map ( int , f . readline ( ) . split ( ) ) NEW_LINE appearance = [ 0 ] * n NEW_LINE point = [ 0 ] * n NEW_LINE top = 0 NEW_LINE pre_t = 0 NEW_LINE for line in f : NEW_LINE INDENT d , t , x = map ( int , line . split ( ) ) NEW_LINE d -= 1 NEW_LINE appearance [ top ] += t - pre_t NEW_LINE pre_t = t NEW_LINE point [ d ] += x NEW_LINE if 0 < x and top != d : NEW_LINE INDENT if point [ top ] < point [ d ] : NEW_LINE INDENT top = d NEW_LINE DEDENT elif point [ top ] == point [ d ] and d < top : NEW_LINE INDENT top = d NEW_LINE DEDENT DEDENT elif x < 0 and top == d : NEW_LINE INDENT top = point . index ( max ( point ) ) NEW_LINE DEDENT DEDENT appearance [ top ] += l - pre_t NEW_LINE print ( 1 + appearance . index ( max ( appearance ) ) ) NEW_LINE"}
{"id": "codejam_12_23", "sol": 0, "python_code": "class Solver ( object ) :\n    @ classmethod\n    def setup ( cls , infile ) :\n        cls.data = { }\n    def __init__ ( self , infile , tc ) :\n        self.tc = tc\n        self.I = I = map ( int , infile.next ( ).split ( ) )\n    def solve ( self ) :\n        import itertools as it\n        S = self.I [ 1 : ]\n        seen = { }\n        for n in xrange ( 1 , 4 ) :\n            for s in it.combinations ( S , n ) :\n                ss = sum ( s )\n                if ss in seen :\n                    return 'Case #%s:\\n%s\\n%s\\n' % ( self.tc , ' '.join ( '%d' % i for i in s ) , ' '.join ( '%d' % i for i in seen [ ss ] ) , )\n                seen [ ss ] = s\n        return 'Case #%s: Impossible\\n' % ( self.tc , )\nif __name__ == '__main__' :\n    import sys\n    T = int ( sys.stdin.next ( ) )\n    Solver.setup ( sys.stdin )\n    for t in xrange ( 1 , T + 1 ) :\n        sys.stdout.write ( Solver ( sys.stdin , t ).solve ( ) )\n", "python_code_tokenized": "class Solver ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def setup ( cls , infile ) : NEW_LINE INDENT cls . data = { } NEW_LINE DEDENT def __init__ ( self , infile , tc ) : NEW_LINE INDENT self . tc = tc NEW_LINE self . I = I = map ( int , infile . next ( ) . split ( ) ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT import itertools as it NEW_LINE S = self . I [ 1 : ] NEW_LINE seen = { } NEW_LINE for n in xrange ( 1 , 4 ) : NEW_LINE INDENT for s in it . combinations ( S , n ) : NEW_LINE INDENT ss = sum ( s ) NEW_LINE if ss in seen : NEW_LINE INDENT return ' Case \u2581 # % s : \\n % s \\n % s \\n ' % ( self . tc , ' \u2581 ' . join ( ' % d ' % i for i in s ) , ' \u2581 ' . join ( ' % d ' % i for i in seen [ ss ] ) , ) NEW_LINE DEDENT seen [ ss ] = s NEW_LINE DEDENT DEDENT return ' Case \u2581 # % s : \u2581 Impossible \\n ' % ( self . tc , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE T = int ( sys . stdin . next ( ) ) NEW_LINE Solver . setup ( sys . stdin ) NEW_LINE for t in xrange ( 1 , T + 1 ) : NEW_LINE INDENT sys . stdout . write ( Solver ( sys . stdin , t ) . solve ( ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4739_A", "sol": 0, "python_code": "INT_SIZE = 32\ndef Right_most_setbit ( num ) :\n    pos = 1\n    for i in range ( INT_SIZE ) :\n        if not ( num & ( 1 << i ) ) :\n            pos += 1\n        else :\n            break\n    return pos\nif __name__ == \"__main__\" :\n    num = 18\n    pos = Right_most_setbit ( num )\n    print ( pos )\n", "python_code_tokenized": "INT_SIZE = 32 NEW_LINE def Right_most_setbit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT if not ( num & ( 1 << i ) ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 18 NEW_LINE pos = Right_most_setbit ( num ) NEW_LINE print ( pos ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC124_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\nc = 0\nfor i in range ( 2 ) :\n    c += max ( a , b )\n    if a >= b :\n        a -= 1\n    else :\n        b -= 1\nprint ( c )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT c += max ( a , b ) NEW_LINE if a >= b : NEW_LINE INDENT a -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT b -= 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE"}
{"id": "geeksforgeeks_107_A", "sol": 0, "python_code": "def freqPairs ( arr , n ) :\n    max = arr [ 0 ]\n    for i in range ( len ( arr ) ) :\n        if arr [ i ] > max :\n            max = arr [ i ]\n    freq = [ 0 for i in range ( max + 1 ) ]\n    count = 0\n    for i in range ( n ) :\n        freq [ arr [ i ] ] += 1\n    for i in range ( n ) :\n        for j in range ( 2 * arr [ i ] , max + 1 , arr [ i ] ) :\n            if ( freq [ j ] >= 1 ) :\n                count += freq [ j ]\n        if ( freq [ arr [ i ] ] > 1 ) :\n            count += freq [ arr [ i ] ] - 1\n            freq [ arr [ i ] ] -= 1\n    return count\nif __name__ == '__main__' :\n    arr = [ 3 , 2 , 4 , 2 , 6 ]\n    n = len ( arr )\n    print ( freqPairs ( arr , n ) )\n", "python_code_tokenized": "def freqPairs ( arr , n ) : NEW_LINE INDENT max = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT freq = [ 0 for i in range ( max + 1 ) ] NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 2 * arr [ i ] , max + 1 , arr [ i ] ) : NEW_LINE INDENT if ( freq [ j ] >= 1 ) : NEW_LINE INDENT count += freq [ j ] NEW_LINE DEDENT DEDENT if ( freq [ arr [ i ] ] > 1 ) : NEW_LINE INDENT count += freq [ arr [ i ] ] - 1 NEW_LINE freq [ arr [ i ] ] -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 4 , 2 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( freqPairs ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1663_A", "sol": 0, "python_code": "def getMinCost ( n , m ) :\n    cost = ( n - 1 ) * m + ( m - 1 ) * n\n    return cost\nif __name__ == \"__main__\" :\n    n , m = 4 , 5\n    print ( getMinCost ( n , m ) )\n", "python_code_tokenized": "def getMinCost ( n , m ) : NEW_LINE INDENT cost = ( n - 1 ) * m + ( m - 1 ) * n NEW_LINE return cost NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m = 4 , 5 NEW_LINE print ( getMinCost ( n , m ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1200_A", "sol": 0, "python_code": "def fib ( f , n ) :\n    f [ 0 ] = 0 ;\n    f [ 1 ] = 1 ;\n    for i in range ( 2 , n + 1 ) :\n        f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 ;\n    return f ;\ndef findLastDigit ( n ) :\n    f = [ 0 ] * 61 ;\n    f = fib ( f , 60 ) ;\n    return f [ n % 60 ] ;\nn = 1 ;\nprint ( findLastDigit ( n ) ) ;\nn = 61 ;\nprint ( findLastDigit ( n ) ) ;\nn = 7 ;\nprint ( findLastDigit ( n ) ) ;\nn = 67 ;\nprint ( findLastDigit ( n ) ) ;\n", "python_code_tokenized": "def fib ( f , n ) : NEW_LINE INDENT f [ 0 ] = 0 ; NEW_LINE f [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 ; NEW_LINE DEDENT return f ; NEW_LINE DEDENT def findLastDigit ( n ) : NEW_LINE INDENT f = [ 0 ] * 61 ; NEW_LINE f = fib ( f , 60 ) ; NEW_LINE return f [ n % 60 ] ; NEW_LINE DEDENT n = 1 ; NEW_LINE print ( findLastDigit ( n ) ) ; NEW_LINE n = 61 ; NEW_LINE print ( findLastDigit ( n ) ) ; NEW_LINE n = 7 ; NEW_LINE print ( findLastDigit ( n ) ) ; NEW_LINE n = 67 ; NEW_LINE print ( findLastDigit ( n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_1694_A", "sol": 0, "python_code": "def minJumps ( arr , l , h ) :\n    if ( h == l ) :\n        return 0\n    if ( arr [ l ] == 0 ) :\n        return float ( 'inf' )\n    min = float ( 'inf' )\n    for i in range ( l + 1 , h + 1 ) :\n        if ( i < l + arr [ l ] + 1 ) :\n            jumps = minJumps ( arr , i , h )\n            if ( jumps != float ( 'inf' ) and jumps + 1 < min ) :\n                min = jumps + 1\n    return min\narr = [ 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 ]\nn = len ( arr )\nprint ( 'Minimum number of jumps to reach' , 'end is' , minJumps ( arr , 0 , n - 1 ) )\n", "python_code_tokenized": "def minJumps ( arr , l , h ) : NEW_LINE INDENT if ( h == l ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ l ] == 0 ) : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT min = float ( ' inf ' ) NEW_LINE for i in range ( l + 1 , h + 1 ) : NEW_LINE INDENT if ( i < l + arr [ l ] + 1 ) : NEW_LINE INDENT jumps = minJumps ( arr , i , h ) NEW_LINE if ( jumps != float ( ' inf ' ) and jumps + 1 < min ) : NEW_LINE INDENT min = jumps + 1 NEW_LINE DEDENT DEDENT DEDENT return min NEW_LINE DEDENT arr = [ 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ' Minimum \u2581 number \u2581 of \u2581 jumps \u2581 to \u2581 reach ' , ' end \u2581 is ' , minJumps ( arr , 0 , n - 1 ) ) NEW_LINE"}
{"id": "aizu_p01854_A", "sol": 0, "python_code": "def main ( ) :\n    n , m = map ( int , input ( ).split ( ) )\n    height = [ ]\n    for _ in range ( n ) :\n        lst = list ( map ( int , input ( ).split ( ) ) )\n        k = lst [ 0 ]\n        ss = lst [ 1 : : 2 ]\n        hs = lst [ 2 : : 2 ]\n        v_acc = 0\n        h_acc = 0\n        index = 0\n        s , h = ss [ 0 ] , hs [ 0 ]\n        save = [ ]\n        for i in range ( m + 1 ) :\n            if i < v_acc + s * h :\n                save.append ( h_acc + ( i - v_acc ) / s )\n            else :\n                v_acc = i\n                h_acc += h\n                index += 1\n                save.append ( h_acc )\n                if index == k : break\n                s , h = ss [ index ] , hs [ index ]\n        height.append ( save )\n    dp = [ 0 ] * ( m + 1 )\n    for i in range ( n ) :\n        hi = height [ i ]\n        for j in range ( m , - 1 , - 1 ) :\n            dp [ j ] = max ( [ dp [ j - v ] + hi [ v ] for v in range ( min ( len ( hi ) , j + 1 ) ) ] )\n    print ( dp [ - 1 ] )\nmain ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE height = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = lst [ 0 ] NEW_LINE ss = lst [ 1 : : 2 ] NEW_LINE hs = lst [ 2 : : 2 ] NEW_LINE v_acc = 0 NEW_LINE h_acc = 0 NEW_LINE index = 0 NEW_LINE s , h = ss [ 0 ] , hs [ 0 ] NEW_LINE save = [ ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT if i < v_acc + s * h : NEW_LINE INDENT save . append ( h_acc + ( i - v_acc ) / s ) NEW_LINE DEDENT else : NEW_LINE INDENT v_acc = i NEW_LINE h_acc += h NEW_LINE index += 1 NEW_LINE save . append ( h_acc ) NEW_LINE if index == k : break NEW_LINE s , h = ss [ index ] , hs [ index ] NEW_LINE DEDENT DEDENT height . append ( save ) NEW_LINE DEDENT dp = [ 0 ] * ( m + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hi = height [ i ] NEW_LINE for j in range ( m , - 1 , - 1 ) : NEW_LINE INDENT dp [ j ] = max ( [ dp [ j - v ] + hi [ v ] for v in range ( min ( len ( hi ) , j + 1 ) ) ] ) NEW_LINE DEDENT DEDENT print ( dp [ - 1 ] ) NEW_LINE DEDENT main ( ) NEW_LINE"}
{"id": "projecteuler_p429_A", "sol": 0, "python_code": "import eulerlib\ndef compute ( ) :\n    LIMIT = 10 ** 8\n    MOD = 1000000009\n    ans = 1\n    for p in eulerlib.prime_generator ( LIMIT ) :\n        power = count_factors ( LIMIT , p )\n        ans *= 1 + pow ( p , power * 2 , MOD )\n        ans %= MOD\n    return str ( ans )\ndef count_factors ( n , p ) :\n    if n == 0 :\n        return 0\n    else :\n        return n // p + count_factors ( n // p , p )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE MOD = 1000000009 NEW_LINE ans = 1 NEW_LINE for p in eulerlib . prime_generator ( LIMIT ) : NEW_LINE INDENT power = count_factors ( LIMIT , p ) NEW_LINE ans *= 1 + pow ( p , power * 2 , MOD ) NEW_LINE ans %= MOD NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT def count_factors ( n , p ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return n // p + count_factors ( n // p , p ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_385_A", "sol": 0, "python_code": "from collections import defaultdict , deque\nfrom functools import lru_cache\nfrom heapq import heappush , heappop\nfrom typing import Counter\nfrom bisect import bisect_right , bisect_left\nimport math\nhpop = heappop\nhpush = heappush\ndef solution ( ) :\n    n , c = map ( int , input ( ).split ( ) )\n    arr = list ( map ( int , input ( ).split ( ) ) )\n    mx = 0\n    for i in range ( 1 , n ) :\n        mx = max ( mx , arr [ i - 1 ] - arr [ i ] )\n    if mx - c <= 0 :\n        print ( 0 )\n        return\n    print ( mx - c )\ndef main ( ) :\n    t = 1\n    for _ in range ( t ) :\n        solution ( )\nmain ( )\n", "python_code_tokenized": "from collections import defaultdict , deque NEW_LINE from functools import lru_cache NEW_LINE from heapq import heappush , heappop NEW_LINE from typing import Counter NEW_LINE from bisect import bisect_right , bisect_left NEW_LINE import math NEW_LINE hpop = heappop NEW_LINE hpush = heappush NEW_LINE def solution ( ) : NEW_LINE INDENT n , c = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mx = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT mx = max ( mx , arr [ i - 1 ] - arr [ i ] ) NEW_LINE DEDENT if mx - c <= 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT print ( mx - c ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = 1 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT solution ( ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "codeforces_696_A", "sol": 0, "python_code": "from typing import Set\nclass AutoMapping ( dict ) :\n    def __getitem__ ( self , key : int ) -> int :\n        try :\n            return super ( ).__getitem__ ( key )\n        except KeyError :\n            return 0\nfees = AutoMapping ( )\ndef path ( i : int , j : int ) -> Set [ int ] :\n    result = set ( )\n    while i != j :\n        result.add ( i )\n        result.add ( j )\n        if i > j :\n            i //= 2\n        else :\n            j //= 2\n    result.discard ( i )\n    return result\nfor _ in range ( int ( input ( ) ) ) :\n    event = input ( ).split ( )\n    if event [ 0 ] == \"1\" :\n        _ , v , u , w = map ( int , event )\n        for index in path ( u , v ) :\n            fees [ index ] += w\n    elif event [ 0 ] == \"2\" :\n        _ , v , u = map ( int , event )\n        result = 0\n        for index in path ( u , v ) :\n            result += fees [ index ]\n        print ( result )\n", "python_code_tokenized": "from typing import Set NEW_LINE class AutoMapping ( dict ) : NEW_LINE INDENT def __getitem__ ( self , key : int ) -> int : NEW_LINE INDENT try : NEW_LINE INDENT return super ( ) . __getitem__ ( key ) NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT fees = AutoMapping ( ) NEW_LINE def path ( i : int , j : int ) -> Set [ int ] : NEW_LINE INDENT result = set ( ) NEW_LINE while i != j : NEW_LINE INDENT result . add ( i ) NEW_LINE result . add ( j ) NEW_LINE if i > j : NEW_LINE INDENT i //= 2 NEW_LINE DEDENT else : NEW_LINE INDENT j //= 2 NEW_LINE DEDENT DEDENT result . discard ( i ) NEW_LINE return result NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT event = input ( ) . split ( ) NEW_LINE if event [ 0 ] == \"1\" : NEW_LINE INDENT _ , v , u , w = map ( int , event ) NEW_LINE for index in path ( u , v ) : NEW_LINE INDENT fees [ index ] += w NEW_LINE DEDENT DEDENT elif event [ 0 ] == \"2\" : NEW_LINE INDENT _ , v , u = map ( int , event ) NEW_LINE result = 0 NEW_LINE for index in path ( u , v ) : NEW_LINE INDENT result += fees [ index ] NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1014_A", "sol": 0, "python_code": "def countNum ( N , arr ) :\n    Sum , count = 0 , 0\n    for i in range ( N ) :\n        Sum += arr [ i ]\n    for i in range ( N ) :\n        if ( ( Sum - arr [ i ] ) % arr [ i ] == 0 ) :\n            count += 1\n    return count\narr = [ 3 , 10 , 4 , 6 , 7 ]\nn = len ( arr )\nprint ( countNum ( n , arr ) )\n", "python_code_tokenized": "def countNum ( N , arr ) : NEW_LINE INDENT Sum , count = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( ( Sum - arr [ i ] ) % arr [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 10 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( n , arr ) ) NEW_LINE"}
{"id": "geeksforgeeks_1013_A", "sol": 0, "python_code": "def countNum ( N , arr ) :\n    count = 0\n    for i in range ( N ) :\n        Sum = 0\n        for j in range ( N ) :\n            if ( i == j ) :\n                continue\n            else :\n                Sum += arr [ j ]\n        if ( Sum % arr [ i ] == 0 ) :\n            count += 1\n    return count\narr = [ 3 , 10 , 4 , 6 , 7 ]\nn = len ( arr )\nprint ( countNum ( n , arr ) )\n", "python_code_tokenized": "def countNum ( N , arr ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT Sum += arr [ j ] NEW_LINE DEDENT DEDENT if ( Sum % arr [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 10 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( n , arr ) ) NEW_LINE"}
{"id": "geeksforgeeks_1263_A", "sol": 0, "python_code": "import math as mt\ndef preProcess ( n ) :\n    preProcessedCubes = list ( )\n    for i in range ( 1 , mt.ceil ( n ** ( 1./ 3.) ) ) :\n        iThCube = i ** 3\n        cubeString = str ( iThCube )\n        preProcessedCubes.append ( cubeString )\n    return preProcessedCubes\ndef findLargestCubeUtil ( num , preProcessedCubes ) :\n    preProcessedCubes = preProcessedCubes [ : : - 1 ]\n    totalCubes = len ( preProcessedCubes )\n    for i in range ( totalCubes ) :\n        currCube = preProcessedCubes [ i ]\n        digitsInCube = len ( currCube )\n        index = 0\n        digitsInNumber = len ( num )\n        for j in range ( digitsInNumber ) :\n            if ( num [ j ] == currCube [ index ] ) :\n                index += 1\n            if ( digitsInCube == index ) :\n                return currCube\n    return \"Not Possible\"\ndef findLargestCube ( n ) :\n    preProcessedCubes = preProcess ( n )\n    num = str ( n )\n    ans = findLargestCubeUtil ( num , preProcessedCubes )\n    print ( \"Largest Cube that can be formed from\" , n , \"is\" , ans )\nn = 4125\nfindLargestCube ( n )\nn = 876\nfindLargestCube ( n )\n", "python_code_tokenized": "import math as mt NEW_LINE def preProcess ( n ) : NEW_LINE INDENT preProcessedCubes = list ( ) NEW_LINE for i in range ( 1 , mt . ceil ( n ** ( 1. / 3. ) ) ) : NEW_LINE INDENT iThCube = i ** 3 NEW_LINE cubeString = str ( iThCube ) NEW_LINE preProcessedCubes . append ( cubeString ) NEW_LINE DEDENT return preProcessedCubes NEW_LINE DEDENT def findLargestCubeUtil ( num , preProcessedCubes ) : NEW_LINE INDENT preProcessedCubes = preProcessedCubes [ : : - 1 ] NEW_LINE totalCubes = len ( preProcessedCubes ) NEW_LINE for i in range ( totalCubes ) : NEW_LINE INDENT currCube = preProcessedCubes [ i ] NEW_LINE digitsInCube = len ( currCube ) NEW_LINE index = 0 NEW_LINE digitsInNumber = len ( num ) NEW_LINE for j in range ( digitsInNumber ) : NEW_LINE INDENT if ( num [ j ] == currCube [ index ] ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT if ( digitsInCube == index ) : NEW_LINE INDENT return currCube NEW_LINE DEDENT DEDENT DEDENT return \" Not \u2581 Possible \" NEW_LINE DEDENT def findLargestCube ( n ) : NEW_LINE INDENT preProcessedCubes = preProcess ( n ) NEW_LINE num = str ( n ) NEW_LINE ans = findLargestCubeUtil ( num , preProcessedCubes ) NEW_LINE print ( \" Largest \u2581 Cube \u2581 that \u2581 can \u2581 be \u2581 formed \u2581 from \" , n , \" is \" , ans ) NEW_LINE DEDENT n = 4125 NEW_LINE findLargestCube ( n ) NEW_LINE n = 876 NEW_LINE findLargestCube ( n ) NEW_LINE"}
{"id": "codeforces_1186_A", "sol": 0, "python_code": "a , b , c = map ( int , input ( ).split ( ) )\nif a <= b and a <= c :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a <= b and a <= c : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "codeforces_52_B", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nlin = [ ]\nkol_stroka = [ 0 for _ in range ( n ) ]\nkol_stolb = [ 0 for _ in range ( m ) ]\nfor i in range ( n ) :\n    lin.append ( list ( input ( ) ) )\n    k = 0\n    for j in range ( len ( lin [ i ] ) ) :\n        if lin [ i ] [ j ] == '*' :\n            k += 1\n            kol_stolb [ j ] += 1\n    kol_stroka [ i ] += k\ncounter = 0\nfor i in range ( n ) :\n    for j in range ( m ) :\n        if lin [ i ] [ j ] == '*' :\n            counter += ( kol_stroka [ i ] - 1 ) * ( kol_stolb [ j ] - 1 )\nprint ( counter )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE lin = [ ] NEW_LINE kol_stroka = [ 0 for _ in range ( n ) ] NEW_LINE kol_stolb = [ 0 for _ in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lin . append ( list ( input ( ) ) ) NEW_LINE k = 0 NEW_LINE for j in range ( len ( lin [ i ] ) ) : NEW_LINE INDENT if lin [ i ] [ j ] == ' * ' : NEW_LINE INDENT k += 1 NEW_LINE kol_stolb [ j ] += 1 NEW_LINE DEDENT DEDENT kol_stroka [ i ] += k NEW_LINE DEDENT counter = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if lin [ i ] [ j ] == ' * ' : NEW_LINE INDENT counter += ( kol_stroka [ i ] - 1 ) * ( kol_stolb [ j ] - 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( counter ) NEW_LINE"}
{"id": "codeforces_1042_B", "sol": 0, "python_code": "n = int ( input ( ) )\nm = { \"A\" : float ( 'inf' ) , \"B\" : float ( 'inf' ) , \"C\" : float ( 'inf' ) , \"AB\" : float ( 'inf' ) , \"AC\" : float ( 'inf' ) , \"BC\" : float ( 'inf' ) , \"ABC\" : float ( 'inf' ) }\nfor i in range ( n ) :\n    inp = input ( )\n    item = inp.split ( ' ' )\n    l = \"\".join ( sorted ( item [ 1 ] ) )\n    m [ l ] = min ( m [ l ] , int ( item [ 0 ] ) )\nres = float ( 'inf' )\nres = min ( res , m [ \"A\" ] + m [ \"B\" ] + m [ \"C\" ] )\nres = min ( res , m [ \"AB\" ] + m [ \"C\" ] )\nres = min ( res , m [ \"AC\" ] + m [ \"B\" ] )\nres = min ( res , m [ \"A\" ] + m [ \"BC\" ] )\nres = min ( res , m [ \"BC\" ] + m [ \"AB\" ] )\nres = min ( res , m [ \"AC\" ] + m [ \"BC\" ] )\nres = min ( res , m [ \"AC\" ] + m [ \"AB\" ] )\nres = min ( res , m [ \"ABC\" ] )\nprint ( res if res != float ( 'inf' ) else - 1 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE m = { \" A \" : float ( ' inf ' ) , \" B \" : float ( ' inf ' ) , \" C \" : float ( ' inf ' ) , \" AB \" : float ( ' inf ' ) , \" AC \" : float ( ' inf ' ) , \" BC \" : float ( ' inf ' ) , \" ABC \" : float ( ' inf ' ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT inp = input ( ) NEW_LINE item = inp . split ( ' \u2581 ' ) NEW_LINE l = \" \" . join ( sorted ( item [ 1 ] ) ) NEW_LINE m [ l ] = min ( m [ l ] , int ( item [ 0 ] ) ) NEW_LINE DEDENT res = float ( ' inf ' ) NEW_LINE res = min ( res , m [ \" A \" ] + m [ \" B \" ] + m [ \" C \" ] ) NEW_LINE res = min ( res , m [ \" AB \" ] + m [ \" C \" ] ) NEW_LINE res = min ( res , m [ \" AC \" ] + m [ \" B \" ] ) NEW_LINE res = min ( res , m [ \" A \" ] + m [ \" BC \" ] ) NEW_LINE res = min ( res , m [ \" BC \" ] + m [ \" AB \" ] ) NEW_LINE res = min ( res , m [ \" AC \" ] + m [ \" BC \" ] ) NEW_LINE res = min ( res , m [ \" AC \" ] + m [ \" AB \" ] ) NEW_LINE res = min ( res , m [ \" ABC \" ] ) NEW_LINE print ( res if res != float ( ' inf ' ) else - 1 ) NEW_LINE"}
{"id": "codeforces_134_B", "sol": 0, "python_code": "def calc ( n , m ) :\n    ans = 0\n    while ( m > 1 ) :\n        ans += n // m\n        n , m = m , n % m\n    if m == 0 :\n        return float ( \"inf\" )\n    return ans + n - 1\nn = int ( input ( ) )\nans = n - 1\nfor i in range ( 1 , n + 1 ) :\n    ans = min ( ans , calc ( n , i ) )\nprint ( ans )\n", "python_code_tokenized": "def calc ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( m > 1 ) : NEW_LINE INDENT ans += n // m NEW_LINE n , m = m , n % m NEW_LINE DEDENT if m == 0 : NEW_LINE INDENT return float ( \" inf \" ) NEW_LINE DEDENT return ans + n - 1 NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE ans = n - 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = min ( ans , calc ( n , i ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_1897_A", "sol": 0, "python_code": "maxin = 100001 ;\ndivisors = [ 0 ] * ( maxin + 1 ) ;\ndef Calc_Max_Div ( arr , n ) :\n    vis = [ 1 ] * ( maxin + 1 ) ;\n    vis [ 0 ] = vis [ 1 ] = 0 ;\n    for i in range ( 1 , maxin + 1 ) :\n        divisors [ i ] = i ;\n    for i in range ( 4 , maxin + 1 , 2 ) :\n        vis [ i ] = 0 ;\n        divisors [ i ] = i // 2 ;\n    for i in range ( 3 , maxin + 1 , 2 ) :\n        if ( divisors [ i ] != i ) :\n            divisors [ i ] = i // divisors [ i ] ;\n        if ( vis [ i ] == 1 ) :\n            for j in range ( i * i , maxin , i ) :\n                vis [ j ] = 0 ;\n                if ( divisors [ j ] == j ) :\n                    divisors [ j ] = i ;\n    for i in range ( n ) :\n        if ( divisors [ arr [ i ] ] == arr [ i ] ) :\n            print ( \"-1 \" , end = \"\" ) ;\n        else :\n            print ( divisors [ arr [ i ] ] , end = \" \" ) ;\nif __name__ == \"__main__\" :\n    arr = [ 5 , 6 , 7 , 8 , 9 , 10 ] ;\n    n = len ( arr ) ;\n    Calc_Max_Div ( arr , n ) ;\n", "python_code_tokenized": "maxin = 100001 ; NEW_LINE divisors = [ 0 ] * ( maxin + 1 ) ; NEW_LINE def Calc_Max_Div ( arr , n ) : NEW_LINE INDENT vis = [ 1 ] * ( maxin + 1 ) ; NEW_LINE vis [ 0 ] = vis [ 1 ] = 0 ; NEW_LINE for i in range ( 1 , maxin + 1 ) : NEW_LINE INDENT divisors [ i ] = i ; NEW_LINE DEDENT for i in range ( 4 , maxin + 1 , 2 ) : NEW_LINE INDENT vis [ i ] = 0 ; NEW_LINE divisors [ i ] = i // 2 ; NEW_LINE DEDENT for i in range ( 3 , maxin + 1 , 2 ) : NEW_LINE INDENT if ( divisors [ i ] != i ) : NEW_LINE INDENT divisors [ i ] = i // divisors [ i ] ; NEW_LINE DEDENT if ( vis [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i * i , maxin , i ) : NEW_LINE INDENT vis [ j ] = 0 ; NEW_LINE if ( divisors [ j ] == j ) : NEW_LINE INDENT divisors [ j ] = i ; NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( divisors [ arr [ i ] ] == arr [ i ] ) : NEW_LINE INDENT print ( \" - 1 \u2581 \" , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( divisors [ arr [ i ] ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 6 , 7 , 8 , 9 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE Calc_Max_Div ( arr , n ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1729_A", "sol": 0, "python_code": "n = int ( input ( ) )\nfor _ in range ( n ) :\n    a , b , c = [ int ( x ) for x in input ( ).split ( ) ]\n    t1 = abs ( a - 1 )\n    t2 = abs ( b - c ) + abs ( c - 1 )\n    if t1 < t2 :\n        print ( 1 )\n    elif t1 > t2 :\n        print ( 2 )\n    else :\n        print ( 3 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b , c = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE t1 = abs ( a - 1 ) NEW_LINE t2 = abs ( b - c ) + abs ( c - 1 ) NEW_LINE if t1 < t2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif t1 > t2 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT DEDENT"}
{"id": "codejam_15_54", "sol": 0, "python_code": "tc = int ( input ( ).strip ( ) )\nfor t in range ( tc ) :\n    n = int ( input ( ).strip ( ) )\n    v = [ int ( x ) for x in input ( ).split ( ) ]\n    c = [ int ( x ) for x in input ( ).split ( ) ]\n    cnt = sum ( c )\n    c [ 0 ] -= 1\n    midx = 0\n    res = [ ]\n    while cnt > 2 :\n        while c [ midx ] == 0 :\n            midx += 1\n        d = v [ midx ] - v [ 0 ]\n        res.append ( d )\n        if d == 0 :\n            for i in range ( n ) :\n                c [ i ] = c [ i ] // 2\n        else :\n            tosub = { d : c [ 0 ] + 1 }\n            for i in range ( 1 , n ) :\n                c [ i ] -= tosub.get ( v [ i ] , 0 )\n                tosub [ v [ i ] + d ] = c [ i ]\n        cnt /= 2\n    while c [ midx ] == 0 :\n        midx += 1\n    if v [ 0 ] == 0 :\n        res.append ( v [ midx ] )\n    else :\n        res.append ( v [ 0 ] )\n    print ( \"Case #%d: %s\" % ( t + 1 , \" \".join ( str ( x ) for x in sorted ( res ) ) ) )\n", "python_code_tokenized": "tc = int ( input ( ) . strip ( ) ) NEW_LINE for t in range ( tc ) : NEW_LINE INDENT n = int ( input ( ) . strip ( ) ) NEW_LINE v = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE c = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE cnt = sum ( c ) NEW_LINE c [ 0 ] -= 1 NEW_LINE midx = 0 NEW_LINE res = [ ] NEW_LINE while cnt > 2 : NEW_LINE INDENT while c [ midx ] == 0 : NEW_LINE INDENT midx += 1 NEW_LINE DEDENT d = v [ midx ] - v [ 0 ] NEW_LINE res . append ( d ) NEW_LINE if d == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT c [ i ] = c [ i ] // 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT tosub = { d : c [ 0 ] + 1 } NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT c [ i ] -= tosub . get ( v [ i ] , 0 ) NEW_LINE tosub [ v [ i ] + d ] = c [ i ] NEW_LINE DEDENT DEDENT cnt /= 2 NEW_LINE DEDENT while c [ midx ] == 0 : NEW_LINE INDENT midx += 1 NEW_LINE DEDENT if v [ 0 ] == 0 : NEW_LINE INDENT res . append ( v [ midx ] ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( v [ 0 ] ) NEW_LINE DEDENT print ( \" Case \u2581 # % d : \u2581 % s \" % ( t + 1 , \" \u2581 \" . join ( str ( x ) for x in sorted ( res ) ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3388_A", "sol": 0, "python_code": "N = 4 ;\ndef diagonalBoundarySum ( arr ) :\n    requiredSum = 0 ;\n    for i in range ( N ) :\n        for j in range ( N ) :\n            if ( i == j or ( i + j ) == N - 1 ) :\n                requiredSum += arr [ i ] [ j ] ;\n            elif ( i == 0 or j == 0 or i == N - 1 or j == N - 1 ) :\n                requiredSum += arr [ i ] [ j ] ;\n    print ( requiredSum ) ;\nif __name__ == '__main__' :\n    arr = [ [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] ] ;\n    diagonalBoundarySum ( arr ) ;\n", "python_code_tokenized": "N = 4 ; NEW_LINE def diagonalBoundarySum ( arr ) : NEW_LINE INDENT requiredSum = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( i == j or ( i + j ) == N - 1 ) : NEW_LINE INDENT requiredSum += arr [ i ] [ j ] ; NEW_LINE DEDENT elif ( i == 0 or j == 0 or i == N - 1 or j == N - 1 ) : NEW_LINE INDENT requiredSum += arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT print ( requiredSum ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] ] ; NEW_LINE diagonalBoundarySum ( arr ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1711_A", "sol": 0, "python_code": "def countNonDecreasing ( n ) :\n    N = 10\n    count = 1\n    for i in range ( 1 , n + 1 ) :\n        count = int ( count * ( N + i - 1 ) )\n        count = int ( count / i )\n    return count\nn = 3 ;\nprint ( countNonDecreasing ( n ) )\n", "python_code_tokenized": "def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count = int ( count * ( N + i - 1 ) ) NEW_LINE count = int ( count / i ) NEW_LINE DEDENT return count NEW_LINE DEDENT n = 3 ; NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE"}
{"id": "aizu_p01298_A", "sol": 0, "python_code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve ( ) :\n    N , L = map ( int , readline ( ).split ( ) )\n    if N == 0 :\n        return False\n    ma = 0\n    P = [ list ( map ( int , readline ( ).split ( ) ) ) for i in range ( N ) ]\n    ma = max ( u for s , t , u in P )\n    K = 86400\n    EPS = 1e-8\n    def check ( x , M = 2 ) :\n        rest = L\n        R = [ 0 ] * M\n        for i in range ( M ) :\n            prv = 0\n            for s , t , u in P :\n                rest = min ( rest + ( s - prv ) * x , L )\n                rest = min ( rest + ( t - s ) * ( x - u ) , L )\n                prv = t\n                if rest < 0 :\n                    return 0\n            rest = min ( rest + ( K - prv ) * x , L )\n            R [ i ] = rest\n        return R [ - 2 ] - EPS < R [ - 1 ]\n    left = 0 ; right = ma\n    while left + EPS < right :\n        mid = ( left + right ) / 2\n        if check ( mid ) :\n            right = mid\n        else :\n            left = mid\n    write ( \"%.016f\\n\" % right )\n    return True\nwhile solve ( ) :\n   ...\n", "python_code_tokenized": "import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT N , L = map ( int , readline ( ) . split ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT ma = 0 NEW_LINE P = [ list ( map ( int , readline ( ) . split ( ) ) ) for i in range ( N ) ] NEW_LINE ma = max ( u for s , t , u in P ) NEW_LINE K = 86400 NEW_LINE EPS = 1e-8 NEW_LINE def check ( x , M = 2 ) : NEW_LINE INDENT rest = L NEW_LINE R = [ 0 ] * M NEW_LINE for i in range ( M ) : NEW_LINE INDENT prv = 0 NEW_LINE for s , t , u in P : NEW_LINE INDENT rest = min ( rest + ( s - prv ) * x , L ) NEW_LINE rest = min ( rest + ( t - s ) * ( x - u ) , L ) NEW_LINE prv = t NEW_LINE if rest < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT rest = min ( rest + ( K - prv ) * x , L ) NEW_LINE R [ i ] = rest NEW_LINE DEDENT return R [ - 2 ] - EPS < R [ - 1 ] NEW_LINE DEDENT left = 0 ; right = ma NEW_LINE while left + EPS < right : NEW_LINE INDENT mid = ( left + right ) / 2 NEW_LINE if check ( mid ) : NEW_LINE INDENT right = mid NEW_LINE DEDENT else : NEW_LINE INDENT left = mid NEW_LINE DEDENT DEDENT write ( \" % .016f \\n \" % right ) NEW_LINE return True NEW_LINE DEDENT while solve ( ) : NEW_LINE INDENT ... NEW_LINE DEDENT"}
{"id": "codeforces_1100_B", "sol": 0, "python_code": "def main ( ) :\n    n , m = [ int ( i ) for i in input ( ).split ( \"\" ) ]\n    a = [ int ( u ) for u in input ( ).split ( \"\" ) ]\n    hash_a = [ 0 for i in range ( n + 2 ) ]\n    counters = [ 0 for i in range ( 2 * m ) ]\n    collector = [ ]\n    for i in range ( len ( a ) ) :\n        hash_a [ a [ i ] ] += 1\n        counters [ hash_a [ a [ i ] ] ] += 1\n        if counters [ hash_a [ a [ i ] ] ] == n :\n            collector.append ( \"1\" )\n        else :\n            collector.append ( \"0\" )\n    print ( \"\".join ( collector ) )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT n , m = [ int ( i ) for i in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE a = [ int ( u ) for u in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE hash_a = [ 0 for i in range ( n + 2 ) ] NEW_LINE counters = [ 0 for i in range ( 2 * m ) ] NEW_LINE collector = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT hash_a [ a [ i ] ] += 1 NEW_LINE counters [ hash_a [ a [ i ] ] ] += 1 NEW_LINE if counters [ hash_a [ a [ i ] ] ] == n : NEW_LINE INDENT collector . append ( \"1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT collector . append ( \"0\" ) NEW_LINE DEDENT DEDENT print ( \" \" . join ( collector ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_74_A", "sol": 0, "python_code": "import math\nresult = [ \"x\" , - math.inf ]\nfor x in range ( int ( input ( ) ) ) :\n    l = [ int ( x ) if x.isnumeric ( ) else x for x in input ( ).split ( ) ]\n    target = ( sum ( l [ 3 : ] ) + 100 * l [ 1 ] - 50 * l [ 2 ] )\n    if result [ 1 ] < target :\n        result = [ l [ 0 ] , target ]\nprint ( result [ 0 ] )\n", "python_code_tokenized": "import math NEW_LINE result = [ \" x \" , - math . inf ] NEW_LINE for x in range ( int ( input ( ) ) ) : NEW_LINE INDENT l = [ int ( x ) if x . isnumeric ( ) else x for x in input ( ) . split ( ) ] NEW_LINE target = ( sum ( l [ 3 : ] ) + 100 * l [ 1 ] - 50 * l [ 2 ] ) NEW_LINE if result [ 1 ] < target : NEW_LINE INDENT result = [ l [ 0 ] , target ] NEW_LINE DEDENT DEDENT print ( result [ 0 ] ) NEW_LINE"}
{"id": "codeforces_245_A", "sol": 0, "python_code": "n_pings = int ( input ( ) )\npackets = [ [ 0 , 0 ] , [ 0 , 0 ] ]\nfor _ in range ( n_pings ) :\n    t , x , y = map ( int , input ( ).split ( ) )\n    packets [ t - 1 ] [ 0 ] += x\n    packets [ t - 1 ] [ 1 ] += x + y\nif packets [ 0 ] [ 1 ] == 0 or packets [ 0 ] [ 0 ] / packets [ 0 ] [ 1 ] >= 0.5 :\n    print ( \"LIVE\" )\nelse :\n    print ( \"DEAD\" )\nif packets [ 1 ] [ 1 ] == 0 or packets [ 1 ] [ 0 ] / packets [ 1 ] [ 1 ] >= 0.5 :\n    print ( \"LIVE\" )\nelse :\n    print ( \"DEAD\" )\n", "python_code_tokenized": "n_pings = int ( input ( ) ) NEW_LINE packets = [ [ 0 , 0 ] , [ 0 , 0 ] ] NEW_LINE for _ in range ( n_pings ) : NEW_LINE INDENT t , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE packets [ t - 1 ] [ 0 ] += x NEW_LINE packets [ t - 1 ] [ 1 ] += x + y NEW_LINE DEDENT if packets [ 0 ] [ 1 ] == 0 or packets [ 0 ] [ 0 ] / packets [ 0 ] [ 1 ] >= 0.5 : NEW_LINE INDENT print ( \" LIVE \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" DEAD \" ) NEW_LINE DEDENT if packets [ 1 ] [ 1 ] == 0 or packets [ 1 ] [ 0 ] / packets [ 1 ] [ 1 ] >= 0.5 : NEW_LINE INDENT print ( \" LIVE \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" DEAD \" ) NEW_LINE DEDENT"}
{"id": "aizu_p02242_A", "sol": 0, "python_code": "inf = float ( \"inf\" )\nn = int ( input ( ) )\nM = [ [ inf for i in range ( n ) ] for i in range ( n ) ]\nfor i in range ( n ) :\n    L = list ( map ( int , input ( ).split ( ) ) )\n    for j in range ( L [ 1 ] ) :\n        M [ L [ 0 ] ] [ L [ 2 * j + 2 ] ] = L [ 2 * j + 3 ]\ndef dijkstra ( s ) :\n    color = [ 0 ] * n\n    d = [ inf ] * n\n    d [ s ] = 0\n    while True :\n        mincost = inf\n        for i in range ( n ) :\n            if color [ i ] != 1 and d [ i ] < mincost :\n                mincost = d [ i ]\n                u = i\n        if mincost == inf : break\n        color [ u ] = 1\n        for v in range ( n ) :\n            if color [ v ] != 1 and M [ u ] [ v ] != inf :\n                if d [ u ] + M [ u ] [ v ] < d [ v ] :\n                    d [ v ] = d [ u ] + M [ u ] [ v ]\n    return d\nd = dijkstra ( 0 )\nfor i , v in enumerate ( d ) :\n    print ( \"{} {}\".format ( i , v ) )\n", "python_code_tokenized": "inf = float ( \" inf \" ) NEW_LINE n = int ( input ( ) ) NEW_LINE M = [ [ inf for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( L [ 1 ] ) : NEW_LINE INDENT M [ L [ 0 ] ] [ L [ 2 * j + 2 ] ] = L [ 2 * j + 3 ] NEW_LINE DEDENT DEDENT def dijkstra ( s ) : NEW_LINE INDENT color = [ 0 ] * n NEW_LINE d = [ inf ] * n NEW_LINE d [ s ] = 0 NEW_LINE while True : NEW_LINE INDENT mincost = inf NEW_LINE for i in range ( n ) : NEW_LINE INDENT if color [ i ] != 1 and d [ i ] < mincost : NEW_LINE INDENT mincost = d [ i ] NEW_LINE u = i NEW_LINE DEDENT DEDENT if mincost == inf : break NEW_LINE color [ u ] = 1 NEW_LINE for v in range ( n ) : NEW_LINE INDENT if color [ v ] != 1 and M [ u ] [ v ] != inf : NEW_LINE INDENT if d [ u ] + M [ u ] [ v ] < d [ v ] : NEW_LINE INDENT d [ v ] = d [ u ] + M [ u ] [ v ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return d NEW_LINE DEDENT d = dijkstra ( 0 ) NEW_LINE for i , v in enumerate ( d ) : NEW_LINE INDENT print ( \" { } \u2581 { } \" . format ( i , v ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4615_A", "sol": 0, "python_code": "def findEquation ( a , b ) :\n    summ = ( a + b )\n    product = ( a * b )\n    print ( \"x^2 - (\" , summ , \"x) + (\" , product , \") = 0\" )\na = 2\nb = 3\nfindEquation ( a , b )\n", "python_code_tokenized": "def findEquation ( a , b ) : NEW_LINE INDENT summ = ( a + b ) NEW_LINE product = ( a * b ) NEW_LINE print ( \" x ^ 2 \u2581 - \u2581 ( \" , summ , \" x ) \u2581 + \u2581 ( \" , product , \" ) \u2581 = \u2581 0\" ) NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE findEquation ( a , b ) NEW_LINE"}
{"id": "geeksforgeeks_5002_A", "sol": 0, "python_code": "import math as mt\ndef countX ( n ) :\n    count = 0\n    for i in range ( n + 1 ) :\n        if n - i == ( n ^ i ) :\n            count += 1\n    return count\nif __name__ == '__main__' :\n    n = 5\n    answer = countX ( n )\n    print ( answer )\n", "python_code_tokenized": "import math as mt NEW_LINE def countX ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if n - i == ( n ^ i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE answer = countX ( n ) NEW_LINE print ( answer ) NEW_LINE DEDENT"}
{"id": "codeforces_847_B", "sol": 0, "python_code": "from sys import stdin\nfrom math import sqrt\ndef main ( ) :\n    n = int ( stdin.readline ( ) )\n    a = list ( map ( int , stdin.readline ( ).split ( ) ) )\n    ans = [ [ a [ 0 ] , ] , ]\n    for i in range ( 1 , n ) :\n        l = 0\n        r = len ( ans ) - 1\n        while r > l :\n            m = ( r + l ) // 2\n            if a [ i ] > ans [ m ] [ len ( ans [ m ] ) - 1 ] :\n                r = m\n            else :\n                l = m + 1\n        if a [ i ] > ans [ l ] [ len ( ans [ l ] ) - 1 ] :\n            ans [ l ].append ( a [ i ] )\n        else :\n            ans.append ( [ a [ i ] , ] )\n    for arr in ans :\n        print ( * arr )\nmain ( )\n", "python_code_tokenized": "from sys import stdin NEW_LINE from math import sqrt NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( stdin . readline ( ) ) NEW_LINE a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE ans = [ [ a [ 0 ] , ] , ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = len ( ans ) - 1 NEW_LINE while r > l : NEW_LINE INDENT m = ( r + l ) // 2 NEW_LINE if a [ i ] > ans [ m ] [ len ( ans [ m ] ) - 1 ] : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if a [ i ] > ans [ l ] [ len ( ans [ l ] ) - 1 ] : NEW_LINE INDENT ans [ l ] . append ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( [ a [ i ] , ] ) NEW_LINE DEDENT DEDENT for arr in ans : NEW_LINE INDENT print ( * arr ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_1611_A", "sol": 0, "python_code": "def findSum ( n ) :\n    ans = 0 ; temp = 0 ;\n    for i in range ( 1 , n + 1 ) :\n        if temp < n :\n            temp = i - 1\n            num = 1\n            while temp < n :\n                if temp + i <= n :\n                    ans += i * num\n                else :\n                    ans += ( n - temp ) * num\n                temp += i\n                num += 1\n    return ans\nN = 2\nprint ( findSum ( N ) )\n", "python_code_tokenized": "def findSum ( n ) : NEW_LINE INDENT ans = 0 ; temp = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if temp < n : NEW_LINE INDENT temp = i - 1 NEW_LINE num = 1 NEW_LINE while temp < n : NEW_LINE INDENT if temp + i <= n : NEW_LINE INDENT ans += i * num NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( n - temp ) * num NEW_LINE DEDENT temp += i NEW_LINE num += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT N = 2 NEW_LINE print ( findSum ( N ) ) NEW_LINE"}
{"id": "geeksforgeeks_2990_A", "sol": 0, "python_code": "def printbinomial ( max ) :\n    for m in range ( max + 1 ) :\n        print ( '% 2d' % m , end = '' )\n        binom = 1\n        for x in range ( m + 1 ) :\n            if m != 0 and x != 0 :\n                binom = binom * ( m - x + 1 ) / x\n            print ( '% 4d' % binom , end = '' )\n        print ( \"\\n\" , end = '' )\nmax = 10\nprintbinomial ( max )\n", "python_code_tokenized": "def printbinomial ( max ) : NEW_LINE INDENT for m in range ( max + 1 ) : NEW_LINE INDENT print ( ' % \u2581 2d ' % m , end = ' \u2581 ' ) NEW_LINE binom = 1 NEW_LINE for x in range ( m + 1 ) : NEW_LINE INDENT if m != 0 and x != 0 : NEW_LINE INDENT binom = binom * ( m - x + 1 ) / x NEW_LINE DEDENT print ( ' % \u2581 4d ' % binom , end = ' \u2581 ' ) NEW_LINE DEDENT print ( \" \\n \" , end = ' ' ) NEW_LINE DEDENT DEDENT max = 10 NEW_LINE printbinomial ( max ) NEW_LINE"}
{"id": "geeksforgeeks_1307_A", "sol": 0, "python_code": "def CountPair ( L , R ) :\n    x = ( R - L + 1 )\n    print ( x // 2 )\nif __name__ == '__main__' :\n    L , R = 1 , 8\n    CountPair ( L , R )\n", "python_code_tokenized": "def CountPair ( L , R ) : NEW_LINE INDENT x = ( R - L + 1 ) NEW_LINE print ( x // 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 1 , 8 NEW_LINE CountPair ( L , R ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_815_A", "sol": 0, "python_code": "def squareArea ( l , b , h ) :\n    if l < 0 or b < 0 or h < 0 :\n        return - 1\n    a = ( l * b ) / ( l + b )\n    return a * a\nif __name__ == \"__main__\" :\n    l , b , h = 5 , 12 , 13\n    print ( round ( squareArea ( l , b , h ) , 4 ) )\n", "python_code_tokenized": "def squareArea ( l , b , h ) : NEW_LINE INDENT if l < 0 or b < 0 or h < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( l * b ) / ( l + b ) NEW_LINE return a * a NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l , b , h = 5 , 12 , 13 NEW_LINE print ( round ( squareArea ( l , b , h ) , 4 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2463_A", "sol": 0, "python_code": "def hexagonside ( a ) :\n    if a < 0 :\n        return - 1\n    x = a // 3\n    return x\na = 6\nprint ( hexagonside ( a ) )\n", "python_code_tokenized": "def hexagonside ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = a // 3 NEW_LINE return x NEW_LINE DEDENT a = 6 NEW_LINE print ( hexagonside ( a ) ) NEW_LINE"}
{"id": "geeksforgeeks_3183_A", "sol": 0, "python_code": "def createHash ( hash1 , maxElement ) :\n    prev , curr = 0 , 1\n    hash1.add ( prev )\n    hash1.add ( curr )\n    while ( curr < maxElement ) :\n        temp = curr + prev\n        hash1.add ( temp )\n        prev = curr\n        curr = temp\ndef findFibonacciPair ( n ) :\n    hash1 = set ( )\n    createHash ( hash1 , n )\n    for i in range ( n ) :\n        if ( i in hash1 and ( n - i ) in hash1 ) :\n            print ( i , \", \" , ( n - i ) )\n            return\n    print ( \"-1\" )\nif __name__ == \"__main__\" :\n    N = 90\n    findFibonacciPair ( N )\n", "python_code_tokenized": "def createHash ( hash1 , maxElement ) : NEW_LINE INDENT prev , curr = 0 , 1 NEW_LINE hash1 . add ( prev ) NEW_LINE hash1 . add ( curr ) NEW_LINE while ( curr < maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash1 . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def findFibonacciPair ( n ) : NEW_LINE INDENT hash1 = set ( ) NEW_LINE createHash ( hash1 , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i in hash1 and ( n - i ) in hash1 ) : NEW_LINE INDENT print ( i , \" , \u2581 \" , ( n - i ) ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" - 1\" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 90 NEW_LINE findFibonacciPair ( N ) NEW_LINE DEDENT"}
{"id": "codeforces_1425_A", "sol": 0, "python_code": "ans = [ ]\ndef solve ( n ) :\n    f = s = 0\n    fs = True\n    if n & 1 :\n        n -= 1\n        fs = False\n    while n :\n        if n == 4 :\n            f += 3\n            s += 1\n            n = 0\n        elif ( n // 2 ) & 1 :\n            f += n // 2\n            s += 1\n            n = ( n // 2 ) - 1 ;\n        else :\n            f += 1\n            s += 1\n            n -= 2\n    ans.append ( [ s + 1 , f ] [ fs ] )\ncoins = [ ]\nfor _ in range ( int ( input ( ) ) ) :\n    coins.append ( int ( input ( ) ) )\nfor i in coins :\n    if i == 1 :\n        ans.append ( 1 )\n    else :\n        solve ( i )\nprint ( '\\n'.join ( map ( str , ans ) ) )\n", "python_code_tokenized": "ans = [ ] NEW_LINE def solve ( n ) : NEW_LINE INDENT f = s = 0 NEW_LINE fs = True NEW_LINE if n & 1 : NEW_LINE INDENT n -= 1 NEW_LINE fs = False NEW_LINE DEDENT while n : NEW_LINE INDENT if n == 4 : NEW_LINE INDENT f += 3 NEW_LINE s += 1 NEW_LINE n = 0 NEW_LINE DEDENT elif ( n // 2 ) & 1 : NEW_LINE INDENT f += n // 2 NEW_LINE s += 1 NEW_LINE n = ( n // 2 ) - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT f += 1 NEW_LINE s += 1 NEW_LINE n -= 2 NEW_LINE DEDENT DEDENT ans . append ( [ s + 1 , f ] [ fs ] ) NEW_LINE DEDENT coins = [ ] NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT coins . append ( int ( input ( ) ) ) NEW_LINE DEDENT for i in coins : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT solve ( i ) NEW_LINE DEDENT DEDENT print ( ' \\n ' . join ( map ( str , ans ) ) ) NEW_LINE"}
{"id": "leetcode_1365_A", "sol": 0, "python_code": "class Solution :\n    def smallerNumbersThanCurrent ( self , nums : List [ int ] ) -> List [ int ] :\n        count_list = [ 0 ] * 101\n        for v in nums :\n            count_list [ v ] += 1\n        for i in range ( 1 , 101 ) :\n            count_list [ i ] += count_list [ i - 1 ]\n        res = [ ]\n        for v in nums :\n            if v == 0 :\n                res.append ( 0 )\n            else :\n                res.append ( count_list [ v - 1 ] )\n        return res\n", "python_code_tokenized": "class Solution : NEW_LINE INDENT def smallerNumbersThanCurrent ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT count_list = [ 0 ] * 101 NEW_LINE for v in nums : NEW_LINE INDENT count_list [ v ] += 1 NEW_LINE DEDENT for i in range ( 1 , 101 ) : NEW_LINE INDENT count_list [ i ] += count_list [ i - 1 ] NEW_LINE DEDENT res = [ ] NEW_LINE for v in nums : NEW_LINE INDENT if v == 0 : NEW_LINE INDENT res . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( count_list [ v - 1 ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_700_B", "sol": 0, "python_code": "( n , k ) = map ( int , input ( ).split ( ) )\ns = [ 0 ] * n\nfor i in map ( int , input ( ).split ( ) ) :\n    s [ i - 1 ] = 1\ne = [ [ ] for _ in range ( n ) ]\nfor _ in range ( n - 1 ) :\n    ( x , y ) = ( int ( s ) - 1 for s in input ( ).split ( ) )\n    e [ x ].append ( y )\n    e [ y ].append ( x )\nq = [ 0 ]\nfa = [ - 1 ] * n\nfa [ 0 ] = 0\nfor i in range ( n ) :\n    x = q [ i ]\n    for y in e [ x ] :\n        if fa [ y ] == - 1 :\n            fa [ y ] = x\n            q.append ( y )\ndp = [ 0 ] * n\nk2 = k * 2\nfor x in reversed ( q ) :\n    for y in e [ x ] :\n        if fa [ y ] == x :\n            i = s [ y ]\n            s [ x ] += i\n            dp [ x ] += dp [ y ] + ( k2 - i if i > k else i )\nprint ( dp [ 0 ] )\n", "python_code_tokenized": "( n , k ) = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ 0 ] * n NEW_LINE for i in map ( int , input ( ) . split ( ) ) : NEW_LINE INDENT s [ i - 1 ] = 1 NEW_LINE DEDENT e = [ [ ] for _ in range ( n ) ] NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT ( x , y ) = ( int ( s ) - 1 for s in input ( ) . split ( ) ) NEW_LINE e [ x ] . append ( y ) NEW_LINE e [ y ] . append ( x ) NEW_LINE DEDENT q = [ 0 ] NEW_LINE fa = [ - 1 ] * n NEW_LINE fa [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = q [ i ] NEW_LINE for y in e [ x ] : NEW_LINE INDENT if fa [ y ] == - 1 : NEW_LINE INDENT fa [ y ] = x NEW_LINE q . append ( y ) NEW_LINE DEDENT DEDENT DEDENT dp = [ 0 ] * n NEW_LINE k2 = k * 2 NEW_LINE for x in reversed ( q ) : NEW_LINE INDENT for y in e [ x ] : NEW_LINE INDENT if fa [ y ] == x : NEW_LINE INDENT i = s [ y ] NEW_LINE s [ x ] += i NEW_LINE dp [ x ] += dp [ y ] + ( k2 - i if i > k else i ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ 0 ] ) NEW_LINE"}
{"id": "leetcode_387_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def firstUniqChar ( self , s ) :\n        count_map = { }\n        for c in s :\n            count_map [ c ] = count_map.get ( c , 0 ) + 1\n        for i , c in enumerate ( s ) :\n            if count_map [ c ] == 1 :\n                return i\n        return - 1\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def firstUniqChar ( self , s ) : NEW_LINE INDENT count_map = { } NEW_LINE for c in s : NEW_LINE INDENT count_map [ c ] = count_map . get ( c , 0 ) + 1 NEW_LINE DEDENT for i , c in enumerate ( s ) : NEW_LINE INDENT if count_map [ c ] == 1 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_5275_A", "sol": 0, "python_code": "def find_idx ( ar , n ) :\n    answer = [ ] ;\n    sum = ar [ 0 ] ;\n    for i in range ( 1 , n ) :\n        if ( sum == ar [ i ] ) :\n            answer.append ( i + 1 ) ;\n        sum += ar [ i ] ;\n    return answer ;\nif __name__ == \"__main__\" :\n    ar = [ 1 , 2 , 3 , 6 , 3 , 15 , 5 ] ;\n    n = len ( ar ) ;\n    ans = find_idx ( ar , n ) ;\n    if ( len ( ans ) != 0 ) :\n        for i in ans :\n            print ( i , end = \" \" ) ;\n    else :\n        print ( \"-1\" ) ;\n    print ( ) ;\n", "python_code_tokenized": "def find_idx ( ar , n ) : NEW_LINE INDENT answer = [ ] ; NEW_LINE sum = ar [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( sum == ar [ i ] ) : NEW_LINE INDENT answer . append ( i + 1 ) ; NEW_LINE DEDENT sum += ar [ i ] ; NEW_LINE DEDENT return answer ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT ar = [ 1 , 2 , 3 , 6 , 3 , 15 , 5 ] ; NEW_LINE n = len ( ar ) ; NEW_LINE ans = find_idx ( ar , n ) ; NEW_LINE if ( len ( ans ) != 0 ) : NEW_LINE INDENT for i in ans : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3586_A", "sol": 0, "python_code": "INF = 1000000\ndef MinimumCost ( cost , n , W ) :\n    val = list ( )\n    wt = list ( )\n    size = 0\n    for i in range ( n ) :\n        if ( cost [ i ] != - 1 ) :\n            val.append ( cost [ i ] )\n            wt.append ( i + 1 )\n            size += 1\n    n = size\n    min_cost = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( W + 1 ) :\n        min_cost [ 0 ] [ i ] = INF\n    for i in range ( 1 , n + 1 ) :\n        min_cost [ i ] [ 0 ] = 0\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , W + 1 ) :\n            if ( wt [ i - 1 ] > j ) :\n                min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ]\n            else :\n                min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] )\n    if ( min_cost [ n ] [ W ] == INF ) :\n        return - 1\n    else :\n        return min_cost [ n ] [ W ]\ncost = [ 1 , 2 , 3 , 4 , 5 ]\nW = 5\nn = len ( cost )\nprint ( MinimumCost ( cost , n , W ) )\n", "python_code_tokenized": "INF = 1000000 NEW_LINE def MinimumCost ( cost , n , W ) : NEW_LINE INDENT val = list ( ) NEW_LINE wt = list ( ) NEW_LINE size = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( cost [ i ] != - 1 ) : NEW_LINE INDENT val . append ( cost [ i ] ) NEW_LINE wt . append ( i + 1 ) NEW_LINE size += 1 NEW_LINE DEDENT DEDENT n = size NEW_LINE min_cost = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( W + 1 ) : NEW_LINE INDENT min_cost [ 0 ] [ i ] = INF NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT min_cost [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , W + 1 ) : NEW_LINE INDENT if ( wt [ i - 1 ] > j ) : NEW_LINE INDENT min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if ( min_cost [ n ] [ W ] == INF ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return min_cost [ n ] [ W ] NEW_LINE DEDENT DEDENT cost = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE W = 5 NEW_LINE n = len ( cost ) NEW_LINE print ( MinimumCost ( cost , n , W ) ) NEW_LINE"}
{"id": "codeforces_670_B", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) ) ; s = input ( ).split ( )\nfor i in range ( 1 , n + 1 ) :\n    if k - i > 0 :\n        k -= i\n    else :\n        print ( s [ k - 1 ] ) ; break\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) ; s = input ( ) . split ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if k - i > 0 : NEW_LINE INDENT k -= i NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ k - 1 ] ) ; break NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1675_B", "sol": 0, "python_code": "import math\nimport copy\nfor tc in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    a = list ( map ( int , input ( ).split ( ) ) )\n    if ( a [ n - 1 ] < n - 1 ) :\n        print ( - 1 )\n        continue\n    c = 0\n    x = n - 2\n    tracker = False\n    while x >= 0 :\n        if ( a [ x ] < x ) :\n            print ( - 1 )\n            tracker = True\n            break\n        if ( a [ x + 1 ] <= a [ x ] ) :\n            y = a [ x ] // a [ x + 1 ]\n            z = int ( math.log2 ( y ) ) + 1\n            a [ x ] //= pow ( 2 , z )\n            c += z\n        else :\n            x -= 1\n    if not tracker :\n        print ( c )\n", "python_code_tokenized": "import math NEW_LINE import copy NEW_LINE for tc in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ( a [ n - 1 ] < n - 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE continue NEW_LINE DEDENT c = 0 NEW_LINE x = n - 2 NEW_LINE tracker = False NEW_LINE while x >= 0 : NEW_LINE INDENT if ( a [ x ] < x ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE tracker = True NEW_LINE break NEW_LINE DEDENT if ( a [ x + 1 ] <= a [ x ] ) : NEW_LINE INDENT y = a [ x ] // a [ x + 1 ] NEW_LINE z = int ( math . log2 ( y ) ) + 1 NEW_LINE a [ x ] //= pow ( 2 , z ) NEW_LINE c += z NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT DEDENT if not tracker : NEW_LINE INDENT print ( c ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_AGC035_A", "sol": 0, "python_code": "from collections import Counter\nn = int ( input ( ) )\nnums = [ int ( i ) for i in input ( ).split ( ) ]\nc = Counter ( nums )\nif sum ( nums ) == 0 :\n    print ( 'Yes' )\nelif len ( c ) == 2 :\n    for k , v in c.items ( ) :\n        if k == 0 :\n            if v != n // 3 :\n                print ( 'No' )\n                break\n        else :\n            if v != n // 3 * 2 :\n                print ( 'No' )\n                break\n    else :\n        print ( 'Yes' )\nelif len ( c ) == 3 :\n    t = 0\n    for k , v in c.items ( ) :\n        if v != n // 3 :\n            print ( 'No' )\n            break\n        t ^= k\n    else :\n        if t :\n            print ( 'No' )\n        else :\n            print ( 'Yes' )\nelse :\n    print ( 'No' )\n", "python_code_tokenized": "from collections import Counter NEW_LINE n = int ( input ( ) ) NEW_LINE nums = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE c = Counter ( nums ) NEW_LINE if sum ( nums ) == 0 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT elif len ( c ) == 2 : NEW_LINE INDENT for k , v in c . items ( ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT if v != n // 3 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if v != n // 3 * 2 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT DEDENT elif len ( c ) == 3 : NEW_LINE INDENT t = 0 NEW_LINE for k , v in c . items ( ) : NEW_LINE INDENT if v != n // 3 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE break NEW_LINE DEDENT t ^= k NEW_LINE DEDENT else : NEW_LINE INDENT if t : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT"}
{"id": "codeforces_433_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nfrom collections import Counter\nc = Counter ( a )\na100 = c [ 100 ]\na200 = c [ 200 ]\nrest_pair = a200 % 2\nrest_100 = a100 - 2 * rest_pair\nif rest_100 >= 0 and rest_100 % 2 == 0 :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE from collections import Counter NEW_LINE c = Counter ( a ) NEW_LINE a100 = c [ 100 ] NEW_LINE a200 = c [ 200 ] NEW_LINE rest_pair = a200 % 2 NEW_LINE rest_100 = a100 - 2 * rest_pair NEW_LINE if rest_100 >= 0 and rest_100 % 2 == 0 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4173_A", "sol": 0, "python_code": "def shortestDistance ( S , X ) :\n    prev = float ( '-inf' )\n    ans = [ ]\n    for i , j in enumerate ( S ) :\n        if j == X :\n            prev = i\n        ans.append ( i - prev )\n    prev = float ( 'inf' )\n    for i in range ( len ( S ) - 1 , - 1 , - 1 ) :\n        if S [ i ] == X :\n            prev = i\n        ans [ i ] = min ( ans [ i ] , prev - i )\n    return ans\nS = \"geeksforgeeks\"\nX = \"g\"\nprint ( shortestDistance ( S , X ) )\n", "python_code_tokenized": "def shortestDistance ( S , X ) : NEW_LINE INDENT prev = float ( ' - inf ' ) NEW_LINE ans = [ ] NEW_LINE for i , j in enumerate ( S ) : NEW_LINE INDENT if j == X : NEW_LINE INDENT prev = i NEW_LINE DEDENT ans . append ( i - prev ) NEW_LINE DEDENT prev = float ( ' inf ' ) NEW_LINE for i in range ( len ( S ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if S [ i ] == X : NEW_LINE INDENT prev = i NEW_LINE DEDENT ans [ i ] = min ( ans [ i ] , prev - i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT S = \" geeksforgeeks \" NEW_LINE X = \" g \" NEW_LINE print ( shortestDistance ( S , X ) ) NEW_LINE"}
{"id": "geeksforgeeks_1943_A", "sol": 0, "python_code": "def sum ( arr , n ) :\n    sum = 0\n    for i in arr :\n        sum += i\n    sum = sum * pow ( 2 , n - 1 )\n    return sum\narr = [ 2 , 1 , 5 , 6 ]\nn = len ( arr )\nprint ( sum ( arr , n ) )\n", "python_code_tokenized": "def sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in arr : NEW_LINE INDENT sum += i NEW_LINE DEDENT sum = sum * pow ( 2 , n - 1 ) NEW_LINE return sum NEW_LINE DEDENT arr = [ 2 , 1 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sum ( arr , n ) ) NEW_LINE"}
{"id": "aizu_p01841_A", "sol": 0, "python_code": "def parse_node ( l , r , S ) :\n    left , right = 0 , 0\n    cnt = 0\n    for i in range ( l , r + 1 ) :\n        if S [ i ] == '(' :\n            cnt += 1\n        elif S [ i ] == ')' :\n            cnt -= 1\n        elif cnt == 0 and S [ i ] == \"[\" :\n            left = i\n        elif cnt == 0 and S [ i ] == \"]\" :\n            right = i\n    return left , right\ndef parser ( l1 , r1 , l2 , r2 ) :\n    n1_l , n1_r = parse_node ( l1 , r1 , S1 )\n    n2_l , n2_r = parse_node ( l2 , r2 , S2 )\n    node = \"[{}]\".format ( int ( S1 [ n1_l + 1 : n1_r ] ) + int ( S2 [ n2_l + 1 : n2_r ] ) )\n    left_node = \"({})\".format ( \"\" if min ( n1_l - l1 , n2_l - l2 ) <= 2 else parser ( l1 + 1 , n1_l - 2 , l2 + 1 , n2_l - 2 ) )\n    right_node = \"({})\".format ( \"\" if min ( r1 - n1_r , r2 - n2_r ) <= 2 else parser ( n1_r + 2 , r1 - 1 , n2_r + 2 , r2 - 1 ) )\n    return left_node + node + right_node\nS1 , S2 = input ( ) , input ( )\nprint ( parser ( 0 , len ( S1 ) - 1 , 0 , len ( S2 ) - 1 ) )\n", "python_code_tokenized": "def parse_node ( l , r , S ) : NEW_LINE INDENT left , right = 0 , 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if S [ i ] == ' ( ' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif S [ i ] == ' ) ' : NEW_LINE INDENT cnt -= 1 NEW_LINE DEDENT elif cnt == 0 and S [ i ] == \" [ \" : NEW_LINE INDENT left = i NEW_LINE DEDENT elif cnt == 0 and S [ i ] == \" ] \" : NEW_LINE INDENT right = i NEW_LINE DEDENT DEDENT return left , right NEW_LINE DEDENT def parser ( l1 , r1 , l2 , r2 ) : NEW_LINE INDENT n1_l , n1_r = parse_node ( l1 , r1 , S1 ) NEW_LINE n2_l , n2_r = parse_node ( l2 , r2 , S2 ) NEW_LINE node = \" [ { } ] \" . format ( int ( S1 [ n1_l + 1 : n1_r ] ) + int ( S2 [ n2_l + 1 : n2_r ] ) ) NEW_LINE left_node = \" ( { } ) \" . format ( \" \" if min ( n1_l - l1 , n2_l - l2 ) <= 2 else parser ( l1 + 1 , n1_l - 2 , l2 + 1 , n2_l - 2 ) ) NEW_LINE right_node = \" ( { } ) \" . format ( \" \" if min ( r1 - n1_r , r2 - n2_r ) <= 2 else parser ( n1_r + 2 , r1 - 1 , n2_r + 2 , r2 - 1 ) ) NEW_LINE return left_node + node + right_node NEW_LINE DEDENT S1 , S2 = input ( ) , input ( ) NEW_LINE print ( parser ( 0 , len ( S1 ) - 1 , 0 , len ( S2 ) - 1 ) ) NEW_LINE"}
{"id": "geeksforgeeks_1191_A", "sol": 0, "python_code": "def minOperations ( a , n , K ) :\n    map = dict.fromkeys ( a , False ) ;\n    for i in range ( n ) :\n        if ( map [ a [ i ] ] ) :\n            return 0 ;\n        map [ a [ i ] ] = True ;\n    b = [ 0 ] * n ;\n    for i in range ( n ) :\n        b [ i ] = a [ i ] ^ K ;\n    map.clear ( ) ;\n    for i in range ( n ) :\n        if ( a [ i ] != b [ i ] ) :\n            map [ b [ i ] ] = True ;\n    for i in range ( n ) :\n        if a [ i ] in map :\n            return 1 ;\n    map.clear ( ) ;\n    for i in range ( n ) :\n        if b [ i ] in map :\n            return 2 ;\n        map [ b [ i ] ] = True ;\n    return - 1 ;\nif __name__ == \"__main__\" :\n    K = 3 ;\n    a = [ 1 , 9 , 4 , 3 ] ;\n    n = len ( a ) ;\n    print ( minOperations ( a , n , K ) ) ;\n", "python_code_tokenized": "def minOperations ( a , n , K ) : NEW_LINE INDENT map = dict . fromkeys ( a , False ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( map [ a [ i ] ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT map [ a [ i ] ] = True ; NEW_LINE DEDENT b = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = a [ i ] ^ K ; NEW_LINE DEDENT map . clear ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT map [ b [ i ] ] = True ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] in map : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT map . clear ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] in map : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT map [ b [ i ] ] = True ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT K = 3 ; NEW_LINE a = [ 1 , 9 , 4 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( minOperations ( a , n , K ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1190_A", "sol": 0, "python_code": "def minOperations ( a , n , K ) :\n    map = dict.fromkeys ( a , 0 ) ;\n    for i in range ( n ) :\n        if ( map [ a [ i ] ] ) :\n            return 0 ;\n        map [ a [ i ] ] = True ;\n    b = [ 0 ] * n ;\n    for i in range ( n ) :\n        b [ i ] = a [ i ] | K ;\n    map.clear ( ) ;\n    for i in range ( n ) :\n        if ( a [ i ] != b [ i ] ) :\n            map [ b [ i ] ] = True ;\n    for i in range ( n ) :\n        if a [ i ] not in map :\n            pass\n        elif ( map [ a [ i ] ] ) :\n            return 1 ;\n    map.clear ( ) ;\n    for i in range ( n ) :\n        if ( map [ b [ i ] ] ) :\n            return 2 ;\n        map [ b [ i ] ] = true ;\n    return - 1 ;\nif __name__ == \"__main__\" :\n    K = 3 ;\n    a = [ 1 , 9 , 4 , 3 ] ;\n    n = len ( a ) ;\n    print ( minOperations ( a , n , K ) ) ;\n", "python_code_tokenized": "def minOperations ( a , n , K ) : NEW_LINE INDENT map = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( map [ a [ i ] ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT map [ a [ i ] ] = True ; NEW_LINE DEDENT b = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = a [ i ] | K ; NEW_LINE DEDENT map . clear ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT map [ b [ i ] ] = True ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in map : NEW_LINE INDENT pass NEW_LINE DEDENT elif ( map [ a [ i ] ] ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT map . clear ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( map [ b [ i ] ] ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT map [ b [ i ] ] = true ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT K = 3 ; NEW_LINE a = [ 1 , 9 , 4 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( minOperations ( a , n , K ) ) ; NEW_LINE DEDENT"}
{"id": "aizu_p02294_A", "sol": 0, "python_code": "import sys\nEPS = 1e-9\ndef cross ( a , b ) :\n    return a.real * b.imag - a.imag * b.real\ndef dot ( a , b ) :\n    return a.real * b.real + a.imag * b.imag\ndef check_ccw ( p0 , p1 , p2 ) :\n    a , b = p1 - p0 , p2 - p0\n    if cross ( a , b ) > EPS :\n        flag = 1\n    elif cross ( a , b ) < - 1 * EPS :\n        flag = - 1\n    elif dot ( a , b ) < - 1 * EPS :\n        flag = 2\n    elif abs ( a ) < abs ( b ) :\n        flag = - 2\n    else :\n        flag = 0\n    return flag\ndef check_intersection ( p0 , p1 , p2 , p3 ) :\n    intersected = ( check_ccw ( p0 , p1 , p2 ) * check_ccw ( p0 , p1 , p3 ) <= 0 ) and ( check_ccw ( p2 , p3 , p0 ) * check_ccw ( p2 , p3 , p1 ) <= 0 )\n    return intersected\ndef solve ( _lines ) :\n    for line in _lines :\n        line = tuple ( map ( int , line ) )\n        p0 , p1 , p2 , p3 = ( x + y * 1j for x , y in zip ( line [ : : 2 ] , line [ 1 : : 2 ] ) )\n        intersected = check_intersection ( p0 , p1 , p2 , p3 )\n        if intersected :\n            print ( '1' )\n        else :\n            print ( '0' )\n    return None\nif __name__ == '__main__' :\n    _input = sys.stdin.readlines ( )\n    l_num = int ( _input [ 0 ] )\n    lines = map ( lambda x : x.split ( ) , _input [ 1 : ] )\n    solve ( lines )\n", "python_code_tokenized": "import sys NEW_LINE EPS = 1e-9 NEW_LINE def cross ( a , b ) : NEW_LINE INDENT return a . real * b . imag - a . imag * b . real NEW_LINE DEDENT def dot ( a , b ) : NEW_LINE INDENT return a . real * b . real + a . imag * b . imag NEW_LINE DEDENT def check_ccw ( p0 , p1 , p2 ) : NEW_LINE INDENT a , b = p1 - p0 , p2 - p0 NEW_LINE if cross ( a , b ) > EPS : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif cross ( a , b ) < - 1 * EPS : NEW_LINE INDENT flag = - 1 NEW_LINE DEDENT elif dot ( a , b ) < - 1 * EPS : NEW_LINE INDENT flag = 2 NEW_LINE DEDENT elif abs ( a ) < abs ( b ) : NEW_LINE INDENT flag = - 2 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT return flag NEW_LINE DEDENT def check_intersection ( p0 , p1 , p2 , p3 ) : NEW_LINE INDENT intersected = ( check_ccw ( p0 , p1 , p2 ) * check_ccw ( p0 , p1 , p3 ) <= 0 ) and ( check_ccw ( p2 , p3 , p0 ) * check_ccw ( p2 , p3 , p1 ) <= 0 ) NEW_LINE return intersected NEW_LINE DEDENT def solve ( _lines ) : NEW_LINE INDENT for line in _lines : NEW_LINE INDENT line = tuple ( map ( int , line ) ) NEW_LINE p0 , p1 , p2 , p3 = ( x + y * 1j for x , y in zip ( line [ : : 2 ] , line [ 1 : : 2 ] ) ) NEW_LINE intersected = check_intersection ( p0 , p1 , p2 , p3 ) NEW_LINE if intersected : NEW_LINE INDENT print ( '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT _input = sys . stdin . readlines ( ) NEW_LINE l_num = int ( _input [ 0 ] ) NEW_LINE lines = map ( lambda x : x . split ( ) , _input [ 1 : ] ) NEW_LINE solve ( lines ) NEW_LINE DEDENT"}
{"id": "codeforces_617_A", "sol": 0, "python_code": "n = int ( input ( ) )\nans = int ( n / 5 )\nif int ( n / 5 ) == n / 5 :\n    print ( ans )\nelse :\n    print ( ans + 1 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE ans = int ( n / 5 ) NEW_LINE if int ( n / 5 ) == n / 5 : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans + 1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3120_A", "sol": 0, "python_code": "def checkNumber ( N ) :\n    temp = N\n    while ( temp > 0 ) :\n        if ( temp % 1000 == 144 ) :\n            temp /= 1000\n        elif ( temp % 100 == 14 ) :\n            temp /= 100\n        elif ( temp % 10 == 1 ) :\n            temp /= 10\n        else :\n            return \"YES\"\n    return \"NO\"\nN = 1414 ;\nprint ( checkNumber ( N ) ) ;\n", "python_code_tokenized": "def checkNumber ( N ) : NEW_LINE INDENT temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 1000 == 144 ) : NEW_LINE INDENT temp /= 1000 NEW_LINE DEDENT elif ( temp % 100 == 14 ) : NEW_LINE INDENT temp /= 100 NEW_LINE DEDENT elif ( temp % 10 == 1 ) : NEW_LINE INDENT temp /= 10 NEW_LINE DEDENT else : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT DEDENT return \" NO \" NEW_LINE DEDENT N = 1414 ; NEW_LINE print ( checkNumber ( N ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_4740_A", "sol": 0, "python_code": "def isPowerOfTwo ( n ) :\n    return ( True if ( n > 0 and ( ( n & ( n - 1 ) ) > 0 ) ) else False ) ;\ndef findPosition ( n ) :\n    if ( isPowerOfTwo ( n ) == True ) :\n        return - 1 ;\n    i = 1 ;\n    pos = 1 ;\n    while ( ( i & n ) == 0 ) :\n        i = i << 1 ;\n        pos += 1 ;\n    return pos ;\nn = 16 ;\npos = findPosition ( n ) ;\nif ( pos == - 1 ) :\n    print ( \"n =\" , n , \", Invalid number\" ) ;\nelse :\n    print ( \"n =\" , n , \", Position \" , pos ) ;\nn = 12 ;\npos = findPosition ( n ) ;\nif ( pos == - 1 ) :\n    print ( \"n =\" , n , \", Invalid number\" ) ;\nelse :\n    print ( \"n =\" , n , \", Position \" , pos ) ;\nn = 128 ;\npos = findPosition ( n ) ;\nif ( pos == - 1 ) :\n    print ( \"n =\" , n , \", Invalid number\" ) ;\nelse :\n    print ( \"n =\" , n , \", Position \" , pos ) ;\n", "python_code_tokenized": "def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( True if ( n > 0 and ( ( n & ( n - 1 ) ) > 0 ) ) else False ) ; NEW_LINE DEDENT def findPosition ( n ) : NEW_LINE INDENT if ( isPowerOfTwo ( n ) == True ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT i = 1 ; NEW_LINE pos = 1 ; NEW_LINE while ( ( i & n ) == 0 ) : NEW_LINE INDENT i = i << 1 ; NEW_LINE pos += 1 ; NEW_LINE DEDENT return pos ; NEW_LINE DEDENT n = 16 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n \u2581 = \" , n , \" , \u2581 Invalid \u2581 number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n \u2581 = \" , n , \" , \u2581 Position \u2581 \" , pos ) ; NEW_LINE DEDENT n = 12 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n \u2581 = \" , n , \" , \u2581 Invalid \u2581 number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n \u2581 = \" , n , \" , \u2581 Position \u2581 \" , pos ) ; NEW_LINE DEDENT n = 128 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" n \u2581 = \" , n , \" , \u2581 Invalid \u2581 number \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" n \u2581 = \" , n , \" , \u2581 Position \u2581 \" , pos ) ; NEW_LINE DEDENT"}
{"id": "codeforces_987_B", "sol": 0, "python_code": "import sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\nx , y = map ( int , input ( ).split ( ) )\nif max ( x , y ) <= 8 :\n    if pow ( x , y ) < pow ( y , x ) :\n        ans = \"<\"\n    elif pow ( x , y ) > pow ( y , x ) :\n        ans = \">\"\n    else :\n        ans = \"=\"\nelse :\n    if x < y :\n        ans = \">\" if x ^ 1 else \"<\"\n    elif x > y :\n        ans = \"<\" if y ^ 1 else \">\"\n    else :\n        ans = \"=\"\nprint ( ans )\n", "python_code_tokenized": "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if max ( x , y ) <= 8 : NEW_LINE INDENT if pow ( x , y ) < pow ( y , x ) : NEW_LINE INDENT ans = \" < \" NEW_LINE DEDENT elif pow ( x , y ) > pow ( y , x ) : NEW_LINE INDENT ans = \" > \" NEW_LINE DEDENT else : NEW_LINE INDENT ans = \" = \" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if x < y : NEW_LINE INDENT ans = \" > \" if x ^ 1 else \" < \" NEW_LINE DEDENT elif x > y : NEW_LINE INDENT ans = \" < \" if y ^ 1 else \" > \" NEW_LINE DEDENT else : NEW_LINE INDENT ans = \" = \" NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "atcoder_ARC069_B", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nn = int ( input ( ) )\ns = input ( )\ndef solve ( first , second ) :\n    sheep = [ ]\n    sheep.append ( first )\n    sheep.append ( second )\n    for i in range ( 1 , n ) :\n        rep = s [ i ] == \"o\"\n        if not rep ^ sheep [ i ] :\n            sheep.append ( sheep [ i - 1 ] )\n        else :\n            sheep.append ( not sheep [ i - 1 ] )\n    if sheep [ 0 ] == sheep [ - 1 ] :\n        rep = s [ 0 ] == \"o\"\n        same = sheep [ - 2 ] == sheep [ 1 ]\n        if sheep [ 0 ] ^ rep != same :\n            for a in sheep [ : - 1 ] :\n                if a :\n                    print ( \"S\" , end = \"\" )\n                else :\n                    print ( \"W\" , end = \"\" )\n            exit ( )\nfir = [ True , False ]\nsec = [ True , False ]\nfor i in fir :\n    for j in sec :\n        solve ( i , j )\nprint ( - 1 )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE def solve ( first , second ) : NEW_LINE INDENT sheep = [ ] NEW_LINE sheep . append ( first ) NEW_LINE sheep . append ( second ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT rep = s [ i ] == \" o \" NEW_LINE if not rep ^ sheep [ i ] : NEW_LINE INDENT sheep . append ( sheep [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT sheep . append ( not sheep [ i - 1 ] ) NEW_LINE DEDENT DEDENT if sheep [ 0 ] == sheep [ - 1 ] : NEW_LINE INDENT rep = s [ 0 ] == \" o \" NEW_LINE same = sheep [ - 2 ] == sheep [ 1 ] NEW_LINE if sheep [ 0 ] ^ rep != same : NEW_LINE INDENT for a in sheep [ : - 1 ] : NEW_LINE INDENT if a : NEW_LINE INDENT print ( \" S \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" W \" , end = \" \" ) NEW_LINE DEDENT DEDENT exit ( ) NEW_LINE DEDENT DEDENT DEDENT fir = [ True , False ] NEW_LINE sec = [ True , False ] NEW_LINE for i in fir : NEW_LINE INDENT for j in sec : NEW_LINE INDENT solve ( i , j ) NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE"}
{"id": "codeforces_104_A", "sol": 0, "python_code": "points = int ( input ( ) )\ncards = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 10 , 10 , 10 , 11 ]\ncard = points - 10\nif card in cards :\n    cnt = cards.count ( card )\nif card == 10 :\n    print ( 4 * cnt - 1 )\nelse :\n    if card <= 0 or card > 11 :\n        print ( 0 )\n    else :\n        print ( 4 * cnt )\n", "python_code_tokenized": "points = int ( input ( ) ) NEW_LINE cards = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 10 , 10 , 10 , 11 ] NEW_LINE card = points - 10 NEW_LINE if card in cards : NEW_LINE INDENT cnt = cards . count ( card ) NEW_LINE DEDENT if card == 10 : NEW_LINE INDENT print ( 4 * cnt - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if card <= 0 or card > 11 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 4 * cnt ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00081_A", "sol": 0, "python_code": "from math import sqrt , atan2 , cos , sin\nwhile ( 1 ) :\n    try :\n        x1 , y1 , x2 , y2 , xq , yq = [ float ( i ) for i in input ( ).split ( \",\" ) ]\n        r = sqrt ( ( xq - x1 ) ** 2 + ( yq - y1 ) ** 2 )\n        th1 = atan2 ( y2 - y1 , x2 - x1 )\n        th2 = atan2 ( yq - y1 , xq - x1 )\n        th3 = - ( th2 - th1 ) + th1\n        print ( \"{:.6f} {:.6f}\".format ( x1 + r * cos ( th3 ) , y1 + r * sin ( th3 ) ) )\n    except EOFError :\n        break\n", "python_code_tokenized": "from math import sqrt , atan2 , cos , sin NEW_LINE while ( 1 ) : NEW_LINE INDENT try : NEW_LINE INDENT x1 , y1 , x2 , y2 , xq , yq = [ float ( i ) for i in input ( ) . split ( \" , \" ) ] NEW_LINE r = sqrt ( ( xq - x1 ) ** 2 + ( yq - y1 ) ** 2 ) NEW_LINE th1 = atan2 ( y2 - y1 , x2 - x1 ) NEW_LINE th2 = atan2 ( yq - y1 , xq - x1 ) NEW_LINE th3 = - ( th2 - th1 ) + th1 NEW_LINE print ( \" { : . 6f } \u2581 { : . 6f } \" . format ( x1 + r * cos ( th3 ) , y1 + r * sin ( th3 ) ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_441_A", "sol": 0, "python_code": "def val ( c ) :\n    if ( c >= '0' and c <= '9' ) :\n        return int ( c )\n    else :\n        return c - 'A' + 10\ndef toDeci ( strr , base ) :\n    lenn = len ( strr )\n    power = 1\n    num = 0\n    for i in range ( lenn - 1 , - 1 , - 1 ) :\n        if ( val ( strr [ i ] ) >= base ) :\n            return - 1\n        num += val ( strr [ i ] ) * power\n        power = power * base\n    return num\ndef checkCorrespond ( strr , x ) :\n    counter = 0\n    n = len ( strr )\n    for i in range ( n ) :\n        for j in range ( 2 , 37 ) :\n            if ( toDeci ( strr [ i ] , j ) == x ) :\n                counter += 1\n                break\n    if ( counter == n ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\nx = 16\nstrr = [ \"10000\" , \"20\" , \"16\" ]\ncheckCorrespond ( strr , x )\n", "python_code_tokenized": "def val ( c ) : NEW_LINE INDENT if ( c >= '0' and c <= '9' ) : NEW_LINE INDENT return int ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT return c - ' A ' + 10 NEW_LINE DEDENT DEDENT def toDeci ( strr , base ) : NEW_LINE INDENT lenn = len ( strr ) NEW_LINE power = 1 NEW_LINE num = 0 NEW_LINE for i in range ( lenn - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( val ( strr [ i ] ) >= base ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT num += val ( strr [ i ] ) * power NEW_LINE power = power * base NEW_LINE DEDENT return num NEW_LINE DEDENT def checkCorrespond ( strr , x ) : NEW_LINE INDENT counter = 0 NEW_LINE n = len ( strr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 2 , 37 ) : NEW_LINE INDENT if ( toDeci ( strr [ i ] , j ) == x ) : NEW_LINE INDENT counter += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( counter == n ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT x = 16 NEW_LINE strr = [ \"10000\" , \"20\" , \"16\" ] NEW_LINE checkCorrespond ( strr , x ) NEW_LINE"}
{"id": "geeksforgeeks_3847_A", "sol": 0, "python_code": "def printArray ( arr , n ) :\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \"\" )\ndef getMin ( arr , i , j ) :\n    minVal = arr [ i ]\n    i += 1\n    while ( i <= j ) :\n        minVal = min ( minVal , arr [ i ] )\n        i += 1\n    return minVal\ndef getMax ( arr , i , j ) :\n    maxVal = arr [ i ]\n    i += 1\n    while ( i <= j ) :\n        maxVal = max ( maxVal , arr [ i ] )\n        i += 1\n    return maxVal\ndef generateArr ( arr , n ) :\n    if ( n == 0 ) :\n        return\n    if ( n == 1 ) :\n        print ( arr [ 0 ] , end = \"\" )\n        return\n    tmpArr = [ 0 for i in range ( n ) ]\n    tmpArr [ 0 ] = getMax ( arr , 1 , n - 1 )\n    for i in range ( 1 , n - 1 ) :\n        tmpArr [ i ] = abs ( getMax ( arr , i + 1 , n - 1 ) - getMin ( arr , 0 , i - 1 ) )\n    tmpArr [ n - 1 ] = getMin ( arr , 0 , n - 2 )\n    printArray ( tmpArr , n )\narr = [ 1 , 5 , 2 , 4 , 3 ]\nn = len ( arr )\ngenerateArr ( arr , n )\n", "python_code_tokenized": "def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT def getMin ( arr , i , j ) : NEW_LINE INDENT minVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT def getMax ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT def generateArr ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( arr [ 0 ] , end = \" \" ) NEW_LINE return NEW_LINE DEDENT tmpArr = [ 0 for i in range ( n ) ] NEW_LINE tmpArr [ 0 ] = getMax ( arr , 1 , n - 1 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT tmpArr [ i ] = abs ( getMax ( arr , i + 1 , n - 1 ) - getMin ( arr , 0 , i - 1 ) ) NEW_LINE DEDENT tmpArr [ n - 1 ] = getMin ( arr , 0 , n - 2 ) NEW_LINE printArray ( tmpArr , n ) NEW_LINE DEDENT arr = [ 1 , 5 , 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_792_A", "sol": 0, "python_code": "def getSum ( n , d ) :\n    if ( n < d ) :\n        return 0\n    while ( n % 10 != d ) :\n        n -= 1\n    k = n // 10\n    return ( ( k + 1 ) * d + ( k * 10 + 10 * k * k ) // 2 )\nif __name__ == \"__main__\" :\n    n = 30\n    d = 3\n    print ( getSum ( n , d ) )\n", "python_code_tokenized": "def getSum ( n , d ) : NEW_LINE INDENT if ( n < d ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n % 10 != d ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT k = n // 10 NEW_LINE return ( ( k + 1 ) * d + ( k * 10 + 10 * k * k ) // 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 30 NEW_LINE d = 3 NEW_LINE print ( getSum ( n , d ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02282_A", "sol": 0, "python_code": "def post_from_pre_in ( preorder_elements , inorder_elements ) :\n    if preorder_elements :\n        global cnt\n        root = preorder_elements [ 0 ]\n        root_index = inorder_elements.index ( root )\n        preorder_left = preorder_elements [ 1 : root_index + 1 ]\n        inorder_left = inorder_elements [ : root_index ]\n        preorder_right = preorder_elements [ root_index + 1 : ]\n        inorder_right = inorder_elements [ root_index + 1 : ]\n        post_from_pre_in ( preorder_left , inorder_left )\n        post_from_pre_in ( preorder_right , inorder_right )\n        if cnt :\n            print ( root , end = ' ' )\n            cnt -= 1\n        else :\n            print ( root )\ncnt = int ( input ( ) ) - 1\na = list ( map ( int , input ( ).split ( ) ) )\nb = list ( map ( int , input ( ).split ( ) ) )\npost_from_pre_in ( a , b )\n", "python_code_tokenized": "def post_from_pre_in ( preorder_elements , inorder_elements ) : NEW_LINE INDENT if preorder_elements : NEW_LINE INDENT global cnt NEW_LINE root = preorder_elements [ 0 ] NEW_LINE root_index = inorder_elements . index ( root ) NEW_LINE preorder_left = preorder_elements [ 1 : root_index + 1 ] NEW_LINE inorder_left = inorder_elements [ : root_index ] NEW_LINE preorder_right = preorder_elements [ root_index + 1 : ] NEW_LINE inorder_right = inorder_elements [ root_index + 1 : ] NEW_LINE post_from_pre_in ( preorder_left , inorder_left ) NEW_LINE post_from_pre_in ( preorder_right , inorder_right ) NEW_LINE if cnt : NEW_LINE INDENT print ( root , end = ' \u2581 ' ) NEW_LINE cnt -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( root ) NEW_LINE DEDENT DEDENT DEDENT cnt = int ( input ( ) ) - 1 NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE post_from_pre_in ( a , b ) NEW_LINE"}
{"id": "geeksforgeeks_281_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    if ( a == 0 ) :\n        return b\n    return gcd ( b % a , a ) ;\ndef findPossibleDerivables ( arr , n , D , A , B ) :\n    gcdAB = gcd ( A , B )\n    counter = 0\n    for i in range ( n ) :\n        if ( ( abs ( arr [ i ] - D ) % gcdAB ) == 0 ) :\n            counter += 1\n    return counter\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 3 , 4 , 7 , 13 ]\n    n = len ( arr )\n    D , A , B = 5 , 4 , 2\n    print ( findPossibleDerivables ( arr , n , D , A , B ) )\n    a = [ 1 , 2 , 3 ]\n    n = len ( a )\n    D , A , B = 6 , 3 , 2\n    print ( findPossibleDerivables ( a , n , D , A , B ) )\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def findPossibleDerivables ( arr , n , D , A , B ) : NEW_LINE INDENT gcdAB = gcd ( A , B ) NEW_LINE counter = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( abs ( arr [ i ] - D ) % gcdAB ) == 0 ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 7 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE D , A , B = 5 , 4 , 2 NEW_LINE print ( findPossibleDerivables ( arr , n , D , A , B ) ) NEW_LINE a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE D , A , B = 6 , 3 , 2 NEW_LINE print ( findPossibleDerivables ( a , n , D , A , B ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_752_A", "sol": 0, "python_code": "def arrange ( arr , n , x ) :\n    for i in range ( 1 , n ) :\n        diff = abs ( arr [ i ] - x )\n        j = i - 1\n        if ( abs ( arr [ j ] - x ) > diff ) :\n            temp = arr [ i ]\n            while ( abs ( arr [ j ] - x ) > diff and j >= 0 ) :\n                arr [ j + 1 ] = arr [ j ]\n                j -= 1\n            arr [ j + 1 ] = temp\ndef print_1 ( arr , n ) :\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" )\nif __name__ == \"__main__\" :\n    arr = [ 10 , 5 , 3 , 9 , 2 ]\n    n = len ( arr )\n    x = 7\n    arrange ( arr , n , x )\n    print_1 ( arr , n )\n", "python_code_tokenized": "def arrange ( arr , n , x ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( arr [ i ] - x ) NEW_LINE j = i - 1 NEW_LINE if ( abs ( arr [ j ] - x ) > diff ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE while ( abs ( arr [ j ] - x ) > diff and j >= 0 ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT arr [ j + 1 ] = temp NEW_LINE DEDENT DEDENT DEDENT def print_1 ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 5 , 3 , 9 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE x = 7 NEW_LINE arrange ( arr , n , x ) NEW_LINE print_1 ( arr , n ) NEW_LINE DEDENT"}
{"id": "codeforces_169_A", "sol": 0, "python_code": "from sys import exit\ndef sort ( nums ) :\n    for i in range ( len ( nums ) - 1 ) :\n        smallnum = nums [ i + 1 ]\n        smalldex = i + 1\n        for j in range ( i , len ( nums ) ) :\n            if nums [ j ] < smallnum :\n                smallnum = nums [ j ]\n                smalldex = j\n        nums [ smalldex ] = nums [ i ]\n        nums [ i ] = smallnum\n    return nums\ninfo = input ( ).split ( )\nchorenum = int ( info [ 0 ] )\npchores = int ( info [ 1 ] )\nvchores = int ( info [ 2 ] )\nchores = input ( ).split ( )\nchores = [ int ( x ) for x in chores ]\nchores = sort ( chores )\ncomplexity = 0\nways = 0\nways = int ( chores [ vchores ] ) - int ( chores [ vchores - 1 ] )\nprint ( ways )\n", "python_code_tokenized": "from sys import exit NEW_LINE def sort ( nums ) : NEW_LINE INDENT for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT smallnum = nums [ i + 1 ] NEW_LINE smalldex = i + 1 NEW_LINE for j in range ( i , len ( nums ) ) : NEW_LINE INDENT if nums [ j ] < smallnum : NEW_LINE INDENT smallnum = nums [ j ] NEW_LINE smalldex = j NEW_LINE DEDENT DEDENT nums [ smalldex ] = nums [ i ] NEW_LINE nums [ i ] = smallnum NEW_LINE DEDENT return nums NEW_LINE DEDENT info = input ( ) . split ( ) NEW_LINE chorenum = int ( info [ 0 ] ) NEW_LINE pchores = int ( info [ 1 ] ) NEW_LINE vchores = int ( info [ 2 ] ) NEW_LINE chores = input ( ) . split ( ) NEW_LINE chores = [ int ( x ) for x in chores ] NEW_LINE chores = sort ( chores ) NEW_LINE complexity = 0 NEW_LINE ways = 0 NEW_LINE ways = int ( chores [ vchores ] ) - int ( chores [ vchores - 1 ] ) NEW_LINE print ( ways ) NEW_LINE"}
{"id": "codeforces_291_A", "sol": 0, "python_code": "n = int ( input ( ) )\nspyke = list ( map ( int , input ( ).split ( ) ) )\nd = { }\nfor x in spyke :\n    if x in d :\n        d [ x ] += 1\n    elif x != 0 :\n        d [ x ] = 1\ncount = 0\nflag = True\nfor x in d.values ( ) :\n    if x == 2 :\n        count += 1\n    elif x >= 3 :\n        print ( - 1 )\n        flag = False\n        break\nif flag :\n    print ( count )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE spyke = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for x in spyke : NEW_LINE INDENT if x in d : NEW_LINE INDENT d [ x ] += 1 NEW_LINE DEDENT elif x != 0 : NEW_LINE INDENT d [ x ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE flag = True NEW_LINE for x in d . values ( ) : NEW_LINE INDENT if x == 2 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif x >= 3 : NEW_LINE INDENT print ( - 1 ) NEW_LINE flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT"}
{"id": "codeforces_110_B", "sol": 0, "python_code": "from collections import defaultdict , deque\nfrom functools import lru_cache\nfrom heapq import heappush , heappop\nfrom bisect import bisect_right , bisect_left\nimport math\nhpop = heappop\nhpush = heappush\nMOD = 10 ** 9 + 7\ndef solution ( ) :\n    n = int ( input ( ) )\n    print ( \"abcd\" * ( n // 4 ) + \"abc\" [ : n % 4 ] )\ndef main ( ) :\n    t = 1\n    for _ in range ( t ) :\n        solution ( )\nimport sys\nimport threading\nsys.setrecursionlimit ( 1 << 30 )\nthreading.stack_size ( 1 << 27 )\nthread = threading.Thread ( target = main )\nthread.start ( ) ; thread.join ( )\n", "python_code_tokenized": "from collections import defaultdict , deque NEW_LINE from functools import lru_cache NEW_LINE from heapq import heappush , heappop NEW_LINE from bisect import bisect_right , bisect_left NEW_LINE import math NEW_LINE hpop = heappop NEW_LINE hpush = heappush NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def solution ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( \" abcd \" * ( n // 4 ) + \" abc \" [ : n % 4 ] ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = 1 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT solution ( ) NEW_LINE DEDENT DEDENT import sys NEW_LINE import threading NEW_LINE sys . setrecursionlimit ( 1 << 30 ) NEW_LINE threading . stack_size ( 1 << 27 ) NEW_LINE thread = threading . Thread ( target = main ) NEW_LINE thread . start ( ) ; thread . join ( ) NEW_LINE"}
{"id": "geeksforgeeks_3555_A", "sol": 0, "python_code": "import numpy as np\nn = 3\ndp = np.zeros ( ( n , n ) )\nv = np.zeros ( ( n , n ) ) ;\ndef minSteps ( i , j , arr ) :\n    if ( i == n - 1 and j == n - 1 ) :\n        return 0 ;\n    if ( i > n - 1 or j > n - 1 ) :\n        return 9999999 ;\n    if ( v [ i ] [ j ] ) :\n        return dp [ i ] [ j ] ;\n    v [ i ] [ j ] = 1 ;\n    dp [ i ] [ j ] = 9999999 ;\n    for k in range ( max ( 0 , arr [ i ] [ j ] + j - n + 1 ) , min ( n - i - 1 , arr [ i ] [ j ] ) + 1 ) :\n        dp [ i ] [ j ] = min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ;\n    dp [ i ] [ j ] += 1 ;\n    return dp [ i ] [ j ] ;\nif __name__ == \"__main__\" :\n    arr = [ [ 4 , 1 , 2 ] , [ 1 , 1 , 1 ] , [ 2 , 1 , 1 ] ] ;\n    ans = minSteps ( 0 , 0 , arr ) ;\n    if ( ans >= 9999999 ) :\n        print ( - 1 ) ;\n    else :\n        print ( ans ) ;\n", "python_code_tokenized": "import numpy as np NEW_LINE n = 3 NEW_LINE dp = np . zeros ( ( n , n ) ) NEW_LINE v = np . zeros ( ( n , n ) ) ; NEW_LINE def minSteps ( i , j , arr ) : NEW_LINE INDENT if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( i > n - 1 or j > n - 1 ) : NEW_LINE INDENT return 9999999 ; NEW_LINE DEDENT if ( v [ i ] [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] ; NEW_LINE DEDENT v [ i ] [ j ] = 1 ; NEW_LINE dp [ i ] [ j ] = 9999999 ; NEW_LINE for k in range ( max ( 0 , arr [ i ] [ j ] + j - n + 1 ) , min ( n - i - 1 , arr [ i ] [ j ] ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ; NEW_LINE DEDENT dp [ i ] [ j ] += 1 ; NEW_LINE return dp [ i ] [ j ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 4 , 1 , 2 ] , [ 1 , 1 , 1 ] , [ 2 , 1 , 1 ] ] ; NEW_LINE ans = minSteps ( 0 , 0 , arr ) ; NEW_LINE if ( ans >= 9999999 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) ; NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3556_A", "sol": 0, "python_code": "import numpy as np ;\nn = 3\ndp = np.zeros ( ( n , n ) ) ;\nv = np.zeros ( ( n , n ) ) ;\ndef minSteps ( i , j , arr ) :\n    if ( i == n - 1 and j == n - 1 ) :\n        return 0 ;\n    if ( i > n - 1 or j > n - 1 ) :\n        return 9999999 ;\n    if ( v [ i ] [ j ] ) :\n        return dp [ i ] [ j ] ;\n    v [ i ] [ j ] = 1 ;\n    dp [ i ] [ j ] = 1 + min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ;\n    return dp [ i ] [ j ] ;\narr = [ [ 2 , 1 , 2 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] ;\nans = minSteps ( 0 , 0 , arr ) ;\nif ( ans >= 9999999 ) :\n    print ( - 1 ) ;\nelse :\n    print ( ans ) ;\n", "python_code_tokenized": "import numpy as np ; NEW_LINE n = 3 NEW_LINE dp = np . zeros ( ( n , n ) ) ; NEW_LINE v = np . zeros ( ( n , n ) ) ; NEW_LINE def minSteps ( i , j , arr ) : NEW_LINE INDENT if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( i > n - 1 or j > n - 1 ) : NEW_LINE INDENT return 9999999 ; NEW_LINE DEDENT if ( v [ i ] [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] ; NEW_LINE DEDENT v [ i ] [ j ] = 1 ; NEW_LINE dp [ i ] [ j ] = 1 + min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ; NEW_LINE return dp [ i ] [ j ] ; NEW_LINE DEDENT arr = [ [ 2 , 1 , 2 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] ; NEW_LINE ans = minSteps ( 0 , 0 , arr ) ; NEW_LINE if ( ans >= 9999999 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) ; NEW_LINE DEDENT"}
{"id": "atcoder_AGC010_D", "sol": 0, "python_code": "import sys\ndef I ( ) : return int ( sys.stdin.readline ( ).rstrip ( ) )\ndef LI ( ) : return list ( map ( int , sys.stdin.readline ( ).rstrip ( ).split ( ) ) )\nN = I ( )\nA = LI ( )\nif N == 1 :\n    print ( 'Second' )\n    exit ( )\nif N == 2 :\n    print ( 'First' )\n    exit ( )\nfrom math import gcd\nr = 0\nwhile True :\n    if ( sum ( A ) - N ) % 2 == 1 :\n        if r == 0 :\n            print ( 'First' )\n        else :\n            print ( 'Second' )\n        break\n    else :\n        a = 0\n        b = 0\n        for i in range ( N ) :\n            if A [ i ] % 2 == 1 :\n                a += 1\n            if A [ i ] == 1 :\n                b += 1\n        if a != 1 or b > 0 :\n            if r == 0 :\n                print ( 'Second' )\n            else :\n                print ( 'First' )\n            break\n        else :\n            g = 0\n            for i in range ( N ) :\n                if A [ i ] % 2 == 1 :\n                    g = gcd ( g , A [ i ] - 1 )\n                else :\n                    g = gcd ( g , A [ i ] )\n            for i in range ( N ) :\n                A [ i ] = A [ i ] // g\n            r = 1 - r\n", "python_code_tokenized": "import sys NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) NEW_LINE N = I ( ) NEW_LINE A = LI ( ) NEW_LINE if N == 1 : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE exit ( ) NEW_LINE DEDENT if N == 2 : NEW_LINE INDENT print ( ' First ' ) NEW_LINE exit ( ) NEW_LINE DEDENT from math import gcd NEW_LINE r = 0 NEW_LINE while True : NEW_LINE INDENT if ( sum ( A ) - N ) % 2 == 1 : NEW_LINE INDENT if r == 0 : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE DEDENT break NEW_LINE DEDENT else : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] % 2 == 1 : NEW_LINE INDENT a += 1 NEW_LINE DEDENT if A [ i ] == 1 : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT if a != 1 or b > 0 : NEW_LINE INDENT if r == 0 : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT break NEW_LINE DEDENT else : NEW_LINE INDENT g = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] % 2 == 1 : NEW_LINE INDENT g = gcd ( g , A [ i ] - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT g = gcd ( g , A [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT A [ i ] = A [ i ] // g NEW_LINE DEDENT r = 1 - r NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "aizu_p00515_A", "sol": 0, "python_code": "s = 0\nfor i in range ( 5 ) :\n    a = int ( input ( ) )\n    if a < 40 :\n        a = 40\n    s += a\nprint ( s // 5 )\n", "python_code_tokenized": "s = 0 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE if a < 40 : NEW_LINE INDENT a = 40 NEW_LINE DEDENT s += a NEW_LINE DEDENT print ( s // 5 ) NEW_LINE"}
{"id": "geeksforgeeks_3635_A", "sol": 0, "python_code": "MAX = 10 ;\ndef binomialCoeff ( C , n , k ) :\n    for i in range ( n + 1 ) :\n        for j in range ( 0 , min ( i , k ) + 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1 ;\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ;\ndef countParallelogram ( n , m ) :\n    C = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ]\n    binomialCoeff ( C , max ( n , m ) , 2 ) ;\n    return C [ n ] [ 2 ] * C [ m ] [ 2 ] ;\nif __name__ == '__main__' :\n    n = 5 ;\n    m = 5 ;\n    print ( countParallelogram ( n , m ) ) ;\n", "python_code_tokenized": "MAX = 10 ; NEW_LINE def binomialCoeff ( C , n , k ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def countParallelogram ( n , m ) : NEW_LINE INDENT C = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE binomialCoeff ( C , max ( n , m ) , 2 ) ; NEW_LINE return C [ n ] [ 2 ] * C [ m ] [ 2 ] ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE m = 5 ; NEW_LINE print ( countParallelogram ( n , m ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_903_A", "sol": 0, "python_code": "import math as mt\ndef countPairs ( arr , n ) :\n    count = 0\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            if arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] :\n                count += 1\n    return count\narr = [ 5 , 0 , 3 , 1 , 2 ]\nn = len ( arr )\nprint ( countPairs ( arr , n ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 5 , 0 , 3 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4968_A", "sol": 0, "python_code": "import math as mt\nMAX = 100001\nisPrime = [ 0 for i in range ( MAX ) ]\ndef sieve ( ) :\n    for p in range ( 2 , mt.ceil ( mt.sqrt ( MAX ) ) ) :\n        if ( isPrime [ p ] == 0 ) :\n            for i in range ( 2 * p , MAX , p ) :\n                isPrime [ i ] = 1\ndef findSubset ( a , n ) :\n    cnt1 = 0\n    for i in range ( n ) :\n        if ( a [ i ] == 1 ) :\n            cnt1 += 1\n    if ( cnt1 > 0 ) :\n        for i in range ( n ) :\n            if ( ( a [ i ] != 1 ) and ( isPrime [ a [ i ] + 1 ] == 0 ) ) :\n                print ( cnt1 + 1 )\n                for j in range ( cnt1 ) :\n                    print ( \"1\" , end = \" \" )\n                print ( a [ i ] )\n                return 0\n    if ( cnt1 >= 2 ) :\n        print ( cnt1 )\n        for i in range ( cnt1 ) :\n            print ( \"1\" , end = \" \" )\n        print ( \"\\n\" )\n        return 0\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            if ( isPrime [ a [ i ] + a [ j ] ] == 0 ) :\n                print ( 2 )\n                print ( a [ i ] , \" \" , a [ j ] )\n    print ( - 1 )\nsieve ( )\nA = [ 2 , 1 , 1 ]\nn = len ( A )\nfindSubset ( A , n )\n", "python_code_tokenized": "import math as mt NEW_LINE MAX = 100001 NEW_LINE isPrime = [ 0 for i in range ( MAX ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for p in range ( 2 , mt . ceil ( mt . sqrt ( MAX ) ) ) : NEW_LINE INDENT if ( isPrime [ p ] == 0 ) : NEW_LINE INDENT for i in range ( 2 * p , MAX , p ) : NEW_LINE INDENT isPrime [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def findSubset ( a , n ) : NEW_LINE INDENT cnt1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT DEDENT if ( cnt1 > 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] != 1 ) and ( isPrime [ a [ i ] + 1 ] == 0 ) ) : NEW_LINE INDENT print ( cnt1 + 1 ) NEW_LINE for j in range ( cnt1 ) : NEW_LINE INDENT print ( \"1\" , end = \" \u2581 \" ) NEW_LINE DEDENT print ( a [ i ] ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT DEDENT if ( cnt1 >= 2 ) : NEW_LINE INDENT print ( cnt1 ) NEW_LINE for i in range ( cnt1 ) : NEW_LINE INDENT print ( \"1\" , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \\n \" ) NEW_LINE return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( isPrime [ a [ i ] + a [ j ] ] == 0 ) : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( a [ i ] , \" \u2581 \" , a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT sieve ( ) NEW_LINE A = [ 2 , 1 , 1 ] NEW_LINE n = len ( A ) NEW_LINE findSubset ( A , n ) NEW_LINE"}
{"id": "geeksforgeeks_273_A", "sol": 0, "python_code": "MAX = 100001\nperfectDiv = [ 0 ] * MAX\ndef precomputeCounts ( ) :\n    i = 1\n    while i * i < MAX :\n        for j in range ( i * i , MAX , i * i ) :\n            perfectDiv [ j ] += 1\n        i += 1\ndef countPerfectDivisors ( n ) :\n    return perfectDiv [ n ]\nif __name__ == \"__main__\" :\n    precomputeCounts ( )\n    n = 16\n    print ( \"Total perfect divisors of \" , n , \" = \" , countPerfectDivisors ( n ) )\n    n = 12\n    print ( \"Total perfect divisors of \" , n , \" = \" , countPerfectDivisors ( n ) )\n", "python_code_tokenized": "MAX = 100001 NEW_LINE perfectDiv = [ 0 ] * MAX NEW_LINE def precomputeCounts ( ) : NEW_LINE INDENT i = 1 NEW_LINE while i * i < MAX : NEW_LINE INDENT for j in range ( i * i , MAX , i * i ) : NEW_LINE INDENT perfectDiv [ j ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT def countPerfectDivisors ( n ) : NEW_LINE INDENT return perfectDiv [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT precomputeCounts ( ) NEW_LINE n = 16 NEW_LINE print ( \" Total \u2581 perfect \u2581 divisors \u2581 of \u2581 \" , n , \" \u2581 = \u2581 \" , countPerfectDivisors ( n ) ) NEW_LINE n = 12 NEW_LINE print ( \" Total \u2581 perfect \u2581 divisors \u2581 of \u2581 \" , n , \" \u2581 = \u2581 \" , countPerfectDivisors ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3078_A", "sol": 0, "python_code": "import math\ndef calculateDivisors ( A , B ) :\n    N = A - B\n    noOfDivisors = 0\n    a = math.sqrt ( N )\n    for i in range ( 1 , int ( a + 1 ) ) :\n        if ( ( N % i == 0 ) ) :\n            if ( i > B ) :\n                noOfDivisors += 1\n            if ( ( N / i ) != i and ( N / i ) > B ) :\n                noOfDivisors += 1 ;\n    return noOfDivisors\ndef numberOfPossibleWaysUtil ( A , B ) :\n    if ( A == B ) :\n        return - 1\n    if ( A < B ) :\n        return 0\n    noOfDivisors = 0\n    noOfDivisors = calculateDivisors ;\n    return noOfDivisors\ndef numberOfPossibleWays ( A , B ) :\n    noOfSolutions = numberOfPossibleWaysUtil ( A , B )\n    if ( noOfSolutions == - 1 ) :\n        print ( \"For A = \" , A , \" and B = \" , B , \", X can take Infinitely many values\" , \" greater than \" , A )\n    else :\n        print ( \"For A = \" , A , \" and B = \" , B , \", X can take \" , noOfSolutions , \" values\" )\nA = 26\nB = 2\nnumberOfPossibleWays ( A , B )\nA = 21\nB = 5\nnumberOfPossibleWays ( A , B )\n", "python_code_tokenized": "import math NEW_LINE def calculateDivisors ( A , B ) : NEW_LINE INDENT N = A - B NEW_LINE noOfDivisors = 0 NEW_LINE a = math . sqrt ( N ) NEW_LINE for i in range ( 1 , int ( a + 1 ) ) : NEW_LINE INDENT if ( ( N % i == 0 ) ) : NEW_LINE INDENT if ( i > B ) : NEW_LINE INDENT noOfDivisors += 1 NEW_LINE DEDENT if ( ( N / i ) != i and ( N / i ) > B ) : NEW_LINE INDENT noOfDivisors += 1 ; NEW_LINE DEDENT DEDENT DEDENT return noOfDivisors NEW_LINE DEDENT def numberOfPossibleWaysUtil ( A , B ) : NEW_LINE INDENT if ( A == B ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( A < B ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT noOfDivisors = 0 NEW_LINE noOfDivisors = calculateDivisors ; NEW_LINE return noOfDivisors NEW_LINE DEDENT def numberOfPossibleWays ( A , B ) : NEW_LINE INDENT noOfSolutions = numberOfPossibleWaysUtil ( A , B ) NEW_LINE if ( noOfSolutions == - 1 ) : NEW_LINE INDENT print ( \" For \u2581 A \u2581 = \u2581 \" , A , \" \u2581 and \u2581 B \u2581 = \u2581 \" , B , \" , \u2581 X \u2581 can \u2581 take \u2581 Infinitely \u2581 many \u2581 values \" , \" \u2581 greater \u2581 than \u2581 \" , A ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" For \u2581 A \u2581 = \u2581 \" , A , \" \u2581 and \u2581 B \u2581 = \u2581 \" , B , \" , \u2581 X \u2581 can \u2581 take \u2581 \" , noOfSolutions , \" \u2581 values \" ) NEW_LINE DEDENT DEDENT A = 26 NEW_LINE B = 2 NEW_LINE numberOfPossibleWays ( A , B ) NEW_LINE A = 21 NEW_LINE B = 5 NEW_LINE numberOfPossibleWays ( A , B ) NEW_LINE"}
{"id": "codeforces_1463_A", "sol": 0, "python_code": "for i in range ( int ( input ( ) ) ) :\n    a , b , c = map ( int , input ( ).split ( ) )\n    if ( a + b + c ) % 9 != 0 :\n        print ( \"NO\" )\n    else :\n        print ( \"YES\" if min ( a , b , c ) >= ( a + b + c ) // 9 else \"NO\" )\n", "python_code_tokenized": "for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a + b + c ) % 9 != 0 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" if min ( a , b , c ) >= ( a + b + c ) // 9 else \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_5200_A", "sol": 0, "python_code": "def numberOfPainters ( arr , n , maxLen ) :\n    total = 0\n    numPainters = 1\n    for i in arr :\n        total += i\n        if ( total > maxLen ) :\n            total = i\n            numPainters += 1\n    return numPainters\ndef partition ( arr , n , k ) :\n    lo = max ( arr )\n    hi = sum ( arr )\n    while ( lo < hi ) :\n        mid = lo + ( hi - lo ) / 2\n        requiredPainters = numberOfPainters ( arr , n , mid )\n        if ( requiredPainters <= k ) :\n            hi = mid\n        else :\n            lo = mid + 1\n    return lo\narr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]\nn = len ( arr )\nk = 3\nprint ( int ( partition ( arr , n , k ) ) )\n", "python_code_tokenized": "def numberOfPainters ( arr , n , maxLen ) : NEW_LINE INDENT total = 0 NEW_LINE numPainters = 1 NEW_LINE for i in arr : NEW_LINE INDENT total += i NEW_LINE if ( total > maxLen ) : NEW_LINE INDENT total = i NEW_LINE numPainters += 1 NEW_LINE DEDENT DEDENT return numPainters NEW_LINE DEDENT def partition ( arr , n , k ) : NEW_LINE INDENT lo = max ( arr ) NEW_LINE hi = sum ( arr ) NEW_LINE while ( lo < hi ) : NEW_LINE INDENT mid = lo + ( hi - lo ) / 2 NEW_LINE requiredPainters = numberOfPainters ( arr , n , mid ) NEW_LINE if ( requiredPainters <= k ) : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT return lo NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( int ( partition ( arr , n , k ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_4254_A", "sol": 0, "python_code": "def uniqueRows ( s , m , n ) :\n    i , j , count = 0 , 0 , 0\n    for i in range ( n ) :\n        for j in range ( i ) :\n            if ( s [ i ] == s [ j ] ) :\n                count += 1\n                break\n    if ( count >= 1 ) :\n        print ( \"No\" )\n    else :\n        print ( \"Yes\" )\nm = 3\nn = 3\ns = [ [ 1 , 0 , 1 ] , [ 0 , 0 , 0 ] , [ 1 , 0 , 0 ] ]\nuniqueRows ( s , m , n )\n", "python_code_tokenized": "def uniqueRows ( s , m , n ) : NEW_LINE INDENT i , j , count = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( count >= 1 ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT DEDENT m = 3 NEW_LINE n = 3 NEW_LINE s = [ [ 1 , 0 , 1 ] , [ 0 , 0 , 0 ] , [ 1 , 0 , 0 ] ] NEW_LINE uniqueRows ( s , m , n ) NEW_LINE"}
{"id": "geeksforgeeks_4807_A", "sol": 0, "python_code": "def isPowerOfTwo ( x ) :\n    if ( x == 0 ) :\n        return False\n    if ( ( x & ( x - 1 ) ) == 0 ) :\n        return True\n    else :\n        return False\ndef countNum ( a , n ) :\n    count = 0\n    for i in range ( 0 , n , 1 ) :\n        if ( isPowerOfTwo ( a [ i ] ) or isPowerOfTwo ( a [ i ] + 1 ) ) :\n            count += 1\n    return count\nif __name__ == '__main__' :\n    arr = [ 5 , 6 , 9 , 3 , 1 ]\n    n = len ( arr )\n    print ( countNum ( arr , n ) )\n", "python_code_tokenized": "def isPowerOfTwo ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( x & ( x - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def countNum ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( isPowerOfTwo ( a [ i ] ) or isPowerOfTwo ( a [ i ] + 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 9 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC118_D", "sol": 0, "python_code": "if __name__ == \"__main__\" :\n    l = [ 0 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ]\n    n , m = list ( map ( int , input ( ).split ( ) ) )\n    a = list ( map ( int , input ( ).split ( ) ) )\n    res = ''\n    INF = 10 ** 4\n    dp = [ [ 0 , 0 ] for i in range ( n + 1 ) ]\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if dp [ i ] [ 1 ] + l [ a [ j ] ] != i + l [ a [ j ] ] or i + l [ a [ j ] ] > n :\n                pass\n            else :\n                dp [ i + l [ a [ j ] ] ] [ 0 ] = max ( dp [ i ] [ 0 ] + 1 , dp [ i + l [ a [ j ] ] ] [ 0 ] )\n                dp [ i + l [ a [ j ] ] ] [ 1 ] = dp [ i ] [ 1 ] + l [ a [ j ] ]\n    for i in range ( 1 , n ) : dp [ i ] [ 0 ] = - INF if dp [ i ] [ 0 ] == 0 else dp [ i ] [ 0 ]\n    a.sort ( reverse = True )\n    i = n\n    while i > 0 :\n        for j in range ( m ) :\n            if i >= l [ a [ j ] ] and dp [ i - l [ a [ j ] ] ] [ 0 ] + 1 == dp [ i ] [ 0 ] :\n                res += str ( a [ j ] )\n                i -= l [ a [ j ] ]\n                break\n            else :\n                pass\n    print ( res )\n", "python_code_tokenized": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = [ 0 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] NEW_LINE n , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE res = ' ' NEW_LINE INF = 10 ** 4 NEW_LINE dp = [ [ 0 , 0 ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if dp [ i ] [ 1 ] + l [ a [ j ] ] != i + l [ a [ j ] ] or i + l [ a [ j ] ] > n : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + l [ a [ j ] ] ] [ 0 ] = max ( dp [ i ] [ 0 ] + 1 , dp [ i + l [ a [ j ] ] ] [ 0 ] ) NEW_LINE dp [ i + l [ a [ j ] ] ] [ 1 ] = dp [ i ] [ 1 ] + l [ a [ j ] ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n ) : dp [ i ] [ 0 ] = - INF if dp [ i ] [ 0 ] == 0 else dp [ i ] [ 0 ] NEW_LINE a . sort ( reverse = True ) NEW_LINE i = n NEW_LINE while i > 0 : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if i >= l [ a [ j ] ] and dp [ i - l [ a [ j ] ] ] [ 0 ] + 1 == dp [ i ] [ 0 ] : NEW_LINE INDENT res += str ( a [ j ] ) NEW_LINE i -= l [ a [ j ] ] NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_865_A", "sol": 0, "python_code": "def isPerfectSquare ( arr , n ) :\n    umap = dict.fromkeys ( arr , n ) ;\n    for key in arr :\n        umap [ key ] += 1 ;\n    for key in arr :\n        if ( umap [ key ] % 2 == 1 ) :\n            return False ;\n    return True ;\nif __name__ == \"__main__\" :\n    arr = [ 2 , 2 , 7 , 7 ] ;\n    n = len ( arr )\n    if ( isPerfectSquare ( arr , n ) ) :\n        print ( \"Yes\" ) ;\n    else :\n        print ( \"No\" ) ;\n", "python_code_tokenized": "def isPerfectSquare ( arr , n ) : NEW_LINE INDENT umap = dict . fromkeys ( arr , n ) ; NEW_LINE for key in arr : NEW_LINE INDENT umap [ key ] += 1 ; NEW_LINE DEDENT for key in arr : NEW_LINE INDENT if ( umap [ key ] % 2 == 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 2 , 7 , 7 ] ; NEW_LINE n = len ( arr ) NEW_LINE if ( isPerfectSquare ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4595_A", "sol": 0, "python_code": "def longestFibonacciSubarray ( n , a ) :\n    if ( n <= 2 ) :\n        return n\n    Len = 2\n    mx = - 10 ** 9\n    for i in range ( 2 , n ) :\n        if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) :\n            Len += 1\n        else :\n            Len = 2\n        mx = max ( mx , Len )\n    return mx\nn = 5\na = [ 2 , 4 , 6 , 10 , 2 ]\nprint ( longestFibonacciSubarray ( n , a ) )\n", "python_code_tokenized": "def longestFibonacciSubarray ( n , a ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT Len = 2 NEW_LINE mx = - 10 ** 9 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) : NEW_LINE INDENT Len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Len = 2 NEW_LINE DEDENT mx = max ( mx , Len ) NEW_LINE DEDENT return mx NEW_LINE DEDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE print ( longestFibonacciSubarray ( n , a ) ) NEW_LINE"}
{"id": "geeksforgeeks_3977_A", "sol": 0, "python_code": "def constructLowerArray ( arr , countSmaller , n ) :\n    for i in range ( n ) :\n        countSmaller [ i ] = 0 ;\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            if ( arr [ j ] < arr [ i ] ) :\n                countSmaller [ i ] += 1\ndef printArray ( arr , size ) :\n    for i in range ( size ) :\n        print ( arr [ i ] , end = \" \" )\n    print ( )\narr = [ 12 , 10 , 5 , 4 , 2 , 20 , 6 , 1 , 0 , 2 ]\nn = len ( arr )\nlow = [ 0 ] * n\nconstructLowerArray ( arr , low , n )\nprintArray ( low , n )\n", "python_code_tokenized": "def constructLowerArray ( arr , countSmaller , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT countSmaller [ i ] = 0 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] ) : NEW_LINE INDENT countSmaller [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 12 , 10 , 5 , 4 , 2 , 20 , 6 , 1 , 0 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE low = [ 0 ] * n NEW_LINE constructLowerArray ( arr , low , n ) NEW_LINE printArray ( low , n ) NEW_LINE"}
{"id": "leetcode_011_A", "sol": 0, "python_code": "class Solution :\n    def maxArea ( self , height : List [ int ] ) -> int :\n        left , right = 0 , len ( height ) - 1\n        result = 0\n        while left < right :\n            result = max ( min ( height [ left ] , height [ right ] ) * ( right - left ) , result )\n            if height [ left ] > height [ right ] :\n                right -= 1\n            else :\n                left += 1\n        return result\n", "python_code_tokenized": "class Solution : NEW_LINE INDENT def maxArea ( self , height : List [ int ] ) -> int : NEW_LINE INDENT left , right = 0 , len ( height ) - 1 NEW_LINE result = 0 NEW_LINE while left < right : NEW_LINE INDENT result = max ( min ( height [ left ] , height [ right ] ) * ( right - left ) , result ) NEW_LINE if height [ left ] > height [ right ] : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT left += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2866_A", "sol": 0, "python_code": "def CountPS ( str , n ) :\n    dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    P = [ [ False for x in range ( n ) ] for y in range ( n ) ]\n    for i in range ( n ) :\n        P [ i ] [ i ] = True\n    for i in range ( n - 1 ) :\n        if ( str [ i ] == str [ i + 1 ] ) :\n            P [ i ] [ i + 1 ] = True\n            dp [ i ] [ i + 1 ] = 1\n    for gap in range ( 2 , n ) :\n        for i in range ( n - gap ) :\n            j = gap + i ;\n            if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) :\n                P [ i ] [ j ] = True\n            if ( P [ i ] [ j ] == True ) :\n                dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] )\n            else :\n                dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] )\n    return dp [ 0 ] [ n - 1 ]\nif __name__ == \"__main__\" :\n    str = \"abaab\"\n    n = len ( str )\n    print ( CountPS ( str , n ) )\n", "python_code_tokenized": "def CountPS ( str , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE P = [ [ False for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT P [ i ] [ i + 1 ] = True NEW_LINE dp [ i ] [ i + 1 ] = 1 NEW_LINE DEDENT DEDENT for gap in range ( 2 , n ) : NEW_LINE INDENT for i in range ( n - gap ) : NEW_LINE INDENT j = gap + i ; NEW_LINE if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) : NEW_LINE INDENT P [ i ] [ j ] = True NEW_LINE DEDENT if ( P [ i ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" abaab \" NEW_LINE n = len ( str ) NEW_LINE print ( CountPS ( str , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1392_A", "sol": 0, "python_code": "import math\ndef divide ( n , m ) :\n    print ( \"Remainder = \" , ( ( n ) & ( m - 1 ) ) )\n    print ( \"Quotient = \" , ( n >> ( int ) ( math.log2 ( m ) ) ) )\nn = 43\nm = 8\ndivide ( n , m )\n", "python_code_tokenized": "import math NEW_LINE def divide ( n , m ) : NEW_LINE INDENT print ( \" Remainder \u2581 = \u2581 \" , ( ( n ) & ( m - 1 ) ) ) NEW_LINE print ( \" Quotient \u2581 = \u2581 \" , ( n >> ( int ) ( math . log2 ( m ) ) ) ) NEW_LINE DEDENT n = 43 NEW_LINE m = 8 NEW_LINE divide ( n , m ) NEW_LINE"}
{"id": "geeksforgeeks_24_A", "sol": 0, "python_code": "def product_subarrays ( arr , n ) :\n    product = 1 ;\n    for i in range ( n ) :\n        for j in range ( i , n ) :\n            product *= arr [ j ] ;\n    print ( product ) ;\nif __name__ == '__main__' :\n    arr = [ 10 , 3 , 7 ] ;\n    n = len ( arr ) ;\n    product_subarrays ( arr , n ) ;\n", "python_code_tokenized": "def product_subarrays ( arr , n ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT product *= arr [ j ] ; NEW_LINE DEDENT DEDENT print ( product ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 3 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE product_subarrays ( arr , n ) ; NEW_LINE DEDENT"}
{"id": "codeforces_598_A", "sol": 0, "python_code": "import math\ntest_case = int ( input ( ) )\nwhile test_case :\n    n = int ( input ( ) )\n    sum = n * ( n + 1 ) // 2\n    i = 1\n    while i <= n :\n        sum -= i * 2\n        i *= 2\n    print ( int ( sum ) )\n    test_case -= 1\n", "python_code_tokenized": "import math NEW_LINE test_case = int ( input ( ) ) NEW_LINE while test_case : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE sum = n * ( n + 1 ) // 2 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT sum -= i * 2 NEW_LINE i *= 2 NEW_LINE DEDENT print ( int ( sum ) ) NEW_LINE test_case -= 1 NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4452_A", "sol": 0, "python_code": "def isVowel ( c ) :\n    if ( c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' ) :\n        return True\n    return False\ndef isVowelPrime ( Str , n ) :\n    prime = [ True for i in range ( n ) ]\n    prime [ 0 ] = False\n    prime [ 1 ] = False\n    for p in range ( 2 , n ) :\n        if p * p > n :\n            break\n        if ( prime [ p ] == True ) :\n            for i in range ( 2 * p , n , p ) :\n                prime [ i ] = False\n    for i in range ( n ) :\n        if ( isVowel ( Str [ i ] ) and prime [ i ] == False ) :\n            return False\n    return True\nStr = \"geeksforgeeks\" ;\nn = len ( Str )\nif ( isVowelPrime ( Str , n ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isVowelPrime ( Str , n ) : NEW_LINE INDENT prime = [ True for i in range ( n ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , n ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( isVowel ( Str [ i ] ) and prime [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT Str = \" geeksforgeeks \" ; NEW_LINE n = len ( Str ) NEW_LINE if ( isVowelPrime ( Str , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4040_A", "sol": 0, "python_code": "def binarySearch ( arr , low , high ) :\n    if ( high < low ) :\n        return - 1\n    mid = int ( ( low + high ) / 2 )\n    midValue = arr [ mid ]\n    if ( mid == arr [ mid ] ) :\n        return mid\n    leftindex = min ( mid - 1 , midValue )\n    left = binarySearch ( arr , low , leftindex )\n    if ( left >= 0 ) :\n        return left\n    rightindex = max ( mid + 1 , midValue )\n    right = binarySearch ( arr , rightindex , high )\n    return right\nif __name__ == '__main__' :\n    arr = [ - 10 , - 5 , 2 , 2 , 2 , 3 , 4 , 7 , 9 , 12 , 13 ]\n    n = len ( arr )\n    print ( \"Fixed Point is\" , binarySearch ( arr , 0 , n - 1 ) )\n    arr1 = [ - 10 , - 1 , 3 , 3 , 10 , 30 , 30 , 50 , 100 ]\n    n1 = len ( arr )\n    print ( \"Fixed Point is\" , binarySearch ( arr1 , 0 , n1 - 1 ) )\n", "python_code_tokenized": "def binarySearch ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE midValue = arr [ mid ] NEW_LINE if ( mid == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT leftindex = min ( mid - 1 , midValue ) NEW_LINE left = binarySearch ( arr , low , leftindex ) NEW_LINE if ( left >= 0 ) : NEW_LINE INDENT return left NEW_LINE DEDENT rightindex = max ( mid + 1 , midValue ) NEW_LINE right = binarySearch ( arr , rightindex , high ) NEW_LINE return right NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ - 10 , - 5 , 2 , 2 , 2 , 3 , 4 , 7 , 9 , 12 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Fixed \u2581 Point \u2581 is \" , binarySearch ( arr , 0 , n - 1 ) ) NEW_LINE arr1 = [ - 10 , - 1 , 3 , 3 , 10 , 30 , 30 , 50 , 100 ] NEW_LINE n1 = len ( arr ) NEW_LINE print ( \" Fixed \u2581 Point \u2581 is \" , binarySearch ( arr1 , 0 , n1 - 1 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_846_A", "sol": 0, "python_code": "def canFormTeam ( n , m ) :\n    if ( n >= 1 and m >= 2 ) :\n        return True\n    if ( m >= 1 and n >= 2 ) :\n        return True\n    return False\ndef maxTeams ( n , m ) :\n    count = 0\n    while ( canFormTeam ( n , m ) ) :\n        if ( n > m ) :\n            n -= 2\n            m -= 1\n        else :\n            m -= 2\n            n -= 1\n        count += 1\n    return count\nif __name__ == '__main__' :\n    n = 4\n    m = 5\n    print ( maxTeams ( n , m ) )\n", "python_code_tokenized": "def canFormTeam ( n , m ) : NEW_LINE INDENT if ( n >= 1 and m >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( m >= 1 and n >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def maxTeams ( n , m ) : NEW_LINE INDENT count = 0 NEW_LINE while ( canFormTeam ( n , m ) ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT n -= 2 NEW_LINE m -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT m -= 2 NEW_LINE n -= 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE m = 5 NEW_LINE print ( maxTeams ( n , m ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_119_A", "sol": 0, "python_code": "def sieveOfEratosthenes ( N , s ) :\n    prime = [ False ] * ( N + 1 )\n    for i in range ( 2 , N + 1 , 2 ) :\n        s [ i ] = 2\n    for i in range ( 3 , N + 1 , 2 ) :\n        if prime [ i ] == False :\n            s [ i ] = i\n            for j in range ( i , ( N + 1 ) // i , 2 ) :\n                if prime [ i * j ] == False :\n                    prime [ i * j ] = True\n                    s [ i * j ] = i\ndef findSum ( N ) :\n    s = [ 0 ] * ( N + 1 )\n    ans = 1\n    sieveOfEratosthenes ( N , s )\n    currFactor = s [ N ]\n    power = 1\n    while N > 1 :\n        N //= s [ N ]\n        if currFactor == s [ N ] :\n            power += 1\n            continue\n        sum = 0\n        for i in range ( power + 1 ) :\n            sum += pow ( currFactor , i )\n        ans *= sum\n        currFactor = s [ N ]\n        power = 1\n    return ans\nif __name__ == \"__main__\" :\n    n = 12\n    print ( \"Sum of the factors is :\" , end = \" \" )\n    print ( findSum ( n ) )\n", "python_code_tokenized": "def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if prime [ i ] == False : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , ( N + 1 ) // i , 2 ) : NEW_LINE INDENT if prime [ i * j ] == False : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def findSum ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE ans = 1 NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE currFactor = s [ N ] NEW_LINE power = 1 NEW_LINE while N > 1 : NEW_LINE INDENT N //= s [ N ] NEW_LINE if currFactor == s [ N ] : NEW_LINE INDENT power += 1 NEW_LINE continue NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( power + 1 ) : NEW_LINE INDENT sum += pow ( currFactor , i ) NEW_LINE DEDENT ans *= sum NEW_LINE currFactor = s [ N ] NEW_LINE power = 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 12 NEW_LINE print ( \" Sum \u2581 of \u2581 the \u2581 factors \u2581 is \u2581 : \" , end = \" \u2581 \" ) NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1684_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    a , b , c = [ int ( x ) for x in input ( ).split ( ) ]\n    print ( a + b + c , \" \" , b + c , \" \" , c )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( a + b + c , \" \u2581 \" , b + c , \" \u2581 \" , c ) NEW_LINE DEDENT"}
{"id": "codeforces_602_A", "sol": 0, "python_code": "i = lambda : [ * map ( int , input ( ).split ( ) ) ]\nn , a = i ( )\nx , y = 0 , 0\nfor c in i ( ) : x = x * a + c\nm , b = i ( )\nfor c in i ( ) : y = y * b + c\nprint ( '<=>' [ ( x >= y ) + ( x > y ) ] )\n", "python_code_tokenized": "i = lambda : [ * map ( int , input ( ) . split ( ) ) ] NEW_LINE n , a = i ( ) NEW_LINE x , y = 0 , 0 NEW_LINE for c in i ( ) : x = x * a + c NEW_LINE m , b = i ( ) NEW_LINE for c in i ( ) : y = y * b + c NEW_LINE print ( ' < = > ' [ ( x >= y ) + ( x > y ) ] ) NEW_LINE"}
{"id": "aizu_p00304_A", "sol": 0, "python_code": "m = 1000000007\nfrom sys import stdin\nf_i = stdin\nN = int ( f_i.readline ( ) )\nn_type = [ '' ] * N\nfor i in range ( N ) :\n    t = f_i.readline ( ).rstrip ( )\n    n_type [ i ] = t\nadj = [ [ ] for i in range ( N ) ]\nfor i in range ( N - 1 ) :\n    s , t = map ( int , f_i.readline ( ).split ( ) )\n    s -= 1\n    t -= 1\n    adj [ s ].append ( t )\nfrom itertools import combinations\ndef prod ( nums ) :\n    p = 1\n    for n in nums :\n        p *= n\n    return p\nimport sys\nsys.setrecursionlimit ( 4000 )\ndef dfs ( node ) :\n    nt = n_type [ node ]\n    chld = adj [ node ]\n    if nt == 'E' :\n        if chld :\n            return prod ( map ( dfs , chld ) ) % m\n        else :\n            return 1\n    elif nt == 'E?' :\n        if chld :\n            return ( prod ( map ( dfs , chld ) ) + 1 ) % m\n        else :\n            return 2\n    elif nt == 'A' :\n        return sum ( map ( dfs , chld ) ) % m\n    elif nt == 'A?' :\n        return ( sum ( map ( dfs , chld ) ) + 1 ) % m\n    else :\n        cnt = 0\n        c_s = tuple ( map ( dfs , chld ) )\n        for i in range ( 1 , len ( chld ) + 1 ) :\n            for vals in combinations ( c_s , i ) :\n                cnt += prod ( vals )\n        if len ( nt ) == 1 :\n            return cnt % m\n        else :\n            return ( cnt + 1 ) % m\nprint ( dfs ( 0 ) )\n", "python_code_tokenized": "m = 1000000007 NEW_LINE from sys import stdin NEW_LINE f_i = stdin NEW_LINE N = int ( f_i . readline ( ) ) NEW_LINE n_type = [ ' ' ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = f_i . readline ( ) . rstrip ( ) NEW_LINE n_type [ i ] = t NEW_LINE DEDENT adj = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT s , t = map ( int , f_i . readline ( ) . split ( ) ) NEW_LINE s -= 1 NEW_LINE t -= 1 NEW_LINE adj [ s ] . append ( t ) NEW_LINE DEDENT from itertools import combinations NEW_LINE def prod ( nums ) : NEW_LINE INDENT p = 1 NEW_LINE for n in nums : NEW_LINE INDENT p *= n NEW_LINE DEDENT return p NEW_LINE DEDENT import sys NEW_LINE sys . setrecursionlimit ( 4000 ) NEW_LINE def dfs ( node ) : NEW_LINE INDENT nt = n_type [ node ] NEW_LINE chld = adj [ node ] NEW_LINE if nt == ' E ' : NEW_LINE INDENT if chld : NEW_LINE INDENT return prod ( map ( dfs , chld ) ) % m NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT elif nt == ' E ? ' : NEW_LINE INDENT if chld : NEW_LINE INDENT return ( prod ( map ( dfs , chld ) ) + 1 ) % m NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT elif nt == ' A ' : NEW_LINE INDENT return sum ( map ( dfs , chld ) ) % m NEW_LINE DEDENT elif nt == ' A ? ' : NEW_LINE INDENT return ( sum ( map ( dfs , chld ) ) + 1 ) % m NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 0 NEW_LINE c_s = tuple ( map ( dfs , chld ) ) NEW_LINE for i in range ( 1 , len ( chld ) + 1 ) : NEW_LINE INDENT for vals in combinations ( c_s , i ) : NEW_LINE INDENT cnt += prod ( vals ) NEW_LINE DEDENT DEDENT if len ( nt ) == 1 : NEW_LINE INDENT return cnt % m NEW_LINE DEDENT else : NEW_LINE INDENT return ( cnt + 1 ) % m NEW_LINE DEDENT DEDENT DEDENT print ( dfs ( 0 ) ) NEW_LINE"}
{"id": "leetcode_453_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def minMoves ( self , nums ) :\n        if nums is None or len ( nums ) == 0 :\n            return 0\n        min_num = min ( nums )\n        return sum ( [ i - min_num for i in nums ] )\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def minMoves ( self , nums ) : NEW_LINE INDENT if nums is None or len ( nums ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT min_num = min ( nums ) NEW_LINE return sum ( [ i - min_num for i in nums ] ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00321_A", "sol": 0, "python_code": "N , F = [ int ( i ) for i in input ( ).split ( ) ]\nitemsets = [ ]\nfor l in range ( N ) :\n    items = input ( ).split ( )\n    M = int ( items.pop ( 0 ) )\n    items.sort ( )\n    for i in range ( len ( items ) ) :\n        for j in range ( i + 1 , len ( items ) ) :\n            itemsets.append ( items [ i ] + \"\" + items [ j ] )\nitemsets.sort ( )\ncnt = 1\nans = [ ]\nif F > 1 :\n    ans.append ( \"\" )\n    for i in range ( 1 , len ( itemsets ) ) :\n        if itemsets [ i ] == itemsets [ i - 1 ] :\n            cnt = cnt + 1\n            if cnt >= F and itemsets [ i ] != ans [ - 1 ] :\n                ans.append ( itemsets [ i ] )\n        else :\n            cnt = 1\n    ans.pop ( 0 )\nelse :\n    ans = itemsets\nprint ( len ( ans ) )\nfor i in range ( len ( ans ) ) :\n    print ( ans [ i ] )\n", "python_code_tokenized": "N , F = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE itemsets = [ ] NEW_LINE for l in range ( N ) : NEW_LINE INDENT items = input ( ) . split ( ) NEW_LINE M = int ( items . pop ( 0 ) ) NEW_LINE items . sort ( ) NEW_LINE for i in range ( len ( items ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( items ) ) : NEW_LINE INDENT itemsets . append ( items [ i ] + \" \u2581 \" + items [ j ] ) NEW_LINE DEDENT DEDENT DEDENT itemsets . sort ( ) NEW_LINE cnt = 1 NEW_LINE ans = [ ] NEW_LINE if F > 1 : NEW_LINE INDENT ans . append ( \" \" ) NEW_LINE for i in range ( 1 , len ( itemsets ) ) : NEW_LINE INDENT if itemsets [ i ] == itemsets [ i - 1 ] : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE if cnt >= F and itemsets [ i ] != ans [ - 1 ] : NEW_LINE INDENT ans . append ( itemsets [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT DEDENT ans . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = itemsets NEW_LINE DEDENT print ( len ( ans ) ) NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] ) NEW_LINE DEDENT"}
{"id": "codeforces_58_B", "sol": 0, "python_code": "a = int ( input ( ) )\nfor i in range ( a , 0 , - 1 ) :\n    if a % i == 0 :\n        print ( i , end = ' ' )\n        a = i\n", "python_code_tokenized": "a = int ( input ( ) ) NEW_LINE for i in range ( a , 0 , - 1 ) : NEW_LINE INDENT if a % i == 0 : NEW_LINE INDENT print ( i , end = ' \u2581 ' ) NEW_LINE a = i NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2171_A", "sol": 0, "python_code": "def isPrime ( k ) :\n    if ( k <= 1 ) :\n        return False\n    for i in range ( 2 , k ) :\n        if ( k % i == 0 ) :\n            return false\n    return True\ndef check ( num , k ) :\n    flag = 1\n    for i in range ( 2 , k ) :\n        if ( num % i == 0 ) :\n            flag = 0\n    if ( flag == 1 ) :\n        if ( num % k == 0 ) :\n            return 1\n        else :\n            return 0\n    else :\n        return 0\ndef findCount ( a , b , k ) :\n    count = 0\n    if ( not isPrime ( k ) ) :\n        return 0\n    else :\n        for i in range ( a , b + 1 ) :\n            ans = check ( i , k )\n            if ( ans == 1 ) :\n                count += 1\n            else :\n                continue\n    return count\nif __name__ == \"__main__\" :\n    a = 2020\n    b = 6300\n    k = 29\n    print ( findCount ( a , b , k ) )\n", "python_code_tokenized": "def isPrime ( k ) : NEW_LINE INDENT if ( k <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , k ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( num , k ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , k ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT if ( num % k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def findCount ( a , b , k ) : NEW_LINE INDENT count = 0 NEW_LINE if ( not isPrime ( k ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT ans = check ( i , k ) NEW_LINE if ( ans == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 2020 NEW_LINE b = 6300 NEW_LINE k = 29 NEW_LINE print ( findCount ( a , b , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1262_A", "sol": 0, "python_code": "from math import floor\ndef countSteps ( n ) :\n    steps = 0\n    while ( n ) :\n        largest = floor ( n ** ( 1 / 3 ) )\n        n -= ( largest * largest * largest )\n        steps += 1\n    return steps\nn = 150\nprint ( countSteps ( n ) )\n", "python_code_tokenized": "from math import floor NEW_LINE def countSteps ( n ) : NEW_LINE INDENT steps = 0 NEW_LINE while ( n ) : NEW_LINE INDENT largest = floor ( n ** ( 1 / 3 ) ) NEW_LINE n -= ( largest * largest * largest ) NEW_LINE steps += 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT n = 150 NEW_LINE print ( countSteps ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3333_A", "sol": 0, "python_code": "import sys\ndef minimunMoves ( arr , n ) :\n    ans = sys.maxsize\n    for i in range ( n ) :\n        curr_count = 0\n        for j in range ( n ) :\n            tmp = arr [ j ] + arr [ j ]\n            index = tmp.find ( arr [ i ] )\n            if ( index == len ( arr [ i ] ) ) :\n                return - 1\n            curr_count += index\n        ans = min ( curr_count , ans )\n    return ans\nif __name__ == \"__main__\" :\n    arr = [ \"xzzwo\" , \"zwoxz\" , \"zzwox\" , \"xzzwo\" ]\n    n = len ( arr )\n    print ( minimunMoves ( arr , n ) )\n", "python_code_tokenized": "import sys NEW_LINE def minimunMoves ( arr , n ) : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT tmp = arr [ j ] + arr [ j ] NEW_LINE index = tmp . find ( arr [ i ] ) NEW_LINE if ( index == len ( arr [ i ] ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT curr_count += index NEW_LINE DEDENT ans = min ( curr_count , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" xzzwo \" , \" zwoxz \" , \" zzwox \" , \" xzzwo \" ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimunMoves ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4154_A", "sol": 0, "python_code": "def isPrefix ( string , length , i , k ) :\n    if i + k > length :\n        return False\n    for j in range ( 0 , k ) :\n        if string [ i ] != string [ j ] :\n            return False\n        i += 1\n    return True\ndef isKPeriodic ( string , length , k ) :\n    for i in range ( k , length , k ) :\n        if isPrefix ( string , length , i , k ) == False :\n            return False\n    return True\nif __name__ == \"__main__\" :\n    string = \"geeksgeeks\"\n    length = len ( string )\n    k = 5\n    if isKPeriodic ( string , length , k ) == True :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def isPrefix ( string , length , i , k ) : NEW_LINE INDENT if i + k > length : NEW_LINE INDENT return False NEW_LINE DEDENT for j in range ( 0 , k ) : NEW_LINE INDENT if string [ i ] != string [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def isKPeriodic ( string , length , k ) : NEW_LINE INDENT for i in range ( k , length , k ) : NEW_LINE INDENT if isPrefix ( string , length , i , k ) == False : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksgeeks \" NEW_LINE length = len ( string ) NEW_LINE k = 5 NEW_LINE if isKPeriodic ( string , length , k ) == True : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_432_A", "sol": 0, "python_code": "import math\nn_ = input ( ).split ( )\nk = int ( n_ [ 1 ] )\nn = input ( ).split ( )\nfor i in range ( len ( n ) ) :\n    n [ i ] = int ( n [ i ] )\ntotal = 0\nfor i in n :\n    if i + k <= 5 :\n        total += 1\nprint ( total // 3 )\n", "python_code_tokenized": "import math NEW_LINE n_ = input ( ) . split ( ) NEW_LINE k = int ( n_ [ 1 ] ) NEW_LINE n = input ( ) . split ( ) NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT n [ i ] = int ( n [ i ] ) NEW_LINE DEDENT total = 0 NEW_LINE for i in n : NEW_LINE INDENT if i + k <= 5 : NEW_LINE INDENT total += 1 NEW_LINE DEDENT DEDENT print ( total // 3 ) NEW_LINE"}
{"id": "atcoder_ABC158_D", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\ndef ST ( ) :\n    return input ( ).rstrip ( )\ndef I ( ) :\n    return int ( input ( ) )\ndef MI ( ) :\n    return map ( int , input ( ).split ( ) )\ndef LI ( ) :\n    return list ( MI ( ) )\nS = ST ( )\nQ = I ( )\nswitch = True\nprefix = \"\"\nsuffix = \"\"\nfor _ in range ( Q ) :\n    query = list ( input ( ).split ( ) )\n    if query [ 0 ] == \"1\" :\n        if switch :\n            switch = False\n        else :\n            switch = True\n    else :\n        if switch :\n            if query [ 1 ] == \"1\" :\n                prefix = query [ 2 ] + prefix\n            else :\n                suffix = suffix + query [ 2 ]\n        else :\n            if query [ 1 ] == \"1\" :\n                suffix = suffix + query [ 2 ]\n            else :\n                prefix = query [ 2 ] + prefix\nans = prefix + S + suffix\nif switch :\n    print ( ans )\nelse :\n    print ( ans [ : : - 1 ] )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE def ST ( ) : NEW_LINE INDENT return input ( ) . rstrip ( ) NEW_LINE DEDENT def I ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def MI ( ) : NEW_LINE INDENT return map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT def LI ( ) : NEW_LINE INDENT return list ( MI ( ) ) NEW_LINE DEDENT S = ST ( ) NEW_LINE Q = I ( ) NEW_LINE switch = True NEW_LINE prefix = \" \" NEW_LINE suffix = \" \" NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT query = list ( input ( ) . split ( ) ) NEW_LINE if query [ 0 ] == \"1\" : NEW_LINE INDENT if switch : NEW_LINE INDENT switch = False NEW_LINE DEDENT else : NEW_LINE INDENT switch = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if switch : NEW_LINE INDENT if query [ 1 ] == \"1\" : NEW_LINE INDENT prefix = query [ 2 ] + prefix NEW_LINE DEDENT else : NEW_LINE INDENT suffix = suffix + query [ 2 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if query [ 1 ] == \"1\" : NEW_LINE INDENT suffix = suffix + query [ 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT prefix = query [ 2 ] + prefix NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = prefix + S + suffix NEW_LINE if switch : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans [ : : - 1 ] ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC036_A", "sol": 0, "python_code": "s = int ( input ( ) )\nMOD = 10 ** 9\nx = ( - s ) % MOD\ny = ( s + x ) // MOD\nprint ( 0 , 0 , 10 ** 9 , 1 , x , y )\n", "python_code_tokenized": "s = int ( input ( ) ) NEW_LINE MOD = 10 ** 9 NEW_LINE x = ( - s ) % MOD NEW_LINE y = ( s + x ) // MOD NEW_LINE print ( 0 , 0 , 10 ** 9 , 1 , x , y ) NEW_LINE"}
{"id": "atcoder_AGC024_C", "sol": 0, "python_code": "N = int ( input ( ) )\nA = [ - 1 ] + [ int ( input ( ) ) for _ in range ( N ) ]\ncount = - 1\nfor i in range ( N , 0 , - 1 ) :\n    if A [ i ] - 1 > A [ i - 1 ] :\n        print ( - 1 )\n        exit ( )\n    elif A [ i ] - 1 == A [ i - 1 ] :\n        count += 1\n    else :\n        count += A [ i ]\nprint ( count )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE A = [ - 1 ] + [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE count = - 1 NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT if A [ i ] - 1 > A [ i - 1 ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT elif A [ i ] - 1 == A [ i - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += A [ i ] NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"}
{"id": "geeksforgeeks_2283_A", "sol": 0, "python_code": "def recaman ( n ) :\n    arr = [ 0 ] * n\n    arr [ 0 ] = 0\n    print ( arr [ 0 ] , end = \", \" )\n    for i in range ( 1 , n ) :\n        curr = arr [ i - 1 ] - i\n        for j in range ( 0 , i ) :\n            if ( ( arr [ j ] == curr ) or curr < 0 ) :\n                curr = arr [ i - 1 ] + i\n                break\n        arr [ i ] = curr\n        print ( arr [ i ] , end = \", \" )\nn = 17\nrecaman ( n )\n", "python_code_tokenized": "def recaman ( n ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE arr [ 0 ] = 0 NEW_LINE print ( arr [ 0 ] , end = \" , \u2581 \" ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = arr [ i - 1 ] - i NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ j ] == curr ) or curr < 0 ) : NEW_LINE INDENT curr = arr [ i - 1 ] + i NEW_LINE break NEW_LINE DEDENT DEDENT arr [ i ] = curr NEW_LINE print ( arr [ i ] , end = \" , \u2581 \" ) NEW_LINE DEDENT DEDENT n = 17 NEW_LINE recaman ( n ) NEW_LINE"}
{"id": "geeksforgeeks_568_A", "sol": 0, "python_code": "MAX = 21\nfact = [ 0 ] * MAX\ndef probability ( k , n ) :\n    ans = 0\n    for i in range ( k , n + 1 ) :\n        ans += fact [ n ] / ( fact [ i ] * fact [ n - i ] )\n    ans = ans / ( 1 << n )\n    return ans\ndef precompute ( ) :\n    fact [ 0 ] = 1\n    fact [ 1 ] = 1\n    for i in range ( 2 , 20 ) :\n        fact [ i ] = fact [ i - 1 ] * i\nif __name__ == '__main__' :\n    precompute ( )\n    print ( probability ( 2 , 3 ) )\n    print ( probability ( 3 , 6 ) )\n    print ( probability ( 12 , 18 ) )\n", "python_code_tokenized": "MAX = 21 NEW_LINE fact = [ 0 ] * MAX NEW_LINE def probability ( k , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( k , n + 1 ) : NEW_LINE INDENT ans += fact [ n ] / ( fact [ i ] * fact [ n - i ] ) NEW_LINE DEDENT ans = ans / ( 1 << n ) NEW_LINE return ans NEW_LINE DEDENT def precompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE fact [ 1 ] = 1 NEW_LINE for i in range ( 2 , 20 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT precompute ( ) NEW_LINE print ( probability ( 2 , 3 ) ) NEW_LINE print ( probability ( 3 , 6 ) ) NEW_LINE print ( probability ( 12 , 18 ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00722_A", "sol": 0, "python_code": "prime = [ True ] * ( 1000001 )\nprime [ 0 ] = False\nprime [ 1 ] = False\nfor i in range ( 2 , 1000001 ) :\n    if prime [ i ] :\n        for j in range ( i * 2 , 1000001 , i ) :\n            prime [ j ] = False\nwhile True :\n    a , d , n = map ( int , input ( ).split ( ) )\n    if a == 0 :\n        break\n    count = 0\n    i = a\n    cont = True\n    while cont :\n        if prime [ i ] :\n            count += 1\n            if count == n :\n                print ( i )\n                cont = False\n        i += d\n", "python_code_tokenized": "prime = [ True ] * ( 1000001 ) NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for i in range ( 2 , 1000001 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT for j in range ( i * 2 , 1000001 , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT while True : NEW_LINE INDENT a , d , n = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT break NEW_LINE DEDENT count = 0 NEW_LINE i = a NEW_LINE cont = True NEW_LINE while cont : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT count += 1 NEW_LINE if count == n : NEW_LINE INDENT print ( i ) NEW_LINE cont = False NEW_LINE DEDENT DEDENT i += d NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1797_A", "sol": 0, "python_code": "def printPermutation ( n ) :\n    if ( n % 2 != 0 ) :\n        print ( - 1 ) ;\n    else :\n        for i in range ( 1 , ( n // 2 ) + 1 ) :\n            print ( ( 2 * i ) , ( 2 * i - 1 ) , end = \" \" ) ;\nn = 4 ;\nprintPermutation ( n ) ;\n", "python_code_tokenized": "def printPermutation ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , ( n // 2 ) + 1 ) : NEW_LINE INDENT print ( ( 2 * i ) , ( 2 * i - 1 ) , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT DEDENT n = 4 ; NEW_LINE printPermutation ( n ) ; NEW_LINE"}
{"id": "projecteuler_p243_A", "sol": 0, "python_code": "import eulerlib , fractions\ndef compute ( ) :\n    TARGET = fractions.Fraction ( 15499 , 94744 )\n    totient = 1\n    denominator = 1\n    p = 2\n    while True :\n        totient *= p - 1\n        denominator *= p\n        while True :\n            p += 1\n            if eulerlib.is_prime ( p ) :\n                break\n        if fractions.Fraction ( totient , denominator ) < TARGET :\n            for i in range ( 1 , p ) :\n                numer = i * totient\n                denom = i * denominator\n                if fractions.Fraction ( numer , denom - 1 ) < TARGET :\n                    return str ( denom )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = fractions . Fraction ( 15499 , 94744 ) NEW_LINE totient = 1 NEW_LINE denominator = 1 NEW_LINE p = 2 NEW_LINE while True : NEW_LINE INDENT totient *= p - 1 NEW_LINE denominator *= p NEW_LINE while True : NEW_LINE INDENT p += 1 NEW_LINE if eulerlib . is_prime ( p ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if fractions . Fraction ( totient , denominator ) < TARGET : NEW_LINE INDENT for i in range ( 1 , p ) : NEW_LINE INDENT numer = i * totient NEW_LINE denom = i * denominator NEW_LINE if fractions . Fraction ( numer , denom - 1 ) < TARGET : NEW_LINE INDENT return str ( denom ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_678_B", "sol": 0, "python_code": "import calendar\ny = int ( input ( ) )\nis_run = calendar.isleap ( y )\nweek = calendar.weekday ( y , 1 , 1 )\nwhile True :\n    y = y + 1\n    if calendar.isleap ( y ) == is_run and calendar.weekday ( y , 1 , 1 ) == week :\n        print ( y )\n        break\n", "python_code_tokenized": "import calendar NEW_LINE y = int ( input ( ) ) NEW_LINE is_run = calendar . isleap ( y ) NEW_LINE week = calendar . weekday ( y , 1 , 1 ) NEW_LINE while True : NEW_LINE INDENT y = y + 1 NEW_LINE if calendar . isleap ( y ) == is_run and calendar . weekday ( y , 1 , 1 ) == week : NEW_LINE INDENT print ( y ) NEW_LINE break NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3510_A", "sol": 0, "python_code": "class newNode :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.left = None\n        self.right = None\ndef getLevelUtil ( node , data , level ) :\n    if ( node == None ) :\n        return 0\n    if ( node.data == data ) :\n        return level\n    downlevel = getLevelUtil ( node.left , data , level + 1 )\n    if ( downlevel != 0 ) :\n        return downlevel\n    downlevel = getLevelUtil ( node.right , data , level + 1 )\n    return downlevel\ndef getLevel ( node , data ) :\n    return getLevelUtil ( node , data , 1 )\nif __name__ == '__main__' :\n    root = newNode ( 3 )\n    root.left = newNode ( 2 )\n    root.right = newNode ( 5 )\n    root.left.left = newNode ( 1 )\n    root.left.right = newNode ( 4 )\n    for x in range ( 1 , 6 ) :\n        level = getLevel ( root , x )\n        if ( level ) :\n            print ( \"Level of\" , x , \"is\" , getLevel ( root , x ) )\n        else :\n            print ( x , \"is not present in tree\" )\n", "python_code_tokenized": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getLevelUtil ( node , data , level ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( node . data == data ) : NEW_LINE INDENT return level NEW_LINE DEDENT downlevel = getLevelUtil ( node . left , data , level + 1 ) NEW_LINE if ( downlevel != 0 ) : NEW_LINE INDENT return downlevel NEW_LINE DEDENT downlevel = getLevelUtil ( node . right , data , level + 1 ) NEW_LINE return downlevel NEW_LINE DEDENT def getLevel ( node , data ) : NEW_LINE INDENT return getLevelUtil ( node , data , 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 3 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 5 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 4 ) NEW_LINE for x in range ( 1 , 6 ) : NEW_LINE INDENT level = getLevel ( root , x ) NEW_LINE if ( level ) : NEW_LINE INDENT print ( \" Level \u2581 of \" , x , \" is \" , getLevel ( root , x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , \" is \u2581 not \u2581 present \u2581 in \u2581 tree \" ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_4858_A", "sol": 0, "python_code": "def isPrime ( n ) :\n    if ( n <= 1 ) : return False\n    if ( n <= 3 ) : return True\n    if ( n % 2 == 0 or n % 3 == 0 ) :\n        return False\n    i = 5\n    while ( i * i <= n ) :\n        if ( n % i == 0 or n % ( i + 2 ) == 0 ) :\n            return False\n        i += 6\n    return True\ndef primorial ( n ) :\n    p = 2 ; n -= 1 ; i = 3\n    while ( n != 0 ) :\n        if ( isPrime ( i ) ) :\n            p = p * i\n            n -= 1\n        i += 1\n    return p\ndef findNextPrime ( n ) :\n    nextPrime = n + 2\n    while ( True ) :\n        if ( isPrime ( nextPrime ) ) :\n            break\n        nextPrime += 1\n    return nextPrime\ndef fortunateNumber ( n ) :\n    p = primorial ( n )\n    return findNextPrime ( p ) - p\nn = 5\nprint ( fortunateNumber ( n ) )\n", "python_code_tokenized": "def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : return False NEW_LINE if ( n <= 3 ) : return True NEW_LINE if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def primorial ( n ) : NEW_LINE INDENT p = 2 ; n -= 1 ; i = 3 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT p = p * i NEW_LINE n -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return p NEW_LINE DEDENT def findNextPrime ( n ) : NEW_LINE INDENT nextPrime = n + 2 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPrime ( nextPrime ) ) : NEW_LINE INDENT break NEW_LINE DEDENT nextPrime += 1 NEW_LINE DEDENT return nextPrime NEW_LINE DEDENT def fortunateNumber ( n ) : NEW_LINE INDENT p = primorial ( n ) NEW_LINE return findNextPrime ( p ) - p NEW_LINE DEDENT n = 5 NEW_LINE print ( fortunateNumber ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_692_A", "sol": 0, "python_code": "def minimumValue ( arr , n , k ) :\n    arr.sort ( ) ;\n    answer = 0 ;\n    for i in range ( k ) :\n        answer += arr [ i ] * arr [ i ] ;\n    return answer * ( 2 * k - 2 ) ;\nif __name__ == '__main__' :\n    arr = [ 4 , 21 , 5 , 3 , 8 ] ;\n    k = 3 ;\n    n = len ( arr ) ;\n    print ( minimumValue ( arr , n , k ) ) ;\n", "python_code_tokenized": "def minimumValue ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE answer = 0 ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT answer += arr [ i ] * arr [ i ] ; NEW_LINE DEDENT return answer * ( 2 * k - 2 ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 21 , 5 , 3 , 8 ] ; NEW_LINE k = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( minimumValue ( arr , n , k ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_262_B", "sol": 0, "python_code": "numbers = list ( map ( int , input ( ).split ( ) ) )\narr = list ( map ( int , input ( ).split ( ) ) )\nsum = 0\nmin = float ( 'inf' )\nfor i in range ( 0 , len ( arr ) ) :\n    if arr [ i ] < 0 and numbers [ 1 ] > 0 :\n        arr [ i ] *= - 1\n        numbers [ 1 ] -= 1\n    sum += arr [ i ]\n    min = min if min < arr [ i ] else arr [ i ]\nif numbers [ 1 ] % 2 != 0 :\n    sum = ( sum - min ) + ( min * - 1 )\nprint ( sum )\n", "python_code_tokenized": "numbers = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum = 0 NEW_LINE min = float ( ' inf ' ) NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if arr [ i ] < 0 and numbers [ 1 ] > 0 : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE numbers [ 1 ] -= 1 NEW_LINE DEDENT sum += arr [ i ] NEW_LINE min = min if min < arr [ i ] else arr [ i ] NEW_LINE DEDENT if numbers [ 1 ] % 2 != 0 : NEW_LINE INDENT sum = ( sum - min ) + ( min * - 1 ) NEW_LINE DEDENT print ( sum ) NEW_LINE"}
{"id": "geeksforgeeks_3897_A", "sol": 0, "python_code": "V = 4\ndef countwalks ( graph , u , v , k ) :\n    if ( k == 0 and u == v ) :\n        return 1\n    if ( k == 1 and graph [ u ] [ v ] ) :\n        return 1\n    if ( k <= 0 ) :\n        return 0\n    count = 0\n    for i in range ( 0 , V ) :\n        if ( graph [ u ] [ i ] == 1 ) :\n            count += countwalks ( graph , i , v , k - 1 )\n    return count\ngraph = [ [ 0 , 1 , 1 , 1 , ] , [ 0 , 0 , 0 , 1 , ] , [ 0 , 0 , 0 , 1 , ] , [ 0 , 0 , 0 , 0 ] ]\nu = 0 ; v = 3 ; k = 2\nprint ( countwalks ( graph , u , v , k ) )\n", "python_code_tokenized": "V = 4 NEW_LINE def countwalks ( graph , u , v , k ) : NEW_LINE INDENT if ( k == 0 and u == v ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 1 and graph [ u ] [ v ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , V ) : NEW_LINE INDENT if ( graph [ u ] [ i ] == 1 ) : NEW_LINE INDENT count += countwalks ( graph , i , v , k - 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT graph = [ [ 0 , 1 , 1 , 1 , ] , [ 0 , 0 , 0 , 1 , ] , [ 0 , 0 , 0 , 1 , ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE u = 0 ; v = 3 ; k = 2 NEW_LINE print ( countwalks ( graph , u , v , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_155_A", "sol": 0, "python_code": "def findLargest ( n , v ) :\n    flag = 0\n    sum = 0\n    for i in range ( n ) :\n        if ( v [ i ] == 0 ) :\n            flag = 1\n        sum += v [ i ]\n    if ( flag == 0 ) :\n        print ( \"Not possible\" )\n    else :\n        v.sort ( reverse = True )\n        if ( v [ 0 ] == 0 ) :\n            print ( \"0\" )\n            return 0\n        else :\n            flag = 0\n            y = sum % 3\n            if ( y != 0 ) :\n                i = n - 1\n                while ( i >= 0 ) :\n                    if ( v [ i ] % 3 == y ) :\n                        v.remove ( v [ i ] )\n                        flag = 1\n                        break\n                    i -= 1\n                if ( flag == 0 ) :\n                    y = 3 - y\n                    cnt = 0\n                    i = n - 1\n                    while ( i >= 0 ) :\n                        if ( v [ i ] % 3 == y ) :\n                            v.remove ( v [ i ] )\n                            cnt += 1\n                            if ( cnt >= 2 ) :\n                                break\n                        i -= 1\n            if ( v [ 0 ] == 0 ) :\n                print ( \"0\" )\n            else :\n                for i in ( v ) :\n                    print ( i , end = \"\" )\nif __name__ == '__main__' :\n    n = 11\n    v = [ 3 , 9 , 9 , 6 , 4 , 3 , 6 , 4 , 9 , 6 , 0 ]\n    findLargest ( n , v )\n", "python_code_tokenized": "def findLargest ( n , v ) : NEW_LINE INDENT flag = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( v [ i ] == 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT sum += v [ i ] NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" Not \u2581 possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT v . sort ( reverse = True ) NEW_LINE if ( v [ 0 ] == 0 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 0 NEW_LINE y = sum % 3 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( v [ i ] % 3 == y ) : NEW_LINE INDENT v . remove ( v [ i ] ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT y = 3 - y NEW_LINE cnt = 0 NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( v [ i ] % 3 == y ) : NEW_LINE INDENT v . remove ( v [ i ] ) NEW_LINE cnt += 1 NEW_LINE if ( cnt >= 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT if ( v [ 0 ] == 0 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in ( v ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 11 NEW_LINE v = [ 3 , 9 , 9 , 6 , 4 , 3 , 6 , 4 , 9 , 6 , 0 ] NEW_LINE findLargest ( n , v ) NEW_LINE DEDENT"}
{"id": "aizu_p00753_A", "sol": 0, "python_code": "MAX = 250000\nSQRT = 500\nprime = [ True ] * MAX\ndef sieve ( ) :\n    for i in range ( 2 , MAX , 2 ) : prime [ i ] = False\n    for i in range ( 3 , SQRT , 2 ) :\n        if prime [ i ] :\n            for j in range ( i * i , MAX , i ) : prime [ j ] = False\nsieve ( )\nwhile True :\n    n = int ( input ( ) )\n    if n == 0 : break\n    ans , m = 0 , n << 1\n    if n == 1 : ans += 1\n    i = n + 1\n    if ( i & 1 ) == 0 : i += 1\n    while i <= m :\n        if prime [ i ] : ans += 1\n        i += 2\n    print ( ans )\n", "python_code_tokenized": "MAX = 250000 NEW_LINE SQRT = 500 NEW_LINE prime = [ True ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 2 , MAX , 2 ) : prime [ i ] = False NEW_LINE for i in range ( 3 , SQRT , 2 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT sieve ( ) NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE ans , m = 0 , n << 1 NEW_LINE if n == 1 : ans += 1 NEW_LINE i = n + 1 NEW_LINE if ( i & 1 ) == 0 : i += 1 NEW_LINE while i <= m : NEW_LINE INDENT if prime [ i ] : ans += 1 NEW_LINE i += 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1394_A", "sol": 0, "python_code": "def _popcnt32 ( number ) :\n    counter = 0\n    while ( number > 0 ) :\n        if ( number % 2 == 1 ) :\n            counter = counter + 1\n        number = int ( number / 2 )\n    return counter\ndef maximize ( a ) :\n    n = _popcnt32 ( a )\n    res = 0\n    for i in range ( 1 , n + 1 ) :\n        res = int ( res | ( 1 << ( 32 - i ) ) )\n    return abs ( res )\na = 1\nprint ( maximize ( a ) )\n", "python_code_tokenized": "def _popcnt32 ( number ) : NEW_LINE INDENT counter = 0 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT if ( number % 2 == 1 ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT number = int ( number / 2 ) NEW_LINE DEDENT return counter NEW_LINE DEDENT def maximize ( a ) : NEW_LINE INDENT n = _popcnt32 ( a ) NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res = int ( res | ( 1 << ( 32 - i ) ) ) NEW_LINE DEDENT return abs ( res ) NEW_LINE DEDENT a = 1 NEW_LINE print ( maximize ( a ) ) NEW_LINE"}
{"id": "geeksforgeeks_5167_A", "sol": 0, "python_code": "def ispower ( n ) :\n    if ( n < 125 ) :\n        return ( n == 1 or n == 5 or n == 25 )\n    if ( n % 125 != 0 ) :\n        return 0\n    else :\n        return ispower ( n // 125 )\ndef number ( s , i , j ) :\n    ans = 0\n    for x in range ( i , j ) :\n        ans = ans * 2 + ( ord ( s [ x ] ) - ord ( '0' ) )\n    return ans\ndef minCuts ( s , n ) :\n    dp = [ n + 1 for i in range ( n + 1 ) ]\n    dp [ 0 ] = 0 ;\n    for i in range ( 1 , n + 1 ) :\n        if ( s [ i - 1 ] == '0' ) :\n            continue\n        for j in range ( i ) :\n            if ( s [ j ] == '0' ) :\n                continue\n            num = number ( s , j , i )\n            if ( not ispower ( num ) ) :\n                continue\n            dp [ i ] = min ( dp [ i ] , dp [ j ] + 1 )\n    if dp [ n ] < n + 1 :\n        return dp [ n ]\n    else :\n        return - 1\nif __name__ == \"__main__\" :\n    s = \"101101101\"\n    n = len ( s )\n    print ( minCuts ( s , n ) )\n", "python_code_tokenized": "def ispower ( n ) : NEW_LINE INDENT if ( n < 125 ) : NEW_LINE INDENT return ( n == 1 or n == 5 or n == 25 ) NEW_LINE DEDENT if ( n % 125 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ispower ( n // 125 ) NEW_LINE DEDENT DEDENT def number ( s , i , j ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( i , j ) : NEW_LINE INDENT ans = ans * 2 + ( ord ( s [ x ] ) - ord ( '0' ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def minCuts ( s , n ) : NEW_LINE INDENT dp = [ n + 1 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( s [ i - 1 ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i ) : NEW_LINE INDENT if ( s [ j ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT num = number ( s , j , i ) NEW_LINE if ( not ispower ( num ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i ] = min ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT if dp [ n ] < n + 1 : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"101101101\" NEW_LINE n = len ( s ) NEW_LINE print ( minCuts ( s , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1121_A", "sol": 0, "python_code": "n , m , k = map ( int , input ( ).split ( ) )\np = list ( map ( int , input ( ).split ( ) ) )\ns = list ( map ( int , input ( ).split ( ) ) )\nc = list ( map ( int , input ( ).split ( ) ) )\nd = { }\nmore_school = 0\nfor i in range ( n ) :\n    if s [ i ] in d :\n        d [ s [ i ] ].append ( p [ i ] )\n    else :\n        d [ s [ i ] ] = [ p [ i ] ]\nfor i in c :\n    if max ( d [ s [ i - 1 ] ] ) != p [ i - 1 ] :\n        more_school += 1\nprint ( more_school )\n", "python_code_tokenized": "n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE more_school = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] in d : NEW_LINE INDENT d [ s [ i ] ] . append ( p [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT d [ s [ i ] ] = [ p [ i ] ] NEW_LINE DEDENT DEDENT for i in c : NEW_LINE INDENT if max ( d [ s [ i - 1 ] ] ) != p [ i - 1 ] : NEW_LINE INDENT more_school += 1 NEW_LINE DEDENT DEDENT print ( more_school ) NEW_LINE"}
{"id": "aizu_p00058_A", "sol": 0, "python_code": "def get_input ( ) :\n    while True :\n        try :\n            yield ''.join ( input ( ) )\n        except EOFError :\n            break\nN = list ( get_input ( ) )\nfor l in range ( len ( N ) ) :\n    Points = [ float ( i ) for i in N [ l ].split ( ) ]\n    P = [ ]\n    for i in range ( 8 ) :\n        P.append ( int ( Points [ i ] * 10 ** 5 ) )\n    AB = [ P [ 2 ] - P [ 0 ] , P [ 3 ] - P [ 1 ] ]\n    CD = [ P [ 6 ] - P [ 4 ] , P [ 7 ] - P [ 5 ] ]\n    if AB [ 0 ] * CD [ 0 ] + AB [ 1 ] * CD [ 1 ] == 0 :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "def get_input ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT yield ' ' . join ( input ( ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT N = list ( get_input ( ) ) NEW_LINE for l in range ( len ( N ) ) : NEW_LINE INDENT Points = [ float ( i ) for i in N [ l ] . split ( ) ] NEW_LINE P = [ ] NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT P . append ( int ( Points [ i ] * 10 ** 5 ) ) NEW_LINE DEDENT AB = [ P [ 2 ] - P [ 0 ] , P [ 3 ] - P [ 1 ] ] NEW_LINE CD = [ P [ 6 ] - P [ 4 ] , P [ 7 ] - P [ 5 ] ] NEW_LINE if AB [ 0 ] * CD [ 0 ] + AB [ 1 ] * CD [ 1 ] == 0 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC160_D", "sol": 0, "python_code": "N , X , Y = map ( int , input ( ).split ( ) )\nX -= 1\nY -= 1\naggre = [ 0 ] * ( N - 1 )\nfor i in range ( N ) :\n    for j in range ( N ) :\n        if i == j :\n            continue\n        dist = min ( abs ( j - i ) , abs ( X - i ) + abs ( Y - j ) + 1 , abs ( Y - i ) + abs ( X - j ) + 1 )\n        aggre [ dist - 1 ] += 1\nfor a in aggre :\n    print ( a // 2 )\n", "python_code_tokenized": "N , X , Y = map ( int , input ( ) . split ( ) ) NEW_LINE X -= 1 NEW_LINE Y -= 1 NEW_LINE aggre = [ 0 ] * ( N - 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT dist = min ( abs ( j - i ) , abs ( X - i ) + abs ( Y - j ) + 1 , abs ( Y - i ) + abs ( X - j ) + 1 ) NEW_LINE aggre [ dist - 1 ] += 1 NEW_LINE DEDENT DEDENT for a in aggre : NEW_LINE INDENT print ( a // 2 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1902_A", "sol": 0, "python_code": "def search ( arr , n , x ) :\n    if ( arr [ n - 1 ] == x ) :\n        return \"Found\"\n    backup = arr [ n - 1 ]\n    arr [ n - 1 ] = x\n    i = 0\n    while ( i < n ) :\n        if ( arr [ i ] == x ) :\n            arr [ n - 1 ] = backup\n            if ( i < n - 1 ) :\n                return \"Found\"\n            return \"Not Found\"\n        i = i + 1\narr = [ 4 , 6 , 1 , 5 , 8 ]\nn = len ( arr )\nx = 1\nprint ( search ( arr , n , x ) )\n", "python_code_tokenized": "def search ( arr , n , x ) : NEW_LINE INDENT if ( arr [ n - 1 ] == x ) : NEW_LINE INDENT return \" Found \" NEW_LINE DEDENT backup = arr [ n - 1 ] NEW_LINE arr [ n - 1 ] = x NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT arr [ n - 1 ] = backup NEW_LINE if ( i < n - 1 ) : NEW_LINE INDENT return \" Found \" NEW_LINE DEDENT return \" Not \u2581 Found \" NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT arr = [ 4 , 6 , 1 , 5 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( search ( arr , n , x ) ) NEW_LINE"}
{"id": "atcoder_ABC161_E", "sol": 0, "python_code": "n , k , c = map ( int , input ( ).split ( ) )\ns = input ( )\nfastest_schedule = [ None for i in range ( n ) ]\nlatest_schedule = [ None for i in range ( n ) ]\ncount = 1\nlast_workday = - 10 ** 10\nfor i in range ( n ) :\n    if s [ i ] == 'o' and i - last_workday > c :\n        fastest_schedule [ i ] = count\n        last_workday = i\n        if count < k :\n            count += 1\n        else :\n            break\ncount = k\nlast_workday = 10 ** 18\nfor i in range ( n - 1 , - 1 , - 1 ) :\n    if s [ i ] == 'o' and last_workday - i > c :\n        latest_schedule [ i ] = count\n        last_workday = i\n        if count > 1 :\n            count -= 1\n        else :\n            break\nfor i in range ( n ) :\n    if fastest_schedule [ i ] == latest_schedule [ i ] and fastest_schedule [ i ] != None :\n        print ( i + 1 )\n", "python_code_tokenized": "n , k , c = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE fastest_schedule = [ None for i in range ( n ) ] NEW_LINE latest_schedule = [ None for i in range ( n ) ] NEW_LINE count = 1 NEW_LINE last_workday = - 10 ** 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' o ' and i - last_workday > c : NEW_LINE INDENT fastest_schedule [ i ] = count NEW_LINE last_workday = i NEW_LINE if count < k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT count = k NEW_LINE last_workday = 10 ** 18 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == ' o ' and last_workday - i > c : NEW_LINE INDENT latest_schedule [ i ] = count NEW_LINE last_workday = i NEW_LINE if count > 1 : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if fastest_schedule [ i ] == latest_schedule [ i ] and fastest_schedule [ i ] != None : NEW_LINE INDENT print ( i + 1 ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_940_A", "sol": 0, "python_code": "class new_Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.next = None\ndef getIntesectionNode ( head1 , head2 ) :\n    current1 = head1\n    current2 = head2\n    if ( not current1 or not current2 ) :\n        return - 1\n    while ( current1 and current2 and current1 != current2 ) :\n        current1 = current1.next\n        current2 = current2.next\n        if ( current1 == current2 ) :\n            return current1.data\n        if ( not current1 ) :\n            current1 = head2\n        if ( not current2 ) :\n            current2 = head1\n    return current1.data\nhead1 = new_Node ( 10 )\nhead2 = new_Node ( 3 )\nnewNode = new_Node ( 6 )\nhead2.next = newNode\nnewNode = new_Node ( 9 )\nhead2.next.next = newNode\nnewNode = new_Node ( 15 )\nhead1.next = newNode\nhead2.next.next.next = newNode\nnewNode = new_Node ( 30 )\nhead1.next.next = newNode\nhead1.next.next.next = None\nprint ( getIntesectionNode ( head1 , head2 ) )\n", "python_code_tokenized": "class new_Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def getIntesectionNode ( head1 , head2 ) : NEW_LINE INDENT current1 = head1 NEW_LINE current2 = head2 NEW_LINE if ( not current1 or not current2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT while ( current1 and current2 and current1 != current2 ) : NEW_LINE INDENT current1 = current1 . next NEW_LINE current2 = current2 . next NEW_LINE if ( current1 == current2 ) : NEW_LINE INDENT return current1 . data NEW_LINE DEDENT if ( not current1 ) : NEW_LINE INDENT current1 = head2 NEW_LINE DEDENT if ( not current2 ) : NEW_LINE INDENT current2 = head1 NEW_LINE DEDENT DEDENT return current1 . data NEW_LINE DEDENT head1 = new_Node ( 10 ) NEW_LINE head2 = new_Node ( 3 ) NEW_LINE newNode = new_Node ( 6 ) NEW_LINE head2 . next = newNode NEW_LINE newNode = new_Node ( 9 ) NEW_LINE head2 . next . next = newNode NEW_LINE newNode = new_Node ( 15 ) NEW_LINE head1 . next = newNode NEW_LINE head2 . next . next . next = newNode NEW_LINE newNode = new_Node ( 30 ) NEW_LINE head1 . next . next = newNode NEW_LINE head1 . next . next . next = None NEW_LINE print ( getIntesectionNode ( head1 , head2 ) ) NEW_LINE"}
{"id": "geeksforgeeks_2545_A", "sol": 0, "python_code": "def summation ( n ) :\n    return n << ( n - 1 ) ;\nn = 2 ;\nprint ( summation ( n ) ) ;\n", "python_code_tokenized": "def summation ( n ) : NEW_LINE INDENT return n << ( n - 1 ) ; NEW_LINE DEDENT n = 2 ; NEW_LINE print ( summation ( n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_4157_A", "sol": 0, "python_code": "def encodedChar ( str , k ) :\n    expand = \"\"\n    freq = 0\n    i = 0\n    while ( i < len ( str ) ) :\n        temp = \"\"\n        freq = 0\n        while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( 'a' ) and ord ( str [ i ] ) <= ord ( 'z' ) ) :\n            temp += str [ i ]\n            i += 1\n        while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( '1' ) and ord ( str [ i ] ) <= ord ( '9' ) ) :\n            freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' )\n            i += 1\n        for j in range ( 1 , freq + 1 , 1 ) :\n            expand += temp\n    if ( freq == 0 ) :\n        expand += temp\n    return expand [ k - 1 ]\nif __name__ == '__main__' :\n    str = \"ab4c12ed3\"\n    k = 21\n    print ( encodedChar ( str , k ) )\n", "python_code_tokenized": "def encodedChar ( str , k ) : NEW_LINE INDENT expand = \" \" NEW_LINE freq = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT temp = \" \" NEW_LINE freq = 0 NEW_LINE while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( ' a ' ) and ord ( str [ i ] ) <= ord ( ' z ' ) ) : NEW_LINE INDENT temp += str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( '1' ) and ord ( str [ i ] ) <= ord ( '9' ) ) : NEW_LINE INDENT freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq + 1 , 1 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT DEDENT if ( freq == 0 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT return expand [ k - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" ab4c12ed3\" NEW_LINE k = 21 NEW_LINE print ( encodedChar ( str , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4200_A", "sol": 0, "python_code": "def getPairsCount ( arr , n , sum ) :\n    count = 0\n    for i in range ( 0 , n ) :\n        for j in range ( i + 1 , n ) :\n            if arr [ i ] + arr [ j ] == sum :\n                count += 1\n    return count\narr = [ 1 , 5 , 7 , - 1 , 5 ]\nn = len ( arr )\nsum = 6\nprint ( \"Count of pairs is\" , getPairsCount ( arr , n , sum ) )\n", "python_code_tokenized": "def getPairsCount ( arr , n , sum ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] == sum : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 5 , 7 , - 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 6 NEW_LINE print ( \" Count \u2581 of \u2581 pairs \u2581 is \" , getPairsCount ( arr , n , sum ) ) NEW_LINE"}
{"id": "geeksforgeeks_556_A", "sol": 0, "python_code": "import math\ndef productPrimeFactors ( n ) :\n    product = 1\n    if ( n % 2 == 0 ) :\n        product *= 2\n        while ( n % 2 == 0 ) :\n            n = n / 2\n    for i in range ( 3 , int ( math.sqrt ( n ) ) , 2 ) :\n        if ( n % i == 0 ) :\n            product = product * i\n            while ( n % i == 0 ) :\n                n = n / i\n    if ( n > 2 ) :\n        product = product * n\n    return product\nn = 44\nprint ( int ( productPrimeFactors ( n ) ) )\n", "python_code_tokenized": "import math NEW_LINE def productPrimeFactors ( n ) : NEW_LINE INDENT product = 1 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT product *= 2 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT product = product * i NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = n / i NEW_LINE DEDENT DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT product = product * n NEW_LINE DEDENT return product NEW_LINE DEDENT n = 44 NEW_LINE print ( int ( productPrimeFactors ( n ) ) ) NEW_LINE"}
{"id": "codeforces_1397_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    s = \"\"\n    for i in range ( n ) : s += input ( )\n    s1 = set ( s )\n    for i in s1 :\n        if s.count ( i ) % n != 0 :\n            print ( \"NO\" )\n            break\n    else : print ( \"YES\" )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = \" \" NEW_LINE for i in range ( n ) : s += input ( ) NEW_LINE s1 = set ( s ) NEW_LINE for i in s1 : NEW_LINE INDENT if s . count ( i ) % n != 0 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE break NEW_LINE DEDENT DEDENT else : print ( \" YES \" ) NEW_LINE DEDENT"}
{"id": "codeforces_732_A", "sol": 0, "python_code": "k , r = [ int ( x ) for x in input ( ).split ( ) ]\nb = 10\nc = 1\nwhile True :\n    l = c * k\n    rem = l % b\n    if rem == 0 :\n        print ( c )\n        break\n    elif rem == r :\n        print ( c )\n        break\n    c += 1\n", "python_code_tokenized": "k , r = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE b = 10 NEW_LINE c = 1 NEW_LINE while True : NEW_LINE INDENT l = c * k NEW_LINE rem = l % b NEW_LINE if rem == 0 : NEW_LINE INDENT print ( c ) NEW_LINE break NEW_LINE DEDENT elif rem == r : NEW_LINE INDENT print ( c ) NEW_LINE break NEW_LINE DEDENT c += 1 NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1427_A", "sol": 0, "python_code": "def kthSmallest ( n , k ) :\n    return 2 * k\nn = 8 ; k = 4\nprint ( kthSmallest ( n , k ) )\n", "python_code_tokenized": "def kthSmallest ( n , k ) : NEW_LINE INDENT return 2 * k NEW_LINE DEDENT n = 8 ; k = 4 NEW_LINE print ( kthSmallest ( n , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_4161_A", "sol": 0, "python_code": "def findKthChar ( s , k ) :\n    len1 = len ( s )\n    i = 0\n    total_len = 0\n    while ( i < len1 ) :\n        if ( s [ i ].isalpha ( ) ) :\n            total_len += 1\n            if ( total_len == k ) :\n                return s [ i ]\n            i += 1\n        else :\n            n = 0\n            while ( i < len1 and s [ i ].isalpha ( ) == False ) :\n                n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) )\n                i += 1\n            next_total_len = total_len * n\n            if ( k <= next_total_len ) :\n                pos = k % total_len\n                if ( pos == 0 ) :\n                    pos = total_len\n                return findKthChar ( s , pos )\n            else :\n                total_len = next_total_len\n    return - 1\nif __name__ == '__main__' :\n    s = \"ab2c3\"\n    k = 5\n    print ( findKthChar ( s , k ) )\n", "python_code_tokenized": "def findKthChar ( s , k ) : NEW_LINE INDENT len1 = len ( s ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while ( i < len1 ) : NEW_LINE INDENT if ( s [ i ] . isalpha ( ) ) : NEW_LINE INDENT total_len += 1 NEW_LINE if ( total_len == k ) : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while ( i < len1 and s [ i ] . isalpha ( ) == False ) : NEW_LINE INDENT n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT next_total_len = total_len * n NEW_LINE if ( k <= next_total_len ) : NEW_LINE INDENT pos = k % total_len NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT pos = total_len NEW_LINE DEDENT return findKthChar ( s , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_total_len NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" ab2c3\" NEW_LINE k = 5 NEW_LINE print ( findKthChar ( s , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_949_A", "sol": 0, "python_code": "def countSubarrays ( a , n , x ) :\n    count = 0\n    number = 0\n    for i in range ( n ) :\n        if ( a [ i ] > x ) :\n            count += 1\n        else :\n            number += ( count ) * ( count + 1 ) / 2\n            count = 0\n    if ( count ) :\n        number += ( count ) * ( count + 1 ) / 2\n    return int ( number )\nif __name__ == '__main__' :\n    a = [ 3 , 4 , 5 , 6 , 7 , 2 , 10 , 11 ]\n    n = len ( a )\n    k = 5\n    print ( countSubarrays ( a , n , k ) )\n", "python_code_tokenized": "def countSubarrays ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE number = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number += ( count ) * ( count + 1 ) / 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT if ( count ) : NEW_LINE INDENT number += ( count ) * ( count + 1 ) / 2 NEW_LINE DEDENT return int ( number ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 3 , 4 , 5 , 6 , 7 , 2 , 10 , 11 ] NEW_LINE n = len ( a ) NEW_LINE k = 5 NEW_LINE print ( countSubarrays ( a , n , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4539_A", "sol": 0, "python_code": "BitCount = [ 0 ] * 10000\ndef fillSetBitsmatrix ( arr : list , n : int ) :\n    global BitCount\n    for i in range ( 32 ) :\n        for j in range ( n ) :\n            temp = arr [ j ] >> i\n            if temp % 2 != 0 :\n                BitCount [ j ] += 1\n    for i in range ( 1 , n ) :\n        BitCount [ i ] += BitCount [ i - 1 ]\ndef Query ( Q : list , q : int ) :\n    for i in range ( q ) :\n        print ( BitCount [ Q [ i ] [ 1 ] ] - BitCount [ Q [ i ] [ 0 ] - 1 ] )\nif __name__ == \"__main__\" :\n    Arr = [ 1 , 5 , 6 , 10 , 9 , 4 , 67 ]\n    n = len ( Arr )\n    fillSetBitsmatrix ( Arr , n )\n    q = 2\n    Q = [ ( 1 , 5 ) , ( 2 , 6 ) ]\n    Query ( Q , q )\n", "python_code_tokenized": "BitCount = [ 0 ] * 10000 NEW_LINE def fillSetBitsmatrix ( arr : list , n : int ) : NEW_LINE INDENT global BitCount NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT temp = arr [ j ] >> i NEW_LINE if temp % 2 != 0 : NEW_LINE INDENT BitCount [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT BitCount [ i ] += BitCount [ i - 1 ] NEW_LINE DEDENT DEDENT def Query ( Q : list , q : int ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT print ( BitCount [ Q [ i ] [ 1 ] ] - BitCount [ Q [ i ] [ 0 ] - 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Arr = [ 1 , 5 , 6 , 10 , 9 , 4 , 67 ] NEW_LINE n = len ( Arr ) NEW_LINE fillSetBitsmatrix ( Arr , n ) NEW_LINE q = 2 NEW_LINE Q = [ ( 1 , 5 ) , ( 2 , 6 ) ] NEW_LINE Query ( Q , q ) NEW_LINE DEDENT"}
{"id": "codeforces_1081_B", "sol": 0, "python_code": "def solve ( ) :\n    N = int ( input ( ) )\n    arr = list ( map ( int , input ( ).split ( ) ) )\n    arr = [ N - x for x in arr ]\n    cnt = { }\n    for i , n in enumerate ( arr ) :\n        if n in cnt : cnt [ n ].append ( i )\n        else : cnt [ n ] = [ i ]\n    ans = [ - 1 ] * N\n    cur = 1\n    for c , nums in cnt.items ( ) :\n        l = len ( nums )\n        if l % c != 0 :\n            print ( \"Impossible\" )\n            return\n        else :\n            for i in range ( l // c ) :\n                for j in range ( c ) :\n                    ans [ nums [ i * c + j ] ] = cur\n                cur += 1\n    print ( \"Possible\" )\n    print ( \" \".join ( map ( str , ans ) ) )\nsolve ( )\n", "python_code_tokenized": "def solve ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr = [ N - x for x in arr ] NEW_LINE cnt = { } NEW_LINE for i , n in enumerate ( arr ) : NEW_LINE INDENT if n in cnt : cnt [ n ] . append ( i ) NEW_LINE else : cnt [ n ] = [ i ] NEW_LINE DEDENT ans = [ - 1 ] * N NEW_LINE cur = 1 NEW_LINE for c , nums in cnt . items ( ) : NEW_LINE INDENT l = len ( nums ) NEW_LINE if l % c != 0 : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( l // c ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT ans [ nums [ i * c + j ] ] = cur NEW_LINE DEDENT cur += 1 NEW_LINE DEDENT DEDENT DEDENT print ( \" Possible \" ) NEW_LINE print ( \" \u2581 \" . join ( map ( str , ans ) ) ) NEW_LINE DEDENT solve ( ) NEW_LINE"}
{"id": "aizu_p00093_A", "sol": 0, "python_code": "def isLeap ( y ) :\n    return y % 4 == 0 and ( y % 100 != 0 or y % 400 == 0 )\nflag2 = False\nwhile True :\n    a , b = map ( int , input ( ).split ( ) )\n    if a == 0 : break\n    if flag2 : print ( )\n    flag2 = True\n    flag = True\n    for y in range ( a , b + 1 ) :\n        if isLeap ( y ) :\n            print ( y )\n            flag = False\n    if ( flag ) : print ( \"NA\" )\n", "python_code_tokenized": "def isLeap ( y ) : NEW_LINE INDENT return y % 4 == 0 and ( y % 100 != 0 or y % 400 == 0 ) NEW_LINE DEDENT flag2 = False NEW_LINE while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : break NEW_LINE if flag2 : print ( ) NEW_LINE flag2 = True NEW_LINE flag = True NEW_LINE for y in range ( a , b + 1 ) : NEW_LINE INDENT if isLeap ( y ) : NEW_LINE INDENT print ( y ) NEW_LINE flag = False NEW_LINE DEDENT DEDENT if ( flag ) : print ( \" NA \" ) NEW_LINE DEDENT"}
{"id": "codeforces_555_A", "sol": 0, "python_code": "n , k = m = map ( int , input ( ).split ( ) )\nans = 0\nfor _ in range ( k ) :\n    l = list ( map ( int , input ( ).split ( ) ) )\n    ans += l [ 0 ] - 1\n    p = - 20\n    for x in l [ 1 : ] :\n        if x == 1 : p = 0\n        elif p != - 20 :\n            if p + 2 == x : p += 1\n            else : ans -= p ; p = - 20\n    if p != - 20 : ans -= p\nans *= 2\nans += k - 1\nprint ( ans )\n", "python_code_tokenized": "n , k = m = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for _ in range ( k ) : NEW_LINE INDENT l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans += l [ 0 ] - 1 NEW_LINE p = - 20 NEW_LINE for x in l [ 1 : ] : NEW_LINE INDENT if x == 1 : p = 0 NEW_LINE elif p != - 20 : NEW_LINE INDENT if p + 2 == x : p += 1 NEW_LINE else : ans -= p ; p = - 20 NEW_LINE DEDENT DEDENT if p != - 20 : ans -= p NEW_LINE DEDENT ans *= 2 NEW_LINE ans += k - 1 NEW_LINE print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_1306_A", "sol": 0, "python_code": "def factorial ( n ) :\n    res = 1\n    for i in range ( 1 , n + 1 ) :\n        res = res * i\n    return res\ndef count ( word ) :\n    freq = [ 0 for i in range ( 30 ) ]\n    vowel = 0\n    consonant = 0\n    for i in range ( len ( word ) ) :\n        freq [ ord ( word [ i ] ) - 65 ] += 1\n        if ( word [ i ] == 'A' or word [ i ] == 'E' or word [ i ] == 'I' or word [ i ] == 'O' or word [ i ] == 'U' ) :\n            vowel += 1\n        else :\n            consonant += 1\n    vowelArrange = factorial ( vowel )\n    vowelArrange //= factorial ( freq [ 0 ] )\n    vowelArrange //= factorial ( freq [ 4 ] )\n    vowelArrange //= factorial ( freq [ 8 ] )\n    vowelArrange //= factorial ( freq [ 14 ] )\n    vowelArrange //= factorial ( freq [ 20 ] )\n    consonantArrange = factorial ( consonant )\n    for i in range ( 26 ) :\n        if ( i != 0 and i != 4 and i != 8 and i != 14 and i != 20 ) :\n            consonantArrange //= factorial ( freq [ i ] )\n    total = vowelArrange * consonantArrange\n    return total\nword = \"COMPUTER\"\nans = count ( word )\nprint ( ans )\n", "python_code_tokenized": "def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def count ( word ) : NEW_LINE INDENT freq = [ 0 for i in range ( 30 ) ] NEW_LINE vowel = 0 NEW_LINE consonant = 0 NEW_LINE for i in range ( len ( word ) ) : NEW_LINE INDENT freq [ ord ( word [ i ] ) - 65 ] += 1 NEW_LINE if ( word [ i ] == ' A ' or word [ i ] == ' E ' or word [ i ] == ' I ' or word [ i ] == ' O ' or word [ i ] == ' U ' ) : NEW_LINE INDENT vowel += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT vowelArrange = factorial ( vowel ) NEW_LINE vowelArrange //= factorial ( freq [ 0 ] ) NEW_LINE vowelArrange //= factorial ( freq [ 4 ] ) NEW_LINE vowelArrange //= factorial ( freq [ 8 ] ) NEW_LINE vowelArrange //= factorial ( freq [ 14 ] ) NEW_LINE vowelArrange //= factorial ( freq [ 20 ] ) NEW_LINE consonantArrange = factorial ( consonant ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( i != 0 and i != 4 and i != 8 and i != 14 and i != 20 ) : NEW_LINE INDENT consonantArrange //= factorial ( freq [ i ] ) NEW_LINE DEDENT DEDENT total = vowelArrange * consonantArrange NEW_LINE return total NEW_LINE DEDENT word = \" COMPUTER \" NEW_LINE ans = count ( word ) NEW_LINE print ( ans ) NEW_LINE"}
{"id": "codeforces_369_A", "sol": 0, "python_code": "n_days , m_bowls , k_plates = map ( int , input ( ).split ( ) )\nwash_counter = 0\nfor type_dish in input ( ).split ( ) :\n    if type_dish == \"1\" :\n        if m_bowls == 0 :\n            wash_counter += 1\n        else :\n            m_bowls -= 1\n    elif type_dish == \"2\" :\n        if k_plates > 0 :\n            k_plates -= 1\n            continue\n        if m_bowls == 0 :\n            wash_counter += 1\n        else :\n            m_bowls -= 1\nprint ( wash_counter )\n", "python_code_tokenized": "n_days , m_bowls , k_plates = map ( int , input ( ) . split ( ) ) NEW_LINE wash_counter = 0 NEW_LINE for type_dish in input ( ) . split ( ) : NEW_LINE INDENT if type_dish == \"1\" : NEW_LINE INDENT if m_bowls == 0 : NEW_LINE INDENT wash_counter += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m_bowls -= 1 NEW_LINE DEDENT DEDENT elif type_dish == \"2\" : NEW_LINE INDENT if k_plates > 0 : NEW_LINE INDENT k_plates -= 1 NEW_LINE continue NEW_LINE DEDENT if m_bowls == 0 : NEW_LINE INDENT wash_counter += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m_bowls -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( wash_counter ) NEW_LINE"}
{"id": "aizu_p00381_A", "sol": 0, "python_code": "N = int ( input ( ) )\ns = input ( )\nt = input ( )\nD = { t [ - 1 ] : 1 }\nfor i in range ( N - 2 , 0 , - 1 ) :\n    si = s [ i ] ; ti = t [ i ]\n    v = D.get ( si , 0 )\n    D [ ti ] = ( D.get ( ti , 0 ) + v ) % ( 10 ** 9 + 7 )\nprint ( D.get ( s [ 0 ] , 0 ) )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE D = { t [ - 1 ] : 1 } NEW_LINE for i in range ( N - 2 , 0 , - 1 ) : NEW_LINE INDENT si = s [ i ] ; ti = t [ i ] NEW_LINE v = D . get ( si , 0 ) NEW_LINE D [ ti ] = ( D . get ( ti , 0 ) + v ) % ( 10 ** 9 + 7 ) NEW_LINE DEDENT print ( D . get ( s [ 0 ] , 0 ) ) NEW_LINE"}
{"id": "geeksforgeeks_3563_A", "sol": 0, "python_code": "def trailingZero ( x ) :\n    i = 5\n    count = 0\n    while ( x > i ) :\n        count = count + x // i\n        i = i * 5\n    return count\ndef countProductTrailing ( M , N ) :\n    return trailingZero ( N ) + trailingZero ( M )\nN = 67\nM = 98\nprint ( countProductTrailing ( N , M ) )\n", "python_code_tokenized": "def trailingZero ( x ) : NEW_LINE INDENT i = 5 NEW_LINE count = 0 NEW_LINE while ( x > i ) : NEW_LINE INDENT count = count + x // i NEW_LINE i = i * 5 NEW_LINE DEDENT return count NEW_LINE DEDENT def countProductTrailing ( M , N ) : NEW_LINE INDENT return trailingZero ( N ) + trailingZero ( M ) NEW_LINE DEDENT N = 67 NEW_LINE M = 98 NEW_LINE print ( countProductTrailing ( N , M ) ) NEW_LINE"}
{"id": "leetcode_628_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def maximumProduct ( self , nums ) :\n        min1 = min2 = float ( 'inf' )\n        max1 = max2 = max3 = float ( '-inf' )\n        for num in nums :\n            if num <= min1 :\n                min2 = min1\n                min1 = num\n            elif num <= min2 :\n                min2 = num\n            if num >= max1 :\n                max3 = max2\n                max2 = max1\n                max1 = num\n            elif num >= max2 :\n                max3 = max2\n                max2 = num\n            elif num >= max3 :\n                max3 = num\n        return max ( min1 * min2 * max1 , max1 * max2 * max3 )\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def maximumProduct ( self , nums ) : NEW_LINE INDENT min1 = min2 = float ( ' inf ' ) NEW_LINE max1 = max2 = max3 = float ( ' - inf ' ) NEW_LINE for num in nums : NEW_LINE INDENT if num <= min1 : NEW_LINE INDENT min2 = min1 NEW_LINE min1 = num NEW_LINE DEDENT elif num <= min2 : NEW_LINE INDENT min2 = num NEW_LINE DEDENT if num >= max1 : NEW_LINE INDENT max3 = max2 NEW_LINE max2 = max1 NEW_LINE max1 = num NEW_LINE DEDENT elif num >= max2 : NEW_LINE INDENT max3 = max2 NEW_LINE max2 = num NEW_LINE DEDENT elif num >= max3 : NEW_LINE INDENT max3 = num NEW_LINE DEDENT DEDENT return max ( min1 * min2 * max1 , max1 * max2 * max3 ) NEW_LINE DEDENT DEDENT"}
{"id": "projecteuler_p211_A", "sol": 0, "python_code": "import array , eulerlib\ndef compute ( ) :\n    LIMIT = 64000000\n    RESIDUE_TEST = 3 * 5 * 7 * 11 * 13\n    isresidue = [ False ] * RESIDUE_TEST\n    for i in range ( RESIDUE_TEST ) :\n        isresidue [ i * i % RESIDUE_TEST ] = True\n    def is_perfect_square ( x ) :\n        return isresidue [ x % RESIDUE_TEST ] and eulerlib.is_square ( x )\n    sigma2 = list_sigma2 ( LIMIT - 1 )\n    ans = sum ( i for i in range ( 1 , LIMIT ) if is_perfect_square ( sigma2 [ i ] ) )\n    return str ( ans )\ndef list_sigma2 ( n ) :\n    sqrt = eulerlib.sqrt ( n )\n    quasiprimefactor = array.array ( \"H\" , ( 0 for _ in range ( n + 1 ) ) )\n    for i in range ( 2 , sqrt + 1 ) :\n        if quasiprimefactor [ i ] == 0 :\n            quasiprimefactor [ i ] = i\n            for j in range ( i * i , n + 1 , i ) :\n                if quasiprimefactor [ j ] == 0 :\n                    quasiprimefactor [ j ] = i\n    sigma2 = array.array ( \"Q\" , ( 0 for _ in range ( n + 1 ) ) )\n    sigma2 [ 1 ] = 1\n    for i in range ( 2 , len ( sigma2 ) ) :\n        p = quasiprimefactor [ i ]\n        if p == 0 :\n            p = i\n        sum = 1\n        j = i\n        p2 = p * p\n        k = p2\n        while j % p == 0 :\n            sum += k\n            j //= p\n            k *= p2\n        sigma2 [ i ] = sum * sigma2 [ j ]\n    return sigma2\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import array , eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 64000000 NEW_LINE RESIDUE_TEST = 3 * 5 * 7 * 11 * 13 NEW_LINE isresidue = [ False ] * RESIDUE_TEST NEW_LINE for i in range ( RESIDUE_TEST ) : NEW_LINE INDENT isresidue [ i * i % RESIDUE_TEST ] = True NEW_LINE DEDENT def is_perfect_square ( x ) : NEW_LINE INDENT return isresidue [ x % RESIDUE_TEST ] and eulerlib . is_square ( x ) NEW_LINE DEDENT sigma2 = list_sigma2 ( LIMIT - 1 ) NEW_LINE ans = sum ( i for i in range ( 1 , LIMIT ) if is_perfect_square ( sigma2 [ i ] ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def list_sigma2 ( n ) : NEW_LINE INDENT sqrt = eulerlib . sqrt ( n ) NEW_LINE quasiprimefactor = array . array ( \" H \" , ( 0 for _ in range ( n + 1 ) ) ) NEW_LINE for i in range ( 2 , sqrt + 1 ) : NEW_LINE INDENT if quasiprimefactor [ i ] == 0 : NEW_LINE INDENT quasiprimefactor [ i ] = i NEW_LINE for j in range ( i * i , n + 1 , i ) : NEW_LINE INDENT if quasiprimefactor [ j ] == 0 : NEW_LINE INDENT quasiprimefactor [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT sigma2 = array . array ( \" Q \" , ( 0 for _ in range ( n + 1 ) ) ) NEW_LINE sigma2 [ 1 ] = 1 NEW_LINE for i in range ( 2 , len ( sigma2 ) ) : NEW_LINE INDENT p = quasiprimefactor [ i ] NEW_LINE if p == 0 : NEW_LINE INDENT p = i NEW_LINE DEDENT sum = 1 NEW_LINE j = i NEW_LINE p2 = p * p NEW_LINE k = p2 NEW_LINE while j % p == 0 : NEW_LINE INDENT sum += k NEW_LINE j //= p NEW_LINE k *= p2 NEW_LINE DEDENT sigma2 [ i ] = sum * sigma2 [ j ] NEW_LINE DEDENT return sigma2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4823_A", "sol": 0, "python_code": "days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] ;\ndef dayOfYear ( date ) :\n    year = ( int ) ( date [ 0 : 4 ] ) ;\n    month = ( int ) ( date [ 5 : 7 ] ) ;\n    day = ( int ) ( date [ 8 : ] ) ;\n    if ( month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) ) :\n        day += 1 ;\n    month -= 1 ;\n    while ( month > 0 ) :\n        day = day + days [ month - 1 ] ;\n        month -= 1 ;\n    return day ;\nif __name__ == '__main__' :\n    date = \"2019-01-09\" ;\n    print ( dayOfYear ( date ) ) ;\n", "python_code_tokenized": "days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] ; NEW_LINE def dayOfYear ( date ) : NEW_LINE INDENT year = ( int ) ( date [ 0 : 4 ] ) ; NEW_LINE month = ( int ) ( date [ 5 : 7 ] ) ; NEW_LINE day = ( int ) ( date [ 8 : ] ) ; NEW_LINE if ( month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) ) : NEW_LINE INDENT day += 1 ; NEW_LINE DEDENT month -= 1 ; NEW_LINE while ( month > 0 ) : NEW_LINE INDENT day = day + days [ month - 1 ] ; NEW_LINE month -= 1 ; NEW_LINE DEDENT return day ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT date = \"2019-01-09\" ; NEW_LINE print ( dayOfYear ( date ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1779_A", "sol": 0, "python_code": "import math\ndef printGreater ( x , y ) :\n    X = y * math.log ( x ) ;\n    Y = x * math.log ( y ) ;\n    if ( abs ( X - Y ) < 1e-9 ) :\n        print ( \"Equal\" ) ;\n    elif ( X > Y ) :\n        print ( x , \"^\" , y ) ;\n    else :\n        print ( y , \"^\" , x ) ;\nx = 5 ;\ny = 8 ;\nprintGreater ( x , y ) ;\n", "python_code_tokenized": "import math NEW_LINE def printGreater ( x , y ) : NEW_LINE INDENT X = y * math . log ( x ) ; NEW_LINE Y = x * math . log ( y ) ; NEW_LINE if ( abs ( X - Y ) < 1e-9 ) : NEW_LINE INDENT print ( \" Equal \" ) ; NEW_LINE DEDENT elif ( X > Y ) : NEW_LINE INDENT print ( x , \" ^ \" , y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( y , \" ^ \" , x ) ; NEW_LINE DEDENT DEDENT x = 5 ; NEW_LINE y = 8 ; NEW_LINE printGreater ( x , y ) ; NEW_LINE"}
{"id": "aizu_p00487_A", "sol": 0, "python_code": "import heapq\ntbl = [ ]\nN = int ( input ( ) )\nfor i in range ( N ) :\n    a , b = map ( int , input ( ).split ( ) )\n    tbl.append ( ( a , b ) )\ntbl.sort ( )\nQ = [ ]\nans = s = sz = 0\nfor t in tbl :\n    s += t [ 0 ]\n    heapq.heappush ( Q , ( t [ 1 ] , t [ 0 ] ) )\n    sz += 1\n    while sz and sz * Q [ 0 ] [ 0 ] < s :\n        s -= Q [ 0 ] [ 1 ]\n        heapq.heappop ( Q )\n        sz -= 1\n    if sz > ans : ans = sz\nprint ( ans )\n", "python_code_tokenized": "import heapq NEW_LINE tbl = [ ] NEW_LINE N = int ( input ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE tbl . append ( ( a , b ) ) NEW_LINE DEDENT tbl . sort ( ) NEW_LINE Q = [ ] NEW_LINE ans = s = sz = 0 NEW_LINE for t in tbl : NEW_LINE INDENT s += t [ 0 ] NEW_LINE heapq . heappush ( Q , ( t [ 1 ] , t [ 0 ] ) ) NEW_LINE sz += 1 NEW_LINE while sz and sz * Q [ 0 ] [ 0 ] < s : NEW_LINE INDENT s -= Q [ 0 ] [ 1 ] NEW_LINE heapq . heappop ( Q ) NEW_LINE sz -= 1 NEW_LINE DEDENT if sz > ans : ans = sz NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "atcoder_AGC041_A", "sol": 0, "python_code": "N , A , B = map ( int , input ( ).split ( ) )\nif ( B - A ) % 2 :\n    print ( min ( A - 1 , N - B ) + ( B + 1 - A ) // 2 )\nelse :\n    print ( ( B - A ) // 2 )\n", "python_code_tokenized": "N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if ( B - A ) % 2 : NEW_LINE INDENT print ( min ( A - 1 , N - B ) + ( B + 1 - A ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( B - A ) // 2 ) NEW_LINE DEDENT"}
{"id": "aizu_p00544_A", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nw = [ ]\nb = [ ]\nr = [ ]\nfor i in range ( n ) :\n    s = input ( )\n    w.append ( m - s.count ( \"W\" ) )\n    b.append ( m - s.count ( \"B\" ) )\n    r.append ( m - s.count ( \"R\" ) )\nans = 3000\nfor i in range ( 1 , n - 1 ) :\n    for j in range ( i , n - 1 ) :\n        ans = min ( ans , sum ( w [ : i ] ) + sum ( b [ i : j + 1 ] ) + sum ( r [ j + 1 : ] ) )\nprint ( ans )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE w = [ ] NEW_LINE b = [ ] NEW_LINE r = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE w . append ( m - s . count ( \" W \" ) ) NEW_LINE b . append ( m - s . count ( \" B \" ) ) NEW_LINE r . append ( m - s . count ( \" R \" ) ) NEW_LINE DEDENT ans = 3000 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT for j in range ( i , n - 1 ) : NEW_LINE INDENT ans = min ( ans , sum ( w [ : i ] ) + sum ( b [ i : j + 1 ] ) + sum ( r [ j + 1 : ] ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "aizu_p01873_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nfor i in range ( 1 , n + 1 ) :\n    if n % i == 0 :\n        for j in range ( n ) :\n            if j >= i and a [ j ] != a [ j - i ] : break\n        else : print ( n // i ) ; exit ( )\nprint ( 1 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if j >= i and a [ j ] != a [ j - i ] : break NEW_LINE DEDENT else : print ( n // i ) ; exit ( ) NEW_LINE DEDENT DEDENT print ( 1 ) NEW_LINE"}
{"id": "geeksforgeeks_5035_A", "sol": 0, "python_code": "import copy\ndef printSmallestSequence ( s ) :\n    m = copy.copy ( s )\n    for i in range ( len ( s ) - 1 ) :\n        if m > s [ i : ] + s [ : i ] :\n            m = s [ i : ] + s [ : i ]\n    return m\nif __name__ == '__main__' :\n    st = 'DCACBCAA'\n    print ( printSmallestSequence ( st ) )\n", "python_code_tokenized": "import copy NEW_LINE def printSmallestSequence ( s ) : NEW_LINE INDENT m = copy . copy ( s ) NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if m > s [ i : ] + s [ : i ] : NEW_LINE INDENT m = s [ i : ] + s [ : i ] NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT st = ' DCACBCAA ' NEW_LINE print ( printSmallestSequence ( st ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC179_C", "sol": 0, "python_code": "N = int ( input ( ) )\ncount = 0\nfor i in range ( 1 , N ) :\n    count += ( N - 1 ) // i\nprint ( count )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT count += ( N - 1 ) // i NEW_LINE DEDENT print ( count ) NEW_LINE"}
{"id": "aizu_p02382_A", "sol": 0, "python_code": "import math\nn = int ( input ( ) )\nx = list ( map ( int , input ( ).split ( ) ) )\ny = list ( map ( int , input ( ).split ( ) ) )\nd1 = 0\nd2 = 0\nd3 = 0\ndmax = 0\nfor i in range ( n ) :\n    d1 += abs ( x [ i ] - y [ i ] )\n    d2 += abs ( x [ i ] - y [ i ] ) ** 2\n    d3 += abs ( x [ i ] - y [ i ] ) ** 3\n    if dmax < abs ( x [ i ] - y [ i ] ) :\n        dmax = abs ( x [ i ] - y [ i ] )\nprint ( d1 )\nprint ( math.sqrt ( d2 ) )\nprint ( d3 ** ( 1.0 / 3.0 ) )\nprint ( dmax )\n", "python_code_tokenized": "import math NEW_LINE n = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d1 = 0 NEW_LINE d2 = 0 NEW_LINE d3 = 0 NEW_LINE dmax = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d1 += abs ( x [ i ] - y [ i ] ) NEW_LINE d2 += abs ( x [ i ] - y [ i ] ) ** 2 NEW_LINE d3 += abs ( x [ i ] - y [ i ] ) ** 3 NEW_LINE if dmax < abs ( x [ i ] - y [ i ] ) : NEW_LINE INDENT dmax = abs ( x [ i ] - y [ i ] ) NEW_LINE DEDENT DEDENT print ( d1 ) NEW_LINE print ( math . sqrt ( d2 ) ) NEW_LINE print ( d3 ** ( 1.0 / 3.0 ) ) NEW_LINE print ( dmax ) NEW_LINE"}
{"id": "codeforces_1358_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor test in range ( t ) :\n    n , m = map ( int , input ( ).split ( ) )\n    area = n * m\n    if area % 2 == 0 :\n        num = int ( area / 2 )\n    else :\n        num = int ( ( area - 1 ) / 2 ) + 1\n    print ( num )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for test in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE area = n * m NEW_LINE if area % 2 == 0 : NEW_LINE INDENT num = int ( area / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT num = int ( ( area - 1 ) / 2 ) + 1 NEW_LINE DEDENT print ( num ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1328_A", "sol": 0, "python_code": "import math\ndef Log2 ( x ) :\n    if x == 0 :\n        return false ;\n    return ( math.log10 ( x ) / math.log10 ( 2 ) ) ;\ndef isPowerOfTwo ( n ) :\n    return ( math.ceil ( Log2 ( n ) ) == math.floor ( Log2 ( n ) ) ) ;\nif ( isPowerOfTwo ( 31 ) ) :\n    print ( \"Yes\" ) ;\nelse :\n    print ( \"No\" ) ;\nif ( isPowerOfTwo ( 64 ) ) :\n    print ( \"Yes\" ) ;\nelse :\n    print ( \"No\" ) ;\n", "python_code_tokenized": "import math NEW_LINE def Log2 ( x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return false ; NEW_LINE DEDENT return ( math . log10 ( x ) / math . log10 ( 2 ) ) ; NEW_LINE DEDENT def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( math . ceil ( Log2 ( n ) ) == math . floor ( Log2 ( n ) ) ) ; NEW_LINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_913_A", "sol": 0, "python_code": "import math\ndef countDigits ( n ) :\n    return int ( n * math.log10 ( 2 ) + 1 ) ;\nn = 5 ;\nprint ( countDigits ( n ) ) ;\n", "python_code_tokenized": "import math NEW_LINE def countDigits ( n ) : NEW_LINE INDENT return int ( n * math . log10 ( 2 ) + 1 ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( countDigits ( n ) ) ; NEW_LINE"}
{"id": "projecteuler_p027_A", "sol": 0, "python_code": "import eulerlib , itertools\ndef compute ( ) :\n    ans = max ( ( ( a , b ) for a in range ( - 999 , 1000 ) for b in range ( 2 , 1000 ) ) , key = count_consecutive_primes )\n    return str ( ans [ 0 ] * ans [ 1 ] )\ndef count_consecutive_primes ( ab ) :\n    a , b = ab\n    for i in itertools.count ( ) :\n        n = i * i + i * a + b\n        if not is_prime ( n ) :\n            return i\nisprimecache = eulerlib.list_primality ( 1000 )\ndef is_prime ( n ) :\n    if n < 0 :\n        return False\n    elif n < len ( isprimecache ) :\n        return isprimecache [ n ]\n    else :\n        return eulerlib.is_prime ( n )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = max ( ( ( a , b ) for a in range ( - 999 , 1000 ) for b in range ( 2 , 1000 ) ) , key = count_consecutive_primes ) NEW_LINE return str ( ans [ 0 ] * ans [ 1 ] ) NEW_LINE DEDENT def count_consecutive_primes ( ab ) : NEW_LINE INDENT a , b = ab NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT n = i * i + i * a + b NEW_LINE if not is_prime ( n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT isprimecache = eulerlib . list_primality ( 1000 ) NEW_LINE def is_prime ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT elif n < len ( isprimecache ) : NEW_LINE INDENT return isprimecache [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return eulerlib . is_prime ( n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02269_A", "sol": 0, "python_code": "import sys\nd = { }\ninput ( )\nfor e in sys.stdin :\n    c , g = e.split ( )\n    if 'i' == c [ 0 ] : d [ g ] = 0\n    else : print ( [ 'no' , 'yes' ] [ g in d ] )\n", "python_code_tokenized": "import sys NEW_LINE d = { } NEW_LINE input ( ) NEW_LINE for e in sys . stdin : NEW_LINE INDENT c , g = e . split ( ) NEW_LINE if ' i ' == c [ 0 ] : d [ g ] = 0 NEW_LINE else : print ( [ ' no ' , ' yes ' ] [ g in d ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_212_A", "sol": 0, "python_code": "import random\ndef printArray ( stream , n ) :\n    for i in range ( n ) :\n        print ( stream [ i ] , end = \" \" ) ;\n    print ( ) ;\ndef selectKItems ( stream , n , k ) :\n    i = 0 ;\n    reservoir = [ 0 ] * k ;\n    for i in range ( k ) :\n        reservoir [ i ] = stream [ i ] ;\n    while ( i < n ) :\n        j = random.randrange ( i + 1 ) ;\n        if ( j < k ) :\n            reservoir [ j ] = stream [ i ] ;\n        i += 1 ;\n    print ( \"Following are k randomly selected items\" ) ;\n    printArray ( reservoir , k ) ;\nif __name__ == \"__main__\" :\n    stream = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ] ;\n    n = len ( stream ) ;\n    k = 5 ;\n    selectKItems ( stream , n , k ) ;\n", "python_code_tokenized": "import random NEW_LINE def printArray ( stream , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( stream [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def selectKItems ( stream , n , k ) : NEW_LINE INDENT i = 0 ; NEW_LINE reservoir = [ 0 ] * k ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT reservoir [ i ] = stream [ i ] ; NEW_LINE DEDENT while ( i < n ) : NEW_LINE INDENT j = random . randrange ( i + 1 ) ; NEW_LINE if ( j < k ) : NEW_LINE INDENT reservoir [ j ] = stream [ i ] ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT print ( \" Following \u2581 are \u2581 k \u2581 randomly \u2581 selected \u2581 items \" ) ; NEW_LINE printArray ( reservoir , k ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT stream = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ] ; NEW_LINE n = len ( stream ) ; NEW_LINE k = 5 ; NEW_LINE selectKItems ( stream , n , k ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3520_A", "sol": 0, "python_code": "def product ( A ) :\n    N = 100010\n    mod = 1000000007\n    prime = [ 1 ] * N\n    prime [ 0 ] = prime [ 1 ] = 0\n    i = 2\n    while i * i < N :\n        if prime [ i ] :\n            for j in range ( i * i , N , i ) :\n                prime [ j ] = 0\n        i += 1\n    n = len ( A )\n    t = pow ( 2 , n - 1 , mod - 1 )\n    ans = 1\n    for i in A :\n        if prime [ i ] :\n            ans *= pow ( i , t , mod )\n            ans %= mod\n    return ans\nA = [ 3 , 7 ]\nprint ( product ( A ) )\n", "python_code_tokenized": "def product ( A ) : NEW_LINE INDENT N = 100010 NEW_LINE mod = 1000000007 NEW_LINE prime = [ 1 ] * N NEW_LINE prime [ 0 ] = prime [ 1 ] = 0 NEW_LINE i = 2 NEW_LINE while i * i < N : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT for j in range ( i * i , N , i ) : NEW_LINE INDENT prime [ j ] = 0 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT n = len ( A ) NEW_LINE t = pow ( 2 , n - 1 , mod - 1 ) NEW_LINE ans = 1 NEW_LINE for i in A : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT ans *= pow ( i , t , mod ) NEW_LINE ans %= mod NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT A = [ 3 , 7 ] NEW_LINE print ( product ( A ) ) NEW_LINE"}
{"id": "aizu_p02245_A", "sol": 0, "python_code": "from collections import deque\nN = 3\nm = { 8 : { 7 , 5 } , 7 : { 8 , 6 , 4 } , 6 : { 7 , 3 } , 5 : { 8 , 4 , 2 } , 4 : { 7 , 5 , 3 , 1 } , 3 : { 6 , 4 , 0 } , 2 : { 5 , 1 } , 1 : { 4 , 2 , 0 } , 0 : { 3 , 1 } }\ngoal = 123456780\ndef g ( i , j , a ) :\n    t = a // ( 10 ** j ) % 10\n    return a - t * ( 10 ** j ) + t * ( 10 ** i )\ndef solve ( ) :\n    MAP = \"\".join ( input ( ).replace ( \"\" , \"\" ) for _ in range ( N ) )\n    zero = 8 - MAP.find ( \"0\" )\n    start = int ( MAP )\n    if start == goal :\n        return 0\n    dp = deque ( [ ( 0 , start , zero , 1 ) , ( 0 , goal , 0 , 0 ) ] )\n    TABLE = { start : ( 1 , 0 ) , goal : ( 0 , 0 ) }\n    while dp :\n        cnt , M , yx , flg = dp.popleft ( )\n        cnt += 1\n        for nyx in m [ yx ] :\n            key = g ( yx , nyx , M )\n            if key in TABLE :\n                if TABLE [ key ] [ 0 ] != flg :\n                    return TABLE [ key ] [ 1 ] + cnt\n                continue\n            TABLE [ key ] = ( flg , cnt )\n            dp.append ( ( cnt , key , nyx , flg ) )\ndef MAIN ( ) :\n    print ( solve ( ) )\nMAIN ( )\n", "python_code_tokenized": "from collections import deque NEW_LINE N = 3 NEW_LINE m = { 8 : { 7 , 5 } , 7 : { 8 , 6 , 4 } , 6 : { 7 , 3 } , 5 : { 8 , 4 , 2 } , 4 : { 7 , 5 , 3 , 1 } , 3 : { 6 , 4 , 0 } , 2 : { 5 , 1 } , 1 : { 4 , 2 , 0 } , 0 : { 3 , 1 } } NEW_LINE goal = 123456780 NEW_LINE def g ( i , j , a ) : NEW_LINE INDENT t = a // ( 10 ** j ) % 10 NEW_LINE return a - t * ( 10 ** j ) + t * ( 10 ** i ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT MAP = \" \" . join ( input ( ) . replace ( \" \u2581 \" , \" \" ) for _ in range ( N ) ) NEW_LINE zero = 8 - MAP . find ( \"0\" ) NEW_LINE start = int ( MAP ) NEW_LINE if start == goal : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = deque ( [ ( 0 , start , zero , 1 ) , ( 0 , goal , 0 , 0 ) ] ) NEW_LINE TABLE = { start : ( 1 , 0 ) , goal : ( 0 , 0 ) } NEW_LINE while dp : NEW_LINE INDENT cnt , M , yx , flg = dp . popleft ( ) NEW_LINE cnt += 1 NEW_LINE for nyx in m [ yx ] : NEW_LINE INDENT key = g ( yx , nyx , M ) NEW_LINE if key in TABLE : NEW_LINE INDENT if TABLE [ key ] [ 0 ] != flg : NEW_LINE INDENT return TABLE [ key ] [ 1 ] + cnt NEW_LINE DEDENT continue NEW_LINE DEDENT TABLE [ key ] = ( flg , cnt ) NEW_LINE dp . append ( ( cnt , key , nyx , flg ) ) NEW_LINE DEDENT DEDENT DEDENT def MAIN ( ) : NEW_LINE INDENT print ( solve ( ) ) NEW_LINE DEDENT MAIN ( ) NEW_LINE"}
{"id": "codeforces_967_A", "sol": 0, "python_code": "f = 1\nn , s = map ( int , input ( ).split ( ) )\nh , m = map ( int , input ( ).split ( ) )\nh1 , m1 = h , m\nif h * 60 + m - s > 0 :\n    print ( 0 , 0 )\n    f = 0\nfor i in range ( n ) :\n    g1 = h1 * 60 + m1\n    g2 = h * 60 + m\n    if g2 - g1 > 2 * s + 1 and f == 1 :\n        print ( ( g1 + s + 1 ) // 60 , ( g1 + s + 1 ) % 60 )\n        f = 0\n    h1 , m1 = h , m\n    if i != n - 1 :\n        h , m = map ( int , input ( ).split ( ) )\nif f == 1 :\n    g1 = h1 * 60 + m1\n    print ( ( g1 + s + 1 ) // 60 , ( g1 + s + 1 ) % 60 )\n", "python_code_tokenized": "f = 1 NEW_LINE n , s = map ( int , input ( ) . split ( ) ) NEW_LINE h , m = map ( int , input ( ) . split ( ) ) NEW_LINE h1 , m1 = h , m NEW_LINE if h * 60 + m - s > 0 : NEW_LINE INDENT print ( 0 , 0 ) NEW_LINE f = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT g1 = h1 * 60 + m1 NEW_LINE g2 = h * 60 + m NEW_LINE if g2 - g1 > 2 * s + 1 and f == 1 : NEW_LINE INDENT print ( ( g1 + s + 1 ) // 60 , ( g1 + s + 1 ) % 60 ) NEW_LINE f = 0 NEW_LINE DEDENT h1 , m1 = h , m NEW_LINE if i != n - 1 : NEW_LINE INDENT h , m = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT DEDENT if f == 1 : NEW_LINE INDENT g1 = h1 * 60 + m1 NEW_LINE print ( ( g1 + s + 1 ) // 60 , ( g1 + s + 1 ) % 60 ) NEW_LINE DEDENT"}
{"id": "codeforces_741_A", "sol": 0, "python_code": "from fractions import gcd\nn = int ( input ( ) )\narr_list = list ( map ( int , input ( ).split ( ) ) )\narr_2 = [ 0 ] * n\nans = 1\nfor i in range ( n ) :\n    if ( arr_2 [ i ] ) :\n        continue\n    num = i\n    j = 0\n    while not arr_2 [ num ] :\n        arr_2 [ num ] = 1\n        num = arr_list [ num ] - 1\n        j += 1\n    if ( i != num ) :\n        ans = - 1\n        break\n    else :\n        if ( j % 2 == 0 ) :\n            j //= 2\n        ans = ans * j // gcd ( ans , j )\nprint ( ans )\n", "python_code_tokenized": "from fractions import gcd NEW_LINE n = int ( input ( ) ) NEW_LINE arr_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr_2 = [ 0 ] * n NEW_LINE ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr_2 [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT num = i NEW_LINE j = 0 NEW_LINE while not arr_2 [ num ] : NEW_LINE INDENT arr_2 [ num ] = 1 NEW_LINE num = arr_list [ num ] - 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( i != num ) : NEW_LINE INDENT ans = - 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT if ( j % 2 == 0 ) : NEW_LINE INDENT j //= 2 NEW_LINE DEDENT ans = ans * j // gcd ( ans , j ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "atcoder_ABC054_A", "sol": 0, "python_code": "import sys\nimport bisect\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nn , m = map ( int , readline ( ).split ( ) )\nif n == m :\n    print ( \"Draw\" )\nelif n == 1 or m == 1 :\n    if n == 1 :\n        print ( \"Alice\" )\n    else :\n        print ( \"Bob\" )\nelse :\n    if n > m :\n        print ( \"Alice\" )\n    else :\n        print ( \"Bob\" )\n", "python_code_tokenized": "import sys NEW_LINE import bisect NEW_LINE read = sys . stdin . buffer . read NEW_LINE readline = sys . stdin . buffer . readline NEW_LINE readlines = sys . stdin . buffer . readlines NEW_LINE n , m = map ( int , readline ( ) . split ( ) ) NEW_LINE if n == m : NEW_LINE INDENT print ( \" Draw \" ) NEW_LINE DEDENT elif n == 1 or m == 1 : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( \" Alice \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Bob \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if n > m : NEW_LINE INDENT print ( \" Alice \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Bob \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1009_A", "sol": 0, "python_code": "def games ( c , a ) :\n    k = 0\n    for i in c :\n        if a == [ ] :\n            return k\n        if i <= a [ 0 ] :\n            a.pop ( 0 )\n            k += 1\n    return k\nnm = input ( )\na = [ int ( i ) for i in input ( ).split ( ) ]\nb = [ int ( i ) for i in input ( ).split ( ) ]\nprint ( games ( a , b ) )\n", "python_code_tokenized": "def games ( c , a ) : NEW_LINE INDENT k = 0 NEW_LINE for i in c : NEW_LINE INDENT if a == [ ] : NEW_LINE INDENT return k NEW_LINE DEDENT if i <= a [ 0 ] : NEW_LINE INDENT a . pop ( 0 ) NEW_LINE k += 1 NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT nm = input ( ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE print ( games ( a , b ) ) NEW_LINE"}
{"id": "codeforces_559_A", "sol": 0, "python_code": "a1 , a2 , a3 , a4 , a5 , a6 = input ( ).split ( )\na = int ( a2 ) + int ( a1 ) + int ( a3 )\ns = a ** 2 - ( int ( a1 ) ** 2 + int ( a3 ) ** 2 + int ( a5 ) ** 2 )\nprint ( s )\n", "python_code_tokenized": "a1 , a2 , a3 , a4 , a5 , a6 = input ( ) . split ( ) NEW_LINE a = int ( a2 ) + int ( a1 ) + int ( a3 ) NEW_LINE s = a ** 2 - ( int ( a1 ) ** 2 + int ( a3 ) ** 2 + int ( a5 ) ** 2 ) NEW_LINE print ( s ) NEW_LINE"}
{"id": "aizu_p02423_A", "sol": 0, "python_code": "x = int ( input ( ) )\nprint ( f'{x:032b}' )\nprint ( f'{~x & 0xffffffff:032b}' )\nprint ( f'{x << 1 & 0xffffffff:032b}' )\nprint ( f'{x >> 1:032b}' )\n", "python_code_tokenized": "x = int ( input ( ) ) NEW_LINE print ( f ' { x : 032b } ' ) NEW_LINE print ( f ' { ~ x \u2581 & \u2581 0xffffffff : 032b } ' ) NEW_LINE print ( f ' { x \u2581 < < \u2581 1 \u2581 & \u2581 0xffffffff : 032b } ' ) NEW_LINE print ( f ' { x \u2581 > > \u2581 1:032b } ' ) NEW_LINE"}
{"id": "codeforces_766_A", "sol": 0, "python_code": "a = input ( )\nb = input ( )\nif a == b :\n    print ( \"-1\" )\nelse :\n    x = len ( a )\n    z = len ( b )\n    print ( max ( x , z ) )\n", "python_code_tokenized": "a = input ( ) NEW_LINE b = input ( ) NEW_LINE if a == b : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT x = len ( a ) NEW_LINE z = len ( b ) NEW_LINE print ( max ( x , z ) ) NEW_LINE DEDENT"}
{"id": "codeforces_344_B", "sol": 0, "python_code": "a , b , c = [ int ( x ) for x in input ( ).split ( ) ]\nz = ( int ) ( 1 / 2 * ( c + b - a ) )\ny = ( int ) ( b - z )\nx = ( int ) ( a - y )\nimposible = False\nif ( c + b - a ) % 2 != 0 :\n    imposible = True\nelif ( a + b + c ) % 2 != 0 :\n    imposible = True\nelif ( x < 0 or y < 0 or z < 0 ) :\n    imposible = True\nif ( imposible ) :\n    print ( \"Impossible\" )\nelse :\n    print ( y , z , x )\n", "python_code_tokenized": "a , b , c = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE z = ( int ) ( 1 / 2 * ( c + b - a ) ) NEW_LINE y = ( int ) ( b - z ) NEW_LINE x = ( int ) ( a - y ) NEW_LINE imposible = False NEW_LINE if ( c + b - a ) % 2 != 0 : NEW_LINE INDENT imposible = True NEW_LINE DEDENT elif ( a + b + c ) % 2 != 0 : NEW_LINE INDENT imposible = True NEW_LINE DEDENT elif ( x < 0 or y < 0 or z < 0 ) : NEW_LINE INDENT imposible = True NEW_LINE DEDENT if ( imposible ) : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( y , z , x ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3329_A", "sol": 0, "python_code": "def firstNonRepeating ( arr , n ) :\n    for i in range ( n ) :\n        j = 0\n        while ( j < n ) :\n            if ( i != j and arr [ i ] == arr [ j ] ) :\n                break\n            j += 1\n        if ( j == n ) :\n            return arr [ i ]\n    return - 1\narr = [ 9 , 4 , 9 , 6 , 7 , 4 ]\nn = len ( arr )\nprint ( firstNonRepeating ( arr , n ) )\n", "python_code_tokenized": "def firstNonRepeating ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( i != j and arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 9 , 4 , 9 , 6 , 7 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( firstNonRepeating ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1407_A", "sol": 0, "python_code": "def printPairs ( arr , n ) :\n    for i in range ( n ) :\n        for j in range ( n ) :\n            print ( \"(\" , arr [ i ] , \",\" , arr [ j ] , \")\" , end = \", \" )\narr = [ 1 , 2 ]\nn = len ( arr )\nprintPairs ( arr , n )\n", "python_code_tokenized": "def printPairs ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( \" ( \" , arr [ i ] , \" , \" , arr [ j ] , \" ) \" , end = \" , \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE printPairs ( arr , n ) NEW_LINE"}
{"id": "codeforces_343_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\nx = a\ny = b\ncount = 0\nwhile x != 1 and y != 1 :\n    if x >= y :\n        num = x\n        den = y\n        new1 = num // den\n        count += new1\n        new2 = num - ( new1 * den )\n        x = new2\n    else :\n        num = y\n        den = x\n        new1 = num // den\n        count += new1\n        new2 = num - ( new1 * den )\n        y = new2\nprint ( count + max ( x , y ) )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE x = a NEW_LINE y = b NEW_LINE count = 0 NEW_LINE while x != 1 and y != 1 : NEW_LINE INDENT if x >= y : NEW_LINE INDENT num = x NEW_LINE den = y NEW_LINE new1 = num // den NEW_LINE count += new1 NEW_LINE new2 = num - ( new1 * den ) NEW_LINE x = new2 NEW_LINE DEDENT else : NEW_LINE INDENT num = y NEW_LINE den = x NEW_LINE new1 = num // den NEW_LINE count += new1 NEW_LINE new2 = num - ( new1 * den ) NEW_LINE y = new2 NEW_LINE DEDENT DEDENT print ( count + max ( x , y ) ) NEW_LINE"}
{"id": "aizu_p02414_A", "sol": 0, "python_code": "n , m , l = map ( int , input ( ).split ( ) )\nA = [ ]\nB = [ ]\nfor i in range ( n ) : A.append ( list ( map ( int , input ( ).split ( ) ) ) )\nfor j in range ( m ) : B.append ( list ( map ( int , input ( ).split ( ) ) ) )\nfor A_r in A :\n    print ( \" \".join ( map ( str , [ sum ( [ x * y for x , y in zip ( A_r , [ B_r [ k ] for B_r in B ] ) ] ) for k in range ( l ) ] ) ) )\n", "python_code_tokenized": "n , m , l = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ ] NEW_LINE B = [ ] NEW_LINE for i in range ( n ) : A . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE for j in range ( m ) : B . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE for A_r in A : NEW_LINE INDENT print ( \" \u2581 \" . join ( map ( str , [ sum ( [ x * y for x , y in zip ( A_r , [ B_r [ k ] for B_r in B ] ) ] ) for k in range ( l ) ] ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1885_A", "sol": 0, "python_code": "def setBitNumber ( n ) :\n    if ( n == 0 ) :\n        return 0 ;\n    msb = 0 ;\n    while ( n > 0 ) :\n        n = int ( n / 2 ) ;\n        msb += 1 ;\n    return ( 1 << msb ) ;\nn = 0 ;\nprint ( setBitNumber ( n ) ) ;\n", "python_code_tokenized": "def setBitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT msb = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = int ( n / 2 ) ; NEW_LINE msb += 1 ; NEW_LINE DEDENT return ( 1 << msb ) ; NEW_LINE DEDENT n = 0 ; NEW_LINE print ( setBitNumber ( n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_2560_A", "sol": 0, "python_code": "import math\ndef perfectSquare ( s ) :\n    n = len ( s )\n    ans = - 1\n    num = \"\"\n    for i in range ( 1 , ( 1 << n ) ) :\n        str = \"\"\n        for j in range ( 0 , n ) :\n            if ( ( i >> j ) & 1 ) :\n                str = str + s [ j ]\n        if ( str [ 0 ] != '0' ) :\n            temp = 0 ;\n            for j in range ( 0 , len ( str ) ) :\n                temp = ( temp * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) )\n            k = int ( math.sqrt ( temp ) )\n            if ( k * k == temp ) :\n                if ( ans < len ( str ) ) :\n                    ans = len ( str )\n                    num = str\n    if ( ans == - 1 ) :\n        return ans\n    else :\n        print ( \"{} \".format ( num ) , end = \"\" )\n        return n - ans\nprint ( perfectSquare ( \"8314\" ) )\nprint ( perfectSquare ( \"753\" ) ) ;\n", "python_code_tokenized": "import math NEW_LINE def perfectSquare ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = - 1 NEW_LINE num = \" \" NEW_LINE for i in range ( 1 , ( 1 << n ) ) : NEW_LINE INDENT str = \" \" NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( i >> j ) & 1 ) : NEW_LINE INDENT str = str + s [ j ] NEW_LINE DEDENT DEDENT if ( str [ 0 ] != '0' ) : NEW_LINE INDENT temp = 0 ; NEW_LINE for j in range ( 0 , len ( str ) ) : NEW_LINE INDENT temp = ( temp * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) ) NEW_LINE DEDENT k = int ( math . sqrt ( temp ) ) NEW_LINE if ( k * k == temp ) : NEW_LINE INDENT if ( ans < len ( str ) ) : NEW_LINE INDENT ans = len ( str ) NEW_LINE num = str NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( ans == - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" { } \u2581 \" . format ( num ) , end = \" \" ) NEW_LINE return n - ans NEW_LINE DEDENT DEDENT print ( perfectSquare ( \"8314\" ) ) NEW_LINE print ( perfectSquare ( \"753\" ) ) ; NEW_LINE"}
{"id": "atcoder_ABC136_B", "sol": 0, "python_code": "n = int ( input ( ) )\ncnt = 0\nfor i in range ( 1 , n + 1 ) :\n    s = str ( i )\n    if len ( s ) % 2 == 1 :\n        cnt += 1\nprint ( cnt )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = str ( i ) NEW_LINE if len ( s ) % 2 == 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE"}
{"id": "codeforces_784_A", "sol": 0, "python_code": "a = [ 4 , 22 , 27 , 58 , 85 , 94 , 121 , 166 , 202 , 265 , 274 , 319 , 346 , 355 , 378 , 382 , 391 , 438 , 454 , 483 , 517 , 526 , 535 , 562 , 576 , 588 , 627 , 634 , 636 , 645 ]\nx = int ( input ( ) )\nprint ( a [ x - 1 ] )\n", "python_code_tokenized": "a = [ 4 , 22 , 27 , 58 , 85 , 94 , 121 , 166 , 202 , 265 , 274 , 319 , 346 , 355 , 378 , 382 , 391 , 438 , 454 , 483 , 517 , 526 , 535 , 562 , 576 , 588 , 627 , 634 , 636 , 645 ] NEW_LINE x = int ( input ( ) ) NEW_LINE print ( a [ x - 1 ] ) NEW_LINE"}
{"id": "geeksforgeeks_1108_A", "sol": 0, "python_code": "def isSubArray ( A , B , n , m ) :\n    i = 0 ; j = 0 ;\n    while ( i < n and j < m ) :\n        if ( A [ i ] == B [ j ] ) :\n            i += 1 ;\n            j += 1 ;\n            if ( j == m ) :\n                return True ;\n        else :\n            i = i - j + 1 ;\n            j = 0 ;\n    return False ;\nif __name__ == '__main__' :\n    A = [ 2 , 3 , 0 , 5 , 1 , 1 , 2 ] ;\n    n = len ( A ) ;\n    B = [ 3 , 0 , 5 , 1 ] ;\n    m = len ( B ) ;\n    if ( isSubArray ( A , B , n , m ) ) :\n        print ( \"YES\" ) ;\n    else :\n        print ( \"NO\" ) ;\n", "python_code_tokenized": "def isSubArray ( A , B , n , m ) : NEW_LINE INDENT i = 0 ; j = 0 ; NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( A [ i ] == B [ j ] ) : NEW_LINE INDENT i += 1 ; NEW_LINE j += 1 ; NEW_LINE if ( j == m ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i = i - j + 1 ; NEW_LINE j = 0 ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 2 , 3 , 0 , 5 , 1 , 1 , 2 ] ; NEW_LINE n = len ( A ) ; NEW_LINE B = [ 3 , 0 , 5 , 1 ] ; NEW_LINE m = len ( B ) ; NEW_LINE if ( isSubArray ( A , B , n , m ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4945_A", "sol": 0, "python_code": "def pattern ( nos , i , space ) :\n    prt = '$'\n    for s in range ( nos , 0 , - 1 ) :\n        print ( end = \"  \" )\n    for j in range ( 1 , i + 1 ) :\n        if ( space != 0 ) :\n            if ( i == 9 and j == 1 ) :\n                continue\n        if ( i == 1 or i == 9 ) :\n            print ( prt , end = \"\" )\n        elif ( j == 1 or j == i ) :\n            print ( prt , end = \"\" )\n        else :\n            print ( end = \"  \" )\nif __name__ == \"__main__\" :\n    nos = 0\n    nosp = - 1\n    nbsp = - 1\n    for i in range ( 9 , 0 , - 2 ) :\n        pattern ( nos , i , 0 )\n        pattern ( nosp , i , 1 )\n        pattern ( nbsp , i , 1 )\n        print ( )\n        nos += 1\n        nosp = nosp + 2\n        nbsp = nbsp + 2\n    nos = 3\n    nosp = 5\n    nbsp = 5\n    for i in range ( 3 , 10 , 2 ) :\n        pattern ( nos , i , 0 )\n        pattern ( nosp , i , 1 )\n        pattern ( nbsp , i , 1 )\n        print ( )\n        nos -= 1\n        nosp = nosp - 2\n        nbsp = nbsp - 2\n", "python_code_tokenized": "def pattern ( nos , i , space ) : NEW_LINE INDENT prt = ' $ ' NEW_LINE for s in range ( nos , 0 , - 1 ) : NEW_LINE INDENT print ( end = \" \u2581 \u2581 \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( space != 0 ) : NEW_LINE INDENT if ( i == 9 and j == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT if ( i == 1 or i == 9 ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT elif ( j == 1 or j == i ) : NEW_LINE INDENT print ( prt , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end = \" \u2581 \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT nos = 0 NEW_LINE nosp = - 1 NEW_LINE nbsp = - 1 NEW_LINE for i in range ( 9 , 0 , - 2 ) : NEW_LINE INDENT pattern ( nos , i , 0 ) NEW_LINE pattern ( nosp , i , 1 ) NEW_LINE pattern ( nbsp , i , 1 ) NEW_LINE print ( ) NEW_LINE nos += 1 NEW_LINE nosp = nosp + 2 NEW_LINE nbsp = nbsp + 2 NEW_LINE DEDENT nos = 3 NEW_LINE nosp = 5 NEW_LINE nbsp = 5 NEW_LINE for i in range ( 3 , 10 , 2 ) : NEW_LINE INDENT pattern ( nos , i , 0 ) NEW_LINE pattern ( nosp , i , 1 ) NEW_LINE pattern ( nbsp , i , 1 ) NEW_LINE print ( ) NEW_LINE nos -= 1 NEW_LINE nosp = nosp - 2 NEW_LINE nbsp = nbsp - 2 NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3962_A", "sol": 0, "python_code": "def isPalin ( str ) :\n    l = len ( str ) // 2\n    for i in range ( l ) :\n        if ( str [ i ] != str [ len ( str ) - i - 1 ] ) :\n            return False\n    return True\ndef palindromicPath ( str , a , i , j , m , n ) :\n    if ( j < m - 1 or i < n - 1 ) :\n        if ( i < n - 1 ) :\n            palindromicPath ( str + a [ i ] [ j ] , a , i + 1 , j , m , n )\n        if ( j < m - 1 ) :\n            palindromicPath ( str + a [ i ] [ j ] , a , i , j + 1 , m , n )\n    else :\n        str = str + a [ n - 1 ] [ m - 1 ]\n        if isPalin ( str ) :\n            print ( str )\nif __name__ == \"__main__\" :\n    arr = [ [ 'a' , 'a' , 'a' , 'b' ] , [ 'b' , 'a' , 'a' , 'a' ] , [ 'a' , 'b' , 'b' , 'a' ] ]\n    str = \"\"\n    palindromicPath ( str , arr , 0 , 0 , 4 , 3 )\n", "python_code_tokenized": "def isPalin ( str ) : NEW_LINE INDENT l = len ( str ) // 2 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] != str [ len ( str ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def palindromicPath ( str , a , i , j , m , n ) : NEW_LINE INDENT if ( j < m - 1 or i < n - 1 ) : NEW_LINE INDENT if ( i < n - 1 ) : NEW_LINE INDENT palindromicPath ( str + a [ i ] [ j ] , a , i + 1 , j , m , n ) NEW_LINE DEDENT if ( j < m - 1 ) : NEW_LINE INDENT palindromicPath ( str + a [ i ] [ j ] , a , i , j + 1 , m , n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT str = str + a [ n - 1 ] [ m - 1 ] NEW_LINE if isPalin ( str ) : NEW_LINE INDENT print ( str ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ ' a ' , ' a ' , ' a ' , ' b ' ] , [ ' b ' , ' a ' , ' a ' , ' a ' ] , [ ' a ' , ' b ' , ' b ' , ' a ' ] ] NEW_LINE str = \" \" NEW_LINE palindromicPath ( str , arr , 0 , 0 , 4 , 3 ) NEW_LINE DEDENT"}
{"id": "codeforces_875_A", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\ndef solve ( n ) :\n    c = 0\n    while n :\n        c += n % 10\n        n //= 10\n    return c\nn = input ( ) [ : - 1 ]\nx = len ( n ) * 9\nn = int ( n )\nd = [ ]\nfor i in range ( n , max ( n - x - 1 , - 1 ) , - 1 ) :\n    if i + solve ( i ) == n :\n        d.append ( i )\nprint ( len ( d ) )\nfor i in d [ : : - 1 ] :\n    print ( i )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while n : NEW_LINE INDENT c += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return c NEW_LINE DEDENT n = input ( ) [ : - 1 ] NEW_LINE x = len ( n ) * 9 NEW_LINE n = int ( n ) NEW_LINE d = [ ] NEW_LINE for i in range ( n , max ( n - x - 1 , - 1 ) , - 1 ) : NEW_LINE INDENT if i + solve ( i ) == n : NEW_LINE INDENT d . append ( i ) NEW_LINE DEDENT DEDENT print ( len ( d ) ) NEW_LINE for i in d [ : : - 1 ] : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_624_A", "sol": 0, "python_code": "import math as mt\ndef findAndSum ( arr , n ) :\n    Sum = 0\n    mul = 1\n    for i in range ( 30 ) :\n        count_on = 0\n        l = 0\n        for j in range ( n ) :\n            if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) :\n                if ( count_on ) :\n                    l += 1\n                else :\n                    count_on = 1\n                    l += 1\n            elif ( count_on ) :\n                Sum += ( ( mul * l * ( l + 1 ) ) // 2 )\n                count_on = 0\n                l = 0\n        if ( count_on ) :\n            Sum += ( ( mul * l * ( l + 1 ) ) // 2 )\n            count_on = 0\n            l = 0\n        mul *= 2\n    return Sum\narr = [ 7 , 1 , 1 , 5 ]\nn = len ( arr )\nprint ( findAndSum ( arr , n ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def findAndSum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT count_on = 0 NEW_LINE l = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT if ( count_on ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_on = 1 NEW_LINE l += 1 NEW_LINE DEDENT DEDENT elif ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) // 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT DEDENT if ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) // 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT arr = [ 7 , 1 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAndSum ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_472_A", "sol": 0, "python_code": "n = int ( input ( ) )\nif n == 12 :\n    print ( 4 , 8 )\nelif n != 12 and n % 2 == 0 :\n    print ( 10 , n - 10 )\nelif n % 2 != 0 :\n    print ( 9 , n - 9 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE if n == 12 : NEW_LINE INDENT print ( 4 , 8 ) NEW_LINE DEDENT elif n != 12 and n % 2 == 0 : NEW_LINE INDENT print ( 10 , n - 10 ) NEW_LINE DEDENT elif n % 2 != 0 : NEW_LINE INDENT print ( 9 , n - 9 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5213_A", "sol": 0, "python_code": "arrSize = 51\ndp = [ 0 for i in range ( arrSize ) ]\nv = [ False for i in range ( arrSize ) ]\ndef sumMax ( i , arr , n ) :\n    if ( i >= n - 1 ) :\n        return 0\n    if ( v [ i ] ) :\n        return dp [ i ]\n    v [ i ] = True\n    dp [ i ] = max ( arr [ i ] + arr [ i + 1 ] + sumMax ( i + 3 , arr , n ) , sumMax ( i + 1 , arr , n ) )\n    return dp [ i ]\nif __name__ == '__main__' :\n    arr = [ 1 , 1 , 1 , 1 ]\n    n = len ( arr )\n    print ( sumMax ( 0 , arr , n ) )\n", "python_code_tokenized": "arrSize = 51 NEW_LINE dp = [ 0 for i in range ( arrSize ) ] NEW_LINE v = [ False for i in range ( arrSize ) ] NEW_LINE def sumMax ( i , arr , n ) : NEW_LINE INDENT if ( i >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] ) : NEW_LINE INDENT return dp [ i ] NEW_LINE DEDENT v [ i ] = True NEW_LINE dp [ i ] = max ( arr [ i ] + arr [ i + 1 ] + sumMax ( i + 3 , arr , n ) , sumMax ( i + 1 , arr , n ) ) NEW_LINE return dp [ i ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sumMax ( 0 , arr , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_441_B", "sol": 0, "python_code": "read = lambda : map ( int , input ( ).split ( ) )\nn , v = read ( )\nN = 3002\np = [ 0 ] * N\nfor i in range ( n ) :\n    a , b = read ( )\n    p [ a ] += b\nans = 0\nrem = 0\nfor i in range ( 1 , N ) :\n    cur = min ( v , rem + p [ i ] )\n    ans += cur\n    if rem >= v : rem = p [ i ]\n    else : rem = max ( 0 , p [ i ] - ( v - rem ) )\nprint ( ans )\n", "python_code_tokenized": "read = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE n , v = read ( ) NEW_LINE N = 3002 NEW_LINE p = [ 0 ] * N NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = read ( ) NEW_LINE p [ a ] += b NEW_LINE DEDENT ans = 0 NEW_LINE rem = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT cur = min ( v , rem + p [ i ] ) NEW_LINE ans += cur NEW_LINE if rem >= v : rem = p [ i ] NEW_LINE else : rem = max ( 0 , p [ i ] - ( v - rem ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_2340_A", "sol": 0, "python_code": "import math\ndef check ( n ) :\n    d = int ( math.sqrt ( n ) )\n    if ( d * d == n ) :\n        return True\n    return False\ndef largestNonPerfectSquareNumber ( a , n ) :\n    maxi = - 1\n    for i in range ( 0 , n ) :\n        if ( check ( a [ i ] ) == False ) :\n            maxi = max ( a [ i ] , maxi )\n    return maxi\na = [ 16 , 20 , 25 , 2 , 3 , 10 ]\nn = len ( a )\nprint ( largestNonPerfectSquareNumber ( a , n ) )\n", "python_code_tokenized": "import math NEW_LINE def check ( n ) : NEW_LINE INDENT d = int ( math . sqrt ( n ) ) NEW_LINE if ( d * d == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestNonPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( check ( a [ i ] ) == False ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestNonPerfectSquareNumber ( a , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4060_A", "sol": 0, "python_code": "def sum ( k , n ) :\n    sum = ( pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) ) ;\n    return sum ;\nn = 3 ;\nK = 3 ;\nprint ( sum ( K , n ) ) ;\n", "python_code_tokenized": "def sum ( k , n ) : NEW_LINE INDENT sum = ( pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 3 ; NEW_LINE K = 3 ; NEW_LINE print ( sum ( K , n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_4003_A", "sol": 0, "python_code": "import math as mt\ndef sph ( r , R , h ) :\n    if ( r < 0 and R < 0 and h < 0 ) :\n        return - 1\n    x = r\n    V = ( 4 * 3.14 * pow ( r , 3 ) ) / 3\n    return V\nr , R , h = 5 , 8 , 11\nprint ( sph ( r , R , h ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def sph ( r , R , h ) : NEW_LINE INDENT if ( r < 0 and R < 0 and h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = r NEW_LINE V = ( 4 * 3.14 * pow ( r , 3 ) ) / 3 NEW_LINE return V NEW_LINE DEDENT r , R , h = 5 , 8 , 11 NEW_LINE print ( sph ( r , R , h ) ) NEW_LINE"}
{"id": "projecteuler_p123_A", "sol": 0, "python_code": "import eulerlib\ndef compute ( ) :\n    primes = eulerlib.list_primes ( 1000000 )\n    for n in range ( 5 , len ( primes ) , 2 ) :\n        rem = n * primes [ n - 1 ] * 2\n        if rem > 10000000000 :\n            return str ( n )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT primes = eulerlib . list_primes ( 1000000 ) NEW_LINE for n in range ( 5 , len ( primes ) , 2 ) : NEW_LINE INDENT rem = n * primes [ n - 1 ] * 2 NEW_LINE if rem > 10000000000 : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_510_B", "sol": 0, "python_code": "def dfs ( x , y , x1 , y1 ) :\n    v.add ( ( x , y ) )\n    for dx , dy in [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] :\n        if x + dx >= 0 and x + dx < n and y + dy >= 0 and y + dy < m and ( x + dx , y + dy ) != ( x1 , y1 ) and a [ x + dx ] [ y + dy ] == a [ x ] [ y ] :\n            if ( x + dx , y + dy ) in v or dfs ( x + dx , y + dy , x , y ) :\n                return True\n    return False\nimport sys\nsys.setrecursionlimit ( 10000 )\nn , m = map ( int , input ( ).split ( ) )\na = [ input ( ) for i in range ( n ) ]\nv = set ( )\nfor i in range ( n ) :\n    for j in range ( m ) :\n        if not ( i , j ) in v and dfs ( i , j , - 1 , - 1 ) :\n            print ( 'Yes' )\n            quit ( )\nprint ( 'No' )\n", "python_code_tokenized": "def dfs ( x , y , x1 , y1 ) : NEW_LINE INDENT v . add ( ( x , y ) ) NEW_LINE for dx , dy in [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] : NEW_LINE INDENT if x + dx >= 0 and x + dx < n and y + dy >= 0 and y + dy < m and ( x + dx , y + dy ) != ( x1 , y1 ) and a [ x + dx ] [ y + dy ] == a [ x ] [ y ] : NEW_LINE INDENT if ( x + dx , y + dy ) in v or dfs ( x + dx , y + dy , x , y ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT import sys NEW_LINE sys . setrecursionlimit ( 10000 ) NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ input ( ) for i in range ( n ) ] NEW_LINE v = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if not ( i , j ) in v and dfs ( i , j , - 1 , - 1 ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE quit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( ' No ' ) NEW_LINE"}
{"id": "geeksforgeeks_4383_A", "sol": 0, "python_code": "import math\np = ( 1 + math.sqrt ( 5 ) ) / 2\nq = ( 1 - math.sqrt ( 5 ) ) / 2\ndef fib ( n ) :\n    i = n - 1\n    x = ( p ** i - q ** i ) / ( p - q )\n    return int ( x )\nn = 5\nprint ( fib ( n ) )\n", "python_code_tokenized": "import math NEW_LINE p = ( 1 + math . sqrt ( 5 ) ) / 2 NEW_LINE q = ( 1 - math . sqrt ( 5 ) ) / 2 NEW_LINE def fib ( n ) : NEW_LINE INDENT i = n - 1 NEW_LINE x = ( p ** i - q ** i ) / ( p - q ) NEW_LINE return int ( x ) NEW_LINE DEDENT n = 5 NEW_LINE print ( fib ( n ) ) NEW_LINE"}
{"id": "codeforces_1199_A", "sol": 0, "python_code": "n , x , y = map ( int , input ( ).split ( ) )\narr = list ( map ( int , input ( ).split ( ) ) )\nans = 0\nfor i in range ( n ) :\n    take = True\n    for j in range ( max ( 0 , i - x ) , min ( n - 1 , i + y ) + 1 ) :\n        if i != j and arr [ i ] >= arr [ j ] :\n            take = False\n    if take : print ( i + 1 ) ; break\n", "python_code_tokenized": "n , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT take = True NEW_LINE for j in range ( max ( 0 , i - x ) , min ( n - 1 , i + y ) + 1 ) : NEW_LINE INDENT if i != j and arr [ i ] >= arr [ j ] : NEW_LINE INDENT take = False NEW_LINE DEDENT DEDENT if take : print ( i + 1 ) ; break NEW_LINE DEDENT"}
{"id": "atcoder_ARC066_A", "sol": 0, "python_code": "from collections import Counter\ndef powmod ( a , n , m ) :\n    ans = 1\n    while n != 0 :\n        if n & 1 : ans = ans * a % m\n        a = a * a % m\n        n >>= 1\n    return ans % m\nn = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\na.sort ( )\ndic = Counter ( a )\nif n % 2 == 0 :\n    temp = { }\n    for i in range ( 1 , n , 2 ) :\n        temp [ i ] = 2\n    if temp != dict ( dic ) :\n        print ( 0 )\n        exit ( )\nelse :\n    temp = { }\n    temp [ 0 ] = 1\n    for i in range ( 2 , n , 2 ) :\n        temp [ i ] = 2\n    if temp != dict ( dic ) :\n        print ( 0 )\n        exit ( )\nprint ( powmod ( 2 , n // 2 , 10 ** 9 + 7 ) )\n", "python_code_tokenized": "from collections import Counter NEW_LINE def powmod ( a , n , m ) : NEW_LINE INDENT ans = 1 NEW_LINE while n != 0 : NEW_LINE INDENT if n & 1 : ans = ans * a % m NEW_LINE a = a * a % m NEW_LINE n >>= 1 NEW_LINE DEDENT return ans % m NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE dic = Counter ( a ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT temp = { } NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT temp [ i ] = 2 NEW_LINE DEDENT if temp != dict ( dic ) : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp = { } NEW_LINE temp [ 0 ] = 1 NEW_LINE for i in range ( 2 , n , 2 ) : NEW_LINE INDENT temp [ i ] = 2 NEW_LINE DEDENT if temp != dict ( dic ) : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( powmod ( 2 , n // 2 , 10 ** 9 + 7 ) ) NEW_LINE"}
{"id": "aizu_p01989_A", "sol": 0, "python_code": "def check ( num ) :\n    if num == \"\" : return False\n    if num [ 0 ] == \"0\" : return num == \"0\"\n    return 0 <= int ( num ) <= 255\ns = input ( )\nans = 0\nfor i in range ( 1 , 4 ) :\n    for j in range ( 1 , 4 ) :\n        for k in range ( 1 , 4 ) :\n            n1 = s [ : i ]\n            n2 = s [ i : i + j ]\n            n3 = s [ i + j : i + j + k ]\n            n4 = s [ i + j + k : ]\n            if check ( n1 ) and check ( n2 ) and check ( n3 ) and check ( n4 ) : ans += 1\nprint ( ans )\n", "python_code_tokenized": "def check ( num ) : NEW_LINE INDENT if num == \" \" : return False NEW_LINE if num [ 0 ] == \"0\" : return num == \"0\" NEW_LINE return 0 <= int ( num ) <= 255 NEW_LINE DEDENT s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , 4 ) : NEW_LINE INDENT for j in range ( 1 , 4 ) : NEW_LINE INDENT for k in range ( 1 , 4 ) : NEW_LINE INDENT n1 = s [ : i ] NEW_LINE n2 = s [ i : i + j ] NEW_LINE n3 = s [ i + j : i + j + k ] NEW_LINE n4 = s [ i + j + k : ] NEW_LINE if check ( n1 ) and check ( n2 ) and check ( n3 ) and check ( n4 ) : ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_2281_A", "sol": 0, "python_code": "def find_count ( ele ) :\n    count = 0\n    for i in range ( len ( ele ) ) :\n        p = [ ]\n        c = 0\n        j = len ( ele ) - 1\n        while j >= ( len ( ele ) - 1 - i ) and j >= 0 :\n            p.append ( ele [ j ] )\n            j -= 1\n        j = len ( ele ) - 1\n        k = 0\n        while j >= 0 :\n            if ele [ j ] != p [ k ] :\n                break\n            j -= 1\n            k += 1\n            if k == len ( p ) :\n                c += 1\n                k = 0\n        count = max ( count , c )\n    return count\ndef solve ( n ) :\n    count = 1\n    ele = [ ]\n    for i in range ( n ) :\n        print ( count , end = \" \" )\n        ele.append ( count )\n        count = find_count ( ele )\nif __name__ == \"__main__\" :\n    n = 10\n    solve ( n )\n", "python_code_tokenized": "def find_count ( ele ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( ele ) ) : NEW_LINE INDENT p = [ ] NEW_LINE c = 0 NEW_LINE j = len ( ele ) - 1 NEW_LINE while j >= ( len ( ele ) - 1 - i ) and j >= 0 : NEW_LINE INDENT p . append ( ele [ j ] ) NEW_LINE j -= 1 NEW_LINE DEDENT j = len ( ele ) - 1 NEW_LINE k = 0 NEW_LINE while j >= 0 : NEW_LINE INDENT if ele [ j ] != p [ k ] : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE if k == len ( p ) : NEW_LINE INDENT c += 1 NEW_LINE k = 0 NEW_LINE DEDENT DEDENT count = max ( count , c ) NEW_LINE DEDENT return count NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT count = 1 NEW_LINE ele = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( count , end = \" \u2581 \" ) NEW_LINE ele . append ( count ) NEW_LINE count = find_count ( ele ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE solve ( n ) NEW_LINE DEDENT"}
{"id": "aizu_p01809_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    while b : a , b = b , a % b\n    return a\nif __name__ == \"__main__\" :\n    a , b = map ( int , input ( ).split ( ) )\n    b //= gcd ( a , b )\n    a , c = 2 , 1\n    while a ** 2 <= b :\n        if b % a == 0 :\n            c *= a\n            while b % a == 0 : b //= a\n        a += 1\n    print ( c if b == 1 else c * b )\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT while b : a , b = b , a % b NEW_LINE return a NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE b //= gcd ( a , b ) NEW_LINE a , c = 2 , 1 NEW_LINE while a ** 2 <= b : NEW_LINE INDENT if b % a == 0 : NEW_LINE INDENT c *= a NEW_LINE while b % a == 0 : b //= a NEW_LINE DEDENT a += 1 NEW_LINE DEDENT print ( c if b == 1 else c * b ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5235_A", "sol": 0, "python_code": "def ReplaceElementsByFrequency ( arr , n ) :\n    mp = { i : 0 for i in range ( len ( arr ) ) }\n    for i in range ( n ) :\n        mp [ arr [ i ] ] += 1\n    for i in range ( n ) :\n        arr [ i ] = mp [ arr [ i ] ]\nif __name__ == '__main__' :\n    arr = [ 1 , 2 , 5 , 2 , 2 , 5 ]\n    n = len ( arr )\n    ReplaceElementsByFrequency ( arr , n ) ;\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" )\n", "python_code_tokenized": "def ReplaceElementsByFrequency ( arr , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( len ( arr ) ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = mp [ arr [ i ] ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 2 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElementsByFrequency ( arr , n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3769_A", "sol": 0, "python_code": "def ReplaceElements ( arr , n ) :\n    mp = dict ( )\n    for i in range ( n ) :\n        mp [ arr [ i ] ] = mp.get ( arr [ i ] , 0 ) + 1\n    for i in range ( n ) :\n        arr [ i ] = n - mp [ arr [ i ] ]\narr = [ 1 , 2 , 5 , 2 , 2 , 5 , 4 ]\nn = len ( arr )\nReplaceElements ( arr , n )\nfor i in range ( n ) :\n    print ( arr [ i ] , end = \" \" )\n", "python_code_tokenized": "def ReplaceElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = n - mp [ arr [ i ] ] NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 5 , 2 , 2 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3812_A", "sol": 0, "python_code": "def remove ( arr , n ) :\n    m = dict.fromkeys ( arr , 0 ) ;\n    for i in range ( n ) :\n        m [ arr [ i ] ] += 1 ;\n    for i in range ( n ) :\n        if ( ( m [ arr [ i ] ] & 1 ) ) :\n            continue ;\n        print ( arr [ i ] , end = \", \" ) ;\nif __name__ == \"__main__\" :\n    arr = [ 3 , 3 , 3 , 2 , 2 , 4 , 7 , 7 ] ;\n    n = len ( arr ) ;\n    remove ( arr , n ) ;\n", "python_code_tokenized": "def remove ( arr , n ) : NEW_LINE INDENT m = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( ( m [ arr [ i ] ] & 1 ) ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT print ( arr [ i ] , end = \" , \u2581 \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 3 , 2 , 2 , 4 , 7 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE remove ( arr , n ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1074_A", "sol": 0, "python_code": "from math import sqrt\ndef sortPerfectSquare ( arr , n ) :\n    v1 = [ ]\n    v2 = [ ]\n    for i in range ( n ) :\n        b = sqrt ( arr [ i ] )\n        a = int ( b )\n        if a == b :\n            v1.append ( i )\n            v2.append ( arr [ i ] )\n    v2.sort ( )\n    j = 0\n    for i in range ( n ) :\n        if v1 [ j ] == i :\n            arr [ i ] = v2 [ j ]\n            j += 1\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" )\nif __name__ == \"__main__\" :\n    arr = [ 9 , 44 , 100 , 81 , 21 , 64 ]\n    n = len ( arr )\n    sortPerfectSquare ( arr , n ) ;\n", "python_code_tokenized": "from math import sqrt NEW_LINE def sortPerfectSquare ( arr , n ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b = sqrt ( arr [ i ] ) NEW_LINE a = int ( b ) NEW_LINE if a == b : NEW_LINE INDENT v1 . append ( i ) NEW_LINE v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v2 . sort ( ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if v1 [ j ] == i : NEW_LINE INDENT arr [ i ] = v2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 9 , 44 , 100 , 81 , 21 , 64 ] NEW_LINE n = len ( arr ) NEW_LINE sortPerfectSquare ( arr , n ) ; NEW_LINE DEDENT"}
{"id": "aizu_p01390_A", "sol": 0, "python_code": "dic = { }\nfor num1 in range ( ord ( \"a\" ) , ord ( \"z\" ) + 1 ) :\n    c1 = chr ( num1 )\n    dic [ c1 ] = [ ]\n    for num2 in range ( ord ( \"a\" ) , ord ( \"z\" ) + 1 ) :\n        c2 = chr ( num2 )\n        for num3 in range ( ord ( \"a\" ) , ord ( \"z\" ) + 1 ) :\n            c3 = chr ( num3 )\n            dic [ c1 ].append ( c1 + c2 + c3 + \"a\" )\nprint ( \"?\" + dic [ \"a\" ].pop ( ) )\nused = set ( )\nwhile True :\n    s = input ( )\n    if s in used or s [ 0 ] != \"a\" :\n        print ( \"!OUT\" )\n        break\n    used.add ( s )\n    print ( \"?\" + dic [ s [ - 1 ] ].pop ( ) )\n", "python_code_tokenized": "dic = { } NEW_LINE for num1 in range ( ord ( \" a \" ) , ord ( \" z \" ) + 1 ) : NEW_LINE INDENT c1 = chr ( num1 ) NEW_LINE dic [ c1 ] = [ ] NEW_LINE for num2 in range ( ord ( \" a \" ) , ord ( \" z \" ) + 1 ) : NEW_LINE INDENT c2 = chr ( num2 ) NEW_LINE for num3 in range ( ord ( \" a \" ) , ord ( \" z \" ) + 1 ) : NEW_LINE INDENT c3 = chr ( num3 ) NEW_LINE dic [ c1 ] . append ( c1 + c2 + c3 + \" a \" ) NEW_LINE DEDENT DEDENT DEDENT print ( \" ? \" + dic [ \" a \" ] . pop ( ) ) NEW_LINE used = set ( ) NEW_LINE while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s in used or s [ 0 ] != \" a \" : NEW_LINE INDENT print ( \" ! OUT \" ) NEW_LINE break NEW_LINE DEDENT used . add ( s ) NEW_LINE print ( \" ? \" + dic [ s [ - 1 ] ] . pop ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1327_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor test in range ( t ) :\n    n , k = map ( int , input ( ).split ( ) )\n    if k == 1 :\n        if n % 2 == 1 :\n            print ( 'YES' )\n        else :\n            print ( 'NO' )\n    else :\n        if n <= k :\n            print ( 'NO' )\n        else :\n            if n % 2 == 0 and k % 2 == 1 :\n                print ( 'NO' )\n            elif n % 2 == 1 and k % 2 == 0 :\n                print ( 'NO' )\n            else :\n                x = 2 * k - 1\n                min_sum = ( ( 1 + x ) ** 2 ) / 4\n                if min_sum > n :\n                    print ( 'NO' )\n                elif min_sum == n :\n                    print ( 'YES' )\n                else :\n                    if ( n - min_sum ) % 2 == 0 :\n                        print ( 'YES' )\n                    else :\n                        print ( 'NO' )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for test in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k == 1 : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if n <= k : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 2 == 0 and k % 2 == 1 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT elif n % 2 == 1 and k % 2 == 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT x = 2 * k - 1 NEW_LINE min_sum = ( ( 1 + x ) ** 2 ) / 4 NEW_LINE if min_sum > n : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT elif min_sum == n : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n - min_sum ) % 2 == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_1834_A", "sol": 0, "python_code": "def nthTerm ( n ) :\n    return 4 * pow ( n , 2 ) - 7 * n + 3\nN = 4\nprint ( nthTerm ( N ) )\n", "python_code_tokenized": "def nthTerm ( n ) : NEW_LINE INDENT return 4 * pow ( n , 2 ) - 7 * n + 3 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE"}
{"id": "geeksforgeeks_3749_A", "sol": 0, "python_code": "M = 100\nmemo = [ [ 0 for i in range ( M ) ] for j in range ( M ) ]\ndef numberOfPermWithKInversion ( N , K ) :\n    if ( N == 0 ) : return 0\n    if ( K == 0 ) : return 1\n    if ( memo [ N ] [ K ] != 0 ) :\n        return memo [ N ] [ K ]\n    sum = 0\n    for i in range ( K + 1 ) :\n        if ( i <= N - 1 ) :\n            sum += numberOfPermWithKInversion ( N - 1 , K - i )\n    memo [ N ] [ K ] = sum\n    return sum\nN = 4 ; K = 2\nprint ( numberOfPermWithKInversion ( N , K ) )\n", "python_code_tokenized": "M = 100 NEW_LINE memo = [ [ 0 for i in range ( M ) ] for j in range ( M ) ] NEW_LINE def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : return 0 NEW_LINE if ( K == 0 ) : return 1 NEW_LINE if ( memo [ N ] [ K ] != 0 ) : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOfPermWithKInversion ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT N = 4 ; K = 2 NEW_LINE print ( numberOfPermWithKInversion ( N , K ) ) NEW_LINE"}
{"id": "codeforces_1256_B", "sol": 0, "python_code": "def find_ans ( arr : list ) -> list :\n    if len ( arr ) == 0 :\n        return [ ]\n    if len ( arr ) == 1 :\n        return arr\n    if len ( arr ) == 2 :\n        return [ min ( arr ) , max ( arr ) ]\n    i = arr.index ( min ( arr ) )\n    if i != 0 :\n        return [ min ( arr ) ] + arr [ : i - 1 ] + find_ans ( [ arr [ i - 1 ] ] + arr [ i + 1 : ] )\n    else :\n        return [ min ( arr ) ] + find_ans ( arr [ 1 : ] )\nfor _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    arr = list ( map ( int , input ( ).split ( ) ) )\n    print ( * find_ans ( arr ) )\n", "python_code_tokenized": "def find_ans ( arr : list ) -> list : NEW_LINE INDENT if len ( arr ) == 0 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT if len ( arr ) == 1 : NEW_LINE INDENT return arr NEW_LINE DEDENT if len ( arr ) == 2 : NEW_LINE INDENT return [ min ( arr ) , max ( arr ) ] NEW_LINE DEDENT i = arr . index ( min ( arr ) ) NEW_LINE if i != 0 : NEW_LINE INDENT return [ min ( arr ) ] + arr [ : i - 1 ] + find_ans ( [ arr [ i - 1 ] ] + arr [ i + 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return [ min ( arr ) ] + find_ans ( arr [ 1 : ] ) NEW_LINE DEDENT DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( * find_ans ( arr ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC173_A", "sol": 0, "python_code": "n = int ( input ( ) )\nprint ( ( ( n + 999 ) // 1000 * 1000 ) - n )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE print ( ( ( n + 999 ) // 1000 * 1000 ) - n ) NEW_LINE"}
{"id": "aizu_p01677_A", "sol": 0, "python_code": "INF = float ( 'inf' )\ndef judge ( src ) :\n    x_max = INF\n    x_min = - INF\n    for i , ( s1 , s2 ) in enumerate ( zip ( src , src [ 1 : ] ) ) :\n        if s1 == s2 :\n            return 'none'\n        if i % 2 :\n            s1 , s2 = s2 , s1\n        if s1 != 'x' and s2 != 'x' :\n            if s1 < s2 :\n                return 'none'\n            else :\n                continue\n        if s1 == 'x' :\n            if x_max <= s2 :\n                return 'none'\n            x_min = max ( x_min , s2 + 1 )\n        elif s2 == 'x' :\n            if s1 <= x_min :\n                return 'none'\n            x_max = min ( x_max , s1 - 1 )\n        if x_max < x_min :\n            return 'none'\n    return x_max if x_max == x_min else 'ambiguous'\nwhile True :\n    N = int ( input ( ) )\n    if N == 0 : break\n    src = [ INF ] + list ( map ( lambda x : x if x == 'x' else int ( x ) , input ( ).split ( ) ) ) + [ INF if N % 2 else - INF ]\n    print ( judge ( src ) )\n", "python_code_tokenized": "INF = float ( ' inf ' ) NEW_LINE def judge ( src ) : NEW_LINE INDENT x_max = INF NEW_LINE x_min = - INF NEW_LINE for i , ( s1 , s2 ) in enumerate ( zip ( src , src [ 1 : ] ) ) : NEW_LINE INDENT if s1 == s2 : NEW_LINE INDENT return ' none ' NEW_LINE DEDENT if i % 2 : NEW_LINE INDENT s1 , s2 = s2 , s1 NEW_LINE DEDENT if s1 != ' x ' and s2 != ' x ' : NEW_LINE INDENT if s1 < s2 : NEW_LINE INDENT return ' none ' NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT if s1 == ' x ' : NEW_LINE INDENT if x_max <= s2 : NEW_LINE INDENT return ' none ' NEW_LINE DEDENT x_min = max ( x_min , s2 + 1 ) NEW_LINE DEDENT elif s2 == ' x ' : NEW_LINE INDENT if s1 <= x_min : NEW_LINE INDENT return ' none ' NEW_LINE DEDENT x_max = min ( x_max , s1 - 1 ) NEW_LINE DEDENT if x_max < x_min : NEW_LINE INDENT return ' none ' NEW_LINE DEDENT DEDENT return x_max if x_max == x_min else ' ambiguous ' NEW_LINE DEDENT while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : break NEW_LINE src = [ INF ] + list ( map ( lambda x : x if x == ' x ' else int ( x ) , input ( ) . split ( ) ) ) + [ INF if N % 2 else - INF ] NEW_LINE print ( judge ( src ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00423_A", "sol": 0, "python_code": "import fileinput\ninput = fileinput.input ( )\nwhile True :\n    n = int ( next ( input ).strip ( ) )\n    if not n : break\n    t = [ 0 , 0 ]\n    for _ in range ( n ) :\n        [ a , b ] = map ( int , next ( input ).strip ( ).split ( ) )\n        if a == b :\n            t [ 0 ] += a\n            t [ 1 ] += b\n        else :\n            t [ a < b ] += a + b\n    print ( ' '.join ( map ( str , t ) ) )\n", "python_code_tokenized": "import fileinput NEW_LINE input = fileinput . input ( ) NEW_LINE while True : NEW_LINE INDENT n = int ( next ( input ) . strip ( ) ) NEW_LINE if not n : break NEW_LINE t = [ 0 , 0 ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT [ a , b ] = map ( int , next ( input ) . strip ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT t [ 0 ] += a NEW_LINE t [ 1 ] += b NEW_LINE DEDENT else : NEW_LINE INDENT t [ a < b ] += a + b NEW_LINE DEDENT DEDENT print ( ' \u2581 ' . join ( map ( str , t ) ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1220_B", "sol": 0, "python_code": "from math import sqrt\nfrom typing import List\ndef restore_table ( n : int , M : List [ List [ int ] ] ) -> List [ int ] :\n    ans = [ 0 ] * n\n    for i in range ( n ) :\n        if i == 0 :\n            a , b = 1 , 2\n        elif i == n - 1 :\n            a , b = n - 3 , n - 2\n        else :\n            a , b = i - 1 , i + 1\n        ans [ i ] = int ( sqrt ( M [ i ] [ a ] * M [ i ] [ b ] // M [ a ] [ b ] ) )\n    return ans\nn = int ( input ( ) )\nc = [ ]\nfor i in range ( n ) :\n    b = [ int ( j ) for j in input ( ).split ( ) ]\n    c.append ( b )\na = restore_table ( n , c )\nprint ( * a )\n", "python_code_tokenized": "from math import sqrt NEW_LINE from typing import List NEW_LINE def restore_table ( n : int , M : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT ans = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT a , b = 1 , 2 NEW_LINE DEDENT elif i == n - 1 : NEW_LINE INDENT a , b = n - 3 , n - 2 NEW_LINE DEDENT else : NEW_LINE INDENT a , b = i - 1 , i + 1 NEW_LINE DEDENT ans [ i ] = int ( sqrt ( M [ i ] [ a ] * M [ i ] [ b ] // M [ a ] [ b ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b = [ int ( j ) for j in input ( ) . split ( ) ] NEW_LINE c . append ( b ) NEW_LINE DEDENT a = restore_table ( n , c ) NEW_LINE print ( * a ) NEW_LINE"}
{"id": "geeksforgeeks_4912_A", "sol": 0, "python_code": "from math import gcd\ndef convert_str ( s , k ) :\n    modified_string = \"\"\n    for i in range ( 0 , len ( s ) ) :\n        ascii = ord ( s [ i ] )\n        if ( ascii >= ord ( 'a' ) and ascii <= ord ( 'z' ) and gcd ( ascii , k ) == 1 ) :\n            modified_string += chr ( ascii - 32 )\n        else :\n            modified_string += s [ i ]\n    print ( modified_string )\nif __name__ == \"__main__\" :\n    s = \"geeksforgeeks\"\n    k = 4\n    convert_str ( s , k )\n", "python_code_tokenized": "from math import gcd NEW_LINE def convert_str ( s , k ) : NEW_LINE INDENT modified_string = \" \" NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT ascii = ord ( s [ i ] ) NEW_LINE if ( ascii >= ord ( ' a ' ) and ascii <= ord ( ' z ' ) and gcd ( ascii , k ) == 1 ) : NEW_LINE INDENT modified_string += chr ( ascii - 32 ) NEW_LINE DEDENT else : NEW_LINE INDENT modified_string += s [ i ] NEW_LINE DEDENT DEDENT print ( modified_string ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE k = 4 NEW_LINE convert_str ( s , k ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4612_A", "sol": 0, "python_code": "def fib ( f , N ) :\n    f [ 1 ] = 1\n    f [ 2 ] = 1\n    for i in range ( 3 , N + 1 ) :\n        f [ i ] = f [ i - 1 ] + f [ i - 2 ]\ndef fiboTriangle ( n ) :\n    N = n * ( n + 1 ) // 2\n    f = [ 0 ] * ( N + 1 )\n    fib ( f , N )\n    fiboNum = 1\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 1 , i + 1 ) :\n            fiboNum = fiboNum + 1\n            print ( f [ fiboNum ] , \"\" , end = \"\" )\n        print ( )\nn = 5\nfiboTriangle ( n )\n", "python_code_tokenized": "def fib ( f , N ) : NEW_LINE INDENT f [ 1 ] = 1 NEW_LINE f [ 2 ] = 1 NEW_LINE for i in range ( 3 , N + 1 ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] NEW_LINE DEDENT DEDENT def fiboTriangle ( n ) : NEW_LINE INDENT N = n * ( n + 1 ) // 2 NEW_LINE f = [ 0 ] * ( N + 1 ) NEW_LINE fib ( f , N ) NEW_LINE fiboNum = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT fiboNum = fiboNum + 1 NEW_LINE print ( f [ fiboNum ] , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE fiboTriangle ( n ) NEW_LINE"}
{"id": "codeforces_225_B", "sol": 0, "python_code": "s , k = map ( int , input ( ).split ( ) )\nfib_n = [ 0 , 1 ]\nwhile ( fib_n [ - 1 ] <= s ) :\n    fib_n.append ( sum ( fib_n [ - 1 - i ] for i in range ( min ( k , len ( fib_n ) ) ) ) )\ndel fib_n [ 1 ]\ndel fib_n [ 0 ]\ndel fib_n [ - 1 ]\nfoundSeries = [ 0 ]\nfound = False\ndef findBSearch ( total , numbers ) :\n    global found\n    if found :\n        return False\n    global foundSeries\n    if total == 0 :\n        return True\n    elif len ( numbers ) == 0 or total < 0 :\n        return False\n    else :\n        top = len ( numbers ) - 1\n        bottom = 0\n        while abs ( top - bottom ) > 1 :\n            if total > ( numbers [ ( top + bottom ) // 2 ] ) :\n                bottom = ( top + bottom ) // 2\n            else :\n                top = ( top + bottom ) // 2\n        if ( total == numbers [ top ] or total == numbers [ bottom ] ) :\n            foundSeries.append ( total )\n            found = True\n            return True\n        else :\n            if ( findBSearch ( total - numbers [ top ] , numbers [ : top ] + numbers [ top + 1 : ] ) ) :\n                foundSeries.append ( numbers [ top ] )\n                return True\n            elif ( findBSearch ( total - numbers [ bottom ] , numbers [ : bottom ] + numbers [ bottom + 1 : ] ) ) :\n                foundSeries.append ( numbers [ bottom ] )\n                return True\n            else :\n                return False\nfindBSearch ( s , fib_n )\nprint ( len ( foundSeries ) )\nfor i in foundSeries :\n    print ( i , end = \" \" )\n", "python_code_tokenized": "s , k = map ( int , input ( ) . split ( ) ) NEW_LINE fib_n = [ 0 , 1 ] NEW_LINE while ( fib_n [ - 1 ] <= s ) : NEW_LINE INDENT fib_n . append ( sum ( fib_n [ - 1 - i ] for i in range ( min ( k , len ( fib_n ) ) ) ) ) NEW_LINE DEDENT del fib_n [ 1 ] NEW_LINE del fib_n [ 0 ] NEW_LINE del fib_n [ - 1 ] NEW_LINE foundSeries = [ 0 ] NEW_LINE found = False NEW_LINE def findBSearch ( total , numbers ) : NEW_LINE INDENT global found NEW_LINE if found : NEW_LINE INDENT return False NEW_LINE DEDENT global foundSeries NEW_LINE if total == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT elif len ( numbers ) == 0 or total < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT top = len ( numbers ) - 1 NEW_LINE bottom = 0 NEW_LINE while abs ( top - bottom ) > 1 : NEW_LINE INDENT if total > ( numbers [ ( top + bottom ) // 2 ] ) : NEW_LINE INDENT bottom = ( top + bottom ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT top = ( top + bottom ) // 2 NEW_LINE DEDENT DEDENT if ( total == numbers [ top ] or total == numbers [ bottom ] ) : NEW_LINE INDENT foundSeries . append ( total ) NEW_LINE found = True NEW_LINE return True NEW_LINE DEDENT else : NEW_LINE INDENT if ( findBSearch ( total - numbers [ top ] , numbers [ : top ] + numbers [ top + 1 : ] ) ) : NEW_LINE INDENT foundSeries . append ( numbers [ top ] ) NEW_LINE return True NEW_LINE DEDENT elif ( findBSearch ( total - numbers [ bottom ] , numbers [ : bottom ] + numbers [ bottom + 1 : ] ) ) : NEW_LINE INDENT foundSeries . append ( numbers [ bottom ] ) NEW_LINE return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT findBSearch ( s , fib_n ) NEW_LINE print ( len ( foundSeries ) ) NEW_LINE for i in foundSeries : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2353_A", "sol": 0, "python_code": "def replace ( A , B ) :\n    n , m = len ( A ) , len ( B )\n    count , i = 0 , 0\n    while i < n :\n        j = 0\n        while j < m :\n            if i + j >= n or A [ i + j ] != B [ j ] :\n                break\n            j += 1\n        if j == m :\n            count += 1\n            i += m - 1\n        i += 1\n    return count\nif __name__ == \"__main__\" :\n    str1 = \"aaaaaaaa\"\n    str2 = \"aaa\"\n    print ( replace ( str1 , str2 ) )\n", "python_code_tokenized": "def replace ( A , B ) : NEW_LINE INDENT n , m = len ( A ) , len ( B ) NEW_LINE count , i = 0 , 0 NEW_LINE while i < n : NEW_LINE INDENT j = 0 NEW_LINE while j < m : NEW_LINE INDENT if i + j >= n or A [ i + j ] != B [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == m : NEW_LINE INDENT count += 1 NEW_LINE i += m - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" aaaaaaaa \" NEW_LINE str2 = \" aaa \" NEW_LINE print ( replace ( str1 , str2 ) ) NEW_LINE DEDENT"}
{"id": "projecteuler_p151_A", "sol": 0, "python_code": "import eulerlib\ndef compute ( ) :\n    ans = get_expected_singles ( ( 1 , ) ) - 2\n    return f\"{ans:.6f}\"\n@ eulerlib.memoize\ndef get_expected_singles ( state ) :\n    result = 0.0\n    if len ( state ) > 0 :\n        for i in range ( len ( state ) ) :\n            tempstate = list ( state )\n            sheet = state [ i ]\n            del tempstate [ i ]\n            for j in range ( sheet + 1 , 6 ) :\n                tempstate.append ( j )\n            tempstate.sort ( )\n            result += get_expected_singles ( tuple ( tempstate ) )\n        result /= len ( state )\n        if len ( state ) == 1 :\n            result += 1.0\n    return result\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = get_expected_singles ( ( 1 , ) ) - 2 NEW_LINE return f \" { ans : .6f } \" NEW_LINE DEDENT @ eulerlib . memoize NEW_LINE def get_expected_singles ( state ) : NEW_LINE INDENT result = 0.0 NEW_LINE if len ( state ) > 0 : NEW_LINE INDENT for i in range ( len ( state ) ) : NEW_LINE INDENT tempstate = list ( state ) NEW_LINE sheet = state [ i ] NEW_LINE del tempstate [ i ] NEW_LINE for j in range ( sheet + 1 , 6 ) : NEW_LINE INDENT tempstate . append ( j ) NEW_LINE DEDENT tempstate . sort ( ) NEW_LINE result += get_expected_singles ( tuple ( tempstate ) ) NEW_LINE DEDENT result /= len ( state ) NEW_LINE if len ( state ) == 1 : NEW_LINE INDENT result += 1.0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC022_B", "sol": 0, "python_code": "from sys import exit , setrecursionlimit , stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import *\nfrom bisect import bisect\ndef read ( ) :\n    return int ( input ( ) )\ndef reads ( ) :\n    return [ int ( x ) for x in input ( ).split ( ) ]\nls = [ n for n in range ( 2 , 30001 ) if n % 2 == 0 or n % 3 == 0 ]\ndef gcd ( x , y ) :\n    return x if y == 0 else gcd ( y , x % y )\ndef check ( N , ans ) :\n    assert len ( ans ) == len ( set ( ans ) ) == N\n    S = sum ( ans )\n    assert reduce ( gcd , ans ) == 1\n    assert all ( gcd ( S - a , a ) != 1 for a in ans )\ndef solve ( N ) :\n    if N == 3 :\n        return [ 2 , 5 , 63 ]\n    q , r = divmod ( N , 8 )\n    t = q * 8\n    ans = ls [ : t ]\n    if r % 2 == 1 :\n        ans += [ ls [ t + 3 ] ]\n    r //= 2\n    if r == 1 :\n        ans += [ ls [ t ] , ls [ t + 2 ] ]\n    elif r == 2 :\n        ans += ls [ t : t + 3 ] + [ ls [ t + 5 ] ]\n    elif r == 3 :\n        ans += ls [ t : t + 3 ] + ls [ t + 4 : t + 7 ]\n    return ans\nN = read ( )\nprint ( ' '.join ( str ( a ) for a in solve ( N ) ) )\n", "python_code_tokenized": "from sys import exit , setrecursionlimit , stderr NEW_LINE from functools import reduce NEW_LINE from itertools import * NEW_LINE from collections import * NEW_LINE from bisect import bisect NEW_LINE def read ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def reads ( ) : NEW_LINE INDENT return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE DEDENT ls = [ n for n in range ( 2 , 30001 ) if n % 2 == 0 or n % 3 == 0 ] NEW_LINE def gcd ( x , y ) : NEW_LINE INDENT return x if y == 0 else gcd ( y , x % y ) NEW_LINE DEDENT def check ( N , ans ) : NEW_LINE INDENT assert len ( ans ) == len ( set ( ans ) ) == N NEW_LINE S = sum ( ans ) NEW_LINE assert reduce ( gcd , ans ) == 1 NEW_LINE assert all ( gcd ( S - a , a ) != 1 for a in ans ) NEW_LINE DEDENT def solve ( N ) : NEW_LINE INDENT if N == 3 : NEW_LINE INDENT return [ 2 , 5 , 63 ] NEW_LINE DEDENT q , r = divmod ( N , 8 ) NEW_LINE t = q * 8 NEW_LINE ans = ls [ : t ] NEW_LINE if r % 2 == 1 : NEW_LINE INDENT ans += [ ls [ t + 3 ] ] NEW_LINE DEDENT r //= 2 NEW_LINE if r == 1 : NEW_LINE INDENT ans += [ ls [ t ] , ls [ t + 2 ] ] NEW_LINE DEDENT elif r == 2 : NEW_LINE INDENT ans += ls [ t : t + 3 ] + [ ls [ t + 5 ] ] NEW_LINE DEDENT elif r == 3 : NEW_LINE INDENT ans += ls [ t : t + 3 ] + ls [ t + 4 : t + 7 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT N = read ( ) NEW_LINE print ( ' \u2581 ' . join ( str ( a ) for a in solve ( N ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_4031_A", "sol": 0, "python_code": "def check ( s , m ) :\n    l = len ( s ) ;\n    c1 = 0 ;\n    c2 = 0 ;\n    for i in range ( 0 , l - 1 ) :\n        if ( s [ i ] == '0' ) :\n            c2 = 0 ;\n            c1 = c1 + 1 ;\n        else :\n            c1 = 0 ;\n            c2 = c2 + 1 ;\n        if ( c1 == m or c2 == m ) :\n            return True ;\n    return False ;\ns = \"001001\" ;\nm = 2 ;\nif ( check ( s , m ) ) :\n    print ( \"YES\" ) ;\nelse :\n    print ( \"NO\" ) ;\n", "python_code_tokenized": "def check ( s , m ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE c1 = 0 ; NEW_LINE c2 = 0 ; NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c2 = 0 ; NEW_LINE c1 = c1 + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT c1 = 0 ; NEW_LINE c2 = c2 + 1 ; NEW_LINE DEDENT if ( c1 == m or c2 == m ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT s = \"001001\" ; NEW_LINE m = 2 ; NEW_LINE if ( check ( s , m ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4139_A", "sol": 0, "python_code": "def reverserWords ( string ) :\n    st = list ( )\n    for i in range ( len ( string ) ) :\n        if string [ i ] != \"\" :\n            st.append ( string [ i ] )\n        else :\n            while len ( st ) > 0 :\n                print ( st [ - 1 ] , end = \"\" )\n                st.pop ( )\n            print ( end = \"\" )\n    while len ( st ) > 0 :\n        print ( st [ - 1 ] , end = \"\" )\n        st.pop ( )\nif __name__ == \"__main__\" :\n    string = \"Geeks for Geeks\"\n    reverserWords ( string )\n", "python_code_tokenized": "def reverserWords ( string ) : NEW_LINE INDENT st = list ( ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] != \" \u2581 \" : NEW_LINE INDENT st . append ( string [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while len ( st ) > 0 : NEW_LINE INDENT print ( st [ - 1 ] , end = \" \" ) NEW_LINE st . pop ( ) NEW_LINE DEDENT print ( end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT while len ( st ) > 0 : NEW_LINE INDENT print ( st [ - 1 ] , end = \" \" ) NEW_LINE st . pop ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" Geeks \u2581 for \u2581 Geeks \" NEW_LINE reverserWords ( string ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1388_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    if ( a == 0 ) :\n        return b\n    return gcd ( b % a , a )\ndef largestGCD1Subset ( A , n ) :\n    currentGCD = A [ 0 ] ;\n    for i in range ( 1 , n ) :\n        currentGCD = gcd ( currentGCD , A [ i ] )\n        if ( currentGCD == 1 ) :\n            return n\n    return 0\nA = [ 2 , 18 , 6 , 3 ]\nn = len ( A )\nprint ( largestGCD1Subset ( A , n ) )\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def largestGCD1Subset ( A , n ) : NEW_LINE INDENT currentGCD = A [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currentGCD = gcd ( currentGCD , A [ i ] ) NEW_LINE if ( currentGCD == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT A = [ 2 , 18 , 6 , 3 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestGCD1Subset ( A , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2923_A", "sol": 0, "python_code": "def CheckSubarray ( arr , N ) :\n    presum = [ 0 for i in range ( N + 1 ) ]\n    for i in range ( 1 , N + 1 ) :\n        presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ]\n    for i in range ( 1 , N + 1 ) :\n        for j in range ( i , N + 1 ) :\n            if ( ( presum [ j ] - presum [ i - 1 ] ) % N == 0 ) :\n                print ( i - 1 , j - 1 )\n                return\n    print ( \"-1\" )\narr = [ 7 , 5 , 3 , 7 ]\nN = len ( arr )\nCheckSubarray ( arr , N )\n", "python_code_tokenized": "def CheckSubarray ( arr , N ) : NEW_LINE INDENT presum = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( i , N + 1 ) : NEW_LINE INDENT if ( ( presum [ j ] - presum [ i - 1 ] ) % N == 0 ) : NEW_LINE INDENT print ( i - 1 , j - 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( \" - 1\" ) NEW_LINE DEDENT arr = [ 7 , 5 , 3 , 7 ] NEW_LINE N = len ( arr ) NEW_LINE CheckSubarray ( arr , N ) NEW_LINE"}
{"id": "codeforces_439_B", "sol": 0, "python_code": "n , x = map ( int , input ( ).split ( ) )\nc = list ( map ( int , input ( ).split ( ) ) )\nc.sort ( )\nans = 0\ni = 0\nn = len ( c )\nwhile i < n and x > 1 :\n    ans += c [ i ] * x\n    x -= 1\n    i += 1\nif i < n :\n    while i < n :\n        ans += c [ i ]\n        i += 1\nprint ( ans )\n", "python_code_tokenized": "n , x = map ( int , input ( ) . split ( ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c . sort ( ) NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE n = len ( c ) NEW_LINE while i < n and x > 1 : NEW_LINE INDENT ans += c [ i ] * x NEW_LINE x -= 1 NEW_LINE i += 1 NEW_LINE DEDENT if i < n : NEW_LINE INDENT while i < n : NEW_LINE INDENT ans += c [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_444_A", "sol": 0, "python_code": "pref = [ 0 ] * 100001\ndef checkPalindrome ( num ) :\n    strr = str ( num )\n    l = 0\n    r = len ( strr ) - 1\n    while ( l < r ) :\n        if ( strr [ l ] != strr [ r ] ) :\n            return 0\n        l += 1\n        r -= 1\n    return num\ndef preCompute ( ) :\n    for i in range ( 1 , 100001 ) :\n        pref [ i ] = pref [ i - 1 ] + checkPalindrome ( i )\ndef printSum ( L , R ) :\n    print ( pref [ R ] - pref [ L - 1 ] )\ndef printSumPalindromic ( arr , Q ) :\n    preCompute ( )\n    for i in range ( Q ) :\n        printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] )\nQ = 2\narr = [ [ 10 , 13 ] , [ 12 , 21 ] ]\nprintSumPalindromic ( arr , Q )\n", "python_code_tokenized": "pref = [ 0 ] * 100001 NEW_LINE def checkPalindrome ( num ) : NEW_LINE INDENT strr = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( strr ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( strr [ l ] != strr [ r ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT def preCompute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + checkPalindrome ( i ) NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT print ( pref [ R ] - pref [ L - 1 ] ) NEW_LINE DEDENT def printSumPalindromic ( arr , Q ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT Q = 2 NEW_LINE arr = [ [ 10 , 13 ] , [ 12 , 21 ] ] NEW_LINE printSumPalindromic ( arr , Q ) NEW_LINE"}
{"id": "codeforces_1509_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    N = int ( input ( ) )\n    S = input ( )\n    ctr = 0\n    for i in S :\n        if i == 'T' :\n            ctr += 1\n        else :\n            ctr -= 1\n        if ctr > N // 3 or ctr < 0 :\n            break\n    print ( 'YES' if ctr == N // 3 else 'NO' )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE S = input ( ) NEW_LINE ctr = 0 NEW_LINE for i in S : NEW_LINE INDENT if i == ' T ' : NEW_LINE INDENT ctr += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ctr -= 1 NEW_LINE DEDENT if ctr > N // 3 or ctr < 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ' YES ' if ctr == N // 3 else ' NO ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4795_A", "sol": 0, "python_code": "def swap ( a , b , c , d ) :\n    a = a + b\n    b = a - b\n    a = a - b\n    b = b + c\n    c = b - c\n    b = b - c\n    c = c + d\n    d = c - d\n    c = c - d\n    print ( \"values after swapping are : \" )\n    print ( \"a = \" , a )\n    print ( \"b = \" , b )\n    print ( \"c = \" , c )\n    print ( \"d = \" , d )\na = 1\nb = 2\nc = 3\nd = 4\nprint ( \"values after swapping are : \" )\nprint ( \"a = \" , a )\nprint ( \"b = \" , b )\nprint ( \"c = \" , c )\nprint ( \"d = \" , d )\nprint ( \"\" )\nswap ( a , b , c , d )\n", "python_code_tokenized": "def swap ( a , b , c , d ) : NEW_LINE INDENT a = a + b NEW_LINE b = a - b NEW_LINE a = a - b NEW_LINE b = b + c NEW_LINE c = b - c NEW_LINE b = b - c NEW_LINE c = c + d NEW_LINE d = c - d NEW_LINE c = c - d NEW_LINE print ( \" values \u2581 after \u2581 swapping \u2581 are \u2581 : \u2581 \" ) NEW_LINE print ( \" a \u2581 = \u2581 \" , a ) NEW_LINE print ( \" b \u2581 = \u2581 \" , b ) NEW_LINE print ( \" c \u2581 = \u2581 \" , c ) NEW_LINE print ( \" d \u2581 = \u2581 \" , d ) NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 3 NEW_LINE d = 4 NEW_LINE print ( \" values \u2581 after \u2581 swapping \u2581 are \u2581 : \u2581 \" ) NEW_LINE print ( \" a \u2581 = \u2581 \" , a ) NEW_LINE print ( \" b \u2581 = \u2581 \" , b ) NEW_LINE print ( \" c \u2581 = \u2581 \" , c ) NEW_LINE print ( \" d \u2581 = \u2581 \" , d ) NEW_LINE print ( \" \" ) NEW_LINE swap ( a , b , c , d ) NEW_LINE"}
{"id": "codeforces_545_A", "sol": 0, "python_code": "n = int ( input ( ) )\nb = set ( )\nfor i in range ( n ) :\n    z = input ( ).split ( )\n    for i in range ( n ) :\n        if z [ i ] == '2' or z [ i ] == '3' :\n            b.add ( i + 1 )\nprint ( n - len ( b ) )\nprint ( * [ i for i in range ( 1 , n + 1 ) if i not in b ] )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE b = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT z = input ( ) . split ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if z [ i ] == '2' or z [ i ] == '3' : NEW_LINE INDENT b . add ( i + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( n - len ( b ) ) NEW_LINE print ( * [ i for i in range ( 1 , n + 1 ) if i not in b ] ) NEW_LINE"}
{"id": "aizu_p02495_A", "sol": 0, "python_code": "while True :\n    h , w = map ( int , input ( ).strip ( ).split ( ) )\n    if h == w == 0 : break\n    for y in range ( h ) :\n        print ( ''.join ( '#.' [ ( x + y ) % 2 ] for x in range ( w ) ) )\n    print ( )\n", "python_code_tokenized": "while True : NEW_LINE INDENT h , w = map ( int , input ( ) . strip ( ) . split ( ) ) NEW_LINE if h == w == 0 : break NEW_LINE for y in range ( h ) : NEW_LINE INDENT print ( ' ' . join ( ' # . ' [ ( x + y ) % 2 ] for x in range ( w ) ) ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"id": "aizu_p00174_A", "sol": 0, "python_code": "while 1 :\n    x = input ( )\n    if x == \"0\" :\n        break\n    a = 0\n    b = 0\n    for i in range ( 1 , len ( x ) ) :\n        if x [ i ] == \"A\" :\n            a += 1\n        else :\n            b += 1\n    if a > b :\n        a += 1\n    else :\n        b += 1\n    print ( a , b )\n", "python_code_tokenized": "while 1 : NEW_LINE INDENT x = input ( ) NEW_LINE if x == \"0\" : NEW_LINE INDENT break NEW_LINE DEDENT a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( 1 , len ( x ) ) : NEW_LINE INDENT if x [ i ] == \" A \" : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT if a > b : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT print ( a , b ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_529_A", "sol": 0, "python_code": "import math\nimport heapq\ndef minProduct ( arr , n , k ) :\n    heapq.heapify ( arr )\n    count = 0\n    ans = 1\n    while ( arr ) and count < k :\n        x = heapq.heappop ( arr )\n        ans = ans * x\n        count = count + 1\n    return ans ;\narr = [ 198 , 76 , 544 , 123 , 154 , 675 ]\nk = 2\nn = len ( arr )\nprint ( \"Minimum product is\" , minProduct ( arr , n , k ) )\n", "python_code_tokenized": "import math NEW_LINE import heapq NEW_LINE def minProduct ( arr , n , k ) : NEW_LINE INDENT heapq . heapify ( arr ) NEW_LINE count = 0 NEW_LINE ans = 1 NEW_LINE while ( arr ) and count < k : NEW_LINE INDENT x = heapq . heappop ( arr ) NEW_LINE ans = ans * x NEW_LINE count = count + 1 NEW_LINE DEDENT return ans ; NEW_LINE DEDENT arr = [ 198 , 76 , 544 , 123 , 154 , 675 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum \u2581 product \u2581 is \" , minProduct ( arr , n , k ) ) NEW_LINE"}
{"id": "codeforces_392_B", "sol": 0, "python_code": "from functools import lru_cache\nt = [ [ 0 ] * 4 for i in range ( 4 ) ]\nfor i in range ( 1 , 4 ) :\n    j = 1\n    for v in map ( int , input ( ).split ( ) ) :\n        t [ i ] [ j ] = v\n        j += 1\nn = int ( input ( ) )\n@ lru_cache ( None )\ndef f ( l , r , nums ) :\n    mid = 6 - l - r\n    if nums == 0 :\n        return 0\n    if l == r :\n        return 0\n    ans1 = f ( l , mid , nums - 1 ) + f ( mid , r , nums - 1 ) + t [ l ] [ r ]\n    ans2 = f ( l , r , nums - 1 ) * 2 + f ( r , l , nums - 1 ) + t [ l ] [ mid ] + t [ mid ] [ r ]\n    return min ( ans1 , ans2 )\nprint ( f ( 1 , 3 , n ) )\n", "python_code_tokenized": "from functools import lru_cache NEW_LINE t = [ [ 0 ] * 4 for i in range ( 4 ) ] NEW_LINE for i in range ( 1 , 4 ) : NEW_LINE INDENT j = 1 NEW_LINE for v in map ( int , input ( ) . split ( ) ) : NEW_LINE INDENT t [ i ] [ j ] = v NEW_LINE j += 1 NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE @ lru_cache ( None ) NEW_LINE def f ( l , r , nums ) : NEW_LINE INDENT mid = 6 - l - r NEW_LINE if nums == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if l == r : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans1 = f ( l , mid , nums - 1 ) + f ( mid , r , nums - 1 ) + t [ l ] [ r ] NEW_LINE ans2 = f ( l , r , nums - 1 ) * 2 + f ( r , l , nums - 1 ) + t [ l ] [ mid ] + t [ mid ] [ r ] NEW_LINE return min ( ans1 , ans2 ) NEW_LINE DEDENT print ( f ( 1 , 3 , n ) ) NEW_LINE"}
{"id": "codeforces_1438_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    n = int ( input ( ) )\n    i = 1\n    while n > 0 :\n        print ( i , end = \" \" )\n        n -= 1\n    print ( )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE i = 1 NEW_LINE while n > 0 : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE n -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"id": "aizu_p00138_A", "sol": 0, "python_code": "import sys\nfrom sys import stdin\nfrom operator import itemgetter\ninput = stdin.readline\ndef solve ( data ) :\n    data.sort ( key = itemgetter ( 1 ) )\n    top2 = data [ : 2 ]\n    others = data [ 2 : ]\n    return top2 , others\ndef main ( args ) :\n    others_results = [ ]\n    for _ in range ( 3 ) :\n        round_results = [ ]\n        for _ in range ( 8 ) :\n            id , time = input ( ).split ( )\n            round_results.append ( [ int ( id ) , float ( time ) ] )\n        top2 , others = solve ( round_results )\n        others_results.extend ( others )\n        for id , time in top2 :\n            print ( '{} {}'.format ( id , time ) )\n    top2 , others = solve ( others_results )\n    for id , time in top2 :\n        print ( '{} {}'.format ( id , time ) )\nif __name__ == '__main__' :\n    main ( sys.argv [ 1 : ] )\n", "python_code_tokenized": "import sys NEW_LINE from sys import stdin NEW_LINE from operator import itemgetter NEW_LINE input = stdin . readline NEW_LINE def solve ( data ) : NEW_LINE INDENT data . sort ( key = itemgetter ( 1 ) ) NEW_LINE top2 = data [ : 2 ] NEW_LINE others = data [ 2 : ] NEW_LINE return top2 , others NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT others_results = [ ] NEW_LINE for _ in range ( 3 ) : NEW_LINE INDENT round_results = [ ] NEW_LINE for _ in range ( 8 ) : NEW_LINE INDENT id , time = input ( ) . split ( ) NEW_LINE round_results . append ( [ int ( id ) , float ( time ) ] ) NEW_LINE DEDENT top2 , others = solve ( round_results ) NEW_LINE others_results . extend ( others ) NEW_LINE for id , time in top2 : NEW_LINE INDENT print ( ' { } \u2581 { } ' . format ( id , time ) ) NEW_LINE DEDENT DEDENT top2 , others = solve ( others_results ) NEW_LINE for id , time in top2 : NEW_LINE INDENT print ( ' { } \u2581 { } ' . format ( id , time ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT"}
{"id": "aizu_p00402_A", "sol": 0, "python_code": "N = int ( input ( ) )\nX = list ( map ( int , input ( ).split ( ) ) )\nXmn , Xmx = min ( X ) , max ( X )\ntemp = [ ]\nres = Xmx - Xmn\nfor x in range ( Xmn , Xmx + 1 ) :\n    for n in range ( N ) :\n        temp.append ( abs ( X [ n ] - x ) )\n    if max ( temp ) < res :\n        res = max ( temp )\n    temp = [ ]\nprint ( res )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Xmn , Xmx = min ( X ) , max ( X ) NEW_LINE temp = [ ] NEW_LINE res = Xmx - Xmn NEW_LINE for x in range ( Xmn , Xmx + 1 ) : NEW_LINE INDENT for n in range ( N ) : NEW_LINE INDENT temp . append ( abs ( X [ n ] - x ) ) NEW_LINE DEDENT if max ( temp ) < res : NEW_LINE INDENT res = max ( temp ) NEW_LINE DEDENT temp = [ ] NEW_LINE DEDENT print ( res ) NEW_LINE"}
{"id": "leetcode_404_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def sumOfLeftLeaves ( self , root ) :\n        stack = [ root ]\n        res = 0\n        while len ( stack ) > 0 :\n            curr = stack.pop ( 0 )\n            if curr is not None :\n                if curr.left is not None :\n                    if curr.left.left is None and curr.left.right is None :\n                        res += curr.left.val\n                stack.insert ( 0 , curr.right )\n                stack.insert ( 0 , curr.left )\n        return res\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def sumOfLeftLeaves ( self , root ) : NEW_LINE INDENT stack = [ root ] NEW_LINE res = 0 NEW_LINE while len ( stack ) > 0 : NEW_LINE INDENT curr = stack . pop ( 0 ) NEW_LINE if curr is not None : NEW_LINE INDENT if curr . left is not None : NEW_LINE INDENT if curr . left . left is None and curr . left . right is None : NEW_LINE INDENT res += curr . left . val NEW_LINE DEDENT DEDENT stack . insert ( 0 , curr . right ) NEW_LINE stack . insert ( 0 , curr . left ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_543_A", "sol": 0, "python_code": "def count_pairs ( n , a ) :\n    frequency = dict.fromkeys ( a , 0 )\n    for i in range ( n ) :\n        frequency [ a [ i ] ] += 1\n    count = 0\n    for f in frequency.values ( ) :\n        count += f * ( f - 1 ) // 2\n    return ( ( n * ( n - 1 ) ) // 2 ) - count\nif __name__ == \"__main__\" :\n    arr = [ 2 , 4 , 5 , 2 , 5 , 7 , 2 , 8 ]\n    n = len ( arr )\n    print ( count_pairs ( n , arr ) )\n", "python_code_tokenized": "def count_pairs ( n , a ) : NEW_LINE INDENT frequency = dict . fromkeys ( a , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT frequency [ a [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for f in frequency . values ( ) : NEW_LINE INDENT count += f * ( f - 1 ) // 2 NEW_LINE DEDENT return ( ( n * ( n - 1 ) ) // 2 ) - count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 2 , 5 , 7 , 2 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( count_pairs ( n , arr ) ) NEW_LINE DEDENT"}
{"id": "aizu_p01855_A", "sol": 0, "python_code": "def gcd ( a , b ) :\n    if a == 0 :\n        return b\n    else :\n        return gcd ( b % a , a )\nt = int ( input ( ) )\nwhile t :\n    t -= 1\n    a , b = map ( int , input ( ).split ( ) )\n    c = gcd ( a , b )\n    a = a // c\n    b = b // c\n    if a == b :\n        ans1 = 1\n        ans2 = 0\n    elif a % 2 == 0 or b % 2 == 0 :\n        ans1 = 1\n        ans2 = 1\n    else :\n        ans1 = a * b // 2 + 1\n        ans2 = a * b // 2\n    print ( ans1 , ans2 )\n", "python_code_tokenized": "def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b % a , a ) NEW_LINE DEDENT DEDENT t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = gcd ( a , b ) NEW_LINE a = a // c NEW_LINE b = b // c NEW_LINE if a == b : NEW_LINE INDENT ans1 = 1 NEW_LINE ans2 = 0 NEW_LINE DEDENT elif a % 2 == 0 or b % 2 == 0 : NEW_LINE INDENT ans1 = 1 NEW_LINE ans2 = 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans1 = a * b // 2 + 1 NEW_LINE ans2 = a * b // 2 NEW_LINE DEDENT print ( ans1 , ans2 ) NEW_LINE DEDENT"}
{"id": "aizu_p00567_A", "sol": 0, "python_code": "N , * L = map ( int , open ( 0 ).read ( ).split ( ) )\nmemo = [ set ( ) for i in range ( N ) ]\nans = sum ( L )\ndef dfs ( i , mi , ma ) :\n    global ans\n    if i == N :\n        ans = min ( ans , ma - mi )\n        return\n    key = ( mi , ma )\n    if ma - mi >= ans or key in memo [ i ] :\n        return\n    memo [ i ].add ( key )\n    s = 0\n    for j in range ( i , N - ( i == 0 ) ) :\n        s += L [ j ]\n        dfs ( j + 1 , min ( mi , s ) , max ( ma , s ) )\ndfs ( 0 , 10 ** 18 , - 10 ** 18 )\nprint ( ans )\n", "python_code_tokenized": "N , * L = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE memo = [ set ( ) for i in range ( N ) ] NEW_LINE ans = sum ( L ) NEW_LINE def dfs ( i , mi , ma ) : NEW_LINE INDENT global ans NEW_LINE if i == N : NEW_LINE INDENT ans = min ( ans , ma - mi ) NEW_LINE return NEW_LINE DEDENT key = ( mi , ma ) NEW_LINE if ma - mi >= ans or key in memo [ i ] : NEW_LINE INDENT return NEW_LINE DEDENT memo [ i ] . add ( key ) NEW_LINE s = 0 NEW_LINE for j in range ( i , N - ( i == 0 ) ) : NEW_LINE INDENT s += L [ j ] NEW_LINE dfs ( j + 1 , min ( mi , s ) , max ( ma , s ) ) NEW_LINE DEDENT DEDENT dfs ( 0 , 10 ** 18 , - 10 ** 18 ) NEW_LINE print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_4402_A", "sol": 0, "python_code": "import sys\ndef areConsecutives ( arr , n ) :\n    first_term = sys.maxsize\n    for i in range ( n ) :\n        if arr [ i ] < first_term :\n            first_term = arr [ i ]\n    ap_sum = ( ( n * ( 2 * first_term + ( n - 1 ) * 1 ) ) // 2 )\n    arr_sum = 0\n    for i in range ( n ) :\n        arr_sum += arr [ i ]\n    return ap_sum == arr_sum\narr = [ 2 , 1 , 0 , - 3 , - 1 , - 2 ]\nn = len ( arr )\nif areConsecutives ( arr , n ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "import sys NEW_LINE def areConsecutives ( arr , n ) : NEW_LINE INDENT first_term = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < first_term : NEW_LINE INDENT first_term = arr [ i ] NEW_LINE DEDENT DEDENT ap_sum = ( ( n * ( 2 * first_term + ( n - 1 ) * 1 ) ) // 2 ) NEW_LINE arr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr_sum += arr [ i ] NEW_LINE DEDENT return ap_sum == arr_sum NEW_LINE DEDENT arr = [ 2 , 1 , 0 , - 3 , - 1 , - 2 ] NEW_LINE n = len ( arr ) NEW_LINE if areConsecutives ( arr , n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "leetcode_695_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def maxAreaOfIsland ( self , grid ) :\n        ans = 0\n        for i in range ( len ( grid ) ) :\n            for j in range ( len ( grid [ 0 ] ) ) :\n                if grid [ i ] [ j ] == 1 :\n                    grid [ i ] [ j ] = 0\n                    ans = max ( self.dfs ( grid , i , j ) , ans )\n        return ans\n    def dfs ( self , grid , i , j ) :\n        stack = [ ( i , j ) ]\n        area = 0\n        while stack :\n            r , c = stack.pop ( - 1 )\n            area += 1\n            for nr , nc in ( ( r - 1 , c ) , ( r + 1 , c ) , ( r , c - 1 ) , ( r , c + 1 ) ) :\n                if ( 0 <= nr < len ( grid ) and 0 <= nc < len ( grid [ 0 ] ) and grid [ nr ] [ nc ] ) :\n                    stack.append ( ( nr , nc ) )\n                    grid [ nr ] [ nc ] = 0\n        return area\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def maxAreaOfIsland ( self , grid ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( grid ) ) : NEW_LINE INDENT for j in range ( len ( grid [ 0 ] ) ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT grid [ i ] [ j ] = 0 NEW_LINE ans = max ( self . dfs ( grid , i , j ) , ans ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def dfs ( self , grid , i , j ) : NEW_LINE INDENT stack = [ ( i , j ) ] NEW_LINE area = 0 NEW_LINE while stack : NEW_LINE INDENT r , c = stack . pop ( - 1 ) NEW_LINE area += 1 NEW_LINE for nr , nc in ( ( r - 1 , c ) , ( r + 1 , c ) , ( r , c - 1 ) , ( r , c + 1 ) ) : NEW_LINE INDENT if ( 0 <= nr < len ( grid ) and 0 <= nc < len ( grid [ 0 ] ) and grid [ nr ] [ nc ] ) : NEW_LINE INDENT stack . append ( ( nr , nc ) ) NEW_LINE grid [ nr ] [ nc ] = 0 NEW_LINE DEDENT DEDENT DEDENT return area NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1337_B", "sol": 0, "python_code": "def get ( ) :\n    return list ( map ( int , input ( ).split ( ) ) )\ndef intput ( ) :\n    return int ( input ( ) )\ndef dfs ( h , a , v ) :\n    if ( h <= 0 ) :\n        return True\n    if ( h > 20 and a > 0 ) :\n        return dfs ( h // 2 + 10 , a - 1 , v )\n    elif ( v > 0 ) :\n        return dfs ( h - 10 , a , v - 1 )\n    else :\n        return False\ndef main ( ) :\n    for _ in range ( intput ( ) ) :\n        a = get ( )\n        print ( \"YES\" if dfs ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) else \"NO\" )\nmain ( )\n", "python_code_tokenized": "def get ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def intput ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def dfs ( h , a , v ) : NEW_LINE INDENT if ( h <= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( h > 20 and a > 0 ) : NEW_LINE INDENT return dfs ( h // 2 + 10 , a - 1 , v ) NEW_LINE DEDENT elif ( v > 0 ) : NEW_LINE INDENT return dfs ( h - 10 , a , v - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT for _ in range ( intput ( ) ) : NEW_LINE INDENT a = get ( ) NEW_LINE print ( \" YES \" if dfs ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) else \" NO \" ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "codeforces_1674_B", "sol": 0, "python_code": "n = int ( input ( ) )\ndef solve ( n ) :\n    for i in range ( n ) :\n        item = input ( )\n        firstBit = ( ord ( item [ 0 ] ) - ord ( 'a' ) ) * 25\n        if item [ 0 ] == 'a' :\n            secondBit = ( ord ( item [ 1 ] ) - ord ( 'a' ) )\n        elif item [ 1 ] > item [ 0 ] :\n            secondBit = ( ord ( item [ 1 ] ) - ord ( 'a' ) )\n        elif item [ 1 ] < item [ 0 ] :\n            secondBit = ( ord ( item [ 1 ] ) - ord ( 'a' ) ) + 1\n        print ( f'{firstBit + secondBit}' )\nsolve ( n )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE def solve ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT item = input ( ) NEW_LINE firstBit = ( ord ( item [ 0 ] ) - ord ( ' a ' ) ) * 25 NEW_LINE if item [ 0 ] == ' a ' : NEW_LINE INDENT secondBit = ( ord ( item [ 1 ] ) - ord ( ' a ' ) ) NEW_LINE DEDENT elif item [ 1 ] > item [ 0 ] : NEW_LINE INDENT secondBit = ( ord ( item [ 1 ] ) - ord ( ' a ' ) ) NEW_LINE DEDENT elif item [ 1 ] < item [ 0 ] : NEW_LINE INDENT secondBit = ( ord ( item [ 1 ] ) - ord ( ' a ' ) ) + 1 NEW_LINE DEDENT print ( f ' { firstBit \u2581 + \u2581 secondBit } ' ) NEW_LINE DEDENT DEDENT solve ( n ) NEW_LINE"}
{"id": "codeforces_1300_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    b = 0\n    c = 0\n    n = int ( input ( ) )\n    a = list ( map ( int , input ( ).split ( ) ) )\n    if 0 in a :\n        c = ( int ( a.count ( 0 ) ) )\n        b += c\n    if sum ( a ) + c == 0 :\n        b += 1\n    print ( b )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT b = 0 NEW_LINE c = 0 NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if 0 in a : NEW_LINE INDENT c = ( int ( a . count ( 0 ) ) ) NEW_LINE b += c NEW_LINE DEDENT if sum ( a ) + c == 0 : NEW_LINE INDENT b += 1 NEW_LINE DEDENT print ( b ) NEW_LINE DEDENT"}
{"id": "codeforces_5_A", "sol": 0, "python_code": "import sys\nx = y = 0\nfor i in sys.stdin :\n    x += i [ 0 ] == '+'\n    x -= i [ 0 ] == '-'\n    y += ( ':' in i ) * ( len ( i ) - i.find ( ':' ) - 2 ) * x\nprint ( y )\n", "python_code_tokenized": "import sys NEW_LINE x = y = 0 NEW_LINE for i in sys . stdin : NEW_LINE INDENT x += i [ 0 ] == ' + ' NEW_LINE x -= i [ 0 ] == ' - ' NEW_LINE y += ( ' : ' in i ) * ( len ( i ) - i . find ( ' : ' ) - 2 ) * x NEW_LINE DEDENT print ( y ) NEW_LINE"}
{"id": "geeksforgeeks_1945_A", "sol": 0, "python_code": "def maxSquareSubsetSum ( A , N ) :\n    sub1 = 0 ; sub2 = 0 ;\n    A.sort ( ) ;\n    for i in range ( N ) :\n        if ( i < ( N // 2 ) - 1 ) :\n            sub1 += A [ i ] ;\n        else :\n            sub2 += A [ i ] ;\n    return sub1 * sub1 + sub2 * sub2 ;\nif __name__ == \"__main__\" :\n    arr = [ 7 , 2 , 13 , 4 , 25 , 8 ] ;\n    N = len ( arr ) ;\n    print ( maxSquareSubsetSum ( arr , N ) ) ;\n", "python_code_tokenized": "def maxSquareSubsetSum ( A , N ) : NEW_LINE INDENT sub1 = 0 ; sub2 = 0 ; NEW_LINE A . sort ( ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i < ( N // 2 ) - 1 ) : NEW_LINE INDENT sub1 += A [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT sub2 += A [ i ] ; NEW_LINE DEDENT DEDENT return sub1 * sub1 + sub2 * sub2 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 7 , 2 , 13 , 4 , 25 , 8 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE print ( maxSquareSubsetSum ( arr , N ) ) ; NEW_LINE DEDENT"}
{"id": "atcoder_ABC075_D", "sol": 0, "python_code": "from itertools import combinations\nN , K = map ( int , input ( ).split ( ) )\nP = [ tuple ( map ( int , input ( ).split ( ) ) ) for _ in range ( N ) ]\nans = 10 ** 18 * 5\nfor x in combinations ( range ( N ) , 2 ) :\n    u = max ( P [ x [ 0 ] ] [ 0 ] , P [ x [ 1 ] ] [ 0 ] )\n    d = min ( P [ x [ 0 ] ] [ 0 ] , P [ x [ 1 ] ] [ 0 ] )\n    for y in combinations ( range ( N ) , 2 ) :\n        r = max ( P [ y [ 0 ] ] [ 1 ] , P [ y [ 1 ] ] [ 1 ] )\n        l = min ( P [ y [ 0 ] ] [ 1 ] , P [ y [ 1 ] ] [ 1 ] )\n        count = 0\n        for i in range ( N ) :\n            if d <= P [ i ] [ 0 ] <= u and l <= P [ i ] [ 1 ] <= r :\n                count += 1\n        if count >= K :\n            ans = min ( ans , ( u - d ) * ( r - l ) )\nprint ( ans )\n", "python_code_tokenized": "from itertools import combinations NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE P = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE ans = 10 ** 18 * 5 NEW_LINE for x in combinations ( range ( N ) , 2 ) : NEW_LINE INDENT u = max ( P [ x [ 0 ] ] [ 0 ] , P [ x [ 1 ] ] [ 0 ] ) NEW_LINE d = min ( P [ x [ 0 ] ] [ 0 ] , P [ x [ 1 ] ] [ 0 ] ) NEW_LINE for y in combinations ( range ( N ) , 2 ) : NEW_LINE INDENT r = max ( P [ y [ 0 ] ] [ 1 ] , P [ y [ 1 ] ] [ 1 ] ) NEW_LINE l = min ( P [ y [ 0 ] ] [ 1 ] , P [ y [ 1 ] ] [ 1 ] ) NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if d <= P [ i ] [ 0 ] <= u and l <= P [ i ] [ 1 ] <= r : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count >= K : NEW_LINE INDENT ans = min ( ans , ( u - d ) * ( r - l ) ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_445_B", "sol": 0, "python_code": "from collections import defaultdict\ndef dfs ( node , graph , vis ) :\n    global count\n    vis [ node ] = True\n    count += 1\n    for i in graph [ node ] :\n        if not vis [ i ] :\n            dfs ( i , graph , vis )\nn , m = map ( int , input ( ).split ( ) )\nif m == 0 :\n    print ( 1 )\nelse :\n    graph = defaultdict ( list )\n    for i in range ( m ) :\n        a , b = map ( int , input ( ).split ( ) )\n        graph [ a ].append ( b )\n        graph [ b ].append ( a )\n    vis = [ False ] * ( n + 1 )\n    ans = 0\n    ans = 0\n    for i in range ( 1 , n + 1 ) :\n        global count\n        count = 0\n        if not vis [ i ] :\n            dfs ( i , graph , vis )\n            ans += 1\n    print ( pow ( 2 , n - ans ) )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE def dfs ( node , graph , vis ) : NEW_LINE INDENT global count NEW_LINE vis [ node ] = True NEW_LINE count += 1 NEW_LINE for i in graph [ node ] : NEW_LINE INDENT if not vis [ i ] : NEW_LINE INDENT dfs ( i , graph , vis ) NEW_LINE DEDENT DEDENT DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT graph = defaultdict ( list ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE graph [ a ] . append ( b ) NEW_LINE graph [ b ] . append ( a ) NEW_LINE DEDENT vis = [ False ] * ( n + 1 ) NEW_LINE ans = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT global count NEW_LINE count = 0 NEW_LINE if not vis [ i ] : NEW_LINE INDENT dfs ( i , graph , vis ) NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT print ( pow ( 2 , n - ans ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1270_A", "sol": 0, "python_code": "_MIN = - 2147483648\n_MAX = 2147483648\nclass newNode :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.left = None\n        self.right = None\ndef closestNodeUsingMorrisTraversal ( root , key ) :\n    diff = _MAX\n    curr = root\n    closest = 0\n    while ( curr ) :\n        if ( curr.left == None ) :\n            if ( diff > abs ( curr.data - key ) ) :\n                diff = abs ( curr.data - key )\n                closest = curr\n            curr = curr.right\n        else :\n            pre = curr.left\n            while ( pre.right != None and pre.right != curr ) :\n                pre = pre.right\n            if ( pre.right == None ) :\n                pre.right = curr\n                curr = curr.left\n            else :\n                pre.right = None\n                if ( diff > abs ( curr.data - key ) ) :\n                    diff = abs ( curr.data - key )\n                    closest = curr\n                curr = curr.right\n    return closest\nif __name__ == '__main__' :\n    root = newNode ( 5 )\n    root.left = newNode ( 3 )\n    root.right = newNode ( 9 )\n    root.left.right = newNode ( 2 )\n    root.left.left = newNode ( 1 )\n    root.right.right = newNode ( 12 )\n    root.right.left = newNode ( 8 )\n    print ( closestNodeUsingMorrisTraversal ( root , 10 ).data )\n", "python_code_tokenized": "_MIN = - 2147483648 NEW_LINE _MAX = 2147483648 NEW_LINE class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def closestNodeUsingMorrisTraversal ( root , key ) : NEW_LINE INDENT diff = _MAX NEW_LINE curr = root NEW_LINE closest = 0 NEW_LINE while ( curr ) : NEW_LINE INDENT if ( curr . left == None ) : NEW_LINE INDENT if ( diff > abs ( curr . data - key ) ) : NEW_LINE INDENT diff = abs ( curr . data - key ) NEW_LINE closest = curr NEW_LINE DEDENT curr = curr . right NEW_LINE DEDENT else : NEW_LINE INDENT pre = curr . left NEW_LINE while ( pre . right != None and pre . right != curr ) : NEW_LINE INDENT pre = pre . right NEW_LINE DEDENT if ( pre . right == None ) : NEW_LINE INDENT pre . right = curr NEW_LINE curr = curr . left NEW_LINE DEDENT else : NEW_LINE INDENT pre . right = None NEW_LINE if ( diff > abs ( curr . data - key ) ) : NEW_LINE INDENT diff = abs ( curr . data - key ) NEW_LINE closest = curr NEW_LINE DEDENT curr = curr . right NEW_LINE DEDENT DEDENT DEDENT return closest NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 5 ) NEW_LINE root . left = newNode ( 3 ) NEW_LINE root . right = newNode ( 9 ) NEW_LINE root . left . right = newNode ( 2 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . right . right = newNode ( 12 ) NEW_LINE root . right . left = newNode ( 8 ) NEW_LINE print ( closestNodeUsingMorrisTraversal ( root , 10 ) . data ) NEW_LINE DEDENT"}
{"id": "codeforces_344_A", "sol": 0, "python_code": "n = int ( input ( ) )\nback = input ( )\ncount = 0\nfor i in range ( n - 1 ) :\n    p = input ( )\n    if p [ : : - 1 ] == back : count += 1\n    back = p\nprint ( count + 1 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE back = input ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT p = input ( ) NEW_LINE if p [ : : - 1 ] == back : count += 1 NEW_LINE back = p NEW_LINE DEDENT print ( count + 1 ) NEW_LINE"}
{"id": "codeforces_268_A", "sol": 0, "python_code": "n = int ( input ( ) )\nq = [ ]\ncount = 0\nfor i in range ( n ) :\n    a = input ( ).split ( )\n    q.append ( a )\nfor j in q :\n    for k in q :\n        if k == j :\n            continue\n        elif j [ 0 ] == k [ len ( k ) - 1 ] :\n            count += 1\n        else :\n            continue\nprint ( count )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE q = [ ] NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = input ( ) . split ( ) NEW_LINE q . append ( a ) NEW_LINE DEDENT for j in q : NEW_LINE INDENT for k in q : NEW_LINE INDENT if k == j : NEW_LINE INDENT continue NEW_LINE DEDENT elif j [ 0 ] == k [ len ( k ) - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE"}
{"id": "codeforces_734_A", "sol": 0, "python_code": "a = int ( input ( ) )\nb = input ( )\nif b.count ( \"A\" ) > b.count ( \"D\" ) :\n    print ( \"Anton\" )\nelif b.count ( \"A\" ) < b.count ( \"D\" ) :\n    print ( \"Danik\" )\nelse :\n    print ( \"Friendship\" )\n", "python_code_tokenized": "a = int ( input ( ) ) NEW_LINE b = input ( ) NEW_LINE if b . count ( \" A \" ) > b . count ( \" D \" ) : NEW_LINE INDENT print ( \" Anton \" ) NEW_LINE DEDENT elif b . count ( \" A \" ) < b . count ( \" D \" ) : NEW_LINE INDENT print ( \" Danik \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Friendship \" ) NEW_LINE DEDENT"}
{"id": "codeforces_228_A", "sol": 0, "python_code": "arr = [ int ( x ) for x in input ( ).split ( ' ' ) ]\ncounter = 0\nfor i in set ( arr ) :\n    counter += arr.count ( i ) - 1\nprint ( counter )\n", "python_code_tokenized": "arr = [ int ( x ) for x in input ( ) . split ( ' \u2581 ' ) ] NEW_LINE counter = 0 NEW_LINE for i in set ( arr ) : NEW_LINE INDENT counter += arr . count ( i ) - 1 NEW_LINE DEDENT print ( counter ) NEW_LINE"}
{"id": "codeforces_43_A", "sol": 0, "python_code": "from collections import *\ndef inp ( ) :\n    return ( int ( input ( ) ) )\ndef inlt ( ) :\n    return ( list ( map ( int , input ( ).split ( ) ) ) )\ndef insr ( ) :\n    s = input ( )\n    return ( list ( s [ : len ( s ) - 1 ] ) )\ndef invr ( ) :\n    return ( map ( int , input ( ).split ( ) ) )\nn = inp ( )\ngoals = defaultdict ( int )\nfor _ in range ( n ) :\n    goals [ input ( ) ] += 1\nteams = list ( goals.keys ( ) )\nif len ( teams ) == 1 :\n    print ( teams [ 0 ] )\nelse :\n    if goals [ teams [ 0 ] ] > goals [ teams [ 1 ] ] :\n        print ( teams [ 0 ] )\n    else :\n        print ( teams [ 1 ] )\n", "python_code_tokenized": "from collections import * NEW_LINE def inp ( ) : NEW_LINE INDENT return ( int ( input ( ) ) ) NEW_LINE DEDENT def inlt ( ) : NEW_LINE INDENT return ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT def insr ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE return ( list ( s [ : len ( s ) - 1 ] ) ) NEW_LINE DEDENT def invr ( ) : NEW_LINE INDENT return ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT n = inp ( ) NEW_LINE goals = defaultdict ( int ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT goals [ input ( ) ] += 1 NEW_LINE DEDENT teams = list ( goals . keys ( ) ) NEW_LINE if len ( teams ) == 1 : NEW_LINE INDENT print ( teams [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if goals [ teams [ 0 ] ] > goals [ teams [ 1 ] ] : NEW_LINE INDENT print ( teams [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( teams [ 1 ] ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC078_A", "sol": 0, "python_code": "x , y = input ( ).split ( )\nprint ( '=' if x == y else '>' if x > y else '<' )\n", "python_code_tokenized": "x , y = input ( ) . split ( ) NEW_LINE print ( ' = ' if x == y else ' > ' if x > y else ' < ' ) NEW_LINE"}
{"id": "codeforces_1133_A", "sol": 0, "python_code": "t1 = tuple ( map ( int , input ( ).split ( \":\" ) ) )\nt2 = tuple ( map ( int , input ( ).split ( \":\" ) ) )\ndef mts ( t ) :\n    return t [ 0 ] * 60 + t [ 1 ]\nt1 = mts ( t1 )\nt2 = mts ( t2 )\ndef stm ( m ) :\n    return map ( str , [ m // 60 , m % 60 ] )\nt = stm ( ( t1 + t2 ) // 2 )\nprint ( \":\".join ( [ ( '00' + s ) [ - 2 : ] for s in t ] ) )\n", "python_code_tokenized": "t1 = tuple ( map ( int , input ( ) . split ( \" : \" ) ) ) NEW_LINE t2 = tuple ( map ( int , input ( ) . split ( \" : \" ) ) ) NEW_LINE def mts ( t ) : NEW_LINE INDENT return t [ 0 ] * 60 + t [ 1 ] NEW_LINE DEDENT t1 = mts ( t1 ) NEW_LINE t2 = mts ( t2 ) NEW_LINE def stm ( m ) : NEW_LINE INDENT return map ( str , [ m // 60 , m % 60 ] ) NEW_LINE DEDENT t = stm ( ( t1 + t2 ) // 2 ) NEW_LINE print ( \" : \" . join ( [ ( '00' + s ) [ - 2 : ] for s in t ] ) ) NEW_LINE"}
{"id": "codeforces_400_B", "sol": 0, "python_code": "numbers = list ( map ( int , input ( ).split ( ) ) )\ncolumns = numbers [ 0 ]\nrows = numbers [ 1 ]\ncounter = - 1\ndata = { }\nstop = 0\nfor i in range ( 0 , columns ) :\n    x = input ( )\n    g = \"not\"\n    s = 'not'\n    count = 0\n    for j in range ( 0 , rows ) :\n        if x [ j ] == \"S\" :\n            if g == \"found\" :\n                counter = count + 1 ;\n                if not f\"{counter}\" in data :\n                    data [ f\"{counter}\" ] = 1\n            else :\n                stop = 1\n            break\n        elif x [ j ] == 'G' :\n            g = 'found'\n            count = 0\n        else :\n            count += 1\nprint ( - 1 if len ( data ) == 0 or stop == 1 else len ( data ) )\n", "python_code_tokenized": "numbers = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE columns = numbers [ 0 ] NEW_LINE rows = numbers [ 1 ] NEW_LINE counter = - 1 NEW_LINE data = { } NEW_LINE stop = 0 NEW_LINE for i in range ( 0 , columns ) : NEW_LINE INDENT x = input ( ) NEW_LINE g = \" not \" NEW_LINE s = ' not ' NEW_LINE count = 0 NEW_LINE for j in range ( 0 , rows ) : NEW_LINE INDENT if x [ j ] == \" S \" : NEW_LINE INDENT if g == \" found \" : NEW_LINE INDENT counter = count + 1 ; NEW_LINE if not f \" { counter } \" in data : NEW_LINE INDENT data [ f \" { counter } \" ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT stop = 1 NEW_LINE DEDENT break NEW_LINE DEDENT elif x [ j ] == ' G ' : NEW_LINE INDENT g = ' found ' NEW_LINE count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( - 1 if len ( data ) == 0 or stop == 1 else len ( data ) ) NEW_LINE"}
{"id": "codeforces_1292_A", "sol": 0, "python_code": "import math\nimport sys\nn , q = map ( int , input ( ).split ( ) )\nrow1 = set ( )\nrow2 = set ( )\ndiagonalCount = 0\nupDownCount = 0\nfor _ in range ( q ) :\n    r , c = map ( int , input ( ).split ( ) )\n    if c in row1 and r == 1 :\n        if c in row2 :\n            upDownCount -= 1\n        if c + 1 in row2 :\n            diagonalCount -= 1\n        if c - 1 in row2 :\n            diagonalCount -= 1\n        row1.remove ( c )\n    elif c in row2 and r == 2 :\n        if c in row1 :\n            upDownCount -= 1\n        if c + 1 in row1 :\n            diagonalCount -= 1\n        if c - 1 in row1 :\n            diagonalCount -= 1\n        row2.remove ( c )\n    else :\n        if r == 1 :\n            row1.add ( c )\n            if c in row2 :\n                upDownCount += 1\n            if c + 1 in row2 :\n                diagonalCount += 1\n            if c - 1 in row2 :\n                diagonalCount += 1\n        else :\n            row2.add ( c )\n            if c in row1 :\n                upDownCount += 1\n            if c + 1 in row1 :\n                diagonalCount += 1\n            if c - 1 in row1 :\n                diagonalCount += 1\n    print ( \"YES\" if diagonalCount == 0 and upDownCount == 0 else \"NO\" )\n", "python_code_tokenized": "import math NEW_LINE import sys NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE row1 = set ( ) NEW_LINE row2 = set ( ) NEW_LINE diagonalCount = 0 NEW_LINE upDownCount = 0 NEW_LINE for _ in range ( q ) : NEW_LINE INDENT r , c = map ( int , input ( ) . split ( ) ) NEW_LINE if c in row1 and r == 1 : NEW_LINE INDENT if c in row2 : NEW_LINE INDENT upDownCount -= 1 NEW_LINE DEDENT if c + 1 in row2 : NEW_LINE INDENT diagonalCount -= 1 NEW_LINE DEDENT if c - 1 in row2 : NEW_LINE INDENT diagonalCount -= 1 NEW_LINE DEDENT row1 . remove ( c ) NEW_LINE DEDENT elif c in row2 and r == 2 : NEW_LINE INDENT if c in row1 : NEW_LINE INDENT upDownCount -= 1 NEW_LINE DEDENT if c + 1 in row1 : NEW_LINE INDENT diagonalCount -= 1 NEW_LINE DEDENT if c - 1 in row1 : NEW_LINE INDENT diagonalCount -= 1 NEW_LINE DEDENT row2 . remove ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT if r == 1 : NEW_LINE INDENT row1 . add ( c ) NEW_LINE if c in row2 : NEW_LINE INDENT upDownCount += 1 NEW_LINE DEDENT if c + 1 in row2 : NEW_LINE INDENT diagonalCount += 1 NEW_LINE DEDENT if c - 1 in row2 : NEW_LINE INDENT diagonalCount += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT row2 . add ( c ) NEW_LINE if c in row1 : NEW_LINE INDENT upDownCount += 1 NEW_LINE DEDENT if c + 1 in row1 : NEW_LINE INDENT diagonalCount += 1 NEW_LINE DEDENT if c - 1 in row1 : NEW_LINE INDENT diagonalCount += 1 NEW_LINE DEDENT DEDENT DEDENT print ( \" YES \" if diagonalCount == 0 and upDownCount == 0 else \" NO \" ) NEW_LINE DEDENT"}
{"id": "codeforces_222_A", "sol": 0, "python_code": "def main ( ) :\n    n , k = list ( map ( int , input ( ).split ( ' ' ) ) )\n    elems = list ( map ( int , input ( ).split ( ' ' ) ) )\n    all_same = lambda arr : all ( [ x == arr [ 0 ] for x in arr ] )\n    if all_same ( elems ) :\n        print ( 0 )\n        return\n    if k == 1 :\n        print ( - 1 )\n        return\n    if not all_same ( elems [ k - 1 : ] ) :\n        print ( - 1 )\n        return\n    target = elems [ - 1 ]\n    to_delete = elems [ 0 : k - 1 ]\n    while to_delete and to_delete [ - 1 ] == target :\n        to_delete.pop ( )\n    print ( len ( to_delete ) )\nif __name__ == \"__main__\" :\n    main ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT n , k = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE elems = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE all_same = lambda arr : all ( [ x == arr [ 0 ] for x in arr ] ) NEW_LINE if all_same ( elems ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT if k == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT if not all_same ( elems [ k - 1 : ] ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT target = elems [ - 1 ] NEW_LINE to_delete = elems [ 0 : k - 1 ] NEW_LINE while to_delete and to_delete [ - 1 ] == target : NEW_LINE INDENT to_delete . pop ( ) NEW_LINE DEDENT print ( len ( to_delete ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3280_A", "sol": 0, "python_code": "def binomialCoeff ( n , k ) :\n    C = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ]\n    for i in range ( 0 , n + 1 , 1 ) :\n        for j in range ( 0 , min ( i , k ) + 1 , 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]\n    return C [ n ] [ k ]\nif __name__ == '__main__' :\n    n = 5\n    k = 3\n    print ( \"Total number of different ways are\" , binomialCoeff ( n - 1 , k - 1 ) )\n", "python_code_tokenized": "def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , k ) + 1 , 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 3 NEW_LINE print ( \" Total \u2581 number \u2581 of \u2581 different \u2581 ways \u2581 are \" , binomialCoeff ( n - 1 , k - 1 ) ) NEW_LINE DEDENT"}
{"id": "aizu_p01840_A", "sol": 0, "python_code": "N , M , T = map ( int , input ( ).split ( ) )\nA = list ( map ( int , input ( ).split ( ) ) )\nprv = 0\ncnt = 0\nfor a in A :\n    if prv == 0 :\n        cnt += a - M\n    else :\n        if prv + M < a - M :\n            cnt += ( a - M ) - ( prv + M )\n    prv = a\nif prv + M < T :\n    cnt += T - ( prv + M )\nprint ( cnt )\n", "python_code_tokenized": "N , M , T = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE prv = 0 NEW_LINE cnt = 0 NEW_LINE for a in A : NEW_LINE INDENT if prv == 0 : NEW_LINE INDENT cnt += a - M NEW_LINE DEDENT else : NEW_LINE INDENT if prv + M < a - M : NEW_LINE INDENT cnt += ( a - M ) - ( prv + M ) NEW_LINE DEDENT DEDENT prv = a NEW_LINE DEDENT if prv + M < T : NEW_LINE INDENT cnt += T - ( prv + M ) NEW_LINE DEDENT print ( cnt ) NEW_LINE"}
{"id": "aizu_p01880_A", "sol": 0, "python_code": "import itertools\ndef check ( x : int ) -> bool :\n    s = str ( x )\n    prev = ord ( s [ 0 ] )\n    for c in s [ 1 : ] :\n        if ord ( c ) != prev + 1 :\n            return False\n        prev = ord ( c )\n    return True\ndef main ( ) -> None :\n    n = int ( input ( ) )\n    v = list ( map ( int , input ( ).split ( ' ' ) ) )\n    max_ = - 1\n    for c in itertools.combinations ( sorted ( v ) , 2 ) :\n        p = c [ 0 ] * c [ 1 ]\n        if check ( p ) :\n            max_ = max ( max_ , p )\n    print ( max_ )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "import itertools NEW_LINE def check ( x : int ) -> bool : NEW_LINE INDENT s = str ( x ) NEW_LINE prev = ord ( s [ 0 ] ) NEW_LINE for c in s [ 1 : ] : NEW_LINE INDENT if ord ( c ) != prev + 1 : NEW_LINE INDENT return False NEW_LINE DEDENT prev = ord ( c ) NEW_LINE DEDENT return True NEW_LINE DEDENT def main ( ) -> None : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE v = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE max_ = - 1 NEW_LINE for c in itertools . combinations ( sorted ( v ) , 2 ) : NEW_LINE INDENT p = c [ 0 ] * c [ 1 ] NEW_LINE if check ( p ) : NEW_LINE INDENT max_ = max ( max_ , p ) NEW_LINE DEDENT DEDENT print ( max_ ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "aizu_p00935_A", "sol": 0, "python_code": "n = int ( input ( ) )\nlength = int ( n / 19 ) + 1\nif n > 19 and n % 19 == 0 :\n    length -= 1\nd = [ ]\nfor i in range ( length ) :\n    d += list ( map ( int , input ( ).split ( ) ) )\nstart , end = 1 , 10\nl = [ ]\nflag = False\nfor j in range ( 1 , len ( d ) + 1 ) :\n    for i in range ( 0 , len ( d ) ) :\n        tmp = ''.join ( map ( str , d [ i : i + j ] ) )\n        if len ( tmp ) > 1 and tmp [ 0 ] == '0' :\n            pass\n        elif len ( tmp ) == j :\n            l.append ( int ( tmp ) )\n    l = sorted ( set ( l ) )\n    if start == 1 :\n        for k in range ( 0 , 10 ) :\n            if k not in l :\n                print ( k )\n                flag = True\n                break\n    else :\n        for k in range ( start , end ) :\n            if k not in l :\n                print ( k )\n                flag = True\n                break\n    if flag :\n        break\n    start , end = start * 10 , end * 10\n    l = [ ]\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE length = int ( n / 19 ) + 1 NEW_LINE if n > 19 and n % 19 == 0 : NEW_LINE INDENT length -= 1 NEW_LINE DEDENT d = [ ] NEW_LINE for i in range ( length ) : NEW_LINE INDENT d += list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT start , end = 1 , 10 NEW_LINE l = [ ] NEW_LINE flag = False NEW_LINE for j in range ( 1 , len ( d ) + 1 ) : NEW_LINE INDENT for i in range ( 0 , len ( d ) ) : NEW_LINE INDENT tmp = ' ' . join ( map ( str , d [ i : i + j ] ) ) NEW_LINE if len ( tmp ) > 1 and tmp [ 0 ] == '0' : NEW_LINE INDENT pass NEW_LINE DEDENT elif len ( tmp ) == j : NEW_LINE INDENT l . append ( int ( tmp ) ) NEW_LINE DEDENT DEDENT l = sorted ( set ( l ) ) NEW_LINE if start == 1 : NEW_LINE INDENT for k in range ( 0 , 10 ) : NEW_LINE INDENT if k not in l : NEW_LINE INDENT print ( k ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for k in range ( start , end ) : NEW_LINE INDENT if k not in l : NEW_LINE INDENT print ( k ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if flag : NEW_LINE INDENT break NEW_LINE DEDENT start , end = start * 10 , end * 10 NEW_LINE l = [ ] NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2091_A", "sol": 0, "python_code": "from math import sqrt\nMAX = 1000000\nprime = [ True ] * MAX\ndef SieveOfEratosthenes ( ) :\n    for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) :\n        if ( prime [ p ] ) :\n            for i in range ( p * p , MAX , p ) :\n                prime [ i ] = False ;\ndef sumPrime ( k ) :\n    SieveOfEratosthenes ( ) ;\n    v = [ ] ;\n    for i in range ( 2 , MAX ) :\n        if ( prime [ i ] ) :\n            v.append ( i ) ;\n    sum = 0 ;\n    skip = ( k * ( k - 1 ) ) // 2 ;\n    while ( k > 0 ) :\n        sum += v [ skip ] ;\n        skip += 1 ;\n        k -= 1 ;\n    return sum ;\nif __name__ == \"__main__\" :\n    k = 3 ;\n    print ( sumPrime ( k ) ) ;\n", "python_code_tokenized": "from math import sqrt NEW_LINE MAX = 1000000 NEW_LINE prime = [ True ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( k ) : NEW_LINE INDENT SieveOfEratosthenes ( ) ; NEW_LINE v = [ ] ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT v . append ( i ) ; NEW_LINE DEDENT DEDENT sum = 0 ; NEW_LINE skip = ( k * ( k - 1 ) ) // 2 ; NEW_LINE while ( k > 0 ) : NEW_LINE INDENT sum += v [ skip ] ; NEW_LINE skip += 1 ; NEW_LINE k -= 1 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 3 ; NEW_LINE print ( sumPrime ( k ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_768_A", "sol": 0, "python_code": "from math import gcd\ndef cntSubArr ( arr , n ) :\n    ans = 0 ;\n    for i in range ( n ) :\n        curr_gcd = 0 ;\n        for j in range ( i , n ) :\n            curr_gcd = gcd ( curr_gcd , arr [ j ] ) ;\n            ans += ( curr_gcd == 1 ) ;\n    return ans ;\nif __name__ == \"__main__\" :\n    arr = [ 1 , 1 , 1 ] ;\n    n = len ( arr ) ;\n    print ( cntSubArr ( arr , n ) ) ;\n", "python_code_tokenized": "from math import gcd NEW_LINE def cntSubArr ( arr , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_gcd = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_gcd = gcd ( curr_gcd , arr [ j ] ) ; NEW_LINE ans += ( curr_gcd == 1 ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( cntSubArr ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_609_B", "sol": 0, "python_code": "def _input ( ) : return map ( int , input ( ).split ( ) )\nn , m = _input ( )\nlst = list ( _input ( ) )\nl = { }\nfor i in range ( n ) :\n    if lst [ i ] not in l :\n        l [ lst [ i ] ] = 1\n    else : l [ lst [ i ] ] += 1\nres = 0\nfor i in range ( n ) :\n    if l [ lst [ i ] ] > 1 :\n        res += n - i - l [ lst [ i ] ]\n        l [ lst [ i ] ] -= 1\n    else :\n        res += n - i - 1\nprint ( res )\n", "python_code_tokenized": "def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE n , m = _input ( ) NEW_LINE lst = list ( _input ( ) ) NEW_LINE l = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if lst [ i ] not in l : NEW_LINE INDENT l [ lst [ i ] ] = 1 NEW_LINE DEDENT else : l [ lst [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ lst [ i ] ] > 1 : NEW_LINE INDENT res += n - i - l [ lst [ i ] ] NEW_LINE l [ lst [ i ] ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += n - i - 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE"}
{"id": "codeforces_2_A", "sol": 0, "python_code": "from collections import defaultdict\nfrom math import inf\nn = int ( input ( ) )\nr = [ ]\nd = defaultdict ( int )\nfor i in range ( n ) :\n    x = input ( ).split ( )\n    name , score = x [ 0 ] , int ( x [ 1 ] )\n    d [ name ] += score\n    r.append ( ( name , score ) )\nwinners = set ( )\nbest = 0\nfor name in d :\n    if d [ name ] > best :\n        best = d [ name ]\n        winners = { name }\n    elif d [ name ] == best :\n        winners.add ( name )\nd = defaultdict ( int )\nfor i in range ( n ) :\n    name , score = r [ i ]\n    d [ name ] += score\n    if name in winners and d [ name ] >= best :\n        print ( name )\n        break\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE from math import inf NEW_LINE n = int ( input ( ) ) NEW_LINE r = [ ] NEW_LINE d = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = input ( ) . split ( ) NEW_LINE name , score = x [ 0 ] , int ( x [ 1 ] ) NEW_LINE d [ name ] += score NEW_LINE r . append ( ( name , score ) ) NEW_LINE DEDENT winners = set ( ) NEW_LINE best = 0 NEW_LINE for name in d : NEW_LINE INDENT if d [ name ] > best : NEW_LINE INDENT best = d [ name ] NEW_LINE winners = { name } NEW_LINE DEDENT elif d [ name ] == best : NEW_LINE INDENT winners . add ( name ) NEW_LINE DEDENT DEDENT d = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT name , score = r [ i ] NEW_LINE d [ name ] += score NEW_LINE if name in winners and d [ name ] >= best : NEW_LINE INDENT print ( name ) NEW_LINE break NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_496_A", "sol": 0, "python_code": "def CamelCase ( words , pattern ) :\n    map = dict.fromkeys ( words , None ) ;\n    for i in range ( len ( words ) ) :\n        string = \"\" ;\n        l = len ( words [ i ] ) ;\n        for j in range ( l ) :\n            if ( words [ i ] [ j ] >= 'A' and words [ i ] [ j ] <= 'Z' ) :\n                string += words [ i ] [ j ] ;\n                if string not in map :\n                    map [ string ] = [ words [ i ] ]\n                elif map [ string ] is None :\n                    map [ string ] = [ words [ i ] ]\n                else :\n                    map [ string ].append ( words [ i ] ) ;\n    wordFound = False ;\n    for key , value in map.items ( ) :\n        if ( key == pattern ) :\n            wordFound = True ;\n            for itt in value :\n                print ( itt ) ;\n    if ( not wordFound ) :\n        print ( \"No match found\" ) ;\nif __name__ == \"__main__\" :\n    words = [ \"Hi\" , \"Hello\" , \"HelloWorld\" , \"HiTech\" , \"HiGeek\" , \"HiTechWorld\" , \"HiTechCity\" , \"HiTechLab\" ] ;\n    pattern = \"HT\" ;\n    CamelCase ( words , pattern ) ;\n", "python_code_tokenized": "def CamelCase ( words , pattern ) : NEW_LINE INDENT map = dict . fromkeys ( words , None ) ; NEW_LINE for i in range ( len ( words ) ) : NEW_LINE INDENT string = \" \" ; NEW_LINE l = len ( words [ i ] ) ; NEW_LINE for j in range ( l ) : NEW_LINE INDENT if ( words [ i ] [ j ] >= ' A ' and words [ i ] [ j ] <= ' Z ' ) : NEW_LINE INDENT string += words [ i ] [ j ] ; NEW_LINE if string not in map : NEW_LINE INDENT map [ string ] = [ words [ i ] ] NEW_LINE DEDENT elif map [ string ] is None : NEW_LINE INDENT map [ string ] = [ words [ i ] ] NEW_LINE DEDENT else : NEW_LINE INDENT map [ string ] . append ( words [ i ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT wordFound = False ; NEW_LINE for key , value in map . items ( ) : NEW_LINE INDENT if ( key == pattern ) : NEW_LINE INDENT wordFound = True ; NEW_LINE for itt in value : NEW_LINE INDENT print ( itt ) ; NEW_LINE DEDENT DEDENT DEDENT if ( not wordFound ) : NEW_LINE INDENT print ( \" No \u2581 match \u2581 found \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT words = [ \" Hi \" , \" Hello \" , \" HelloWorld \" , \" HiTech \" , \" HiGeek \" , \" HiTechWorld \" , \" HiTechCity \" , \" HiTechLab \" ] ; NEW_LINE pattern = \" HT \" ; NEW_LINE CamelCase ( words , pattern ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5164_A", "sol": 0, "python_code": "MAX_CHAR = 256 ;\ncount = [ 0 ] * ( MAX_CHAR + 1 ) ;\ndef fact ( n ) :\n    return 1 if ( n <= 1 ) else ( n * fact ( n - 1 ) ) ;\ndef populateAndIncreaseCount ( str ) :\n    for i in range ( len ( str ) ) :\n        count [ ord ( str [ i ] ) ] += 1 ;\n    for i in range ( 1 , MAX_CHAR ) :\n        count [ i ] += count [ i - 1 ] ;\ndef updatecount ( ch ) :\n    for i in range ( ord ( ch ) , MAX_CHAR ) :\n        count [ i ] -= 1 ;\ndef findRank ( str ) :\n    len1 = len ( str ) ;\n    mul = fact ( len1 ) ;\n    rank = 1 ;\n    populateAndIncreaseCount ( str ) ;\n    for i in range ( len1 ) :\n        mul = mul // ( len1 - i ) ;\n        rank += count [ ord ( str [ i ] ) - 1 ] * mul ;\n        updatecount ( str [ i ] ) ;\n    return rank ;\nstr = \"string\" ;\nprint ( findRank ( str ) ) ;\n", "python_code_tokenized": "MAX_CHAR = 256 ; NEW_LINE count = [ 0 ] * ( MAX_CHAR + 1 ) ; NEW_LINE def fact ( n ) : NEW_LINE INDENT return 1 if ( n <= 1 ) else ( n * fact ( n - 1 ) ) ; NEW_LINE DEDENT def populateAndIncreaseCount ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 ; NEW_LINE DEDENT for i in range ( 1 , MAX_CHAR ) : NEW_LINE INDENT count [ i ] += count [ i - 1 ] ; NEW_LINE DEDENT DEDENT def updatecount ( ch ) : NEW_LINE INDENT for i in range ( ord ( ch ) , MAX_CHAR ) : NEW_LINE INDENT count [ i ] -= 1 ; NEW_LINE DEDENT DEDENT def findRank ( str ) : NEW_LINE INDENT len1 = len ( str ) ; NEW_LINE mul = fact ( len1 ) ; NEW_LINE rank = 1 ; NEW_LINE populateAndIncreaseCount ( str ) ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT mul = mul // ( len1 - i ) ; NEW_LINE rank += count [ ord ( str [ i ] ) - 1 ] * mul ; NEW_LINE updatecount ( str [ i ] ) ; NEW_LINE DEDENT return rank ; NEW_LINE DEDENT str = \" string \" ; NEW_LINE print ( findRank ( str ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_2316_A", "sol": 0, "python_code": "def minimumMoves ( a , n ) :\n    operations = 0\n    a.sort ( reverse = False )\n    for i in range ( 0 , n , 1 ) :\n        operations = operations + abs ( a [ i ] - ( i + 1 ) )\n    return operations\nif __name__ == '__main__' :\n    arr = [ 5 , 3 , 2 ]\n    n = len ( arr )\n    print ( minimumMoves ( arr , n ) )\n", "python_code_tokenized": "def minimumMoves ( a , n ) : NEW_LINE INDENT operations = 0 NEW_LINE a . sort ( reverse = False ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT operations = operations + abs ( a [ i ] - ( i + 1 ) ) NEW_LINE DEDENT return operations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumMoves ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "leetcode_844_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def backspaceCompare ( self , S , T ) :\n        if S == T :\n            return True\n        s_stack = [ ]\n        t_stack = [ ]\n        for c in S :\n            if c != '#' :\n                s_stack.append ( c )\n            elif len ( s_stack ) != 0 :\n                s_stack.pop ( - 1 )\n        for c in T :\n            if c != '#' :\n                t_stack.append ( c )\n            elif len ( t_stack ) != 0 :\n                t_stack.pop ( - 1 )\n        return ''.join ( s_stack ) == ''.join ( t_stack )\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def backspaceCompare ( self , S , T ) : NEW_LINE INDENT if S == T : NEW_LINE INDENT return True NEW_LINE DEDENT s_stack = [ ] NEW_LINE t_stack = [ ] NEW_LINE for c in S : NEW_LINE INDENT if c != ' # ' : NEW_LINE INDENT s_stack . append ( c ) NEW_LINE DEDENT elif len ( s_stack ) != 0 : NEW_LINE INDENT s_stack . pop ( - 1 ) NEW_LINE DEDENT DEDENT for c in T : NEW_LINE INDENT if c != ' # ' : NEW_LINE INDENT t_stack . append ( c ) NEW_LINE DEDENT elif len ( t_stack ) != 0 : NEW_LINE INDENT t_stack . pop ( - 1 ) NEW_LINE DEDENT DEDENT return ' ' . join ( s_stack ) == ' ' . join ( t_stack ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00233_A", "sol": 0, "python_code": "while True :\n    X = input ( )\n    if X == '0' : break\n    r = ''\n    minus = False\n    if X [ 0 ] == '-' :\n        minus = True\n        X = X [ 1 : ]\n    kuri = 0\n    idx = len ( X ) - 1\n    while idx >= 0 :\n        a = int ( X [ idx ] )\n        if minus :\n            r = str ( ( 10 - a - kuri ) % 10 ) + r\n            kuri = 0 if kuri + a == 0 else 1\n        else :\n            r = str ( ( kuri + a ) % 10 ) + r\n            kuri = ( kuri + a ) // 10\n        minus = not minus\n        if idx == 0 and kuri > 0 :\n            X = '0' + X\n        else :\n            idx -= 1\n    r = str ( kuri ) + r\n    print ( int ( r ) )\n", "python_code_tokenized": "while True : NEW_LINE INDENT X = input ( ) NEW_LINE if X == '0' : break NEW_LINE r = ' ' NEW_LINE minus = False NEW_LINE if X [ 0 ] == ' - ' : NEW_LINE INDENT minus = True NEW_LINE X = X [ 1 : ] NEW_LINE DEDENT kuri = 0 NEW_LINE idx = len ( X ) - 1 NEW_LINE while idx >= 0 : NEW_LINE INDENT a = int ( X [ idx ] ) NEW_LINE if minus : NEW_LINE INDENT r = str ( ( 10 - a - kuri ) % 10 ) + r NEW_LINE kuri = 0 if kuri + a == 0 else 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = str ( ( kuri + a ) % 10 ) + r NEW_LINE kuri = ( kuri + a ) // 10 NEW_LINE DEDENT minus = not minus NEW_LINE if idx == 0 and kuri > 0 : NEW_LINE INDENT X = '0' + X NEW_LINE DEDENT else : NEW_LINE INDENT idx -= 1 NEW_LINE DEDENT DEDENT r = str ( kuri ) + r NEW_LINE print ( int ( r ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2109_A", "sol": 0, "python_code": "def validate ( n ) :\n    for i in range ( 10 ) :\n        temp = n ;\n        count = 0 ;\n        while ( temp ) :\n            if ( temp % 10 == i ) :\n                count += 1 ;\n            if ( count > i ) :\n                return - 1 ;\n            temp //= 10 ;\n    return 1 ;\nn = 1552793 ;\ngeek = \"True\" if validate ( n ) else \"False\" ;\nprint ( geek ) ;\n", "python_code_tokenized": "def validate ( n ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT temp = n ; NEW_LINE count = 0 ; NEW_LINE while ( temp ) : NEW_LINE INDENT if ( temp % 10 == i ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count > i ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT temp //= 10 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT n = 1552793 ; NEW_LINE geek = \" True \" if validate ( n ) else \" False \" ; NEW_LINE print ( geek ) ; NEW_LINE"}
{"id": "geeksforgeeks_2839_A", "sol": 0, "python_code": "MAX_CHARS = 26\ndef isValid ( count , k ) :\n    val = 0\n    for i in range ( MAX_CHARS ) :\n        if count [ i ] > 0 :\n            val += 1\n    return ( k >= val )\ndef kUniques ( s , k ) :\n    u = 0\n    n = len ( s )\n    count = [ 0 ] * MAX_CHARS\n    for i in range ( n ) :\n        if count [ ord ( s [ i ] ) - ord ( 'a' ) ] == 0 :\n            u += 1\n        count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1\n    if u < k :\n        print ( \"Not enough unique characters\" )\n        return\n    curr_start = 0\n    curr_end = 0\n    max_window_size = 1\n    max_window_start = 0\n    count = [ 0 ] * len ( count )\n    count [ ord ( s [ 0 ] ) - ord ( 'a' ) ] += 1\n    for i in range ( 1 , n ) :\n        count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1\n        curr_end += 1\n        while not isValid ( count , k ) :\n            count [ ord ( s [ curr_start ] ) - ord ( 'a' ) ] -= 1\n            curr_start += 1\n        if curr_end - curr_start + 1 > max_window_size :\n            max_window_size = curr_end - curr_start + 1\n            max_window_start = curr_start\n    print ( \"Max substring is : \" + s [ max_window_start : max_window_start + max_window_size ] + \" with length \" + str ( max_window_size ) )\ns = \"aabacbebebe\"\nk = 3\nkUniques ( s , k )\n", "python_code_tokenized": "MAX_CHARS = 26 NEW_LINE def isValid ( count , k ) : NEW_LINE INDENT val = 0 NEW_LINE for i in range ( MAX_CHARS ) : NEW_LINE INDENT if count [ i ] > 0 : NEW_LINE INDENT val += 1 NEW_LINE DEDENT DEDENT return ( k >= val ) NEW_LINE DEDENT def kUniques ( s , k ) : NEW_LINE INDENT u = 0 NEW_LINE n = len ( s ) NEW_LINE count = [ 0 ] * MAX_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT u += 1 NEW_LINE DEDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if u < k : NEW_LINE INDENT print ( \" Not \u2581 enough \u2581 unique \u2581 characters \" ) NEW_LINE return NEW_LINE DEDENT curr_start = 0 NEW_LINE curr_end = 0 NEW_LINE max_window_size = 1 NEW_LINE max_window_start = 0 NEW_LINE count = [ 0 ] * len ( count ) NEW_LINE count [ ord ( s [ 0 ] ) - ord ( ' a ' ) ] += 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE curr_end += 1 NEW_LINE while not isValid ( count , k ) : NEW_LINE INDENT count [ ord ( s [ curr_start ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE curr_start += 1 NEW_LINE DEDENT if curr_end - curr_start + 1 > max_window_size : NEW_LINE INDENT max_window_size = curr_end - curr_start + 1 NEW_LINE max_window_start = curr_start NEW_LINE DEDENT DEDENT print ( \" Max \u2581 substring \u2581 is \u2581 : \u2581 \" + s [ max_window_start : max_window_start + max_window_size ] + \" \u2581 with \u2581 length \u2581 \" + str ( max_window_size ) ) NEW_LINE DEDENT s = \" aabacbebebe \" NEW_LINE k = 3 NEW_LINE kUniques ( s , k ) NEW_LINE"}
{"id": "geeksforgeeks_3582_A", "sol": 0, "python_code": "def lenOfLongSubarr ( arr , n ) :\n    um = { i : 0 for i in range ( 10 ) }\n    sum = 0\n    maxLen = 0\n    for i in range ( n ) :\n        if arr [ i ] == 0 :\n            sum += - 1\n        else :\n            sum += 1\n        if ( sum == 1 ) :\n            maxLen = i + 1\n        elif ( sum not in um ) :\n            um [ sum ] = i\n        if ( ( sum - 1 ) in um ) :\n            if ( maxLen < ( i - um [ sum - 1 ] ) ) :\n                maxLen = i - um [ sum - 1 ]\n    return maxLen\nif __name__ == '__main__' :\n    arr = [ 0 , 1 , 1 , 0 , 0 , 1 ]\n    n = len ( arr )\n    print ( \"Length =\" , lenOfLongSubarr ( arr , n ) )\n", "python_code_tokenized": "def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = { i : 0 for i in range ( 10 ) } NEW_LINE sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT sum += - 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif ( sum not in um ) : NEW_LINE INDENT um [ sum ] = i NEW_LINE DEDENT if ( ( sum - 1 ) in um ) : NEW_LINE INDENT if ( maxLen < ( i - um [ sum - 1 ] ) ) : NEW_LINE INDENT maxLen = i - um [ sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 0 , 1 , 1 , 0 , 0 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length \u2581 = \" , lenOfLongSubarr ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3127_A", "sol": 0, "python_code": "class Node :\n    def __init__ ( self , next = None , data = None ) :\n        self.next = next\n        self.data = data\ndef push ( head_ref , new_data ) :\n    new_node = Node ( )\n    new_node.data = new_data\n    new_node.next = ( head_ref )\n    ( head_ref ) = new_node\n    return head_ref\ndef getCount ( head ) :\n    count = 0\n    current = head\n    while ( current != None ) :\n        count = count + 1\n        current = current.next\n    return count\ndef getNth ( head , n ) :\n    curr = head\n    i = 0\n    while ( i < n - 1 and curr != None ) :\n        curr = curr.next\n        i = i + 1\n    return curr.data\ndef printReverse ( head ) :\n    stk = [ ]\n    ptr = head\n    while ( ptr != None ) :\n        stk.append ( ptr )\n        ptr = ptr.next\n    while ( len ( stk ) > 0 ) :\n        print ( stk [ - 1 ].data , end = \" \" )\n        stk.pop ( )\n    print ( \" \" )\nhead = None\nhead = push ( head , 5 )\nhead = push ( head , 4 )\nhead = push ( head , 3 )\nhead = push ( head , 2 )\nhead = push ( head , 1 )\nprintReverse ( head )\n", "python_code_tokenized": "class Node : NEW_LINE INDENT def __init__ ( self , next = None , data = None ) : NEW_LINE INDENT self . next = next NEW_LINE self . data = data NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE DEDENT def getCount ( head ) : NEW_LINE INDENT count = 0 NEW_LINE current = head NEW_LINE while ( current != None ) : NEW_LINE INDENT count = count + 1 NEW_LINE current = current . next NEW_LINE DEDENT return count NEW_LINE DEDENT def getNth ( head , n ) : NEW_LINE INDENT curr = head NEW_LINE i = 0 NEW_LINE while ( i < n - 1 and curr != None ) : NEW_LINE INDENT curr = curr . next NEW_LINE i = i + 1 NEW_LINE DEDENT return curr . data NEW_LINE DEDENT def printReverse ( head ) : NEW_LINE INDENT stk = [ ] NEW_LINE ptr = head NEW_LINE while ( ptr != None ) : NEW_LINE INDENT stk . append ( ptr ) NEW_LINE ptr = ptr . next NEW_LINE DEDENT while ( len ( stk ) > 0 ) : NEW_LINE INDENT print ( stk [ - 1 ] . data , end = \" \u2581 \" ) NEW_LINE stk . pop ( ) NEW_LINE DEDENT print ( \" \u2581 \" ) NEW_LINE DEDENT head = None NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 2 ) NEW_LINE head = push ( head , 1 ) NEW_LINE printReverse ( head ) NEW_LINE"}
{"id": "geeksforgeeks_2099_A", "sol": 0, "python_code": "import math\ndef numberofterm ( n , number ) :\n    firstnum = math.pow ( 10 , n - 1 )\n    lastnum = math.pow ( 10 , n )\n    count = 0\n    for i in range ( int ( firstnum ) , int ( lastnum ) ) :\n        if ( i % number == 0 ) :\n            count += 1\n    return count\nn = 3\nnum = 7\nprint ( numberofterm ( n , num ) )\n", "python_code_tokenized": "import math NEW_LINE def numberofterm ( n , number ) : NEW_LINE INDENT firstnum = math . pow ( 10 , n - 1 ) NEW_LINE lastnum = math . pow ( 10 , n ) NEW_LINE count = 0 NEW_LINE for i in range ( int ( firstnum ) , int ( lastnum ) ) : NEW_LINE INDENT if ( i % number == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 3 NEW_LINE num = 7 NEW_LINE print ( numberofterm ( n , num ) ) NEW_LINE"}
{"id": "geeksforgeeks_2436_A", "sol": 0, "python_code": "def totalSumDivisibleByNum ( n , number ) :\n    firstnum = pow ( 10 , n - 1 )\n    lastnum = pow ( 10 , n )\n    sum = 0\n    for i in range ( firstnum , lastnum ) :\n        if ( i % number == 0 ) :\n            sum += i\n    return sum\nn = 3 ; num = 7\nprint ( totalSumDivisibleByNum ( n , num ) )\n", "python_code_tokenized": "def totalSumDivisibleByNum ( n , number ) : NEW_LINE INDENT firstnum = pow ( 10 , n - 1 ) NEW_LINE lastnum = pow ( 10 , n ) NEW_LINE sum = 0 NEW_LINE for i in range ( firstnum , lastnum ) : NEW_LINE INDENT if ( i % number == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 3 ; num = 7 NEW_LINE print ( totalSumDivisibleByNum ( n , num ) ) NEW_LINE"}
{"id": "geeksforgeeks_4358_A", "sol": 0, "python_code": "N = 3 ;\ndef rotateMatrix ( mat ) :\n    i = N - 1 ;\n    while ( i >= 0 ) :\n        j = N - 1 ;\n        while ( j >= 0 ) :\n            print ( mat [ i ] [ j ] , end = \" \" ) ;\n            j = j - 1 ;\n        print ( ) ;\n        i = i - 1 ;\nmat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ;\nrotateMatrix ( mat ) ;\n", "python_code_tokenized": "N = 3 ; NEW_LINE def rotateMatrix ( mat ) : NEW_LINE INDENT i = N - 1 ; NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT j = N - 1 ; NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" \u2581 \" ) ; NEW_LINE j = j - 1 ; NEW_LINE DEDENT print ( ) ; NEW_LINE i = i - 1 ; NEW_LINE DEDENT DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; NEW_LINE rotateMatrix ( mat ) ; NEW_LINE"}
{"id": "geeksforgeeks_3071_A", "sol": 0, "python_code": "def FirstAndLast ( string ) :\n    arrOfStr = string.split ( ) ;\n    res = \"\" ;\n    for a in arrOfStr :\n        res += a [ 1 : len ( a ) - 1 ] + \" \" ;\n    return res ;\nif __name__ == \"__main__\" :\n    string = \"Geeks for Geeks\" ;\n    print ( string ) ;\n    print ( FirstAndLast ( string ) ) ;\n", "python_code_tokenized": "def FirstAndLast ( string ) : NEW_LINE INDENT arrOfStr = string . split ( ) ; NEW_LINE res = \" \" ; NEW_LINE for a in arrOfStr : NEW_LINE INDENT res += a [ 1 : len ( a ) - 1 ] + \" \u2581 \" ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" Geeks \u2581 for \u2581 Geeks \" ; NEW_LINE print ( string ) ; NEW_LINE print ( FirstAndLast ( string ) ) ; NEW_LINE DEDENT"}
{"id": "atcoder_ABC093_A", "sol": 0, "python_code": "a = input ( )\nif \"a\" in a and \"b\" in a and \"c\" in a :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "a = input ( ) NEW_LINE if \" a \" in a and \" b \" in a and \" c \" in a : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1203_A", "sol": 0, "python_code": "for pratyush in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    a = list ( map ( int , input ( ).split ( ) ) )\n    x = a.index ( 1 )\n    y = a.index ( n )\n    b = a [ x : ] + a [ : x ]\n    c = a [ y : ] + a [ : y ]\n    d , e = a.copy ( ) , a.copy ( )\n    d.sort ( )\n    e.sort ( reverse = True )\n    if d == b or e == c :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "for pratyush in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = a . index ( 1 ) NEW_LINE y = a . index ( n ) NEW_LINE b = a [ x : ] + a [ : x ] NEW_LINE c = a [ y : ] + a [ : y ] NEW_LINE d , e = a . copy ( ) , a . copy ( ) NEW_LINE d . sort ( ) NEW_LINE e . sort ( reverse = True ) NEW_LINE if d == b or e == c : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_70_A", "sol": 0, "python_code": "SIZE = 4\ndef productOfSingelDgt ( n ) :\n    if n >= 0 and n <= 9 :\n        return True\n    prime = [ 2 , 3 , 5 , 7 ]\n    i = 0\n    while i < SIZE and n > 1 :\n        while n % prime [ i ] == 0 :\n            n = n / prime [ i ]\n        i += 1\n    return n == 1\nn = 24\nif productOfSingelDgt ( n ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "SIZE = 4 NEW_LINE def productOfSingelDgt ( n ) : NEW_LINE INDENT if n >= 0 and n <= 9 : NEW_LINE INDENT return True NEW_LINE DEDENT prime = [ 2 , 3 , 5 , 7 ] NEW_LINE i = 0 NEW_LINE while i < SIZE and n > 1 : NEW_LINE INDENT while n % prime [ i ] == 0 : NEW_LINE INDENT n = n / prime [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return n == 1 NEW_LINE DEDENT n = 24 NEW_LINE if productOfSingelDgt ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1342_A", "sol": 0, "python_code": "import math\nN = 1000\ndp = [ 0 ] * ( N + 1 )\ndef seive ( ) :\n    array = [ 0 ] * ( N + 1 )\n    array [ 0 ] = 1\n    array [ 1 ] = 1\n    for i in range ( 2 , math.ceil ( math.sqrt ( N ) + 1 ) ) :\n        if array [ i ] == 0 :\n            for j in range ( i * i , N + 1 , i ) :\n                array [ j ] = 1\n    runningPrimeSum = 0\n    for i in range ( 1 , N + 1 ) :\n        if array [ i ] == 0 :\n            runningPrimeSum += i\n        dp [ i ] = runningPrimeSum\nl = 4\nr = 13\nseive ( )\nprint ( dp [ r ] - dp [ l - 1 ] )\n", "python_code_tokenized": "import math NEW_LINE N = 1000 NEW_LINE dp = [ 0 ] * ( N + 1 ) NEW_LINE def seive ( ) : NEW_LINE INDENT array = [ 0 ] * ( N + 1 ) NEW_LINE array [ 0 ] = 1 NEW_LINE array [ 1 ] = 1 NEW_LINE for i in range ( 2 , math . ceil ( math . sqrt ( N ) + 1 ) ) : NEW_LINE INDENT if array [ i ] == 0 : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT array [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT runningPrimeSum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if array [ i ] == 0 : NEW_LINE INDENT runningPrimeSum += i NEW_LINE DEDENT dp [ i ] = runningPrimeSum NEW_LINE DEDENT DEDENT l = 4 NEW_LINE r = 13 NEW_LINE seive ( ) NEW_LINE print ( dp [ r ] - dp [ l - 1 ] ) NEW_LINE"}
{"id": "atcoder_ABC177_D", "sol": 0, "python_code": "N , M = [ int ( s ) for s in input ( ).split ( ) ]\nhito = [ 0 for i in range ( N ) ]\nedge = [ set ( ) for _ in range ( N ) ]\nfor i in range ( M ) :\n    a , b = [ int ( s ) for s in input ( ).split ( ) ]\n    edge [ a - 1 ].add ( b - 1 )\n    edge [ b - 1 ].add ( a - 1 )\ndef dfs ( start ) :\n    count = 1\n    reach = set ( )\n    reach.add ( start )\n    hito [ start ] = 1\n    while reach :\n        _from = reach.pop ( )\n        for _to in edge [ _from ] :\n            if not ( _to in reach ) and hito [ _to ] == 0 :\n                reach.add ( _to )\n                count += 1\n                hito [ _to ] = 1\n    return ( count )\nans = set ( )\nfor h in range ( N ) :\n    if hito [ h ] == 0 :\n        ans.add ( dfs ( h ) )\nprint ( max ( ans ) )\n", "python_code_tokenized": "N , M = [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE hito = [ 0 for i in range ( N ) ] NEW_LINE edge = [ set ( ) for _ in range ( N ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT a , b = [ int ( s ) for s in input ( ) . split ( ) ] NEW_LINE edge [ a - 1 ] . add ( b - 1 ) NEW_LINE edge [ b - 1 ] . add ( a - 1 ) NEW_LINE DEDENT def dfs ( start ) : NEW_LINE INDENT count = 1 NEW_LINE reach = set ( ) NEW_LINE reach . add ( start ) NEW_LINE hito [ start ] = 1 NEW_LINE while reach : NEW_LINE INDENT _from = reach . pop ( ) NEW_LINE for _to in edge [ _from ] : NEW_LINE INDENT if not ( _to in reach ) and hito [ _to ] == 0 : NEW_LINE INDENT reach . add ( _to ) NEW_LINE count += 1 NEW_LINE hito [ _to ] = 1 NEW_LINE DEDENT DEDENT DEDENT return ( count ) NEW_LINE DEDENT ans = set ( ) NEW_LINE for h in range ( N ) : NEW_LINE INDENT if hito [ h ] == 0 : NEW_LINE INDENT ans . add ( dfs ( h ) ) NEW_LINE DEDENT DEDENT print ( max ( ans ) ) NEW_LINE"}
{"id": "geeksforgeeks_4679_A", "sol": 0, "python_code": "def MaxTotalRectangleArea ( a , n ) :\n    a.sort ( reverse = True )\n    sum = 0\n    flag = False\n    len = 0\n    i = 0\n    while ( i < n - 1 ) :\n        if ( i != 0 ) :\n            i = i + 1\n        if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == False ) :\n            flag = True\n            len = a [ i + 1 ]\n            i = i + 1\n        elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == True ) :\n            sum = sum + a [ i + 1 ] * len\n            flag = False\n            i = i + 1\n    return sum\na = [ 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 ]\nn = len ( a )\nprint ( MaxTotalRectangleArea ( a , n ) )\n", "python_code_tokenized": "def MaxTotalRectangleArea ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE sum = 0 NEW_LINE flag = False NEW_LINE len = 0 NEW_LINE i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == False ) : NEW_LINE INDENT flag = True NEW_LINE len = a [ i + 1 ] NEW_LINE i = i + 1 NEW_LINE DEDENT elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == True ) : NEW_LINE INDENT sum = sum + a [ i + 1 ] * len NEW_LINE flag = False NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT a = [ 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( MaxTotalRectangleArea ( a , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_683_A", "sol": 0, "python_code": "from collections import deque ;\ndef remainingDigit ( S , N ) :\n    c = [ i for i in S ]\n    de = [ 0 , 0 ]\n    count = [ 0 , 0 ]\n    q = deque ( )\n    for i in c :\n        x = 0\n        if i == '1' :\n            x = 1\n        count [ x ] += 1\n        q.append ( x )\n    while ( count [ 0 ] > 0 and count [ 1 ] > 0 ) :\n        t = q.popleft ( )\n        if ( de [ t ] > 0 ) :\n            de [ t ] -= 1\n            count [ t ] -= 1\n        else :\n            de [ t ^ 1 ] += 1\n            q.append ( t )\n    if ( count [ 0 ] > 0 ) :\n        return \"0\"\n    return \"1\"\nif __name__ == '__main__' :\n    S = \"1010100100000\"\n    N = len ( S )\n    print ( remainingDigit ( S , N ) )\n", "python_code_tokenized": "from collections import deque ; NEW_LINE def remainingDigit ( S , N ) : NEW_LINE INDENT c = [ i for i in S ] NEW_LINE de = [ 0 , 0 ] NEW_LINE count = [ 0 , 0 ] NEW_LINE q = deque ( ) NEW_LINE for i in c : NEW_LINE INDENT x = 0 NEW_LINE if i == '1' : NEW_LINE INDENT x = 1 NEW_LINE DEDENT count [ x ] += 1 NEW_LINE q . append ( x ) NEW_LINE DEDENT while ( count [ 0 ] > 0 and count [ 1 ] > 0 ) : NEW_LINE INDENT t = q . popleft ( ) NEW_LINE if ( de [ t ] > 0 ) : NEW_LINE INDENT de [ t ] -= 1 NEW_LINE count [ t ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT de [ t ^ 1 ] += 1 NEW_LINE q . append ( t ) NEW_LINE DEDENT DEDENT if ( count [ 0 ] > 0 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT return \"1\" NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \"1010100100000\" NEW_LINE N = len ( S ) NEW_LINE print ( remainingDigit ( S , N ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1427_B", "sol": 0, "python_code": "import sys\ndef sol ( n , k , s ) :\n    a = sorted ( map ( len , s.strip ( 'L' ).split ( 'W' ) ) )\n    m = len ( a ) + k\n    while a and a [ 0 ] <= k :\n        k -= a.pop ( 0 )\n    return ( 2 * min ( n , m - 1 ) - len ( a ) or 1 ) - 1\ndef main ( ) :\n    f = sys.stdin\n    t = int ( f.readline ( ) )\n    for _ in range ( t ) :\n        n , k = map ( int , f.readline ( ).split ( ) )\n        s = f.readline ( ).strip ( )\n        print ( sol ( n , k , s ) )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "import sys NEW_LINE def sol ( n , k , s ) : NEW_LINE INDENT a = sorted ( map ( len , s . strip ( ' L ' ) . split ( ' W ' ) ) ) NEW_LINE m = len ( a ) + k NEW_LINE while a and a [ 0 ] <= k : NEW_LINE INDENT k -= a . pop ( 0 ) NEW_LINE DEDENT return ( 2 * min ( n , m - 1 ) - len ( a ) or 1 ) - 1 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT f = sys . stdin NEW_LINE t = int ( f . readline ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = map ( int , f . readline ( ) . split ( ) ) NEW_LINE s = f . readline ( ) . strip ( ) NEW_LINE print ( sol ( n , k , s ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "aizu_p00533_A", "sol": 0, "python_code": "h , w = map ( int , input ( ).split ( ) )\ncloud = [ [ i for i in input ( ) ] for i in range ( h ) ]\nflag = 0\ncnt = 0\nfor i in range ( h ) :\n    for j in range ( w ) :\n        if j == w - 1 and flag == 0 and cloud [ i ] [ j ] == '.' :\n            print ( - 1 , end = '' )\n        elif j == w - 1 and cloud [ i ] [ j ] == 'c' :\n            print ( 0 , end = '' )\n            flag = 1\n            cnt = 0\n        elif j == w - 1 and cloud [ i ] [ j ] == '.' :\n            cnt += 1\n            print ( cnt , end = '' )\n        elif flag == 0 and cloud [ i ] [ j ] == '.' :\n            print ( - 1 , end = ' ' )\n        elif cloud [ i ] [ j ] == 'c' :\n            print ( 0 , end = ' ' )\n            flag = 1\n            cnt = 0\n        else :\n            cnt += 1\n            print ( cnt , end = ' ' )\n    print ( )\n    cnt = 0\n    flag = 0\n", "python_code_tokenized": "h , w = map ( int , input ( ) . split ( ) ) NEW_LINE cloud = [ [ i for i in input ( ) ] for i in range ( h ) ] NEW_LINE flag = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if j == w - 1 and flag == 0 and cloud [ i ] [ j ] == ' . ' : NEW_LINE INDENT print ( - 1 , end = ' ' ) NEW_LINE DEDENT elif j == w - 1 and cloud [ i ] [ j ] == ' c ' : NEW_LINE INDENT print ( 0 , end = ' ' ) NEW_LINE flag = 1 NEW_LINE cnt = 0 NEW_LINE DEDENT elif j == w - 1 and cloud [ i ] [ j ] == ' . ' : NEW_LINE INDENT cnt += 1 NEW_LINE print ( cnt , end = ' ' ) NEW_LINE DEDENT elif flag == 0 and cloud [ i ] [ j ] == ' . ' : NEW_LINE INDENT print ( - 1 , end = ' \u2581 ' ) NEW_LINE DEDENT elif cloud [ i ] [ j ] == ' c ' : NEW_LINE INDENT print ( 0 , end = ' \u2581 ' ) NEW_LINE flag = 1 NEW_LINE cnt = 0 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE print ( cnt , end = ' \u2581 ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE cnt = 0 NEW_LINE flag = 0 NEW_LINE DEDENT"}
{"id": "codeforces_900_A", "sol": 0, "python_code": "n = int ( input ( ) )\nleft = 0\nright = 0\nfor _ in range ( n ) :\n    a , b = map ( int , input ( ).split ( ) )\n    if a > 0 : right += 1\n    elif a < 0 : left += 1\nif left == 0 or right == 0 or left == 1 or right == 1 :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > 0 : right += 1 NEW_LINE elif a < 0 : left += 1 NEW_LINE DEDENT if left == 0 or right == 0 or left == 1 or right == 1 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "codeforces_303_B", "sol": 0, "python_code": "import math\nn , m , x , y , a , b = map ( int , input ( ).split ( ) )\ngcd = math.gcd ( a , b )\na //= gcd\nb //= gcd\nmax_ratio = min ( n // a , m // b )\na *= max_ratio\nb *= max_ratio\nx1 = max ( 0 , min ( x - ( a + 1 ) // 2 , n - a ) )\ny1 = max ( 0 , min ( y - ( b + 1 ) // 2 , m - b ) )\nprint ( x1 , y1 , x1 + a , y1 + b )\n", "python_code_tokenized": "import math NEW_LINE n , m , x , y , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE gcd = math . gcd ( a , b ) NEW_LINE a //= gcd NEW_LINE b //= gcd NEW_LINE max_ratio = min ( n // a , m // b ) NEW_LINE a *= max_ratio NEW_LINE b *= max_ratio NEW_LINE x1 = max ( 0 , min ( x - ( a + 1 ) // 2 , n - a ) ) NEW_LINE y1 = max ( 0 , min ( y - ( b + 1 ) // 2 , m - b ) ) NEW_LINE print ( x1 , y1 , x1 + a , y1 + b ) NEW_LINE"}
{"id": "geeksforgeeks_5169_A", "sol": 0, "python_code": "def myCopy ( s1 , s2 , index ) :\n    s2 [ index ] = s1 [ index ] ;\n    if ( index == len ( s1 ) - 1 ) :\n        return ;\n    myCopy ( s1 , s2 , index + 1 ) ;\nif __name__ == '__main__' :\n    s1 = \"GEEKSFORGEEKS\" ;\n    s2 = [ 0 ] * ( len ( s1 ) ) ;\n    index = 0 ;\n    myCopy ( s1 , s2 , index ) ;\n    print ( \"\".join ( s2 ) ) ;\n", "python_code_tokenized": "def myCopy ( s1 , s2 , index ) : NEW_LINE INDENT s2 [ index ] = s1 [ index ] ; NEW_LINE if ( index == len ( s1 ) - 1 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT myCopy ( s1 , s2 , index + 1 ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = \" GEEKSFORGEEKS \" ; NEW_LINE s2 = [ 0 ] * ( len ( s1 ) ) ; NEW_LINE index = 0 ; NEW_LINE myCopy ( s1 , s2 , index ) ; NEW_LINE print ( \" \" . join ( s2 ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_384_A", "sol": 0, "python_code": "n = int ( input ( ) )\nif n % 2 == 0 :\n    print ( n * n // 2 )\n    for x in range ( n // 2 ) :\n        for x in range ( n // 2 ) :\n            print ( \"C.\" , end = \"\" )\n        print ( \"\" )\n        for x in range ( n // 2 ) :\n            print ( \".C\" , end = \"\" )\n        print ( \"\" )\nelse :\n    print ( ( ( ( n // 2 ) + 1 ) * ( ( n // 2 ) + 1 ) ) + ( ( n // 2 ) * ( n // 2 ) ) )\n    for x in range ( n // 2 ) :\n        for x in range ( n // 2 ) :\n            print ( \"C.\" , end = \"\" )\n        print ( \"C\" )\n        for x in range ( n // 2 ) :\n            print ( \".C\" , end = \"\" )\n        print ( \".\" )\n    for x in range ( n // 2 ) :\n        print ( \"C.\" , end = \"\" )\n    print ( \"C\" )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( n * n // 2 ) NEW_LINE for x in range ( n // 2 ) : NEW_LINE INDENT for x in range ( n // 2 ) : NEW_LINE INDENT print ( \" C . \" , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE for x in range ( n // 2 ) : NEW_LINE INDENT print ( \" . C \" , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ( ( ( n // 2 ) + 1 ) * ( ( n // 2 ) + 1 ) ) + ( ( n // 2 ) * ( n // 2 ) ) ) NEW_LINE for x in range ( n // 2 ) : NEW_LINE INDENT for x in range ( n // 2 ) : NEW_LINE INDENT print ( \" C . \" , end = \" \" ) NEW_LINE DEDENT print ( \" C \" ) NEW_LINE for x in range ( n // 2 ) : NEW_LINE INDENT print ( \" . C \" , end = \" \" ) NEW_LINE DEDENT print ( \" . \" ) NEW_LINE DEDENT for x in range ( n // 2 ) : NEW_LINE INDENT print ( \" C . \" , end = \" \" ) NEW_LINE DEDENT print ( \" C \" ) NEW_LINE DEDENT"}
{"id": "aizu_p00069_A", "sol": 0, "python_code": "while True :\n    n = int ( input ( ) )\n    if not n :\n        break\n    start = int ( input ( ) ) - 1\n    goal = int ( input ( ) ) - 1\n    d = int ( input ( ) )\n    nums = [ [ i for i in range ( n ) ] ]\n    bars = [ ]\n    for i in range ( d ) :\n        s = input ( )\n        bars.append ( s )\n        new = nums [ - 1 ] [ : ]\n        for j in range ( n - 1 ) :\n            if s [ j ] == \"1\" :\n                new [ j ] , new [ j + 1 ] = new [ j + 1 ] , new [ j ]\n        nums.append ( new )\n    to_goal = nums [ - 1 ] [ goal ]\n    if to_goal == start :\n        print ( 0 )\n    else :\n        for i , status in enumerate ( nums [ 1 : ] ) :\n            to_goal_ind = status.index ( to_goal )\n            start_ind = status.index ( start )\n            ind1 , ind2 = min ( to_goal_ind , start_ind ) , max ( to_goal_ind , start_ind )\n            if ind2 - ind1 == 1 :\n                if ( bars [ i ] [ ind1 ] == \"0\" ) and ( ind1 == 0 or bars [ i ] [ ind1 - 1 ] == \"0\" ) and ( ind2 == n - 1 or bars [ i ] [ ind2 ] == \"0\" ) :\n                    print ( i + 1 , ind1 + 1 )\n                    break\n        else :\n            print ( 1 )\n", "python_code_tokenized": "while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT start = int ( input ( ) ) - 1 NEW_LINE goal = int ( input ( ) ) - 1 NEW_LINE d = int ( input ( ) ) NEW_LINE nums = [ [ i for i in range ( n ) ] ] NEW_LINE bars = [ ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT s = input ( ) NEW_LINE bars . append ( s ) NEW_LINE new = nums [ - 1 ] [ : ] NEW_LINE for j in range ( n - 1 ) : NEW_LINE INDENT if s [ j ] == \"1\" : NEW_LINE INDENT new [ j ] , new [ j + 1 ] = new [ j + 1 ] , new [ j ] NEW_LINE DEDENT DEDENT nums . append ( new ) NEW_LINE DEDENT to_goal = nums [ - 1 ] [ goal ] NEW_LINE if to_goal == start : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i , status in enumerate ( nums [ 1 : ] ) : NEW_LINE INDENT to_goal_ind = status . index ( to_goal ) NEW_LINE start_ind = status . index ( start ) NEW_LINE ind1 , ind2 = min ( to_goal_ind , start_ind ) , max ( to_goal_ind , start_ind ) NEW_LINE if ind2 - ind1 == 1 : NEW_LINE INDENT if ( bars [ i ] [ ind1 ] == \"0\" ) and ( ind1 == 0 or bars [ i ] [ ind1 - 1 ] == \"0\" ) and ( ind2 == n - 1 or bars [ i ] [ ind2 ] == \"0\" ) : NEW_LINE INDENT print ( i + 1 , ind1 + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_620_A", "sol": 0, "python_code": "def countSubarrays ( arr , n , k ) :\n    start = 0\n    end = 0\n    count = 0\n    sum = arr [ 0 ]\n    while ( start < n and end < n ) :\n        if ( sum < k ) :\n            end += 1\n            if ( end >= start ) :\n                count += end - start\n            if ( end < n ) :\n                sum += arr [ end ]\n        else :\n            sum -= arr [ start ]\n            start += 1\n    return count\nif __name__ == \"__main__\" :\n    array = [ 1 , 11 , 2 , 3 , 15 ]\n    k = 10\n    size = len ( array )\n    print ( countSubarrays ( array , size , k ) )\n", "python_code_tokenized": "def countSubarrays ( arr , n , k ) : NEW_LINE INDENT start = 0 NEW_LINE end = 0 NEW_LINE count = 0 NEW_LINE sum = arr [ 0 ] NEW_LINE while ( start < n and end < n ) : NEW_LINE INDENT if ( sum < k ) : NEW_LINE INDENT end += 1 NEW_LINE if ( end >= start ) : NEW_LINE INDENT count += end - start NEW_LINE DEDENT if ( end < n ) : NEW_LINE INDENT sum += arr [ end ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT sum -= arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT array = [ 1 , 11 , 2 , 3 , 15 ] NEW_LINE k = 10 NEW_LINE size = len ( array ) NEW_LINE print ( countSubarrays ( array , size , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1105_A", "sol": 0, "python_code": "def maxProduct ( arr , n , p ) :\n    minVal = arr [ 0 ]\n    maxVal = arr [ 0 ]\n    maxProduct = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        if ( arr [ i ] < 0 ) :\n            maxVal , minVal = minVal , maxVal\n        maxVal = max ( arr [ i ] , maxVal * arr [ i ] )\n        minVal = min ( arr [ i ] , minVal * arr [ i ] )\n        if ( minVal == p or maxVal == p ) :\n            return True\n        maxProduct = max ( maxProduct , maxVal )\n    return False\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , - 5 , - 4 ]\n    product = - 10\n    n = len ( arr )\n    if ( maxProduct ( arr , n , product ) ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "def maxProduct ( arr , n , p ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE maxVal = arr [ 0 ] NEW_LINE maxProduct = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT maxVal , minVal = minVal , maxVal NEW_LINE DEDENT maxVal = max ( arr [ i ] , maxVal * arr [ i ] ) NEW_LINE minVal = min ( arr [ i ] , minVal * arr [ i ] ) NEW_LINE if ( minVal == p or maxVal == p ) : NEW_LINE INDENT return True NEW_LINE DEDENT maxProduct = max ( maxProduct , maxVal ) NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , - 5 , - 4 ] NEW_LINE product = - 10 NEW_LINE n = len ( arr ) NEW_LINE if ( maxProduct ( arr , n , product ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1129_A", "sol": 0, "python_code": "def LCM ( arr , n ) :\n    max_num = 0 ;\n    for i in range ( n ) :\n        if ( max_num < arr [ i ] ) :\n            max_num = arr [ i ] ;\n    res = 1 ;\n    x = 2 ;\n    while ( x <= max_num ) :\n        indexes = [ ] ;\n        for j in range ( n ) :\n            if ( arr [ j ] % x == 0 ) :\n                indexes.append ( j ) ;\n        if ( len ( indexes ) >= 2 ) :\n            for j in range ( len ( indexes ) ) :\n                arr [ indexes [ j ] ] = int ( arr [ indexes [ j ] ] / x ) ;\n            res = res * x ;\n        else :\n            x += 1 ;\n    for i in range ( n ) :\n        res = res * arr [ i ] ;\n    return res ;\narr = [ 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 ] ;\nn = len ( arr ) ;\nprint ( LCM ( arr , n ) ) ;\n", "python_code_tokenized": "def LCM ( arr , n ) : NEW_LINE INDENT max_num = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max_num < arr [ i ] ) : NEW_LINE INDENT max_num = arr [ i ] ; NEW_LINE DEDENT DEDENT res = 1 ; NEW_LINE x = 2 ; NEW_LINE while ( x <= max_num ) : NEW_LINE INDENT indexes = [ ] ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % x == 0 ) : NEW_LINE INDENT indexes . append ( j ) ; NEW_LINE DEDENT DEDENT if ( len ( indexes ) >= 2 ) : NEW_LINE INDENT for j in range ( len ( indexes ) ) : NEW_LINE INDENT arr [ indexes [ j ] ] = int ( arr [ indexes [ j ] ] / x ) ; NEW_LINE DEDENT res = res * x ; NEW_LINE DEDENT else : NEW_LINE INDENT x += 1 ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT res = res * arr [ i ] ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( LCM ( arr , n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_863_A", "sol": 0, "python_code": "def isProductEven ( arr , n ) :\n    for i in range ( 0 , n ) :\n        if ( ( arr [ i ] & 1 ) == 0 ) :\n            return True\n    return False\narr = [ 2 , 4 , 3 , 5 ]\nn = len ( arr )\nif ( isProductEven ( arr , n ) ) :\n    print ( \"Even\" )\nelse :\n    print ( \"Odd\" )\n", "python_code_tokenized": "def isProductEven ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ i ] & 1 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isProductEven ( arr , n ) ) : NEW_LINE INDENT print ( \" Even \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Odd \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1958_A", "sol": 0, "python_code": "def answerQuery ( a , n , l , r ) :\n    count = 0\n    l = l - 1\n    for i in range ( l , r , 1 ) :\n        element = a [ i ]\n        divisors = 0\n        for j in range ( l , r , 1 ) :\n            if ( a [ j ] % a [ i ] == 0 ) :\n                divisors += 1\n            else :\n                break\n        if ( divisors == ( r - l ) ) :\n            count += 1\n    return count\nif __name__ == '__main__' :\n    a = [ 1 , 2 , 3 , 5 ]\n    n = len ( a )\n    l = 1\n    r = 4\n    print ( answerQuery ( a , n , l , r ) )\n    l = 2\n    r = 4\n    print ( answerQuery ( a , n , l , r ) )\n", "python_code_tokenized": "def answerQuery ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE l = l - 1 NEW_LINE for i in range ( l , r , 1 ) : NEW_LINE INDENT element = a [ i ] NEW_LINE divisors = 0 NEW_LINE for j in range ( l , r , 1 ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT divisors += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( divisors == ( r - l ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 2 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE l = 1 NEW_LINE r = 4 NEW_LINE print ( answerQuery ( a , n , l , r ) ) NEW_LINE l = 2 NEW_LINE r = 4 NEW_LINE print ( answerQuery ( a , n , l , r ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1675_A", "sol": 0, "python_code": "def sumPowersK ( n , k ) :\n    sum = 0 ; num = 1 ;\n    while ( num <= n ) :\n        sum += num ;\n        num *= k ;\n    return sum ;\ndef getSum ( n , k ) :\n    pwrK = sumPowersK ( n , k ) ;\n    sumAll = ( n * ( n + 1 ) ) / 2 ;\n    return ( sumAll - pwrK ) ;\nif __name__ == \"__main__\" :\n    n = 10 ; k = 3 ;\n    print ( getSum ( n , k ) ) ;\n", "python_code_tokenized": "def sumPowersK ( n , k ) : NEW_LINE INDENT sum = 0 ; num = 1 ; NEW_LINE while ( num <= n ) : NEW_LINE INDENT sum += num ; NEW_LINE num *= k ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def getSum ( n , k ) : NEW_LINE INDENT pwrK = sumPowersK ( n , k ) ; NEW_LINE sumAll = ( n * ( n + 1 ) ) / 2 ; NEW_LINE return ( sumAll - pwrK ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 ; k = 3 ; NEW_LINE print ( getSum ( n , k ) ) ; NEW_LINE DEDENT"}
{"id": "atcoder_ARC070_D", "sol": 0, "python_code": "A , B = map ( int , input ( ).split ( \"\" ) )\nif A <= B :\n    print ( \"Impossible\" )\n    exit ( 0 )\nchain = [ ]\nN = A + B\ndef ask ( i , j ) :\n    print ( \"? %d %d\" % ( i , j ) )\n    return input ( ) == 'Y'\nfor i in range ( 0 , N ) :\n    if len ( chain ) == 0 :\n        chain.append ( i )\n        continue\n    last = chain [ - 1 ]\n    if ask ( last , i ) :\n        chain.append ( i )\n    else :\n        chain.pop ( )\nmain = chain.pop ( )\nret = [ ( '1' if ask ( main , x ) else '0' ) for x in range ( 0 , N ) ]\nprint ( \"! %s\" % ( \"\".join ( ret ) ) )\n", "python_code_tokenized": "A , B = map ( int , input ( ) . split ( \" \u2581 \" ) ) NEW_LINE if A <= B : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT chain = [ ] NEW_LINE N = A + B NEW_LINE def ask ( i , j ) : NEW_LINE INDENT print ( \" ? \u2581 % d \u2581 % d \" % ( i , j ) ) NEW_LINE return input ( ) == ' Y ' NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT if len ( chain ) == 0 : NEW_LINE INDENT chain . append ( i ) NEW_LINE continue NEW_LINE DEDENT last = chain [ - 1 ] NEW_LINE if ask ( last , i ) : NEW_LINE INDENT chain . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT chain . pop ( ) NEW_LINE DEDENT DEDENT main = chain . pop ( ) NEW_LINE ret = [ ( '1' if ask ( main , x ) else '0' ) for x in range ( 0 , N ) ] NEW_LINE print ( \" ! \u2581 % s \" % ( \" \" . join ( ret ) ) ) NEW_LINE"}
{"id": "aizu_p01513_A", "sol": 0, "python_code": "while True :\n    persons = int ( input ( ) )\n    if persons == 0 : break\n    receivedlist = [ ]\n    for i in range ( persons ) :\n        target = list ( map ( int , input ( ).split ( ) ) )\n        target = target [ 1 : ]\n        target = set ( target )\n        receivedlist.append ( target )\n    target = list ( map ( int , input ( ).split ( ) ) )\n    target = set ( target [ 1 : ] )\n    answer = [ ]\n    for i in range ( len ( receivedlist ) ) :\n        received_set = receivedlist [ i ]\n        diff = target - received_set\n        if not diff : answer.append ( i + 1 )\n    if len ( answer ) == 1 :\n        print ( answer [ 0 ] )\n    else :\n        print ( - 1 )\n", "python_code_tokenized": "while True : NEW_LINE INDENT persons = int ( input ( ) ) NEW_LINE if persons == 0 : break NEW_LINE receivedlist = [ ] NEW_LINE for i in range ( persons ) : NEW_LINE INDENT target = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE target = target [ 1 : ] NEW_LINE target = set ( target ) NEW_LINE receivedlist . append ( target ) NEW_LINE DEDENT target = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE target = set ( target [ 1 : ] ) NEW_LINE answer = [ ] NEW_LINE for i in range ( len ( receivedlist ) ) : NEW_LINE INDENT received_set = receivedlist [ i ] NEW_LINE diff = target - received_set NEW_LINE if not diff : answer . append ( i + 1 ) NEW_LINE DEDENT if len ( answer ) == 1 : NEW_LINE INDENT print ( answer [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1914_A", "sol": 0, "python_code": "def maxZeros ( N ) :\n    maxm = - 1\n    cnt = 0\n    while ( N ) :\n        if ( not ( N & 1 ) ) :\n            cnt += 1\n            N >>= 1\n            maxm = max ( maxm , cnt )\n        else :\n            maxm = max ( maxm , cnt )\n            cnt = 0\n            N >>= 1\n    return maxm\nN = 14\nprint ( maxZeros ( N ) )\n", "python_code_tokenized": "def maxZeros ( N ) : NEW_LINE INDENT maxm = - 1 NEW_LINE cnt = 0 NEW_LINE while ( N ) : NEW_LINE INDENT if ( not ( N & 1 ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE N >>= 1 NEW_LINE maxm = max ( maxm , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT maxm = max ( maxm , cnt ) NEW_LINE cnt = 0 NEW_LINE N >>= 1 NEW_LINE DEDENT DEDENT return maxm NEW_LINE DEDENT N = 14 NEW_LINE print ( maxZeros ( N ) ) NEW_LINE"}
{"id": "geeksforgeeks_2717_A", "sol": 0, "python_code": "def sortArrays ( arr , length ) :\n    j = 0\n    while ( j < length - 1 ) :\n        d1 = arr [ j ]\n        d2 = arr [ j + 1 ]\n        if ( d1 > d2 ) :\n            temp = arr [ j ]\n            arr [ j ] = arr [ j + 1 ]\n            arr [ j + 1 ] = temp\n            j = - 1\n        j += 1\n    return arr\ngeeks = \"GEEKSFORGEEKS\"\nn = len ( geeks )\narr = [ 0 ] * n\nfor i in range ( n ) :\n    arr [ i ] = geeks [ i ]\nprint ( \"Original array: [\" , end = \"\" )\nfor i in range ( n ) :\n    print ( arr [ i ] , end = \"\" )\n    if ( i + 1 != n ) :\n        print ( \", \" , end = \"\" )\nprint ( \"]\" )\nansarr = sortArrays ( arr , n )\nprint ( \"Sorted array: [\" , end = \"\" )\nfor i in range ( n ) :\n    print ( ansarr [ i ] , end = \"\" )\n    if ( i + 1 != n ) :\n        print ( \", \" , end = \"\" )\nprint ( \"]\" )\n", "python_code_tokenized": "def sortArrays ( arr , length ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < length - 1 ) : NEW_LINE INDENT d1 = arr [ j ] NEW_LINE d2 = arr [ j + 1 ] NEW_LINE if ( d1 > d2 ) : NEW_LINE INDENT temp = arr [ j ] NEW_LINE arr [ j ] = arr [ j + 1 ] NEW_LINE arr [ j + 1 ] = temp NEW_LINE j = - 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT return arr NEW_LINE DEDENT geeks = \" GEEKSFORGEEKS \" NEW_LINE n = len ( geeks ) NEW_LINE arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = geeks [ i ] NEW_LINE DEDENT print ( \" Original \u2581 array : \u2581 [ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \" ) NEW_LINE if ( i + 1 != n ) : NEW_LINE INDENT print ( \" , \u2581 \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( \" ] \" ) NEW_LINE ansarr = sortArrays ( arr , n ) NEW_LINE print ( \" Sorted \u2581 array : \u2581 [ \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( ansarr [ i ] , end = \" \" ) NEW_LINE if ( i + 1 != n ) : NEW_LINE INDENT print ( \" , \u2581 \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( \" ] \" ) NEW_LINE"}
{"id": "aizu_p00048_A", "sol": 0, "python_code": "level = [ \"heavy\" , \"light heavy\" , \"middle\" , \"light middle\" , \"welter\" , \"light welter\" , \"light\" , \"feather\" , \"bantam\" , \"fly\" ]\nweight = [ 91 , 81 , 75 , 69 , 64 , 60 , 57 , 54 , 51 , 48 ]\nwhile True :\n    try :\n        w = float ( input ( ) )\n    except :\n        break\n    f = False\n    for wei , lev in zip ( weight , level ) :\n        if w > wei :\n            print ( lev )\n            f = True\n            break\n    if not f :\n        print ( \"light fly\" )\n", "python_code_tokenized": "level = [ \" heavy \" , \" light \u2581 heavy \" , \" middle \" , \" light \u2581 middle \" , \" welter \" , \" light \u2581 welter \" , \" light \" , \" feather \" , \" bantam \" , \" fly \" ] NEW_LINE weight = [ 91 , 81 , 75 , 69 , 64 , 60 , 57 , 54 , 51 , 48 ] NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT w = float ( input ( ) ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT f = False NEW_LINE for wei , lev in zip ( weight , level ) : NEW_LINE INDENT if w > wei : NEW_LINE INDENT print ( lev ) NEW_LINE f = True NEW_LINE break NEW_LINE DEDENT DEDENT if not f : NEW_LINE INDENT print ( \" light \u2581 fly \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_648_A", "sol": 0, "python_code": "def findMinDifference ( arr , n ) :\n    arr.sort ( )\n    diff1 = arr [ n - 1 ] - arr [ 1 ]\n    diff2 = arr [ n - 2 ] - arr [ 0 ]\n    return min ( diff1 , diff2 )\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 4 , 3 , 4 ]\n    n = len ( arr )\n    print ( findMinDifference ( arr , n ) )\n", "python_code_tokenized": "def findMinDifference ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE diff1 = arr [ n - 1 ] - arr [ 1 ] NEW_LINE diff2 = arr [ n - 2 ] - arr [ 0 ] NEW_LINE return min ( diff1 , diff2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinDifference ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_899_B", "sol": 0, "python_code": "from collections import deque , Counter\nfrom math import *\nimport sys\nimport random\nfrom bisect import *\nfrom functools import reduce\nfrom sys import stdin\nimport copy\nfrom collections import deque , Counter\nfrom math import *\nimport sys\nimport random\nfrom bisect import *\nfrom functools import reduce\nfrom sys import stdin\nimport copy\nn = int ( input ( ) )\ncal = [ 31 , 0 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ]\narr = list ( map ( int , input ( ).split ( ) ) )\nif arr.count ( 29 ) == 2 :\n    print ( \"No\" )\n    sys.exit ( )\ni = 0\nj = 0\nfirst = arr [ 0 ]\nfor j in range ( 12 ) :\n    if first == cal [ j ] or ( cal [ j ] == 0 and ( first == 28 or first == 29 ) ) :\n        x , y = 0 , j\n        count = 0\n        while x < n :\n            if ( cal [ y ] == 0 and ( arr [ x ] == 28 or arr [ x ] == 29 ) ) :\n                count += 1\n            count += arr [ x ] == cal [ y ]\n            x += 1\n            y += 1\n            y %= 12\n        if count == n :\n            print ( \"Yes\" )\n            sys.exit ( )\nprint ( \"No\" )\n", "python_code_tokenized": "from collections import deque , Counter NEW_LINE from math import * NEW_LINE import sys NEW_LINE import random NEW_LINE from bisect import * NEW_LINE from functools import reduce NEW_LINE from sys import stdin NEW_LINE import copy NEW_LINE from collections import deque , Counter NEW_LINE from math import * NEW_LINE import sys NEW_LINE import random NEW_LINE from bisect import * NEW_LINE from functools import reduce NEW_LINE from sys import stdin NEW_LINE import copy NEW_LINE n = int ( input ( ) ) NEW_LINE cal = [ 31 , 0 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if arr . count ( 29 ) == 2 : NEW_LINE INDENT print ( \" No \" ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE first = arr [ 0 ] NEW_LINE for j in range ( 12 ) : NEW_LINE INDENT if first == cal [ j ] or ( cal [ j ] == 0 and ( first == 28 or first == 29 ) ) : NEW_LINE INDENT x , y = 0 , j NEW_LINE count = 0 NEW_LINE while x < n : NEW_LINE INDENT if ( cal [ y ] == 0 and ( arr [ x ] == 28 or arr [ x ] == 29 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT count += arr [ x ] == cal [ y ] NEW_LINE x += 1 NEW_LINE y += 1 NEW_LINE y %= 12 NEW_LINE DEDENT if count == n : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( \" No \" ) NEW_LINE"}
{"id": "projecteuler_p055_A", "sol": 0, "python_code": "def compute ( ) :\n    ans = sum ( 1 for i in range ( 10000 ) if is_lychrel ( i ) )\n    return str ( ans )\ndef is_lychrel ( n ) :\n    for i in range ( 50 ) :\n        n += int ( str ( n ) [ : : - 1 ] )\n        if str ( n ) == str ( n ) [ : : - 1 ] :\n            return False\n    return True\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 10000 ) if is_lychrel ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def is_lychrel ( n ) : NEW_LINE INDENT for i in range ( 50 ) : NEW_LINE INDENT n += int ( str ( n ) [ : : - 1 ] ) NEW_LINE if str ( n ) == str ( n ) [ : : - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1391_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n , m = map ( int , input ( ).split ( ) )\n    lst = [ input ( ) for i in range ( n ) ]\n    print ( lst [ - 1 ].count ( 'D' ) + sum ( i [ - 1 ] == 'R' for i in lst ) )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE lst = [ input ( ) for i in range ( n ) ] NEW_LINE print ( lst [ - 1 ] . count ( ' D ' ) + sum ( i [ - 1 ] == ' R ' for i in lst ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1063_A", "sol": 0, "python_code": "import sys\ninput = sys.stdin.buffer.readline\ndef process ( S ) :\n    S = ''.join ( sorted ( S ) )\n    print ( S )\nn = int ( input ( ) )\nS = input ( ).decode ( ).strip ( )\nprocess ( S )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . buffer . readline NEW_LINE def process ( S ) : NEW_LINE INDENT S = ' ' . join ( sorted ( S ) ) NEW_LINE print ( S ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE S = input ( ) . decode ( ) . strip ( ) NEW_LINE process ( S ) NEW_LINE"}
{"id": "geeksforgeeks_3233_A", "sol": 0, "python_code": "from math import pow\ndef highestPower ( n , k ) :\n    i = 0\n    a = pow ( n , i )\n    while ( a <= k ) :\n        i += 1\n        a = pow ( n , i )\n    return i - 1\nb = [ 0 for i in range ( 50 ) ]\ndef PowerArray ( n , k ) :\n    while ( k ) :\n        t = highestPower ( n , k )\n        if ( b [ t ] ) :\n            print ( - 1 )\n            return 0\n        else :\n            b [ t ] = 1\n        k -= pow ( n , t )\n    for i in range ( 50 ) :\n        if ( b [ i ] ) :\n            print ( i , end = ', ' )\nif __name__ == '__main__' :\n    N = 3\n    K = 40\n    PowerArray ( N , K )\n", "python_code_tokenized": "from math import pow NEW_LINE def highestPower ( n , k ) : NEW_LINE INDENT i = 0 NEW_LINE a = pow ( n , i ) NEW_LINE while ( a <= k ) : NEW_LINE INDENT i += 1 NEW_LINE a = pow ( n , i ) NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT b = [ 0 for i in range ( 50 ) ] NEW_LINE def PowerArray ( n , k ) : NEW_LINE INDENT while ( k ) : NEW_LINE INDENT t = highestPower ( n , k ) NEW_LINE if ( b [ t ] ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT b [ t ] = 1 NEW_LINE DEDENT k -= pow ( n , t ) NEW_LINE DEDENT for i in range ( 50 ) : NEW_LINE INDENT if ( b [ i ] ) : NEW_LINE INDENT print ( i , end = ' , \u2581 ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE K = 40 NEW_LINE PowerArray ( N , K ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC137_E", "sol": 0, "python_code": "n , m , p = map ( int , input ( ).split ( ) )\nabc = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( m ) ]\nabc = [ [ a , b , p - c ] for a , b , c in abc ]\ndef BF ( edges , num_v , source ) :\n    inf = float ( \"inf\" )\n    dist = [ inf for i in range ( num_v ) ]\n    dist [ source - 1 ] = 0\n    neg = [ False for _ in range ( num_v ) ]\n    for i in range ( num_v - 1 ) :\n        for edge in edges :\n            if edge [ 0 ] != inf and dist [ edge [ 1 ] - 1 ] > dist [ edge [ 0 ] - 1 ] + edge [ 2 ] :\n                dist [ edge [ 1 ] - 1 ] = dist [ edge [ 0 ] - 1 ] + edge [ 2 ]\n    for i in range ( num_v ) :\n        for edge in edges :\n            if edge [ 0 ] != inf and dist [ edge [ 1 ] - 1 ] > dist [ edge [ 0 ] - 1 ] + edge [ 2 ] :\n                dist [ edge [ 1 ] - 1 ] = dist [ edge [ 0 ] - 1 ] + edge [ 2 ]\n                neg [ edge [ 1 ] - 1 ] = True\n            if neg [ edge [ 0 ] - 1 ] == True :\n                neg [ edge [ 1 ] - 1 ] = True\n    return dist , neg\ndis , neg = BF ( abc , n , 1 )\nprint ( - 1 if neg [ - 1 ] else max ( 0 , - dis [ - 1 ] ) )\n", "python_code_tokenized": "n , m , p = map ( int , input ( ) . split ( ) ) NEW_LINE abc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] NEW_LINE abc = [ [ a , b , p - c ] for a , b , c in abc ] NEW_LINE def BF ( edges , num_v , source ) : NEW_LINE INDENT inf = float ( \" inf \" ) NEW_LINE dist = [ inf for i in range ( num_v ) ] NEW_LINE dist [ source - 1 ] = 0 NEW_LINE neg = [ False for _ in range ( num_v ) ] NEW_LINE for i in range ( num_v - 1 ) : NEW_LINE INDENT for edge in edges : NEW_LINE INDENT if edge [ 0 ] != inf and dist [ edge [ 1 ] - 1 ] > dist [ edge [ 0 ] - 1 ] + edge [ 2 ] : NEW_LINE INDENT dist [ edge [ 1 ] - 1 ] = dist [ edge [ 0 ] - 1 ] + edge [ 2 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( num_v ) : NEW_LINE INDENT for edge in edges : NEW_LINE INDENT if edge [ 0 ] != inf and dist [ edge [ 1 ] - 1 ] > dist [ edge [ 0 ] - 1 ] + edge [ 2 ] : NEW_LINE INDENT dist [ edge [ 1 ] - 1 ] = dist [ edge [ 0 ] - 1 ] + edge [ 2 ] NEW_LINE neg [ edge [ 1 ] - 1 ] = True NEW_LINE DEDENT if neg [ edge [ 0 ] - 1 ] == True : NEW_LINE INDENT neg [ edge [ 1 ] - 1 ] = True NEW_LINE DEDENT DEDENT DEDENT return dist , neg NEW_LINE DEDENT dis , neg = BF ( abc , n , 1 ) NEW_LINE print ( - 1 if neg [ - 1 ] else max ( 0 , - dis [ - 1 ] ) ) NEW_LINE"}
{"id": "codeforces_1271_A", "sol": 0, "python_code": "from sys import stdin\ninput = stdin.readline\ninp = lambda : list ( map ( int , input ( ).split ( ) ) )\ndef answer ( a , b , c , d , e , f ) :\n    if ( e > f ) :\n        m = min ( a , d )\n        ans = e * m\n        d -= m\n        ans += f * min ( b , c , d )\n    else :\n        m = min ( b , c , d )\n        ans = f * m\n        d -= m\n        ans += e * min ( a , d )\n    return ans\nfor T in range ( 1 ) :\n    a = int ( input ( ) )\n    b = int ( input ( ) )\n    c = int ( input ( ) )\n    d = int ( input ( ) )\n    e = int ( input ( ) )\n    f = int ( input ( ) )\n    print ( answer ( a , b , c , d , e , f ) )\n", "python_code_tokenized": "from sys import stdin NEW_LINE input = stdin . readline NEW_LINE inp = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def answer ( a , b , c , d , e , f ) : NEW_LINE INDENT if ( e > f ) : NEW_LINE INDENT m = min ( a , d ) NEW_LINE ans = e * m NEW_LINE d -= m NEW_LINE ans += f * min ( b , c , d ) NEW_LINE DEDENT else : NEW_LINE INDENT m = min ( b , c , d ) NEW_LINE ans = f * m NEW_LINE d -= m NEW_LINE ans += e * min ( a , d ) NEW_LINE DEDENT return ans NEW_LINE DEDENT for T in range ( 1 ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE c = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE e = int ( input ( ) ) NEW_LINE f = int ( input ( ) ) NEW_LINE print ( answer ( a , b , c , d , e , f ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00067_A", "sol": 0, "python_code": "def count_island ( ban ) :\n    def remove ( x , y ) :\n        if 0 <= y < 12 and 0 <= x < 12 and ban [ y ] [ x ] == 1 :\n            ban [ y ] [ x ] = 0\n            for dx , dy in [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] :\n                remove ( x + dx , y + dy )\n    count = 0\n    for y in range ( 12 ) :\n        for x in range ( 12 ) :\n            if ban [ y ] [ x ] == 1 :\n                count += 1\n                remove ( x , y )\n    print ( count )\nban = [ ]\nwhile True :\n    try :\n        s = input ( )\n    except EOFError :\n        break\n    if s :\n        ban.append ( list ( map ( int , s ) ) )\n    else :\n        count_island ( ban )\n        ban = [ ]\nif ban : count_island ( ban )\n", "python_code_tokenized": "def count_island ( ban ) : NEW_LINE INDENT def remove ( x , y ) : NEW_LINE INDENT if 0 <= y < 12 and 0 <= x < 12 and ban [ y ] [ x ] == 1 : NEW_LINE INDENT ban [ y ] [ x ] = 0 NEW_LINE for dx , dy in [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] : NEW_LINE INDENT remove ( x + dx , y + dy ) NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for y in range ( 12 ) : NEW_LINE INDENT for x in range ( 12 ) : NEW_LINE INDENT if ban [ y ] [ x ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE remove ( x , y ) NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT ban = [ ] NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT s = input ( ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT if s : NEW_LINE INDENT ban . append ( list ( map ( int , s ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT count_island ( ban ) NEW_LINE ban = [ ] NEW_LINE DEDENT DEDENT if ban : count_island ( ban ) NEW_LINE"}
{"id": "aizu_p01138_A", "sol": 0, "python_code": "def calc_imos ( one_day ) :\n    day = [ ]\n    cum_sum = 0\n    for i in one_day :\n        cum_sum += i\n        day.append ( cum_sum )\n    return max ( day )\ndef calc_time ( time ) :\n    h , m , s = map ( int , time.split ( \":\" ) )\n    return h * 60 * 60 + m * 60 + s\nwhile True :\n    N = int ( input ( ) )\n    if N == 0 : break\n    one_day = [ 0 ] * ( 24 * 60 * 60 + 1 )\n    for i in range ( N ) :\n        start , end = input ( ).split ( )\n        start = calc_time ( start )\n        end = calc_time ( end )\n        one_day [ start + 1 ] += 1\n        one_day [ end + 1 ] -= 1\n    print ( calc_imos ( one_day ) )\n", "python_code_tokenized": "def calc_imos ( one_day ) : NEW_LINE INDENT day = [ ] NEW_LINE cum_sum = 0 NEW_LINE for i in one_day : NEW_LINE INDENT cum_sum += i NEW_LINE day . append ( cum_sum ) NEW_LINE DEDENT return max ( day ) NEW_LINE DEDENT def calc_time ( time ) : NEW_LINE INDENT h , m , s = map ( int , time . split ( \" : \" ) ) NEW_LINE return h * 60 * 60 + m * 60 + s NEW_LINE DEDENT while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : break NEW_LINE one_day = [ 0 ] * ( 24 * 60 * 60 + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT start , end = input ( ) . split ( ) NEW_LINE start = calc_time ( start ) NEW_LINE end = calc_time ( end ) NEW_LINE one_day [ start + 1 ] += 1 NEW_LINE one_day [ end + 1 ] -= 1 NEW_LINE DEDENT print ( calc_imos ( one_day ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1323_B", "sol": 0, "python_code": "n , m , k = map ( int , input ( ).split ( ) )\na = [ len ( i ) for i in input ( ).replace ( '' , '' ).split ( '0' ) if len ( i ) > 0 ]\nb = [ len ( i ) for i in input ( ).replace ( '' , '' ).split ( '0' ) if len ( i ) > 0 ]\nd = [ ( i , k // i ) for i in range ( 1 , int ( k ** 0.5 ) + 1 ) if k % i == 0 ]\nd += [ ( j , i ) for i , j in d if i != j ]\nc = 0\nfor x , y in d : c += sum ( i - x + 1 for i in a if x <= i ) * sum ( j - y + 1 for j in b if y <= j )\nprint ( c )\n", "python_code_tokenized": "n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ len ( i ) for i in input ( ) . replace ( ' \u2581 ' , ' ' ) . split ( '0' ) if len ( i ) > 0 ] NEW_LINE b = [ len ( i ) for i in input ( ) . replace ( ' \u2581 ' , ' ' ) . split ( '0' ) if len ( i ) > 0 ] NEW_LINE d = [ ( i , k // i ) for i in range ( 1 , int ( k ** 0.5 ) + 1 ) if k % i == 0 ] NEW_LINE d += [ ( j , i ) for i , j in d if i != j ] NEW_LINE c = 0 NEW_LINE for x , y in d : c += sum ( i - x + 1 for i in a if x <= i ) * sum ( j - y + 1 for j in b if y <= j ) NEW_LINE print ( c ) NEW_LINE"}
{"id": "geeksforgeeks_1030_A", "sol": 0, "python_code": "N = 100005\nmod = 1000000007\ncnt = [ 0 ] * N ;\ndef Divisors ( ) :\n    for i in range ( 1 , N ) :\n        for j in range ( 1 , N // i ) :\n            cnt [ i * j ] += 1 ;\ndef Sumofdivisors ( A , B , C ) :\n    sum = 0 ;\n    Divisors ( ) ;\n    for i in range ( 1 , A + 1 ) :\n        for j in range ( 1 , B + 1 ) :\n            for k in range ( 1 , C + 1 ) :\n                x = i * j * k ;\n                sum += cnt [ x ] ;\n                if ( sum >= mod ) :\n                    sum -= mod ;\n    return sum ;\nif __name__ == \"__main__\" :\n    A = 5 ; B = 6 ; C = 7 ;\n    print ( Sumofdivisors ( A , B , C ) ) ;\n", "python_code_tokenized": "N = 100005 NEW_LINE mod = 1000000007 NEW_LINE cnt = [ 0 ] * N ; NEW_LINE def Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N // i ) : NEW_LINE INDENT cnt [ i * j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT def Sumofdivisors ( A , B , C ) : NEW_LINE INDENT sum = 0 ; NEW_LINE Divisors ( ) ; NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT x = i * j * k ; NEW_LINE sum += cnt [ x ] ; NEW_LINE if ( sum >= mod ) : NEW_LINE INDENT sum -= mod ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 5 ; B = 6 ; C = 7 ; NEW_LINE print ( Sumofdivisors ( A , B , C ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_395_A", "sol": 0, "python_code": "import math\ndef isPrime ( n ) :\n    flag = 1\n    i = 2\n    while ( i * i <= n ) :\n        if ( n % i == 0 ) :\n            flag = 0\n            break\n        i += 1\n    return ( True if flag == 1 else False )\ndef isPerfectSquare ( x ) :\n    sr = math.sqrt ( x )\n    return ( ( sr - math.floor ( sr ) ) == 0 )\ndef countInterestingPrimes ( n ) :\n    answer = 0\n    for i in range ( 2 , n ) :\n        if ( isPrime ( i ) != None ) :\n            j = 1\n            while ( j * j * j * j <= i ) :\n                if ( isPerfectSquare ( i - j * j * j * j ) ) :\n                    answer += 1\n                    break\n                j += 1\n    return answer\nif __name__ == '__main__' :\n    N = 10\n    print ( countInterestingPrimes ( N ) )\n", "python_code_tokenized": "import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT flag = 1 NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( True if flag == 1 else False ) NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def countInterestingPrimes ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( isPrime ( i ) != None ) : NEW_LINE INDENT j = 1 NEW_LINE while ( j * j * j * j <= i ) : NEW_LINE INDENT if ( isPerfectSquare ( i - j * j * j * j ) ) : NEW_LINE INDENT answer += 1 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( countInterestingPrimes ( N ) ) NEW_LINE DEDENT"}
{"id": "codeforces_59_A", "sol": 0, "python_code": "txt = input ( )\nout = \"\"\ncap = 0\nsmall = 0\nfor t in txt :\n    if t.islower ( ) :\n        small += 1\n    else :\n        cap += 1\nif small >= cap :\n    for t in txt :\n        out += t.lower ( )\nelse :\n    for t in txt :\n        out += t.upper ( )\nprint ( out )\n", "python_code_tokenized": "txt = input ( ) NEW_LINE out = \" \" NEW_LINE cap = 0 NEW_LINE small = 0 NEW_LINE for t in txt : NEW_LINE INDENT if t . islower ( ) : NEW_LINE INDENT small += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cap += 1 NEW_LINE DEDENT DEDENT if small >= cap : NEW_LINE INDENT for t in txt : NEW_LINE INDENT out += t . lower ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for t in txt : NEW_LINE INDENT out += t . upper ( ) NEW_LINE DEDENT DEDENT print ( out ) NEW_LINE"}
{"id": "geeksforgeeks_3366_A", "sol": 0, "python_code": "def noOfDeletions ( string , k ) :\n    ans = 0 ; cnt = 0 ; pos = 0 ;\n    while ( pos < len ( string ) and string [ pos ] != k ) :\n        pos += 1 ;\n    i = pos ;\n    while ( i < len ( string ) ) :\n        while ( i < len ( string ) and string [ i ] == k ) :\n            i = i + 1 ;\n        ans = ans + cnt ;\n        cnt = 0 ;\n        while ( i < len ( string ) and string [ i ] != k ) :\n            i = i + 1 ;\n            cnt = cnt + 1 ;\n    return ans ;\nif __name__ == \"__main__\" :\n    str1 = \"ababababa\" ;\n    k1 = 'a' ;\n    print ( noOfDeletions ( str1 , k1 ) ) ;\n    str2 = \"kprkkoinkopt\" ;\n    k2 = 'k' ;\n    print ( noOfDeletions ( str2 , k2 ) ) ;\n", "python_code_tokenized": "def noOfDeletions ( string , k ) : NEW_LINE INDENT ans = 0 ; cnt = 0 ; pos = 0 ; NEW_LINE while ( pos < len ( string ) and string [ pos ] != k ) : NEW_LINE INDENT pos += 1 ; NEW_LINE DEDENT i = pos ; NEW_LINE while ( i < len ( string ) ) : NEW_LINE INDENT while ( i < len ( string ) and string [ i ] == k ) : NEW_LINE INDENT i = i + 1 ; NEW_LINE DEDENT ans = ans + cnt ; NEW_LINE cnt = 0 ; NEW_LINE while ( i < len ( string ) and string [ i ] != k ) : NEW_LINE INDENT i = i + 1 ; NEW_LINE cnt = cnt + 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" ababababa \" ; NEW_LINE k1 = ' a ' ; NEW_LINE print ( noOfDeletions ( str1 , k1 ) ) ; NEW_LINE str2 = \" kprkkoinkopt \" ; NEW_LINE k2 = ' k ' ; NEW_LINE print ( noOfDeletions ( str2 , k2 ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1154_B", "sol": 0, "python_code": "import os , sys , io , math\nfrom tokenize import Triple\nfrom array import array\nfrom math import *\nI = lambda : [ * map ( int , sys.stdin.readline ( ).split ( ) ) ]\nIS = lambda : input ( )\nIN = lambda : int ( input ( ) )\nIF = lambda : float ( input ( ) )\nn = IN ( )\nl = I ( )\nif n == 1 : print ( 0 )\nelse :\n    l = list ( set ( l ) )\n    if len ( l ) == 1 : print ( 0 )\n    elif len ( l ) > 3 : print ( - 1 )\n    else :\n        l.sort ( )\n        if len ( l ) == 1 : print ( 0 )\n        elif len ( l ) == 2 :\n            if ( l [ 1 ] - l [ 0 ] ) % 2 == 0 : print ( ( l [ 1 ] - l [ 0 ] ) // 2 )\n            else : print ( ( l [ 1 ] - l [ 0 ] ) )\n        else :\n            if l [ 1 ] - l [ 0 ] != l [ 2 ] - l [ 1 ] : print ( - 1 )\n            else : print ( l [ 1 ] - l [ 0 ] )\n", "python_code_tokenized": "import os , sys , io , math NEW_LINE from tokenize import Triple NEW_LINE from array import array NEW_LINE from math import * NEW_LINE I = lambda : [ * map ( int , sys . stdin . readline ( ) . split ( ) ) ] NEW_LINE IS = lambda : input ( ) NEW_LINE IN = lambda : int ( input ( ) ) NEW_LINE IF = lambda : float ( input ( ) ) NEW_LINE n = IN ( ) NEW_LINE l = I ( ) NEW_LINE if n == 1 : print ( 0 ) NEW_LINE else : NEW_LINE INDENT l = list ( set ( l ) ) NEW_LINE if len ( l ) == 1 : print ( 0 ) NEW_LINE elif len ( l ) > 3 : print ( - 1 ) NEW_LINE else : NEW_LINE INDENT l . sort ( ) NEW_LINE if len ( l ) == 1 : print ( 0 ) NEW_LINE elif len ( l ) == 2 : NEW_LINE INDENT if ( l [ 1 ] - l [ 0 ] ) % 2 == 0 : print ( ( l [ 1 ] - l [ 0 ] ) // 2 ) NEW_LINE else : print ( ( l [ 1 ] - l [ 0 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if l [ 1 ] - l [ 0 ] != l [ 2 ] - l [ 1 ] : print ( - 1 ) NEW_LINE else : print ( l [ 1 ] - l [ 0 ] ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_555_A", "sol": 0, "python_code": "def productPrimeFactors ( n ) :\n    product = 1\n    for i in range ( 2 , n + 1 ) :\n        if ( n % i == 0 ) :\n            isPrime = 1\n            for j in range ( 2 , int ( i / 2 + 1 ) ) :\n                if ( i % j == 0 ) :\n                    isPrime = 0\n                    break\n            if ( isPrime ) :\n                product = product * i\n    return product\nn = 44\nprint ( productPrimeFactors ( n ) )\n", "python_code_tokenized": "def productPrimeFactors ( n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT isPrime = 1 NEW_LINE for j in range ( 2 , int ( i / 2 + 1 ) ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT isPrime = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( isPrime ) : NEW_LINE INDENT product = product * i NEW_LINE DEDENT DEDENT DEDENT return product NEW_LINE DEDENT n = 44 NEW_LINE print ( productPrimeFactors ( n ) ) NEW_LINE"}
{"id": "codeforces_935_B", "sol": 0, "python_code": "input ( )\ns = input ( )\na = p = 0\nx = [ 0 , 0 ]\nfor c in s :\n    a += x [ 0 ] == x [ 1 ] and c == p ; x [ c < 'U' ] += 1 ; p = c\nprint ( a )\n", "python_code_tokenized": "input ( ) NEW_LINE s = input ( ) NEW_LINE a = p = 0 NEW_LINE x = [ 0 , 0 ] NEW_LINE for c in s : NEW_LINE INDENT a += x [ 0 ] == x [ 1 ] and c == p ; x [ c < ' U ' ] += 1 ; p = c NEW_LINE DEDENT print ( a ) NEW_LINE"}
{"id": "geeksforgeeks_651_A", "sol": 0, "python_code": "def getMaxLength ( arr , n ) :\n    l = n ;\n    i = 0 ; maxlen = 0 ;\n    while ( i < l ) :\n        j = i ;\n        while ( i + 1 < l and ( abs ( arr [ i ] - arr [ i + 1 ] ) == 1 or abs ( arr [ i ] - arr [ i + 1 ] ) == 0 ) ) :\n            i += 1 ;\n        currLen = i - j + 1 ;\n        if ( maxlen < currLen ) :\n            maxlen = currLen ;\n        if ( j == i ) :\n            i += 1 ;\n    return maxlen ;\nif __name__ == \"__main__\" :\n    arr = [ 2 , 4 ] ;\n    n = len ( arr )\n    print ( getMaxLength ( arr , n ) ) ;\n", "python_code_tokenized": "def getMaxLength ( arr , n ) : NEW_LINE INDENT l = n ; NEW_LINE i = 0 ; maxlen = 0 ; NEW_LINE while ( i < l ) : NEW_LINE INDENT j = i ; NEW_LINE while ( i + 1 < l and ( abs ( arr [ i ] - arr [ i + 1 ] ) == 1 or abs ( arr [ i ] - arr [ i + 1 ] ) == 0 ) ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT currLen = i - j + 1 ; NEW_LINE if ( maxlen < currLen ) : NEW_LINE INDENT maxlen = currLen ; NEW_LINE DEDENT if ( j == i ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT DEDENT return maxlen ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( getMaxLength ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "leetcode_415_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def addStrings ( self , num1 , num2 ) :\n        res = [ ]\n        pos1 = len ( num1 ) - 1\n        pos2 = len ( num2 ) - 1\n        carry = 0\n        while pos1 >= 0 or pos2 >= 0 or carry == 1 :\n            digit1 = digit2 = 0\n            if pos1 >= 0 :\n                digit1 = ord ( num1 [ pos1 ] ) - ord ( '0' )\n            if pos2 >= 0 :\n                digit2 = ord ( num2 [ pos2 ] ) - ord ( '0' )\n            res.append ( str ( ( digit1 + digit2 + carry ) % 10 ) )\n            carry = ( digit1 + digit2 + carry ) / 10\n            pos1 -= 1\n            pos2 -= 1\n        return ''.join ( res [ : : - 1 ] )\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def addStrings ( self , num1 , num2 ) : NEW_LINE INDENT res = [ ] NEW_LINE pos1 = len ( num1 ) - 1 NEW_LINE pos2 = len ( num2 ) - 1 NEW_LINE carry = 0 NEW_LINE while pos1 >= 0 or pos2 >= 0 or carry == 1 : NEW_LINE INDENT digit1 = digit2 = 0 NEW_LINE if pos1 >= 0 : NEW_LINE INDENT digit1 = ord ( num1 [ pos1 ] ) - ord ( '0' ) NEW_LINE DEDENT if pos2 >= 0 : NEW_LINE INDENT digit2 = ord ( num2 [ pos2 ] ) - ord ( '0' ) NEW_LINE DEDENT res . append ( str ( ( digit1 + digit2 + carry ) % 10 ) ) NEW_LINE carry = ( digit1 + digit2 + carry ) / 10 NEW_LINE pos1 -= 1 NEW_LINE pos2 -= 1 NEW_LINE DEDENT return ' ' . join ( res [ : : - 1 ] ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1519_A", "sol": 0, "python_code": "def minOperations ( arr , n ) :\n    result = 0\n    freq = [ 0 ] * 1000001\n    for i in range ( 0 , n ) :\n        freq [ arr [ i ] ] += 1\n    maxi = max ( arr )\n    for i in range ( 1 , maxi + 1 ) :\n        if freq [ i ] != 0 :\n            for j in range ( i * 2 , maxi + 1 , i ) :\n                freq [ j ] = 0\n            result += 1\n    return result\nif __name__ == \"__main__\" :\n    arr = [ 2 , 4 , 2 , 4 , 4 , 4 ]\n    n = len ( arr )\n    print ( minOperations ( arr , n ) )\n", "python_code_tokenized": "def minOperations ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE freq = [ 0 ] * 1000001 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT maxi = max ( arr ) NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT for j in range ( i * 2 , maxi + 1 , i ) : NEW_LINE INDENT freq [ j ] = 0 NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4007_A", "sol": 0, "python_code": "def swap ( xp , yp ) :\n    xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]\n    yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]\n    xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]\nx = [ 10 ]\nswap ( x , x )\nprint ( \"After swap(&x, &x): x = \" , x [ 0 ] )\n", "python_code_tokenized": "def swap ( xp , yp ) : NEW_LINE INDENT xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE DEDENT x = [ 10 ] NEW_LINE swap ( x , x ) NEW_LINE print ( \" After \u2581 swap ( & x , \u2581 & x ) : \u2581 x \u2581 = \u2581 \" , x [ 0 ] ) NEW_LINE"}
{"id": "geeksforgeeks_4008_A", "sol": 0, "python_code": "def swap ( xp , yp ) :\n    if ( xp [ 0 ] == yp [ 0 ] ) :\n        return\n    xp [ 0 ] = xp [ 0 ] + yp [ 0 ]\n    yp [ 0 ] = xp [ 0 ] - yp [ 0 ]\n    xp [ 0 ] = xp [ 0 ] - yp [ 0 ]\nx = [ 10 ]\nswap ( x , x )\nprint ( \"After swap(&x, &x): x = \" , x [ 0 ] )\n", "python_code_tokenized": "def swap ( xp , yp ) : NEW_LINE INDENT if ( xp [ 0 ] == yp [ 0 ] ) : NEW_LINE INDENT return NEW_LINE DEDENT xp [ 0 ] = xp [ 0 ] + yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 0 ] - yp [ 0 ] NEW_LINE xp [ 0 ] = xp [ 0 ] - yp [ 0 ] NEW_LINE DEDENT x = [ 10 ] NEW_LINE swap ( x , x ) NEW_LINE print ( \" After \u2581 swap ( & x , \u2581 & x ) : \u2581 x \u2581 = \u2581 \" , x [ 0 ] ) NEW_LINE"}
{"id": "geeksforgeeks_2338_A", "sol": 0, "python_code": "def printNumber ( n ) :\n    count = [ 0 ] * 10\n    while ( n ) :\n        count [ n % 10 ] += 1\n        n //= 10\n    for i in range ( 1 , 10 ) :\n        for j in range ( count [ i ] * i ) :\n            print ( i , end = \"\" )\nif __name__ == \"__main__\" :\n    n = 3225\n    printNumber ( n )\n", "python_code_tokenized": "def printNumber ( n ) : NEW_LINE INDENT count = [ 0 ] * 10 NEW_LINE while ( n ) : NEW_LINE INDENT count [ n % 10 ] += 1 NEW_LINE n //= 10 NEW_LINE DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( count [ i ] * i ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3225 NEW_LINE printNumber ( n ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC120_A", "sol": 0, "python_code": "A , B , C = map ( int , input ( ).split ( ) )\nif B >= A * C :\n    print ( C )\nelse :\n    print ( B // A )\n", "python_code_tokenized": "A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE if B >= A * C : NEW_LINE INDENT print ( C ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( B // A ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_924_A", "sol": 0, "python_code": "MAXN = 1000001\nspf = [ i for i in range ( MAXN ) ]\nhash1 = [ 0 for i in range ( MAXN ) ]\ndef sieve ( ) :\n    for i in range ( 4 , MAXN , 2 ) :\n        spf [ i ] = 2\n    for i in range ( 3 , MAXN ) :\n        if i * i < MAXN :\n            break\n        if ( spf [ i ] == i ) :\n            for j in range ( i * i , MAXN , i ) :\n                if ( spf [ j ] == j ) :\n                    spf [ j ] = i\ndef getFactorization ( x ) :\n    while ( x != 1 ) :\n        temp = spf [ x ]\n        if ( x % temp == 0 ) :\n            hash1 [ spf [ x ] ] += 1\n            x = x // spf [ x ]\n        while ( x % temp == 0 ) :\n            x = x // temp\ndef check ( x ) :\n    while ( x != 1 ) :\n        temp = spf [ x ]\n        if ( x % temp == 0 and hash1 [ temp ] > 1 ) :\n            return False\n        while ( x % temp == 0 ) :\n            x = x // temp\n    return True\ndef hasValidNum ( arr , n ) :\n    sieve ( )\n    for i in range ( n ) :\n        getFactorization ( arr [ i ] )\n    for i in range ( n ) :\n        if ( check ( arr [ i ] ) ) :\n            return True\n    return False\narr = [ 2 , 8 , 4 , 10 , 6 , 7 ]\nn = len ( arr )\nif ( hasValidNum ( arr , n ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "MAXN = 1000001 NEW_LINE spf = [ i for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN ) : NEW_LINE INDENT if i * i < MAXN : NEW_LINE INDENT break NEW_LINE DEDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x // spf [ x ] NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT DEDENT def check ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasValidNum ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_851_A", "sol": 0, "python_code": "def nCr ( n , r ) :\n    if ( n == r ) :\n        return 1\n    if ( r == 0 ) :\n        return 1\n    return nCr ( n - 1 , r - 1 ) + nCr ( n - 1 , r )\ndef factorial ( n ) :\n    res = 1\n    if ( n <= 1 ) :\n        return res\n    for i in range ( 1 , n + 1 ) :\n        res *= i\n    return res\ndef stirlingNumber ( r , n ) :\n    if ( r == n ) :\n        return 1\n    if ( n == 0 ) :\n        return 0\n    if ( n == r - 1 ) :\n        return nCr ( r , 2 )\n    if ( r - n == 1 ) :\n        return factorial ( r - 1 )\n    return ( stirlingNumber ( r - 1 , n - 1 ) + ( r - 1 ) * stirlingNumber ( r - 1 , n ) )\nr , n = 9 , 2\nprint ( stirlingNumber ( r , n ) )\n", "python_code_tokenized": "def nCr ( n , r ) : NEW_LINE INDENT if ( n == r ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return nCr ( n - 1 , r - 1 ) + nCr ( n - 1 , r ) NEW_LINE DEDENT def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE if ( n <= 1 ) : NEW_LINE INDENT return res NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT def stirlingNumber ( r , n ) : NEW_LINE INDENT if ( r == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == r - 1 ) : NEW_LINE INDENT return nCr ( r , 2 ) NEW_LINE DEDENT if ( r - n == 1 ) : NEW_LINE INDENT return factorial ( r - 1 ) NEW_LINE DEDENT return ( stirlingNumber ( r - 1 , n - 1 ) + ( r - 1 ) * stirlingNumber ( r - 1 , n ) ) NEW_LINE DEDENT r , n = 9 , 2 NEW_LINE print ( stirlingNumber ( r , n ) ) NEW_LINE"}
{"id": "projecteuler_p145_A", "sol": 0, "python_code": "def compute ( ) :\n    def count_reversibles ( numdigits ) :\n        if numdigits % 2 == 0 :\n            return 20 * 30 ** ( numdigits // 2 - 1 )\n        elif numdigits % 4 == 3 :\n            return 100 * 500 ** ( ( numdigits - 3 ) // 4 )\n        elif numdigits % 4 == 1 :\n            return 0\n        else :\n            raise AssertionError ( )\n    ans = sum ( count_reversibles ( d ) for d in range ( 2 , 10 ) )\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT def count_reversibles ( numdigits ) : NEW_LINE INDENT if numdigits % 2 == 0 : NEW_LINE INDENT return 20 * 30 ** ( numdigits // 2 - 1 ) NEW_LINE DEDENT elif numdigits % 4 == 3 : NEW_LINE INDENT return 100 * 500 ** ( ( numdigits - 3 ) // 4 ) NEW_LINE DEDENT elif numdigits % 4 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT DEDENT ans = sum ( count_reversibles ( d ) for d in range ( 2 , 10 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2491_A", "sol": 0, "python_code": "def sumSquare ( n ) :\n    s = dict ( )\n    for i in range ( n ) :\n        if i * i > n :\n            break\n        s [ i * i ] = 1\n        if ( n - i * i ) in s.keys ( ) :\n            print ( ( n - i * i ) ** ( 1 / 2 ) , \"^2 +\" , i , \"^2\" )\n            return True\n    return False\nn = 169\nif ( sumSquare ( n ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def sumSquare ( n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT s [ i * i ] = 1 NEW_LINE if ( n - i * i ) in s . keys ( ) : NEW_LINE INDENT print ( ( n - i * i ) ** ( 1 / 2 ) , \" ^ 2 \u2581 + \" , i , \" ^ 2\" ) NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT n = 169 NEW_LINE if ( sumSquare ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1445_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    n , x = map ( int , input ( ).split ( ) )\n    a = sorted ( list ( map ( int , input ( ).split ( ) ) ) )\n    b = sorted ( list ( map ( int , input ( ).split ( ) ) ) , reverse = True )\n    if _ != t - 1 :\n        input ( )\n    flag = True\n    for i in range ( n ) :\n        if a [ i ] + b [ i ] > x :\n            flag = False\n            break\n    print ( 'YES' if flag else 'NO' )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) NEW_LINE if _ != t - 1 : NEW_LINE INDENT input ( ) NEW_LINE DEDENT flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] + b [ i ] > x : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT print ( ' YES ' if flag else ' NO ' ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC074_D", "sol": 0, "python_code": "import numpy as np\nN = int ( input ( ) )\nA = [ np.array ( list ( map ( int , input ( ).split ( ) ) ) ) for i in range ( N ) ]\nans = sum ( [ sum ( A [ i ] ) for i in range ( N ) ] )\nans //= 2\nfor i in range ( N ) :\n    A [ i ] [ i ] = 10 ** 10\ndef main ( ans ) :\n    for i in range ( N ) :\n        for j in range ( i + 1 , N ) :\n            Min = min ( A [ i ] + A [ j ] )\n            if Min < A [ i ] [ j ] :\n                return - 1\n            if Min == A [ i ] [ j ] :\n                ans -= A [ i ] [ j ]\n    return ans\nprint ( main ( ans ) )\n", "python_code_tokenized": "import numpy as np NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) for i in range ( N ) ] NEW_LINE ans = sum ( [ sum ( A [ i ] ) for i in range ( N ) ] ) NEW_LINE ans //= 2 NEW_LINE for i in range ( N ) : NEW_LINE INDENT A [ i ] [ i ] = 10 ** 10 NEW_LINE DEDENT def main ( ans ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT Min = min ( A [ i ] + A [ j ] ) NEW_LINE if Min < A [ i ] [ j ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if Min == A [ i ] [ j ] : NEW_LINE INDENT ans -= A [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT print ( main ( ans ) ) NEW_LINE"}
{"id": "projecteuler_p348_A", "sol": 0, "python_code": "import eulerlib , itertools\nTARGET_WAYS = 4\nTARGET_COUNT = 5\ndef compute ( ) :\n    for i in itertools.count ( ) :\n        limit = 10 ** i\n        ans = try_search ( limit )\n        if ans is not None :\n            return str ( ans )\ndef try_search ( limit ) :\n    ways = { }\n    for i in itertools.count ( 2 ) :\n        cube = i ** 3\n        if cube >= limit :\n            break\n        for j in range ( 2 , eulerlib.sqrt ( limit - 1 - cube ) + 1 ) :\n            index = cube + j ** 2\n            ways [ index ] = ways.get ( index , 0 ) + 1\n    result = 0\n    count = 0\n    for i in sorted ( ways.keys ( ) ) :\n        if ways [ i ] == TARGET_WAYS and is_palindrome ( i ) :\n            result += i\n            count += 1\n            if count == TARGET_COUNT :\n                return result\n    return None\ndef is_palindrome ( x ) :\n    s = str ( x )\n    return s == s [ : : - 1 ]\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib , itertools NEW_LINE TARGET_WAYS = 4 NEW_LINE TARGET_COUNT = 5 NEW_LINE def compute ( ) : NEW_LINE INDENT for i in itertools . count ( ) : NEW_LINE INDENT limit = 10 ** i NEW_LINE ans = try_search ( limit ) NEW_LINE if ans is not None : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT DEDENT DEDENT def try_search ( limit ) : NEW_LINE INDENT ways = { } NEW_LINE for i in itertools . count ( 2 ) : NEW_LINE INDENT cube = i ** 3 NEW_LINE if cube >= limit : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( 2 , eulerlib . sqrt ( limit - 1 - cube ) + 1 ) : NEW_LINE INDENT index = cube + j ** 2 NEW_LINE ways [ index ] = ways . get ( index , 0 ) + 1 NEW_LINE DEDENT DEDENT result = 0 NEW_LINE count = 0 NEW_LINE for i in sorted ( ways . keys ( ) ) : NEW_LINE INDENT if ways [ i ] == TARGET_WAYS and is_palindrome ( i ) : NEW_LINE INDENT result += i NEW_LINE count += 1 NEW_LINE if count == TARGET_COUNT : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT DEDENT return None NEW_LINE DEDENT def is_palindrome ( x ) : NEW_LINE INDENT s = str ( x ) NEW_LINE return s == s [ : : - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5238_A", "sol": 0, "python_code": "def totalBoxesRemoved ( arr , n ) :\n    count = 0\n    prev = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        if ( arr [ i ] > prev ) :\n            count += ( arr [ i ] - prev )\n            arr [ i ] = prev\n            prev = arr [ i ]\n        else :\n            prev = arr [ i ]\n    return count\narr = [ 5 , 4 , 7 , 3 , 2 , 1 ]\nn = len ( arr )\nprint ( totalBoxesRemoved ( arr , n ) )\n", "python_code_tokenized": "def totalBoxesRemoved ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > prev ) : NEW_LINE INDENT count += ( arr [ i ] - prev ) NEW_LINE arr [ i ] = prev NEW_LINE prev = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT prev = arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 5 , 4 , 7 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( totalBoxesRemoved ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_1196_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    a , b , c = map ( int , input ( ).split ( ) )\n    print ( ( a + b + c ) // 2 )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a + b + c ) // 2 ) NEW_LINE DEDENT"}
{"id": "aizu_p00565_A", "sol": 0, "python_code": "n = int ( input ( ) )\ns = list ( map ( int , input ( ).split ( ) ) )\nmax = 1\nfor i in range ( n ) :\n    if s [ i ] == 1 :\n        count = 2\n        for j in range ( i + 1 , n ) :\n            if s [ j ] == 1 :\n                count += 1\n                continue\n            else :\n                break\n        if count > max :\n            max = count\nprint ( max )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE max = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == 1 : NEW_LINE INDENT count = 2 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if s [ j ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if count > max : NEW_LINE INDENT max = count NEW_LINE DEDENT DEDENT DEDENT print ( max ) NEW_LINE"}
{"id": "projecteuler_p188_A", "sol": 0, "python_code": "import eulerlib , sys\ndef compute ( ) :\n    x , y , m = 1777 , 1855 , 10 ** 8\n    sys.setrecursionlimit ( y + 30 )\n    ans = tetration_mod ( x , y , m )\n    return str ( ans )\ndef tetration_mod ( x , y , m ) :\n    if y == 1 :\n        return x % m\n    else :\n        return pow ( x , tetration_mod ( x , y - 1 , totient ( m ) ) , m )\ndef totient ( n ) :\n    assert n > 0\n    p = 1\n    i = 2\n    end = eulerlib.sqrt ( n )\n    while i <= end :\n        if n % i == 0 :\n            p *= i - 1\n            n //= i\n            while n % i == 0 :\n                p *= i\n                n //= i\n            end = eulerlib.sqrt ( n )\n        i += 1\n    if n != 1 :\n        p *= n - 1\n    return p\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib , sys NEW_LINE def compute ( ) : NEW_LINE INDENT x , y , m = 1777 , 1855 , 10 ** 8 NEW_LINE sys . setrecursionlimit ( y + 30 ) NEW_LINE ans = tetration_mod ( x , y , m ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def tetration_mod ( x , y , m ) : NEW_LINE INDENT if y == 1 : NEW_LINE INDENT return x % m NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( x , tetration_mod ( x , y - 1 , totient ( m ) ) , m ) NEW_LINE DEDENT DEDENT def totient ( n ) : NEW_LINE INDENT assert n > 0 NEW_LINE p = 1 NEW_LINE i = 2 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE while i <= end : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT p *= i - 1 NEW_LINE n //= i NEW_LINE while n % i == 0 : NEW_LINE INDENT p *= i NEW_LINE n //= i NEW_LINE DEDENT end = eulerlib . sqrt ( n ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if n != 1 : NEW_LINE INDENT p *= n - 1 NEW_LINE DEDENT return p NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2185_A", "sol": 0, "python_code": "def countNumbers ( l , r ) :\n    return ( ( r // 6 ) - ( l - 1 ) // 6 ) ;\nif __name__ == \"__main__\" :\n    l = 1000 ; r = 6000 ;\n    print ( countNumbers ( l , r ) ) ;\n", "python_code_tokenized": "def countNumbers ( l , r ) : NEW_LINE INDENT return ( ( r // 6 ) - ( l - 1 ) // 6 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 1000 ; r = 6000 ; NEW_LINE print ( countNumbers ( l , r ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2938_A", "sol": 0, "python_code": "def find_greatest_divisor ( l , r ) :\n    if ( l == r ) :\n        return l ;\n    return 1 ;\nl = 2 ;\nr = 12 ;\nprint ( find_greatest_divisor ( l , r ) ) ;\n", "python_code_tokenized": "def find_greatest_divisor ( l , r ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT return l ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT l = 2 ; NEW_LINE r = 12 ; NEW_LINE print ( find_greatest_divisor ( l , r ) ) ; NEW_LINE"}
{"id": "codeforces_145_A", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\na = input ( ) [ : - 1 ]\nb = input ( ) [ : - 1 ]\nx = len ( a )\nc , d = 0 , 0\nfor i in range ( x ) :\n    if a [ i ] == '7' and b [ i ] == '4' :\n        c += 1\n    if a [ i ] == '4' and b [ i ] == '7' :\n        d += 1\nprint ( min ( c , d ) + c - min ( c , d ) + d - min ( c , d ) )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE a = input ( ) [ : - 1 ] NEW_LINE b = input ( ) [ : - 1 ] NEW_LINE x = len ( a ) NEW_LINE c , d = 0 , 0 NEW_LINE for i in range ( x ) : NEW_LINE INDENT if a [ i ] == '7' and b [ i ] == '4' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if a [ i ] == '4' and b [ i ] == '7' : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT print ( min ( c , d ) + c - min ( c , d ) + d - min ( c , d ) ) NEW_LINE"}
{"id": "codeforces_1647_A", "sol": 0, "python_code": "for i in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    if n == 1 or n == 2 :\n        print ( n )\n    else :\n        u = str ( )\n        v = n // 3\n        w = n % 3\n        u += '21' * v\n        if w == 1 :\n            u = '1' + u\n        elif w == 2 :\n            u += '2'\n        print ( u )\n", "python_code_tokenized": "for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 1 or n == 2 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT u = str ( ) NEW_LINE v = n // 3 NEW_LINE w = n % 3 NEW_LINE u += '21' * v NEW_LINE if w == 1 : NEW_LINE INDENT u = '1' + u NEW_LINE DEDENT elif w == 2 : NEW_LINE INDENT u += '2' NEW_LINE DEDENT print ( u ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_48_A", "sol": 0, "python_code": "a = [ input ( ) for _ in [ 0 ] * 3 ]\nd = dict ( zip ( 'rsp' , 'spr' ) )\nr = 'FMS'\nfor i in range ( 3 ) :\n    if sum ( x [ 0 ] == d [ a [ i ] [ 0 ] ] for x in a ) == 2 :\n        print ( r [ i ] )\n        exit ( )\nprint ( '?' )\n", "python_code_tokenized": "a = [ input ( ) for _ in [ 0 ] * 3 ] NEW_LINE d = dict ( zip ( ' rsp ' , ' spr ' ) ) NEW_LINE r = ' FMS ' NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if sum ( x [ 0 ] == d [ a [ i ] [ 0 ] ] for x in a ) == 2 : NEW_LINE INDENT print ( r [ i ] ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ' ? ' ) NEW_LINE"}
{"id": "codeforces_1197_A", "sol": 0, "python_code": "T = int ( input ( ) )\nans = [ ]\nfor _ in range ( T ) :\n    n = int ( input ( ) )\n    boards = list ( map ( int , input ( ).split ( ) ) )\n    boards.sort ( )\n    answer = min ( boards [ - 2 ] - 1 , n - 2 )\n    ans.append ( answer )\nfor i in ans :\n    print ( i )\n", "python_code_tokenized": "T = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE for _ in range ( T ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE boards = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE boards . sort ( ) NEW_LINE answer = min ( boards [ - 2 ] - 1 , n - 2 ) NEW_LINE ans . append ( answer ) NEW_LINE DEDENT for i in ans : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT"}
{"id": "leetcode_485_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def findMaxConsecutiveOnes ( self , nums ) :\n        ans = 0\n        curr = 0\n        for n in nums :\n            if n == 1 :\n                curr += 1\n                if curr > ans :\n                    ans = curr\n            else :\n                curr = 0\n        return ans\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def findMaxConsecutiveOnes ( self , nums ) : NEW_LINE INDENT ans = 0 NEW_LINE curr = 0 NEW_LINE for n in nums : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT curr += 1 NEW_LINE if curr > ans : NEW_LINE INDENT ans = curr NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT curr = 0 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC076_D", "sol": 0, "python_code": "N = int ( input ( ) )\nt = list ( map ( int , input ( ).split ( ) ) )\nv = list ( map ( int , input ( ).split ( ) ) )\ntime = 0\nsum_t = sum ( t )\nvelo_cap = [ float ( \"inf\" ) ] * ( 2 * sum_t + 1 )\nfor i in range ( N ) :\n    start_t = time\n    goal_t = time + 2 * t [ i ]\n    for s in range ( 0 , 2 * sum_t + 1 ) :\n        if s < start_t :\n            velo_cap [ s ] = min ( velo_cap [ s ] , 2 * v [ i ] + ( start_t - s ) )\n        elif s < goal_t :\n            velo_cap [ s ] = min ( velo_cap [ s ] , 2 * v [ i ] )\n        else :\n            velo_cap [ s ] = min ( velo_cap [ s ] , 2 * v [ i ] + ( s - goal_t ) )\n    time += 2 * t [ i ]\nfor s in range ( 2 * sum_t + 1 ) :\n    velo_cap [ s ] = min ( velo_cap [ s ] , 2 * sum_t - s , s )\nprint ( sum ( velo_cap ) / 4 - ( velo_cap [ 0 ] + velo_cap [ - 1 ] ) / 8 )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE t = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE v = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE time = 0 NEW_LINE sum_t = sum ( t ) NEW_LINE velo_cap = [ float ( \" inf \" ) ] * ( 2 * sum_t + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT start_t = time NEW_LINE goal_t = time + 2 * t [ i ] NEW_LINE for s in range ( 0 , 2 * sum_t + 1 ) : NEW_LINE INDENT if s < start_t : NEW_LINE INDENT velo_cap [ s ] = min ( velo_cap [ s ] , 2 * v [ i ] + ( start_t - s ) ) NEW_LINE DEDENT elif s < goal_t : NEW_LINE INDENT velo_cap [ s ] = min ( velo_cap [ s ] , 2 * v [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT velo_cap [ s ] = min ( velo_cap [ s ] , 2 * v [ i ] + ( s - goal_t ) ) NEW_LINE DEDENT DEDENT time += 2 * t [ i ] NEW_LINE DEDENT for s in range ( 2 * sum_t + 1 ) : NEW_LINE INDENT velo_cap [ s ] = min ( velo_cap [ s ] , 2 * sum_t - s , s ) NEW_LINE DEDENT print ( sum ( velo_cap ) / 4 - ( velo_cap [ 0 ] + velo_cap [ - 1 ] ) / 8 ) NEW_LINE"}
{"id": "geeksforgeeks_969_A", "sol": 0, "python_code": "def findString ( str , n , k ) :\n    if ( k == 0 ) :\n        print ( str )\n        return\n    str2 = str\n    p = 0\n    for i in range ( 0 , n , 1 ) :\n        if ( str2 [ i ] != 'a' ) :\n            str2 = str2.replace ( str2 [ i ] , 'a' )\n            p += 1\n            if ( p == k ) :\n                break\n    if ( p < k ) :\n        i = n - 1\n        while ( i >= 0 ) :\n            if ( str [ i ] == 'a' ) :\n                str2 = str2.replace ( str2 [ i ] , 'b' )\n                p += 1\n            if ( p == k ) :\n                break\n            i -= 1\n    print ( str2 )\nif __name__ == '__main__' :\n    str = \"pqrs\"\n    n = len ( str )\n    k = 2\n    findString ( str , n , k )\n", "python_code_tokenized": "def findString ( str , n , k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT print ( str ) NEW_LINE return NEW_LINE DEDENT str2 = str NEW_LINE p = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( str2 [ i ] != ' a ' ) : NEW_LINE INDENT str2 = str2 . replace ( str2 [ i ] , ' a ' ) NEW_LINE p += 1 NEW_LINE if ( p == k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( p < k ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( str [ i ] == ' a ' ) : NEW_LINE INDENT str2 = str2 . replace ( str2 [ i ] , ' b ' ) NEW_LINE p += 1 NEW_LINE DEDENT if ( p == k ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT print ( str2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" pqrs \" NEW_LINE n = len ( str ) NEW_LINE k = 2 NEW_LINE findString ( str , n , k ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2538_A", "sol": 0, "python_code": "def mulmod ( a , b , mod ) :\n    res = 0\n    a = a % mod\n    while ( b > 0 ) :\n        if ( b % 2 == 1 ) :\n            res = ( res + a ) % mod\n        a = ( a * 2 ) % mod\n        b //= 2\n    return res % mod\ndef findProduct ( N ) :\n    product = 1 ; fact = 1\n    MOD = 1e9 + 7\n    for i in range ( 1 , N + 1 ) :\n        fact = mulmod ( fact , i , MOD )\n        product = mulmod ( product , fact , MOD )\n        if not product :\n            return 0\n    return int ( product )\nN = 3\nprint ( findProduct ( N ) )\nN = 5\nprint ( findProduct ( N ) )\n", "python_code_tokenized": "def mulmod ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b //= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def findProduct ( N ) : NEW_LINE INDENT product = 1 ; fact = 1 NEW_LINE MOD = 1e9 + 7 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = mulmod ( fact , i , MOD ) NEW_LINE product = mulmod ( product , fact , MOD ) NEW_LINE if not product : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return int ( product ) NEW_LINE DEDENT N = 3 NEW_LINE print ( findProduct ( N ) ) NEW_LINE N = 5 NEW_LINE print ( findProduct ( N ) ) NEW_LINE"}
{"id": "codeforces_988_A", "sol": 0, "python_code": "n , k = input ( ).split ( )\nn = int ( n )\nk = int ( k )\na = input ( )\nl = a.split ( )\nteam = [ ]\nposition_team = [ ]\nfor i in range ( len ( l ) ) :\n    l [ i ] = int ( l [ i ] )\n    if l [ i ] not in team :\n        team.append ( l [ i ] )\n        position_team.append ( i + 1 )\nif len ( team ) >= k :\n    print ( \"YES\" )\n    for i in range ( k ) :\n        print ( position_team [ i ] , end = \" \" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "n , k = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE k = int ( k ) NEW_LINE a = input ( ) NEW_LINE l = a . split ( ) NEW_LINE team = [ ] NEW_LINE position_team = [ ] NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT l [ i ] = int ( l [ i ] ) NEW_LINE if l [ i ] not in team : NEW_LINE INDENT team . append ( l [ i ] ) NEW_LINE position_team . append ( i + 1 ) NEW_LINE DEDENT DEDENT if len ( team ) >= k : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT print ( position_team [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3663_A", "sol": 0, "python_code": "def innerCirclearea ( radius ) :\n    if ( radius < 0 ) :\n        return - 1 ;\n    r = radius / 2 ;\n    Area = ( 3.14 * pow ( r , 2 ) ) ;\n    return Area ;\nif __name__ == \"__main__\" :\n    radius = 4 ;\n    print ( \"Area of circle c2 =\" , innerCirclearea ( radius ) ) ;\n", "python_code_tokenized": "def innerCirclearea ( radius ) : NEW_LINE INDENT if ( radius < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT r = radius / 2 ; NEW_LINE Area = ( 3.14 * pow ( r , 2 ) ) ; NEW_LINE return Area ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT radius = 4 ; NEW_LINE print ( \" Area \u2581 of \u2581 circle \u2581 c2 \u2581 = \" , innerCirclearea ( radius ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2660_A", "sol": 0, "python_code": "def negProdSubArr ( arr , n ) :\n    positive = 1\n    negative = 0\n    for i in range ( n ) :\n        if ( arr [ i ] > 0 ) :\n            arr [ i ] = 1\n        else :\n            arr [ i ] = - 1\n        if ( i > 0 ) :\n            arr [ i ] *= arr [ i - 1 ]\n        if ( arr [ i ] == 1 ) :\n            positive += 1\n        else :\n            negative += 1\n    return ( positive * negative )\narr = [ 5 , - 4 , - 3 , 2 , - 5 ]\nn = len ( arr )\nprint ( negProdSubArr ( arr , n ) )\n", "python_code_tokenized": "def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( negProdSubArr ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_240_A", "sol": 0, "python_code": "def negProdSubArr ( arr , n ) :\n    positive = 1\n    negative = 0\n    for i in range ( n ) :\n        if ( arr [ i ] > 0 ) :\n            arr [ i ] = 1\n        else :\n            arr [ i ] = - 1\n        if ( i > 0 ) :\n            arr [ i ] *= arr [ i - 1 ]\n        if ( arr [ i ] == 1 ) :\n            positive += 1\n        else :\n            negative += 1\n    return ( positive * negative )\ndef posProdSubArr ( arr , n ) :\n    total = ( n * ( n + 1 ) ) / 2 ;\n    cntNeg = negProdSubArr ( arr , n ) ;\n    return ( total - cntNeg ) ;\narr = [ 5 , - 4 , - 3 , 2 , - 5 ]\nn = len ( arr )\nprint ( posProdSubArr ( arr , n ) )\n", "python_code_tokenized": "def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT def posProdSubArr ( arr , n ) : NEW_LINE INDENT total = ( n * ( n + 1 ) ) / 2 ; NEW_LINE cntNeg = negProdSubArr ( arr , n ) ; NEW_LINE return ( total - cntNeg ) ; NEW_LINE DEDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( posProdSubArr ( arr , n ) ) NEW_LINE"}
{"id": "aizu_p02530_A", "sol": 0, "python_code": "class Player :\n    def __init__ ( self ) :\n        self.score = 0\n        self.card = ''\na = Player ( )\nb = Player ( )\nno_gemes = int ( input ( ) )\nfor _ in range ( no_gemes ) :\n    a.card , b.card = input ( ).split ( )\n    if a.card == b.card :\n        a.score += 1\n        b.score += 1\n    elif a.card > b.card :\n        a.score += 3\n    elif a.card < b.card :\n        b.score += 3\nprint ( a.score , b.score )\n", "python_code_tokenized": "class Player : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . score = 0 NEW_LINE self . card = ' ' NEW_LINE DEDENT DEDENT a = Player ( ) NEW_LINE b = Player ( ) NEW_LINE no_gemes = int ( input ( ) ) NEW_LINE for _ in range ( no_gemes ) : NEW_LINE INDENT a . card , b . card = input ( ) . split ( ) NEW_LINE if a . card == b . card : NEW_LINE INDENT a . score += 1 NEW_LINE b . score += 1 NEW_LINE DEDENT elif a . card > b . card : NEW_LINE INDENT a . score += 3 NEW_LINE DEDENT elif a . card < b . card : NEW_LINE INDENT b . score += 3 NEW_LINE DEDENT DEDENT print ( a . score , b . score ) NEW_LINE"}
{"id": "aizu_p02487_A", "sol": 0, "python_code": "from __future__ import print_function\nFC = '#'\nPC = '.'\ndef bothends ( f ) :\n    def _func ( self ) :\n        print ( FC , end = '' )\n        f ( self )\n        print ( FC )\n    return _func\nclass Frame :\n    c = FC\n    s = PC\n    def __init__ ( self , w , h ) :\n        self.w = w\n        self.h = h\n    @ bothends\n    def _draw ( self ) :\n        print ( self.s * ( self.w - 2 ) , end = '' )\n    def draw ( self ) :\n        for i in range ( self.h - 2 ) :\n            self._draw ( )\n    def __enter__ ( self ) :\n        print ( self.c * self.w )\n        return self\n    def __exit__ ( self , exc_type , exc_value , traceback ) :\n        print ( self.c * self.w )\n        return True\nwhile True :\n    w , h = [ int ( s ) for s in raw_input ( ).split ( ) ]\n    if w == h == 0 :\n        break\n    with Frame ( h , w ) as fr :\n        fr.draw ( )\n    print ( )\n", "python_code_tokenized": "from __future__ import print_function NEW_LINE FC = ' # ' NEW_LINE PC = ' . ' NEW_LINE def bothends ( f ) : NEW_LINE INDENT def _func ( self ) : NEW_LINE INDENT print ( FC , end = ' ' ) NEW_LINE f ( self ) NEW_LINE print ( FC ) NEW_LINE DEDENT return _func NEW_LINE DEDENT class Frame : NEW_LINE INDENT c = FC NEW_LINE s = PC NEW_LINE def __init__ ( self , w , h ) : NEW_LINE INDENT self . w = w NEW_LINE self . h = h NEW_LINE DEDENT @ bothends NEW_LINE def _draw ( self ) : NEW_LINE INDENT print ( self . s * ( self . w - 2 ) , end = ' ' ) NEW_LINE DEDENT def draw ( self ) : NEW_LINE INDENT for i in range ( self . h - 2 ) : NEW_LINE INDENT self . _draw ( ) NEW_LINE DEDENT DEDENT def __enter__ ( self ) : NEW_LINE INDENT print ( self . c * self . w ) NEW_LINE return self NEW_LINE DEDENT def __exit__ ( self , exc_type , exc_value , traceback ) : NEW_LINE INDENT print ( self . c * self . w ) NEW_LINE return True NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT w , h = [ int ( s ) for s in raw_input ( ) . split ( ) ] NEW_LINE if w == h == 0 : NEW_LINE INDENT break NEW_LINE DEDENT with Frame ( h , w ) as fr : NEW_LINE INDENT fr . draw ( ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2522_A", "sol": 0, "python_code": "def maximize ( A1 , A2 , n , x , y ) :\n    c = [ 0 for i in range ( n ) ]\n    Sum = 0\n    for i in range ( n ) :\n        c [ i ] = A2 [ i ] - A1 [ i ]\n        Sum += A1 [ i ]\n    c.sort ( )\n    c = c [ : : - 1 ]\n    maxi = - 1\n    for i in range ( n ) :\n        Sum += c [ i ]\n        if ( i + 1 >= ( n - x ) ) :\n            maxi = max ( Sum , maxi )\n    return maxi\nA1 = [ 1 , 2 , 3 , 4 , 5 ]\nA2 = [ 5 , 4 , 3 , 2 , 1 ]\nn = 5\nx , y = 3 , 3\nprint ( maximize ( A1 , A2 , n , x , y ) )\n", "python_code_tokenized": "def maximize ( A1 , A2 , n , x , y ) : NEW_LINE INDENT c = [ 0 for i in range ( n ) ] NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = A2 [ i ] - A1 [ i ] NEW_LINE Sum += A1 [ i ] NEW_LINE DEDENT c . sort ( ) NEW_LINE c = c [ : : - 1 ] NEW_LINE maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += c [ i ] NEW_LINE if ( i + 1 >= ( n - x ) ) : NEW_LINE INDENT maxi = max ( Sum , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT A1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE A2 = [ 5 , 4 , 3 , 2 , 1 ] NEW_LINE n = 5 NEW_LINE x , y = 3 , 3 NEW_LINE print ( maximize ( A1 , A2 , n , x , y ) ) NEW_LINE"}
{"id": "codeforces_1341_A", "sol": 0, "python_code": "t = int ( input ( ) )\ni = 1\nwhile True :\n    if i > t :\n        break\n    n , a , b , c , d = map ( int , input ( ).split ( ) )\n    if n * ( a - b ) > ( c + d ) or n * ( a + b ) < ( c - d ) :\n        print ( \"No\" )\n    else :\n        print ( \"Yes\" )\n    i = i + 1\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT if i > t : NEW_LINE INDENT break NEW_LINE DEDENT n , a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if n * ( a - b ) > ( c + d ) or n * ( a + b ) < ( c - d ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4810_A", "sol": 0, "python_code": "def getIndex ( a , n ) :\n    if ( n == 1 ) :\n        return 0\n    ptrL = 0\n    ptrR = n - 1\n    sumL = a [ 0 ]\n    sumR = a [ n - 1 ]\n    while ( ptrR - ptrL > 1 ) :\n        if ( sumL < sumR ) :\n            ptrL += 1\n            sumL += a [ ptrL ]\n        elif ( sumL > sumR ) :\n            ptrR -= 1\n            sumR += a [ ptrR ]\n        else :\n            break\n    return ptrL\nif __name__ == \"__main__\" :\n    a = [ 2 , 7 , 9 , 8 , 7 ]\n    n = len ( a )\n    print ( getIndex ( a , n ) )\n", "python_code_tokenized": "def getIndex ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ptrL = 0 NEW_LINE ptrR = n - 1 NEW_LINE sumL = a [ 0 ] NEW_LINE sumR = a [ n - 1 ] NEW_LINE while ( ptrR - ptrL > 1 ) : NEW_LINE INDENT if ( sumL < sumR ) : NEW_LINE INDENT ptrL += 1 NEW_LINE sumL += a [ ptrL ] NEW_LINE DEDENT elif ( sumL > sumR ) : NEW_LINE INDENT ptrR -= 1 NEW_LINE sumR += a [ ptrR ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ptrL NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 7 , 9 , 8 , 7 ] NEW_LINE n = len ( a ) NEW_LINE print ( getIndex ( a , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1041_A", "sol": 0, "python_code": "import functools as ft\nprime = [ 0 for i in range ( 100001 ) ]\ndef SieveOfEratosthenes ( ) :\n    prime [ 0 ] = 0\n    prime [ 1 ] = 0\n    for p in range ( 2 , 100002 ) :\n        if p * p > 100001 :\n            break\n        if ( prime [ p ] == 0 ) :\n            prime [ p ] += 1\n            for i in range ( 2 * p , 100001 , p ) :\n                prime [ i ] += 1\ndef sortArr ( arr , n ) :\n    v = [ ]\n    for i in range ( n ) :\n        v.append ( [ arr [ i ] , prime [ arr [ i ] ] ] )\n    v.sort ( key = lambda x : x [ 1 ] )\n    for i in range ( n ) :\n        print ( v [ i ] [ 0 ] , end = \" \" )\n    print ( )\nSieveOfEratosthenes ( )\narr = [ 30 , 2 , 1024 , 210 , 3 , 6 ]\nn = len ( arr )\nsortArr ( arr , n )\n", "python_code_tokenized": "import functools as ft NEW_LINE prime = [ 0 for i in range ( 100001 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 0 ] = 0 NEW_LINE prime [ 1 ] = 0 NEW_LINE for p in range ( 2 , 100002 ) : NEW_LINE INDENT if p * p > 100001 : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == 0 ) : NEW_LINE INDENT prime [ p ] += 1 NEW_LINE for i in range ( 2 * p , 100001 , p ) : NEW_LINE INDENT prime [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def sortArr ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v . append ( [ arr [ i ] , prime [ arr [ i ] ] ] ) NEW_LINE DEDENT v . sort ( key = lambda x : x [ 1 ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( v [ i ] [ 0 ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE arr = [ 30 , 2 , 1024 , 210 , 3 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE sortArr ( arr , n ) NEW_LINE"}
{"id": "atcoder_ABC133_B", "sol": 0, "python_code": "import math\nn , d = map ( int , input ( ).split ( ) )\npoints = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( n ) ]\ndef dist ( x , y ) :\n    tmp = 0.0\n    for i in range ( d ) :\n        tmp += ( x [ i ] - y [ i ] ) ** 2\n    return math.sqrt ( tmp )\ncount = 0\nfor i , elm in enumerate ( points ) :\n    for j in range ( i + 1 , n ) :\n        if dist ( elm , points [ j ] ).is_integer ( ) :\n            count += 1\nprint ( count )\n", "python_code_tokenized": "import math NEW_LINE n , d = map ( int , input ( ) . split ( ) ) NEW_LINE points = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE def dist ( x , y ) : NEW_LINE INDENT tmp = 0.0 NEW_LINE for i in range ( d ) : NEW_LINE INDENT tmp += ( x [ i ] - y [ i ] ) ** 2 NEW_LINE DEDENT return math . sqrt ( tmp ) NEW_LINE DEDENT count = 0 NEW_LINE for i , elm in enumerate ( points ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if dist ( elm , points [ j ] ) . is_integer ( ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE"}
{"id": "geeksforgeeks_839_A", "sol": 0, "python_code": "import math\ndef arcLength ( diameter , angle ) :\n    if angle >= 360 :\n        print ( \"Angle cannot be formed\" )\n        return 0\n    else :\n        arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 )\n        return arc\ndiameter = 25.0\nangle = 45.0\narc_len = arcLength ( diameter , angle )\nprint ( arc_len )\n", "python_code_tokenized": "import math NEW_LINE def arcLength ( diameter , angle ) : NEW_LINE INDENT if angle >= 360 : NEW_LINE INDENT print ( \" Angle \u2581 cannot \u2581 be \u2581 formed \" ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) NEW_LINE return arc NEW_LINE DEDENT DEDENT diameter = 25.0 NEW_LINE angle = 45.0 NEW_LINE arc_len = arcLength ( diameter , angle ) NEW_LINE print ( arc_len ) NEW_LINE"}
{"id": "codeforces_831_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = * map ( int , input ( ).split ( ) ) ,\nl = 0\nr = n\nwhile l + 1 < n and a [ l ] < a [ l + 1 ] : l += 1\nwhile r > 0 and a [ r - 2 ] > a [ r - 1 ] : r -= 1\nprint ( 'YNEOS' [ len ( { * a [ l : r ] } ) != 1 : : 2 ] )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = * map ( int , input ( ) . split ( ) ) , NEW_LINE l = 0 NEW_LINE r = n NEW_LINE while l + 1 < n and a [ l ] < a [ l + 1 ] : l += 1 NEW_LINE while r > 0 and a [ r - 2 ] > a [ r - 1 ] : r -= 1 NEW_LINE print ( ' YNEOS ' [ len ( { * a [ l : r ] } ) != 1 : : 2 ] ) NEW_LINE"}
{"id": "codeforces_1311_B", "sol": 0, "python_code": "for i in range ( int ( input ( ) ) ) :\n    n1 , n2 = map ( int , input ( ).split ( ) )\n    a_dados = list ( map ( int , input ( ).split ( ) ) )\n    p_posicoes = list ( map ( int , input ( ).split ( ) ) )\n    for i in range ( n2 ) :\n        for j in p_posicoes :\n            if a_dados [ j - 1 ] > a_dados [ j ] :\n                a_dados [ j - 1 ] , a_dados [ j ] = a_dados [ j ] , a_dados [ j - 1 ]\n    if a_dados != sorted ( a_dados ) :\n        print ( \"NO\" )\n    else :\n        print ( \"YES\" )\n", "python_code_tokenized": "for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n1 , n2 = map ( int , input ( ) . split ( ) ) NEW_LINE a_dados = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p_posicoes = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT for j in p_posicoes : NEW_LINE INDENT if a_dados [ j - 1 ] > a_dados [ j ] : NEW_LINE INDENT a_dados [ j - 1 ] , a_dados [ j ] = a_dados [ j ] , a_dados [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT if a_dados != sorted ( a_dados ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_408_A", "sol": 0, "python_code": "import sys\ndef minSubarray ( A , n ) :\n    minValue = min ( A )\n    maxValue = max ( A )\n    pos_min , pos_max , ans = - 1 , - 1 , sys.maxsize\n    for i in range ( 0 , n ) :\n        if A [ i ] == minValue :\n            pos_min = i\n        if A [ i ] == maxValue :\n            pos_max = i\n        if pos_max != - 1 and pos_min != - 1 :\n            ans = min ( ans , abs ( pos_min - pos_max ) + 1 )\n    return ans\nA = [ 1 , 5 , 9 , 7 , 1 , 9 , 4 ]\nn = len ( A )\nprint ( minSubarray ( A , n ) )\n", "python_code_tokenized": "import sys NEW_LINE def minSubarray ( A , n ) : NEW_LINE INDENT minValue = min ( A ) NEW_LINE maxValue = max ( A ) NEW_LINE pos_min , pos_max , ans = - 1 , - 1 , sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if A [ i ] == minValue : NEW_LINE INDENT pos_min = i NEW_LINE DEDENT if A [ i ] == maxValue : NEW_LINE INDENT pos_max = i NEW_LINE DEDENT if pos_max != - 1 and pos_min != - 1 : NEW_LINE INDENT ans = min ( ans , abs ( pos_min - pos_max ) + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT A = [ 1 , 5 , 9 , 7 , 1 , 9 , 4 ] NEW_LINE n = len ( A ) NEW_LINE print ( minSubarray ( A , n ) ) NEW_LINE"}
{"id": "codeforces_1509_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    n , a = int ( input ( ) ) , ( int ( i ) for i in input ( ).split ( ) )\n    s = [ [ ] , [ ] ]\n    for i in a :\n        s [ i & 1 ].append ( i )\n    res = s [ 0 ] + s [ 1 ]\n    print ( * res )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , a = int ( input ( ) ) , ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE s = [ [ ] , [ ] ] NEW_LINE for i in a : NEW_LINE INDENT s [ i & 1 ] . append ( i ) NEW_LINE DEDENT res = s [ 0 ] + s [ 1 ] NEW_LINE print ( * res ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC088_B", "sol": 0, "python_code": "( lambda _ , L : print ( sum ( L [ 0 : : 2 ] ) - sum ( L [ 1 : : 2 ] ) ) ) ( input ( ) , sorted ( [ int ( i ) for i in input ( ).split ( ) ] , reverse = True ) )\n", "python_code_tokenized": "( lambda _ , L : print ( sum ( L [ 0 : : 2 ] ) - sum ( L [ 1 : : 2 ] ) ) ) ( input ( ) , sorted ( [ int ( i ) for i in input ( ) . split ( ) ] , reverse = True ) ) NEW_LINE"}
{"id": "codeforces_1351_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    a , b = map ( int , input ( ).split ( ) )\n    a1 , b1 = map ( int , input ( ).split ( ) )\n    if max ( a , b ) == max ( a1 , b1 ) :\n        if min ( a , b ) + min ( a1 , b1 ) == max ( a , b ) :\n            print ( 'YES' )\n        else :\n            print ( 'NO' )\n    else :\n        print ( 'NO' )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a1 , b1 = map ( int , input ( ) . split ( ) ) NEW_LINE if max ( a , b ) == max ( a1 , b1 ) : NEW_LINE INDENT if min ( a , b ) + min ( a1 , b1 ) == max ( a , b ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3761_A", "sol": 0, "python_code": "def ceilSearch ( arr , low , high , x ) :\n    if x <= arr [ low ] :\n        return low\n    if x > arr [ high ] :\n        return - 1\n    mid = ( low + high ) / 2 ;\n    if arr [ mid ] == x :\n        return mid\n    elif arr [ mid ] < x :\n        if mid + 1 <= high and x <= arr [ mid + 1 ] :\n            return mid + 1\n        else :\n            return ceilSearch ( arr , mid + 1 , high , x )\n    else :\n        if mid - 1 >= low and x > arr [ mid - 1 ] :\n            return mid\n        else :\n            return ceilSearch ( arr , low , mid - 1 , x )\narr = [ 1 , 2 , 8 , 10 , 10 , 12 , 19 ]\nn = len ( arr )\nx = 20\nindex = ceilSearch ( arr , 0 , n - 1 , x ) ;\nif index == - 1 :\n    print ( \"Ceiling of %d doesn't exist in array \" % x )\nelse :\n    print ( \"ceiling of %d is %d\" % ( x , arr [ index ] ) )\n", "python_code_tokenized": "def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT if x > arr [ high ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 ; NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT if mid + 1 <= high and x <= arr [ mid + 1 ] : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , mid + 1 , high , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if mid - 1 >= low and x > arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 8 , 10 , 10 , 12 , 19 ] NEW_LINE n = len ( arr ) NEW_LINE x = 20 NEW_LINE index = ceilSearch ( arr , 0 , n - 1 , x ) ; NEW_LINE if index == - 1 : NEW_LINE INDENT print ( \" Ceiling \u2581 of \u2581 % d \u2581 doesn ' t \u2581 exist \u2581 in \u2581 array \u2581 \" % x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ceiling \u2581 of \u2581 % d \u2581 is \u2581 % d \" % ( x , arr [ index ] ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1951_A", "sol": 0, "python_code": "def maxDiff ( arr , n ) :\n    result = 0\n    arr.sort ( )\n    for i in range ( n - 1 ) :\n        if ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) :\n            result += abs ( arr [ i ] )\n        else :\n            pass\n    if ( arr [ n - 2 ] != arr [ n - 1 ] ) :\n        result += abs ( arr [ n - 1 ] )\n    return result\nif __name__ == \"__main__\" :\n    arr = [ 4 , 2 , - 3 , 3 , - 2 , - 2 , 8 ]\n    n = len ( arr )\n    print ( \"Maximum Difference = \" , maxDiff ( arr , n ) )\n", "python_code_tokenized": "def maxDiff ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) : NEW_LINE INDENT result += abs ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT if ( arr [ n - 2 ] != arr [ n - 1 ] ) : NEW_LINE INDENT result += abs ( arr [ n - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 2 , - 3 , 3 , - 2 , - 2 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Maximum \u2581 Difference \u2581 = \u2581 \" , maxDiff ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1260_A", "sol": 0, "python_code": "r = int ( input ( ) )\nfor i in range ( r ) :\n    h , s = map ( int , input ( ).split ( ) )\n    if s <= h :\n        print ( s )\n    else :\n        ans = s // h\n        rem = s % h\n        sol = ans * ans * ( h - rem ) + ( ans + 1 ) * ( ans + 1 ) * rem\n        print ( sol )\n", "python_code_tokenized": "r = int ( input ( ) ) NEW_LINE for i in range ( r ) : NEW_LINE INDENT h , s = map ( int , input ( ) . split ( ) ) NEW_LINE if s <= h : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = s // h NEW_LINE rem = s % h NEW_LINE sol = ans * ans * ( h - rem ) + ( ans + 1 ) * ( ans + 1 ) * rem NEW_LINE print ( sol ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1054_A", "sol": 0, "python_code": "x , y , z , t , r , s = map ( int , input ( ).split ( ) )\nd = abs ( x - y )\nprint ( 'YNEOS' [ d * t < ( abs ( x - z ) + d ) * r + 3 * s : : 2 ] )\n", "python_code_tokenized": "x , y , z , t , r , s = map ( int , input ( ) . split ( ) ) NEW_LINE d = abs ( x - y ) NEW_LINE print ( ' YNEOS ' [ d * t < ( abs ( x - z ) + d ) * r + 3 * s : : 2 ] ) NEW_LINE"}
{"id": "geeksforgeeks_3138_A", "sol": 0, "python_code": "def isPalindrome ( N ) :\n    str1 = \"\" + str ( N )\n    len1 = len ( str1 )\n    for i in range ( int ( len1 / 2 ) ) :\n        if ( str1 [ i ] != str1 [ len1 - 1 - i ] ) :\n            return False\n    return True\ndef isPalinArray ( arr , n ) :\n    for i in range ( n ) :\n        ans = isPalindrome ( arr [ i ] )\n        if ( ans == False ) :\n            return False\n    return True\nif __name__ == '__main__' :\n    arr = [ 121 , 131 , 20 ]\n    n = len ( arr )\n    res = isPalinArray ( arr , n )\n    if ( res == True ) :\n        print ( \"Array is a PalinArray\" )\n    else :\n        print ( \"Array is not a PalinArray\" )\n", "python_code_tokenized": "def isPalindrome ( N ) : NEW_LINE INDENT str1 = \" \" + str ( N ) NEW_LINE len1 = len ( str1 ) NEW_LINE for i in range ( int ( len1 / 2 ) ) : NEW_LINE INDENT if ( str1 [ i ] != str1 [ len1 - 1 - i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPalinArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT ans = isPalindrome ( arr [ i ] ) NEW_LINE if ( ans == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 121 , 131 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE res = isPalinArray ( arr , n ) NEW_LINE if ( res == True ) : NEW_LINE INDENT print ( \" Array \u2581 is \u2581 a \u2581 PalinArray \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Array \u2581 is \u2581 not \u2581 a \u2581 PalinArray \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_950_A", "sol": 0, "python_code": "l , r , a = map ( int , input ( ).split ( ) ) ;\nif ( ( l == 0 and a == 0 ) or ( r == 0 and a == 0 ) ) :\n    print ( 0 )\nelse :\n    if ( l == r ) :\n        print ( ( l + r + a ) - ( ( l + r + a ) % 2 ) )\n    else :\n        x = min ( l , r )\n        y = max ( l , r )\n        z = y - x\n        if ( z <= a ) :\n            x = x + z\n            a = a - z\n        else :\n            x = x + a\n            a = 0\n        y = x\n        print ( ( x + y + a ) - ( ( x + y + a ) % 2 ) )\n", "python_code_tokenized": "l , r , a = map ( int , input ( ) . split ( ) ) ; NEW_LINE if ( ( l == 0 and a == 0 ) or ( r == 0 and a == 0 ) ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT print ( ( l + r + a ) - ( ( l + r + a ) % 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT x = min ( l , r ) NEW_LINE y = max ( l , r ) NEW_LINE z = y - x NEW_LINE if ( z <= a ) : NEW_LINE INDENT x = x + z NEW_LINE a = a - z NEW_LINE DEDENT else : NEW_LINE INDENT x = x + a NEW_LINE a = 0 NEW_LINE DEDENT y = x NEW_LINE print ( ( x + y + a ) - ( ( x + y + a ) % 2 ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4500_A", "sol": 0, "python_code": "import sys\ndef toggleLastMBits ( n , m ) :\n    num = ( 1 << m ) - 1\n    return ( n ^ num )\ndef unsetLastMBits ( n , m ) :\n    num = ( 1 << ( sys.getsizeof ( int ) * 8 - 1 ) ) - 1\n    num = toggleLastMBits ( num , m )\n    return ( n & num )\nn = 150\nm = 4\nprint ( unsetLastMBits ( n , m ) )\n", "python_code_tokenized": "import sys NEW_LINE def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def unsetLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << ( sys . getsizeof ( int ) * 8 - 1 ) ) - 1 NEW_LINE num = toggleLastMBits ( num , m ) NEW_LINE return ( n & num ) NEW_LINE DEDENT n = 150 NEW_LINE m = 4 NEW_LINE print ( unsetLastMBits ( n , m ) ) NEW_LINE"}
{"id": "geeksforgeeks_4574_A", "sol": 0, "python_code": "def getTotalXorOfSubarrayXors ( arr , N ) :\n    res = 0\n    for i in range ( 0 , N ) :\n        for j in range ( i , N ) :\n            for k in range ( i , j + 1 ) :\n                res = res ^ arr [ k ]\n    return res\narr = [ 3 , 5 , 2 , 4 , 6 ]\nN = len ( arr )\nprint ( getTotalXorOfSubarrayXors ( arr , N ) )\n", "python_code_tokenized": "def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT res = res ^ arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE"}
{"id": "geeksforgeeks_4467_A", "sol": 0, "python_code": "def findSetBits ( n ) :\n    dp = [ 0 ] * ( n + 1 ) ;\n    print ( dp [ 0 ] , end = \" \" ) ;\n    for i in range ( 1 , n + 1 ) :\n        if ( i % 2 == 0 ) :\n            dp [ i ] = dp [ i // 2 ] ;\n        else :\n            dp [ i ] = dp [ i // 2 ] + 1 ;\n        print ( dp [ i ] , end = \" \" ) ;\nif __name__ == \"__main__\" :\n    n = 5 ;\n    findSetBits ( n ) ;\n", "python_code_tokenized": "def findSetBits ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) ; NEW_LINE print ( dp [ 0 ] , end = \" \u2581 \" ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT dp [ i ] = dp [ i // 2 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i // 2 ] + 1 ; NEW_LINE DEDENT print ( dp [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE findSetBits ( n ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2125_A", "sol": 0, "python_code": "def getCount ( N ) :\n    if ( N % 2 == 1 ) :\n        return \"0\"\n    result = \"9\"\n    for i in range ( 1 , N // 2 ) :\n        result = result + \"0\"\n    return result\nN = 4\nprint ( getCount ( N ) )\n", "python_code_tokenized": "def getCount ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT result = \"9\" NEW_LINE for i in range ( 1 , N // 2 ) : NEW_LINE INDENT result = result + \"0\" NEW_LINE DEDENT return result NEW_LINE DEDENT N = 4 NEW_LINE print ( getCount ( N ) ) NEW_LINE"}
{"id": "geeksforgeeks_3108_A", "sol": 0, "python_code": "import math as mt\ndef findlargestAfterDel ( arr , m , dell , n ) :\n    mp = dict ( )\n    for i in range ( n ) :\n        if dell [ i ] in mp.keys ( ) :\n            mp [ dell [ i ] ] += 1\n        else :\n            mp [ dell [ i ] ] = 1\n    largestElement = - 10 ** 9\n    for i in range ( m ) :\n        if ( arr [ i ] in mp.keys ( ) ) :\n            mp [ arr [ i ] ] -= 1\n            if ( mp [ arr [ i ] ] == 0 ) :\n                mp.pop ( arr [ i ] )\n        else :\n            largestElement = max ( largestElement , arr [ i ] )\n    return largestElement\narray = [ 5 , 12 , 33 , 4 , 56 , 12 , 20 ]\nm = len ( array )\ndell = [ 12 , 33 , 56 , 5 ]\nn = len ( dell )\nprint ( findlargestAfterDel ( array , m , dell , n ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def findlargestAfterDel ( arr , m , dell , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if dell [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ dell [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ dell [ i ] ] = 1 NEW_LINE DEDENT DEDENT largestElement = - 10 ** 9 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( arr [ i ] in mp . keys ( ) ) : NEW_LINE INDENT mp [ arr [ i ] ] -= 1 NEW_LINE if ( mp [ arr [ i ] ] == 0 ) : NEW_LINE INDENT mp . pop ( arr [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT largestElement = max ( largestElement , arr [ i ] ) NEW_LINE DEDENT DEDENT return largestElement NEW_LINE DEDENT array = [ 5 , 12 , 33 , 4 , 56 , 12 , 20 ] NEW_LINE m = len ( array ) NEW_LINE dell = [ 12 , 33 , 56 , 5 ] NEW_LINE n = len ( dell ) NEW_LINE print ( findlargestAfterDel ( array , m , dell , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2516_A", "sol": 0, "python_code": "import math\ndef squares ( l , b , a ) :\n    return math.ceil ( l / a ) * math.ceil ( b / a )\nif __name__ == \"__main__\" :\n    l = 11\n    b = 23\n    a = 14\n    print ( squares ( l , b , a ) )\n", "python_code_tokenized": "import math NEW_LINE def squares ( l , b , a ) : NEW_LINE INDENT return math . ceil ( l / a ) * math . ceil ( b / a ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 11 NEW_LINE b = 23 NEW_LINE a = 14 NEW_LINE print ( squares ( l , b , a ) ) NEW_LINE DEDENT"}
{"id": "codeforces_266_A", "sol": 0, "python_code": "n = int ( input ( ) )\ns = input ( )\ncount = 0\nfor i in range ( len ( s ) - 1 ) :\n    if s [ i ] == s [ i + 1 ] :\n        count += 1\nprint ( count )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"}
{"id": "codeforces_1339_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    n = int ( input ( ) )\n    print ( n )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4736_A", "sol": 0, "python_code": "def countBits ( n ) :\n    count = 0\n    while ( n ) :\n        count += 1\n        n >>= 1\n    return count\ni = 65\nprint ( countBits ( i ) )\n", "python_code_tokenized": "def countBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT i = 65 NEW_LINE print ( countBits ( i ) ) NEW_LINE"}
{"id": "aizu_p02289_A", "sol": 0, "python_code": "from heapq import *\nimport sys\nq = [ ]\nwhile True :\n    a = sys.stdin.readline ( ).split ( )\n    if a [ 0 ] == 'end' : break\n    if a [ 0 ] == 'insert' :\n        heappush ( q , - int ( a [ 1 ] ) )\n    else :\n        print ( - heappop ( q ) )\n", "python_code_tokenized": "from heapq import * NEW_LINE import sys NEW_LINE q = [ ] NEW_LINE while True : NEW_LINE INDENT a = sys . stdin . readline ( ) . split ( ) NEW_LINE if a [ 0 ] == ' end ' : break NEW_LINE if a [ 0 ] == ' insert ' : NEW_LINE INDENT heappush ( q , - int ( a [ 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - heappop ( q ) ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ARC075_C", "sol": 0, "python_code": "class BIT :\n    def __init__ ( self , n ) :\n        self.n = n\n        self.data = [ 0 ] * ( n + 1 )\n        self.el = [ 0 ] * ( n + 1 )\n    def sum ( self , i ) :\n        s = 0\n        while i > 0 :\n            s += self.data [ i ]\n            i -= i & - i\n        return s\n    def add ( self , i , x ) :\n        self.el [ i ] += x\n        while i <= self.n :\n            self.data [ i ] += x\n            i += i & - i\n    def get ( self , i , j = None ) :\n        if j is None :\n            return self.el [ i ]\n        return self.sum ( j ) - self.sum ( i )\ndef main ( ) :\n    from itertools import accumulate\n    N , K = map ( int , input ( ).split ( ) )\n    A = ( int ( input ( ) ) - K for _ in range ( N ) )\n    acc = ( 0 , ) + tuple ( accumulate ( A ) )\n    def compress ( iter ) :\n        convert = { x : i for i , x in enumerate ( sorted ( iter ) , start = 1 ) }\n        return ( convert [ x ] for x in iter )\n    comacc = tuple ( compress ( acc ) )\n    ret = 0\n    b = BIT ( len ( comacc ) )\n    for x in comacc :\n        ret += b.sum ( x )\n        b.add ( x , 1 )\n    print ( ret )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "class BIT : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . n = n NEW_LINE self . data = [ 0 ] * ( n + 1 ) NEW_LINE self . el = [ 0 ] * ( n + 1 ) NEW_LINE DEDENT def sum ( self , i ) : NEW_LINE INDENT s = 0 NEW_LINE while i > 0 : NEW_LINE INDENT s += self . data [ i ] NEW_LINE i -= i & - i NEW_LINE DEDENT return s NEW_LINE DEDENT def add ( self , i , x ) : NEW_LINE INDENT self . el [ i ] += x NEW_LINE while i <= self . n : NEW_LINE INDENT self . data [ i ] += x NEW_LINE i += i & - i NEW_LINE DEDENT DEDENT def get ( self , i , j = None ) : NEW_LINE INDENT if j is None : NEW_LINE INDENT return self . el [ i ] NEW_LINE DEDENT return self . sum ( j ) - self . sum ( i ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT from itertools import accumulate NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = ( int ( input ( ) ) - K for _ in range ( N ) ) NEW_LINE acc = ( 0 , ) + tuple ( accumulate ( A ) ) NEW_LINE def compress ( iter ) : NEW_LINE INDENT convert = { x : i for i , x in enumerate ( sorted ( iter ) , start = 1 ) } NEW_LINE return ( convert [ x ] for x in iter ) NEW_LINE DEDENT comacc = tuple ( compress ( acc ) ) NEW_LINE ret = 0 NEW_LINE b = BIT ( len ( comacc ) ) NEW_LINE for x in comacc : NEW_LINE INDENT ret += b . sum ( x ) NEW_LINE b . add ( x , 1 ) NEW_LINE DEDENT print ( ret ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4889_A", "sol": 0, "python_code": "def getElement ( a , n , S ) :\n    a.sort ( ) ;\n    sum = 0 ;\n    for i in range ( n ) :\n        if ( sum + ( a [ i ] * ( n - i ) ) == S ) :\n            return a [ i ] ;\n        sum += a [ i ] ;\n    return - 1 ;\nif __name__ == \"__main__\" :\n    S = 5 ;\n    a = [ 1 , 3 , 2 , 5 , 8 ] ;\n    n = len ( a ) ;\n    print ( getElement ( a , n , S ) ) ;\n", "python_code_tokenized": "def getElement ( a , n , S ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( sum + ( a [ i ] * ( n - i ) ) == S ) : NEW_LINE INDENT return a [ i ] ; NEW_LINE DEDENT sum += a [ i ] ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = 5 ; NEW_LINE a = [ 1 , 3 , 2 , 5 , 8 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( getElement ( a , n , S ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_280_B", "sol": 0, "python_code": "import sys\ndef solver ( nums ) :\n    st = [ float ( 'inf' ) ]\n    res = nums [ 0 ] ^ nums [ 1 ]\n    for i , num in enumerate ( nums ) :\n        while num > st [ - 1 ] :\n            cur = st.pop ( )\n            if len ( st ) > 1 :\n                res = max ( [ res , cur ^ st [ - 1 ] , cur ^ num ] )\n            else :\n                res = max ( res , cur ^ num )\n                break\n        st.append ( num )\n    while len ( st ) > 2 :\n        cur = st.pop ( )\n        res = max ( res , cur ^ st [ - 1 ] )\n    return res\nif __name__ == '__main__' :\n    n = int ( sys.stdin.readline ( ).strip ( '/n' ).split ( ) [ 0 ] )\n    nums = sys.stdin.readline ( ).strip ( '/n' ).split ( )\n    nums = list ( map ( int , nums ) )\n    print ( solver ( nums ) )\n", "python_code_tokenized": "import sys NEW_LINE def solver ( nums ) : NEW_LINE INDENT st = [ float ( ' inf ' ) ] NEW_LINE res = nums [ 0 ] ^ nums [ 1 ] NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT while num > st [ - 1 ] : NEW_LINE INDENT cur = st . pop ( ) NEW_LINE if len ( st ) > 1 : NEW_LINE INDENT res = max ( [ res , cur ^ st [ - 1 ] , cur ^ num ] ) NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , cur ^ num ) NEW_LINE break NEW_LINE DEDENT DEDENT st . append ( num ) NEW_LINE DEDENT while len ( st ) > 2 : NEW_LINE INDENT cur = st . pop ( ) NEW_LINE res = max ( res , cur ^ st [ - 1 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) . strip ( ' / n ' ) . split ( ) [ 0 ] ) NEW_LINE nums = sys . stdin . readline ( ) . strip ( ' / n ' ) . split ( ) NEW_LINE nums = list ( map ( int , nums ) ) NEW_LINE print ( solver ( nums ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02494_A", "sol": 0, "python_code": "while True :\n    h , w = map ( int , raw_input ( ).split ( ' ' ) )\n    if h == w and h == 0 :\n        break\n    print ( '#' * w + '\\n' ) * h\n", "python_code_tokenized": "while True : NEW_LINE INDENT h , w = map ( int , raw_input ( ) . split ( ' \u2581 ' ) ) NEW_LINE if h == w and h == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( ' # ' * w + ' \\n ' ) * h NEW_LINE DEDENT"}
{"id": "geeksforgeeks_92_A", "sol": 0, "python_code": "def ___gcd ( a , b ) :\n    if ( a == 0 or b == 0 ) :\n        return 0\n    if ( a == b ) :\n        return a\n    if ( a > b ) :\n        return ___gcd ( a - b , b )\n    return ___gcd ( a , b - a )\ndef lcmOfArray ( arr , n ) :\n    ans = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        ans = ( arr [ i ] * ans ) / ___gcd ( arr [ i ] , ans )\n    return ans\ndef checkArray ( arr , prime , n , m ) :\n    lcm = lcmOfArray ( arr , n )\n    for i in range ( n ) :\n        val = lcm / arr [ i ]\n        for j in range ( m and val != 1 ) :\n            while ( val % prime [ j ] == 0 ) :\n                val = val / prime [ j ]\n        if ( val != 1 ) :\n            return 0\n    return 1\narr = [ 50 , 200 ]\nprime = [ 2 , 3 ]\nn = len ( arr )\nm = len ( prime )\nif ( checkArray ( arr , prime , n , m ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def ___gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return ___gcd ( a - b , b ) NEW_LINE DEDENT return ___gcd ( a , b - a ) NEW_LINE DEDENT def lcmOfArray ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = ( arr [ i ] * ans ) / ___gcd ( arr [ i ] , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def checkArray ( arr , prime , n , m ) : NEW_LINE INDENT lcm = lcmOfArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = lcm / arr [ i ] NEW_LINE for j in range ( m and val != 1 ) : NEW_LINE INDENT while ( val % prime [ j ] == 0 ) : NEW_LINE INDENT val = val / prime [ j ] NEW_LINE DEDENT DEDENT if ( val != 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT arr = [ 50 , 200 ] NEW_LINE prime = [ 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = len ( prime ) NEW_LINE if ( checkArray ( arr , prime , n , m ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2287_A", "sol": 0, "python_code": "MAX = 32768\narr = [ None ] * ( 2 * MAX )\ndef gouldSequence ( ) :\n    arr [ 0 ] = 1\n    i = 1\n    p = 1\n    while i <= MAX :\n        j = 0\n        while j < i :\n            arr [ i + j ] = 2 * arr [ j ]\n            j += 1\n        i = ( 1 << p )\n        p += 1\ndef printSequence ( n ) :\n    for i in range ( 0 , n ) :\n        print ( arr [ i ] , end = \" \" )\nif __name__ == \"__main__\" :\n    gouldSequence ( )\n    n = 16\n    printSequence ( n )\n", "python_code_tokenized": "MAX = 32768 NEW_LINE arr = [ None ] * ( 2 * MAX ) NEW_LINE def gouldSequence ( ) : NEW_LINE INDENT arr [ 0 ] = 1 NEW_LINE i = 1 NEW_LINE p = 1 NEW_LINE while i <= MAX : NEW_LINE INDENT j = 0 NEW_LINE while j < i : NEW_LINE INDENT arr [ i + j ] = 2 * arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT i = ( 1 << p ) NEW_LINE p += 1 NEW_LINE DEDENT DEDENT def printSequence ( n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT gouldSequence ( ) NEW_LINE n = 16 NEW_LINE printSequence ( n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5153_A", "sol": 0, "python_code": "N = 4\ndef printSolution ( sol ) :\n    for i in sol :\n        for j in i :\n            print ( str ( j ) + \"\" , end = \"\" )\n        print ( \"\" )\ndef isSafe ( maze , x , y ) :\n    if x >= 0 and x < N and y >= 0 and y < N and maze [ x ] [ y ] == 1 :\n        return True\n    return False\ndef solveMaze ( maze ) :\n    sol = [ [ 0 for j in range ( 4 ) ] for i in range ( 4 ) ]\n    if solveMazeUtil ( maze , 0 , 0 , sol ) == False :\n        print ( \"Solution doesn't exist\" ) ;\n        return False\n    printSolution ( sol )\n    return True\ndef solveMazeUtil ( maze , x , y , sol ) :\n    if x == N - 1 and y == N - 1 and maze [ x ] [ y ] == 1 :\n        sol [ x ] [ y ] = 1\n        return True\n    if isSafe ( maze , x , y ) == True :\n        sol [ x ] [ y ] = 1\n        if solveMazeUtil ( maze , x + 1 , y , sol ) == True :\n            return True\n        if solveMazeUtil ( maze , x , y + 1 , sol ) == True :\n            return True\n        sol [ x ] [ y ] = 0\n        return False\nif __name__ == \"__main__\" :\n    maze = [ [ 1 , 0 , 0 , 0 ] , [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 0 , 0 ] , [ 1 , 1 , 1 , 1 ] ]\n    solveMaze ( maze )\n", "python_code_tokenized": "N = 4 NEW_LINE def printSolution ( sol ) : NEW_LINE INDENT for i in sol : NEW_LINE INDENT for j in i : NEW_LINE INDENT print ( str ( j ) + \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT DEDENT def isSafe ( maze , x , y ) : NEW_LINE INDENT if x >= 0 and x < N and y >= 0 and y < N and maze [ x ] [ y ] == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def solveMaze ( maze ) : NEW_LINE INDENT sol = [ [ 0 for j in range ( 4 ) ] for i in range ( 4 ) ] NEW_LINE if solveMazeUtil ( maze , 0 , 0 , sol ) == False : NEW_LINE INDENT print ( \" Solution \u2581 doesn ' t \u2581 exist \" ) ; NEW_LINE return False NEW_LINE DEDENT printSolution ( sol ) NEW_LINE return True NEW_LINE DEDENT def solveMazeUtil ( maze , x , y , sol ) : NEW_LINE INDENT if x == N - 1 and y == N - 1 and maze [ x ] [ y ] == 1 : NEW_LINE INDENT sol [ x ] [ y ] = 1 NEW_LINE return True NEW_LINE DEDENT if isSafe ( maze , x , y ) == True : NEW_LINE INDENT sol [ x ] [ y ] = 1 NEW_LINE if solveMazeUtil ( maze , x + 1 , y , sol ) == True : NEW_LINE INDENT return True NEW_LINE DEDENT if solveMazeUtil ( maze , x , y + 1 , sol ) == True : NEW_LINE INDENT return True NEW_LINE DEDENT sol [ x ] [ y ] = 0 NEW_LINE return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT maze = [ [ 1 , 0 , 0 , 0 ] , [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 0 , 0 ] , [ 1 , 1 , 1 , 1 ] ] NEW_LINE solveMaze ( maze ) NEW_LINE DEDENT"}
{"id": "codeforces_597_A", "sol": 0, "python_code": "k , a , b = map ( int , input ( ).split ( ) )\ndef numbers ( a , b , k ) :\n    x = b // k - a // k\n    if a % k == 0 :\n        x += 1\n    return x\nif a == 0 and b == 0 :\n    print ( 1 )\nif a > 0 and b > 0 :\n    print ( numbers ( a , b , k ) )\nelif a == 0 and b > 0 :\n    print ( numbers ( a + 1 , b , k ) + 1 )\nelif a < 0 and b == 0 :\n    print ( numbers ( 1 , - a , k ) + 1 )\nelif a < 0 and b > 0 :\n    print ( numbers ( 1 , b , k ) + numbers ( 1 , - a , k ) + 1 )\nelif a < 0 and b < 0 :\n    print ( numbers ( - b , - a , k ) )\n", "python_code_tokenized": "k , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE def numbers ( a , b , k ) : NEW_LINE INDENT x = b // k - a // k NEW_LINE if a % k == 0 : NEW_LINE INDENT x += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT if a == 0 and b == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT if a > 0 and b > 0 : NEW_LINE INDENT print ( numbers ( a , b , k ) ) NEW_LINE DEDENT elif a == 0 and b > 0 : NEW_LINE INDENT print ( numbers ( a + 1 , b , k ) + 1 ) NEW_LINE DEDENT elif a < 0 and b == 0 : NEW_LINE INDENT print ( numbers ( 1 , - a , k ) + 1 ) NEW_LINE DEDENT elif a < 0 and b > 0 : NEW_LINE INDENT print ( numbers ( 1 , b , k ) + numbers ( 1 , - a , k ) + 1 ) NEW_LINE DEDENT elif a < 0 and b < 0 : NEW_LINE INDENT print ( numbers ( - b , - a , k ) ) NEW_LINE DEDENT"}
{"id": "codeforces_230_B", "sol": 0, "python_code": "n , m = int ( input ( ) ) , [ int ( t ) for t in input ( ).split ( ) ]\nub = int ( max ( m ) ** 0.5 ) + 1\nisprimes = [ 1 ] * ub\nfor i in range ( 2 , ub + 1 ) :\n    if isprimes [ i - 1 ] :\n        j = 2\n        while j * i <= ub :\n            isprimes [ j * i - 1 ] = 0\n            j += 1\nisprimes [ 0 ] = 0\nfor k in m :\n    div = int ( k ** 0.5 )\n    if div * div == k :\n        if isprimes [ div - 1 ] :\n            print ( 'YES' )\n        else :\n            print ( 'NO' )\n    else :\n        print ( 'NO' )\n", "python_code_tokenized": "n , m = int ( input ( ) ) , [ int ( t ) for t in input ( ) . split ( ) ] NEW_LINE ub = int ( max ( m ) ** 0.5 ) + 1 NEW_LINE isprimes = [ 1 ] * ub NEW_LINE for i in range ( 2 , ub + 1 ) : NEW_LINE INDENT if isprimes [ i - 1 ] : NEW_LINE INDENT j = 2 NEW_LINE while j * i <= ub : NEW_LINE INDENT isprimes [ j * i - 1 ] = 0 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT isprimes [ 0 ] = 0 NEW_LINE for k in m : NEW_LINE INDENT div = int ( k ** 0.5 ) NEW_LINE if div * div == k : NEW_LINE INDENT if isprimes [ div - 1 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_AGC014_B", "sol": 0, "python_code": "import sys\nYES = \"YES\"\nNO = \"NO\"\ndef solve ( N : int , M : int , a : \"List[int]\" , b : \"List[int]\" ) :\n    edge_weights = [ 0 ] * ( N + 1 )\n    for i in range ( M ) :\n        edge_weights [ a [ i ] ] += 1\n        edge_weights [ b [ i ] ] -= 1\n    from itertools import accumulate\n    edge_weights = list ( accumulate ( edge_weights ) )\n    for i in range ( N + 1 ) :\n        if edge_weights [ i ] % 2 == 0 :\n            continue\n        else :\n            print ( NO )\n            return\n    print ( YES )\n    return\ndef main ( ) :\n    def iterate_tokens ( ) :\n        for line in sys.stdin :\n            for word in line.split ( ) :\n                yield word\n    tokens = iterate_tokens ( )\n    N = int ( next ( tokens ) )\n    M = int ( next ( tokens ) )\n    a = [ int ( ) ] * ( M )\n    b = [ int ( ) ] * ( M )\n    for i in range ( M ) :\n        a [ i ] = int ( next ( tokens ) )\n        b [ i ] = int ( next ( tokens ) )\n    solve ( N , M , a , b )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "import sys NEW_LINE YES = \" YES \" NEW_LINE NO = \" NO \" NEW_LINE def solve ( N : int , M : int , a : \" List [ int ] \" , b : \" List [ int ] \" ) : NEW_LINE INDENT edge_weights = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT edge_weights [ a [ i ] ] += 1 NEW_LINE edge_weights [ b [ i ] ] -= 1 NEW_LINE DEDENT from itertools import accumulate NEW_LINE edge_weights = list ( accumulate ( edge_weights ) ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if edge_weights [ i ] % 2 == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( NO ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( YES ) NEW_LINE return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE M = int ( next ( tokens ) ) NEW_LINE a = [ int ( ) ] * ( M ) NEW_LINE b = [ int ( ) ] * ( M ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT a [ i ] = int ( next ( tokens ) ) NEW_LINE b [ i ] = int ( next ( tokens ) ) NEW_LINE DEDENT solve ( N , M , a , b ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1417_A", "sol": 0, "python_code": "def maxLength ( a , n ) :\n    maximum = 1 ;\n    left = [ 0 ] * n ;\n    right = [ 0 ] * n ;\n    for i in range ( n ) :\n        left [ i ] = 1 ;\n        right [ i ] = 1 ;\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if ( a [ i ] > a [ i + 1 ] ) :\n            right [ i ] = right [ i + 1 ] + 1 ;\n        maximum = max ( maximum , right [ i ] ) ;\n    for i in range ( 1 , n ) :\n        if ( a [ i ] < a [ i - 1 ] ) :\n            left [ i ] = left [ i - 1 ] + 1 ;\n    if ( n > 2 ) :\n        for i in range ( 1 , n - 1 ) :\n            if ( a [ i - 1 ] > a [ i + 1 ] ) :\n                maximum = max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ;\n    return maximum ;\nif __name__ == \"__main__\" :\n    arr = [ 8 , 7 , 3 , 5 , 2 , 9 ] ;\n    n = len ( arr ) ;\n    print ( maxLength ( arr , n ) ) ;\n", "python_code_tokenized": "def maxLength ( a , n ) : NEW_LINE INDENT maximum = 1 ; NEW_LINE left = [ 0 ] * n ; NEW_LINE right = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT left [ i ] = 1 ; NEW_LINE right [ i ] = 1 ; NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 ; NEW_LINE DEDENT maximum = max ( maximum , right [ i ] ) ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] > a [ i + 1 ] ) : NEW_LINE INDENT maximum = max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT return maximum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 7 , 3 , 5 , 2 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxLength ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4661_A", "sol": 0, "python_code": "def strScore ( str , s , n ) :\n    score = 0\n    index = 0\n    for i in range ( n ) :\n        if ( str [ i ] == s ) :\n            for j in range ( len ( s ) ) :\n                score += ( ord ( s [ j ] ) - ord ( 'a' ) + 1 )\n            index = i + 1\n            break\n    score = score * index\n    return score\nstr = [ \"sahil\" , \"shashanak\" , \"sanjit\" , \"abhinav\" , \"mohit\" ]\ns = \"abhinav\"\nn = len ( str )\nscore = strScore ( str , s , n ) ;\nprint ( score )\n", "python_code_tokenized": "def strScore ( str , s , n ) : NEW_LINE INDENT score = 0 NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == s ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT score += ( ord ( s [ j ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT index = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT score = score * index NEW_LINE return score NEW_LINE DEDENT str = [ \" sahil \" , \" shashanak \" , \" sanjit \" , \" abhinav \" , \" mohit \" ] NEW_LINE s = \" abhinav \" NEW_LINE n = len ( str ) NEW_LINE score = strScore ( str , s , n ) ; NEW_LINE print ( score ) NEW_LINE"}
{"id": "codeforces_946_A", "sol": 0, "python_code": "n = int ( input ( ) )\nlst = list ( map ( int , input ( ).split ( ) ) )\nb = [ ]\nc = [ ]\nsum_c = 0\nsum_b = 0\nfor x in lst :\n    if x < 0 :\n        sum_c += x\n    else :\n        sum_b += x\nprint ( sum_b - sum_c )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE c = [ ] NEW_LINE sum_c = 0 NEW_LINE sum_b = 0 NEW_LINE for x in lst : NEW_LINE INDENT if x < 0 : NEW_LINE INDENT sum_c += x NEW_LINE DEDENT else : NEW_LINE INDENT sum_b += x NEW_LINE DEDENT DEDENT print ( sum_b - sum_c ) NEW_LINE"}
{"id": "projecteuler_p304_A", "sol": 0, "python_code": "import eulerlib\ndef compute ( ) :\n    BASE = 10 ** 14\n    SEARCH_RANGE = 10000000\n    MODULUS = 1234567891011\n    iscomposite = [ False ] * SEARCH_RANGE\n    primes = eulerlib.list_primes ( eulerlib.sqrt ( BASE + SEARCH_RANGE ) )\n    for p in primes :\n        for i in range ( ( BASE + p - 1 ) // p * p - BASE , len ( iscomposite ) , p ) :\n            iscomposite [ i ] = True\n    def next_prime ( n ) :\n        while True :\n            n += 1\n            if n >= len ( iscomposite ) :\n                raise AssertionError ( \"Search range exhausted\" )\n            if not iscomposite [ n ] :\n                return n\n    ans = 0\n    p = 0\n    for i in range ( 100000 ) :\n        p = next_prime ( p )\n        ans = ( ans + fibonacci_mod ( BASE + p , MODULUS ) ) % MODULUS\n    return str ( ans )\ndef fibonacci_mod ( n , mod ) :\n    a , b = 0 , 1\n    binary = bin ( n ) [ 2 : ]\n    for bit in binary :\n        a , b = a * ( b * 2 - a ) , a * a + b * b\n        if bit == \"1\" :\n            a , b = b , a + b\n        a %= mod\n        b %= mod\n    return a\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT BASE = 10 ** 14 NEW_LINE SEARCH_RANGE = 10000000 NEW_LINE MODULUS = 1234567891011 NEW_LINE iscomposite = [ False ] * SEARCH_RANGE NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( BASE + SEARCH_RANGE ) ) NEW_LINE for p in primes : NEW_LINE INDENT for i in range ( ( BASE + p - 1 ) // p * p - BASE , len ( iscomposite ) , p ) : NEW_LINE INDENT iscomposite [ i ] = True NEW_LINE DEDENT DEDENT def next_prime ( n ) : NEW_LINE INDENT while True : NEW_LINE INDENT n += 1 NEW_LINE if n >= len ( iscomposite ) : NEW_LINE INDENT raise AssertionError ( \" Search \u2581 range \u2581 exhausted \" ) NEW_LINE DEDENT if not iscomposite [ n ] : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE p = 0 NEW_LINE for i in range ( 100000 ) : NEW_LINE INDENT p = next_prime ( p ) NEW_LINE ans = ( ans + fibonacci_mod ( BASE + p , MODULUS ) ) % MODULUS NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT def fibonacci_mod ( n , mod ) : NEW_LINE INDENT a , b = 0 , 1 NEW_LINE binary = bin ( n ) [ 2 : ] NEW_LINE for bit in binary : NEW_LINE INDENT a , b = a * ( b * 2 - a ) , a * a + b * b NEW_LINE if bit == \"1\" : NEW_LINE INDENT a , b = b , a + b NEW_LINE DEDENT a %= mod NEW_LINE b %= mod NEW_LINE DEDENT return a NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_611_A", "sol": 0, "python_code": "def printTrib ( n ) :\n    dp = [ 0 ] * n\n    dp [ 0 ] = dp [ 1 ] = 0 ;\n    dp [ 2 ] = 1 ;\n    for i in range ( 3 , n ) :\n        dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ;\n    for i in range ( 0 , n ) :\n        print ( dp [ i ] , \"\" , end = \"\" )\nn = 10\nprintTrib ( n )\n", "python_code_tokenized": "def printTrib ( n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = dp [ 1 ] = 0 ; NEW_LINE dp [ 2 ] = 1 ; NEW_LINE for i in range ( 3 , n ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( dp [ i ] , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE"}
{"id": "codeforces_1470_A", "sol": 0, "python_code": "def strangeBDParty ( n : int , m : int , k : [ int ] , c : [ int ] ) -> int :\n    k.sort ( reverse = True )\n    cost = l = 0\n    for i in range ( n ) :\n        if l < m and c [ l ] < c [ k [ i ] - 1 ] :\n            cost += c [ l ]\n            l += 1\n        else :\n            cost += c [ k [ i ] - 1 ]\n    return cost\nrep = int ( input ( ) )\nfor _ in range ( rep ) :\n    n , m = list ( map ( int , input ( ).split ( ) ) )\n    k = list ( map ( int , input ( ).split ( ) ) )\n    c = list ( map ( int , input ( ).split ( ) ) )\n    print ( strangeBDParty ( n , m , k , c ) )\n", "python_code_tokenized": "def strangeBDParty ( n : int , m : int , k : [ int ] , c : [ int ] ) -> int : NEW_LINE INDENT k . sort ( reverse = True ) NEW_LINE cost = l = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l < m and c [ l ] < c [ k [ i ] - 1 ] : NEW_LINE INDENT cost += c [ l ] NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cost += c [ k [ i ] - 1 ] NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT rep = int ( input ( ) ) NEW_LINE for _ in range ( rep ) : NEW_LINE INDENT n , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( strangeBDParty ( n , m , k , c ) ) NEW_LINE DEDENT"}
