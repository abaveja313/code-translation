{"id": "geeksforgeeks_4735_A", "sol": 0, "python_code": "import math\ndef countBits ( number ) :\n    return int ( ( math.log ( number ) / math.log ( 2 ) ) + 1 ) ;\nnum = 65 ;\nprint ( countBits ( num ) ) ;\n", "python_code_tokenized": "import math NEW_LINE def countBits ( number ) : NEW_LINE INDENT return int ( ( math . log ( number ) / math . log ( 2 ) ) + 1 ) ; NEW_LINE DEDENT num = 65 ; NEW_LINE print ( countBits ( num ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_4672_A", "sol": 0, "python_code": "def isSellingPossible ( n , a ) :\n    c25 = 0 ;\n    c50 = 0 ;\n    i = 0 ;\n    while ( i < n ) :\n        if ( a [ i ] == 25 ) :\n            c25 += 1 ;\n        elif ( a [ i ] == 50 ) :\n            c50 += 1 ;\n            if ( c25 == 0 ) :\n                break ;\n            c25 -= 1 ;\n        else :\n            if ( c50 > 0 and c25 > 0 ) :\n                c50 -= 1 ;\n                c25 -= 1 ;\n            elif ( c25 >= 3 ) :\n                c25 -= 3 ;\n            else :\n                break ;\n        i += 1 ;\n    if ( i == n ) :\n        return True ;\n    else :\n        return False ;\na = [ 25 , 25 , 50 , 100 ] ;\nn = len ( a ) ;\nif ( isSellingPossible ( n , a ) ) :\n    print ( \"YES\" ) ;\nelse :\n    print ( \"NO\" ) ;\n", "python_code_tokenized": "def isSellingPossible ( n , a ) : NEW_LINE INDENT c25 = 0 ; NEW_LINE c50 = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( a [ i ] == 25 ) : NEW_LINE INDENT c25 += 1 ; NEW_LINE DEDENT elif ( a [ i ] == 50 ) : NEW_LINE INDENT c50 += 1 ; NEW_LINE if ( c25 == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT c25 -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( c50 > 0 and c25 > 0 ) : NEW_LINE INDENT c50 -= 1 ; NEW_LINE c25 -= 1 ; NEW_LINE DEDENT elif ( c25 >= 3 ) : NEW_LINE INDENT c25 -= 3 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT a = [ 25 , 25 , 50 , 100 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( isSellingPossible ( n , a ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3170_A", "sol": 0, "python_code": "def findMissingNo ( arr , n ) :\n    for i in range ( n ) :\n        if ( arr [ i ] <= 0 or arr [ i ] > n ) :\n            continue\n        val = arr [ i ]\n        while ( arr [ val - 1 ] != val ) :\n            nextval = arr [ val - 1 ]\n            arr [ val - 1 ] = val\n            val = nextval\n            if ( val <= 0 or val > n ) :\n                break\n    for i in range ( n ) :\n        if ( arr [ i ] != i + 1 ) :\n            return i + 1\n    return n + 1\nif __name__ == \"__main__\" :\n    arr = [ 2 , 3 , 7 , 6 , 8 , - 1 , - 10 , 15 ]\n    arr_size = len ( arr )\n    missing = findMissingNo ( arr , arr_size )\n    print ( \"The smallest positive\" , \"missing number is \" , missing )\n", "python_code_tokenized": "def findMissingNo ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= 0 or arr [ i ] > n ) : NEW_LINE INDENT continue NEW_LINE DEDENT val = arr [ i ] NEW_LINE while ( arr [ val - 1 ] != val ) : NEW_LINE INDENT nextval = arr [ val - 1 ] NEW_LINE arr [ val - 1 ] = val NEW_LINE val = nextval NEW_LINE if ( val <= 0 or val > n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != i + 1 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return n + 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 7 , 6 , 8 , - 1 , - 10 , 15 ] NEW_LINE arr_size = len ( arr ) NEW_LINE missing = findMissingNo ( arr , arr_size ) NEW_LINE print ( \" The \u2581 smallest \u2581 positive \" , \" missing \u2581 number \u2581 is \u2581 \" , missing ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4436_A", "sol": 0, "python_code": "def ladder_pattern ( N ) :\n    for i in range ( N + 1 ) :\n        print ( \"*   *\" ) ;\n        print ( \"*   *\" ) ;\n        if ( i < N ) :\n            print ( \"*****\" ) ;\nif __name__ == \"__main__\" :\n    N = 3 ;\n    ladder_pattern ( N ) ;\n", "python_code_tokenized": "def ladder_pattern ( N ) : NEW_LINE INDENT for i in range ( N + 1 ) : NEW_LINE INDENT print ( \" * \u2581 \u2581 \u2581 * \" ) ; NEW_LINE print ( \" * \u2581 \u2581 \u2581 * \" ) ; NEW_LINE if ( i < N ) : NEW_LINE INDENT print ( \" * * * * * \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 ; NEW_LINE ladder_pattern ( N ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1155_A", "sol": 0, "python_code": "def f ( s ) :\n    for i in range ( 1 , len ( s ) ) :\n        if s [ i ] < s [ i - 1 ] :\n            print ( \"YES\" )\n            print ( i , i + 1 )\n            return\n    print ( 'NO' )\nn = int ( input ( ) )\nf ( input ( ) )\n", "python_code_tokenized": "def f ( s ) : NEW_LINE INDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] < s [ i - 1 ] : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE print ( i , i + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( ' NO ' ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE f ( input ( ) ) NEW_LINE"}
{"id": "geeksforgeeks_3611_A", "sol": 0, "python_code": "MAX = 1000 ;\ndef lineExists ( x , y , v , n ) :\n    size = ( 2 * MAX ) + 1 ;\n    arr = [ 0 ] * size ;\n    for i in range ( n ) :\n        arr [ x [ i ] + MAX ] += v [ i ] ;\n    for i in range ( 1 , size ) :\n        arr [ i ] += arr [ i - 1 ] ;\n    if ( arr [ size - 1 ] == 0 ) :\n        return True ;\n    if ( arr [ size - 1 ] - arr [ 0 ] == 0 ) :\n        return True ;\n    for i in range ( 1 , size - 1 ) :\n        if ( arr [ i - 1 ] == arr [ size - 1 ] - arr [ i - 1 ] ) :\n            return True ;\n        if ( arr [ i - 1 ] == arr [ size - 1 ] - arr [ i ] ) :\n            return True ;\n        if ( arr [ i ] == arr [ size - 1 ] - arr [ i ] ) :\n            return True ;\n    if ( arr [ size - 2 ] == 0 ) :\n        return True ;\n    return False ;\nif __name__ == \"__main__\" :\n    x = [ - 3 , 5 , 8 ] ;\n    y = [ 8 , 7 , 9 ] ;\n    v = [ 8 , 2 , 10 ] ;\n    n = len ( x ) ;\n    if ( lineExists ( x , y , v , n ) ) :\n        print ( \"Yes\" ) ;\n    else :\n        print ( \"No\" ) ;\n", "python_code_tokenized": "MAX = 1000 ; NEW_LINE def lineExists ( x , y , v , n ) : NEW_LINE INDENT size = ( 2 * MAX ) + 1 ; NEW_LINE arr = [ 0 ] * size ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ x [ i ] + MAX ] += v [ i ] ; NEW_LINE DEDENT for i in range ( 1 , size ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] ; NEW_LINE DEDENT if ( arr [ size - 1 ] == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( arr [ size - 1 ] - arr [ 0 ] == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT for i in range ( 1 , size - 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] == arr [ size - 1 ] - arr [ i - 1 ] ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( arr [ i - 1 ] == arr [ size - 1 ] - arr [ i ] ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( arr [ i ] == arr [ size - 1 ] - arr [ i ] ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT if ( arr [ size - 2 ] == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = [ - 3 , 5 , 8 ] ; NEW_LINE y = [ 8 , 7 , 9 ] ; NEW_LINE v = [ 8 , 2 , 10 ] ; NEW_LINE n = len ( x ) ; NEW_LINE if ( lineExists ( x , y , v , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3504_A", "sol": 0, "python_code": "class newNode :\n    def __init__ ( self , key ) :\n        self.data = key\n        self.left = None\n        self.right = None\ndef evenOddLevelDifference ( root ) :\n    if ( not root ) :\n        return 0\n    q = [ ]\n    q.append ( root )\n    level = 0\n    evenSum = 0\n    oddSum = 0\n    while ( len ( q ) ) :\n        size = len ( q )\n        level += 1\n        while ( size > 0 ) :\n            temp = q [ 0 ]\n            q.pop ( 0 )\n            if ( level % 2 == 0 ) :\n                evenSum += temp.data\n            else :\n                oddSum += temp.data\n            if ( temp.left ) :\n                q.append ( temp.left )\n            if ( temp.right ) :\n                q.append ( temp.right )\n            size -= 1\n    return ( oddSum - evenSum )\nif __name__ == '__main__' :\n    root = newNode ( 5 )\n    root.left = newNode ( 2 )\n    root.right = newNode ( 6 )\n    root.left.left = newNode ( 1 )\n    root.left.right = newNode ( 4 )\n    root.left.right.left = newNode ( 3 )\n    root.right.right = newNode ( 8 )\n    root.right.right.right = newNode ( 9 )\n    root.right.right.left = newNode ( 7 )\n    result = evenOddLevelDifference ( root )\n    print ( \"Diffence between sums is\" , result )\n", "python_code_tokenized": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def evenOddLevelDifference ( root ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE level = 0 NEW_LINE evenSum = 0 NEW_LINE oddSum = 0 NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT size = len ( q ) NEW_LINE level += 1 NEW_LINE while ( size > 0 ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( level % 2 == 0 ) : NEW_LINE INDENT evenSum += temp . data NEW_LINE DEDENT else : NEW_LINE INDENT oddSum += temp . data NEW_LINE DEDENT if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT size -= 1 NEW_LINE DEDENT DEDENT return ( oddSum - evenSum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 5 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 6 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 4 ) NEW_LINE root . left . right . left = newNode ( 3 ) NEW_LINE root . right . right = newNode ( 8 ) NEW_LINE root . right . right . right = newNode ( 9 ) NEW_LINE root . right . right . left = newNode ( 7 ) NEW_LINE result = evenOddLevelDifference ( root ) NEW_LINE print ( \" Diffence \u2581 between \u2581 sums \u2581 is \" , result ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3011_A", "sol": 0, "python_code": "N = 4\ndef isDiagonalMatrix ( mat ) :\n    for i in range ( 0 , N ) :\n        for j in range ( 0 , N ) :\n            if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) :\n                return False\n    return True\nmat = [ [ 4 , 0 , 0 , 0 ] , [ 0 , 7 , 0 , 0 ] , [ 0 , 0 , 5 , 0 ] , [ 0 , 0 , 0 , 1 ] ]\nif ( isDiagonalMatrix ( mat ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "N = 4 NEW_LINE def isDiagonalMatrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 4 , 0 , 0 , 0 ] , [ 0 , 7 , 0 , 0 ] , [ 0 , 0 , 5 , 0 ] , [ 0 , 0 , 0 , 1 ] ] NEW_LINE if ( isDiagonalMatrix ( mat ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "aizu_p01701_A", "sol": 0, "python_code": "from fractions import Fraction\nwhile True :\n    s = input ( )\n    if s == \"#\" : break\n    s = \"\".join ( [ c for c in s if c == 'n' or c == 'w' ] )\n    x = 0 if s [ - 1 ] == 'n' else 90\n    for i in range ( len ( s ) - 1 ) :\n        if s [ - 2 - i ] == 'n' :\n            x -= Fraction ( 45 , 1 << i )\n        else :\n            x += Fraction ( 45 , 1 << i )\n    print ( x )\n", "python_code_tokenized": "from fractions import Fraction NEW_LINE while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == \" # \" : break NEW_LINE s = \" \" . join ( [ c for c in s if c == ' n ' or c == ' w ' ] ) NEW_LINE x = 0 if s [ - 1 ] == ' n ' else 90 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ - 2 - i ] == ' n ' : NEW_LINE INDENT x -= Fraction ( 45 , 1 << i ) NEW_LINE DEDENT else : NEW_LINE INDENT x += Fraction ( 45 , 1 << i ) NEW_LINE DEDENT DEDENT print ( x ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2909_A", "sol": 0, "python_code": "def Divison ( a , n ) :\n    maxi = - 10 ** 9\n    mini = 10 ** 9\n    for i in a :\n        maxi = max ( i , maxi )\n        mini = min ( i , mini )\n    return maxi // mini\na = [ 3 , 7 , 9 , 3 , 11 ]\nn = len ( a )\nprint ( Divison ( a , n ) )\n", "python_code_tokenized": "def Divison ( a , n ) : NEW_LINE INDENT maxi = - 10 ** 9 NEW_LINE mini = 10 ** 9 NEW_LINE for i in a : NEW_LINE INDENT maxi = max ( i , maxi ) NEW_LINE mini = min ( i , mini ) NEW_LINE DEDENT return maxi // mini NEW_LINE DEDENT a = [ 3 , 7 , 9 , 3 , 11 ] NEW_LINE n = len ( a ) NEW_LINE print ( Divison ( a , n ) ) NEW_LINE"}
{"id": "aizu_p00070_A", "sol": 0, "python_code": "s_max = [ 0 ]\nfor i in range ( 1 , 11 ) :\n    s = 0\n    for j in range ( i ) :\n        s += ( 10 - j - 1 ) * ( i - j )\n    s_max.append ( s )\ndef check ( u , r , s , m ) :\n    if r == 0 :\n        return s == 0\n    n = 0\n    for i in range ( 10 ) :\n        n *= 2\n        if u [ i ] :\n            n += 1\n    if ( n , r , s ) in m :\n        return m [ ( n , r , s ) ]\n    if s < 0 or s > s_max [ r ] :\n        return 0\n    ans = 0\n    for i in range ( 10 ) :\n        if not u [ i ] :\n            u [ i ] = True\n            ans += check ( u , r - 1 , s - i * r , m )\n            u [ i ] = False\n    m [ ( n , r , s ) ] = ans\n    return m [ ( n , r , s ) ]\nmemo = { }\nwhile True :\n    try :\n        n , s = map ( int , input ( ).split ( ) )\n        used = [ False for i in range ( 10 ) ]\n        ans = check ( used , n , s , memo )\n        print ( ans )\n    except :\n        break\n", "python_code_tokenized": "s_max = [ 0 ] NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT s = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT s += ( 10 - j - 1 ) * ( i - j ) NEW_LINE DEDENT s_max . append ( s ) NEW_LINE DEDENT def check ( u , r , s , m ) : NEW_LINE INDENT if r == 0 : NEW_LINE INDENT return s == 0 NEW_LINE DEDENT n = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT n *= 2 NEW_LINE if u [ i ] : NEW_LINE INDENT n += 1 NEW_LINE DEDENT DEDENT if ( n , r , s ) in m : NEW_LINE INDENT return m [ ( n , r , s ) ] NEW_LINE DEDENT if s < 0 or s > s_max [ r ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if not u [ i ] : NEW_LINE INDENT u [ i ] = True NEW_LINE ans += check ( u , r - 1 , s - i * r , m ) NEW_LINE u [ i ] = False NEW_LINE DEDENT DEDENT m [ ( n , r , s ) ] = ans NEW_LINE return m [ ( n , r , s ) ] NEW_LINE DEDENT memo = { } NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT n , s = map ( int , input ( ) . split ( ) ) NEW_LINE used = [ False for i in range ( 10 ) ] NEW_LINE ans = check ( used , n , s , memo ) NEW_LINE print ( ans ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1385_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor test in range ( t ) :\n    n = int ( input ( ) )\n    numbers1 = list ( map ( int , input ( ).split ( ) ) )\n    numbers2 = [ numbers1 [ 0 ] ]\n    for x in numbers1 :\n        if x not in numbers2 :\n            numbers2.append ( x )\n    for i in numbers2 :\n        print ( i , end = ' ' )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for test in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE numbers1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE numbers2 = [ numbers1 [ 0 ] ] NEW_LINE for x in numbers1 : NEW_LINE INDENT if x not in numbers2 : NEW_LINE INDENT numbers2 . append ( x ) NEW_LINE DEDENT DEDENT for i in numbers2 : NEW_LINE INDENT print ( i , end = ' \u2581 ' ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC149_B", "sol": 0, "python_code": "number = input ( )\na , b , k = [ int ( ele ) for ele in number.split ( ' ' ) ]\nres = a - k\nif res < 0 :\n    a = 0\n    b = b + res\n    b = 0 if b < 0 else b\nelse :\n    a = res\nprint ( a , b )\n", "python_code_tokenized": "number = input ( ) NEW_LINE a , b , k = [ int ( ele ) for ele in number . split ( ' \u2581 ' ) ] NEW_LINE res = a - k NEW_LINE if res < 0 : NEW_LINE INDENT a = 0 NEW_LINE b = b + res NEW_LINE b = 0 if b < 0 else b NEW_LINE DEDENT else : NEW_LINE INDENT a = res NEW_LINE DEDENT print ( a , b ) NEW_LINE"}
{"id": "codeforces_622_B", "sol": 0, "python_code": "h , m = map ( int , input ( ).split ( \":\" ) )\na = int ( input ( ) )\nm += a\nh += m // 60\nm %= 60\nh %= 24\nprint ( format ( h , \"02\" ) , \":\" , format ( m , \"02\" ) , sep = \"\" )\n", "python_code_tokenized": "h , m = map ( int , input ( ) . split ( \" : \" ) ) NEW_LINE a = int ( input ( ) ) NEW_LINE m += a NEW_LINE h += m // 60 NEW_LINE m %= 60 NEW_LINE h %= 24 NEW_LINE print ( format ( h , \"02\" ) , \" : \" , format ( m , \"02\" ) , sep = \" \" ) NEW_LINE"}
{"id": "aizu_p02204_A", "sol": 0, "python_code": "m , n = map ( int , input ( ).split ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nif m == 2 :\n    ans = n\n    for i in range ( 2 ) :\n        t = 0\n        for j in range ( n ) :\n            idx = ( i + j ) % 2 + 1\n            if idx != a [ j ] :\n                t += 1\n        ans = min ( ans , t )\nelse :\n    ans = 0\n    prev = a [ 0 ]\n    for i in range ( 1 , n ) :\n        if prev == a [ i ] :\n            ans += 1\n            a [ i ] = - 1\n        prev = a [ i ]\nprint ( ans )\n", "python_code_tokenized": "m , n = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if m == 2 : NEW_LINE INDENT ans = n NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT t = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT idx = ( i + j ) % 2 + 1 NEW_LINE if idx != a [ j ] : NEW_LINE INDENT t += 1 NEW_LINE DEDENT DEDENT ans = min ( ans , t ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE prev = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if prev == a [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE a [ i ] = - 1 NEW_LINE DEDENT prev = a [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_877_B", "sol": 0, "python_code": "inp = str ( input ( ) )\na = [ 0 ] * 3\nfor i in inp :\n    if i == 'a' :\n        a [ 2 ] = max ( a ) + 1\n        a [ 0 ] += 1\n    else :\n        a [ 1 ] = max ( a [ : 2 ] ) + 1\nprint ( max ( a ) )\n", "python_code_tokenized": "inp = str ( input ( ) ) NEW_LINE a = [ 0 ] * 3 NEW_LINE for i in inp : NEW_LINE INDENT if i == ' a ' : NEW_LINE INDENT a [ 2 ] = max ( a ) + 1 NEW_LINE a [ 0 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ 1 ] = max ( a [ : 2 ] ) + 1 NEW_LINE DEDENT DEDENT print ( max ( a ) ) NEW_LINE"}
{"id": "geeksforgeeks_133_A", "sol": 0, "python_code": "mod = 10 ** 9 + 7\ndef power ( a , m1 ) :\n    if ( m1 == 0 ) :\n        return 1\n    elif ( m1 == 1 ) :\n        return a\n    elif ( m1 == 2 ) :\n        return ( a * a ) % mod\n    elif ( m1 & 1 ) :\n        return ( a * power ( power ( a , m1 // 2 ) , 2 ) ) % mod\n    else :\n        return power ( power ( a , m1 // 2 ) , 2 ) % mod\ndef factorial ( x ) :\n    ans = 1\n    for i in range ( 1 , x + 1 ) :\n        ans = ( ans * i ) % mod\n    return ans\ndef inverse ( x ) :\n    return power ( x , mod - 2 )\ndef binomial ( n , r ) :\n    if ( r > n ) :\n        return 0\n    ans = factorial ( n )\n    ans = ( ans * inverse ( factorial ( r ) ) ) % mod\n    ans = ( ans * inverse ( factorial ( n - r ) ) ) % mod\n    return ans\ndef number_of_sets ( n , a , b ) :\n    ans = power ( 2 , n )\n    ans = ans - binomial ( n , a )\n    if ( ans < 0 ) :\n        ans += mod\n    ans = ans - binomial ( n , b )\n    ans -= 1\n    if ( ans < 0 ) :\n        ans += mod\n    return ans\nif __name__ == '__main__' :\n    N = 4\n    A = 1\n    B = 3\n    print ( number_of_sets ( N , A , B ) )\n", "python_code_tokenized": "mod = 10 ** 9 + 7 NEW_LINE def power ( a , m1 ) : NEW_LINE INDENT if ( m1 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( m1 == 1 ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( m1 == 2 ) : NEW_LINE INDENT return ( a * a ) % mod NEW_LINE DEDENT elif ( m1 & 1 ) : NEW_LINE INDENT return ( a * power ( power ( a , m1 // 2 ) , 2 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return power ( power ( a , m1 // 2 ) , 2 ) % mod NEW_LINE DEDENT DEDENT def factorial ( x ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT ans = ( ans * i ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT def inverse ( x ) : NEW_LINE INDENT return power ( x , mod - 2 ) NEW_LINE DEDENT def binomial ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = factorial ( n ) NEW_LINE ans = ( ans * inverse ( factorial ( r ) ) ) % mod NEW_LINE ans = ( ans * inverse ( factorial ( n - r ) ) ) % mod NEW_LINE return ans NEW_LINE DEDENT def number_of_sets ( n , a , b ) : NEW_LINE INDENT ans = power ( 2 , n ) NEW_LINE ans = ans - binomial ( n , a ) NEW_LINE if ( ans < 0 ) : NEW_LINE INDENT ans += mod NEW_LINE DEDENT ans = ans - binomial ( n , b ) NEW_LINE ans -= 1 NEW_LINE if ( ans < 0 ) : NEW_LINE INDENT ans += mod NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE A = 1 NEW_LINE B = 3 NEW_LINE print ( number_of_sets ( N , A , B ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5185_A", "sol": 0, "python_code": "def findCandidate ( A ) :\n    maj_index = 0\n    count = 1\n    for i in range ( len ( A ) ) :\n        if A [ maj_index ] == A [ i ] :\n            count += 1\n        else :\n            count -= 1\n        if count == 0 :\n            maj_index = i\n            count = 1\n    return A [ maj_index ]\ndef isMajority ( A , cand ) :\n    count = 0\n    for i in range ( len ( A ) ) :\n        if A [ i ] == cand :\n            count += 1\n    if count > len ( A ) / 2 :\n        return True\n    else :\n        return False\ndef printMajority ( A ) :\n    cand = findCandidate ( A )\n    if isMajority ( A , cand ) == True :\n        print ( cand )\n    else :\n        print ( \"No Majority Element\" )\nA = [ 1 , 3 , 3 , 1 , 2 ]\nprintMajority ( A )\n", "python_code_tokenized": "def findCandidate ( A ) : NEW_LINE INDENT maj_index = 0 NEW_LINE count = 1 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if A [ maj_index ] == A [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if count == 0 : NEW_LINE INDENT maj_index = i NEW_LINE count = 1 NEW_LINE DEDENT DEDENT return A [ maj_index ] NEW_LINE DEDENT def isMajority ( A , cand ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if A [ i ] == cand : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count > len ( A ) / 2 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def printMajority ( A ) : NEW_LINE INDENT cand = findCandidate ( A ) NEW_LINE if isMajority ( A , cand ) == True : NEW_LINE INDENT print ( cand ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 Majority \u2581 Element \" ) NEW_LINE DEDENT DEDENT A = [ 1 , 3 , 3 , 1 , 2 ] NEW_LINE printMajority ( A ) NEW_LINE"}
{"id": "geeksforgeeks_4710_A", "sol": 0, "python_code": "def findsolution ( n , x , y ) :\n    if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x or y < n ) :\n        print ( \"No solution\" ) ;\n        return ;\n    print ( y - n + 1 ) ;\n    while ( n > 1 ) :\n        print ( 1 ) ;\n        n -= 1 ;\nn = 5 ;\nx = 15 ;\ny = 15 ;\nfindsolution ( n , x , y ) ;\n", "python_code_tokenized": "def findsolution ( n , x , y ) : NEW_LINE INDENT if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x or y < n ) : NEW_LINE INDENT print ( \" No \u2581 solution \" ) ; NEW_LINE return ; NEW_LINE DEDENT print ( y - n + 1 ) ; NEW_LINE while ( n > 1 ) : NEW_LINE INDENT print ( 1 ) ; NEW_LINE n -= 1 ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE x = 15 ; NEW_LINE y = 15 ; NEW_LINE findsolution ( n , x , y ) ; NEW_LINE"}
{"id": "codeforces_347_A", "sol": 0, "python_code": "import math as mt\nfrom collections import defaultdict , deque\nfrom re import L\nimport sys\nfrom bisect import bisect_right as b_r\nfrom bisect import bisect_left as b_l\nfrom os import path\nfrom heapq import *\nmod = 1000000007\nINT_MAX = sys.maxsize - 1\nINT_MIN = - sys.maxsize\ndef myyy__answer ( ) :\n    n = int ( input ( ) )\n    a = list ( map ( int , input ( ).split ( ) ) )\n    a.sort ( )\n    a [ 0 ] , a [ - 1 ] = a [ - 1 ] , a [ 0 ]\n    print ( * a )\nif __name__ == \"__main__\" :\n    myyy__answer ( )\n", "python_code_tokenized": "import math as mt NEW_LINE from collections import defaultdict , deque NEW_LINE from re import L NEW_LINE import sys NEW_LINE from bisect import bisect_right as b_r NEW_LINE from bisect import bisect_left as b_l NEW_LINE from os import path NEW_LINE from heapq import * NEW_LINE mod = 1000000007 NEW_LINE INT_MAX = sys . maxsize - 1 NEW_LINE INT_MIN = - sys . maxsize NEW_LINE def myyy__answer ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE a [ 0 ] , a [ - 1 ] = a [ - 1 ] , a [ 0 ] NEW_LINE print ( * a ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT myyy__answer ( ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC177_A", "sol": 0, "python_code": "D , T , S = map ( int , input ( ).split ( ) )\nif D <= T * S :\n    print ( 'Yes' )\nelse :\n    print ( 'No' )\n", "python_code_tokenized": "D , T , S = map ( int , input ( ) . split ( ) ) NEW_LINE if D <= T * S : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT"}
{"id": "aizu_p00103_A", "sol": 0, "python_code": "N = int ( input ( ) )\nbase = [ 0 ] * 3\nout = 0\npoint = 0\ninning = 0\nwhile True :\n    event = input ( )\n    if event == \"HIT\" :\n        if base [ 2 ] == 1 :\n            point += 1\n        base [ 2 ] = base [ 1 ]\n        base [ 1 ] = base [ 0 ]\n        base [ 0 ] = 1\n    elif event == \"HOMERUN\" :\n        point += sum ( base ) + 1\n        base = [ 0 ] * 3\n    elif event == \"OUT\" :\n        out += 1\n        if out == 3 :\n            print ( point )\n            inning += 1\n            if inning == N :\n                break\n            base = [ 0 ] * 3\n            out = 0\n            point = 0\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE base = [ 0 ] * 3 NEW_LINE out = 0 NEW_LINE point = 0 NEW_LINE inning = 0 NEW_LINE while True : NEW_LINE INDENT event = input ( ) NEW_LINE if event == \" HIT \" : NEW_LINE INDENT if base [ 2 ] == 1 : NEW_LINE INDENT point += 1 NEW_LINE DEDENT base [ 2 ] = base [ 1 ] NEW_LINE base [ 1 ] = base [ 0 ] NEW_LINE base [ 0 ] = 1 NEW_LINE DEDENT elif event == \" HOMERUN \" : NEW_LINE INDENT point += sum ( base ) + 1 NEW_LINE base = [ 0 ] * 3 NEW_LINE DEDENT elif event == \" OUT \" : NEW_LINE INDENT out += 1 NEW_LINE if out == 3 : NEW_LINE INDENT print ( point ) NEW_LINE inning += 1 NEW_LINE if inning == N : NEW_LINE INDENT break NEW_LINE DEDENT base = [ 0 ] * 3 NEW_LINE out = 0 NEW_LINE point = 0 NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "atcoder_ABC080_A", "sol": 0, "python_code": "n , a , b = map ( int , input ( ).split ( ) )\nprint ( min ( n * a , b ) )\n", "python_code_tokenized": "n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( n * a , b ) ) NEW_LINE"}
{"id": "geeksforgeeks_2127_A", "sol": 0, "python_code": "def countRec ( n , sum ) :\n    if ( n == 0 ) :\n        return ( sum == 0 )\n    if ( sum == 0 ) :\n        return 1\n    ans = 0\n    for i in range ( 0 , 10 ) :\n        if ( sum - i >= 0 ) :\n            ans = ans + countRec ( n - 1 , sum - i )\n    return ans\ndef finalCount ( n , sum ) :\n    ans = 0\n    for i in range ( 1 , 10 ) :\n        if ( sum - i >= 0 ) :\n            ans = ans + countRec ( n - 1 , sum - i )\n    return ans\nn = 2\nsum = 5\nprint ( finalCount ( n , sum ) )\n", "python_code_tokenized": "def countRec ( n , sum ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( sum == 0 ) NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans = ans + countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def finalCount ( n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans = ans + countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 2 NEW_LINE sum = 5 NEW_LINE print ( finalCount ( n , sum ) ) NEW_LINE"}
{"id": "geeksforgeeks_2128_A", "sol": 0, "python_code": "lookup = [ [ - 1 for i in range ( 501 ) ] for i in range ( 101 ) ]\ndef countRec ( n , Sum ) :\n    if ( n == 0 ) :\n        return Sum == 0\n    if ( lookup [ n ] [ Sum ] != - 1 ) :\n        return lookup [ n ] [ Sum ]\n    ans = 0\n    for i in range ( 10 ) :\n        if ( Sum - i >= 0 ) :\n            ans += countRec ( n - 1 , Sum - i )\n    lookup [ n ] [ Sum ] = ans\n    return lookup [ n ] [ Sum ]\ndef finalCount ( n , Sum ) :\n    ans = 0\n    for i in range ( 1 , 10 ) :\n        if ( Sum - i >= 0 ) :\n            ans += countRec ( n - 1 , Sum - i )\n    return ans\nn , Sum = 3 , 5\nprint ( finalCount ( n , Sum ) )\n", "python_code_tokenized": "lookup = [ [ - 1 for i in range ( 501 ) ] for i in range ( 101 ) ] NEW_LINE def countRec ( n , Sum ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return Sum == 0 NEW_LINE DEDENT if ( lookup [ n ] [ Sum ] != - 1 ) : NEW_LINE INDENT return lookup [ n ] [ Sum ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( Sum - i >= 0 ) : NEW_LINE INDENT ans += countRec ( n - 1 , Sum - i ) NEW_LINE DEDENT DEDENT lookup [ n ] [ Sum ] = ans NEW_LINE return lookup [ n ] [ Sum ] NEW_LINE DEDENT def finalCount ( n , Sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( Sum - i >= 0 ) : NEW_LINE INDENT ans += countRec ( n - 1 , Sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n , Sum = 3 , 5 NEW_LINE print ( finalCount ( n , Sum ) ) NEW_LINE"}
{"id": "codeforces_485_A", "sol": 0, "python_code": "a , m = list ( map ( int , input ( ).split ( ) ) )\nf = False\nfor i in range ( 1000 ) :\n    p = a % m\n    a += p\n    if p == 0 :\n        f = True\n        break\nif f :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "a , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE f = False NEW_LINE for i in range ( 1000 ) : NEW_LINE INDENT p = a % m NEW_LINE a += p NEW_LINE if p == 0 : NEW_LINE INDENT f = True NEW_LINE break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "projecteuler_p048_A", "sol": 0, "python_code": "def compute ( ) :\n    MOD = 10 ** 10\n    ans = sum ( pow ( i , i , MOD ) for i in range ( 1 , 1001 ) ) % MOD\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT MOD = 10 ** 10 NEW_LINE ans = sum ( pow ( i , i , MOD ) for i in range ( 1 , 1001 ) ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3570_A", "sol": 0, "python_code": "def dfs ( graph , node , dist , vis , c ) :\n    if ( vis [ node ] ) :\n        return ;\n    vis [ node ] = True ;\n    dist [ node ] = c ;\n    for i in range ( len ( graph [ node ] ) ) :\n        if ( not vis [ graph [ node ] [ i ] ] ) :\n            dfs ( graph , graph [ node ] [ i ] , dist , vis , c + 1 ) ;\ndef countOfNodes ( graph , n ) :\n    vis = [ False ] * ( n + 1 ) ;\n    dist = [ 0 ] * ( n + 1 ) ;\n    dfs ( graph , 1 , dist , vis , 0 ) ;\n    even = 0 ; odd = 0 ;\n    for i in range ( 1 , n + 1 ) :\n        if ( dist [ i ] % 2 == 0 ) :\n            even += 1 ;\n        else :\n            odd += 1 ;\n    ans = ( ( even * ( even - 1 ) ) + ( odd * ( odd - 1 ) ) ) // 2 ;\n    return ans ;\nif __name__ == \"__main__\" :\n    n = 5 ;\n    graph = [ [ ] , [ 2 ] , [ 1 , 3 ] , [ 2 ] ] ;\n    ans = countOfNodes ( graph , n ) ;\n    print ( ans ) ;\n", "python_code_tokenized": "def dfs ( graph , node , dist , vis , c ) : NEW_LINE INDENT if ( vis [ node ] ) : NEW_LINE INDENT return ; NEW_LINE DEDENT vis [ node ] = True ; NEW_LINE dist [ node ] = c ; NEW_LINE for i in range ( len ( graph [ node ] ) ) : NEW_LINE INDENT if ( not vis [ graph [ node ] [ i ] ] ) : NEW_LINE INDENT dfs ( graph , graph [ node ] [ i ] , dist , vis , c + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def countOfNodes ( graph , n ) : NEW_LINE INDENT vis = [ False ] * ( n + 1 ) ; NEW_LINE dist = [ 0 ] * ( n + 1 ) ; NEW_LINE dfs ( graph , 1 , dist , vis , 0 ) ; NEW_LINE even = 0 ; odd = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( dist [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT DEDENT ans = ( ( even * ( even - 1 ) ) + ( odd * ( odd - 1 ) ) ) // 2 ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE graph = [ [ ] , [ 2 ] , [ 1 , 3 ] , [ 2 ] ] ; NEW_LINE ans = countOfNodes ( graph , n ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_127_A", "sol": 0, "python_code": "mod = 1000000007\ndp = [ [ [ - 1 for i in range ( 2 ) ] for i in range ( 105 ) ] for i in range ( 1005 ) ]\npowers = [ 0 ] * 1005\npowersModk = [ 0 ] * 1005\ndef calculate ( pos , rem , z , k , n ) :\n    if ( rem == 0 and z ) :\n        if ( pos != n ) :\n            return ( powers [ n - pos - 1 ] * 9 ) % mod\n        else :\n            return 1\n    if ( pos == n ) :\n        return 0\n    if ( dp [ pos ] [ rem ] [ z ] != - 1 ) :\n        return dp [ pos ] [ rem ] [ z ]\n    count = 0\n    for i in range ( 10 ) :\n        if ( i == 0 ) :\n            count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , z , k , n ) ) ) % mod\n        else :\n            count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , 1 , k , n ) ) ) % mod\n    dp [ pos ] [ rem ] [ z ] = count\n    return count\ndef countNumbers ( n , k ) :\n    st = 1\n    for i in range ( n + 1 ) :\n        powers [ i ] = st\n        st *= 10\n        st %= mod\n    st = 1\n    for i in range ( n + 1 ) :\n        powersModk [ i ] = st\n        st *= 10\n        st %= mod\n    return calculate ( 0 , 0 , 0 , k , n )\nif __name__ == '__main__' :\n    N = 2\n    K = 2\n    print ( countNumbers ( N , K ) )\n", "python_code_tokenized": "mod = 1000000007 NEW_LINE dp = [ [ [ - 1 for i in range ( 2 ) ] for i in range ( 105 ) ] for i in range ( 1005 ) ] NEW_LINE powers = [ 0 ] * 1005 NEW_LINE powersModk = [ 0 ] * 1005 NEW_LINE def calculate ( pos , rem , z , k , n ) : NEW_LINE INDENT if ( rem == 0 and z ) : NEW_LINE INDENT if ( pos != n ) : NEW_LINE INDENT return ( powers [ n - pos - 1 ] * 9 ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( pos == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ pos ] [ rem ] [ z ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ rem ] [ z ] NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , z , k , n ) ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , 1 , k , n ) ) ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ rem ] [ z ] = count NEW_LINE return count NEW_LINE DEDENT def countNumbers ( n , k ) : NEW_LINE INDENT st = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT powers [ i ] = st NEW_LINE st *= 10 NEW_LINE st %= mod NEW_LINE DEDENT st = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT powersModk [ i ] = st NEW_LINE st *= 10 NEW_LINE st %= mod NEW_LINE DEDENT return calculate ( 0 , 0 , 0 , k , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2 NEW_LINE K = 2 NEW_LINE print ( countNumbers ( N , K ) ) NEW_LINE DEDENT"}
{"id": "aizu_p01956_A", "sol": 0, "python_code": "n , h , w = map ( int , input ( ).split ( ) )\nx = list ( map ( int , input ( ).split ( ) ) )\nwide_total = n * w\nwide_cover = [ False ] * wide_total\nfor i in range ( n ) :\n    if ( i + 1 ) % 2 == 1 :\n        for j in range ( i * w + x [ i ] , i * w + x [ i ] + w ) :\n            wide_cover [ j ] = True\n    else :\n        for j in range ( i * w - x [ i ] , i * w - x [ i ] + w ) :\n            wide_cover [ j ] = True\ncnt = 0\nfor c in wide_cover :\n    if c == False :\n        cnt += 1\nprint ( cnt * h )\n", "python_code_tokenized": "n , h , w = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE wide_total = n * w NEW_LINE wide_cover = [ False ] * wide_total NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i + 1 ) % 2 == 1 : NEW_LINE INDENT for j in range ( i * w + x [ i ] , i * w + x [ i ] + w ) : NEW_LINE INDENT wide_cover [ j ] = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( i * w - x [ i ] , i * w - x [ i ] + w ) : NEW_LINE INDENT wide_cover [ j ] = True NEW_LINE DEDENT DEDENT DEDENT cnt = 0 NEW_LINE for c in wide_cover : NEW_LINE INDENT if c == False : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt * h ) NEW_LINE"}
{"id": "geeksforgeeks_2325_A", "sol": 0, "python_code": "import math\ndef firstkdigits ( n , k ) :\n    product = n * math.log ( n , 10 ) ;\n    decimal_part = product - math.floor ( product ) ;\n    decimal_part = pow ( 10 , decimal_part ) ;\n    digits = pow ( 10 , k - 1 ) ;\n    return math.floor ( decimal_part * digits ) ;\nn = 1450 ;\nk = 6 ;\nprint ( firstkdigits ( n , k ) ) ;\n", "python_code_tokenized": "import math NEW_LINE def firstkdigits ( n , k ) : NEW_LINE INDENT product = n * math . log ( n , 10 ) ; NEW_LINE decimal_part = product - math . floor ( product ) ; NEW_LINE decimal_part = pow ( 10 , decimal_part ) ; NEW_LINE digits = pow ( 10 , k - 1 ) ; NEW_LINE return math . floor ( decimal_part * digits ) ; NEW_LINE DEDENT n = 1450 ; NEW_LINE k = 6 ; NEW_LINE print ( firstkdigits ( n , k ) ) ; NEW_LINE"}
{"id": "codeforces_744_B", "sol": 0, "python_code": "def rel ( w ) :\n    global ans\n    if w == set ( ) : return\n    print ( str ( len ( w ) ) + '\\n' + ' '.join ( map ( str , w ) ) )\n    res = list ( map ( int , input ( ).split ( ) ) )\n    for i in range ( n ) :\n        if i + 1 not in w :\n            ans [ i ] = min ( ans [ i ] , res [ i ] )\nn = int ( input ( ) )\nans = [ 10 ** 10 ] * n\na = [ ( 1 , n ) ]\nfor i in range ( 10 ) :\n    b = [ n + 1 ]\n    for l , r in a :\n        b += [ l , ( l + r ) // 2 + 1 ]\n    b.sort ( )\n    m = len ( b )\n    w = set ( )\n    for j in range ( 0 , m - 1 , 2 ) :\n        w |= { x for x in range ( b [ j ] , b [ j + 1 ] ) }\n    rel ( w )\n    rel ( w ^ { i for i in range ( 1 , n + 1 ) } )\n    a = [ ( b [ j ] , b [ j + 1 ] - 1 ) for j in range ( m - 1 ) ]\nprint ( '-1\\n' + ' '.join ( map ( str , ans ) ) )\n", "python_code_tokenized": "def rel ( w ) : NEW_LINE INDENT global ans NEW_LINE if w == set ( ) : return NEW_LINE print ( str ( len ( w ) ) + ' \\n ' + ' \u2581 ' . join ( map ( str , w ) ) ) NEW_LINE res = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i + 1 not in w : NEW_LINE INDENT ans [ i ] = min ( ans [ i ] , res [ i ] ) NEW_LINE DEDENT DEDENT DEDENT n = int ( input ( ) ) NEW_LINE ans = [ 10 ** 10 ] * n NEW_LINE a = [ ( 1 , n ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT b = [ n + 1 ] NEW_LINE for l , r in a : NEW_LINE INDENT b += [ l , ( l + r ) // 2 + 1 ] NEW_LINE DEDENT b . sort ( ) NEW_LINE m = len ( b ) NEW_LINE w = set ( ) NEW_LINE for j in range ( 0 , m - 1 , 2 ) : NEW_LINE INDENT w |= { x for x in range ( b [ j ] , b [ j + 1 ] ) } NEW_LINE DEDENT rel ( w ) NEW_LINE rel ( w ^ { i for i in range ( 1 , n + 1 ) } ) NEW_LINE a = [ ( b [ j ] , b [ j + 1 ] - 1 ) for j in range ( m - 1 ) ] NEW_LINE DEDENT print ( ' - 1 \\n ' + ' \u2581 ' . join ( map ( str , ans ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_1044_A", "sol": 0, "python_code": "last = 31\ndef findSubset ( temp , k ) :\n    global last\n    ans = [ ]\n    for i in range ( last , - 1 , - 1 ) :\n        cnt = 0\n        for it in temp :\n            bit = it & ( 1 << i )\n            if ( bit > 0 ) :\n                cnt += 1\n        if ( cnt >= k ) :\n            for it in temp :\n                bit = it & ( 1 << i )\n                if ( bit > 0 ) :\n                    ans.append ( it )\n            last = i - 1\n            return ans\n    return ans\ndef findMaxiumAnd ( a , n , k ) :\n    global last\n    temp1 , temp2 , = [ ] , [ ]\n    for i in range ( n ) :\n        temp2.append ( a [ i ] )\n    while len ( temp2 ) >= k :\n        temp1 = temp2\n        temp2 = findSubset ( temp2 , k )\n    ans = temp1 [ 0 ]\n    for i in range ( k ) :\n        ans = ans & temp1 [ i ]\n    return ans\na = [ 255 , 127 , 31 , 5 , 24 , 37 , 15 ]\nn = len ( a )\nk = 4\nprint ( findMaxiumAnd ( a , n , k ) )\n", "python_code_tokenized": "last = 31 NEW_LINE def findSubset ( temp , k ) : NEW_LINE INDENT global last NEW_LINE ans = [ ] NEW_LINE for i in range ( last , - 1 , - 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for it in temp : NEW_LINE INDENT bit = it & ( 1 << i ) NEW_LINE if ( bit > 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= k ) : NEW_LINE INDENT for it in temp : NEW_LINE INDENT bit = it & ( 1 << i ) NEW_LINE if ( bit > 0 ) : NEW_LINE INDENT ans . append ( it ) NEW_LINE DEDENT DEDENT last = i - 1 NEW_LINE return ans NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def findMaxiumAnd ( a , n , k ) : NEW_LINE INDENT global last NEW_LINE temp1 , temp2 , = [ ] , [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp2 . append ( a [ i ] ) NEW_LINE DEDENT while len ( temp2 ) >= k : NEW_LINE INDENT temp1 = temp2 NEW_LINE temp2 = findSubset ( temp2 , k ) NEW_LINE DEDENT ans = temp1 [ 0 ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT ans = ans & temp1 [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 255 , 127 , 31 , 5 , 24 , 37 , 15 ] NEW_LINE n = len ( a ) NEW_LINE k = 4 NEW_LINE print ( findMaxiumAnd ( a , n , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_330_A", "sol": 0, "python_code": "def cntSubsets ( arr , n ) :\n    max = pow ( 2 , n )\n    result = 0\n    for i in range ( max ) :\n        counter = i\n        if ( counter & ( counter >> 1 ) ) :\n            continue\n        result += 1\n    return result\narr = [ 3 , 5 , 7 ]\nn = len ( arr )\nprint ( cntSubsets ( arr , n ) )\n", "python_code_tokenized": "def cntSubsets ( arr , n ) : NEW_LINE INDENT max = pow ( 2 , n ) NEW_LINE result = 0 NEW_LINE for i in range ( max ) : NEW_LINE INDENT counter = i NEW_LINE if ( counter & ( counter >> 1 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT result += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 3 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( cntSubsets ( arr , n ) ) NEW_LINE"}
{"id": "codeforces_172_B", "sol": 0, "python_code": "a , b , m , r = map ( int , input ( ).split ( ) )\nl , s = [ ] , set ( )\nwhile r not in s :\n    s.add ( r )\n    l.append ( r )\n    r = ( a * r + b ) % m\nprint ( len ( l ) - l.index ( r ) )\n", "python_code_tokenized": "a , b , m , r = map ( int , input ( ) . split ( ) ) NEW_LINE l , s = [ ] , set ( ) NEW_LINE while r not in s : NEW_LINE INDENT s . add ( r ) NEW_LINE l . append ( r ) NEW_LINE r = ( a * r + b ) % m NEW_LINE DEDENT print ( len ( l ) - l . index ( r ) ) NEW_LINE"}
{"id": "codeforces_757_A", "sol": 0, "python_code": "import sys\ninput = sys.stdin.buffer.readline\ndef process ( S ) :\n    lower_counts = [ 0 for i in range ( 26 ) ]\n    upper_counts = 0\n    for c in S :\n        if 'a' <= c <= 'z' :\n            lower_counts [ ord ( c ) - ord ( 'a' ) ] += 1\n        elif c == 'B' :\n            upper_counts += 1\n    target = [ 0 for i in range ( 26 ) ]\n    target1 = 0\n    for c in 'Bulbasaur' :\n        if 'a' <= c <= 'z' :\n            target [ ord ( c ) - ord ( 'a' ) ] += 1\n        else :\n            target1 += 1\n    answer = float ( 'inf' )\n    for i in range ( 26 ) :\n        if target [ i ] > 0 :\n            answer = min ( answer , lower_counts [ i ] // target [ i ] )\n    answer = min ( answer , upper_counts // target1 )\n    print ( answer )\n    return\nS = input ( ).decode ( ).strip ( )\nprocess ( S )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . buffer . readline NEW_LINE def process ( S ) : NEW_LINE INDENT lower_counts = [ 0 for i in range ( 26 ) ] NEW_LINE upper_counts = 0 NEW_LINE for c in S : NEW_LINE INDENT if ' a ' <= c <= ' z ' : NEW_LINE INDENT lower_counts [ ord ( c ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT elif c == ' B ' : NEW_LINE INDENT upper_counts += 1 NEW_LINE DEDENT DEDENT target = [ 0 for i in range ( 26 ) ] NEW_LINE target1 = 0 NEW_LINE for c in ' Bulbasaur ' : NEW_LINE INDENT if ' a ' <= c <= ' z ' : NEW_LINE INDENT target [ ord ( c ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT target1 += 1 NEW_LINE DEDENT DEDENT answer = float ( ' inf ' ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if target [ i ] > 0 : NEW_LINE INDENT answer = min ( answer , lower_counts [ i ] // target [ i ] ) NEW_LINE DEDENT DEDENT answer = min ( answer , upper_counts // target1 ) NEW_LINE print ( answer ) NEW_LINE return NEW_LINE DEDENT S = input ( ) . decode ( ) . strip ( ) NEW_LINE process ( S ) NEW_LINE"}
{"id": "geeksforgeeks_790_A", "sol": 0, "python_code": "def getSum ( n , d ) :\n    sum = 0 ;\n    for i in range ( n + 1 ) :\n        if ( i % 10 == d ) :\n            sum += i\n    return sum\nif __name__ == \"__main__\" :\n    n , d = 30 , 3\n    print ( getSum ( n , d ) )\n", "python_code_tokenized": "def getSum ( n , d ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i % 10 == d ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , d = 30 , 3 NEW_LINE print ( getSum ( n , d ) ) NEW_LINE DEDENT"}
{"id": "codeforces_7_B", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\ns = [ input ( ) for i in range ( n ) ]\na = [ 0 ] * m\nnum = 1\ndef alloc ( x ) :\n    global num\n    x = int ( x.split ( ) [ 1 ] )\n    for i in range ( m - x + 1 ) :\n        if a [ i : i + x ] == [ 0 ] * x :\n            a [ i : i + x ] = [ num ] * x\n            print ( num )\n            num += 1\n            return\n    print ( 'NULL' )\ndef erase ( x ) :\n    x = int ( x.split ( ) [ 1 ] )\n    if x not in a or x < 1 :\n        print ( 'ILLEGAL_ERASE_ARGUMENT' )\n    for i , j in enumerate ( a ) :\n        if j == x :\n            a [ i ] = 0\ndef defragment ( x ) :\n    global a\n    a = [ i for i in a if i != 0 ]\n    a += [ 0 ] * ( m - len ( a ) )\nf = { 'alloc' : alloc , 'erase' : erase , 'defragment' : defragment }\nfor i in s :\n    f [ i.split ( ) [ 0 ] ] ( i )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ input ( ) for i in range ( n ) ] NEW_LINE a = [ 0 ] * m NEW_LINE num = 1 NEW_LINE def alloc ( x ) : NEW_LINE INDENT global num NEW_LINE x = int ( x . split ( ) [ 1 ] ) NEW_LINE for i in range ( m - x + 1 ) : NEW_LINE INDENT if a [ i : i + x ] == [ 0 ] * x : NEW_LINE INDENT a [ i : i + x ] = [ num ] * x NEW_LINE print ( num ) NEW_LINE num += 1 NEW_LINE return NEW_LINE DEDENT DEDENT print ( ' NULL ' ) NEW_LINE DEDENT def erase ( x ) : NEW_LINE INDENT x = int ( x . split ( ) [ 1 ] ) NEW_LINE if x not in a or x < 1 : NEW_LINE INDENT print ( ' ILLEGAL _ ERASE _ ARGUMENT ' ) NEW_LINE DEDENT for i , j in enumerate ( a ) : NEW_LINE INDENT if j == x : NEW_LINE INDENT a [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT def defragment ( x ) : NEW_LINE INDENT global a NEW_LINE a = [ i for i in a if i != 0 ] NEW_LINE a += [ 0 ] * ( m - len ( a ) ) NEW_LINE DEDENT f = { ' alloc ' : alloc , ' erase ' : erase , ' defragment ' : defragment } NEW_LINE for i in s : NEW_LINE INDENT f [ i . split ( ) [ 0 ] ] ( i ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC048_D", "sol": 0, "python_code": "def main ( ) :\n    s = input ( )\n    print ( [ \"First\" , \"Second\" ] [ ( ( s [ 0 ] == s [ - 1 ] ) ^ ( len ( s ) % 2 == 0 ) ) ] )\nmain ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE print ( [ \" First \" , \" Second \" ] [ ( ( s [ 0 ] == s [ - 1 ] ) ^ ( len ( s ) % 2 == 0 ) ) ] ) NEW_LINE DEDENT main ( ) NEW_LINE"}
{"id": "codeforces_425_A", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nif n == 1 :\n    print ( a [ 0 ] )\nelse :\n    res = - 1e9\n    for i in range ( n ) :\n        for j in range ( n ) :\n            b = a [ i : j + 1 ]\n            if not b :\n                continue\n            if i > 0 and j < n - 1 :\n                c = a [ : i ] + a [ j + 1 : ]\n            elif i == 0 and j < n - 1 :\n                c = a [ j + 1 : ]\n            elif i > 0 and j == n - 1 :\n                c = a [ : i ]\n            b.sort ( )\n            c.sort ( reverse = True )\n            b1 = 0\n            c1 = 0\n            l = 0\n            while l < k and b1 < len ( b ) and c1 < len ( c ) :\n                if b [ b1 ] < c [ c1 ] :\n                    b [ b1 ] , c [ c1 ] = c [ c1 ] , b [ b1 ]\n                    b1 += 1\n                    c1 += 1\n                    l += 1\n                else :\n                    break\n            res = max ( res , sum ( b ) )\n    print ( max ( res , sum ( a ) ) )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT res = - 1e9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT b = a [ i : j + 1 ] NEW_LINE if not b : NEW_LINE INDENT continue NEW_LINE DEDENT if i > 0 and j < n - 1 : NEW_LINE INDENT c = a [ : i ] + a [ j + 1 : ] NEW_LINE DEDENT elif i == 0 and j < n - 1 : NEW_LINE INDENT c = a [ j + 1 : ] NEW_LINE DEDENT elif i > 0 and j == n - 1 : NEW_LINE INDENT c = a [ : i ] NEW_LINE DEDENT b . sort ( ) NEW_LINE c . sort ( reverse = True ) NEW_LINE b1 = 0 NEW_LINE c1 = 0 NEW_LINE l = 0 NEW_LINE while l < k and b1 < len ( b ) and c1 < len ( c ) : NEW_LINE INDENT if b [ b1 ] < c [ c1 ] : NEW_LINE INDENT b [ b1 ] , c [ c1 ] = c [ c1 ] , b [ b1 ] NEW_LINE b1 += 1 NEW_LINE c1 += 1 NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res = max ( res , sum ( b ) ) NEW_LINE DEDENT DEDENT print ( max ( res , sum ( a ) ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1144_B", "sol": 0, "python_code": "n = int ( input ( ) )\nnum = list ( map ( int , input ( ).split ( ) ) )\nnum.sort ( reverse = True )\nevenlist , oddlist = [ ] , [ ]\nfor i in range ( n ) :\n    if ( num [ i ] % 2 == 0 ) :\n        evenlist.append ( num [ i ] )\n    else :\n        oddlist.append ( num [ i ] )\nans = sum ( num )\ne = len ( evenlist )\no = len ( oddlist )\nx = min ( e , o )\nfor i in range ( x ) :\n    ans = ans - evenlist [ i ]\n    ans = ans - oddlist [ i ]\nif ( e > o ) :\n    ans = ans - evenlist [ x ]\nif ( o > e ) :\n    ans = ans - oddlist [ x ]\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE num = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE num . sort ( reverse = True ) NEW_LINE evenlist , oddlist = [ ] , [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( num [ i ] % 2 == 0 ) : NEW_LINE INDENT evenlist . append ( num [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddlist . append ( num [ i ] ) NEW_LINE DEDENT DEDENT ans = sum ( num ) NEW_LINE e = len ( evenlist ) NEW_LINE o = len ( oddlist ) NEW_LINE x = min ( e , o ) NEW_LINE for i in range ( x ) : NEW_LINE INDENT ans = ans - evenlist [ i ] NEW_LINE ans = ans - oddlist [ i ] NEW_LINE DEDENT if ( e > o ) : NEW_LINE INDENT ans = ans - evenlist [ x ] NEW_LINE DEDENT if ( o > e ) : NEW_LINE INDENT ans = ans - oddlist [ x ] NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_3654_A", "sol": 0, "python_code": "def mirrorImage ( a , b , c , x1 , y1 ) :\n    temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b )\n    x = temp * a + x1\n    y = temp * b + y1\n    return ( x , y )\na = - 1.0\nb = 1.0\nc = 0.0\nx1 = 1.0\ny1 = 0.0\nx , y = mirrorImage ( a , b , c , x1 , y1 ) ;\nprint ( \"Image of point (\" + str ( x1 ) + \", \" + str ( y1 ) + \") \" )\nprint ( \"by mirror (\" + str ( a ) + \")x + (\" + str ( b ) + \")y + (\" + str ( c ) + \") = 0, is :\" )\nprint ( \"(\" + str ( x ) + \", \" + str ( y ) + \")\" )\n", "python_code_tokenized": "def mirrorImage ( a , b , c , x1 , y1 ) : NEW_LINE INDENT temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) NEW_LINE x = temp * a + x1 NEW_LINE y = temp * b + y1 NEW_LINE return ( x , y ) NEW_LINE DEDENT a = - 1.0 NEW_LINE b = 1.0 NEW_LINE c = 0.0 NEW_LINE x1 = 1.0 NEW_LINE y1 = 0.0 NEW_LINE x , y = mirrorImage ( a , b , c , x1 , y1 ) ; NEW_LINE print ( \" Image \u2581 of \u2581 point \u2581 ( \" + str ( x1 ) + \" , \u2581 \" + str ( y1 ) + \" ) \u2581 \" ) NEW_LINE print ( \" by \u2581 mirror \u2581 ( \" + str ( a ) + \" ) x \u2581 + \u2581 ( \" + str ( b ) + \" ) y \u2581 + \u2581 ( \" + str ( c ) + \" ) \u2581 = \u2581 0 , \u2581 is \u2581 : \" ) NEW_LINE print ( \" ( \" + str ( x ) + \" , \u2581 \" + str ( y ) + \" ) \" ) NEW_LINE"}
{"id": "geeksforgeeks_895_A", "sol": 0, "python_code": "def countDivisors ( n ) :\n    x , ans = 0 , 1\n    while ( n % 2 == 0 ) :\n        x += 1\n        n = n / 2\n    ans = ans * ( x + 1 )\n    for i in range ( 3 , int ( n ** 1 / 2 ) + 1 , 2 ) :\n        x = 0\n        while ( n % i == 0 ) :\n            x += 1\n            n = n / i\n        ans = ans * ( x + 1 )\n    if ( n > 2 ) :\n        ans = ans * 2\n    return ans\ndef getTotalCount ( n , k ) :\n    k_count = countDivisors ( k )\n    count = 0\n    for i in range ( 1 , n ) :\n        if ( k_count == countDivisors ( i ) ) :\n            count += 1\n    if ( k < n ) :\n        count = count - 1\n    return count\nif __name__ == '__main__' :\n    n , k = 500 , 6\n    print ( getTotalCount ( n , k ) )\n", "python_code_tokenized": "def countDivisors ( n ) : NEW_LINE INDENT x , ans = 0 , 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT x += 1 NEW_LINE n = n / 2 NEW_LINE DEDENT ans = ans * ( x + 1 ) NEW_LINE for i in range ( 3 , int ( n ** 1 / 2 ) + 1 , 2 ) : NEW_LINE INDENT x = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT x += 1 NEW_LINE n = n / i NEW_LINE DEDENT ans = ans * ( x + 1 ) NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT ans = ans * 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT def getTotalCount ( n , k ) : NEW_LINE INDENT k_count = countDivisors ( k ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( k_count == countDivisors ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( k < n ) : NEW_LINE INDENT count = count - 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n , k = 500 , 6 NEW_LINE print ( getTotalCount ( n , k ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02432_A", "sol": 0, "python_code": "from collections import deque\nq = int ( input ( ) )\nS = deque ( )\nfor i in range ( q ) :\n    query = list ( map ( int , input ( ).split ( ) ) )\n    if query [ 0 ] == 0 :\n        if query [ 1 ] == 0 :\n            S.appendleft ( query [ 2 ] )\n        elif query [ 1 ] == 1 :\n            S.append ( query [ 2 ] )\n    elif query [ 0 ] == 1 :\n        print ( \"{}\".format ( S [ query [ 1 ] ] ) )\n    elif query [ 0 ] == 2 :\n        if query [ 1 ] == 0 :\n            S.popleft ( )\n        elif query [ 1 ] == 1 :\n            S.pop ( )\n", "python_code_tokenized": "from collections import deque NEW_LINE q = int ( input ( ) ) NEW_LINE S = deque ( ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT query = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if query [ 0 ] == 0 : NEW_LINE INDENT if query [ 1 ] == 0 : NEW_LINE INDENT S . appendleft ( query [ 2 ] ) NEW_LINE DEDENT elif query [ 1 ] == 1 : NEW_LINE INDENT S . append ( query [ 2 ] ) NEW_LINE DEDENT DEDENT elif query [ 0 ] == 1 : NEW_LINE INDENT print ( \" { } \" . format ( S [ query [ 1 ] ] ) ) NEW_LINE DEDENT elif query [ 0 ] == 2 : NEW_LINE INDENT if query [ 1 ] == 0 : NEW_LINE INDENT S . popleft ( ) NEW_LINE DEDENT elif query [ 1 ] == 1 : NEW_LINE INDENT S . pop ( ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "codeforces_26_A", "sol": 0, "python_code": "r = int ( input ( ) )\nk = [ 0 ] * ( r + 1 )\nfor x in range ( 2 , r + 1 ) :\n    if k [ x ] == 0 :\n        for y in range ( 2 * x , r + 1 , x ) :\n            k [ y ] += 1\nprint ( k.count ( 2 ) )\n", "python_code_tokenized": "r = int ( input ( ) ) NEW_LINE k = [ 0 ] * ( r + 1 ) NEW_LINE for x in range ( 2 , r + 1 ) : NEW_LINE INDENT if k [ x ] == 0 : NEW_LINE INDENT for y in range ( 2 * x , r + 1 , x ) : NEW_LINE INDENT k [ y ] += 1 NEW_LINE DEDENT DEDENT DEDENT print ( k . count ( 2 ) ) NEW_LINE"}
{"id": "geeksforgeeks_2999_A", "sol": 0, "python_code": "def printPascal ( n : int ) :\n    arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]\n    for line in range ( 0 , n ) :\n        for i in range ( 0 , line + 1 ) :\n            if ( i is 0 or i is line ) :\n                arr [ line ] [ i ] = 1\n                print ( arr [ line ] [ i ] , end = \"\" )\n            else :\n                arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] )\n                print ( arr [ line ] [ i ] , end = \"\" )\n        print ( \"\\n\" , end = \"\" )\nn = 5\nprintPascal ( n )\n", "python_code_tokenized": "def printPascal ( n : int ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for line in range ( 0 , n ) : NEW_LINE INDENT for i in range ( 0 , line + 1 ) : NEW_LINE INDENT if ( i is 0 or i is line ) : NEW_LINE INDENT arr [ line ] [ i ] = 1 NEW_LINE print ( arr [ line ] [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) NEW_LINE print ( arr [ line ] [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT print ( \" \\n \" , end = \" \" ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE printPascal ( n ) NEW_LINE"}
{"id": "codeforces_863_B", "sol": 0, "python_code": "n = int ( input ( ) )\nw = input ( ).split ( )\nfor i in range ( len ( w ) ) :\n    w [ i ] = int ( w [ i ] )\nw.sort ( )\nans = 1000000000\nfor i in range ( len ( w ) ) :\n    for j in range ( i + 1 , len ( w ) ) :\n        add = False\n        sums = 0\n        for k in range ( len ( w ) ) :\n            if ( k == i or k == j ) :\n                continue\n            if ( not add ) :\n                sums -= w [ k ]\n                add = True\n            else :\n                sums += w [ k ]\n                add = False\n        ans = min ( ans , sums )\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE w = input ( ) . split ( ) NEW_LINE for i in range ( len ( w ) ) : NEW_LINE INDENT w [ i ] = int ( w [ i ] ) NEW_LINE DEDENT w . sort ( ) NEW_LINE ans = 1000000000 NEW_LINE for i in range ( len ( w ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( w ) ) : NEW_LINE INDENT add = False NEW_LINE sums = 0 NEW_LINE for k in range ( len ( w ) ) : NEW_LINE INDENT if ( k == i or k == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( not add ) : NEW_LINE INDENT sums -= w [ k ] NEW_LINE add = True NEW_LINE DEDENT else : NEW_LINE INDENT sums += w [ k ] NEW_LINE add = False NEW_LINE DEDENT DEDENT ans = min ( ans , sums ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_4769_A", "sol": 0, "python_code": "def countAnomalies ( arr , n , k ) :\n    cnt = 0\n    i , Sum = 0 , 0\n    for i in range ( n ) :\n        Sum += arr [ i ]\n    for i in range ( n ) :\n        if ( abs ( arr [ i ] - ( Sum - arr [ i ] ) ) > k ) :\n            cnt += 1\n    return cnt\narr = [ 1 , 3 , 5 ]\nn = len ( arr )\nk = 1\nprint ( countAnomalies ( arr , n , k ) )\n", "python_code_tokenized": "def countAnomalies ( arr , n , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE i , Sum = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( abs ( arr [ i ] - ( Sum - arr [ i ] ) ) > k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 1 NEW_LINE print ( countAnomalies ( arr , n , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_2457_A", "sol": 0, "python_code": "def isPossible ( Sx , Sy , Dx , Dy , x , y ) :\n    if ( abs ( Sx - Dx ) % x == 0 and abs ( Sy - Dy ) % y == 0 and ( abs ( Sx - Dx ) / x ) % 2 == ( abs ( Sy - Dy ) / y ) % 2 ) :\n        return True ;\n    return False ;\nSx = 0 ;\nSy = 0 ;\nDx = 0 ;\nDy = 0 ;\nx = 3 ;\ny = 4 ;\nif ( isPossible ( Sx , Sy , Dx , Dy , x , y ) ) :\n    print ( \"Yes\" ) ;\nelse :\n    print ( \"No\" ) ;\n", "python_code_tokenized": "def isPossible ( Sx , Sy , Dx , Dy , x , y ) : NEW_LINE INDENT if ( abs ( Sx - Dx ) % x == 0 and abs ( Sy - Dy ) % y == 0 and ( abs ( Sx - Dx ) / x ) % 2 == ( abs ( Sy - Dy ) / y ) % 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT Sx = 0 ; NEW_LINE Sy = 0 ; NEW_LINE Dx = 0 ; NEW_LINE Dy = 0 ; NEW_LINE x = 3 ; NEW_LINE y = 4 ; NEW_LINE if ( isPossible ( Sx , Sy , Dx , Dy , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4122_A", "sol": 0, "python_code": "def checkPalin ( word ) :\n    if word.lower ( ) == word.lower ( ) [ : : - 1 ] :\n        return True\ndef countPalin ( str ) :\n    count = 0\n    listOfWords = str.split ( \" \" )\n    for elements in listOfWords :\n        if ( checkPalin ( elements ) ) :\n            count += 1\n    print ( count )\ncountPalin ( \"Madam Arora teaches malayalam\" )\ncountPalin ( \"Nitin speaks malayalam\" )\n", "python_code_tokenized": "def checkPalin ( word ) : NEW_LINE INDENT if word . lower ( ) == word . lower ( ) [ : : - 1 ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def countPalin ( str ) : NEW_LINE INDENT count = 0 NEW_LINE listOfWords = str . split ( \" \u2581 \" ) NEW_LINE for elements in listOfWords : NEW_LINE INDENT if ( checkPalin ( elements ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT countPalin ( \" Madam \u2581 Arora \u2581 teaches \u2581 malayalam \" ) NEW_LINE countPalin ( \" Nitin \u2581 speaks \u2581 malayalam \" ) NEW_LINE"}
{"id": "geeksforgeeks_963_A", "sol": 0, "python_code": "def minimumCost ( cost , n ) :\n    dp1 = 0\n    dp2 = 0\n    for i in range ( n ) :\n        dp0 = cost [ i ] + min ( dp1 , dp2 )\n        dp2 = dp1\n        dp1 = dp0\n    return min ( dp1 , dp2 )\nif __name__ == \"__main__\" :\n    a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ]\n    n = len ( a )\n    print ( minimumCost ( a , n ) )\n", "python_code_tokenized": "def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_447_A", "sol": 0, "python_code": "def trace ( n , m ) :\n    A = [ [ 0 for x in range ( m ) ] for y in range ( n ) ] ;\n    B = [ [ 0 for x in range ( m ) ] for y in range ( n ) ] ;\n    C = [ [ 0 for x in range ( m ) ] for y in range ( n ) ] ;\n    cnt = 1 ;\n    for i in range ( n ) :\n        for j in range ( m ) :\n            A [ i ] [ j ] = cnt ;\n            cnt += 1 ;\n    cnt = 1 ;\n    for i in range ( n ) :\n        for j in range ( m ) :\n            B [ j ] [ i ] = cnt ;\n            cnt += 1 ;\n    for i in range ( n ) :\n        for j in range ( m ) :\n            C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ;\n    sum = 0 ;\n    for i in range ( n ) :\n        for j in range ( m ) :\n            if ( i == j ) :\n                sum += C [ i ] [ j ] ;\n    return sum ;\nN = 3 ;\nM = 3 ;\nprint ( trace ( N , M ) ) ;\n", "python_code_tokenized": "def trace ( n , m ) : NEW_LINE INDENT A = [ [ 0 for x in range ( m ) ] for y in range ( n ) ] ; NEW_LINE B = [ [ 0 for x in range ( m ) ] for y in range ( n ) ] ; NEW_LINE C = [ [ 0 for x in range ( m ) ] for y in range ( n ) ] ; NEW_LINE cnt = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT A [ i ] [ j ] = cnt ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT DEDENT cnt = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT B [ j ] [ i ] = cnt ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; NEW_LINE DEDENT DEDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT sum += C [ i ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT return sum ; NEW_LINE DEDENT N = 3 ; NEW_LINE M = 3 ; NEW_LINE print ( trace ( N , M ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_4909_A", "sol": 0, "python_code": "MAX_LEN , MAX_CHAR = 1005 , 26\ncnt = [ [ 0 for i in range ( MAX_CHAR ) ] for j in range ( MAX_LEN ) ]\ndef preProcess ( s ) :\n    n = len ( s )\n    for i in range ( 0 , n ) :\n        cnt [ i ] [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1\n    for i in range ( 0 , n ) :\n        for j in range ( 0 , 26 ) :\n            cnt [ i ] [ j ] += cnt [ i - 1 ] [ j ]\ndef findCharFreq ( l , r , c ) :\n    return ( cnt [ r ] [ ord ( c ) - 97 ] - cnt [ l - 1 ] [ ord ( c ) - 97 ] )\nif __name__ == \"__main__\" :\n    s = \"geeksforgeeks\"\n    Q = 4\n    preProcess ( s )\n    print ( findCharFreq ( 0 , 5 , 'e' ) )\n    print ( findCharFreq ( 2 , 6 , 'f' ) )\n    print ( findCharFreq ( 4 , 7 , 'm' ) )\n    print ( findCharFreq ( 0 , 12 , 'e' ) )\n", "python_code_tokenized": "MAX_LEN , MAX_CHAR = 1005 , 26 NEW_LINE cnt = [ [ 0 for i in range ( MAX_CHAR ) ] for j in range ( MAX_LEN ) ] NEW_LINE def preProcess ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cnt [ i ] [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , 26 ) : NEW_LINE INDENT cnt [ i ] [ j ] += cnt [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def findCharFreq ( l , r , c ) : NEW_LINE INDENT return ( cnt [ r ] [ ord ( c ) - 97 ] - cnt [ l - 1 ] [ ord ( c ) - 97 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE Q = 4 NEW_LINE preProcess ( s ) NEW_LINE print ( findCharFreq ( 0 , 5 , ' e ' ) ) NEW_LINE print ( findCharFreq ( 2 , 6 , ' f ' ) ) NEW_LINE print ( findCharFreq ( 4 , 7 , ' m ' ) ) NEW_LINE print ( findCharFreq ( 0 , 12 , ' e ' ) ) NEW_LINE DEDENT"}
{"id": "codeforces_495_A", "sol": 0, "python_code": "num = input ( )\nsol = [ 2 , 7 , 2 , 3 , 3 , 4 , 2 , 5 , 1 , 2 ]\nf_num = sol [ int ( num [ 0 ] ) ]\ns_num = sol [ int ( num [ 1 ] ) ]\nprint ( f_num * s_num )\n", "python_code_tokenized": "num = input ( ) NEW_LINE sol = [ 2 , 7 , 2 , 3 , 3 , 4 , 2 , 5 , 1 , 2 ] NEW_LINE f_num = sol [ int ( num [ 0 ] ) ] NEW_LINE s_num = sol [ int ( num [ 1 ] ) ] NEW_LINE print ( f_num * s_num ) NEW_LINE"}
{"id": "geeksforgeeks_3924_A", "sol": 0, "python_code": "def subsetGraph ( C ) :\n    global N\n    vertices = set ( )\n    for i in range ( N ) :\n        vertices.add ( i )\n    while ( len ( vertices ) != 0 ) :\n        if ( len ( vertices ) == 1 ) :\n            return 1\n        someone_removed = False\n        for x in vertices :\n            values = set ( )\n            for y in vertices :\n                if ( y != x ) :\n                    values.add ( C [ x ] [ y ] )\n            if ( len ( values ) == 1 ) :\n                vertices.remove ( x )\n                someone_removed = True\n                break\n        if ( not someone_removed ) :\n            break\n    return len ( vertices )\nN = 6\nC = [ [ 0 , 9 , 2 , 4 , 7 , 8 ] , [ 9 , 0 , 9 , 9 , 7 , 9 ] , [ 2 , 9 , 0 , 3 , 7 , 6 ] , [ 4 , 9 , 3 , 0 , 7 , 1 ] , [ 7 , 7 , 7 , 7 , 0 , 7 ] , [ 8 , 9 , 6 , 1 , 7 , 0 ] ]\nprint ( subsetGraph ( C ) )\n", "python_code_tokenized": "def subsetGraph ( C ) : NEW_LINE INDENT global N NEW_LINE vertices = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT vertices . add ( i ) NEW_LINE DEDENT while ( len ( vertices ) != 0 ) : NEW_LINE INDENT if ( len ( vertices ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT someone_removed = False NEW_LINE for x in vertices : NEW_LINE INDENT values = set ( ) NEW_LINE for y in vertices : NEW_LINE INDENT if ( y != x ) : NEW_LINE INDENT values . add ( C [ x ] [ y ] ) NEW_LINE DEDENT DEDENT if ( len ( values ) == 1 ) : NEW_LINE INDENT vertices . remove ( x ) NEW_LINE someone_removed = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not someone_removed ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return len ( vertices ) NEW_LINE DEDENT N = 6 NEW_LINE C = [ [ 0 , 9 , 2 , 4 , 7 , 8 ] , [ 9 , 0 , 9 , 9 , 7 , 9 ] , [ 2 , 9 , 0 , 3 , 7 , 6 ] , [ 4 , 9 , 3 , 0 , 7 , 1 ] , [ 7 , 7 , 7 , 7 , 0 , 7 ] , [ 8 , 9 , 6 , 1 , 7 , 0 ] ] NEW_LINE print ( subsetGraph ( C ) ) NEW_LINE"}
{"id": "geeksforgeeks_2083_A", "sol": 0, "python_code": "def converthenumber ( n ) :\n    s = str ( n ) ;\n    res = \"\" ;\n    for i in range ( len ( s ) ) :\n        if ( s [ i ] == '1' or s [ i ] == '3' or s [ i ] == '5' or s [ i ] == '7' or s [ i ] == '9' ) :\n            res += s [ i ] ;\n        if ( len ( res ) == 2 ) :\n            break ;\n    if ( len ( res ) == 2 ) :\n        print ( res ) ;\n    else :\n        print ( \"-1\" ) ;\nif __name__ == \"__main__\" :\n    n = 18720 ;\n    converthenumber ( n ) ;\n", "python_code_tokenized": "def converthenumber ( n ) : NEW_LINE INDENT s = str ( n ) ; NEW_LINE res = \" \" ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' or s [ i ] == '3' or s [ i ] == '5' or s [ i ] == '7' or s [ i ] == '9' ) : NEW_LINE INDENT res += s [ i ] ; NEW_LINE DEDENT if ( len ( res ) == 2 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( len ( res ) == 2 ) : NEW_LINE INDENT print ( res ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 18720 ; NEW_LINE converthenumber ( n ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4228_A", "sol": 0, "python_code": "def findIndex ( a , n , key ) :\n    start = - 1\n    for i in range ( n ) :\n        if a [ i ] == key :\n            start = i\n            break\n    if start == - 1 :\n        print ( \"Key not present in array\" )\n        return 0\n    end = start\n    for i in range ( n - 1 , start - 1 , - 1 ) :\n        if a [ i ] == key :\n            end = i\n            break\n    if start == end :\n        print ( \"Only one key is present at index : \" , start )\n    else :\n        print ( \"Start index: \" , start )\n        print ( \"Last index: \" , end )\na = [ 1 , 2 , 7 , 8 , 8 , 9 , 8 , 0 , 0 , 0 , 8 ]\nn = len ( a )\nkey = 8\nfindIndex ( a , n , key )\n", "python_code_tokenized": "def findIndex ( a , n , key ) : NEW_LINE INDENT start = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == key : NEW_LINE INDENT start = i NEW_LINE break NEW_LINE DEDENT DEDENT if start == - 1 : NEW_LINE INDENT print ( \" Key \u2581 not \u2581 present \u2581 in \u2581 array \" ) NEW_LINE return 0 NEW_LINE DEDENT end = start NEW_LINE for i in range ( n - 1 , start - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] == key : NEW_LINE INDENT end = i NEW_LINE break NEW_LINE DEDENT DEDENT if start == end : NEW_LINE INDENT print ( \" Only \u2581 one \u2581 key \u2581 is \u2581 present \u2581 at \u2581 index \u2581 : \u2581 \" , start ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Start \u2581 index : \u2581 \" , start ) NEW_LINE print ( \" Last \u2581 index : \u2581 \" , end ) NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 7 , 8 , 8 , 9 , 8 , 0 , 0 , 0 , 8 ] NEW_LINE n = len ( a ) NEW_LINE key = 8 NEW_LINE findIndex ( a , n , key ) NEW_LINE"}
{"id": "geeksforgeeks_2526_A", "sol": 0, "python_code": "import math\ndef minimumCuts ( a , n ) :\n    a.sort ( )\n    gcd = a [ 1 ] - a [ 0 ]\n    s = gcd\n    for i in range ( 2 , n ) :\n        gcd = math.gcd ( gcd , a [ i ] - a [ i - 1 ] )\n        s += a [ i ] - a [ i - 1 ]\n    if ( 360 - s > 0 ) :\n        gcd = math.gcd ( gcd , 360 - s )\n    return ( 360 // gcd ) - n\nif __name__ == \"__main__\" :\n    arr = [ 30 , 60 , 180 ]\n    n = len ( arr )\n    print ( minimumCuts ( arr , n ) )\n", "python_code_tokenized": "import math NEW_LINE def minimumCuts ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE gcd = a [ 1 ] - a [ 0 ] NEW_LINE s = gcd NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT gcd = math . gcd ( gcd , a [ i ] - a [ i - 1 ] ) NEW_LINE s += a [ i ] - a [ i - 1 ] NEW_LINE DEDENT if ( 360 - s > 0 ) : NEW_LINE INDENT gcd = math . gcd ( gcd , 360 - s ) NEW_LINE DEDENT return ( 360 // gcd ) - n NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 30 , 60 , 180 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumCuts ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC179_E", "sol": 0, "python_code": "n , x , m = map ( int , input ( ).split ( ) )\nnum , lst = set ( ) , [ ]\nfor i in range ( n ) :\n    num.add ( x ) , lst.append ( x )\n    x = x ** 2 % m\n    if x in num :\n        cnt , idx = i + 1 , lst.index ( x )\n        break\nans = sum ( num )\nif x in num :\n    div , mod = divmod ( n - cnt , len ( lst ) - idx )\n    ans += sum ( lst [ idx : ] ) * div\n    ans += sum ( lst [ idx : idx + mod ] )\nprint ( ans )\n", "python_code_tokenized": "n , x , m = map ( int , input ( ) . split ( ) ) NEW_LINE num , lst = set ( ) , [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num . add ( x ) , lst . append ( x ) NEW_LINE x = x ** 2 % m NEW_LINE if x in num : NEW_LINE INDENT cnt , idx = i + 1 , lst . index ( x ) NEW_LINE break NEW_LINE DEDENT DEDENT ans = sum ( num ) NEW_LINE if x in num : NEW_LINE INDENT div , mod = divmod ( n - cnt , len ( lst ) - idx ) NEW_LINE ans += sum ( lst [ idx : ] ) * div NEW_LINE ans += sum ( lst [ idx : idx + mod ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "atcoder_ABC087_C", "sol": 0, "python_code": "N = int ( input ( ) )\nA = list ( map ( int , input ( ).split ( ) ) )\nB = list ( map ( int , input ( ).split ( ) ) )\nanswer = 0\nfor i in range ( N ) :\n    answer = max ( answer , sum ( A [ : i + 1 ] + B [ i : ] ) )\nprint ( answer )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE answer = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT answer = max ( answer , sum ( A [ : i + 1 ] + B [ i : ] ) ) NEW_LINE DEDENT print ( answer ) NEW_LINE"}
{"id": "codeforces_849_A", "sol": 0, "python_code": "num_inp = lambda : int ( input ( ) )\narr_inp = lambda : list ( map ( int , input ( ).split ( ) ) )\nsp_inp = lambda : map ( int , input ( ).split ( ) )\nn = int ( input ( ) )\nA = list ( map ( int , input ( ).split ( ) ) )\nprint ( 'Yes' if A [ 0 ] % 2 and A [ - 1 ] % 2 and n % 2 else 'No' )\n", "python_code_tokenized": "num_inp = lambda : int ( input ( ) ) NEW_LINE arr_inp = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sp_inp = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( ' Yes ' if A [ 0 ] % 2 and A [ - 1 ] % 2 and n % 2 else ' No ' ) NEW_LINE"}
{"id": "geeksforgeeks_3791_A", "sol": 0, "python_code": "MAX_INT = 1000000\ndef solve ( Array , N ) :\n    pos = [ [ ] for i in range ( 5 ) ]\n    pref = [ 0 for i in range ( 5 ) ]\n    if ( Array [ 0 ] == 0 ) :\n        pref [ 0 ] = 1\n        pos [ 0 ].append ( 0 )\n    ans = MAX_INT\n    for i in range ( N ) :\n        if ( Array [ i ] == 0 ) :\n            pref [ 0 ] += 1\n            pos [ 0 ].append ( i )\n        else :\n            if ( pref [ Array [ i ] - 1 ] > 0 ) :\n                pref [ Array [ i ] ] += 1\n                pos [ Array [ i ] ].append ( i )\n                if ( Array [ i ] == 4 ) :\n                    end = i\n                    start = i\n                    for j in range ( 3 , - 1 , - 1 ) :\n                        s = 0\n                        e = len ( pos [ j ] ) - 1\n                        temp = - 1\n                        while ( s <= e ) :\n                            m = ( s + e ) // 2\n                            if ( pos [ j ] [ m ] <= start ) :\n                                temp = pos [ j ] [ m ]\n                                s = m + 1\n                            else :\n                                e = m - 1\n                        start = temp\n                    ans = min ( ans , end - start + 1 )\n    return ans\nArray = [ 0 , 1 , 2 , 3 , 4 , 2 , 0 , 3 , 4 ]\nN = len ( Array )\nprint ( solve ( Array , N ) )\n", "python_code_tokenized": "MAX_INT = 1000000 NEW_LINE def solve ( Array , N ) : NEW_LINE INDENT pos = [ [ ] for i in range ( 5 ) ] NEW_LINE pref = [ 0 for i in range ( 5 ) ] NEW_LINE if ( Array [ 0 ] == 0 ) : NEW_LINE INDENT pref [ 0 ] = 1 NEW_LINE pos [ 0 ] . append ( 0 ) NEW_LINE DEDENT ans = MAX_INT NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( Array [ i ] == 0 ) : NEW_LINE INDENT pref [ 0 ] += 1 NEW_LINE pos [ 0 ] . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( pref [ Array [ i ] - 1 ] > 0 ) : NEW_LINE INDENT pref [ Array [ i ] ] += 1 NEW_LINE pos [ Array [ i ] ] . append ( i ) NEW_LINE if ( Array [ i ] == 4 ) : NEW_LINE INDENT end = i NEW_LINE start = i NEW_LINE for j in range ( 3 , - 1 , - 1 ) : NEW_LINE INDENT s = 0 NEW_LINE e = len ( pos [ j ] ) - 1 NEW_LINE temp = - 1 NEW_LINE while ( s <= e ) : NEW_LINE INDENT m = ( s + e ) // 2 NEW_LINE if ( pos [ j ] [ m ] <= start ) : NEW_LINE INDENT temp = pos [ j ] [ m ] NEW_LINE s = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT e = m - 1 NEW_LINE DEDENT DEDENT start = temp NEW_LINE DEDENT ans = min ( ans , end - start + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT Array = [ 0 , 1 , 2 , 3 , 4 , 2 , 0 , 3 , 4 ] NEW_LINE N = len ( Array ) NEW_LINE print ( solve ( Array , N ) ) NEW_LINE"}
{"id": "geeksforgeeks_1015_A", "sol": 0, "python_code": "def CountingEvenOdd ( arr , arr_size ) :\n    even_count = 0\n    odd_count = 0\n    for i in range ( arr_size ) :\n        if ( arr [ i ] & 1 == 1 ) :\n            odd_count += 1\n        else :\n            even_count += 1\n    print ( \"Number of even elements = \" , even_count )\n    print ( \"Number of odd elements = \" , odd_count )\narr = [ 2 , 3 , 4 , 5 , 6 ]\nn = len ( arr )\nCountingEvenOdd ( arr , n )\n", "python_code_tokenized": "def CountingEvenOdd ( arr , arr_size ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT DEDENT print ( \" Number \u2581 of \u2581 even \u2581 elements \u2581 = \u2581 \" , even_count ) NEW_LINE print ( \" Number \u2581 of \u2581 odd \u2581 elements \u2581 = \u2581 \" , odd_count ) NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE CountingEvenOdd ( arr , n ) NEW_LINE"}
{"id": "atcoder_ARC103_C", "sol": 0, "python_code": "from sys import stdin\nimport sys\nimport math\nfrom functools import reduce\nimport functools\nimport itertools\nfrom collections import deque , Counter , defaultdict\nfrom operator import mul\nimport copy\nimport heapq\nsys.setrecursionlimit ( 10 ** 6 )\nINF = float ( \"inf\" )\nimport bisect\ns = input ( )\nn = len ( s )\nif s [ n - 1 ] == \"1\" or s [ 0 ] == \"0\" :\n    print ( - 1 )\n    sys.exit ( )\nfor i in range ( ( n - 1 ) // 2 ) :\n    if s [ i ] != s [ n - 2 - i ] :\n        print ( - 1 )\n        sys.exit ( )\nj = 0\nfor i in range ( 1 , n ) :\n    if s [ i ] == \"1\" :\n        for k in range ( j , i ) :\n            print ( k + 1 , i + 1 )\n        j = i\nfor k in range ( j + 1 , n ) :\n    print ( j + 1 , k + 1 )\n", "python_code_tokenized": "from sys import stdin NEW_LINE import sys NEW_LINE import math NEW_LINE from functools import reduce NEW_LINE import functools NEW_LINE import itertools NEW_LINE from collections import deque , Counter , defaultdict NEW_LINE from operator import mul NEW_LINE import copy NEW_LINE import heapq NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE INF = float ( \" inf \" ) NEW_LINE import bisect NEW_LINE s = input ( ) NEW_LINE n = len ( s ) NEW_LINE if s [ n - 1 ] == \"1\" or s [ 0 ] == \"0\" : NEW_LINE INDENT print ( - 1 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT for i in range ( ( n - 1 ) // 2 ) : NEW_LINE INDENT if s [ i ] != s [ n - 2 - i ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT j = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] == \"1\" : NEW_LINE INDENT for k in range ( j , i ) : NEW_LINE INDENT print ( k + 1 , i + 1 ) NEW_LINE DEDENT j = i NEW_LINE DEDENT DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT print ( j + 1 , k + 1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3476_A", "sol": 0, "python_code": "def check ( mid , array , n , K ) :\n    count = 0\n    sum = 0\n    for i in range ( n ) :\n        if ( array [ i ] > mid ) :\n            return False\n        sum += array [ i ]\n        if ( sum > mid ) :\n            count += 1\n            sum = array [ i ]\n    count += 1\n    if ( count <= K ) :\n        return True\n    return False\ndef solve ( array , n , K ) :\n    start = 1\n    end = 0\n    for i in range ( n ) :\n        end += array [ i ]\n    answer = 0\n    while ( start <= end ) :\n        mid = ( start + end ) // 2\n        if ( check ( mid , array , n , K ) ) :\n            answer = mid\n            end = mid - 1\n        else :\n            start = mid + 1\n    return answer\nif __name__ == '__main__' :\n    array = [ 1 , 2 , 3 , 4 ]\n    n = len ( array )\n    K = 3\n    print ( solve ( array , n , K ) )\n", "python_code_tokenized": "def check ( mid , array , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( array [ i ] > mid ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += array [ i ] NEW_LINE if ( sum > mid ) : NEW_LINE INDENT count += 1 NEW_LINE sum = array [ i ] NEW_LINE DEDENT DEDENT count += 1 NEW_LINE if ( count <= K ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def solve ( array , n , K ) : NEW_LINE INDENT start = 1 NEW_LINE end = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT end += array [ i ] NEW_LINE DEDENT answer = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( check ( mid , array , n , K ) ) : NEW_LINE INDENT answer = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT array = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( array ) NEW_LINE K = 3 NEW_LINE print ( solve ( array , n , K ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1141_A", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nif n == m :\n    print ( 0 )\nelse :\n    counter = 0\n    flag = True\n    while m > n :\n        if ( m / 2 ) % n == 0 :\n            m /= 2\n            counter += 1\n        elif ( m / 3 ) % n == 0 :\n            m /= 3\n            counter += 1\n        else :\n            flag = False\n            break\n    print ( counter if flag else - 1 )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == m : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT counter = 0 NEW_LINE flag = True NEW_LINE while m > n : NEW_LINE INDENT if ( m / 2 ) % n == 0 : NEW_LINE INDENT m /= 2 NEW_LINE counter += 1 NEW_LINE DEDENT elif ( m / 3 ) % n == 0 : NEW_LINE INDENT m /= 3 NEW_LINE counter += 1 NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT print ( counter if flag else - 1 ) NEW_LINE DEDENT"}
{"id": "codeforces_1703_A", "sol": 0, "python_code": "n = int ( input ( ) )\nfor rt in range ( n ) :\n    s = input ( )\n    if ( s [ 0 ] == 'Y' or s [ 0 ] == 'y' ) and ( s [ 1 ] == \"e\" or s [ 1 ] == 'E' ) and ( s [ 2 ] == 's' or s [ 2 ] == 'S' ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE for rt in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if ( s [ 0 ] == ' Y ' or s [ 0 ] == ' y ' ) and ( s [ 1 ] == \" e \" or s [ 1 ] == ' E ' ) and ( s [ 2 ] == ' s ' or s [ 2 ] == ' S ' ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00657_A", "sol": 0, "python_code": "while True :\n    r , c = map ( int , input ( ).split ( ) )\n    if r == 0 : break\n    print ( \"no\" if r * c & 1 else \"yes\" )\n", "python_code_tokenized": "while True : NEW_LINE INDENT r , c = map ( int , input ( ) . split ( ) ) NEW_LINE if r == 0 : break NEW_LINE print ( \" no \" if r * c & 1 else \" yes \" ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC047_A", "sol": 0, "python_code": "a , b , c = [ int ( i ) for i in input ( ).split ( ) ]\nif ( 2 * max ( a , b , c ) - ( a + b + c ) == 0 ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if ( 2 * max ( a , b , c ) - ( a + b + c ) == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1015_A", "sol": 0, "python_code": "toch , dlin = map ( int , input ( ).split ( ) )\notrez = [ 0 ] * ( dlin + 1 )\nfor i in range ( toch ) :\n    nach , konec = map ( int , input ( ).split ( ) )\n    for j in range ( nach , konec + 1 ) :\n        otrez [ j ] = 1\npust = otrez.count ( 0 ) - 1\nprint ( pust )\nif pust != 0 :\n    for i in range ( 1 , dlin + 1 ) :\n        if otrez [ i ] != 1 :\n            print ( i , end = ' ' )\n", "python_code_tokenized": "toch , dlin = map ( int , input ( ) . split ( ) ) NEW_LINE otrez = [ 0 ] * ( dlin + 1 ) NEW_LINE for i in range ( toch ) : NEW_LINE INDENT nach , konec = map ( int , input ( ) . split ( ) ) NEW_LINE for j in range ( nach , konec + 1 ) : NEW_LINE INDENT otrez [ j ] = 1 NEW_LINE DEDENT DEDENT pust = otrez . count ( 0 ) - 1 NEW_LINE print ( pust ) NEW_LINE if pust != 0 : NEW_LINE INDENT for i in range ( 1 , dlin + 1 ) : NEW_LINE INDENT if otrez [ i ] != 1 : NEW_LINE INDENT print ( i , end = ' \u2581 ' ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "projecteuler_p132_A", "sol": 0, "python_code": "import eulerlib , itertools\ndef compute ( ) :\n    cond = lambda i : eulerlib.is_prime ( i ) and repunit_mod ( 10 ** 9 , i ) == 0\n    ans = sum ( itertools.islice ( filter ( cond , itertools.count ( 2 ) ) , 40 ) )\n    return str ( ans )\ndef repunit_mod ( k , m ) :\n    return ( pow ( 10 , k , m * 9 ) - 1 ) // 9\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT cond = lambda i : eulerlib . is_prime ( i ) and repunit_mod ( 10 ** 9 , i ) == 0 NEW_LINE ans = sum ( itertools . islice ( filter ( cond , itertools . count ( 2 ) ) , 40 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def repunit_mod ( k , m ) : NEW_LINE INDENT return ( pow ( 10 , k , m * 9 ) - 1 ) // 9 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1778_A", "sol": 0, "python_code": "def multiply ( x , y ) :\n    if ( y == 0 ) :\n        return 0\n    if ( y > 0 ) :\n        return ( x + multiply ( x , y - 1 ) )\n    if ( y < 0 ) :\n        return - multiply ( x , - y )\nprint ( multiply ( 5 , - 11 ) )\n", "python_code_tokenized": "def multiply ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( y > 0 ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) NEW_LINE DEDENT if ( y < 0 ) : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT DEDENT print ( multiply ( 5 , - 11 ) ) NEW_LINE"}
{"id": "codeforces_1537_B", "sol": 0, "python_code": "t = int ( input ( ) )\nl1 = [ ]\nl2 = [ ]\nl3 = [ ]\nl4 = [ ]\nfor k in range ( t ) :\n    n , m , i , j = map ( int , input ( ).split ( ) )\n    l1.append ( n )\n    l2.append ( m )\n    l3.append ( i )\n    l4.append ( j )\nfor i in range ( len ( l1 ) ) :\n    print ( 1 , 1 , l1 [ i ] , l2 [ i ] )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE l1 = [ ] NEW_LINE l2 = [ ] NEW_LINE l3 = [ ] NEW_LINE l4 = [ ] NEW_LINE for k in range ( t ) : NEW_LINE INDENT n , m , i , j = map ( int , input ( ) . split ( ) ) NEW_LINE l1 . append ( n ) NEW_LINE l2 . append ( m ) NEW_LINE l3 . append ( i ) NEW_LINE l4 . append ( j ) NEW_LINE DEDENT for i in range ( len ( l1 ) ) : NEW_LINE INDENT print ( 1 , 1 , l1 [ i ] , l2 [ i ] ) NEW_LINE DEDENT"}
{"id": "codeforces_1108_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    a , b , c , d = map ( int , input ( ).split ( ) )\n    if ( a == c and b == d ) :\n        print ( a , a + 1 )\n    elif ( a == c ) :\n        print ( a , a + 1 )\n    elif ( b == d ) :\n        print ( b - 1 , b )\n    else :\n        print ( a , c )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a == c and b == d ) : NEW_LINE INDENT print ( a , a + 1 ) NEW_LINE DEDENT elif ( a == c ) : NEW_LINE INDENT print ( a , a + 1 ) NEW_LINE DEDENT elif ( b == d ) : NEW_LINE INDENT print ( b - 1 , b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a , c ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC068_A", "sol": 0, "python_code": "N = int ( input ( ) )\nprint ( 'ABC' + str ( N ) )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE print ( ' ABC ' + str ( N ) ) NEW_LINE"}
{"id": "atcoder_ABC109_D", "sol": 0, "python_code": "H , W = map ( int , input ( ).split ( ) )\na = [ [ - 1 ] * ( W + 2 ) for _ in range ( H + 2 ) ]\nodd_count = 0\nfor i in range ( 1 , H + 1 ) :\n    tmp = list ( map ( int , input ( ).split ( ) ) )\n    for j in range ( 1 , W + 1 ) :\n        a [ i ] [ j ] = tmp [ j - 1 ]\n        odd_count += int ( a [ i ] [ j ] % 2 == 1 )\nmoves = [ ]\nroutes = [ ]\nfor h in range ( 1 , H + 1 ) :\n    tmp = [ ]\n    for w in range ( 1 , W + 1 ) :\n        tmp.append ( ( h , w ) )\n    if h % 2 == 1 :\n        routes += tmp\n    else :\n        routes += tmp [ : : - 1 ]\nis_carrying = 0\nfor i , ( h , w ) in enumerate ( routes ) :\n    if i == H * W - 1 :\n        break\n    if odd_count == 1 :\n        break\n    if a [ h ] [ w ] % 2 == 1 and not is_carrying :\n        tmp = ( h , w )\n        is_carrying = 1\n        moves.append ( ( h , w , routes [ i + 1 ] [ 0 ] , routes [ i + 1 ] [ 1 ] ) )\n    elif a [ h ] [ w ] % 2 == 1 and is_carrying :\n        is_carrying = 0\n        odd_count -= 2\n    elif a [ h ] [ w ] % 2 == 0 and is_carrying :\n        moves.append ( ( h , w , routes [ i + 1 ] [ 0 ] , routes [ i + 1 ] [ 1 ] ) )\nprint ( len ( moves ) )\nfor move in moves :\n    print ( * move )\n", "python_code_tokenized": "H , W = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ [ - 1 ] * ( W + 2 ) for _ in range ( H + 2 ) ] NEW_LINE odd_count = 0 NEW_LINE for i in range ( 1 , H + 1 ) : NEW_LINE INDENT tmp = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( 1 , W + 1 ) : NEW_LINE INDENT a [ i ] [ j ] = tmp [ j - 1 ] NEW_LINE odd_count += int ( a [ i ] [ j ] % 2 == 1 ) NEW_LINE DEDENT DEDENT moves = [ ] NEW_LINE routes = [ ] NEW_LINE for h in range ( 1 , H + 1 ) : NEW_LINE INDENT tmp = [ ] NEW_LINE for w in range ( 1 , W + 1 ) : NEW_LINE INDENT tmp . append ( ( h , w ) ) NEW_LINE DEDENT if h % 2 == 1 : NEW_LINE INDENT routes += tmp NEW_LINE DEDENT else : NEW_LINE INDENT routes += tmp [ : : - 1 ] NEW_LINE DEDENT DEDENT is_carrying = 0 NEW_LINE for i , ( h , w ) in enumerate ( routes ) : NEW_LINE INDENT if i == H * W - 1 : NEW_LINE INDENT break NEW_LINE DEDENT if odd_count == 1 : NEW_LINE INDENT break NEW_LINE DEDENT if a [ h ] [ w ] % 2 == 1 and not is_carrying : NEW_LINE INDENT tmp = ( h , w ) NEW_LINE is_carrying = 1 NEW_LINE moves . append ( ( h , w , routes [ i + 1 ] [ 0 ] , routes [ i + 1 ] [ 1 ] ) ) NEW_LINE DEDENT elif a [ h ] [ w ] % 2 == 1 and is_carrying : NEW_LINE INDENT is_carrying = 0 NEW_LINE odd_count -= 2 NEW_LINE DEDENT elif a [ h ] [ w ] % 2 == 0 and is_carrying : NEW_LINE INDENT moves . append ( ( h , w , routes [ i + 1 ] [ 0 ] , routes [ i + 1 ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT print ( len ( moves ) ) NEW_LINE for move in moves : NEW_LINE INDENT print ( * move ) NEW_LINE DEDENT"}
{"id": "aizu_p00042_A", "sol": 0, "python_code": "def f ( ) :\n    c = 0\n    for W in iter ( input , '0' ) :\n        c += 1\n        W = int ( W )\n        d = [ 0 ] * - ~ W\n        for _ in [ 0 ] * int ( input ( ) ) :\n            v , w = map ( int , input ( ).split ( ',' ) )\n            for i in range ( W , w - 1 , - 1 ) :\n                if d [ i ] < d [ i - w ] + v : d [ i ] = d [ i - w ] + v\n        print ( f'Case {c}:\\n{d[W]}\\n{d.index(d[W])}' )\nf ( )\n", "python_code_tokenized": "def f ( ) : NEW_LINE INDENT c = 0 NEW_LINE for W in iter ( input , '0' ) : NEW_LINE INDENT c += 1 NEW_LINE W = int ( W ) NEW_LINE d = [ 0 ] * - ~ W NEW_LINE for _ in [ 0 ] * int ( input ( ) ) : NEW_LINE INDENT v , w = map ( int , input ( ) . split ( ' , ' ) ) NEW_LINE for i in range ( W , w - 1 , - 1 ) : NEW_LINE INDENT if d [ i ] < d [ i - w ] + v : d [ i ] = d [ i - w ] + v NEW_LINE DEDENT DEDENT print ( f ' Case \u2581 { c } : \\n { d [ W ] } \\n { d . index ( d [ W ] ) } ' ) NEW_LINE DEDENT DEDENT f ( ) NEW_LINE"}
{"id": "aizu_p01096_A", "sol": 0, "python_code": "import sys\ninput = lambda : sys.stdin.readline ( ).strip ( )\nsys.setrecursionlimit ( 10 ** 8 )\ndef solve ( ) :\n    n = int ( input ( ) )\n    while n != 0 :\n        w = tuple ( map ( int , input ( ).split ( ) ) )\n        dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ]\n        for i in range ( n - 1 , - 1 , - 1 ) :\n            for j in range ( i + 1 , n ) :\n                if ( j - i + 1 ) % 2 == 0 :\n                    if dp [ i + 1 ] [ j - 1 ] == j - i - 1 and abs ( w [ i ] - w [ j ] ) <= 1 :\n                        dp [ i ] [ j ] = dp [ i + 1 ] [ j - 1 ] + 2\n                    else :\n                        p = tuple ( dp [ i ] [ k ] + dp [ k + 1 ] [ j ] for k in range ( i , j + 1 ) )\n                        dp [ i ] [ j ] = max ( p )\n                else :\n                    dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i + 1 ] [ j ] )\n        print ( dp [ 0 ] [ n - 1 ] )\n        n = int ( input ( ) )\nif __name__ == \"__main__\" :\n    solve ( )\n", "python_code_tokenized": "import sys NEW_LINE input = lambda : sys . stdin . readline ( ) . strip ( ) NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE while n != 0 : NEW_LINE INDENT w = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j - i + 1 ) % 2 == 0 : NEW_LINE INDENT if dp [ i + 1 ] [ j - 1 ] == j - i - 1 and abs ( w [ i ] - w [ j ] ) <= 1 : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT p = tuple ( dp [ i ] [ k ] + dp [ k + 1 ] [ j ] for k in range ( i , j + 1 ) ) NEW_LINE dp [ i ] [ j ] = max ( p ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ 0 ] [ n - 1 ] ) NEW_LINE n = int ( input ( ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"}
{"id": "aizu_p02037_A", "sol": 0, "python_code": "h , w = map ( int , input ( ).split ( ) )\na , b = map ( int , input ( ).split ( ) )\nprint ( h * w - ( a * b * ( ( h // a ) * ( w // b ) ) ) )\n", "python_code_tokenized": "h , w = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( h * w - ( a * b * ( ( h // a ) * ( w // b ) ) ) ) NEW_LINE"}
{"id": "aizu_p02332_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\nm = 10 ** 9 + 7\nif a > b :\n    print ( 0 )\nelse :\n    r = 1\n    for i in range ( b - a + 1 , b + 1 ) :\n        r *= i\n        r %= m\n    print ( r )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE m = 10 ** 9 + 7 NEW_LINE if a > b : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT r = 1 NEW_LINE for i in range ( b - a + 1 , b + 1 ) : NEW_LINE INDENT r *= i NEW_LINE r %= m NEW_LINE DEDENT print ( r ) NEW_LINE DEDENT"}
{"id": "aizu_p02331_A", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nans = 1\nfor _ in range ( n ) :\n    ans *= k\n    ans %= 1000000007\nprint ( ans )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 1 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT ans *= k NEW_LINE ans %= 1000000007 NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "aizu_p01970_A", "sol": 0, "python_code": "from collections import defaultdict\nMAX = 1000000\nROOT = 1000\nMOD = 1000000007\nis_prime = [ True ] * ( MAX + 1 )\nis_prime [ 0 ] = is_prime [ 1 ] = False\nfor i in range ( 2 , ROOT + 1 ) :\n    if is_prime [ i ] :\n        for j in range ( i * i , MAX + 1 , i ) :\n            is_prime [ j ] = False\nn = int ( input ( ) )\nqlst = list ( map ( int , input ( ).split ( ) ) )\ntotal1 = 0\ntotal2 = 1\nlast_prime = 0\ndic = { }\ndic [ ( last_prime , 0 ) ] = total1\ndic [ ( last_prime , 1 ) ] = total2\nfor q in qlst :\n    new_dic = defaultdict ( int )\n    for k , v in dic.items ( ) :\n        last_prime , t = k\n        if is_prime [ q ] :\n            if t == 0 :\n                if last_prime < q :\n                    new_dic [ ( q , 0 ) ] = ( new_dic [ ( q , 0 ) ] + v ) % MOD\n                    new_dic [ ( last_prime , 1 ) ] = ( new_dic [ ( last_prime , 1 ) ] + v ) % MOD\n                else :\n                    new_dic [ ( last_prime , 1 ) ] = ( new_dic [ ( last_prime , 1 ) ] + v ) % MOD\n            else :\n                if last_prime < q :\n                    new_dic [ ( q , 0 ) ] = ( new_dic [ ( q , 0 ) ] + v ) % MOD\n        if not is_prime [ q ] :\n            if t == 0 :\n                new_dic [ ( last_prime , 1 ) ] = ( new_dic [ ( last_prime , 1 ) ] + v ) % MOD\n    dic = new_dic\nprint ( sum ( dic.values ( ) ) % MOD )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE MAX = 1000000 NEW_LINE ROOT = 1000 NEW_LINE MOD = 1000000007 NEW_LINE is_prime = [ True ] * ( MAX + 1 ) NEW_LINE is_prime [ 0 ] = is_prime [ 1 ] = False NEW_LINE for i in range ( 2 , ROOT + 1 ) : NEW_LINE INDENT if is_prime [ i ] : NEW_LINE INDENT for j in range ( i * i , MAX + 1 , i ) : NEW_LINE INDENT is_prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT n = int ( input ( ) ) NEW_LINE qlst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE total1 = 0 NEW_LINE total2 = 1 NEW_LINE last_prime = 0 NEW_LINE dic = { } NEW_LINE dic [ ( last_prime , 0 ) ] = total1 NEW_LINE dic [ ( last_prime , 1 ) ] = total2 NEW_LINE for q in qlst : NEW_LINE INDENT new_dic = defaultdict ( int ) NEW_LINE for k , v in dic . items ( ) : NEW_LINE INDENT last_prime , t = k NEW_LINE if is_prime [ q ] : NEW_LINE INDENT if t == 0 : NEW_LINE INDENT if last_prime < q : NEW_LINE INDENT new_dic [ ( q , 0 ) ] = ( new_dic [ ( q , 0 ) ] + v ) % MOD NEW_LINE new_dic [ ( last_prime , 1 ) ] = ( new_dic [ ( last_prime , 1 ) ] + v ) % MOD NEW_LINE DEDENT else : NEW_LINE INDENT new_dic [ ( last_prime , 1 ) ] = ( new_dic [ ( last_prime , 1 ) ] + v ) % MOD NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if last_prime < q : NEW_LINE INDENT new_dic [ ( q , 0 ) ] = ( new_dic [ ( q , 0 ) ] + v ) % MOD NEW_LINE DEDENT DEDENT DEDENT if not is_prime [ q ] : NEW_LINE INDENT if t == 0 : NEW_LINE INDENT new_dic [ ( last_prime , 1 ) ] = ( new_dic [ ( last_prime , 1 ) ] + v ) % MOD NEW_LINE DEDENT DEDENT DEDENT dic = new_dic NEW_LINE DEDENT print ( sum ( dic . values ( ) ) % MOD ) NEW_LINE"}
{"id": "geeksforgeeks_882_A", "sol": 0, "python_code": "def findRemainder ( n ) :\n    x = n & 3\n    return x\nif __name__ == '__main__' :\n    N = 43\n    ans = findRemainder ( N )\n    print ( ans )\n", "python_code_tokenized": "def findRemainder ( n ) : NEW_LINE INDENT x = n & 3 NEW_LINE return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 43 NEW_LINE ans = findRemainder ( N ) NEW_LINE print ( ans ) NEW_LINE DEDENT"}
{"id": "aizu_p02264_A", "sol": 0, "python_code": "nq = list ( map ( int , input ( ).split ( ) ) )\nqueue = list ( )\nfor i in range ( nq [ 0 ] ) :\n    queue.append ( input ( ).split ( ) )\nti = 0\ncur = 0\nwhile int ( queue [ cur ] [ 1 ] ) > 0 :\n    num = queue [ cur ]\n    syori = int ( num [ 1 ] ) - nq [ 1 ]\n    if syori > 0 :\n        num [ 1 ] = syori\n        queue.append ( num )\n        ti += nq [ 1 ]\n    else :\n        ti += int ( num [ 1 ] )\n        print ( '{} {}'.format ( num [ 0 ] , ti ) )\n    cur += 1\n    if len ( queue ) <= cur :\n        break\n", "python_code_tokenized": "nq = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE queue = list ( ) NEW_LINE for i in range ( nq [ 0 ] ) : NEW_LINE INDENT queue . append ( input ( ) . split ( ) ) NEW_LINE DEDENT ti = 0 NEW_LINE cur = 0 NEW_LINE while int ( queue [ cur ] [ 1 ] ) > 0 : NEW_LINE INDENT num = queue [ cur ] NEW_LINE syori = int ( num [ 1 ] ) - nq [ 1 ] NEW_LINE if syori > 0 : NEW_LINE INDENT num [ 1 ] = syori NEW_LINE queue . append ( num ) NEW_LINE ti += nq [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ti += int ( num [ 1 ] ) NEW_LINE print ( ' { } \u2581 { } ' . format ( num [ 0 ] , ti ) ) NEW_LINE DEDENT cur += 1 NEW_LINE if len ( queue ) <= cur : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3064_A", "sol": 0, "python_code": "def getMinDiff ( arr , n , k ) :\n    if ( n == 1 ) :\n        return 0\n    arr.sort ( )\n    ans = arr [ n - 1 ] - arr [ 0 ]\n    small = arr [ 0 ] + k\n    big = arr [ n - 1 ] - k\n    if ( small > big ) :\n        small , big = big , small\n    for i in range ( 1 , n - 1 ) :\n        subtract = arr [ i ] - k\n        add = arr [ i ] + k\n        if ( subtract >= small or add <= big ) :\n            continue\n        if ( big - subtract <= add - small ) :\n            small = subtract\n        else :\n            big = add\n    return min ( ans , big - small )\narr = [ 4 , 6 ]\nn = len ( arr )\nk = 10\nprint ( \"Maximum difference is\" , getMinDiff ( arr , n , k ) )\n", "python_code_tokenized": "def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE small = arr [ 0 ] + k NEW_LINE big = arr [ n - 1 ] - k NEW_LINE if ( small > big ) : NEW_LINE INDENT small , big = big , small NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT subtract = arr [ i ] - k NEW_LINE add = arr [ i ] + k NEW_LINE if ( subtract >= small or add <= big ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( big - subtract <= add - small ) : NEW_LINE INDENT small = subtract NEW_LINE DEDENT else : NEW_LINE INDENT big = add NEW_LINE DEDENT DEDENT return min ( ans , big - small ) NEW_LINE DEDENT arr = [ 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 10 NEW_LINE print ( \" Maximum \u2581 difference \u2581 is \" , getMinDiff ( arr , n , k ) ) NEW_LINE"}
{"id": "aizu_p02489_A", "sol": 0, "python_code": "count = 1\nwhile True :\n    x = int ( raw_input ( ) )\n    if x == 0 :\n        break\n    print ( \"Case %d: %d\" % ( count , x ) )\n    count += 1\n", "python_code_tokenized": "count = 1 NEW_LINE while True : NEW_LINE INDENT x = int ( raw_input ( ) ) NEW_LINE if x == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( \" Case \u2581 % d : \u2581 % d \" % ( count , x ) ) NEW_LINE count += 1 NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2911_A", "sol": 0, "python_code": "def Count_subarray ( arr , n ) :\n    total_sum = 0 ;\n    count = 0 ;\n    for i in range ( n ) :\n        total_sum += arr [ i ] ;\n    for i in range ( n ) :\n        subarray_sum = 0 ;\n        for j in range ( i , n ) :\n            subarray_sum += arr [ j ] ;\n            remaining_sum = total_sum - subarray_sum ;\n            if ( subarray_sum > remaining_sum ) :\n                count += 1 ;\n    return count ;\nif __name__ == \"__main__\" :\n    arr = [ 10 , 9 , 12 , 6 ] ;\n    n = len ( arr ) ;\n    print ( Count_subarray ( arr , n ) ) ;\n", "python_code_tokenized": "def Count_subarray ( arr , n ) : NEW_LINE INDENT total_sum = 0 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT total_sum += arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT subarray_sum = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT subarray_sum += arr [ j ] ; NEW_LINE remaining_sum = total_sum - subarray_sum ; NEW_LINE if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 9 , 12 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( Count_subarray ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4687_A", "sol": 0, "python_code": "def summation ( n ) :\n    return sum ( [ i ** 2 for i in range ( 1 , n + 1 ) ] )\nif __name__ == \"__main__\" :\n    n = 2\n    print ( summation ( n ) )\n", "python_code_tokenized": "def summation ( n ) : NEW_LINE INDENT return sum ( [ i ** 2 for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( summation ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2978_A", "sol": 0, "python_code": "def largest ( arr , n ) :\n    return max ( arr )\narr = [ 10 , 324 , 45 , 90 , 9808 ]\nn = len ( arr )\nprint ( largest ( arr , n ) )\n", "python_code_tokenized": "def largest ( arr , n ) : NEW_LINE INDENT return max ( arr ) NEW_LINE DEDENT arr = [ 10 , 324 , 45 , 90 , 9808 ] NEW_LINE n = len ( arr ) NEW_LINE print ( largest ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_118_A", "sol": 0, "python_code": "import math\ndef haversine ( lat1 , lon1 , lat2 , lon2 ) :\n    dLat = ( lat2 - lat1 ) * math.pi / 180.0\n    dLon = ( lon2 - lon1 ) * math.pi / 180.0\n    lat1 = ( lat1 ) * math.pi / 180.0\n    lat2 = ( lat2 ) * math.pi / 180.0\n    a = ( pow ( math.sin ( dLat / 2 ) , 2 ) + pow ( math.sin ( dLon / 2 ) , 2 ) * math.cos ( lat1 ) * math.cos ( lat2 ) ) ;\n    rad = 6371\n    c = 2 * math.asin ( math.sqrt ( a ) )\n    return rad * c\nif __name__ == \"__main__\" :\n    lat1 = 51.5007\n    lon1 = 0.1246\n    lat2 = 40.6892\n    lon2 = 74.0445\n    print ( haversine ( lat1 , lon1 , lat2 , lon2 ) , \"K.M.\" )\n", "python_code_tokenized": "import math NEW_LINE def haversine ( lat1 , lon1 , lat2 , lon2 ) : NEW_LINE INDENT dLat = ( lat2 - lat1 ) * math . pi / 180.0 NEW_LINE dLon = ( lon2 - lon1 ) * math . pi / 180.0 NEW_LINE lat1 = ( lat1 ) * math . pi / 180.0 NEW_LINE lat2 = ( lat2 ) * math . pi / 180.0 NEW_LINE a = ( pow ( math . sin ( dLat / 2 ) , 2 ) + pow ( math . sin ( dLon / 2 ) , 2 ) * math . cos ( lat1 ) * math . cos ( lat2 ) ) ; NEW_LINE rad = 6371 NEW_LINE c = 2 * math . asin ( math . sqrt ( a ) ) NEW_LINE return rad * c NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT lat1 = 51.5007 NEW_LINE lon1 = 0.1246 NEW_LINE lat2 = 40.6892 NEW_LINE lon2 = 74.0445 NEW_LINE print ( haversine ( lat1 , lon1 , lat2 , lon2 ) , \" K . M . \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2194_A", "sol": 0, "python_code": "import math as mt\ndef isPrime ( n ) :\n    i , c = 0 , 0\n    for i in range ( 1 , n // 2 ) :\n        if ( n % i == 0 ) :\n            c += 1\n    if ( c == 1 ) :\n        return 1\n    else :\n        return 0\ndef findMinNum ( arr , n ) :\n    first , last = 0 , 0\n    Hash = [ 0 for i in range ( 10 ) ]\n    for i in range ( n ) :\n        Hash [ arr [ i ] ] += 1\n    print ( \"Minimum number: \" , end = \"\" )\n    for i in range ( 0 , 10 ) :\n        for j in range ( Hash [ i ] ) :\n            print ( i , end = \"\" )\n    print ( )\n    for i in range ( 10 ) :\n        if ( Hash [ i ] != 0 ) :\n            first = i\n            break\n    for i in range ( 9 , - 1 , - 1 ) :\n        if ( Hash [ i ] != 0 ) :\n            last = i\n            break\n    num = first * 10 + last\n    rev = last * 10 + first\n    print ( \"Prime combinations: \" , end = \"\" )\n    if ( isPrime ( num ) and isPrime ( rev ) ) :\n        print ( num , \" \" , rev )\n    elif ( isPrime ( num ) ) :\n        print ( num )\n    elif ( isPrime ( rev ) ) :\n        print ( rev )\n    else :\n        print ( \"No combinations exist\" )\narr = [ 1 , 2 , 4 , 7 , 8 ]\nfindMinNum ( arr , 5 )\n", "python_code_tokenized": "import math as mt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT i , c = 0 , 0 NEW_LINE for i in range ( 1 , n // 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def findMinNum ( arr , n ) : NEW_LINE INDENT first , last = 0 , 0 NEW_LINE Hash = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash [ arr [ i ] ] += 1 NEW_LINE DEDENT print ( \" Minimum \u2581 number : \u2581 \" , end = \" \" ) NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT for j in range ( Hash [ i ] ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( Hash [ i ] != 0 ) : NEW_LINE INDENT first = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT if ( Hash [ i ] != 0 ) : NEW_LINE INDENT last = i NEW_LINE break NEW_LINE DEDENT DEDENT num = first * 10 + last NEW_LINE rev = last * 10 + first NEW_LINE print ( \" Prime \u2581 combinations : \u2581 \" , end = \" \" ) NEW_LINE if ( isPrime ( num ) and isPrime ( rev ) ) : NEW_LINE INDENT print ( num , \" \u2581 \" , rev ) NEW_LINE DEDENT elif ( isPrime ( num ) ) : NEW_LINE INDENT print ( num ) NEW_LINE DEDENT elif ( isPrime ( rev ) ) : NEW_LINE INDENT print ( rev ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 combinations \u2581 exist \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 4 , 7 , 8 ] NEW_LINE findMinNum ( arr , 5 ) NEW_LINE"}
{"id": "codeforces_333_B", "sol": 0, "python_code": "I = input\nn , m = map ( int , I ( ).split ( ) )\nb = [ 1 ] * n * 2\nb [ 0 ] = b [ n - 1 ] = b [ n ] = b [ 2 * n - 1 ] = 0\nfor i in range ( m ) :\n    r , c = map ( int , I ( ).split ( ) )\n    b [ r - 1 ] = b [ n + c - 1 ] = 0\nif n % 2 and b [ n // 2 ] and b [ n + n // 2 ] : b [ n // 2 ] = 0\nprint ( sum ( b ) )\n", "python_code_tokenized": "I = input NEW_LINE n , m = map ( int , I ( ) . split ( ) ) NEW_LINE b = [ 1 ] * n * 2 NEW_LINE b [ 0 ] = b [ n - 1 ] = b [ n ] = b [ 2 * n - 1 ] = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT r , c = map ( int , I ( ) . split ( ) ) NEW_LINE b [ r - 1 ] = b [ n + c - 1 ] = 0 NEW_LINE DEDENT if n % 2 and b [ n // 2 ] and b [ n + n // 2 ] : b [ n // 2 ] = 0 NEW_LINE print ( sum ( b ) ) NEW_LINE"}
{"id": "codeforces_1475_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    if ( n & ( n - 1 ) ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if ( n & ( n - 1 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_5129_A", "sol": 0, "python_code": "def sumOfSeries ( num ) :\n    res = 0\n    fact = 1\n    for i in range ( 1 , num + 1 ) :\n        fact *= i\n        res = res + ( i / fact )\n    return res\nn = 5\nprint ( \"Sum: \" , sumOfSeries ( n ) )\n", "python_code_tokenized": "def sumOfSeries ( num ) : NEW_LINE INDENT res = 0 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE res = res + ( i / fact ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE print ( \" Sum : \u2581 \" , sumOfSeries ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_750_A", "sol": 0, "python_code": "def fillPrefixSum ( arr , n , prefixSum ) :\n    prefixSum [ 0 ] = arr [ 0 ]\n    for i in range ( 1 , n ) :\n        prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ]\narr = [ 10 , 4 , 16 , 20 ]\nn = len ( arr )\nprefixSum = [ 0 for i in range ( n + 1 ) ]\nfillPrefixSum ( arr , n , prefixSum )\nfor i in range ( n ) :\n    print ( prefixSum [ i ] , \"\" , end = \"\" )\n", "python_code_tokenized": "def fillPrefixSum ( arr , n , prefixSum ) : NEW_LINE INDENT prefixSum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT DEDENT arr = [ 10 , 4 , 16 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE prefixSum = [ 0 for i in range ( n + 1 ) ] NEW_LINE fillPrefixSum ( arr , n , prefixSum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( prefixSum [ i ] , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4685_A", "sol": 0, "python_code": "def printPermutation ( N , K ) :\n    res = list ( ) ;\n    l , r , flag = 1 , N , 0\n    for i in range ( K ) :\n        if flag == False :\n            res.append ( l )\n            l += 1\n        else :\n            res.append ( r ) ;\n            r -= 1 ;\n        flag = flag ^ 1 ;\n    if flag == False :\n        for i in range ( r , 2 , - 1 ) :\n            res.append ( i )\n    else :\n        for i in range ( l , r ) :\n            res.append ( i )\n    for i in res :\n        print ( i , end = \" \" )\nN , K = 10 , 4\nprintPermutation ( N , K )\n", "python_code_tokenized": "def printPermutation ( N , K ) : NEW_LINE INDENT res = list ( ) ; NEW_LINE l , r , flag = 1 , N , 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT if flag == False : NEW_LINE INDENT res . append ( l ) NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( r ) ; NEW_LINE r -= 1 ; NEW_LINE DEDENT flag = flag ^ 1 ; NEW_LINE DEDENT if flag == False : NEW_LINE INDENT for i in range ( r , 2 , - 1 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( l , r ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT for i in res : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT N , K = 10 , 4 NEW_LINE printPermutation ( N , K ) NEW_LINE"}
{"id": "geeksforgeeks_1998_A", "sol": 0, "python_code": "def computeTotient ( n ) :\n    phi = [ ]\n    for i in range ( n + 2 ) :\n        phi.append ( 0 )\n    for i in range ( 1 , n + 1 ) :\n        phi [ i ] = i\n    for p in range ( 2 , n + 1 ) :\n        if ( phi [ p ] == p ) :\n            phi [ p ] = p - 1\n            for i in range ( 2 * p , n + 1 , p ) :\n                phi [ i ] = ( phi [ i ] // p ) * ( p - 1 )\n    for i in range ( 1 , n + 1 ) :\n        print ( \"Totient of \" , i , \" is \" , phi [ i ] )\nn = 12\ncomputeTotient ( n )\n", "python_code_tokenized": "def computeTotient ( n ) : NEW_LINE INDENT phi = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT phi . append ( 0 ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( \" Totient \u2581 of \u2581 \" , i , \" \u2581 is \u2581 \" , phi [ i ] ) NEW_LINE DEDENT DEDENT n = 12 NEW_LINE computeTotient ( n ) NEW_LINE"}
{"id": "atcoder_ABC052_A", "sol": 0, "python_code": "a , b , c , d = map ( int , input ( ).split ( ) )\nprint ( max ( a * b , c * d ) )\n", "python_code_tokenized": "a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( a * b , c * d ) ) NEW_LINE"}
{"id": "geeksforgeeks_1241_A", "sol": 0, "python_code": "def ellipse ( l , b ) :\n    if l < 0 or b < 0 :\n        return - 1\n    x = ( 3.14 * l * b ) / 4\n    return x\nif __name__ == \"__main__\" :\n    l , b = 5 , 3\n    print ( ellipse ( l , b ) )\n", "python_code_tokenized": "def ellipse ( l , b ) : NEW_LINE INDENT if l < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( 3.14 * l * b ) / 4 NEW_LINE return x NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l , b = 5 , 3 NEW_LINE print ( ellipse ( l , b ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1706_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    n = int ( input ( ) )\n    c = list ( map ( int , input ( ).split ( ) ) )\n    d = { }\n    for i in range ( n ) :\n        if d.get ( c [ i ] , None ) is None :\n            d [ c [ i ] ] = [ 1 , i % 2 ]\n        elif d [ c [ i ] ] [ 1 ] != i % 2 :\n            d [ c [ i ] ] [ 0 ] += 1\n            d [ c [ i ] ] [ 1 ] ^= 1\n    print ( * ( d.get ( i , [ 0 ] ) [ 0 ] for i in range ( 1 , n + 1 ) ) )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if d . get ( c [ i ] , None ) is None : NEW_LINE INDENT d [ c [ i ] ] = [ 1 , i % 2 ] NEW_LINE DEDENT elif d [ c [ i ] ] [ 1 ] != i % 2 : NEW_LINE INDENT d [ c [ i ] ] [ 0 ] += 1 NEW_LINE d [ c [ i ] ] [ 1 ] ^= 1 NEW_LINE DEDENT DEDENT print ( * ( d . get ( i , [ 0 ] ) [ 0 ] for i in range ( 1 , n + 1 ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1194_A", "sol": 0, "python_code": "def last_digit ( X , Y ) :\n    print ( X % Y ) ;\nif __name__ == \"__main__\" :\n    X = 55 ; Y = 3 ;\n    last_digit ( X , Y ) ;\n", "python_code_tokenized": "def last_digit ( X , Y ) : NEW_LINE INDENT print ( X % Y ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 55 ; Y = 3 ; NEW_LINE last_digit ( X , Y ) ; NEW_LINE DEDENT"}
{"id": "codeforces_24_B", "sol": 0, "python_code": "D , points = { } , [ 25 , 18 , 15 , 12 , 10 , 8 , 6 , 4 , 2 , 1 ] + [ 0 ] * 50\nfor tour in range ( int ( input ( ) ) ) :\n    for j in range ( int ( input ( ) ) ) :\n        player = str ( input ( ) )\n        if player not in D :\n            D [ player ] = [ 0 ] * 51 + [ player ]\n        D [ player ] [ 0 ] += points [ j ]\n        D [ player ] [ j + 1 ] += 1\nwin = D.values ( )\nprint ( sorted ( win ) [ - 1 ] [ - 1 ] )\nwin = [ [ p [ 1 ] ] + p for p in win ]\nprint ( sorted ( win ) [ - 1 ] [ - 1 ] )\n", "python_code_tokenized": "D , points = { } , [ 25 , 18 , 15 , 12 , 10 , 8 , 6 , 4 , 2 , 1 ] + [ 0 ] * 50 NEW_LINE for tour in range ( int ( input ( ) ) ) : NEW_LINE INDENT for j in range ( int ( input ( ) ) ) : NEW_LINE INDENT player = str ( input ( ) ) NEW_LINE if player not in D : NEW_LINE INDENT D [ player ] = [ 0 ] * 51 + [ player ] NEW_LINE DEDENT D [ player ] [ 0 ] += points [ j ] NEW_LINE D [ player ] [ j + 1 ] += 1 NEW_LINE DEDENT DEDENT win = D . values ( ) NEW_LINE print ( sorted ( win ) [ - 1 ] [ - 1 ] ) NEW_LINE win = [ [ p [ 1 ] ] + p for p in win ] NEW_LINE print ( sorted ( win ) [ - 1 ] [ - 1 ] ) NEW_LINE"}
{"id": "codejam_14_01", "sol": 0, "python_code": "from util import *\ndef main ( ) :\n    r = reader ( \"input\" )\n    num = int ( r.next ( ) )\n    ans = [ ]\n    for i in xrange ( num ) :\n        g1 = int ( r.next ( ) )\n        row1 = [ ]\n        for j in xrange ( 4 ) :\n            if j == g1 - 1 :\n                row1 = map ( int , r.next ( ).split ( \" \" ) )\n            else :\n                r.next ( )\n        g2 = int ( r.next ( ) )\n        row2 = [ ]\n        for j in xrange ( 4 ) :\n            if j == g2 - 1 :\n                row2 = map ( int , r.next ( ).split ( \" \" ) )\n            else :\n                r.next ( )\n        intersection = [ x for x in row1 if x in row2 ]\n        if len ( intersection ) == 0 :\n            ans.append ( \"Volunteer cheated!\" )\n        elif len ( intersection ) == 1 :\n            ans.append ( intersection [ 0 ] )\n        else :\n            ans.append ( \"Bad magician!\" )\n    write ( \"output\" , ans )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "from util import * NEW_LINE def main ( ) : NEW_LINE INDENT r = reader ( \" input \" ) NEW_LINE num = int ( r . next ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in xrange ( num ) : NEW_LINE INDENT g1 = int ( r . next ( ) ) NEW_LINE row1 = [ ] NEW_LINE for j in xrange ( 4 ) : NEW_LINE INDENT if j == g1 - 1 : NEW_LINE INDENT row1 = map ( int , r . next ( ) . split ( \" \u2581 \" ) ) NEW_LINE DEDENT else : NEW_LINE INDENT r . next ( ) NEW_LINE DEDENT DEDENT g2 = int ( r . next ( ) ) NEW_LINE row2 = [ ] NEW_LINE for j in xrange ( 4 ) : NEW_LINE INDENT if j == g2 - 1 : NEW_LINE INDENT row2 = map ( int , r . next ( ) . split ( \" \u2581 \" ) ) NEW_LINE DEDENT else : NEW_LINE INDENT r . next ( ) NEW_LINE DEDENT DEDENT intersection = [ x for x in row1 if x in row2 ] NEW_LINE if len ( intersection ) == 0 : NEW_LINE INDENT ans . append ( \" Volunteer \u2581 cheated ! \" ) NEW_LINE DEDENT elif len ( intersection ) == 1 : NEW_LINE INDENT ans . append ( intersection [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( \" Bad \u2581 magician ! \" ) NEW_LINE DEDENT DEDENT write ( \" output \" , ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_813_A", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nn = int ( input ( ) )\nx = sum ( map ( int , input ( ).split ( ) ) )\nm = int ( input ( ) )\nc = 0\ng = sorted ( [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( m ) ] , key = lambda x : x [ 1 ] )\nfor i in g :\n    if x <= i [ 1 ] :\n        print ( max ( x , i [ 0 ] ) )\n        break\nelse :\n    print ( - 1 )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE x = sum ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE c = 0 NEW_LINE g = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] , key = lambda x : x [ 1 ] ) NEW_LINE for i in g : NEW_LINE INDENT if x <= i [ 1 ] : NEW_LINE INDENT print ( max ( x , i [ 0 ] ) ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"}
{"id": "codeforces_1498_A", "sol": 0, "python_code": "from math import gcd\nfor _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    while gcd ( n , sum ( [ ord ( i ) - ord ( '0' ) for i in str ( n ) ] ) ) == 1 :\n        n += 1\n    print ( n )\n", "python_code_tokenized": "from math import gcd NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE while gcd ( n , sum ( [ ord ( i ) - ord ( '0' ) for i in str ( n ) ] ) ) == 1 : NEW_LINE INDENT n += 1 NEW_LINE DEDENT print ( n ) NEW_LINE DEDENT"}
{"id": "atcoder_ARC073_A", "sol": 0, "python_code": "def main ( ) :\n    line = input ( )\n    line = line.split ( ' ' )\n    n = int ( line [ 0 ] )\n    t = int ( line [ 1 ] )\n    line = input ( )\n    line = line.split ( ' ' )\n    total = 0\n    for i in range ( 1 , n ) :\n        total += min ( t , int ( line [ i ] ) - int ( line [ i - 1 ] ) )\n    print ( total + t )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT line = input ( ) NEW_LINE line = line . split ( ' \u2581 ' ) NEW_LINE n = int ( line [ 0 ] ) NEW_LINE t = int ( line [ 1 ] ) NEW_LINE line = input ( ) NEW_LINE line = line . split ( ' \u2581 ' ) NEW_LINE total = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT total += min ( t , int ( line [ i ] ) - int ( line [ i - 1 ] ) ) NEW_LINE DEDENT print ( total + t ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_26_A", "sol": 0, "python_code": "def uniqueNumbers ( arr , n ) :\n    arr.sort ( )\n    freq = [ 0 ] * ( n + 2 )\n    for val in arr :\n        if ( freq [ val - 1 ] == 0 ) :\n            freq [ val - 1 ] += 1\n        elif ( freq [ val ] == 0 ) :\n            freq [ val ] += 1\n        else :\n            freq [ val + 1 ] += 1\n    unique = 0\n    for val in freq :\n        if ( val > 0 ) :\n            unique += 1\n    return unique\nif __name__ == \"__main__\" :\n    arr = [ 3 , 3 , 3 , 3 ]\n    n = 4\n    print ( uniqueNumbers ( arr , n ) )\n", "python_code_tokenized": "def uniqueNumbers ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE freq = [ 0 ] * ( n + 2 ) NEW_LINE for val in arr : NEW_LINE INDENT if ( freq [ val - 1 ] == 0 ) : NEW_LINE INDENT freq [ val - 1 ] += 1 NEW_LINE DEDENT elif ( freq [ val ] == 0 ) : NEW_LINE INDENT freq [ val ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ val + 1 ] += 1 NEW_LINE DEDENT DEDENT unique = 0 NEW_LINE for val in freq : NEW_LINE INDENT if ( val > 0 ) : NEW_LINE INDENT unique += 1 NEW_LINE DEDENT DEDENT return unique NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 3 , 3 ] NEW_LINE n = 4 NEW_LINE print ( uniqueNumbers ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_712_B", "sol": 0, "python_code": "s = input ( )\nx = s.count ( \"R\" ) - s.count ( \"L\" )\ny = s.count ( \"U\" ) - s.count ( \"D\" )\nif x % 2 == 0 and y % 2 == 0 or x % 2 != 0 and y % 2 != 0 :\n    print ( ( abs ( x ) + abs ( y ) ) // 2 )\nelse :\n    print ( - 1 )\n", "python_code_tokenized": "s = input ( ) NEW_LINE x = s . count ( \" R \" ) - s . count ( \" L \" ) NEW_LINE y = s . count ( \" U \" ) - s . count ( \" D \" ) NEW_LINE if x % 2 == 0 and y % 2 == 0 or x % 2 != 0 and y % 2 != 0 : NEW_LINE INDENT print ( ( abs ( x ) + abs ( y ) ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"}
{"id": "codeforces_1177_B", "sol": 0, "python_code": "k = int ( input ( ) )\ns = 0\ndigits = 1\nwhile s + digits * 9 * 10 ** ( digits - 1 ) < k :\n    s += digits * 9 * 10 ** ( digits - 1 )\n    digits += 1\ncnt = ( k - s - 1 ) // digits\ns += cnt * digits\nn = 10 ** ( digits - 1 ) + cnt\nprint ( str ( n ) [ k - s - 1 ] )\n", "python_code_tokenized": "k = int ( input ( ) ) NEW_LINE s = 0 NEW_LINE digits = 1 NEW_LINE while s + digits * 9 * 10 ** ( digits - 1 ) < k : NEW_LINE INDENT s += digits * 9 * 10 ** ( digits - 1 ) NEW_LINE digits += 1 NEW_LINE DEDENT cnt = ( k - s - 1 ) // digits NEW_LINE s += cnt * digits NEW_LINE n = 10 ** ( digits - 1 ) + cnt NEW_LINE print ( str ( n ) [ k - s - 1 ] ) NEW_LINE"}
{"id": "geeksforgeeks_4372_A", "sol": 0, "python_code": "def reverse ( arr , n , k ) :\n    for i in range ( 0 , n , 2 * k ) :\n        left = i\n        right = min ( i + k - 1 , n - 1 )\n        while ( left < right ) :\n            temp = arr [ left ]\n            arr [ left ] = arr [ right ]\n            arr [ right ] = temp\n            left += 1\n            right -= 1\nif __name__ == '__main__' :\n    arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ]\n    k = 3\n    n = len ( arr )\n    reverse ( arr , n , k )\n    for i in range ( 0 , n , 1 ) :\n        print ( arr [ i ] , end = \" \" )\n", "python_code_tokenized": "def reverse ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n , 2 * k ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE while ( left < right ) : NEW_LINE INDENT temp = arr [ left ] NEW_LINE arr [ left ] = arr [ right ] NEW_LINE arr [ right ] = temp NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4368_A", "sol": 0, "python_code": "def reverse ( arr , n , k ) :\n    i = 0\n    while ( i < n ) :\n        left = i\n        right = min ( i + k - 1 , n - 1 )\n        while ( left < right ) :\n            arr [ left ] , arr [ right ] = arr [ right ] , arr [ left ]\n            left += 1 ;\n            right - + 1\n        i += k\narr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]\nk = 3\nn = len ( arr )\nreverse ( arr , n , k )\nfor i in range ( 0 , n ) :\n    print ( arr [ i ] , end = \" \" )\n", "python_code_tokenized": "def reverse ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT left = i NEW_LINE right = min ( i + k - 1 , n - 1 ) NEW_LINE while ( left < right ) : NEW_LINE INDENT arr [ left ] , arr [ right ] = arr [ right ] , arr [ left ] NEW_LINE left += 1 ; NEW_LINE right - + 1 NEW_LINE DEDENT i += k NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE reverse ( arr , n , k ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4373_A", "sol": 0, "python_code": "def reverse ( arr , n , k , m ) :\n    for i in range ( 0 , n , k + m ) :\n        left = i ;\n        right = min ( i + k - 1 , n - 1 ) ;\n        while ( left < right ) :\n            arr = swap ( arr , left , right ) ;\n            left += 1 ;\n            right -= 1 ;\n    return arr ;\ndef swap ( arr , i , j ) :\n    temp = arr [ i ] ;\n    arr [ i ] = arr [ j ] ;\n    arr [ j ] = temp ;\n    return arr ;\narr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] ;\nk = 3 ;\nm = 2 ;\nn = len ( arr ) ;\narr = reverse ( arr , n , k , m ) ;\nfor i in range ( 0 , n ) :\n    print ( arr [ i ] , end = \" \" ) ;\n", "python_code_tokenized": "def reverse ( arr , n , k , m ) : NEW_LINE INDENT for i in range ( 0 , n , k + m ) : NEW_LINE INDENT left = i ; NEW_LINE right = min ( i + k - 1 , n - 1 ) ; NEW_LINE while ( left < right ) : NEW_LINE INDENT arr = swap ( arr , left , right ) ; NEW_LINE left += 1 ; NEW_LINE right -= 1 ; NEW_LINE DEDENT DEDENT return arr ; NEW_LINE DEDENT def swap ( arr , i , j ) : NEW_LINE INDENT temp = arr [ i ] ; NEW_LINE arr [ i ] = arr [ j ] ; NEW_LINE arr [ j ] = temp ; NEW_LINE return arr ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ] ; NEW_LINE k = 3 ; NEW_LINE m = 2 ; NEW_LINE n = len ( arr ) ; NEW_LINE arr = reverse ( arr , n , k , m ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4344_A", "sol": 0, "python_code": "import numpy as np\nimport sys\nRODS = 3\nN = 3\ndp = np.zeros ( ( N + 1 , RODS + 1 , RODS + 1 ) ) ;\ndef initialize ( ) :\n    for i in range ( N + 1 ) :\n        for j in range ( 1 , RODS + 1 ) :\n            for k in range ( 1 , RODS + 1 ) :\n                dp [ i ] [ j ] [ k ] = sys.maxsize ;\ndef mincost ( idx , src , dest , costs ) :\n    if ( idx > N ) :\n        return 0 ;\n    if ( dp [ idx ] [ src ] [ dest ] != sys.maxsize ) :\n        return dp [ idx ] [ src ] [ dest ] ;\n    rem = 6 - ( src + dest ) ;\n    ans = sys.maxsize ;\n    case1 = costs [ src - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , rem , costs ) + mincost ( idx + 1 , rem , dest , costs ) ;\n    case2 = ( costs [ src - 1 ] [ rem - 1 ] + mincost ( idx + 1 , src , dest , costs ) + mincost ( idx + 1 , dest , src , costs ) + costs [ rem - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , dest , costs ) ) ;\n    ans = min ( case1 , case2 ) ;\n    dp [ idx ] [ src ] [ dest ] = ans ;\n    return ans ;\nif __name__ == \"__main__\" :\n    costs = [ [ 0 , 1 , 2 ] , [ 2 , 0 , 1 ] , [ 3 , 2 , 0 ] ] ;\n    initialize ( ) ;\n    print ( mincost ( 1 , 1 , 3 , costs ) ) ;\n", "python_code_tokenized": "import numpy as np NEW_LINE import sys NEW_LINE RODS = 3 NEW_LINE N = 3 NEW_LINE dp = np . zeros ( ( N + 1 , RODS + 1 , RODS + 1 ) ) ; NEW_LINE def initialize ( ) : NEW_LINE INDENT for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( 1 , RODS + 1 ) : NEW_LINE INDENT for k in range ( 1 , RODS + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = sys . maxsize ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def mincost ( idx , src , dest , costs ) : NEW_LINE INDENT if ( idx > N ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ idx ] [ src ] [ dest ] != sys . maxsize ) : NEW_LINE INDENT return dp [ idx ] [ src ] [ dest ] ; NEW_LINE DEDENT rem = 6 - ( src + dest ) ; NEW_LINE ans = sys . maxsize ; NEW_LINE case1 = costs [ src - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , rem , costs ) + mincost ( idx + 1 , rem , dest , costs ) ; NEW_LINE case2 = ( costs [ src - 1 ] [ rem - 1 ] + mincost ( idx + 1 , src , dest , costs ) + mincost ( idx + 1 , dest , src , costs ) + costs [ rem - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , dest , costs ) ) ; NEW_LINE ans = min ( case1 , case2 ) ; NEW_LINE dp [ idx ] [ src ] [ dest ] = ans ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT costs = [ [ 0 , 1 , 2 ] , [ 2 , 0 , 1 ] , [ 3 , 2 , 0 ] ] ; NEW_LINE initialize ( ) ; NEW_LINE print ( mincost ( 1 , 1 , 3 , costs ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4836_A", "sol": 0, "python_code": "from math import sqrt\ndef isPrime ( n ) :\n    if ( n <= 1 ) :\n        return False\n    if ( n <= 3 ) :\n        return True\n    if ( n % 2 == 0 or n % 3 == 0 ) :\n        return False\n    k = int ( sqrt ( n ) ) + 1\n    for i in range ( 5 , k , 6 ) :\n        if ( n % i == 0 or n % ( i + 2 ) == 0 ) :\n            return False\n    return True\ndef isThreeDisctFactors ( n ) :\n    sq = int ( sqrt ( n ) )\n    if ( 1 * sq * sq != n ) :\n        return False\n    if ( isPrime ( sq ) ) :\n        return True\n    else :\n        return False\nif __name__ == '__main__' :\n    num = 9\n    if ( isThreeDisctFactors ( num ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n    num = 15\n    if ( isThreeDisctFactors ( num ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n    num = 12397923568441\n    if ( isThreeDisctFactors ( num ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT k = int ( sqrt ( n ) ) + 1 NEW_LINE for i in range ( 5 , k , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isThreeDisctFactors ( n ) : NEW_LINE INDENT sq = int ( sqrt ( n ) ) NEW_LINE if ( 1 * sq * sq != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( isPrime ( sq ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 9 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT num = 15 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT num = 12397923568441 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3019_A", "sol": 0, "python_code": "def factorial ( n ) :\n    if ( n == 0 ) :\n        return 1\n    return n * factorial ( n - 1 )\ndef LCMOfNeighbourFact ( n ) :\n    return factorial ( n + 1 )\nN = 5\nprint ( LCMOfNeighbourFact ( N ) )\n", "python_code_tokenized": "def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT def LCMOfNeighbourFact ( n ) : NEW_LINE INDENT return factorial ( n + 1 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( LCMOfNeighbourFact ( N ) ) NEW_LINE"}
{"id": "geeksforgeeks_2929_A", "sol": 0, "python_code": "import math as m\ndef findMin ( a , n ) :\n    _sum = 0\n    for i in range ( n ) :\n        _sum += m.log ( a [ i ] )\n    x = m.exp ( _sum / n )\n    return int ( x + 1 )\na = [ 3 , 2 , 1 , 4 ]\nn = len ( a )\nprint ( findMin ( a , n ) )\n", "python_code_tokenized": "import math as m NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT _sum += m . log ( a [ i ] ) NEW_LINE DEDENT x = m . exp ( _sum / n ) NEW_LINE return int ( x + 1 ) NEW_LINE DEDENT a = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMin ( a , n ) ) NEW_LINE"}
{"id": "codeforces_447_A", "sol": 0, "python_code": "p , n = map ( int , input ( ).split ( ) )\nlisty = [ ]\nfor i in range ( n ) :\n    listy.append ( int ( input ( ) ) )\ndef solve ( listy , p ) :\n    dicty = { }\n    for i in range ( n ) :\n        mod = listy [ i ] % p\n        if mod in dicty.values ( ) :\n            return i + 1\n        else :\n            dicty.update ( { i : mod } )\n    return - 1\nprint ( solve ( listy , p ) )\n", "python_code_tokenized": "p , n = map ( int , input ( ) . split ( ) ) NEW_LINE listy = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT listy . append ( int ( input ( ) ) ) NEW_LINE DEDENT def solve ( listy , p ) : NEW_LINE INDENT dicty = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mod = listy [ i ] % p NEW_LINE if mod in dicty . values ( ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dicty . update ( { i : mod } ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT print ( solve ( listy , p ) ) NEW_LINE"}
{"id": "atcoder_ABC118_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\nif b % a == 0 : print ( a + b )\nelse : print ( b - a )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b % a == 0 : print ( a + b ) NEW_LINE else : print ( b - a ) NEW_LINE"}
{"id": "geeksforgeeks_3614_A", "sol": 0, "python_code": "def pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) :\n    fx1 = 0\n    fx2 = 0\n    fx1 = a * x1 + b * y1 - c\n    fx2 = a * x2 + b * y2 - c\n    if ( ( fx1 * fx2 ) > 0 ) :\n        return True\n    return False\na , b , c = 1 , 1 , 1\nx1 , y1 = 1 , 1\nx2 , y2 = 2 , 1\nif ( pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT fx1 = 0 NEW_LINE fx2 = 0 NEW_LINE fx1 = a * x1 + b * y1 - c NEW_LINE fx2 = a * x2 + b * y2 - c NEW_LINE if ( ( fx1 * fx2 ) > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a , b , c = 1 , 1 , 1 NEW_LINE x1 , y1 = 1 , 1 NEW_LINE x2 , y2 = 2 , 1 NEW_LINE if ( pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2303_A", "sol": 0, "python_code": "def count_minimum_operations ( n ) :\n    count = 0\n    while ( n > 1 ) :\n        if ( n % 3 == 0 ) :\n            n //= 3\n        elif ( n % 3 == 1 ) :\n            n -= 1\n        else :\n            if ( n == 2 ) :\n                n -= 1\n            else :\n                n += 1\n        count += 1\n    return count\nif __name__ == \"__main__\" :\n    n = 4\n    ans = count_minimum_operations ( n )\n    print ( ans )\n", "python_code_tokenized": "def count_minimum_operations ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 1 ) : NEW_LINE INDENT if ( n % 3 == 0 ) : NEW_LINE INDENT n //= 3 NEW_LINE DEDENT elif ( n % 3 == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT n += 1 NEW_LINE DEDENT DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE ans = count_minimum_operations ( n ) NEW_LINE print ( ans ) NEW_LINE DEDENT"}
{"id": "codeforces_978_A", "sol": 0, "python_code": "n = int ( input ( ) )\nnums = [ int ( x ) for x in input ( ).split ( ) ]\nans = [ ]\nfor i in reversed ( nums ) :\n    if i not in ans :\n        ans.append ( i )\nprint ( len ( ans ) )\nfor i in reversed ( ans ) :\n    print ( i , end = ' ' )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE nums = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = [ ] NEW_LINE for i in reversed ( nums ) : NEW_LINE INDENT if i not in ans : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE for i in reversed ( ans ) : NEW_LINE INDENT print ( i , end = ' \u2581 ' ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC102_A", "sol": 0, "python_code": "import fractions\ndef lcm ( a , b ) :\n    return ( a * b ) // fractions.gcd ( a , b )\nN = int ( input ( ) )\nprint ( lcm ( 2 , N ) )\n", "python_code_tokenized": "import fractions NEW_LINE def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // fractions . gcd ( a , b ) NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE print ( lcm ( 2 , N ) ) NEW_LINE"}
{"id": "geeksforgeeks_1150_A", "sol": 0, "python_code": "import sys\ndef minBroadcastRange ( houses , towers , n , m ) :\n    leftTower = - sys.maxsize - 1\n    rightTower = towers [ 0 ]\n    j , k = 0 , 0\n    min_range = 0\n    while ( j < n ) :\n        if ( houses [ j ] < rightTower ) :\n            left = houses [ j ] - leftTower\n            right = rightTower - houses [ j ]\n            if left < right :\n                local_max = left\n            else :\n                local_max = right\n            if ( local_max > min_range ) :\n                min_range = local_max\n            j += 1\n        else :\n            leftTower = towers [ k ]\n            if ( k < m - 1 ) :\n                k += 1\n                rightTower = towers [ k ]\n            else :\n                rightTower = sys.maxsize\n    return min_range\nif __name__ == \"__main__\" :\n    a = [ 12 , 13 , 11 , 80 ]\n    b = [ 4 , 6 , 15 , 60 ]\n    n = len ( a )\n    m = len ( b )\n    max = minBroadcastRange ( a , b , n , m )\n    print ( max )\n", "python_code_tokenized": "import sys NEW_LINE def minBroadcastRange ( houses , towers , n , m ) : NEW_LINE INDENT leftTower = - sys . maxsize - 1 NEW_LINE rightTower = towers [ 0 ] NEW_LINE j , k = 0 , 0 NEW_LINE min_range = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( houses [ j ] < rightTower ) : NEW_LINE INDENT left = houses [ j ] - leftTower NEW_LINE right = rightTower - houses [ j ] NEW_LINE if left < right : NEW_LINE INDENT local_max = left NEW_LINE DEDENT else : NEW_LINE INDENT local_max = right NEW_LINE DEDENT if ( local_max > min_range ) : NEW_LINE INDENT min_range = local_max NEW_LINE DEDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT leftTower = towers [ k ] NEW_LINE if ( k < m - 1 ) : NEW_LINE INDENT k += 1 NEW_LINE rightTower = towers [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT rightTower = sys . maxsize NEW_LINE DEDENT DEDENT DEDENT return min_range NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 12 , 13 , 11 , 80 ] NEW_LINE b = [ 4 , 6 , 15 , 60 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE max = minBroadcastRange ( a , b , n , m ) NEW_LINE print ( max ) NEW_LINE DEDENT"}
{"id": "codeforces_1709_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor z in range ( t ) :\n    f = 0\n    x = int ( input ( ) )\n    a , b , c = map ( int , input ( ).split ( ) )\n    for y in range ( 2 ) :\n        if x == 1 :\n            if a == 0 :\n                print ( 'NO' )\n                break\n            else :\n                x = a\n                f += 1\n        elif x == 2 :\n            if b == 0 :\n                print ( 'NO' )\n                break\n            else :\n                x = b\n                f += 1\n        else :\n            if c == 0 :\n                print ( 'NO' )\n                break\n            else :\n                x = c\n                f += 1\n    if f == 2 :\n        print ( 'YES' )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for z in range ( t ) : NEW_LINE INDENT f = 0 NEW_LINE x = int ( input ( ) ) NEW_LINE a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE for y in range ( 2 ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT x = a NEW_LINE f += 1 NEW_LINE DEDENT DEDENT elif x == 2 : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT x = b NEW_LINE f += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if c == 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT x = c NEW_LINE f += 1 NEW_LINE DEDENT DEDENT DEDENT if f == 2 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1892_A", "sol": 0, "python_code": "def maxOperations ( str ) :\n    i , g , gk , gks = 0 , 0 , 0 , 0\n    for i in range ( len ( str ) ) :\n        if ( str [ i ] == 'g' ) :\n            g += 1\n        elif ( str [ i ] == 'k' ) :\n            if ( g > 0 ) :\n                g -= 1\n                gk += 1\n        elif ( str [ i ] == 's' ) :\n            if ( gk > 0 ) :\n                gk -= 1\n                gks += 1\n    return gks\nif __name__ == \"__main__\" :\n    a = \"ggkssk\"\n    print ( maxOperations ( a ) )\n", "python_code_tokenized": "def maxOperations ( str ) : NEW_LINE INDENT i , g , gk , gks = 0 , 0 , 0 , 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' g ' ) : NEW_LINE INDENT g += 1 NEW_LINE DEDENT elif ( str [ i ] == ' k ' ) : NEW_LINE INDENT if ( g > 0 ) : NEW_LINE INDENT g -= 1 NEW_LINE gk += 1 NEW_LINE DEDENT DEDENT elif ( str [ i ] == ' s ' ) : NEW_LINE INDENT if ( gk > 0 ) : NEW_LINE INDENT gk -= 1 NEW_LINE gks += 1 NEW_LINE DEDENT DEDENT DEDENT return gks NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = \" ggkssk \" NEW_LINE print ( maxOperations ( a ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3936_A", "sol": 0, "python_code": "def isPossibleToZero ( a , n ) :\n    even = 0 ;\n    odd = 0 ;\n    for i in range ( n ) :\n        if ( i & 1 ) :\n            odd += a [ i ] ;\n        else :\n            even += a [ i ] ;\n    return ( odd == even ) ;\narr = [ 0 , 1 , 1 , 0 ] ;\nn = len ( arr ) ;\nif ( isPossibleToZero ( arr , n ) ) :\n    print ( \"YES\" ) ;\nelse :\n    print ( \"NO\" ) ;\n", "python_code_tokenized": "def isPossibleToZero ( a , n ) : NEW_LINE INDENT even = 0 ; NEW_LINE odd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT odd += a [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT even += a [ i ] ; NEW_LINE DEDENT DEDENT return ( odd == even ) ; NEW_LINE DEDENT arr = [ 0 , 1 , 1 , 0 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( isPossibleToZero ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1957_A", "sol": 0, "python_code": "def digitDividesK ( num , k ) :\n    while ( num ) :\n        d = num % 10\n        if ( d != 0 and k % d == 0 ) :\n            return True\n        num = num // 10\n    return False\ndef findCount ( l , r , k ) :\n    count = 0\n    for i in range ( l , r + 1 ) :\n        if ( digitDividesK ( i , k ) ) :\n            count += 1\n    return count\nl = 20\nr = 35\nk = 45\nprint ( findCount ( l , r , k ) )\n", "python_code_tokenized": "def digitDividesK ( num , k ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT d = num % 10 NEW_LINE if ( d != 0 and k % d == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT num = num // 10 NEW_LINE DEDENT return False NEW_LINE DEDENT def findCount ( l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( digitDividesK ( i , k ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT l = 20 NEW_LINE r = 35 NEW_LINE k = 45 NEW_LINE print ( findCount ( l , r , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_772_A", "sol": 0, "python_code": "from math import sqrt\ndef findRoots ( b , c ) :\n    a = 1\n    d = b * b - 4 * a * c\n    sqrt_val = sqrt ( abs ( d ) )\n    if ( d > 0 ) :\n        x = - b + sqrt_val\n        y = - b - sqrt_val\n        root1 = ( x ) // ( 2 * a )\n        root2 = ( y ) // ( 2 * a )\n        if ( root1 + root2 == - 1 * b and root1 * root2 == c ) :\n            print ( int ( root1 ) , \",\" , int ( root2 ) )\n        else :\n            print ( - 1 )\n    elif ( d == 0 ) :\n        root = - b // ( 2 * a )\n        if ( root + root == - 1 * b and root * root == c ) :\n            print ( root , \",\" , root )\n        else :\n            print ( - 1 )\n    else :\n        print ( - 1 )\nif __name__ == '__main__' :\n    S = 5\n    P = 6\n    findRoots ( - S , P )\n    S = 5\n    P = 9\n    findRoots ( - S , P )\n", "python_code_tokenized": "from math import sqrt NEW_LINE def findRoots ( b , c ) : NEW_LINE INDENT a = 1 NEW_LINE d = b * b - 4 * a * c NEW_LINE sqrt_val = sqrt ( abs ( d ) ) NEW_LINE if ( d > 0 ) : NEW_LINE INDENT x = - b + sqrt_val NEW_LINE y = - b - sqrt_val NEW_LINE root1 = ( x ) // ( 2 * a ) NEW_LINE root2 = ( y ) // ( 2 * a ) NEW_LINE if ( root1 + root2 == - 1 * b and root1 * root2 == c ) : NEW_LINE INDENT print ( int ( root1 ) , \" , \" , int ( root2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT elif ( d == 0 ) : NEW_LINE INDENT root = - b // ( 2 * a ) NEW_LINE if ( root + root == - 1 * b and root * root == c ) : NEW_LINE INDENT print ( root , \" , \" , root ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = 5 NEW_LINE P = 6 NEW_LINE findRoots ( - S , P ) NEW_LINE S = 5 NEW_LINE P = 9 NEW_LINE findRoots ( - S , P ) NEW_LINE DEDENT"}
{"id": "codeforces_373_B", "sol": 0, "python_code": "import sys\ndef main ( lines ) :\n    w , m , k = list ( map ( int , lines [ 0 ].split ( ) ) )\n    max_length = 0\n    available_digits = int ( w / k )\n    while available_digits > 0 :\n        current_cost_per_n = len ( str ( m ) )\n        same_cost_until = 10 ** ( current_cost_per_n )\n        usable_numbers = same_cost_until - m\n        use_digits = usable_numbers * current_cost_per_n\n        m = same_cost_until\n        if available_digits >= use_digits :\n            max_length += usable_numbers\n            available_digits -= use_digits\n        else :\n            max_length += int ( available_digits / current_cost_per_n )\n            available_digits = 0\n    print ( max_length )\nif __name__ == \"__main__\" :\n    main ( sys.stdin.readlines ( ) )\n", "python_code_tokenized": "import sys NEW_LINE def main ( lines ) : NEW_LINE INDENT w , m , k = list ( map ( int , lines [ 0 ] . split ( ) ) ) NEW_LINE max_length = 0 NEW_LINE available_digits = int ( w / k ) NEW_LINE while available_digits > 0 : NEW_LINE INDENT current_cost_per_n = len ( str ( m ) ) NEW_LINE same_cost_until = 10 ** ( current_cost_per_n ) NEW_LINE usable_numbers = same_cost_until - m NEW_LINE use_digits = usable_numbers * current_cost_per_n NEW_LINE m = same_cost_until NEW_LINE if available_digits >= use_digits : NEW_LINE INDENT max_length += usable_numbers NEW_LINE available_digits -= use_digits NEW_LINE DEDENT else : NEW_LINE INDENT max_length += int ( available_digits / current_cost_per_n ) NEW_LINE available_digits = 0 NEW_LINE DEDENT DEDENT print ( max_length ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( sys . stdin . readlines ( ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC045_B", "sol": 0, "python_code": "s = [ list ( input ( ) ) for _ in range ( 3 ) ]\np = 1\nwhile True :\n    if len ( s [ p - 1 ] ) == 0 :\n        break\n    c = s [ p - 1 ].pop ( 0 )\n    if c == 'a' :\n        p = 1\n    elif c == 'b' :\n        p = 2\n    else :\n        p = 3\nif p == 1 :\n    print ( 'A' )\nelif p == 2 :\n    print ( 'B' )\nelif p == 3 :\n    print ( 'C' )\n", "python_code_tokenized": "s = [ list ( input ( ) ) for _ in range ( 3 ) ] NEW_LINE p = 1 NEW_LINE while True : NEW_LINE INDENT if len ( s [ p - 1 ] ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT c = s [ p - 1 ] . pop ( 0 ) NEW_LINE if c == ' a ' : NEW_LINE INDENT p = 1 NEW_LINE DEDENT elif c == ' b ' : NEW_LINE INDENT p = 2 NEW_LINE DEDENT else : NEW_LINE INDENT p = 3 NEW_LINE DEDENT DEDENT if p == 1 : NEW_LINE INDENT print ( ' A ' ) NEW_LINE DEDENT elif p == 2 : NEW_LINE INDENT print ( ' B ' ) NEW_LINE DEDENT elif p == 3 : NEW_LINE INDENT print ( ' C ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4370_A", "sol": 0, "python_code": "def reverseArray ( arr , n ) :\n    import sys\n    x = - sys.maxsize // sys.maxsize\n    for i in range ( n // 2 ) :\n        arr [ i ] , arr [ n + ( x * i ) + x ] = arr [ n + ( x * i ) + x ] , arr [ i ]\nif __name__ == \"__main__\" :\n    arr = [ 5 , 3 , 7 , 2 , 1 , 6 ]\n    n = len ( arr )\n    reverseArray ( arr , n )\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" )\n", "python_code_tokenized": "def reverseArray ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE x = - sys . maxsize // sys . maxsize NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT arr [ i ] , arr [ n + ( x * i ) + x ] = arr [ n + ( x * i ) + x ] , arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1385_A", "sol": 0, "python_code": "max_Element = 100005\nsum1 = [ 0 for i in range ( max_Element ) ]\nsum2 = [ 0 for i in range ( max_Element ) ]\nsum3 = [ 0 for i in range ( max_Element ) ]\ndef precomputation ( arr , n ) :\n    for i in range ( 1 , max_Element , 1 ) :\n        for j in range ( i , max_Element , i ) :\n            sum1 [ j ] += i\n    for i in range ( 1 , max_Element , 1 ) :\n        for j in range ( i , max_Element , i ) :\n            sum2 [ j ] += ( sum1 [ j ] - i ) * i\n    for i in range ( 1 , max_Element , 1 ) :\n        sum2 [ i ] = int ( sum2 [ i ] / 2 )\n    for i in range ( 1 , max_Element , 1 ) :\n        for j in range ( i , max_Element , i ) :\n            sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) )\n    for i in range ( 1 , max_Element , 1 ) :\n        sum3 [ i ] = int ( sum3 [ i ] / 3 )\n    for i in range ( n ) :\n        print ( sum3 [ arr [ i ] ] , end = \" \" )\nif __name__ == '__main__' :\n    arr = [ 9 , 5 , 6 ]\n    n = len ( arr )\n    precomputation ( arr , n )\n", "python_code_tokenized": "max_Element = 100005 NEW_LINE sum1 = [ 0 for i in range ( max_Element ) ] NEW_LINE sum2 = [ 0 for i in range ( max_Element ) ] NEW_LINE sum3 = [ 0 for i in range ( max_Element ) ] NEW_LINE def precomputation ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum1 [ j ] += i NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum2 [ j ] += ( sum1 [ j ] - i ) * i NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT sum2 [ i ] = int ( sum2 [ i ] / 2 ) NEW_LINE DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT sum3 [ i ] = int ( sum3 [ i ] / 3 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( sum3 [ arr [ i ] ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE precomputation ( arr , n ) NEW_LINE DEDENT"}
{"id": "codeforces_891_B", "sol": 0, "python_code": "n , a = int ( input ( ) ) , list ( map ( int , input ( ).split ( ) ) )\nb = sorted ( a ) + [ min ( a ) ]\nprint ( ' '.join ( [ str ( b [ b.index ( a [ i ] ) + 1 ] ) for i in range ( n ) ] ) )\n", "python_code_tokenized": "n , a = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = sorted ( a ) + [ min ( a ) ] NEW_LINE print ( ' \u2581 ' . join ( [ str ( b [ b . index ( a [ i ] ) + 1 ] ) for i in range ( n ) ] ) ) NEW_LINE"}
{"id": "aizu_p00664_A", "sol": 0, "python_code": "while True :\n    r , c , q = map ( int , input ( ).split ( ) )\n    if r == 0 : break\n    querys = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( q ) ]\n    querys.reverse ( )\n    r_used = [ False ] * r\n    c_used = [ False ] * c\n    r_cnt = c\n    c_cnt = r\n    ans = 0\n    for a , b , o in querys :\n        if a == 0 :\n            if not r_used [ b ] :\n                r_used [ b ] = True\n                c_cnt -= 1\n                if o :\n                    ans += r_cnt\n        else :\n            if not c_used [ b ] :\n                c_used [ b ] = True\n                r_cnt -= 1\n                if o :\n                    ans += c_cnt\n    print ( ans )\n", "python_code_tokenized": "while True : NEW_LINE INDENT r , c , q = map ( int , input ( ) . split ( ) ) NEW_LINE if r == 0 : break NEW_LINE querys = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] NEW_LINE querys . reverse ( ) NEW_LINE r_used = [ False ] * r NEW_LINE c_used = [ False ] * c NEW_LINE r_cnt = c NEW_LINE c_cnt = r NEW_LINE ans = 0 NEW_LINE for a , b , o in querys : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT if not r_used [ b ] : NEW_LINE INDENT r_used [ b ] = True NEW_LINE c_cnt -= 1 NEW_LINE if o : NEW_LINE INDENT ans += r_cnt NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if not c_used [ b ] : NEW_LINE INDENT c_used [ b ] = True NEW_LINE r_cnt -= 1 NEW_LINE if o : NEW_LINE INDENT ans += c_cnt NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "codeforces_628_A", "sol": 0, "python_code": "n , b , p = map ( int , input ( ).split ( ) )\nx = 0\ny = n * p\nwhile n > 1 :\n    k = 1\n    while k <= n :\n        k *= 2\n    k //= 2\n    x += b * k + k // 2\n    n -= k // 2\nprint ( x , y )\n", "python_code_tokenized": "n , b , p = map ( int , input ( ) . split ( ) ) NEW_LINE x = 0 NEW_LINE y = n * p NEW_LINE while n > 1 : NEW_LINE INDENT k = 1 NEW_LINE while k <= n : NEW_LINE INDENT k *= 2 NEW_LINE DEDENT k //= 2 NEW_LINE x += b * k + k // 2 NEW_LINE n -= k // 2 NEW_LINE DEDENT print ( x , y ) NEW_LINE"}
{"id": "aizu_p02408_A", "sol": 0, "python_code": "n = int ( input ( ) )\nsoots = [ \"S\" , \"H\" , \"C\" , \"D\" ]\nsootlist = [ ]\nnumlist = [ ]\nfor i in range ( n ) :\n    soot , num = map ( str , input ( ).split ( ) )\n    sootlist.append ( soot )\n    numlist.append ( int ( num ) )\nans_sootlist = [ ]\nans_numlist = [ ]\nfor soot in soots :\n    for num in range ( 1 , 14 ) :\n        flag = 0\n        for s , n in zip ( sootlist , numlist ) :\n            if soot == s and num == n :\n                flag = 1\n                break\n        if flag == 1 :\n            continue\n        else :\n            ans_sootlist.append ( soot )\n            ans_numlist.append ( num )\nfor soot , num in zip ( ans_sootlist , ans_numlist ) :\n    print ( soot , num )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE soots = [ \" S \" , \" H \" , \" C \" , \" D \" ] NEW_LINE sootlist = [ ] NEW_LINE numlist = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT soot , num = map ( str , input ( ) . split ( ) ) NEW_LINE sootlist . append ( soot ) NEW_LINE numlist . append ( int ( num ) ) NEW_LINE DEDENT ans_sootlist = [ ] NEW_LINE ans_numlist = [ ] NEW_LINE for soot in soots : NEW_LINE INDENT for num in range ( 1 , 14 ) : NEW_LINE INDENT flag = 0 NEW_LINE for s , n in zip ( sootlist , numlist ) : NEW_LINE INDENT if soot == s and num == n : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT ans_sootlist . append ( soot ) NEW_LINE ans_numlist . append ( num ) NEW_LINE DEDENT DEDENT DEDENT for soot , num in zip ( ans_sootlist , ans_numlist ) : NEW_LINE INDENT print ( soot , num ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4860_A", "sol": 0, "python_code": "import math\ndef printRoots ( n ) :\n    theta = math.pi * 2 / n\n    for k in range ( 0 , n ) :\n        real = math.cos ( k * theta )\n        img = math.sin ( k * theta )\n        print ( real , end = \" \" )\n        if ( img >= 0 ) :\n            print ( \" + i \" , end = \" \" )\n        else :\n            print ( \" - i \" , end = \" \" )\n        print ( abs ( img ) )\nif __name__ == '__main__' :\n    printRoots ( 1 )\n    printRoots ( 2 )\n    printRoots ( 3 )\n", "python_code_tokenized": "import math NEW_LINE def printRoots ( n ) : NEW_LINE INDENT theta = math . pi * 2 / n NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT real = math . cos ( k * theta ) NEW_LINE img = math . sin ( k * theta ) NEW_LINE print ( real , end = \" \u2581 \" ) NEW_LINE if ( img >= 0 ) : NEW_LINE INDENT print ( \" \u2581 + \u2581 i \u2581 \" , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \u2581 - \u2581 i \u2581 \" , end = \" \u2581 \" ) NEW_LINE DEDENT print ( abs ( img ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT printRoots ( 1 ) NEW_LINE printRoots ( 2 ) NEW_LINE printRoots ( 3 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3214_A", "sol": 0, "python_code": "def rangeGCD ( n , m ) :\n    return n if ( n == m ) else 1\nn , m = 475 , 475\nprint ( rangeGCD ( n , m ) )\n", "python_code_tokenized": "def rangeGCD ( n , m ) : NEW_LINE INDENT return n if ( n == m ) else 1 NEW_LINE DEDENT n , m = 475 , 475 NEW_LINE print ( rangeGCD ( n , m ) ) NEW_LINE"}
{"id": "geeksforgeeks_1597_A", "sol": 0, "python_code": "import sys ;\ndef maxSubArraySum ( a , size ) :\n    max_so_far = - ( sys.maxsize - 1 ) ;\n    max_ending_here = 0 ;\n    for i in range ( size ) :\n        max_ending_here = max_ending_here + a [ i ] ;\n        if ( max_so_far < max_ending_here ) :\n            max_so_far = max_ending_here ;\n        if ( max_ending_here < 0 ) :\n            max_ending_here = 0 ;\n    return max_so_far ;\ndef maximizeSum ( a , n ) :\n    cnt = 0 ;\n    mini = sys.maxsize ;\n    minSubarray = sys.maxsize ;\n    sum = maxSubArraySum ( a , n ) ;\n    max_so_far = - ( sys.maxsize - 1 ) ;\n    max_ending_here = 0 ;\n    for i in range ( n ) :\n        max_ending_here = max_ending_here + a [ i ] ;\n        cnt += 1 ;\n        minSubarray = min ( a [ i ] , minSubarray ) ;\n        if ( sum == max_ending_here ) :\n            if ( cnt == 1 ) :\n                mini = min ( mini , 0 ) ;\n            else :\n                mini = min ( mini , minSubarray ) ;\n        if ( max_ending_here < 0 ) :\n            max_ending_here = 0 ;\n            cnt = 0 ;\n            minSubarray = sys.maxsize ;\n    return sum - mini ;\nif __name__ == \"__main__\" :\n    a = [ 1 , 2 , 3 , - 2 , 3 ] ;\n    n = len ( a )\n    print ( maximizeSum ( a , n ) ) ;\n", "python_code_tokenized": "import sys ; NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - ( sys . maxsize - 1 ) ; NEW_LINE max_ending_here = 0 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] ; NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here ; NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 ; NEW_LINE DEDENT DEDENT return max_so_far ; NEW_LINE DEDENT def maximizeSum ( a , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE mini = sys . maxsize ; NEW_LINE minSubarray = sys . maxsize ; NEW_LINE sum = maxSubArraySum ( a , n ) ; NEW_LINE max_so_far = - ( sys . maxsize - 1 ) ; NEW_LINE max_ending_here = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] ; NEW_LINE cnt += 1 ; NEW_LINE minSubarray = min ( a [ i ] , minSubarray ) ; NEW_LINE if ( sum == max_ending_here ) : NEW_LINE INDENT if ( cnt == 1 ) : NEW_LINE INDENT mini = min ( mini , 0 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT mini = min ( mini , minSubarray ) ; NEW_LINE DEDENT DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 ; NEW_LINE cnt = 0 ; NEW_LINE minSubarray = sys . maxsize ; NEW_LINE DEDENT DEDENT return sum - mini ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 3 , - 2 , 3 ] ; NEW_LINE n = len ( a ) NEW_LINE print ( maximizeSum ( a , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5070_A", "sol": 0, "python_code": "MAX = 1000000\ndef ksmallest ( arr , n , k ) :\n    b = [ 0 ] * MAX ;\n    for i in range ( n ) :\n        b [ arr [ i ] ] = 1 ;\n    for j in range ( 1 , MAX ) :\n        if ( b [ j ] != 1 ) :\n            k -= 1 ;\n        if ( k is not 1 ) :\n            return j ;\nk = 1 ;\narr = [ 1 ] ;\nn = len ( arr ) ;\nprint ( ksmallest ( arr , n , k ) ) ;\n", "python_code_tokenized": "MAX = 1000000 NEW_LINE def ksmallest ( arr , n , k ) : NEW_LINE INDENT b = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ arr [ i ] ] = 1 ; NEW_LINE DEDENT for j in range ( 1 , MAX ) : NEW_LINE INDENT if ( b [ j ] != 1 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE DEDENT if ( k is not 1 ) : NEW_LINE INDENT return j ; NEW_LINE DEDENT DEDENT DEDENT k = 1 ; NEW_LINE arr = [ 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ksmallest ( arr , n , k ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_1924_A", "sol": 0, "python_code": "def getRemainder ( num , divisor ) :\n    while ( num >= divisor ) :\n        num -= divisor ;\n    return num ;\nif __name__ == '__main__' :\n    num = 100 ; divisor = 7 ;\n    print ( getRemainder ( num , divisor ) ) ;\n", "python_code_tokenized": "def getRemainder ( num , divisor ) : NEW_LINE INDENT while ( num >= divisor ) : NEW_LINE INDENT num -= divisor ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 100 ; divisor = 7 ; NEW_LINE print ( getRemainder ( num , divisor ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4053_A", "sol": 0, "python_code": "def sumOfTheSeries ( n ) :\n    sum = 0\n    for i in range ( 0 , n + 1 ) :\n        k = 2\n        for j in range ( 1 , i + 1 ) :\n            sum = sum + k ;\n            k = k + 2\n    return sum ;\nn = 5\nans = sumOfTheSeries ( n ) ;\nprint ( ans )\n", "python_code_tokenized": "def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT k = 2 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT sum = sum + k ; NEW_LINE k = k + 2 NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT n = 5 NEW_LINE ans = sumOfTheSeries ( n ) ; NEW_LINE print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_1645_A", "sol": 0, "python_code": "import numpy as np\nright = 3 ;\nleft = 6 ;\ndp = np.ones ( ( left , right ) )\ndp = - 1 * dp\ndef findSubarraySum ( ind , flips , n , a , k ) :\n    if ( flips > k ) :\n        return - 1e9 ;\n    if ( ind == n ) :\n        return 0 ;\n    if ( dp [ ind ] [ flips ] != - 1 ) :\n        return dp [ ind ] [ flips ] ;\n    ans = 0 ;\n    ans = max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) ;\n    ans = max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) ;\n    dp [ ind ] [ flips ] = ans ;\n    return dp [ ind ] [ flips ] ;\ndef findMaxSubarraySum ( a , n , k ) :\n    ans = - 1e9 ;\n    for i in range ( n ) :\n        ans = max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) ;\n    return ans ;\nif __name__ == \"__main__\" :\n    a = [ - 1 , - 2 , - 100 , - 10 ] ;\n    n = len ( a ) ;\n    k = 1 ;\n    print ( findMaxSubarraySum ( a , n , k ) ) ;\n", "python_code_tokenized": "import numpy as np NEW_LINE right = 3 ; NEW_LINE left = 6 ; NEW_LINE dp = np . ones ( ( left , right ) ) NEW_LINE dp = - 1 * dp NEW_LINE def findSubarraySum ( ind , flips , n , a , k ) : NEW_LINE INDENT if ( flips > k ) : NEW_LINE INDENT return - 1e9 ; NEW_LINE DEDENT if ( ind == n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ ind ] [ flips ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] [ flips ] ; NEW_LINE DEDENT ans = 0 ; NEW_LINE ans = max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) ; NEW_LINE ans = max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) ; NEW_LINE dp [ ind ] [ flips ] = ans ; NEW_LINE return dp [ ind ] [ flips ] ; NEW_LINE DEDENT def findMaxSubarraySum ( a , n , k ) : NEW_LINE INDENT ans = - 1e9 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ - 1 , - 2 , - 100 , - 10 ] ; NEW_LINE n = len ( a ) ; NEW_LINE k = 1 ; NEW_LINE print ( findMaxSubarraySum ( a , n , k ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_136_B", "sol": 0, "python_code": "def ss_3 ( t ) :\n    s = ''\n    while t != 0 :\n        s += str ( t % 3 )\n        t //= 3\n    return s [ : : - 1 ]\na , b = map ( int , input ( ).split ( ) )\nif a == b and a == 0 :\n    print ( 0 )\nelse :\n    a , b = ss_3 ( a ) , ss_3 ( b )\n    n = max ( len ( a ) , len ( b ) )\n    a = ( n - len ( a ) ) * '0' + a\n    b = ( n - len ( b ) ) * '0' + b\n    c = ''\n    for i in range ( len ( a ) ) :\n        if int ( b [ i ] ) < int ( a [ i ] ) :\n            c += str ( int ( b [ i ] ) + 3 - int ( a [ i ] ) )\n        else :\n            c += str ( int ( b [ i ] ) - int ( a [ i ] ) )\n    print ( int ( c , 3 ) )\n", "python_code_tokenized": "def ss_3 ( t ) : NEW_LINE INDENT s = ' ' NEW_LINE while t != 0 : NEW_LINE INDENT s += str ( t % 3 ) NEW_LINE t //= 3 NEW_LINE DEDENT return s [ : : - 1 ] NEW_LINE DEDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b and a == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT a , b = ss_3 ( a ) , ss_3 ( b ) NEW_LINE n = max ( len ( a ) , len ( b ) ) NEW_LINE a = ( n - len ( a ) ) * '0' + a NEW_LINE b = ( n - len ( b ) ) * '0' + b NEW_LINE c = ' ' NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if int ( b [ i ] ) < int ( a [ i ] ) : NEW_LINE INDENT c += str ( int ( b [ i ] ) + 3 - int ( a [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT c += str ( int ( b [ i ] ) - int ( a [ i ] ) ) NEW_LINE DEDENT DEDENT print ( int ( c , 3 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_547_A", "sol": 0, "python_code": "from math import gcd\ndef printNumbers ( a , n , x ) :\n    flag = False\n    for i in range ( n ) :\n        num = a [ i ]\n        g = gcd ( num , x )\n        while ( g != 1 ) :\n            num //= g\n            g = gcd ( num , x )\n        if ( num == 1 ) :\n            flag = True ;\n            print ( a [ i ] , end = \" \" ) ;\n    if ( not flag ) :\n        print ( \"There are no such numbers\" )\nif __name__ == \"__main__\" :\n    x = 60\n    a = [ 2 , 5 , 10 , 7 , 17 ]\n    n = len ( a )\n    printNumbers ( a , n , x )\n", "python_code_tokenized": "from math import gcd NEW_LINE def printNumbers ( a , n , x ) : NEW_LINE INDENT flag = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE g = gcd ( num , x ) NEW_LINE while ( g != 1 ) : NEW_LINE INDENT num //= g NEW_LINE g = gcd ( num , x ) NEW_LINE DEDENT if ( num == 1 ) : NEW_LINE INDENT flag = True ; NEW_LINE print ( a [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT if ( not flag ) : NEW_LINE INDENT print ( \" There \u2581 are \u2581 no \u2581 such \u2581 numbers \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 60 NEW_LINE a = [ 2 , 5 , 10 , 7 , 17 ] NEW_LINE n = len ( a ) NEW_LINE printNumbers ( a , n , x ) NEW_LINE DEDENT"}
{"id": "projecteuler_p104_A", "sol": 0, "python_code": "import itertools\ndef compute ( ) :\n    MOD = 10 ** 9\n    a = 0\n    b = 1\n    for i in itertools.count ( ) :\n        if \"\".join ( sorted ( str ( a ) ) ) == \"123456789\" :\n            f = fibonacci ( i ) [ 0 ]\n            if \"\".join ( sorted ( str ( f ) [ : 9 ] ) ) == \"123456789\" :\n                return str ( i )\n        a , b = b , ( a + b ) % MOD\n    return str ( ans )\ndef fibonacci ( n ) :\n    if n == 0 :\n        return ( 0 , 1 )\n    else :\n        a , b = fibonacci ( n // 2 )\n        c = a * ( b * 2 - a )\n        d = a * a + b * b\n        if n % 2 == 0 :\n            return ( c , d )\n        else :\n            return ( d , c + d )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT MOD = 10 ** 9 NEW_LINE a = 0 NEW_LINE b = 1 NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT if \" \" . join ( sorted ( str ( a ) ) ) == \"123456789\" : NEW_LINE INDENT f = fibonacci ( i ) [ 0 ] NEW_LINE if \" \" . join ( sorted ( str ( f ) [ : 9 ] ) ) == \"123456789\" : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT DEDENT a , b = b , ( a + b ) % MOD NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT def fibonacci ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return ( 0 , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT a , b = fibonacci ( n // 2 ) NEW_LINE c = a * ( b * 2 - a ) NEW_LINE d = a * a + b * b NEW_LINE if n % 2 == 0 : NEW_LINE INDENT return ( c , d ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( d , c + d ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_955_A", "sol": 0, "python_code": "disc_time = 1200\ntime = input ( ).split ( )\ngiven_time = int ( time [ 0 ] ) * 60 + int ( time [ 1 ] )\ntime_diff = abs ( disc_time - given_time )\nval = list ( map ( int , input ( ).split ( ) ) )\ninc_hunger = time_diff * val [ 1 ]\ninitial_hunger = val [ 0 ]\ncost = val [ 2 ]\ndiscount_cost = 0.8 * cost\ndec_hunger = val [ 3 ]\nreq = - 1\nif ( initial_hunger % dec_hunger == 0 ) :\n    req = initial_hunger / dec_hunger\nelse :\n    req = initial_hunger // dec_hunger + 1\ncost1 = req * cost\nreq = - 1\ninitial_hunger += inc_hunger\nif ( initial_hunger % dec_hunger == 0 ) :\n    req = initial_hunger / dec_hunger\nelse :\n    req = initial_hunger // dec_hunger + 1\ncost2 = req * discount_cost\nif given_time >= disc_time :\n    print ( ( cost1 // cost ) * discount_cost )\nelse :\n    print ( min ( cost1 , cost2 ) )\n", "python_code_tokenized": "disc_time = 1200 NEW_LINE time = input ( ) . split ( ) NEW_LINE given_time = int ( time [ 0 ] ) * 60 + int ( time [ 1 ] ) NEW_LINE time_diff = abs ( disc_time - given_time ) NEW_LINE val = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE inc_hunger = time_diff * val [ 1 ] NEW_LINE initial_hunger = val [ 0 ] NEW_LINE cost = val [ 2 ] NEW_LINE discount_cost = 0.8 * cost NEW_LINE dec_hunger = val [ 3 ] NEW_LINE req = - 1 NEW_LINE if ( initial_hunger % dec_hunger == 0 ) : NEW_LINE INDENT req = initial_hunger / dec_hunger NEW_LINE DEDENT else : NEW_LINE INDENT req = initial_hunger // dec_hunger + 1 NEW_LINE DEDENT cost1 = req * cost NEW_LINE req = - 1 NEW_LINE initial_hunger += inc_hunger NEW_LINE if ( initial_hunger % dec_hunger == 0 ) : NEW_LINE INDENT req = initial_hunger / dec_hunger NEW_LINE DEDENT else : NEW_LINE INDENT req = initial_hunger // dec_hunger + 1 NEW_LINE DEDENT cost2 = req * discount_cost NEW_LINE if given_time >= disc_time : NEW_LINE INDENT print ( ( cost1 // cost ) * discount_cost ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( cost1 , cost2 ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC154_E", "sol": 0, "python_code": "N = input ( )\nK = int ( input ( ) )\nm = len ( N )\ndp = [ [ [ 0 ] * ( K + 1 ) for _ in range ( 2 ) ] for _ in range ( m + 1 ) ]\ndp [ 0 ] [ 0 ] [ 0 ] = 1\nfor i in range ( 1 , m + 1 ) :\n    l = int ( N [ i - 1 ] )\n    for k in range ( K + 1 ) :\n        if k == 0 :\n            dp [ i ] [ 0 ] [ k ] = 0\n            dp [ i ] [ 1 ] [ k ] = 1\n        else :\n            if l != 0 :\n                dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k - 1 ]\n                dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + 9 * dp [ i - 1 ] [ 1 ] [ k - 1 ] + dp [ i - 1 ] [ 0 ] [ k ] + ( l - 1 ) * dp [ i - 1 ] [ 0 ] [ k - 1 ]\n            else :\n                dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k ]\n                dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + 9 * dp [ i - 1 ] [ 1 ] [ k - 1 ]\nprint ( dp [ m ] [ 0 ] [ K ] + dp [ m ] [ 1 ] [ K ] )\n", "python_code_tokenized": "N = input ( ) NEW_LINE K = int ( input ( ) ) NEW_LINE m = len ( N ) NEW_LINE dp = [ [ [ 0 ] * ( K + 1 ) for _ in range ( 2 ) ] for _ in range ( m + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT l = int ( N [ i - 1 ] ) NEW_LINE for k in range ( K + 1 ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT dp [ i ] [ 0 ] [ k ] = 0 NEW_LINE dp [ i ] [ 1 ] [ k ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if l != 0 : NEW_LINE INDENT dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k - 1 ] NEW_LINE dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + 9 * dp [ i - 1 ] [ 1 ] [ k - 1 ] + dp [ i - 1 ] [ 0 ] [ k ] + ( l - 1 ) * dp [ i - 1 ] [ 0 ] [ k - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k ] NEW_LINE dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + 9 * dp [ i - 1 ] [ 1 ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( dp [ m ] [ 0 ] [ K ] + dp [ m ] [ 1 ] [ K ] ) NEW_LINE"}
{"id": "geeksforgeeks_1859_A", "sol": 0, "python_code": "def closetAND ( arr , n , k ) :\n    ans = 10 ** 9\n    for i in range ( n ) :\n        X = arr [ i ]\n        for j in range ( i , n ) :\n            X &= arr [ j ]\n            ans = min ( ans , abs ( k - X ) )\n    return ans\narr = [ 4 , 7 , 10 ]\nn = len ( arr )\nk = 2 ;\nprint ( closetAND ( arr , n , k ) )\n", "python_code_tokenized": "def closetAND ( arr , n , k ) : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT X = arr [ i ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT X &= arr [ j ] NEW_LINE ans = min ( ans , abs ( k - X ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 4 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 ; NEW_LINE print ( closetAND ( arr , n , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_3453_A", "sol": 0, "python_code": "from math import *\ndef Probability ( sum , times ) :\n    favorable , total , probability = 0.0 , 36.0 , 0\n    for i in range ( 7 ) :\n        for j in range ( 7 ) :\n            if ( ( i + j ) == sum ) :\n                favorable += 1\n    gcd1 = gcd ( int ( favorable ) , int ( total ) )\n    favorable = favorable / gcd1\n    total = total / gcd1\n    probability = pow ( total , times )\n    return int ( probability )\nif __name__ == \"__main__\" :\n    sum , times = 7 , 7\n    print ( \"1\" , \"/\" , Probability ( sum , times ) )\n", "python_code_tokenized": "from math import * NEW_LINE def Probability ( sum , times ) : NEW_LINE INDENT favorable , total , probability = 0.0 , 36.0 , 0 NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT for j in range ( 7 ) : NEW_LINE INDENT if ( ( i + j ) == sum ) : NEW_LINE INDENT favorable += 1 NEW_LINE DEDENT DEDENT DEDENT gcd1 = gcd ( int ( favorable ) , int ( total ) ) NEW_LINE favorable = favorable / gcd1 NEW_LINE total = total / gcd1 NEW_LINE probability = pow ( total , times ) NEW_LINE return int ( probability ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sum , times = 7 , 7 NEW_LINE print ( \"1\" , \" / \" , Probability ( sum , times ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2672_A", "sol": 0, "python_code": "def compareStrings ( str1 , str2 ) :\n    i = 0\n    while i < len ( str1 ) - 1 and str1 [ i ] == str2 [ i ] :\n        i += 1\n    if str1 [ i ] > str2 [ i ] :\n        return - 1\n    return str1 [ i ] < str2 [ i ]\ndef searchStr ( arr , string , first , last ) :\n    if first > last :\n        return - 1\n    mid = ( last + first ) // 2\n    if len ( arr [ mid ] ) == 0 :\n        left , right = mid - 1 , mid + 1\n        while True :\n            if left < first and right > last :\n                return - 1\n            if right <= last and len ( arr [ right ] ) != 0 :\n                mid = right\n                break\n            if left >= first and len ( arr [ left ] ) != 0 :\n                mid = left\n                break\n            right += 1\n            left -= 1\n    if compareStrings ( string , arr [ mid ] ) == 0 :\n        return mid\n    if compareStrings ( string , arr [ mid ] ) < 0 :\n        return searchStr ( arr , string , mid + 1 , last )\n    return searchStr ( arr , string , first , mid - 1 )\nif __name__ == \"__main__\" :\n    arr = [ \"for\" , \"\" , \"\" , \"\" , \"geeks\" , \"ide\" , \"\" , \"practice\" , \"\" , \"\" , \"quiz\" , \"\" , \"\" ]\n    string = \"quiz\"\n    n = len ( arr )\n    print ( searchStr ( arr , string , 0 , n - 1 ) )\n", "python_code_tokenized": "def compareStrings ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( str1 ) - 1 and str1 [ i ] == str2 [ i ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if str1 [ i ] > str2 [ i ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return str1 [ i ] < str2 [ i ] NEW_LINE DEDENT def searchStr ( arr , string , first , last ) : NEW_LINE INDENT if first > last : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( last + first ) // 2 NEW_LINE if len ( arr [ mid ] ) == 0 : NEW_LINE INDENT left , right = mid - 1 , mid + 1 NEW_LINE while True : NEW_LINE INDENT if left < first and right > last : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if right <= last and len ( arr [ right ] ) != 0 : NEW_LINE INDENT mid = right NEW_LINE break NEW_LINE DEDENT if left >= first and len ( arr [ left ] ) != 0 : NEW_LINE INDENT mid = left NEW_LINE break NEW_LINE DEDENT right += 1 NEW_LINE left -= 1 NEW_LINE DEDENT DEDENT if compareStrings ( string , arr [ mid ] ) == 0 : NEW_LINE INDENT return mid NEW_LINE DEDENT if compareStrings ( string , arr [ mid ] ) < 0 : NEW_LINE INDENT return searchStr ( arr , string , mid + 1 , last ) NEW_LINE DEDENT return searchStr ( arr , string , first , mid - 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" for \" , \" \" , \" \" , \" \" , \" geeks \" , \" ide \" , \" \" , \" practice \" , \" \" , \" \" , \" quiz \" , \" \" , \" \" ] NEW_LINE string = \" quiz \" NEW_LINE n = len ( arr ) NEW_LINE print ( searchStr ( arr , string , 0 , n - 1 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3724_A", "sol": 0, "python_code": "def countOccurrence ( n , arr , k ) :\n    cnt , ans = 0 , 0\n    Hash = dict ( )\n    for i in range ( n ) :\n        cnt = 0\n        if ( arr [ i ] in Hash.keys ( ) ) :\n            continue\n        Hash [ arr [ i ] ] = 1\n        for j in range ( i + 1 , n ) :\n            if ( arr [ j ] == arr [ i ] ) :\n                cnt += 1\n            if ( cnt >= k ) :\n                break\n        if ( cnt >= k ) :\n            ans += 1\n    return ans\narr = [ 1 , 2 , 1 , 3 ]\nn = len ( arr )\nk = 1\nprint ( countOccurrence ( n , arr , k ) )\n", "python_code_tokenized": "def countOccurrence ( n , arr , k ) : NEW_LINE INDENT cnt , ans = 0 , 0 NEW_LINE Hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE if ( arr [ i ] in Hash . keys ( ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT Hash [ arr [ i ] ] = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] == arr [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( cnt >= k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( cnt >= k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 1 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 1 NEW_LINE print ( countOccurrence ( n , arr , k ) ) NEW_LINE"}
{"id": "codeforces_1029_A", "sol": 0, "python_code": "n , k = map ( int , input ( ).rstrip ( ).split ( ) )\ns = input ( )\ncommon = 0\nfor i in range ( n - 1 ) :\n    a = s [ n - 1 - i : ]\n    b = s [ : i + 1 ]\n    if ( a == b ) :\n        common = i + 1\n        continue\nans = ( n ) + ( k - 1 ) * ( n - common )\nfinal = s\nfor i in range ( k - 1 ) :\n    final += ( s [ common : ] )\nprint ( final )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . rstrip ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE common = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a = s [ n - 1 - i : ] NEW_LINE b = s [ : i + 1 ] NEW_LINE if ( a == b ) : NEW_LINE INDENT common = i + 1 NEW_LINE continue NEW_LINE DEDENT DEDENT ans = ( n ) + ( k - 1 ) * ( n - common ) NEW_LINE final = s NEW_LINE for i in range ( k - 1 ) : NEW_LINE INDENT final += ( s [ common : ] ) NEW_LINE DEDENT print ( final ) NEW_LINE"}
{"id": "codeforces_303_A", "sol": 0, "python_code": "n = int ( input ( ) )\nif n % 2 == 0 :\n    print ( - 1 )\nelse :\n    print ( * range ( n ) )\n    print ( * range ( n ) )\n    print ( * map ( lambda x : x * 2 % n , range ( n ) ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( * range ( n ) ) NEW_LINE print ( * range ( n ) ) NEW_LINE print ( * map ( lambda x : x * 2 % n , range ( n ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4496_A", "sol": 0, "python_code": "def powerOfTwo ( n ) :\n    return ( not ( n & n - 1 ) )\ndef onlyFirstAndLastAreSet ( n ) :\n    if ( n == 1 ) :\n        return True\n    return powerOfTwo ( n - 1 )\nn = 9\nif ( onlyFirstAndLastAreSet ( n ) ) :\n    print ( 'Yes' )\nelse :\n    print ( 'No' )\n", "python_code_tokenized": "def powerOfTwo ( n ) : NEW_LINE INDENT return ( not ( n & n - 1 ) ) NEW_LINE DEDENT def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return powerOfTwo ( n - 1 ) NEW_LINE DEDENT n = 9 NEW_LINE if ( onlyFirstAndLastAreSet ( n ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT"}
{"id": "codeforces_1017_B", "sol": 0, "python_code": "from sys import stdin\ninput = stdin.readline\nn = int ( input ( ) )\na = input ( ).rstrip ( )\nb = input ( ).rstrip ( )\nnum_ones = 0\nnum_zeros = 0\nx = 0\ny = 0\nfor i in range ( n ) :\n    num_zeros += a [ i ] == \"0\"\n    num_ones += a [ i ] == \"1\"\n    x += a [ i ] == \"1\" and b [ i ] == \"1\"\n    y += a [ i ] == \"0\" and b [ i ] == \"1\"\nans = ( num_ones * num_zeros ) - ( x * y )\nprint ( ans )\n", "python_code_tokenized": "from sys import stdin NEW_LINE input = stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = input ( ) . rstrip ( ) NEW_LINE b = input ( ) . rstrip ( ) NEW_LINE num_ones = 0 NEW_LINE num_zeros = 0 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT num_zeros += a [ i ] == \"0\" NEW_LINE num_ones += a [ i ] == \"1\" NEW_LINE x += a [ i ] == \"1\" and b [ i ] == \"1\" NEW_LINE y += a [ i ] == \"0\" and b [ i ] == \"1\" NEW_LINE DEDENT ans = ( num_ones * num_zeros ) - ( x * y ) NEW_LINE print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_1657_A", "sol": 0, "python_code": "import math\ndef minOperations ( A , B ) :\n    if ( A > B ) :\n        swap ( A , B )\n    B = B // math.gcd ( A , B ) ;\n    return B - 1\nA = 7\nB = 15\nprint ( minOperations ( A , B ) )\n", "python_code_tokenized": "import math NEW_LINE def minOperations ( A , B ) : NEW_LINE INDENT if ( A > B ) : NEW_LINE INDENT swap ( A , B ) NEW_LINE DEDENT B = B // math . gcd ( A , B ) ; NEW_LINE return B - 1 NEW_LINE DEDENT A = 7 NEW_LINE B = 15 NEW_LINE print ( minOperations ( A , B ) ) NEW_LINE"}
{"id": "geeksforgeeks_1728_A", "sol": 0, "python_code": "from math import sqrt\ndef centeredSquare_number ( N ) :\n    n = ( 9 + sqrt ( 36 * N + 45 ) ) / 18 ;\n    if ( n - int ( n ) ) == 0 :\n        return 1\n    else :\n        return 0\nif __name__ == \"__main__\" :\n    i = 13 ;\n    print ( centeredSquare_number ( i ) ) ;\n", "python_code_tokenized": "from math import sqrt NEW_LINE def centeredSquare_number ( N ) : NEW_LINE INDENT n = ( 9 + sqrt ( 36 * N + 45 ) ) / 18 ; NEW_LINE if ( n - int ( n ) ) == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT i = 13 ; NEW_LINE print ( centeredSquare_number ( i ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1440_B", "sol": 0, "python_code": "for p in range ( int ( input ( ) ) ) :\n    n , k = list ( map ( int , input ( ).split ( ) ) )\n    a = list ( map ( int , input ( ).split ( ) ) )\n    if n % 2 :\n        x , y = n // 2 , n // 2 + 1\n    else :\n        x , y = n // 2 - 1 , n // 2 + 1\n    if n == 2 :\n        s = 0\n        for i in range ( 0 , n * k , 2 ) :\n            s += a [ i ]\n        print ( s )\n    else :\n        d , s = x * k , 0\n        while d < ( n * k ) :\n            s += a [ d ]\n            d += y\n        print ( s )\n", "python_code_tokenized": "for p in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n % 2 : NEW_LINE INDENT x , y = n // 2 , n // 2 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT x , y = n // 2 - 1 , n // 2 + 1 NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , n * k , 2 ) : NEW_LINE INDENT s += a [ i ] NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT d , s = x * k , 0 NEW_LINE while d < ( n * k ) : NEW_LINE INDENT s += a [ d ] NEW_LINE d += y NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p01751_A", "sol": 0, "python_code": "import math\na , b , c = map ( int , input ( ).split ( ) )\nfor k in range ( 60 ) :\n    t = math.ceil ( ( k * ( a + b ) - c ) / 60 )\n    if t <= ( k * ( a + b ) + a - c ) / 60 :\n        print ( t * 60 + c )\n        break\nelse :\n    print ( - 1 )\n", "python_code_tokenized": "import math NEW_LINE a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE for k in range ( 60 ) : NEW_LINE INDENT t = math . ceil ( ( k * ( a + b ) - c ) / 60 ) NEW_LINE if t <= ( k * ( a + b ) + a - c ) / 60 : NEW_LINE INDENT print ( t * 60 + c ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"}
{"id": "codeforces_268_B", "sol": 0, "python_code": "i = int ( input ( ) )\np = 0\nq = 0\nwhile p < i :\n    f = i - p - 1\n    q += p * f + f\n    p += 1\nprint ( q + i )\n", "python_code_tokenized": "i = int ( input ( ) ) NEW_LINE p = 0 NEW_LINE q = 0 NEW_LINE while p < i : NEW_LINE INDENT f = i - p - 1 NEW_LINE q += p * f + f NEW_LINE p += 1 NEW_LINE DEDENT print ( q + i ) NEW_LINE"}
{"id": "codeforces_46_A", "sol": 0, "python_code": "num = int ( input ( ) )\nresult = \"\"\nn = 2\nfor i in range ( 2 , num + 1 ) :\n    if n % num != 0 :\n        result += str ( n % num ) + \" \"\n    else :\n        result += str ( num ) + \" \"\n    n += i\nprint ( result )\n", "python_code_tokenized": "num = int ( input ( ) ) NEW_LINE result = \" \" NEW_LINE n = 2 NEW_LINE for i in range ( 2 , num + 1 ) : NEW_LINE INDENT if n % num != 0 : NEW_LINE INDENT result += str ( n % num ) + \" \u2581 \" NEW_LINE DEDENT else : NEW_LINE INDENT result += str ( num ) + \" \u2581 \" NEW_LINE DEDENT n += i NEW_LINE DEDENT print ( result ) NEW_LINE"}
{"id": "codeforces_1143_B", "sol": 0, "python_code": "def l ( n ) : return len ( str ( n ) )\ndef el ( n ) : return int ( str ( n ) [ 1 : ] )\ndef first ( n ) : return int ( str ( n ) [ 0 ] )\ndef maxima ( n ) :\n    if l ( n ) == 1 :\n        return n\n    elif first ( n ) == 1 :\n        return max ( 9 ** ( l ( n ) - 1 ) , first ( n ) * maxima ( el ( n ) ) )\n    else :\n        return max ( ( first ( n ) - 1 ) * 9 ** ( l ( n ) - 1 ) , first ( n ) * maxima ( el ( n ) ) )\nn = int ( input ( ) )\nprint ( maxima ( n ) )\n", "python_code_tokenized": "def l ( n ) : return len ( str ( n ) ) NEW_LINE def el ( n ) : return int ( str ( n ) [ 1 : ] ) NEW_LINE def first ( n ) : return int ( str ( n ) [ 0 ] ) NEW_LINE def maxima ( n ) : NEW_LINE INDENT if l ( n ) == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT elif first ( n ) == 1 : NEW_LINE INDENT return max ( 9 ** ( l ( n ) - 1 ) , first ( n ) * maxima ( el ( n ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( ( first ( n ) - 1 ) * 9 ** ( l ( n ) - 1 ) , first ( n ) * maxima ( el ( n ) ) ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE print ( maxima ( n ) ) NEW_LINE"}
{"id": "atcoder_ARC059_C", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nfrom itertools import accumulate\nMOD = 10 ** 9 + 7\nn , c = map ( int , input ( ).split ( ) )\nA = tuple ( map ( int , input ( ).split ( ) ) )\nB = tuple ( map ( int , input ( ).split ( ) ) )\nE = [ [ 0 ] * ( c + 1 ) for _ in range ( n ) ]\nfor j in range ( c + 1 ) :\n    cumsum = tuple ( pow ( k , j , MOD ) for k in range ( 401 ) )\n    cumsum = tuple ( i % MOD for i in accumulate ( cumsum ) )\n    for i , ( a , b ) in enumerate ( zip ( A , B ) ) :\n        E [ i ] [ j ] = cumsum [ b ] - cumsum [ a - 1 ]\ndp = [ [ 0 ] * ( c + 1 ) for _ in range ( n + 1 ) ]\ndp [ 0 ] [ 0 ] = 1\nfor i , e in enumerate ( E ) :\n    for j , f in enumerate ( e ) :\n        for k in range ( c + 1 ) :\n            if j + k <= c :\n                dp [ i + 1 ] [ j + k ] += dp [ i ] [ k ] * f\n                dp [ i + 1 ] [ j + k ] %= MOD\nans = dp [ n ] [ c ]\nprint ( ans )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE from itertools import accumulate NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE n , c = map ( int , input ( ) . split ( ) ) NEW_LINE A = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE E = [ [ 0 ] * ( c + 1 ) for _ in range ( n ) ] NEW_LINE for j in range ( c + 1 ) : NEW_LINE INDENT cumsum = tuple ( pow ( k , j , MOD ) for k in range ( 401 ) ) NEW_LINE cumsum = tuple ( i % MOD for i in accumulate ( cumsum ) ) NEW_LINE for i , ( a , b ) in enumerate ( zip ( A , B ) ) : NEW_LINE INDENT E [ i ] [ j ] = cumsum [ b ] - cumsum [ a - 1 ] NEW_LINE DEDENT DEDENT dp = [ [ 0 ] * ( c + 1 ) for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i , e in enumerate ( E ) : NEW_LINE INDENT for j , f in enumerate ( e ) : NEW_LINE INDENT for k in range ( c + 1 ) : NEW_LINE INDENT if j + k <= c : NEW_LINE INDENT dp [ i + 1 ] [ j + k ] += dp [ i ] [ k ] * f NEW_LINE dp [ i + 1 ] [ j + k ] %= MOD NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = dp [ n ] [ c ] NEW_LINE print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_3631_A", "sol": 0, "python_code": "def parallel ( n , a ) :\n    x = True ;\n    y = True ;\n    for i in range ( n - 1 ) :\n        for j in range ( 2 ) :\n            if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) :\n                x = False ;\n            if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) :\n                y = False ;\n    if ( x ) :\n        print ( \"Parallel to X Axis\" ) ;\n    elif ( y ) :\n        print ( \"Parallel to Y Axis\" ) ;\n    else :\n        print ( \"Not Parallel to X and Y Axis\" ) ;\na = [ [ 1 , 2 ] , [ 1 , 4 ] , [ 1 , 6 ] , [ 1 , 0 ] ] ;\nn = len ( a ) ;\nparallel ( n , a ) ;\n", "python_code_tokenized": "def parallel ( n , a ) : NEW_LINE INDENT x = True ; NEW_LINE y = True ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) : NEW_LINE INDENT x = False ; NEW_LINE DEDENT if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) : NEW_LINE INDENT y = False ; NEW_LINE DEDENT DEDENT DEDENT if ( x ) : NEW_LINE INDENT print ( \" Parallel \u2581 to \u2581 X \u2581 Axis \" ) ; NEW_LINE DEDENT elif ( y ) : NEW_LINE INDENT print ( \" Parallel \u2581 to \u2581 Y \u2581 Axis \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Parallel \u2581 to \u2581 X \u2581 and \u2581 Y \u2581 Axis \" ) ; NEW_LINE DEDENT DEDENT a = [ [ 1 , 2 ] , [ 1 , 4 ] , [ 1 , 6 ] , [ 1 , 0 ] ] ; NEW_LINE n = len ( a ) ; NEW_LINE parallel ( n , a ) ; NEW_LINE"}
{"id": "geeksforgeeks_995_A", "sol": 0, "python_code": "import numpy as np\nmaxN = 20\nmaxM = 256\ndp = np.zeros ( ( maxN , maxM ) ) ;\nv = np.zeros ( ( maxN , maxM ) ) ;\ndef findLen ( arr , i , curr , n , m ) :\n    if ( i == n ) :\n        if ( curr == m ) :\n            return 0 ;\n        else :\n            return - 1 ;\n    if ( v [ i ] [ curr ] ) :\n        return dp [ i ] [ curr ] ;\n    v [ i ] [ curr ] = 1 ;\n    l = findLen ( arr , i + 1 , curr , n , m ) ;\n    r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ;\n    dp [ i ] [ curr ] = l ;\n    if ( r != - 1 ) :\n        dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ;\n    return dp [ i ] [ curr ] ;\nif __name__ == \"__main__\" :\n    arr = [ 3 , 7 , 2 , 3 ] ;\n    n = len ( arr ) ;\n    m = 3 ;\n    ans = findLen ( arr , 0 , ( ( 1 << 8 ) - 1 ) , n , m ) ;\n    if ( ans == - 1 ) :\n        print ( 0 ) ;\n    else :\n        print ( ans ) ;\n", "python_code_tokenized": "import numpy as np NEW_LINE maxN = 20 NEW_LINE maxM = 256 NEW_LINE dp = np . zeros ( ( maxN , maxM ) ) ; NEW_LINE v = np . zeros ( ( maxN , maxM ) ) ; NEW_LINE def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE m = 3 ; NEW_LINE ans = findLen ( arr , 0 , ( ( 1 << 8 ) - 1 ) , n , m ) ; NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( 0 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) ; NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3309_A", "sol": 0, "python_code": "import numpy as np\nmaxN = 20\nmaxM = 64\ndp = np.zeros ( ( maxN , maxM ) ) ;\nv = np.zeros ( ( maxN , maxM ) ) ;\ndef findLen ( arr , i , curr , n , m ) :\n    if ( i == n ) :\n        if ( curr == m ) :\n            return 0 ;\n        else :\n            return - 1 ;\n    if ( v [ i ] [ curr ] ) :\n        return dp [ i ] [ curr ] ;\n    v [ i ] [ curr ] = 1 ;\n    l = findLen ( arr , i + 1 , curr , n , m ) ;\n    r = findLen ( arr , i + 1 , curr | arr [ i ] , n , m ) ;\n    dp [ i ] [ curr ] = l ;\n    if ( r != - 1 ) :\n        dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ;\n    return dp [ i ] [ curr ] ;\nif __name__ == \"__main__\" :\n    arr = [ 3 , 7 , 2 , 3 ] ;\n    n = len ( arr ) ;\n    m = 3 ;\n    ans = findLen ( arr , 0 , 0 , n , m ) ;\n    if ( ans == - 1 ) :\n        print ( 0 ) ;\n    else :\n        print ( ans ) ;\n", "python_code_tokenized": "import numpy as np NEW_LINE maxN = 20 NEW_LINE maxM = 64 NEW_LINE dp = np . zeros ( ( maxN , maxM ) ) ; NEW_LINE v = np . zeros ( ( maxN , maxM ) ) ; NEW_LINE def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1 , curr | arr [ i ] , n , m ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE m = 3 ; NEW_LINE ans = findLen ( arr , 0 , 0 , n , m ) ; NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( 0 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) ; NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1470_A", "sol": 0, "python_code": "def printArr ( arr , n ) :\n    for i in range ( n ) :\n        print ( arr [ i ] , \"\" , end = \"\" )\n    print ( )\ndef generateUtil ( A , B , C , i , j , m , n , len , flag ) :\n    if ( flag ) :\n        if ( len ) :\n            printArr ( C , len + 1 )\n        for k in range ( i , m ) :\n            if ( not len ) :\n                C [ len ] = A [ k ]\n                generateUtil ( A , B , C , k + 1 , j , m , n , len , not flag )\n            else :\n                if ( A [ k ] > C [ len ] ) :\n                    C [ len + 1 ] = A [ k ]\n                    generateUtil ( A , B , C , k + 1 , j , m , n , len + 1 , not flag )\n    else :\n        for l in range ( j , n ) :\n            if ( B [ l ] > C [ len ] ) :\n                C [ len + 1 ] = B [ l ]\n                generateUtil ( A , B , C , i , l + 1 , m , n , len + 1 , not flag )\ndef generate ( A , B , m , n ) :\n    C = [ ]\n    for i in range ( m + n + 1 ) :\n        C.append ( 0 )\n    generateUtil ( A , B , C , 0 , 0 , m , n , 0 , True )\nA = [ 10 , 15 , 25 ]\nB = [ 5 , 20 , 30 ]\nn = len ( A )\nm = len ( B )\ngenerate ( A , B , n , m )\n", "python_code_tokenized": "def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def generateUtil ( A , B , C , i , j , m , n , len , flag ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT if ( len ) : NEW_LINE INDENT printArr ( C , len + 1 ) NEW_LINE DEDENT for k in range ( i , m ) : NEW_LINE INDENT if ( not len ) : NEW_LINE INDENT C [ len ] = A [ k ] NEW_LINE generateUtil ( A , B , C , k + 1 , j , m , n , len , not flag ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( A [ k ] > C [ len ] ) : NEW_LINE INDENT C [ len + 1 ] = A [ k ] NEW_LINE generateUtil ( A , B , C , k + 1 , j , m , n , len + 1 , not flag ) NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT for l in range ( j , n ) : NEW_LINE INDENT if ( B [ l ] > C [ len ] ) : NEW_LINE INDENT C [ len + 1 ] = B [ l ] NEW_LINE generateUtil ( A , B , C , i , l + 1 , m , n , len + 1 , not flag ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def generate ( A , B , m , n ) : NEW_LINE INDENT C = [ ] NEW_LINE for i in range ( m + n + 1 ) : NEW_LINE INDENT C . append ( 0 ) NEW_LINE DEDENT generateUtil ( A , B , C , 0 , 0 , m , n , 0 , True ) NEW_LINE DEDENT A = [ 10 , 15 , 25 ] NEW_LINE B = [ 5 , 20 , 30 ] NEW_LINE n = len ( A ) NEW_LINE m = len ( B ) NEW_LINE generate ( A , B , n , m ) NEW_LINE"}
{"id": "atcoder_AGC004_D", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nN , K = map ( int , input ( ).split ( ) )\nA = list ( map ( int , input ( ).split ( ) ) )\nans = 0\ngraph = [ [ ] for _ in range ( N ) ]\nPar = [ - 1 ] * N\nfor i , a in enumerate ( A ) :\n    if i == 0 :\n        if a != 1 :\n            ans += 1\n        continue\n    Par [ i ] = a - 1\n    graph [ a - 1 ].append ( i )\nqs = [ ]\nstack = [ 0 ]\nDepth = [ - 1 ] * N\nDepth [ 0 ] = 0\nwhile stack :\n    p = stack.pop ( )\n    for np in graph [ p ] :\n        Depth [ np ] = Depth [ p ] + 1\n        stack.append ( np )\n    qs.append ( ( Depth [ p ] , p ) )\nqs.sort ( reverse = True )\nchecked = [ False ] * N\nfor d , s in qs :\n    if d <= K : break\n    if checked [ s ] : continue\n    for _ in range ( K - 1 ) :\n        s = Par [ s ]\n    que = [ s ]\n    checked [ s ] = True\n    while que :\n        qq = [ ]\n        for p in que :\n            for np in graph [ p ] :\n                if not checked [ np ] :\n                    checked [ np ] = True\n                    qq.append ( np )\n        que = qq\n    ans += 1\nprint ( ans )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE graph = [ [ ] for _ in range ( N ) ] NEW_LINE Par = [ - 1 ] * N NEW_LINE for i , a in enumerate ( A ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT if a != 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT continue NEW_LINE DEDENT Par [ i ] = a - 1 NEW_LINE graph [ a - 1 ] . append ( i ) NEW_LINE DEDENT qs = [ ] NEW_LINE stack = [ 0 ] NEW_LINE Depth = [ - 1 ] * N NEW_LINE Depth [ 0 ] = 0 NEW_LINE while stack : NEW_LINE INDENT p = stack . pop ( ) NEW_LINE for np in graph [ p ] : NEW_LINE INDENT Depth [ np ] = Depth [ p ] + 1 NEW_LINE stack . append ( np ) NEW_LINE DEDENT qs . append ( ( Depth [ p ] , p ) ) NEW_LINE DEDENT qs . sort ( reverse = True ) NEW_LINE checked = [ False ] * N NEW_LINE for d , s in qs : NEW_LINE INDENT if d <= K : break NEW_LINE if checked [ s ] : continue NEW_LINE for _ in range ( K - 1 ) : NEW_LINE INDENT s = Par [ s ] NEW_LINE DEDENT que = [ s ] NEW_LINE checked [ s ] = True NEW_LINE while que : NEW_LINE INDENT qq = [ ] NEW_LINE for p in que : NEW_LINE INDENT for np in graph [ p ] : NEW_LINE INDENT if not checked [ np ] : NEW_LINE INDENT checked [ np ] = True NEW_LINE qq . append ( np ) NEW_LINE DEDENT DEDENT DEDENT que = qq NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "atcoder_ABC163_E", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nans = 0\nplace = [ 0 ] * n\nactive = sorted ( a , reverse = True )\nfor i in range ( n ) :\n    place [ i ] = a.index ( active [ i ] )\n    a [ a.index ( active [ i ] ) ] = - 1\ndp = [ [ 0 for i in range ( n + 2 ) ] for j in range ( n + 2 ) ]\nfor i in range ( n ) :\n    dp [ 0 ] [ i + 1 ] = dp [ 0 ] [ i ] + active [ i ] * abs ( n - i - 1 - place [ i ] )\n    dp [ i + 1 ] [ 0 ] = dp [ i ] [ 0 ] + active [ i ] * abs ( place [ i ] - i )\ndef check ( mat ) :\n    for i in range ( len ( mat ) ) :\n        print ( mat [ i ] )\n    print ( \"\\n\" )\nfor i in range ( n ) :\n    for x in range ( i + 2 ) :\n        y = i + 1 - x\n        if x != 0 and y != 0 :\n            dp [ x ] [ y ] = max ( dp [ x - 1 ] [ y ] + active [ i ] * abs ( place [ i ] - x + 1 ) , dp [ x ] [ y - 1 ] + active [ i ] * abs ( n - y - place [ i ] ) )\n            if i == n - 1 :\n                ans = max ( ans , dp [ x ] [ y ] )\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE place = [ 0 ] * n NEW_LINE active = sorted ( a , reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT place [ i ] = a . index ( active [ i ] ) NEW_LINE a [ a . index ( active [ i ] ) ] = - 1 NEW_LINE DEDENT dp = [ [ 0 for i in range ( n + 2 ) ] for j in range ( n + 2 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ i + 1 ] = dp [ 0 ] [ i ] + active [ i ] * abs ( n - i - 1 - place [ i ] ) NEW_LINE dp [ i + 1 ] [ 0 ] = dp [ i ] [ 0 ] + active [ i ] * abs ( place [ i ] - i ) NEW_LINE DEDENT def check ( mat ) : NEW_LINE INDENT for i in range ( len ( mat ) ) : NEW_LINE INDENT print ( mat [ i ] ) NEW_LINE DEDENT print ( \" \\n \" ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for x in range ( i + 2 ) : NEW_LINE INDENT y = i + 1 - x NEW_LINE if x != 0 and y != 0 : NEW_LINE INDENT dp [ x ] [ y ] = max ( dp [ x - 1 ] [ y ] + active [ i ] * abs ( place [ i ] - x + 1 ) , dp [ x ] [ y - 1 ] + active [ i ] * abs ( n - y - place [ i ] ) ) NEW_LINE if i == n - 1 : NEW_LINE INDENT ans = max ( ans , dp [ x ] [ y ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_3609_A", "sol": 0, "python_code": "def findFoot ( a , b , c , x1 , y1 ) :\n    temp = ( - 1 * ( a * x1 + b * y1 + c ) // ( a * a + b * b ) )\n    x = temp * a + x1\n    y = temp * b + y1\n    return ( x , y )\nif __name__ == \"__main__\" :\n    a , b , c = 0.0 , 1.0 , - 2\n    x1 , y1 = 3.0 , 3.0\n    foot = findFoot ( a , b , c , x1 , y1 )\n    print ( int ( foot [ 0 ] ) , int ( foot [ 1 ] ) )\n", "python_code_tokenized": "def findFoot ( a , b , c , x1 , y1 ) : NEW_LINE INDENT temp = ( - 1 * ( a * x1 + b * y1 + c ) // ( a * a + b * b ) ) NEW_LINE x = temp * a + x1 NEW_LINE y = temp * b + y1 NEW_LINE return ( x , y ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , c = 0.0 , 1.0 , - 2 NEW_LINE x1 , y1 = 3.0 , 3.0 NEW_LINE foot = findFoot ( a , b , c , x1 , y1 ) NEW_LINE print ( int ( foot [ 0 ] ) , int ( foot [ 1 ] ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3122_A", "sol": 0, "python_code": "import math\ndef canBePicked ( digits , num ) :\n    copyDigits = [ ] ;\n    for i in range ( len ( digits ) ) :\n        copyDigits.append ( digits [ i ] ) ;\n    while ( num > 0 ) :\n        digit = num % 10 ;\n        if ( copyDigits [ digit ] == 0 ) :\n            return False ;\n        else :\n            copyDigits [ digit ] -= 1 ;\n        num = math.floor ( num / 10 ) ;\n    return True ;\ndef countAlphabets ( n ) :\n    count = 0 ;\n    digits = [ 0 ] * 10 ;\n    while ( n > 0 ) :\n        digit = n % 10 ;\n        digits [ digit ] += 1 ;\n        n = math.floor ( n / 10 ) ;\n    for i in range ( ord ( 'a' ) , ord ( 'z' ) + 1 ) :\n        if ( canBePicked ( digits , i ) ) :\n            count += 1 ;\n    for i in range ( ord ( 'A' ) , ord ( 'Z' ) + 1 ) :\n        if ( canBePicked ( digits , i ) ) :\n            count += 1 ;\n    return count ;\nn = 1623455078 ;\nprint ( countAlphabets ( n ) ) ;\n", "python_code_tokenized": "import math NEW_LINE def canBePicked ( digits , num ) : NEW_LINE INDENT copyDigits = [ ] ; NEW_LINE for i in range ( len ( digits ) ) : NEW_LINE INDENT copyDigits . append ( digits [ i ] ) ; NEW_LINE DEDENT while ( num > 0 ) : NEW_LINE INDENT digit = num % 10 ; NEW_LINE if ( copyDigits [ digit ] == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT copyDigits [ digit ] -= 1 ; NEW_LINE DEDENT num = math . floor ( num / 10 ) ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def countAlphabets ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE digits = [ 0 ] * 10 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 ; NEW_LINE digits [ digit ] += 1 ; NEW_LINE n = math . floor ( n / 10 ) ; NEW_LINE DEDENT for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT if ( canBePicked ( digits , i ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT for i in range ( ord ( ' A ' ) , ord ( ' Z ' ) + 1 ) : NEW_LINE INDENT if ( canBePicked ( digits , i ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT n = 1623455078 ; NEW_LINE print ( countAlphabets ( n ) ) ; NEW_LINE"}
{"id": "codeforces_1330_B", "sol": 0, "python_code": "T = int ( input ( ) )\nfor _ in range ( T ) :\n    n = int ( input ( ) )\n    lst = list ( map ( int , input ( ).split ( ) ) )\n    m = max ( lst )\n    diclstfront = [ { } ]\n    diclstback = [ { } ]\n    xFront , xBack = 0 , 0\n    for i in lst :\n        if i in diclstfront [ xFront ].keys ( ) :\n            diclstfront.append ( { } )\n            xFront += 1\n        diclstfront [ xFront ] [ i ] = 1\n    for i in lst [ : : - 1 ] :\n        if i in diclstback [ xBack ].keys ( ) :\n            diclstback.append ( { } )\n            xBack += 1\n        diclstback [ xBack ] [ i ] = 1\n    ans = 0\n    lst = [ ]\n    if len ( diclstfront ) == 2 :\n        lst1 = list ( diclstfront [ 0 ].keys ( ) )\n        lst2 = list ( diclstfront [ 1 ].keys ( ) )\n        m1 , m2 = max ( lst1 ) , max ( lst2 )\n        if sorted ( lst1 ) == list ( range ( 1 , m1 + 1 ) ) and sorted ( lst2 ) == list ( range ( 1 , m2 + 1 ) ) :\n            ans += 1\n            lst.append ( [ len ( lst1 ) , len ( lst2 ) ] )\n    if len ( diclstback ) == 2 :\n        lst1 = list ( diclstback [ 0 ].keys ( ) )\n        lst2 = list ( diclstback [ 1 ].keys ( ) )\n        m1 , m2 = max ( lst1 ) , max ( lst2 )\n        if sorted ( lst1 ) == list ( range ( 1 , m1 + 1 ) ) and sorted ( lst2 ) == list ( range ( 1 , m2 + 1 ) ) and [ len ( lst2 ) , len ( lst1 ) ] not in lst :\n            ans += 1\n            lst.append ( [ len ( lst2 ) , len ( lst1 ) ] )\n    print ( ans )\n    for i in range ( ans ) :\n        print ( lst [ i ] [ 0 ] , ' ' , lst [ i ] [ 1 ] )\n", "python_code_tokenized": "T = int ( input ( ) ) NEW_LINE for _ in range ( T ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = max ( lst ) NEW_LINE diclstfront = [ { } ] NEW_LINE diclstback = [ { } ] NEW_LINE xFront , xBack = 0 , 0 NEW_LINE for i in lst : NEW_LINE INDENT if i in diclstfront [ xFront ] . keys ( ) : NEW_LINE INDENT diclstfront . append ( { } ) NEW_LINE xFront += 1 NEW_LINE DEDENT diclstfront [ xFront ] [ i ] = 1 NEW_LINE DEDENT for i in lst [ : : - 1 ] : NEW_LINE INDENT if i in diclstback [ xBack ] . keys ( ) : NEW_LINE INDENT diclstback . append ( { } ) NEW_LINE xBack += 1 NEW_LINE DEDENT diclstback [ xBack ] [ i ] = 1 NEW_LINE DEDENT ans = 0 NEW_LINE lst = [ ] NEW_LINE if len ( diclstfront ) == 2 : NEW_LINE INDENT lst1 = list ( diclstfront [ 0 ] . keys ( ) ) NEW_LINE lst2 = list ( diclstfront [ 1 ] . keys ( ) ) NEW_LINE m1 , m2 = max ( lst1 ) , max ( lst2 ) NEW_LINE if sorted ( lst1 ) == list ( range ( 1 , m1 + 1 ) ) and sorted ( lst2 ) == list ( range ( 1 , m2 + 1 ) ) : NEW_LINE INDENT ans += 1 NEW_LINE lst . append ( [ len ( lst1 ) , len ( lst2 ) ] ) NEW_LINE DEDENT DEDENT if len ( diclstback ) == 2 : NEW_LINE INDENT lst1 = list ( diclstback [ 0 ] . keys ( ) ) NEW_LINE lst2 = list ( diclstback [ 1 ] . keys ( ) ) NEW_LINE m1 , m2 = max ( lst1 ) , max ( lst2 ) NEW_LINE if sorted ( lst1 ) == list ( range ( 1 , m1 + 1 ) ) and sorted ( lst2 ) == list ( range ( 1 , m2 + 1 ) ) and [ len ( lst2 ) , len ( lst1 ) ] not in lst : NEW_LINE INDENT ans += 1 NEW_LINE lst . append ( [ len ( lst2 ) , len ( lst1 ) ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE for i in range ( ans ) : NEW_LINE INDENT print ( lst [ i ] [ 0 ] , ' \u2581 ' , lst [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00201_A", "sol": 0, "python_code": "items = { }\nrecipes = { }\ndef reset ( ) :\n    items.clear ( )\n    recipes.clear ( )\ndef algorithm ( ) :\n    while True :\n        reset ( )\n        for _ in range ( int ( input ( ) ) ) :\n            item , price = input ( ).split ( )\n            items [ item ] = int ( price )\n        if len ( items ) == 0 :\n            break\n        for _ in range ( int ( input ( ) ) ) :\n            recipe = input ( ).split ( )\n            recipes [ recipe [ 0 ] ] = recipe [ 2 : ]\n        for _ in range ( len ( recipes ) ) :\n            for k , v in recipes.items ( ) :\n                total = 0\n                for i in range ( len ( v ) ) :\n                    total += items [ v [ i ] ]\n                items [ k ] = items [ k ] if items [ k ] < total else total\n        print ( items [ input ( ) ] )\ndef main ( ) :\n    algorithm ( )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "items = { } NEW_LINE recipes = { } NEW_LINE def reset ( ) : NEW_LINE INDENT items . clear ( ) NEW_LINE recipes . clear ( ) NEW_LINE DEDENT def algorithm ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT reset ( ) NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT item , price = input ( ) . split ( ) NEW_LINE items [ item ] = int ( price ) NEW_LINE DEDENT if len ( items ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT recipe = input ( ) . split ( ) NEW_LINE recipes [ recipe [ 0 ] ] = recipe [ 2 : ] NEW_LINE DEDENT for _ in range ( len ( recipes ) ) : NEW_LINE INDENT for k , v in recipes . items ( ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT total += items [ v [ i ] ] NEW_LINE DEDENT items [ k ] = items [ k ] if items [ k ] < total else total NEW_LINE DEDENT DEDENT print ( items [ input ( ) ] ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT algorithm ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4602_A", "sol": 0, "python_code": "def reverseFibonacci ( n ) :\n    a = [ 0 ] * n\n    a [ 0 ] = 0\n    a [ 1 ] = 1\n    for i in range ( 2 , n ) :\n        a [ i ] = a [ i - 2 ] + a [ i - 1 ]\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        print ( a [ i ] , end = \" \" )\nn = 5\nreverseFibonacci ( n )\n", "python_code_tokenized": "def reverseFibonacci ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 2 ] + a [ i - 1 ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE reverseFibonacci ( n ) NEW_LINE"}
{"id": "geeksforgeeks_4494_A", "sol": 0, "python_code": "def areAllBitsSet ( n ) :\n    if ( n == 0 ) :\n        return \"No\"\n    while ( n > 0 ) :\n        if ( ( n & 1 ) == 0 ) :\n            return \"No\"\n        n = n >> 1\n    return \"Yes\"\nn = 7\nprint ( areAllBitsSet ( n ) )\n", "python_code_tokenized": "def areAllBitsSet ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return \" Yes \" NEW_LINE DEDENT n = 7 NEW_LINE print ( areAllBitsSet ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4495_A", "sol": 0, "python_code": "def areAllBitsSet ( n ) :\n    if ( n == 0 ) :\n        return \"No\"\n    if ( ( ( n + 1 ) & n ) == 0 ) :\n        return \"Yes\"\n    return \"No\"\nn = 7\nprint ( areAllBitsSet ( n ) )\n", "python_code_tokenized": "def areAllBitsSet ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT return \" No \" NEW_LINE DEDENT n = 7 NEW_LINE print ( areAllBitsSet ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4927_A", "sol": 0, "python_code": "def convertOpposite ( str ) :\n    ln = len ( str )\n    for i in range ( ln ) :\n        if str [ i ] >= 'a' and str [ i ] <= 'z' :\n            str [ i ] = chr ( ord ( str [ i ] ) - 32 )\n        elif str [ i ] >= 'A' and str [ i ] <= 'Z' :\n            str [ i ] = chr ( ord ( str [ i ] ) + 32 )\nif __name__ == \"__main__\" :\n    str = \"GeEkSfOrGeEkS\"\n    str = list ( str )\n    convertOpposite ( str )\n    str = ''.join ( str )\n    print ( str )\n", "python_code_tokenized": "def convertOpposite ( str ) : NEW_LINE INDENT ln = len ( str ) NEW_LINE for i in range ( ln ) : NEW_LINE INDENT if str [ i ] >= ' a ' and str [ i ] <= ' z ' : NEW_LINE INDENT str [ i ] = chr ( ord ( str [ i ] ) - 32 ) NEW_LINE DEDENT elif str [ i ] >= ' A ' and str [ i ] <= ' Z ' : NEW_LINE INDENT str [ i ] = chr ( ord ( str [ i ] ) + 32 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" GeEkSfOrGeEkS \" NEW_LINE str = list ( str ) NEW_LINE convertOpposite ( str ) NEW_LINE str = ' ' . join ( str ) NEW_LINE print ( str ) NEW_LINE DEDENT"}
{"id": "codeforces_1499_B", "sol": 0, "python_code": "t = int ( input ( ) )\nwhile t > 0 :\n    t -= 1\n    S = input ( )\n    s = list ( S )\n    stack = [ ]\n    pos = [ ]\n    check0 = 0\n    for i in range ( 0 , len ( s ) ) :\n        j = len ( s ) - i - 1\n        stack.append ( [ j , int ( s [ j ] ) ] )\n        if s [ j ] == \"0\" :\n            if check0 == 0 :\n                if not pos :\n                    stack.pop ( )\n                    pos.append ( j )\n                else :\n                    if pos [ - 1 ] - j > 1 :\n                        stack.pop ( )\n                        pos.append ( j )\n                if stack :\n                    if stack [ - 1 ] [ 1 ] == 0 :\n                        check0 = 1\n        if check0 == 1 :\n            if s [ j ] == \"1\" :\n                if pos [ - 1 ] - j > 1 :\n                    stack.pop ( )\n                    pos.append ( j )\n    stack2 = [ ]\n    check = 0\n    for i in range ( 0 , len ( stack ) - 1 ) :\n        if stack [ i ] [ 1 ] < stack [ i + 1 ] [ 1 ] :\n            check = 1\n    if check == 1 :\n        print ( \"NO\" )\n    else :\n        print ( \"YES\" )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE S = input ( ) NEW_LINE s = list ( S ) NEW_LINE stack = [ ] NEW_LINE pos = [ ] NEW_LINE check0 = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT j = len ( s ) - i - 1 NEW_LINE stack . append ( [ j , int ( s [ j ] ) ] ) NEW_LINE if s [ j ] == \"0\" : NEW_LINE INDENT if check0 == 0 : NEW_LINE INDENT if not pos : NEW_LINE INDENT stack . pop ( ) NEW_LINE pos . append ( j ) NEW_LINE DEDENT else : NEW_LINE INDENT if pos [ - 1 ] - j > 1 : NEW_LINE INDENT stack . pop ( ) NEW_LINE pos . append ( j ) NEW_LINE DEDENT DEDENT if stack : NEW_LINE INDENT if stack [ - 1 ] [ 1 ] == 0 : NEW_LINE INDENT check0 = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if check0 == 1 : NEW_LINE INDENT if s [ j ] == \"1\" : NEW_LINE INDENT if pos [ - 1 ] - j > 1 : NEW_LINE INDENT stack . pop ( ) NEW_LINE pos . append ( j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT stack2 = [ ] NEW_LINE check = 0 NEW_LINE for i in range ( 0 , len ( stack ) - 1 ) : NEW_LINE INDENT if stack [ i ] [ 1 ] < stack [ i + 1 ] [ 1 ] : NEW_LINE INDENT check = 1 NEW_LINE DEDENT DEDENT if check == 1 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_639_A", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nn , k , q = map ( int , input ( ).split ( ) )\nw = list ( map ( int , input ( ).split ( ) ) )\nd = [ 0 ] * ( n + 1 )\nc , x = 0 , [ ]\nfor i in range ( q ) :\n    a , b = map ( int , input ( ).split ( ) )\n    if a == 1 :\n        d [ b ] = 1\n        if c < k :\n            c += 1\n            x.append ( w [ b - 1 ] )\n            x.sort ( reverse = True )\n        else :\n            if w [ b - 1 ] > x [ - 1 ] :\n                x.pop ( )\n                x.append ( w [ b - 1 ] )\n                x.sort ( reverse = True )\n    else :\n        if d [ b ] == 0 :\n            print ( 'NO' )\n        elif d [ b ] == 1 :\n            if w [ b - 1 ] >= x [ - 1 ] :\n                print ( 'YES' )\n            else :\n                print ( 'NO' )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , k , q = map ( int , input ( ) . split ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = [ 0 ] * ( n + 1 ) NEW_LINE c , x = 0 , [ ] NEW_LINE for i in range ( q ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 1 : NEW_LINE INDENT d [ b ] = 1 NEW_LINE if c < k : NEW_LINE INDENT c += 1 NEW_LINE x . append ( w [ b - 1 ] ) NEW_LINE x . sort ( reverse = True ) NEW_LINE DEDENT else : NEW_LINE INDENT if w [ b - 1 ] > x [ - 1 ] : NEW_LINE INDENT x . pop ( ) NEW_LINE x . append ( w [ b - 1 ] ) NEW_LINE x . sort ( reverse = True ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if d [ b ] == 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT elif d [ b ] == 1 : NEW_LINE INDENT if w [ b - 1 ] >= x [ - 1 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_1603_A", "sol": 0, "python_code": "def find ( a , b , k , n1 , n2 ) :\n    s = set ( )\n    for i in range ( n2 ) :\n        s.add ( b [ i ] )\n    missing = 0\n    for i in range ( n1 ) :\n        if a [ i ] not in s :\n            missing += 1\n        if missing == k :\n            return a [ i ]\n    return - 1\na = [ 0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 15 ]\nb = [ 4 , 10 , 6 , 8 , 12 ]\nn1 = len ( a )\nn2 = len ( b )\nk = 3\nprint ( find ( a , b , k , n1 , n2 ) )\n", "python_code_tokenized": "def find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if a [ i ] not in s : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if missing == k : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT a = [ 0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 15 ] NEW_LINE b = [ 4 , 10 , 6 , 8 , 12 ] NEW_LINE n1 = len ( a ) NEW_LINE n2 = len ( b ) NEW_LINE k = 3 NEW_LINE print ( find ( a , b , k , n1 , n2 ) ) NEW_LINE"}
{"id": "geeksforgeeks_4607_A", "sol": 0, "python_code": "def pell ( n ) :\n    if ( n <= 2 ) :\n        return n\n    a = 1\n    b = 2\n    for i in range ( 3 , n + 1 ) :\n        c = 2 * b + a\n        a = b\n        b = c\n    return b\nn = 4\nprint ( pell ( n ) )\n", "python_code_tokenized": "def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT c = 2 * b + a NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE DEDENT n = 4 NEW_LINE print ( pell ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4997_A", "sol": 0, "python_code": "import sys\ndef maxProduct ( arr , n ) :\n    if n < 3 :\n        return - 1\n    max_product = - ( sys.maxsize - 1 )\n    for i in range ( 0 , n - 2 ) :\n        for j in range ( i + 1 , n - 1 ) :\n            for k in range ( j + 1 , n ) :\n                max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] )\n    return max_product\narr = [ 10 , 3 , 5 , 6 , 20 ]\nn = len ( arr )\nmax = maxProduct ( arr , n )\nif max == - 1 :\n    print ( \"No Tripplet Exits\" )\nelse :\n    print ( \"Maximum product is\" , max )\n", "python_code_tokenized": "import sys NEW_LINE def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE max = maxProduct ( arr , n ) NEW_LINE if max == - 1 : NEW_LINE INDENT print ( \" No \u2581 Tripplet \u2581 Exits \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Maximum \u2581 product \u2581 is \" , max ) NEW_LINE DEDENT"}
{"id": "aizu_p02020_A", "sol": 0, "python_code": "N = int ( input ( ) )\nA = list ( map ( int , input ( ).split ( ) ) )\nA.sort ( )\nif sum ( A ) % 2 == 0 :\n    print ( sum ( A ) // 2 )\nelse :\n    for i in range ( N ) :\n        if A [ i ] % 2 == 1 :\n            break\n    print ( ( sum ( A ) - A [ i ] ) // 2 )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( ) NEW_LINE if sum ( A ) % 2 == 0 : NEW_LINE INDENT print ( sum ( A ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if A [ i ] % 2 == 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ( sum ( A ) - A [ i ] ) // 2 ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC166_B", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nl = [ ]\nfor _ in range ( k ) :\n    d = int ( input ( ) )\n    a = list ( map ( int , input ( ).split ( ) ) )\n    for i in range ( d ) :\n        l.append ( a [ i ] )\nprint ( n - len ( set ( l ) ) )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for _ in range ( k ) : NEW_LINE INDENT d = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( d ) : NEW_LINE INDENT l . append ( a [ i ] ) NEW_LINE DEDENT DEDENT print ( n - len ( set ( l ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_2861_A", "sol": 0, "python_code": "def computeLPSArray ( string ) :\n    M = len ( string )\n    lps = [ None ] * M\n    length = 0\n    lps [ 0 ] = 0\n    i = 1\n    while i < M :\n        if string [ i ] == string [ length ] :\n            length += 1\n            lps [ i ] = length\n            i += 1\n        else :\n            if length != 0 :\n                length = lps [ length - 1 ]\n            else :\n                lps [ i ] = 0\n                i += 1\n    return lps\ndef getMinCharToAddedToMakeStringPalin ( string ) :\n    revStr = string [ : : - 1 ]\n    concat = string + \"$\" + revStr\n    lps = computeLPSArray ( concat )\n    return len ( string ) - lps [ - 1 ]\nif __name__ == \"__main__\" :\n    string = \"AACECAAAA\"\n    print ( getMinCharToAddedToMakeStringPalin ( string ) )\n", "python_code_tokenized": "def computeLPSArray ( string ) : NEW_LINE INDENT M = len ( string ) NEW_LINE lps = [ None ] * M NEW_LINE length = 0 NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while i < M : NEW_LINE INDENT if string [ i ] == string [ length ] : NEW_LINE INDENT length += 1 NEW_LINE lps [ i ] = length NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if length != 0 : NEW_LINE INDENT length = lps [ length - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT return lps NEW_LINE DEDENT def getMinCharToAddedToMakeStringPalin ( string ) : NEW_LINE INDENT revStr = string [ : : - 1 ] NEW_LINE concat = string + \" $ \" + revStr NEW_LINE lps = computeLPSArray ( concat ) NEW_LINE return len ( string ) - lps [ - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" AACECAAAA \" NEW_LINE print ( getMinCharToAddedToMakeStringPalin ( string ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_883_A", "sol": 0, "python_code": "def ReverseComplement ( s , n , k ) :\n    rev = ( k + 1 ) // 2\n    complment = k - rev\n    if ( rev % 2 ) :\n        s = s [ : : - 1 ]\n    if ( complment % 2 ) :\n        for i in range ( n ) :\n            if ( s [ i ] == '0' ) :\n                s [ i ] = '1'\n            else :\n                s [ i ] = '0'\n    return s\nif __name__ == '__main__' :\n    str1 = \"10011\"\n    k = 5\n    n = len ( str1 )\n    print ( ReverseComplement ( str1 , n , k ) )\n", "python_code_tokenized": "def ReverseComplement ( s , n , k ) : NEW_LINE INDENT rev = ( k + 1 ) // 2 NEW_LINE complment = k - rev NEW_LINE if ( rev % 2 ) : NEW_LINE INDENT s = s [ : : - 1 ] NEW_LINE DEDENT if ( complment % 2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT s [ i ] = '1' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = '0' NEW_LINE DEDENT DEDENT DEDENT return s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \"10011\" NEW_LINE k = 5 NEW_LINE n = len ( str1 ) NEW_LINE print ( ReverseComplement ( str1 , n , k ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02397_A", "sol": 0, "python_code": "while True :\n    x , y = map ( int , input ( ).split ( ) )\n    if x == 0 and y == 0 : break\n    liste = [ x , y ]\n    liste.sort ( )\n    print ( liste [ 0 ] , liste [ 1 ] )\n", "python_code_tokenized": "while True : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x == 0 and y == 0 : break NEW_LINE liste = [ x , y ] NEW_LINE liste . sort ( ) NEW_LINE print ( liste [ 0 ] , liste [ 1 ] ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC162_A", "sol": 0, "python_code": "print ( [ \"No\" , \"Yes\" ] [ \"7\" in input ( ) ] )\n", "python_code_tokenized": "print ( [ \" No \" , \" Yes \" ] [ \"7\" in input ( ) ] ) NEW_LINE"}
{"id": "codeforces_1185_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor z in range ( 0 , t ) :\n    s = list ( input ( ) )\n    v = list ( input ( ) )\n    x = [ ]\n    count = 1\n    for i in range ( 0 , len ( s ) ) :\n        if i == len ( s ) - 1 :\n            x.append ( [ s [ i ] , count ] )\n        elif s [ i ] != s [ i + 1 ] :\n            x.append ( [ s [ i ] , count ] )\n            count = 1\n        else :\n            count += 1\n    count = 1\n    point = 0\n    ans = 'YES'\n    for i in range ( 0 , len ( v ) ) :\n        if point > len ( x ) - 1 :\n            ans = 'NO'\n            break\n        elif i == len ( v ) - 1 :\n            if point + 1 <= len ( x ) - 1 :\n                ans = 'NO'\n                break\n            if x [ point ] [ 0 ] == v [ i ] and count >= x [ point ] [ 1 ] :\n                pass\n            else :\n                ans = 'NO'\n        elif v [ i ] != v [ i + 1 ] :\n            if x [ point ] [ 0 ] == v [ i ] and count >= x [ point ] [ 1 ] :\n                point += 1\n                count = 1\n            else :\n                ans = 'NO'\n        else :\n            count += 1\n    print ( ans )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for z in range ( 0 , t ) : NEW_LINE INDENT s = list ( input ( ) ) NEW_LINE v = list ( input ( ) ) NEW_LINE x = [ ] NEW_LINE count = 1 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if i == len ( s ) - 1 : NEW_LINE INDENT x . append ( [ s [ i ] , count ] ) NEW_LINE DEDENT elif s [ i ] != s [ i + 1 ] : NEW_LINE INDENT x . append ( [ s [ i ] , count ] ) NEW_LINE count = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT count = 1 NEW_LINE point = 0 NEW_LINE ans = ' YES ' NEW_LINE for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT if point > len ( x ) - 1 : NEW_LINE INDENT ans = ' NO ' NEW_LINE break NEW_LINE DEDENT elif i == len ( v ) - 1 : NEW_LINE INDENT if point + 1 <= len ( x ) - 1 : NEW_LINE INDENT ans = ' NO ' NEW_LINE break NEW_LINE DEDENT if x [ point ] [ 0 ] == v [ i ] and count >= x [ point ] [ 1 ] : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT ans = ' NO ' NEW_LINE DEDENT DEDENT elif v [ i ] != v [ i + 1 ] : NEW_LINE INDENT if x [ point ] [ 0 ] == v [ i ] and count >= x [ point ] [ 1 ] : NEW_LINE INDENT point += 1 NEW_LINE count = 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ' NO ' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4717_A", "sol": 0, "python_code": "pref = [ 0 ] * 100010 ;\ndef isPerfectCube ( x ) :\n    cr = round ( x ** ( 1 / 3 ) ) ;\n    rslt = x if ( cr * cr * cr == x ) else 0 ;\n    return rslt ;\ndef compute ( ) :\n    for i in range ( 1 , 100001 ) :\n        pref [ i ] = pref [ i - 1 ] + isPerfectCube ( i ) ;\ndef printSum ( L , R ) :\n    sum = pref [ R ] - pref [ L - 1 ] ;\n    print ( sum , end = \" \" ) ;\nif __name__ == \"__main__\" :\n    compute ( ) ;\n    Q = 4 ;\n    arr = [ [ 1 , 10 ] , [ 1 , 100 ] , [ 2 , 25 ] , [ 4 , 50 ] ] ;\n    for i in range ( Q ) :\n        printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ;\n", "python_code_tokenized": "pref = [ 0 ] * 100010 ; NEW_LINE def isPerfectCube ( x ) : NEW_LINE INDENT cr = round ( x ** ( 1 / 3 ) ) ; NEW_LINE rslt = x if ( cr * cr * cr == x ) else 0 ; NEW_LINE return rslt ; NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + isPerfectCube ( i ) ; NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT sum = pref [ R ] - pref [ L - 1 ] ; NEW_LINE print ( sum , end = \" \u2581 \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT compute ( ) ; NEW_LINE Q = 4 ; NEW_LINE arr = [ [ 1 , 10 ] , [ 1 , 100 ] , [ 2 , 25 ] , [ 4 , 50 ] ] ; NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_569_B", "sol": 0, "python_code": "number_of_item = int ( input ( ) )\nout = [ ]\narr1 = { x for x in range ( 1 , number_of_item + 1 ) }\ninitial_inventory = [ int ( i ) for i in input ( ).split ( ) ]\nfor x in initial_inventory :\n    if x in arr1 :\n        arr1.remove ( x )\n        out.append ( x )\n    else :\n        out.append ( None )\ni = 0\nfor x in out :\n    if x is None :\n        out [ i ] = arr1.pop ( )\n    i += 1\nprint ( * out )\n", "python_code_tokenized": "number_of_item = int ( input ( ) ) NEW_LINE out = [ ] NEW_LINE arr1 = { x for x in range ( 1 , number_of_item + 1 ) } NEW_LINE initial_inventory = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE for x in initial_inventory : NEW_LINE INDENT if x in arr1 : NEW_LINE INDENT arr1 . remove ( x ) NEW_LINE out . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT out . append ( None ) NEW_LINE DEDENT DEDENT i = 0 NEW_LINE for x in out : NEW_LINE INDENT if x is None : NEW_LINE INDENT out [ i ] = arr1 . pop ( ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( * out ) NEW_LINE"}
{"id": "codeforces_315_B", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\narr = [ int ( x ) for x in input ( ).split ( ) ]\ntotal = 0\nfor _ in range ( m ) :\n    op = [ int ( x ) for x in input ( ).split ( ) ]\n    if op [ 0 ] == 1 :\n        idx = op [ 1 ] - 1\n        arr [ idx ] = op [ 2 ] - total\n    elif op [ 0 ] == 2 :\n        total += op [ 1 ]\n    else :\n        idx = op [ 1 ] - 1\n        print ( arr [ idx ] + total )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE arr = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE total = 0 NEW_LINE for _ in range ( m ) : NEW_LINE INDENT op = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if op [ 0 ] == 1 : NEW_LINE INDENT idx = op [ 1 ] - 1 NEW_LINE arr [ idx ] = op [ 2 ] - total NEW_LINE DEDENT elif op [ 0 ] == 2 : NEW_LINE INDENT total += op [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT idx = op [ 1 ] - 1 NEW_LINE print ( arr [ idx ] + total ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_80_A", "sol": 0, "python_code": "c = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 ]\nn , m = map ( int , input ( ).split ( ) )\na = c.index ( n )\nif c [ a + 1 ] == m :\n    print ( 'YES' )\nelse :\n    print ( 'NO' )\n", "python_code_tokenized": "c = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 ] NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = c . index ( n ) NEW_LINE if c [ a + 1 ] == m : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"}
{"id": "codeforces_1149_A", "sol": 0, "python_code": "from collections import Counter\nx = int ( input ( ) )\ny = list ( map ( int , input ( ).split ( ) ) )\nif x == 1 :\n    print ( y [ 0 ] )\nelif y.count ( 2 ) == 0 or y.count ( 1 ) == 0 :\n    for i in y :\n        print ( i , end = \" \" )\nelse :\n    c = Counter ( y )\n    print ( 2 , 1 , end = \" \" )\n    c [ 1 ] -= 1\n    c [ 2 ] -= 1\n    if c [ 2 ] > 0 :\n        for i in range ( c [ 2 ] ) :\n            print ( 2 , end = \" \" )\n    if c [ 1 ] > 0 :\n        for i in range ( c [ 1 ] ) :\n            print ( 1 , end = \" \" )\n        print ( )\n", "python_code_tokenized": "from collections import Counter NEW_LINE x = int ( input ( ) ) NEW_LINE y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if x == 1 : NEW_LINE INDENT print ( y [ 0 ] ) NEW_LINE DEDENT elif y . count ( 2 ) == 0 or y . count ( 1 ) == 0 : NEW_LINE INDENT for i in y : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT c = Counter ( y ) NEW_LINE print ( 2 , 1 , end = \" \u2581 \" ) NEW_LINE c [ 1 ] -= 1 NEW_LINE c [ 2 ] -= 1 NEW_LINE if c [ 2 ] > 0 : NEW_LINE INDENT for i in range ( c [ 2 ] ) : NEW_LINE INDENT print ( 2 , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if c [ 1 ] > 0 : NEW_LINE INDENT for i in range ( c [ 1 ] ) : NEW_LINE INDENT print ( 1 , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3455_A", "sol": 0, "python_code": "MAX = 10000\nhashTable = [ 0 ] * MAX\ndef minOperations ( arr , n ) :\n    arr.sort ( )\n    for i in range ( n ) :\n        hashTable [ arr [ i ] ] += 1\n    res = 0\n    for i in range ( n ) :\n        if ( hashTable [ arr [ i ] ] ) :\n            for j in range ( i , n ) :\n                if ( arr [ j ] % arr [ i ] == 0 ) :\n                    hashTable [ arr [ j ] ] = 0\n            res += 1\n    return res\nif __name__ == \"__main__\" :\n    arr = [ 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 ]\n    n = len ( arr )\n    print ( minOperations ( arr , n ) )\n", "python_code_tokenized": "MAX = 10000 NEW_LINE hashTable = [ 0 ] * MAX NEW_LINE def minOperations ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hashTable [ arr [ i ] ] ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT hashTable [ arr [ j ] ] = 0 NEW_LINE DEDENT DEDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4776_A", "sol": 0, "python_code": "def shuffle ( N , key ) :\n    NO_OF_BITS = N\n    reverse_num = 0\n    for i in range ( NO_OF_BITS ) :\n        temp = ( key & ( 1 << i ) )\n        if ( temp ) :\n            reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) )\n    print ( reverse_num )\nN = 3\nkey = 3\nshuffle ( N , key )\n", "python_code_tokenized": "def shuffle ( N , key ) : NEW_LINE INDENT NO_OF_BITS = N NEW_LINE reverse_num = 0 NEW_LINE for i in range ( NO_OF_BITS ) : NEW_LINE INDENT temp = ( key & ( 1 << i ) ) NEW_LINE if ( temp ) : NEW_LINE INDENT reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) NEW_LINE DEDENT DEDENT print ( reverse_num ) NEW_LINE DEDENT N = 3 NEW_LINE key = 3 NEW_LINE shuffle ( N , key ) NEW_LINE"}
{"id": "codeforces_285_B", "sol": 0, "python_code": "n , s , t = map ( int , input ( ).split ( ) )\np = [ [ x , False ] for x in map ( int , input ( ).split ( ) ) ]\nans = 0\nwhile True :\n    if s == t :\n        print ( ans ) ; break\n    if p [ s - 1 ] [ 1 ] :\n        print ( - 1 ) ; break\n    else :\n        p [ s - 1 ] [ 1 ] = True\n        s = p [ s - 1 ] [ 0 ]\n    ans += 1\n", "python_code_tokenized": "n , s , t = map ( int , input ( ) . split ( ) ) NEW_LINE p = [ [ x , False ] for x in map ( int , input ( ) . split ( ) ) ] NEW_LINE ans = 0 NEW_LINE while True : NEW_LINE INDENT if s == t : NEW_LINE INDENT print ( ans ) ; break NEW_LINE DEDENT if p [ s - 1 ] [ 1 ] : NEW_LINE INDENT print ( - 1 ) ; break NEW_LINE DEDENT else : NEW_LINE INDENT p [ s - 1 ] [ 1 ] = True NEW_LINE s = p [ s - 1 ] [ 0 ] NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1056_A", "sol": 0, "python_code": "def countGreater ( arr , n , k ) :\n    l = 0\n    r = n - 1\n    leftGreater = n\n    while ( l <= r ) :\n        m = int ( l + ( r - l ) / 2 )\n        if ( arr [ m ] > k ) :\n            leftGreater = m\n            r = m - 1\n        else :\n            l = m + 1\n    return ( n - leftGreater )\nif __name__ == '__main__' :\n    arr = [ 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 ]\n    n = len ( arr )\n    k = 7\n    print ( countGreater ( arr , n , k ) )\n", "python_code_tokenized": "def countGreater ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE leftGreater = n NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = int ( l + ( r - l ) / 2 ) NEW_LINE if ( arr [ m ] > k ) : NEW_LINE INDENT leftGreater = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return ( n - leftGreater ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE k = 7 NEW_LINE print ( countGreater ( arr , n , k ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2763_A", "sol": 0, "python_code": "def match_words ( dictionary , sentence , n , m ) :\n    mp = dict ( )\n    for i in range ( n ) :\n        mp [ dictionary [ i ] ] = mp.get ( dictionary [ i ] , 0 ) + 1\n    for i in range ( m ) :\n        if ( mp [ sentence [ i ] ] ) :\n            mp [ sentence [ i ] ] -= 1\n        else :\n            return False\n    return True\ndictionary = [ \"find\" , \"a\" , \"geeks\" , \"all\" , \"for\" , \"on\" , \"geeks\" , \"answers\" , \"inter\" ]\nn = len ( dictionary )\nsentence = [ \"find\" , \"all\" , \"answers\" , \"on\" , \"geeks\" , \"for\" , \"geeks\" ]\nm = len ( sentence )\nif ( match_words ( dictionary , sentence , n , m ) ) :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "def match_words ( dictionary , sentence , n , m ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ dictionary [ i ] ] = mp . get ( dictionary [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( mp [ sentence [ i ] ] ) : NEW_LINE INDENT mp [ sentence [ i ] ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT dictionary = [ \" find \" , \" a \" , \" geeks \" , \" all \" , \" for \" , \" on \" , \" geeks \" , \" answers \" , \" inter \" ] NEW_LINE n = len ( dictionary ) NEW_LINE sentence = [ \" find \" , \" all \" , \" answers \" , \" on \" , \" geeks \" , \" for \" , \" geeks \" ] NEW_LINE m = len ( sentence ) NEW_LINE if ( match_words ( dictionary , sentence , n , m ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3281_A", "sol": 0, "python_code": "import random\npermutation = [ ]\ndef printPermutation ( ) :\n    for i in permutation :\n        print ( i , end = \" \" )\ndef give_random_number ( l , r ) :\n    x = random.randint ( l , r )\n    return x\ndef generate_random_permutation ( l , r ) :\n    if ( l > r ) :\n        return\n    n = give_random_number ( l , r )\n    permutation.append ( n )\n    generate_random_permutation ( l , n - 1 )\n    generate_random_permutation ( n + 1 , r )\nl = 5\nr = 15\ngenerate_random_permutation ( l , r )\nprintPermutation ( )\n", "python_code_tokenized": "import random NEW_LINE permutation = [ ] NEW_LINE def printPermutation ( ) : NEW_LINE INDENT for i in permutation : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT def give_random_number ( l , r ) : NEW_LINE INDENT x = random . randint ( l , r ) NEW_LINE return x NEW_LINE DEDENT def generate_random_permutation ( l , r ) : NEW_LINE INDENT if ( l > r ) : NEW_LINE INDENT return NEW_LINE DEDENT n = give_random_number ( l , r ) NEW_LINE permutation . append ( n ) NEW_LINE generate_random_permutation ( l , n - 1 ) NEW_LINE generate_random_permutation ( n + 1 , r ) NEW_LINE DEDENT l = 5 NEW_LINE r = 15 NEW_LINE generate_random_permutation ( l , r ) NEW_LINE printPermutation ( ) NEW_LINE"}
{"id": "codejam_16_41", "sol": 0, "python_code": "__author__ = 'Tianren Liu'\nimport sys\nimport numpy as np\ndef solve ( R , P , S ) :\n    if ( R < 0 or P < 0 or S < 0 ) :\n        return \"IMPOSSIBLE\"\n    if R + P + S == 1 :\n        return 'R' if R > 0 else 'P' if P > 0 else 'S'\n    Rn , Pn , Sn = ( R + S - P ) // 2 , ( P - S + R ) // 2 , ( - R + S + P ) // 2\n    if ( Rn > R or Pn > P or Sn > S ) :\n        return \"IMPOSSIBLE\"\n    res = solve ( Rn , Pn , Sn )\n    if res == \"IMPOSSIBLE\" :\n        return \"IMPOSSIBLE\"\n    else :\n        nres = ''\n        m = { 'R' : 'RS' , 'S' : 'SP' , 'P' : 'PR' }\n        for c in res :\n            nres += m [ c ]\n        return nres\ndef asort ( S ) :\n    if S == \"IMPOSSIBLE\" :\n        return S\n    l = len ( S )\n    if l > 1 :\n        Sl = asort ( S [ : l // 2 ] )\n        Sh = asort ( S [ l // 2 : ] )\n        S = Sl + Sh if Sl < Sh else Sh + Sl\n    return S\nif __name__ == \"__main__\" :\n    T = int ( sys.stdin.readline ( ) )\n    for t in range ( T ) :\n        N , R , P , S = map ( int , sys.stdin.readline ( ).split ( ) )\n        print ( \"Case #{}: {}\".format ( t + 1 , asort ( solve ( R , P , S ) ) ) )\n", "python_code_tokenized": "__author__ = ' Tianren \u2581 Liu ' NEW_LINE import sys NEW_LINE import numpy as np NEW_LINE def solve ( R , P , S ) : NEW_LINE INDENT if ( R < 0 or P < 0 or S < 0 ) : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT if R + P + S == 1 : NEW_LINE INDENT return ' R ' if R > 0 else ' P ' if P > 0 else ' S ' NEW_LINE DEDENT Rn , Pn , Sn = ( R + S - P ) // 2 , ( P - S + R ) // 2 , ( - R + S + P ) // 2 NEW_LINE if ( Rn > R or Pn > P or Sn > S ) : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT res = solve ( Rn , Pn , Sn ) NEW_LINE if res == \" IMPOSSIBLE \" : NEW_LINE INDENT return \" IMPOSSIBLE \" NEW_LINE DEDENT else : NEW_LINE INDENT nres = ' ' NEW_LINE m = { ' R ' : ' RS ' , ' S ' : ' SP ' , ' P ' : ' PR ' } NEW_LINE for c in res : NEW_LINE INDENT nres += m [ c ] NEW_LINE DEDENT return nres NEW_LINE DEDENT DEDENT def asort ( S ) : NEW_LINE INDENT if S == \" IMPOSSIBLE \" : NEW_LINE INDENT return S NEW_LINE DEDENT l = len ( S ) NEW_LINE if l > 1 : NEW_LINE INDENT Sl = asort ( S [ : l // 2 ] ) NEW_LINE Sh = asort ( S [ l // 2 : ] ) NEW_LINE S = Sl + Sh if Sl < Sh else Sh + Sl NEW_LINE DEDENT return S NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT N , R , P , S = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( t + 1 , asort ( solve ( R , P , S ) ) ) ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1119_B", "sol": 0, "python_code": "def check ( h , high ) :\n    h.sort ( )\n    summ = 0\n    for i in range ( len ( h ) - 1 , - 1 , - 2 ) :\n        summ += h [ i ]\n    return summ <= high\nn , h = map ( int , input ( ).split ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nl = - 1\nr = len ( a ) + 1\nwhile r - l > 1 :\n    m = ( r + l ) // 2\n    if check ( a [ : m ] , h ) :\n        l = m\n    else :\n        r = m\nprint ( l )\n", "python_code_tokenized": "def check ( h , high ) : NEW_LINE INDENT h . sort ( ) NEW_LINE summ = 0 NEW_LINE for i in range ( len ( h ) - 1 , - 1 , - 2 ) : NEW_LINE INDENT summ += h [ i ] NEW_LINE DEDENT return summ <= high NEW_LINE DEDENT n , h = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = - 1 NEW_LINE r = len ( a ) + 1 NEW_LINE while r - l > 1 : NEW_LINE INDENT m = ( r + l ) // 2 NEW_LINE if check ( a [ : m ] , h ) : NEW_LINE INDENT l = m NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT print ( l ) NEW_LINE"}
{"id": "geeksforgeeks_876_A", "sol": 0, "python_code": "def printPair ( g , l ) :\n    print ( g , l )\ng = 3 ; l = 12 ;\nprintPair ( g , l ) ;\n", "python_code_tokenized": "def printPair ( g , l ) : NEW_LINE INDENT print ( g , l ) NEW_LINE DEDENT g = 3 ; l = 12 ; NEW_LINE printPair ( g , l ) ; NEW_LINE"}
{"id": "codeforces_961_A", "sol": 0, "python_code": "import sys\ndef main ( ) :\n    table = list ( )\n    n , m = map ( int , sys.stdin.readline ( ).split ( ) )\n    columns = list ( map ( int , input ( ).split ( ) ) )\n    for i in range ( n ) :\n        table.append ( 0 )\n    for i in range ( m ) :\n        colum = columns [ i ]\n        table [ colum - 1 ] += 1\n    print ( min ( table ) )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "import sys NEW_LINE def main ( ) : NEW_LINE INDENT table = list ( ) NEW_LINE n , m = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE columns = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT table . append ( 0 ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT colum = columns [ i ] NEW_LINE table [ colum - 1 ] += 1 NEW_LINE DEDENT print ( min ( table ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_1260_B", "sol": 0, "python_code": "for pratyush in range ( int ( input ( ) ) ) :\n    a , b = list ( map ( int , input ( ).split ( ) ) )\n    if a > b :\n        c , d = a , b\n    else :\n        c , d = b , a\n    if d * 2 >= c and ( c + d ) % 3 == 0 :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "for pratyush in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a > b : NEW_LINE INDENT c , d = a , b NEW_LINE DEDENT else : NEW_LINE INDENT c , d = b , a NEW_LINE DEDENT if d * 2 >= c and ( c + d ) % 3 == 0 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4646_A", "sol": 0, "python_code": "cm = 1000 ;\nmeter = cm / 100.0 ;\nkilometer = cm / 100000.0 ;\nprint ( \"Length in meter = \" , meter , \"m\" ) ;\nprint ( \"Length in Kilometer = \" , kilometer , \"km\" ) ;\n", "python_code_tokenized": "cm = 1000 ; NEW_LINE meter = cm / 100.0 ; NEW_LINE kilometer = cm / 100000.0 ; NEW_LINE print ( \" Length \u2581 in \u2581 meter \u2581 = \u2581 \" , meter , \" m \" ) ; NEW_LINE print ( \" Length \u2581 in \u2581 Kilometer \u2581 = \u2581 \" , kilometer , \" km \" ) ; NEW_LINE"}
{"id": "codeforces_443_A", "sol": 0, "python_code": "s = input ( )\nif len ( s [ 1 : - 1 ] ) == 0 :\n    print ( 0 )\nelse :\n    print ( len ( set ( s [ 1 : - 1 ].split ( ', ' ) ) ) )\n", "python_code_tokenized": "s = input ( ) NEW_LINE if len ( s [ 1 : - 1 ] ) == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( len ( set ( s [ 1 : - 1 ] . split ( ' , \u2581 ' ) ) ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00687_A", "sol": 0, "python_code": "while True :\n    n , a , b = map ( int , input ( ).split ( ) )\n    if n == 0 : break\n    f = [ 0 ] * ( n + max ( a , b ) + 1 )\n    f [ 0 ] , f [ a ] , f [ b ] = 1 , 1 , 1\n    s = min ( a , b )\n    for k in range ( s , n + 1 ) :\n        if f [ k ] : f [ a + k ] = 1 ; f [ b + k ] = 1\n    print ( n - sum ( f [ s : n + 1 ] ) )\n", "python_code_tokenized": "while True : NEW_LINE INDENT n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE f = [ 0 ] * ( n + max ( a , b ) + 1 ) NEW_LINE f [ 0 ] , f [ a ] , f [ b ] = 1 , 1 , 1 NEW_LINE s = min ( a , b ) NEW_LINE for k in range ( s , n + 1 ) : NEW_LINE INDENT if f [ k ] : f [ a + k ] = 1 ; f [ b + k ] = 1 NEW_LINE DEDENT print ( n - sum ( f [ s : n + 1 ] ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_816_A", "sol": 0, "python_code": "def NotParallel ( p , n ) :\n    x_axis = { } ; y_axis = { } ;\n    for i in range ( n ) :\n        if p [ i ] [ 0 ] not in x_axis :\n            x_axis [ p [ i ] [ 0 ] ] = 0 ;\n        x_axis [ p [ i ] [ 0 ] ] += 1 ;\n        if p [ i ] [ 1 ] not in y_axis :\n            y_axis [ p [ i ] [ 1 ] ] = 0 ;\n        y_axis [ p [ i ] [ 1 ] ] += 1 ;\n    total = ( n * ( n - 1 ) ) // 2 ;\n    for i in x_axis :\n        c = x_axis [ i ] ;\n        total -= ( c * ( c - 1 ) ) // 2 ;\n    for i in y_axis :\n        c = y_axis [ i ] ;\n        total -= ( c * ( c - 1 ) ) // 2 ;\n    return total ;\nif __name__ == \"__main__\" :\n    p = [ [ 1 , 2 ] , [ 1 , 5 ] , [ 1 , 15 ] , [ 2 , 10 ] ] ;\n    n = len ( p ) ;\n    print ( NotParallel ( p , n ) ) ;\n", "python_code_tokenized": "def NotParallel ( p , n ) : NEW_LINE INDENT x_axis = { } ; y_axis = { } ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] [ 0 ] not in x_axis : NEW_LINE INDENT x_axis [ p [ i ] [ 0 ] ] = 0 ; NEW_LINE DEDENT x_axis [ p [ i ] [ 0 ] ] += 1 ; NEW_LINE if p [ i ] [ 1 ] not in y_axis : NEW_LINE INDENT y_axis [ p [ i ] [ 1 ] ] = 0 ; NEW_LINE DEDENT y_axis [ p [ i ] [ 1 ] ] += 1 ; NEW_LINE DEDENT total = ( n * ( n - 1 ) ) // 2 ; NEW_LINE for i in x_axis : NEW_LINE INDENT c = x_axis [ i ] ; NEW_LINE total -= ( c * ( c - 1 ) ) // 2 ; NEW_LINE DEDENT for i in y_axis : NEW_LINE INDENT c = y_axis [ i ] ; NEW_LINE total -= ( c * ( c - 1 ) ) // 2 ; NEW_LINE DEDENT return total ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p = [ [ 1 , 2 ] , [ 1 , 5 ] , [ 1 , 15 ] , [ 2 , 10 ] ] ; NEW_LINE n = len ( p ) ; NEW_LINE print ( NotParallel ( p , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4208_A", "sol": 0, "python_code": "def findCountOfPairs ( a , b , n ) :\n    ans = 0\n    for i in range ( 1 , a + 1 ) :\n        ans += b // n\n        ans += 1 if ( i % n + b % n ) >= n else 0\n    return ans\na = 5 ; b = 13 ; n = 3\nprint ( findCountOfPairs ( a , b , n ) )\n", "python_code_tokenized": "def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT ans += b // n NEW_LINE ans += 1 if ( i % n + b % n ) >= n else 0 NEW_LINE DEDENT return ans NEW_LINE DEDENT a = 5 ; b = 13 ; n = 3 NEW_LINE print ( findCountOfPairs ( a , b , n ) ) NEW_LINE"}
{"id": "codeforces_1485_A", "sol": 0, "python_code": "from math import log\nt = int ( input ( ) )\nfor i in range ( t ) :\n    total = 0\n    a , b = input ( ).split ( )\n    a , b = int ( a ) , int ( b )\n    if ( b == 1 ) :\n        b += 1\n        total += 1\n    b0 = b\n    loga = log ( a )\n    while True :\n        if loga // log ( b ) == loga // log ( b + 1 ) :\n            max = b\n            break\n        else :\n            b += 1\n    total += max - b0\n    while a != 0 :\n        a //= b\n        total += 1\n    print ( total )\n", "python_code_tokenized": "from math import log NEW_LINE t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT total = 0 NEW_LINE a , b = input ( ) . split ( ) NEW_LINE a , b = int ( a ) , int ( b ) NEW_LINE if ( b == 1 ) : NEW_LINE INDENT b += 1 NEW_LINE total += 1 NEW_LINE DEDENT b0 = b NEW_LINE loga = log ( a ) NEW_LINE while True : NEW_LINE INDENT if loga // log ( b ) == loga // log ( b + 1 ) : NEW_LINE INDENT max = b NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT total += max - b0 NEW_LINE while a != 0 : NEW_LINE INDENT a //= b NEW_LINE total += 1 NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2402_A", "sol": 0, "python_code": "def number_of_tower ( house , r , n ) :\n    house.sort ( )\n    numOfTower = 0\n    i = 0\n    while ( i < n ) :\n        numOfTower += 1\n        loc = house [ i ] + r\n        while ( i < n and house [ i ] <= loc ) :\n            i += 1\n        i -= 1\n        loc = house [ i ] + r\n        while ( i < n and house [ i ] <= loc ) :\n            i += 1\n    return numOfTower\nif __name__ == \"__main__\" :\n    house = [ 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 ]\n    r = 2\n    n = len ( house )\n    print ( number_of_tower ( house , r , n ) )\n", "python_code_tokenized": "def number_of_tower ( house , r , n ) : NEW_LINE INDENT house . sort ( ) NEW_LINE numOfTower = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT numOfTower += 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return numOfTower NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT house = [ 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 ] NEW_LINE r = 2 NEW_LINE n = len ( house ) NEW_LINE print ( number_of_tower ( house , r , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4623_A", "sol": 0, "python_code": "import math\ndef fibonacci ( n ) :\n    for i in range ( n ) :\n        fib = ( ( pow ( ( 1 + math.sqrt ( 5 ) ) , i ) - pow ( ( 1 - math.sqrt ( 5 ) ) , i ) ) / ( pow ( 2 , i ) * math.sqrt ( 5 ) ) ) ;\n        print ( int ( fib ) , end = \" \" ) ;\nn = 8 ;\nfibonacci ( n ) ;\n", "python_code_tokenized": "import math NEW_LINE def fibonacci ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT fib = ( ( pow ( ( 1 + math . sqrt ( 5 ) ) , i ) - pow ( ( 1 - math . sqrt ( 5 ) ) , i ) ) / ( pow ( 2 , i ) * math . sqrt ( 5 ) ) ) ; NEW_LINE print ( int ( fib ) , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT n = 8 ; NEW_LINE fibonacci ( n ) ; NEW_LINE"}
{"id": "geeksforgeeks_167_A", "sol": 0, "python_code": "def isDivisibleBy25 ( st ) :\n    n = len ( st )\n    if ( n == 1 ) :\n        return False\n    return ( ( int ) ( st [ n - 1 ] ) == 0 and ( ( int ) ( st [ n - 2 ] ) == 0 ) or ( ( int ) ( st [ n - 2 ] ) * 10 + ( int ) ( st [ n - 1 ] ) % 25 == 0 ) )\nst = \"76955\"\nif ( isDivisibleBy25 ( st ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def isDivisibleBy25 ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( int ) ( st [ n - 1 ] ) == 0 and ( ( int ) ( st [ n - 2 ] ) == 0 ) or ( ( int ) ( st [ n - 2 ] ) * 10 + ( int ) ( st [ n - 1 ] ) % 25 == 0 ) ) NEW_LINE DEDENT st = \"76955\" NEW_LINE if ( isDivisibleBy25 ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "aizu_p02441_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nq = int ( input ( ) )\nfor i in range ( q ) :\n    b , e , k = list ( map ( int , input ( ).split ( ) ) )\n    print ( a [ b : e ].count ( k ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT b , e , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( a [ b : e ] . count ( k ) ) NEW_LINE DEDENT"}
{"id": "aizu_p02199_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\np , q , r = map ( int , input ( ).split ( ) )\nprint ( b + ( p * b - ( b - a ) * q ) / ( q + r ) )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE p , q , r = map ( int , input ( ) . split ( ) ) NEW_LINE print ( b + ( p * b - ( b - a ) * q ) / ( q + r ) ) NEW_LINE"}
{"id": "geeksforgeeks_3167_A", "sol": 0, "python_code": "def maxSum ( a , n ) :\n    ans = 0\n    arr = [ 0 ] * ( n + 1 )\n    for i in range ( 1 , n + 1 ) :\n        arr [ i ] = a [ i - 1 ]\n    dp = [ [ 0 for i in range ( 3 ) ] for j in range ( n + 1 ) ]\n    for i in range ( 0 , n + 1 ) :\n        dp [ i ] [ 0 ] = max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] )\n        dp [ i ] [ 1 ] = max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ]\n        if i >= 2 :\n            dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] )\n        if i >= 2 :\n            dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ]\n        if i >= 3 :\n            dp [ i ] [ 2 ] = max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] )\n        ans = max ( ans , dp [ i ] [ 0 ] )\n        ans = max ( ans , dp [ i ] [ 1 ] )\n        ans = max ( ans , dp [ i ] [ 2 ] )\n    return ans\nif __name__ == \"__main__\" :\n    arr = [ - 5 , 3 , 2 , 7 , - 8 , 3 , 7 , - 9 , 10 , 12 , - 6 ]\n    n = len ( arr )\n    print ( maxSum ( arr , n ) )\n", "python_code_tokenized": "def maxSum ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] = a [ i - 1 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( 3 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) NEW_LINE dp [ i ] [ 1 ] = max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] NEW_LINE if i >= 2 : NEW_LINE INDENT dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) NEW_LINE DEDENT if i >= 2 : NEW_LINE INDENT dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] NEW_LINE DEDENT if i >= 3 : NEW_LINE INDENT dp [ i ] [ 2 ] = max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) NEW_LINE DEDENT ans = max ( ans , dp [ i ] [ 0 ] ) NEW_LINE ans = max ( ans , dp [ i ] [ 1 ] ) NEW_LINE ans = max ( ans , dp [ i ] [ 2 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 5 , 3 , 2 , 7 , - 8 , 3 , 7 , - 9 , 10 , 12 , - 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1781_A", "sol": 0, "python_code": "def sumDigitSquare ( n ) :\n    sq = 0 ;\n    while ( n != 0 ) :\n        digit = n % 10\n        sq += digit * digit\n        n = n // 10\n    return sq ;\ndef isHappy ( n ) :\n    s = set ( )\n    s.add ( n )\n    while ( True ) :\n        if ( n == 1 ) :\n            return True ;\n        n = sumDigitSquare ( n )\n        if n in s :\n            return False\n        s.add ( n )\n    return false ;\nn = 4\nif ( isHappy ( n ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def sumDigitSquare ( n ) : NEW_LINE INDENT sq = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE sq += digit * digit NEW_LINE n = n // 10 NEW_LINE DEDENT return sq ; NEW_LINE DEDENT def isHappy ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE s . add ( n ) NEW_LINE while ( True ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT n = sumDigitSquare ( n ) NEW_LINE if n in s : NEW_LINE INDENT return False NEW_LINE DEDENT s . add ( n ) NEW_LINE DEDENT return false ; NEW_LINE DEDENT n = 4 NEW_LINE if ( isHappy ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "aizu_p01900_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nc = [ 0 ] * 3\nfor i in a : c [ i % 3 ] += 1\nif ( c [ 1 ] | c [ 2 ] ) == 0 : ans = 1\nelse :\n    ans , n = c [ 0 ] , n - c [ 0 ]\n    if n <= 3 : ans += n\n    else :\n        t = max ( - 3 , min ( 3 , c [ 1 ] - c [ 2 ] ) )\n        if t > 0 : ans += 2 * c [ 2 ] + t\n        else : ans += 2 * c [ 1 ] - t\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = [ 0 ] * 3 NEW_LINE for i in a : c [ i % 3 ] += 1 NEW_LINE if ( c [ 1 ] | c [ 2 ] ) == 0 : ans = 1 NEW_LINE else : NEW_LINE INDENT ans , n = c [ 0 ] , n - c [ 0 ] NEW_LINE if n <= 3 : ans += n NEW_LINE else : NEW_LINE INDENT t = max ( - 3 , min ( 3 , c [ 1 ] - c [ 2 ] ) ) NEW_LINE if t > 0 : ans += 2 * c [ 2 ] + t NEW_LINE else : ans += 2 * c [ 1 ] - t NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_3632_A", "sol": 0, "python_code": "def lineFromPoints ( P , Q ) :\n    a = Q [ 1 ] - P [ 1 ]\n    b = P [ 0 ] - Q [ 0 ]\n    c = a * ( P [ 0 ] ) + b * ( P [ 1 ] )\n    if ( b < 0 ) :\n        print ( \"The line passing through points P and Q is:\" , a , \"x \" , b , \"y = \" , c , \"\\n\" )\n    else :\n        print ( \"The line passing through points P and Q is: \" , a , \"x + \" , b , \"y = \" , c , \"\\n\" )\nif __name__ == '__main__' :\n    P = [ 3 , 2 ]\n    Q = [ 2 , 6 ]\n    lineFromPoints ( P , Q )\n", "python_code_tokenized": "def lineFromPoints ( P , Q ) : NEW_LINE INDENT a = Q [ 1 ] - P [ 1 ] NEW_LINE b = P [ 0 ] - Q [ 0 ] NEW_LINE c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) NEW_LINE if ( b < 0 ) : NEW_LINE INDENT print ( \" The \u2581 line \u2581 passing \u2581 through \u2581 points \u2581 P \u2581 and \u2581 Q \u2581 is : \" , a , \" x \u2581 \" , b , \" y \u2581 = \u2581 \" , c , \" \\n \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The \u2581 line \u2581 passing \u2581 through \u2581 points \u2581 P \u2581 and \u2581 Q \u2581 is : \u2581 \" , a , \" x \u2581 + \u2581 \" , b , \" y \u2581 = \u2581 \" , c , \" \\n \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT P = [ 3 , 2 ] NEW_LINE Q = [ 2 , 6 ] NEW_LINE lineFromPoints ( P , Q ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3543_A", "sol": 0, "python_code": "fib = [ 0 ] * 43\ndef fibonacci ( ) :\n    fib [ 0 ] = 1\n    fib [ 1 ] = 2\n    for i in range ( 2 , 43 ) :\n        fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ]\ndef rec ( x , y , last ) :\n    if y == 0 :\n        if x == 0 :\n            return 1\n        return 0\n    Sum , i = 0 , last\n    while i >= 0 and fib [ i ] * y >= x :\n        if fib [ i ] > x :\n            i -= 1\n            continue\n        Sum += rec ( x - fib [ i ] , y - 1 , i )\n        i -= 1\n    return Sum\nif __name__ == \"__main__\" :\n    fibonacci ( )\n    n , k = 13 , 3\n    print ( \"Possible ways are:\" , rec ( n , k , 42 ) )\n", "python_code_tokenized": "fib = [ 0 ] * 43 NEW_LINE def fibonacci ( ) : NEW_LINE INDENT fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , 43 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT DEDENT def rec ( x , y , last ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT Sum , i = 0 , last NEW_LINE while i >= 0 and fib [ i ] * y >= x : NEW_LINE INDENT if fib [ i ] > x : NEW_LINE INDENT i -= 1 NEW_LINE continue NEW_LINE DEDENT Sum += rec ( x - fib [ i ] , y - 1 , i ) NEW_LINE i -= 1 NEW_LINE DEDENT return Sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT fibonacci ( ) NEW_LINE n , k = 13 , 3 NEW_LINE print ( \" Possible \u2581 ways \u2581 are : \" , rec ( n , k , 42 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4153_A", "sol": 0, "python_code": "def encryptString ( string , n ) :\n    i , cnt = 0 , 0\n    encryptedStr = \"\"\n    while i < n :\n        cnt = i + 1\n        while cnt > 0 :\n            encryptedStr += string [ i ]\n            cnt -= 1\n        i += 1\n    return encryptedStr\nif __name__ == \"__main__\" :\n    string = \"geeks\"\n    n = len ( string )\n    print ( encryptString ( string , n ) )\n", "python_code_tokenized": "def encryptString ( string , n ) : NEW_LINE INDENT i , cnt = 0 , 0 NEW_LINE encryptedStr = \" \" NEW_LINE while i < n : NEW_LINE INDENT cnt = i + 1 NEW_LINE while cnt > 0 : NEW_LINE INDENT encryptedStr += string [ i ] NEW_LINE cnt -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return encryptedStr NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeks \" NEW_LINE n = len ( string ) NEW_LINE print ( encryptString ( string , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_933_A", "sol": 0, "python_code": "import sys\nclass Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.next = None\ndef push ( head , data ) :\n    if not head :\n        return Node ( data )\n    newNode = Node ( data )\n    newNode.next = head\n    head = newNode\n    return head\ndef circular ( head ) :\n    start = head\n    while ( head.next is not None ) :\n        head = head.next\n    head.next = start\n    return start\ndef displayList ( node ) :\n    start = node\n    while ( node.next is not start ) :\n        print ( \"{} \".format ( node.data ) , end = \"\" )\n        node = node.next\n    print ( \"{} \".format ( node.data ) , end = \"\" )\nif __name__ == '__main__' :\n    head = None\n    head = push ( head , 15 )\n    head = push ( head , 14 )\n    head = push ( head , 13 )\n    head = push ( head , 22 )\n    head = push ( head , 17 )\n    circular ( head )\n    print ( \"Display List:\" )\n    displayList ( head )\n", "python_code_tokenized": "import sys NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head , data ) : NEW_LINE INDENT if not head : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT newNode = Node ( data ) NEW_LINE newNode . next = head NEW_LINE head = newNode NEW_LINE return head NEW_LINE DEDENT def circular ( head ) : NEW_LINE INDENT start = head NEW_LINE while ( head . next is not None ) : NEW_LINE INDENT head = head . next NEW_LINE DEDENT head . next = start NEW_LINE return start NEW_LINE DEDENT def displayList ( node ) : NEW_LINE INDENT start = node NEW_LINE while ( node . next is not start ) : NEW_LINE INDENT print ( \" { } \u2581 \" . format ( node . data ) , end = \" \" ) NEW_LINE node = node . next NEW_LINE DEDENT print ( \" { } \u2581 \" . format ( node . data ) , end = \" \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 15 ) NEW_LINE head = push ( head , 14 ) NEW_LINE head = push ( head , 13 ) NEW_LINE head = push ( head , 22 ) NEW_LINE head = push ( head , 17 ) NEW_LINE circular ( head ) NEW_LINE print ( \" Display \u2581 List : \" ) NEW_LINE displayList ( head ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4826_A", "sol": 0, "python_code": "arr = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 1 , 2 , 3 , 4 ] ;\ndef countKeyPressed ( string , length ) :\n    count = 0 ;\n    for i in range ( length ) :\n        count += arr [ ord ( string [ i ] ) - ord ( 'a' ) ] ;\n    return count ;\nif __name__ == \"__main__\" :\n    string = \"abcdef\" ;\n    length = len ( string ) ;\n    print ( countKeyPressed ( string , length ) ) ;\n", "python_code_tokenized": "arr = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 1 , 2 , 3 , 4 ] ; NEW_LINE def countKeyPressed ( string , length ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT count += arr [ ord ( string [ i ] ) - ord ( ' a ' ) ] ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcdef \" ; NEW_LINE length = len ( string ) ; NEW_LINE print ( countKeyPressed ( string , length ) ) ; NEW_LINE DEDENT"}
{"id": "aizu_p02233_A", "sol": 0, "python_code": "MAX_N = 44\n_memo = [ None for _ in range ( MAX_N + 1 ) ]\n_memo [ 0 ] = _memo [ 1 ] = 1\ndef fibonacci ( n ) :\n    if _memo [ n ] is not None :\n        return _memo [ n ]\n    else :\n        _memo [ n ] = fibonacci ( n - 1 ) + fibonacci ( n - 2 )\n        return _memo [ n ]\nif __name__ == '__main__' :\n    n = int ( input ( ) )\n    print ( fibonacci ( n ) )\n", "python_code_tokenized": "MAX_N = 44 NEW_LINE _memo = [ None for _ in range ( MAX_N + 1 ) ] NEW_LINE _memo [ 0 ] = _memo [ 1 ] = 1 NEW_LINE def fibonacci ( n ) : NEW_LINE INDENT if _memo [ n ] is not None : NEW_LINE INDENT return _memo [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT _memo [ n ] = fibonacci ( n - 1 ) + fibonacci ( n - 2 ) NEW_LINE return _memo [ n ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( fibonacci ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2977_A", "sol": 0, "python_code": "def largest ( arr , n ) :\n    return ( max ( arr ) )\narr = [ 10 , 324 , 45 , 90 , 9808 ]\nn = len ( arr )\nAns = largest ( arr , n )\nprint ( \"Largest in given array is\" , Ans )\n", "python_code_tokenized": "def largest ( arr , n ) : NEW_LINE INDENT return ( max ( arr ) ) NEW_LINE DEDENT arr = [ 10 , 324 , 45 , 90 , 9808 ] NEW_LINE n = len ( arr ) NEW_LINE Ans = largest ( arr , n ) NEW_LINE print ( \" Largest \u2581 in \u2581 given \u2581 array \u2581 is \" , Ans ) NEW_LINE"}
{"id": "geeksforgeeks_992_A", "sol": 0, "python_code": "def zzis ( arr , n ) :\n    Z = [ [ 1 for i in range ( 2 ) ] for i in range ( n ) ]\n    res = 1\n    for i in range ( 1 , n ) :\n        for j in range ( i ) :\n            if ( arr [ j ] < arr [ i ] and Z [ i ] [ 0 ] < Z [ j ] [ 1 ] + 1 ) :\n                Z [ i ] [ 0 ] = Z [ j ] [ 1 ] + 1\n            if ( arr [ j ] > arr [ i ] and Z [ i ] [ 1 ] < Z [ j ] [ 0 ] + 1 ) :\n                Z [ i ] [ 1 ] = Z [ j ] [ 0 ] + 1\n        if ( res < max ( Z [ i ] [ 0 ] , Z [ i ] [ 1 ] ) ) :\n            res = max ( Z [ i ] [ 0 ] , Z [ i ] [ 1 ] )\n    return res\narr = [ 10 , 22 , 9 , 33 , 49 , 50 , 31 , 60 ]\nn = len ( arr )\nprint ( \"Length of Longest Zig-Zag subsequence is\" , zzis ( arr , n ) )\n", "python_code_tokenized": "def zzis ( arr , n ) : NEW_LINE INDENT Z = [ [ 1 for i in range ( 2 ) ] for i in range ( n ) ] NEW_LINE res = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] and Z [ i ] [ 0 ] < Z [ j ] [ 1 ] + 1 ) : NEW_LINE INDENT Z [ i ] [ 0 ] = Z [ j ] [ 1 ] + 1 NEW_LINE DEDENT if ( arr [ j ] > arr [ i ] and Z [ i ] [ 1 ] < Z [ j ] [ 0 ] + 1 ) : NEW_LINE INDENT Z [ i ] [ 1 ] = Z [ j ] [ 0 ] + 1 NEW_LINE DEDENT DEDENT if ( res < max ( Z [ i ] [ 0 ] , Z [ i ] [ 1 ] ) ) : NEW_LINE INDENT res = max ( Z [ i ] [ 0 ] , Z [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 10 , 22 , 9 , 33 , 49 , 50 , 31 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length \u2581 of \u2581 Longest \u2581 Zig - Zag \u2581 subsequence \u2581 is \" , zzis ( arr , n ) ) NEW_LINE"}
{"id": "aizu_p01620_A", "sol": 0, "python_code": "char_list = list ( map ( chr , range ( ord ( 'a' ) , ord ( 'z' ) + 1 ) ) )\nchar_list += list ( map ( chr , range ( ord ( 'A' ) , ord ( 'Z' ) + 1 ) ) )\nwhile True :\n    n = int ( input ( ) )\n    if n == 0 :\n        break\n    keys = list ( map ( int , input ( ).split ( \"\" ) ) )\n    sentence = input ( )\n    for i in range ( len ( sentence ) ) :\n        if sentence [ i ].isupper ( ) :\n            j = ord ( sentence [ i ] ) - ord ( 'A' ) + 26\n        else :\n            j = ord ( sentence [ i ] ) - ord ( 'a' )\n        print ( char_list [ j - keys [ i % len ( keys ) ] ] , end = \"\" )\n    print ( )\n", "python_code_tokenized": "char_list = list ( map ( chr , range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) ) ) NEW_LINE char_list += list ( map ( chr , range ( ord ( ' A ' ) , ord ( ' Z ' ) + 1 ) ) ) NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT keys = list ( map ( int , input ( ) . split ( \" \u2581 \" ) ) ) NEW_LINE sentence = input ( ) NEW_LINE for i in range ( len ( sentence ) ) : NEW_LINE INDENT if sentence [ i ] . isupper ( ) : NEW_LINE INDENT j = ord ( sentence [ i ] ) - ord ( ' A ' ) + 26 NEW_LINE DEDENT else : NEW_LINE INDENT j = ord ( sentence [ i ] ) - ord ( ' a ' ) NEW_LINE DEDENT print ( char_list [ j - keys [ i % len ( keys ) ] ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2714_A", "sol": 0, "python_code": "MAX_CHAR = 26\ndef sortString ( str ) :\n    charCount = [ 0 for i in range ( MAX_CHAR ) ]\n    for i in range ( 0 , len ( str ) , 1 ) :\n        charCount [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1\n    for i in range ( 0 , MAX_CHAR , 1 ) :\n        for j in range ( 0 , charCount [ i ] , 1 ) :\n            print ( chr ( ord ( 'a' ) + i ) , end = \"\" )\nif __name__ == '__main__' :\n    s = \"geeksforgeeks\"\n    sortString ( s )\n", "python_code_tokenized": "MAX_CHAR = 26 NEW_LINE def sortString ( str ) : NEW_LINE INDENT charCount = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( 0 , len ( str ) , 1 ) : NEW_LINE INDENT charCount [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR , 1 ) : NEW_LINE INDENT for j in range ( 0 , charCount [ i ] , 1 ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE sortString ( s ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2076_A", "sol": 0, "python_code": "def leastPrimeFactor ( n ) :\n    least_prime = [ 0 ] * ( n + 1 )\n    least_prime [ 1 ] = 1\n    for i in range ( 2 , n + 1 ) :\n        if ( least_prime [ i ] == 0 ) :\n            least_prime [ i ] = i\n            for j in range ( 2 * i , n + 1 , i ) :\n                if ( least_prime [ j ] == 0 ) :\n                    least_prime [ j ] = i\n    for i in range ( 1 , n + 1 ) :\n        print ( \"Least Prime factor of \" , i , \": \" , least_prime [ i ] )\nn = 10\nleastPrimeFactor ( n )\n", "python_code_tokenized": "def leastPrimeFactor ( n ) : NEW_LINE INDENT least_prime = [ 0 ] * ( n + 1 ) NEW_LINE least_prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( least_prime [ i ] == 0 ) : NEW_LINE INDENT least_prime [ i ] = i NEW_LINE for j in range ( 2 * i , n + 1 , i ) : NEW_LINE INDENT if ( least_prime [ j ] == 0 ) : NEW_LINE INDENT least_prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( \" Least \u2581 Prime \u2581 factor \u2581 of \u2581 \" , i , \" : \u2581 \" , least_prime [ i ] ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE leastPrimeFactor ( n ) NEW_LINE"}
{"id": "projecteuler_p214_A", "sol": 0, "python_code": "import array\ndef compute ( ) :\n    LIMIT = 40000000\n    totient = list_totients ( LIMIT - 1 )\n    totientchainlen = array.array ( \"L\" , [ 0 , 1 ] )\n    ans = 0\n    for i in range ( len ( totientchainlen ) , len ( totient ) ) :\n        chainlen = totientchainlen [ totient [ i ] ] + 1\n        totientchainlen.append ( chainlen )\n        if chainlen == 25 and totient [ i ] == i - 1 :\n            ans += i\n    return str ( ans )\ndef list_totients ( n ) :\n    assert n < ( 1 << 32 )\n    result = array.array ( \"L\" , range ( n + 1 ) )\n    for i in range ( 2 , n + 1 ) :\n        if result [ i ] == i :\n            for j in range ( i , n + 1 , i ) :\n                result [ j ] = result [ j ] // i * ( i - 1 )\n    return result\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import array NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 40000000 NEW_LINE totient = list_totients ( LIMIT - 1 ) NEW_LINE totientchainlen = array . array ( \" L \" , [ 0 , 1 ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( totientchainlen ) , len ( totient ) ) : NEW_LINE INDENT chainlen = totientchainlen [ totient [ i ] ] + 1 NEW_LINE totientchainlen . append ( chainlen ) NEW_LINE if chainlen == 25 and totient [ i ] == i - 1 : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT def list_totients ( n ) : NEW_LINE INDENT assert n < ( 1 << 32 ) NEW_LINE result = array . array ( \" L \" , range ( n + 1 ) ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if result [ i ] == i : NEW_LINE INDENT for j in range ( i , n + 1 , i ) : NEW_LINE INDENT result [ j ] = result [ j ] // i * ( i - 1 ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_571_A", "sol": 0, "python_code": "import numpy as np\ndef Probability ( p , n ) :\n    dp = np.zeros ( ( n + 1 , n + 1 ) ) ;\n    for i in range ( n + 1 ) :\n        for j in range ( n + 1 ) :\n            dp [ i ] [ j ] = 0.0\n    dp [ 0 ] [ 0 ] = 1.0 ;\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( i + 1 ) :\n            if ( j == 0 ) :\n                dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) ;\n            else :\n                dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) + dp [ i - 1 ] [ j - 1 ] * p [ i ] ) ;\n    ans = 0.0 ;\n    for i in range ( ( n + 1 ) // 2 , n + 1 ) :\n        ans += dp [ n ] [ i ] ;\n    return ans ;\nif __name__ == \"__main__\" :\n    p = [ 0.0 , 0.3 , 0.4 , 0.7 ] ;\n    n = len ( p ) - 1 ;\n    print ( Probability ( p , n ) ) ;\n", "python_code_tokenized": "import numpy as np NEW_LINE def Probability ( p , n ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , n + 1 ) ) ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0.0 NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 1.0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) + dp [ i - 1 ] [ j - 1 ] * p [ i ] ) ; NEW_LINE DEDENT DEDENT DEDENT ans = 0.0 ; NEW_LINE for i in range ( ( n + 1 ) // 2 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT p = [ 0.0 , 0.3 , 0.4 , 0.7 ] ; NEW_LINE n = len ( p ) - 1 ; NEW_LINE print ( Probability ( p , n ) ) ; NEW_LINE DEDENT"}
{"id": "aizu_p00595_A", "sol": 0, "python_code": "import math\ntry :\n    while True :\n        a , b = input ( ).split ( \" \" )\n        print ( math.gcd ( int ( a ) , int ( b ) ) )\nexcept EOFError :\n    m = 0\n", "python_code_tokenized": "import math NEW_LINE try : NEW_LINE INDENT while True : NEW_LINE INDENT a , b = input ( ) . split ( \" \u2581 \" ) NEW_LINE print ( math . gcd ( int ( a ) , int ( b ) ) ) NEW_LINE DEDENT DEDENT except EOFError : NEW_LINE INDENT m = 0 NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5262_A", "sol": 0, "python_code": "def CountCharacters ( str , k ) :\n    cnt = 0\n    l = len ( str )\n    for i in range ( l ) :\n        if ( ord ( str [ i ] ) < k ) :\n            cnt += 1\n    return cnt\nif __name__ == \"__main__\" :\n    str = \"GeeksForGeeks\"\n    k = 90\n    count = CountCharacters ( str , k )\n    print ( \"Characters with ASCII values\" , \"less than K are\" , count )\n    print ( \"Characters with ASCII values\" , \"greater than or equal to K are\" , len ( str ) - count )\n", "python_code_tokenized": "def CountCharacters ( str , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ord ( str [ i ] ) < k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" GeeksForGeeks \" NEW_LINE k = 90 NEW_LINE count = CountCharacters ( str , k ) NEW_LINE print ( \" Characters \u2581 with \u2581 ASCII \u2581 values \" , \" less \u2581 than \u2581 K \u2581 are \" , count ) NEW_LINE print ( \" Characters \u2581 with \u2581 ASCII \u2581 values \" , \" greater \u2581 than \u2581 or \u2581 equal \u2581 to \u2581 K \u2581 are \" , len ( str ) - count ) NEW_LINE DEDENT"}
{"id": "aizu_p02345_A", "sol": 0, "python_code": "class RMQ :\n    def __init__ ( self , n , e ) :\n        self.n = 2 ** ( ( n - 1 ).bit_length ( ) )\n        self.e = e\n        self.d = [ e ] * ( self.n << 1 )\n    def update ( self , k , x ) :\n        k += self.n - 1\n        self.d [ k ] = x\n        while k > 0 :\n            k = ( k - 1 ) >> 1\n            self.d [ k ] = min ( self.d [ ( k << 1 ) + 1 ] , self.d [ ( k << 1 ) + 2 ] )\n    def query ( self , l , r ) :\n        L = l + self.n ; R = r + self.n\n        s = self.e\n        while L < R :\n            if R & 1 :\n                R -= 1\n                s = min ( s , self.d [ R - 1 ] )\n            if L & 1 :\n                s = min ( s , self.d [ L - 1 ] )\n                L += 1\n            L >>= 1 ; R >>= 1\n        return s\n[ n , q ] = list ( map ( int , input ( ).split ( ) ) )\nrmq = RMQ ( n , ( 1 << 31 ) - 1 )\nfor i in range ( q ) :\n    [ com , x , y ] = list ( map ( int , input ( ).split ( ) ) )\n    if com == 0 :\n        rmq.update ( x , y )\n    else :\n        print ( rmq.query ( x , y + 1 ) )\n", "python_code_tokenized": "class RMQ : NEW_LINE INDENT def __init__ ( self , n , e ) : NEW_LINE INDENT self . n = 2 ** ( ( n - 1 ) . bit_length ( ) ) NEW_LINE self . e = e NEW_LINE self . d = [ e ] * ( self . n << 1 ) NEW_LINE DEDENT def update ( self , k , x ) : NEW_LINE INDENT k += self . n - 1 NEW_LINE self . d [ k ] = x NEW_LINE while k > 0 : NEW_LINE INDENT k = ( k - 1 ) >> 1 NEW_LINE self . d [ k ] = min ( self . d [ ( k << 1 ) + 1 ] , self . d [ ( k << 1 ) + 2 ] ) NEW_LINE DEDENT DEDENT def query ( self , l , r ) : NEW_LINE INDENT L = l + self . n ; R = r + self . n NEW_LINE s = self . e NEW_LINE while L < R : NEW_LINE INDENT if R & 1 : NEW_LINE INDENT R -= 1 NEW_LINE s = min ( s , self . d [ R - 1 ] ) NEW_LINE DEDENT if L & 1 : NEW_LINE INDENT s = min ( s , self . d [ L - 1 ] ) NEW_LINE L += 1 NEW_LINE DEDENT L >>= 1 ; R >>= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT DEDENT [ n , q ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE rmq = RMQ ( n , ( 1 << 31 ) - 1 ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT [ com , x , y ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if com == 0 : NEW_LINE INDENT rmq . update ( x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( rmq . query ( x , y + 1 ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1453_A", "sol": 0, "python_code": "from collections import defaultdict\nimport math\ndef add_factors ( n , mp ) :\n    for i in range ( 1 , int ( math.sqrt ( n ) ) + 1 , ) :\n        if ( n % i == 0 ) :\n            if ( n // i == i ) :\n                mp [ i ] += 1\n            else :\n                mp [ i ] += 1\n                mp [ n // i ] += 1\ndef count_divisors ( a , n ) :\n    mp = defaultdict ( int )\n    for i in range ( n ) :\n        print ( mp [ a [ i ] ] , end = \" \" )\n        add_factors ( a [ i ] , mp )\nif __name__ == \"__main__\" :\n    arr = [ 8 , 1 , 28 , 4 , 2 , 6 , 7 ]\n    n = len ( arr )\n    count_divisors ( arr , n )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE import math NEW_LINE def add_factors ( n , mp ) : NEW_LINE INDENT for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 , ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE mp [ n // i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def count_divisors ( a , n ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( mp [ a [ i ] ] , end = \" \u2581 \" ) NEW_LINE add_factors ( a [ i ] , mp ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 1 , 28 , 4 , 2 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE count_divisors ( arr , n ) NEW_LINE DEDENT"}
{"id": "aizu_p02253_A", "sol": 0, "python_code": "class Activity :\n    def __init__ ( self , s , e ) :\n        self.s = s\n        self.e = e\nn = int ( input ( ) )\nacts = [ ]\nfor i in range ( n ) :\n    si , ei = map ( int , input ( ).split ( ) )\n    acts.append ( Activity ( si , ei ) )\nacts.sort ( key = lambda x : x.s )\nstack = [ ]\nstack.append ( acts [ 0 ] )\nfor i in range ( 1 , n ) :\n    last = stack [ - 1 ]\n    acti = acts [ i ]\n    if acti.s > last.e :\n        stack.append ( acti )\n    elif acti.e < last.e :\n        stack.pop ( )\n        stack.append ( acti )\nprint ( len ( stack ) )\n", "python_code_tokenized": "class Activity : NEW_LINE INDENT def __init__ ( self , s , e ) : NEW_LINE INDENT self . s = s NEW_LINE self . e = e NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE acts = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT si , ei = map ( int , input ( ) . split ( ) ) NEW_LINE acts . append ( Activity ( si , ei ) ) NEW_LINE DEDENT acts . sort ( key = lambda x : x . s ) NEW_LINE stack = [ ] NEW_LINE stack . append ( acts [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT last = stack [ - 1 ] NEW_LINE acti = acts [ i ] NEW_LINE if acti . s > last . e : NEW_LINE INDENT stack . append ( acti ) NEW_LINE DEDENT elif acti . e < last . e : NEW_LINE INDENT stack . pop ( ) NEW_LINE stack . append ( acti ) NEW_LINE DEDENT DEDENT print ( len ( stack ) ) NEW_LINE"}
{"id": "geeksforgeeks_3954_A", "sol": 0, "python_code": "class Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.left = None\n        self.right = None\ndef specific_level_order_traversal ( root ) :\n    q = [ ]\n    s = [ ]\n    q.append ( root )\n    sz = 0\n    while ( len ( q ) > 0 ) :\n        v = [ ]\n        sz = len ( q )\n        i = 0\n        while ( i < sz ) :\n            temp = q [ 0 ]\n            q.pop ( 0 )\n            v.append ( temp.data )\n            if ( temp.left != None ) :\n                q.append ( temp.left )\n            if ( temp.right != None ) :\n                q.append ( temp.right )\n            i = i + 1\n        s.append ( v )\n    while ( len ( s ) > 0 ) :\n        v = s [ - 1 ]\n        s.pop ( )\n        i = 0\n        j = len ( v ) - 1\n        while ( i < j ) :\n            print ( v [ i ] , \" \" , v [ j ] , end = \" \" )\n            j = j - 1\n            i = i + 1\n    print ( root.data )\nroot = Node ( 1 )\nroot.left = Node ( 2 )\nroot.right = Node ( 3 )\nprint ( \"Specific Level Order traversal of binary tree is\" )\nspecific_level_order_traversal ( root )\n", "python_code_tokenized": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def specific_level_order_traversal ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE s = [ ] NEW_LINE q . append ( root ) NEW_LINE sz = 0 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT v = [ ] NEW_LINE sz = len ( q ) NEW_LINE i = 0 NEW_LINE while ( i < sz ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE v . append ( temp . data ) NEW_LINE if ( temp . left != None ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right != None ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT s . append ( v ) NEW_LINE DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT v = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE i = 0 NEW_LINE j = len ( v ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT print ( v [ i ] , \" \u2581 \" , v [ j ] , end = \" \u2581 \" ) NEW_LINE j = j - 1 NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT print ( root . data ) NEW_LINE DEDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE print ( \" Specific \u2581 Level \u2581 Order \u2581 traversal \u2581 of \u2581 binary \u2581 tree \u2581 is \" ) NEW_LINE specific_level_order_traversal ( root ) NEW_LINE"}
{"id": "atcoder_ABC155_E", "sol": 0, "python_code": "import sys\ninput_methods = [ 'clipboard' , 'file' , 'key' ]\nusing_method = 0\ninput_method = input_methods [ using_method ]\nIN = lambda : map ( int , input ( ).split ( ) )\nmod = 1000000007\ndef main_b ( ) :\n    s = input ( )\n    pp = 0\n    na = 0\n    for i , c in enumerate ( s [ : : - 1 ] ) :\n        cc = na + int ( c )\n        na = 0\n        if cc <= 4 :\n            pp += cc\n        else :\n            na = 1\n            if i == len ( s ) - 1 :\n                pp += 1\n            pp += 10 - cc\n    print ( pp )\ndef main ( ) :\n    s = input ( )\n    pmin = 1000\n    mmin = 0\n    s = '0' + s\n    for c in s [ : : - 1 ] :\n        v = int ( c )\n        npmin = min ( pmin + 10 - ( v + 1 ) , mmin + 10 - v )\n        nmmin = min ( pmin + v + 1 , mmin + v )\n        pmin = npmin\n        mmin = nmmin\n    return min ( pmin , mmin )\nisTest = False\ndef pa ( v ) :\n    if isTest :\n        print ( v )\ndef input_clipboard ( ) :\n    import clipboard\n    input_text = clipboard.get ( )\n    input_l = input_text.splitlines ( )\n    for l in input_l :\n        yield l\nif __name__ == \"__main__\" :\n    if sys.platform == 'ios' :\n        if input_method == input_methods [ 0 ] :\n            ic = input_clipboard ( )\n            input = lambda : ic.__next__ ( )\n        elif input_method == input_methods [ 1 ] :\n            sys.stdin = open ( 'inputFile.txt' )\n        else :\n            pass\n        isTest = True\n    else :\n        pass\n    ret = main ( )\n    if ret is not None :\n        print ( ret )\n", "python_code_tokenized": "import sys NEW_LINE input_methods = [ ' clipboard ' , ' file ' , ' key ' ] NEW_LINE using_method = 0 NEW_LINE input_method = input_methods [ using_method ] NEW_LINE IN = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE mod = 1000000007 NEW_LINE def main_b ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE pp = 0 NEW_LINE na = 0 NEW_LINE for i , c in enumerate ( s [ : : - 1 ] ) : NEW_LINE INDENT cc = na + int ( c ) NEW_LINE na = 0 NEW_LINE if cc <= 4 : NEW_LINE INDENT pp += cc NEW_LINE DEDENT else : NEW_LINE INDENT na = 1 NEW_LINE if i == len ( s ) - 1 : NEW_LINE INDENT pp += 1 NEW_LINE DEDENT pp += 10 - cc NEW_LINE DEDENT DEDENT print ( pp ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE pmin = 1000 NEW_LINE mmin = 0 NEW_LINE s = '0' + s NEW_LINE for c in s [ : : - 1 ] : NEW_LINE INDENT v = int ( c ) NEW_LINE npmin = min ( pmin + 10 - ( v + 1 ) , mmin + 10 - v ) NEW_LINE nmmin = min ( pmin + v + 1 , mmin + v ) NEW_LINE pmin = npmin NEW_LINE mmin = nmmin NEW_LINE DEDENT return min ( pmin , mmin ) NEW_LINE DEDENT isTest = False NEW_LINE def pa ( v ) : NEW_LINE INDENT if isTest : NEW_LINE INDENT print ( v ) NEW_LINE DEDENT DEDENT def input_clipboard ( ) : NEW_LINE INDENT import clipboard NEW_LINE input_text = clipboard . get ( ) NEW_LINE input_l = input_text . splitlines ( ) NEW_LINE for l in input_l : NEW_LINE INDENT yield l NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT if sys . platform == ' ios ' : NEW_LINE INDENT if input_method == input_methods [ 0 ] : NEW_LINE INDENT ic = input_clipboard ( ) NEW_LINE input = lambda : ic . __next__ ( ) NEW_LINE DEDENT elif input_method == input_methods [ 1 ] : NEW_LINE INDENT sys . stdin = open ( ' inputFile . txt ' ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT isTest = True NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT ret = main ( ) NEW_LINE if ret is not None : NEW_LINE INDENT print ( ret ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1702_B", "sol": 0, "python_code": "def sol ( s ) :\n    cnt = 0\n    days = 1\n    string_list = [ ]\n    for i in s :\n        if i in string_list :\n            pass\n        else :\n            if cnt >= 3 :\n                cnt = 0\n                days += 1\n                string_list = [ ]\n            string_list.append ( i )\n            cnt += 1\n    return days\nfor i in range ( int ( input ( ) ) ) :\n    print ( sol ( input ( ) ) )\n", "python_code_tokenized": "def sol ( s ) : NEW_LINE INDENT cnt = 0 NEW_LINE days = 1 NEW_LINE string_list = [ ] NEW_LINE for i in s : NEW_LINE INDENT if i in string_list : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT if cnt >= 3 : NEW_LINE INDENT cnt = 0 NEW_LINE days += 1 NEW_LINE string_list = [ ] NEW_LINE DEDENT string_list . append ( i ) NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT return days NEW_LINE DEDENT for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( sol ( input ( ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3856_A", "sol": 0, "python_code": "def countSetBits ( n ) :\n    count = 0 ;\n    while ( n ) :\n        n &= ( n - 1 ) ;\n        count += 1\n    return count ;\ndef pairs ( arr , n , k ) :\n    count = 0 ;\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            sum = countSetBits ( arr [ i ] ) + countSetBits ( arr [ j ] ) ;\n            if ( sum == k ) :\n                count += 1 ;\n    return count ;\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 3 , 4 , 5 ] ;\n    n = len ( arr ) ;\n    k = 4 ;\n    print ( pairs ( arr , n , k ) ) ;\n", "python_code_tokenized": "def countSetBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) ; NEW_LINE count += 1 NEW_LINE DEDENT return count ; NEW_LINE DEDENT def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = countSetBits ( arr [ i ] ) + countSetBits ( arr [ j ] ) ; NEW_LINE if ( sum == k ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 4 ; NEW_LINE print ( pairs ( arr , n , k ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1132_A", "sol": 0, "python_code": "def solve ( ) :\n    cnt_1 , cnt_2 , cnt_3 , cnt_4 = map ( int , [ input ( ) for i in range ( 4 ) ] )\n    open = 0\n    closed = 0\n    if cnt_1 == 0 and cnt_4 == 0 and cnt_3 > 0 :\n        print ( 0 )\n        return\n    open += cnt_1 * 2\n    open += cnt_3\n    closed += cnt_4 * 2\n    closed += cnt_3\n    if closed - open == 0 :\n        print ( 1 )\n    else :\n        print ( 0 )\nsolve ( )\n", "python_code_tokenized": "def solve ( ) : NEW_LINE INDENT cnt_1 , cnt_2 , cnt_3 , cnt_4 = map ( int , [ input ( ) for i in range ( 4 ) ] ) NEW_LINE open = 0 NEW_LINE closed = 0 NEW_LINE if cnt_1 == 0 and cnt_4 == 0 and cnt_3 > 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT open += cnt_1 * 2 NEW_LINE open += cnt_3 NEW_LINE closed += cnt_4 * 2 NEW_LINE closed += cnt_3 NEW_LINE if closed - open == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE"}
{"id": "geeksforgeeks_2068_A", "sol": 0, "python_code": "def power ( x , y , p ) :\n    res = 1\n    x = x % p\n    while y > 0 :\n        if y & 1 :\n            res = ( res * x ) % p\n        y = y >> 1\n        x = ( x * x ) % p\n    return res\ndef NearestElement ( A , D , P ) :\n    if A == 0 :\n        return 0\n    elif D == 0 :\n        return - 1\n    else :\n        X = power ( D , P - 2 , P )\n        return ( X * ( P - A ) ) % P\nif __name__ == \"__main__\" :\n    A , D , P = 4 , 9 , 11\n    A %= P\n    D %= P\n    print ( NearestElement ( A , D , P ) )\n", "python_code_tokenized": "def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while y > 0 : NEW_LINE INDENT if y & 1 : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def NearestElement ( A , D , P ) : NEW_LINE INDENT if A == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif D == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT X = power ( D , P - 2 , P ) NEW_LINE return ( X * ( P - A ) ) % P NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A , D , P = 4 , 9 , 11 NEW_LINE A %= P NEW_LINE D %= P NEW_LINE print ( NearestElement ( A , D , P ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5281_A", "sol": 0, "python_code": "def modPower ( x , y , p ) :\n    res = 1\n    x = x % p\n    while ( y > 0 ) :\n        if ( y & 1 ) :\n            res = ( res * x ) % p\n        y = y >> 1\n        x = ( x * x ) % p\n    return res\ndef gcd ( a , b ) :\n    if ( b == 0 ) :\n        return a\n    return gcd ( b , a % b )\ndef gcdPow ( a , n , c ) :\n    if ( a % c == 0 ) :\n        return c\n    modexpo = modPower ( a , n , c )\n    return gcd ( modexpo , c )\nif __name__ == \"__main__\" :\n    a = 10248585\n    n = 1000000\n    c = 12564\n    print ( gcdPow ( a , n , c ) )\n", "python_code_tokenized": "def modPower ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def gcdPow ( a , n , c ) : NEW_LINE INDENT if ( a % c == 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT modexpo = modPower ( a , n , c ) NEW_LINE return gcd ( modexpo , c ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10248585 NEW_LINE n = 1000000 NEW_LINE c = 12564 NEW_LINE print ( gcdPow ( a , n , c ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4517_A", "sol": 0, "python_code": "def nextPowerOf2 ( n ) :\n    count = 0 ;\n    if ( n and not ( n & ( n - 1 ) ) ) :\n        return n\n    while ( n != 0 ) :\n        n >>= 1\n        count += 1\n    return 1 << count ;\nn = 0\nprint ( nextPowerOf2 ( n ) )\n", "python_code_tokenized": "def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count ; NEW_LINE DEDENT n = 0 NEW_LINE print ( nextPowerOf2 ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4518_A", "sol": 0, "python_code": "def nextPowerOf2 ( n ) :\n    p = 1\n    if ( n and not ( n & ( n - 1 ) ) ) :\n        return n\n    while ( p < n ) :\n        p <<= 1\n    return p ;\nn = 5\nprint ( nextPowerOf2 ( n ) ) ;\n", "python_code_tokenized": "def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p ; NEW_LINE DEDENT n = 5 NEW_LINE print ( nextPowerOf2 ( n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_4188_A", "sol": 0, "python_code": "from math import ceil , floor\ndef printArr ( arr , n ) :\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" )\ndef generateArr ( arr , n ) :\n    flip = True\n    for i in range ( n ) :\n        if ( arr [ i ] & 1 ) :\n            flip ^= True\n            if ( flip ) :\n                print ( int ( ceil ( ( arr [ i ] ) / 2 ) ) , end = \" \" )\n            else :\n                print ( int ( floor ( ( arr [ i ] ) / 2 ) ) , end = \" \" )\n        else :\n            print ( int ( arr [ i ] / 2 ) , end = \" \" )\narr = [ 3 , - 5 , - 7 , 9 , 2 , - 2 ]\nn = len ( arr )\ngenerateArr ( arr , n )\n", "python_code_tokenized": "from math import ceil , floor NEW_LINE def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT def generateArr ( arr , n ) : NEW_LINE INDENT flip = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT flip ^= True NEW_LINE if ( flip ) : NEW_LINE INDENT print ( int ( ceil ( ( arr [ i ] ) / 2 ) ) , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( floor ( ( arr [ i ] ) / 2 ) ) , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( int ( arr [ i ] / 2 ) , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 3 , - 5 , - 7 , 9 , 2 , - 2 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_600_A", "sol": 0, "python_code": "def findIndex ( n ) :\n    if ( n <= 1 ) :\n        return n\n    a = 0\n    b = 1\n    c = 1\n    res = 1\n    while ( c < n ) :\n        c = a + b\n        res = res + 1\n        a = b\n        b = c\n    return res\nresult = findIndex ( 21 )\nprint ( result )\n", "python_code_tokenized": "def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res = res + 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT result = findIndex ( 21 ) NEW_LINE print ( result ) NEW_LINE"}
{"id": "codeforces_348_A", "sol": 0, "python_code": "import math\ndef marathon ( n , b ) :\n    sum = 0\n    ll = b.split ( ' ' )\n    l = [ int ( i ) for i in ll ]\n    maxx = max ( l )\n    for i in l :\n        sum = sum + int ( i )\n    m = max ( math.ceil ( sum / ( n - 1 ) ) , maxx )\n    return m\nn = int ( input ( ) )\nb = input ( )\nprint ( marathon ( n , b ) )\n", "python_code_tokenized": "import math NEW_LINE def marathon ( n , b ) : NEW_LINE INDENT sum = 0 NEW_LINE ll = b . split ( ' \u2581 ' ) NEW_LINE l = [ int ( i ) for i in ll ] NEW_LINE maxx = max ( l ) NEW_LINE for i in l : NEW_LINE INDENT sum = sum + int ( i ) NEW_LINE DEDENT m = max ( math . ceil ( sum / ( n - 1 ) ) , maxx ) NEW_LINE return m NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE b = input ( ) NEW_LINE print ( marathon ( n , b ) ) NEW_LINE"}
{"id": "geeksforgeeks_3900_A", "sol": 0, "python_code": "from collections import defaultdict\nclass Graph :\n    def __init__ ( self ) :\n        self.graph = defaultdict ( list )\n    def addEdge ( self , u , v ) :\n        self.graph [ u ].append ( v )\n    def DFSUtil ( self , v , visited ) :\n        visited [ v ] = True\n        print ( v , end = ' ' )\n        for i in self.graph [ v ] :\n            if visited [ i ] == False :\n                self.DFSUtil ( i , visited )\n    def DFS ( self , v ) :\n        visited = [ False ] * ( max ( self.graph ) + 1 )\n        self.DFSUtil ( v , visited )\ng = Graph ( )\ng.addEdge ( 0 , 1 )\ng.addEdge ( 0 , 2 )\ng.addEdge ( 1 , 2 )\ng.addEdge ( 2 , 0 )\ng.addEdge ( 2 , 3 )\ng.addEdge ( 3 , 3 )\nprint ( \"Following is DFS from (starting from vertex 2)\" )\ng.DFS ( 2 )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE DEDENT def addEdge ( self , u , v ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE DEDENT def DFSUtil ( self , v , visited ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE print ( v , end = ' \u2581 ' ) NEW_LINE for i in self . graph [ v ] : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT self . DFSUtil ( i , visited ) NEW_LINE DEDENT DEDENT DEDENT def DFS ( self , v ) : NEW_LINE INDENT visited = [ False ] * ( max ( self . graph ) + 1 ) NEW_LINE self . DFSUtil ( v , visited ) NEW_LINE DEDENT DEDENT g = Graph ( ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( \" Following \u2581 is \u2581 DFS \u2581 from \u2581 ( starting \u2581 from \u2581 vertex \u2581 2 ) \" ) NEW_LINE g . DFS ( 2 ) NEW_LINE"}
{"id": "geeksforgeeks_4801_A", "sol": 0, "python_code": "def isPresent ( arr , low , high , value ) :\n    while ( low <= high ) :\n        mid = ( low + high ) // 2\n        if ( arr [ mid ] == value ) :\n            return True\n        elif ( arr [ mid ] > value ) :\n            high = mid - 1\n        else :\n            low = mid + 1\n    return False\ndef countPairs ( arr1 , arr2 , m , n , x ) :\n    count = 0\n    for i in range ( m ) :\n        value = x - arr1 [ i ]\n        if ( isPresent ( arr2 , 0 , n - 1 , value ) ) :\n            count += 1\n    return count\nif __name__ == \"__main__\" :\n    arr1 = [ 1 , 3 , 5 , 7 ]\n    arr2 = [ 2 , 3 , 5 , 8 ]\n    m = len ( arr1 )\n    n = len ( arr2 )\n    x = 10\n    print ( \"Count = \" , countPairs ( arr1 , arr2 , m , n , x ) )\n", "python_code_tokenized": "def isPresent ( arr , low , high , value ) : NEW_LINE INDENT while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( arr [ mid ] == value ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( arr [ mid ] > value ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT value = x - arr1 [ i ] NEW_LINE if ( isPresent ( arr2 , 0 , n - 1 , value ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 1 , 3 , 5 , 7 ] NEW_LINE arr2 = [ 2 , 3 , 5 , 8 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE x = 10 NEW_LINE print ( \" Count \u2581 = \u2581 \" , countPairs ( arr1 , arr2 , m , n , x ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1373_B", "sol": 0, "python_code": "n = int ( input ( ) )\ndef out ( case ) :\n    x = 0\n    while ( True ) :\n        if case.count ( \"01\" ) == 0 and case.count ( \"10\" ) == 0 :\n            break\n        elif case.count ( \"01\" ) > 0 :\n            case = case.replace ( \"01\" , \"\" , 1 )\n        else :\n            case = case.replace ( \"10\" , \"\" , 1 )\n        x += 1\n    if x % 2 == 1 :\n        print ( \"DA\" )\n    else :\n        print ( \"NET\" )\nfor i in range ( n ) :\n    case = str ( input ( ) )\n    x = 0\n    out ( case )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE def out ( case ) : NEW_LINE INDENT x = 0 NEW_LINE while ( True ) : NEW_LINE INDENT if case . count ( \"01\" ) == 0 and case . count ( \"10\" ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT elif case . count ( \"01\" ) > 0 : NEW_LINE INDENT case = case . replace ( \"01\" , \" \" , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT case = case . replace ( \"10\" , \" \" , 1 ) NEW_LINE DEDENT x += 1 NEW_LINE DEDENT if x % 2 == 1 : NEW_LINE INDENT print ( \" DA \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NET \" ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT case = str ( input ( ) ) NEW_LINE x = 0 NEW_LINE out ( case ) NEW_LINE DEDENT"}
{"id": "codeforces_305_B", "sol": 0, "python_code": "p , q = [ int ( x ) for x in input ( ).split ( ) ]\nn = int ( input ( ) )\na = [ int ( x ) for x in input ( ).split ( ) ]\nfor x in a :\n    p -= q * x\n    p , q = q , p\nif ( q == 0 ) :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "p , q = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE for x in a : NEW_LINE INDENT p -= q * x NEW_LINE p , q = q , p NEW_LINE DEDENT if ( q == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4054_A", "sol": 0, "python_code": "def sumOfTheSeries ( n ) :\n    sum_n = int ( ( n * ( n + 1 ) / 2 ) ) ;\n    sum_sq_n = int ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 )\n    return ( sum_n + sum_sq_n ) ;\nn = 5\nans = sumOfTheSeries ( n )\nprint ( ans )\n", "python_code_tokenized": "def sumOfTheSeries ( n ) : NEW_LINE INDENT sum_n = int ( ( n * ( n + 1 ) / 2 ) ) ; NEW_LINE sum_sq_n = int ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE return ( sum_n + sum_sq_n ) ; NEW_LINE DEDENT n = 5 NEW_LINE ans = sumOfTheSeries ( n ) NEW_LINE print ( ans ) NEW_LINE"}
{"id": "atcoder_ABC081_D", "sol": 0, "python_code": "import sys\nn = int ( input ( ) )\nINF = 10 ** 18\na_ls = [ int ( i ) for i in sys.stdin.readline ( ).split ( ) ]\nmax_ind = 1\n_max = a_ls [ 0 ]\nmin_ind = 1\n_min = a_ls [ 0 ]\nfor i , a in enumerate ( a_ls , 1 ) :\n    if a > _max :\n        _max = a\n        max_ind = i\n    if a < _min :\n        _min = a\n        min_ind = i\nflg = abs ( _max ) >= abs ( _min )\nls = [ ]\nif flg :\n    for i in range ( 1 , n + 1 ) :\n        if i != max_ind :\n            ls.append ( ( max_ind , i ) )\n    for i in range ( 1 , n ) :\n        ls.append ( ( i , i + 1 ) )\nelse :\n    for i in range ( 1 , n + 1 ) :\n        if i != min_ind :\n            ls.append ( ( min_ind , i ) )\n    for i in range ( n , 1 , - 1 ) :\n        ls.append ( ( i , i - 1 ) )\nprint ( len ( ls ) )\nfor x , y in ls :\n    print ( x , y )\n", "python_code_tokenized": "import sys NEW_LINE n = int ( input ( ) ) NEW_LINE INF = 10 ** 18 NEW_LINE a_ls = [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] NEW_LINE max_ind = 1 NEW_LINE _max = a_ls [ 0 ] NEW_LINE min_ind = 1 NEW_LINE _min = a_ls [ 0 ] NEW_LINE for i , a in enumerate ( a_ls , 1 ) : NEW_LINE INDENT if a > _max : NEW_LINE INDENT _max = a NEW_LINE max_ind = i NEW_LINE DEDENT if a < _min : NEW_LINE INDENT _min = a NEW_LINE min_ind = i NEW_LINE DEDENT DEDENT flg = abs ( _max ) >= abs ( _min ) NEW_LINE ls = [ ] NEW_LINE if flg : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i != max_ind : NEW_LINE INDENT ls . append ( ( max_ind , i ) ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT ls . append ( ( i , i + 1 ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i != min_ind : NEW_LINE INDENT ls . append ( ( min_ind , i ) ) NEW_LINE DEDENT DEDENT for i in range ( n , 1 , - 1 ) : NEW_LINE INDENT ls . append ( ( i , i - 1 ) ) NEW_LINE DEDENT DEDENT print ( len ( ls ) ) NEW_LINE for x , y in ls : NEW_LINE INDENT print ( x , y ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1302_A", "sol": 0, "python_code": "def OddDivCount ( a , b ) :\n    res = 0\n    for i in range ( a , b + 1 ) :\n        divCount = 0\n        for j in range ( 1 , i + 1 ) :\n            if ( i % j == 0 ) :\n                divCount += 1\n        if ( divCount % 2 ) :\n            res += 1\n    return res\nif __name__ == \"__main__\" :\n    a = 1\n    b = 10\n    print ( OddDivCount ( a , b ) )\n", "python_code_tokenized": "def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if ( divCount % 2 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 1 NEW_LINE b = 10 NEW_LINE print ( OddDivCount ( a , b ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_810_A", "sol": 0, "python_code": "import math as mt\ndef ReuleauxArea ( a ) :\n    if a < 0 :\n        return - 1\n    return 0.70477 * pow ( a , 2 )\na = 6\nprint ( ReuleauxArea ( a ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def ReuleauxArea ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 0.70477 * pow ( a , 2 ) NEW_LINE DEDENT a = 6 NEW_LINE print ( ReuleauxArea ( a ) ) NEW_LINE"}
{"id": "geeksforgeeks_3418_A", "sol": 0, "python_code": "def squareRootExists ( n , p ) :\n    n = n % p\n    for x in range ( 2 , p , 1 ) :\n        if ( ( x * x ) % p == n ) :\n            return True\n    return False\nif __name__ == '__main__' :\n    p = 7\n    n = 2\n    if ( squareRootExists ( n , p ) == True ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def squareRootExists ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p , 1 ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = 7 NEW_LINE n = 2 NEW_LINE if ( squareRootExists ( n , p ) == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_564_A", "sol": 0, "python_code": "def Hex ( num ) :\n    m = dict.fromkeys ( range ( 16 ) , 0 ) ;\n    digit = ord ( '0' ) ;\n    c = ord ( 'a' ) ;\n    for i in range ( 16 ) :\n        if ( i < 10 ) :\n            m [ i ] = chr ( digit ) ;\n            digit += 1 ;\n        else :\n            m [ i ] = chr ( c ) ;\n            c += 1\n    res = \"\" ;\n    if ( not num ) :\n        return \"0\" ;\n    if ( num > 0 ) :\n        while ( num ) :\n            res = m [ num % 16 ] + res ;\n            num //= 16 ;\n    else :\n        n = num + 2 ** 32 ;\n        while ( n ) :\n            res = m [ n % 16 ] + res ;\n            n //= 16 ;\n    return res ;\nif __name__ == \"__main__\" :\n    x = 134 ; y = - 1 ; z = - 234 ;\n    print ( \"Hexa representation for\" ) ;\n    print ( x , \"is\" , Hex ( x ) ) ;\n    print ( y , \"is\" , Hex ( y ) ) ;\n    print ( z , \"is\" , Hex ( z ) ) ;\n", "python_code_tokenized": "def Hex ( num ) : NEW_LINE INDENT m = dict . fromkeys ( range ( 16 ) , 0 ) ; NEW_LINE digit = ord ( '0' ) ; NEW_LINE c = ord ( ' a ' ) ; NEW_LINE for i in range ( 16 ) : NEW_LINE INDENT if ( i < 10 ) : NEW_LINE INDENT m [ i ] = chr ( digit ) ; NEW_LINE digit += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT m [ i ] = chr ( c ) ; NEW_LINE c += 1 NEW_LINE DEDENT DEDENT res = \" \" ; NEW_LINE if ( not num ) : NEW_LINE INDENT return \"0\" ; NEW_LINE DEDENT if ( num > 0 ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT res = m [ num % 16 ] + res ; NEW_LINE num //= 16 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT n = num + 2 ** 32 ; NEW_LINE while ( n ) : NEW_LINE INDENT res = m [ n % 16 ] + res ; NEW_LINE n //= 16 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 134 ; y = - 1 ; z = - 234 ; NEW_LINE print ( \" Hexa \u2581 representation \u2581 for \" ) ; NEW_LINE print ( x , \" is \" , Hex ( x ) ) ; NEW_LINE print ( y , \" is \" , Hex ( y ) ) ; NEW_LINE print ( z , \" is \" , Hex ( z ) ) ; NEW_LINE DEDENT"}
{"id": "atcoder_ARC094_B", "sol": 0, "python_code": "Q = int ( input ( ) )\nA , B = [ None ] * Q , [ None ] * Q\nfor i in range ( Q ) :\n    A [ i ] , B [ i ] = sorted ( map ( int , input ( ).split ( ) ) )\ndef solve ( a , b ) :\n    w = a * b - 1\n    left , right = 0 , b - a\n    while right - left > 1 :\n        x = ( left + right ) // 2\n        v = w // ( a + x )\n        if v < a :\n            right = x\n        else :\n            left = x\n    n = left\n    left , right = 0 , n\n    while right - left > 1 :\n        x = ( left + right ) // 2\n        v = w // ( a + x )\n        if v < a + x :\n            right = x\n        else :\n            left = x\n    return right + ( w // ( a + right ) ) - ( w // ( a + n ) )\ndef main ( ) :\n    for a , b in zip ( A , B ) :\n        ans = 2 * ( a - 1 ) + solve ( a , b )\n        print ( ans )\nif __name__ == \"__main__\" :\n    main ( )\n", "python_code_tokenized": "Q = int ( input ( ) ) NEW_LINE A , B = [ None ] * Q , [ None ] * Q NEW_LINE for i in range ( Q ) : NEW_LINE INDENT A [ i ] , B [ i ] = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def solve ( a , b ) : NEW_LINE INDENT w = a * b - 1 NEW_LINE left , right = 0 , b - a NEW_LINE while right - left > 1 : NEW_LINE INDENT x = ( left + right ) // 2 NEW_LINE v = w // ( a + x ) NEW_LINE if v < a : NEW_LINE INDENT right = x NEW_LINE DEDENT else : NEW_LINE INDENT left = x NEW_LINE DEDENT DEDENT n = left NEW_LINE left , right = 0 , n NEW_LINE while right - left > 1 : NEW_LINE INDENT x = ( left + right ) // 2 NEW_LINE v = w // ( a + x ) NEW_LINE if v < a + x : NEW_LINE INDENT right = x NEW_LINE DEDENT else : NEW_LINE INDENT left = x NEW_LINE DEDENT DEDENT return right + ( w // ( a + right ) ) - ( w // ( a + n ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT for a , b in zip ( A , B ) : NEW_LINE INDENT ans = 2 * ( a - 1 ) + solve ( a , b ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC090_C", "sol": 0, "python_code": "def main ( ) :\n    N , M = map ( int , input ( ).split ( ) )\n    if 1 < N :\n        N -= 2\n    if 1 < M :\n        M -= 2\n    print ( N * M )\n    return\nmain ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT N , M = map ( int , input ( ) . split ( ) ) NEW_LINE if 1 < N : NEW_LINE INDENT N -= 2 NEW_LINE DEDENT if 1 < M : NEW_LINE INDENT M -= 2 NEW_LINE DEDENT print ( N * M ) NEW_LINE return NEW_LINE DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_59_A", "sol": 0, "python_code": "MAX = 100005\nfibonacci = set ( )\ndef createHash ( ) :\n    global fibonacci\n    prev , curr = 0 , 1\n    fibonacci.add ( prev )\n    fibonacci.add ( curr )\n    while ( curr <= MAX ) :\n        temp = curr + prev\n        if temp <= MAX :\n            fibonacci.add ( temp )\n        prev = curr\n        curr = temp\ndef checkArray ( arr , n ) :\n    sum = 0\n    for i in range ( n ) :\n        if ( arr [ i ] in fibonacci ) :\n            sum += arr [ i ]\n    if ( sum in fibonacci ) :\n        return True\n    return False\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 4 , 8 , 2 ]\n    n = len ( arr )\n    createHash ( )\n    if ( checkArray ( arr , n ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "MAX = 100005 NEW_LINE fibonacci = set ( ) NEW_LINE def createHash ( ) : NEW_LINE INDENT global fibonacci NEW_LINE prev , curr = 0 , 1 NEW_LINE fibonacci . add ( prev ) NEW_LINE fibonacci . add ( curr ) NEW_LINE while ( curr <= MAX ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if temp <= MAX : NEW_LINE INDENT fibonacci . add ( temp ) NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def checkArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in fibonacci ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum in fibonacci ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE createHash ( ) NEW_LINE if ( checkArray ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4578_A", "sol": 0, "python_code": "def maxSum ( arr , n ) :\n    if ( n < 2 ) :\n        return - 1\n    ans = arr [ 0 ] + arr [ 1 ]\n    for i in range ( 1 , n - 1 , 1 ) :\n        ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) )\n    return ans\nif __name__ == '__main__' :\n    arr = [ 1 , 12 , 2 , 2 ]\n    n = len ( arr )\n    print ( maxSum ( arr , n ) )\n", "python_code_tokenized": "def maxSum ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 , 1 ) : NEW_LINE INDENT ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 12 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "codejam_15_23", "sol": 0, "python_code": "from fractions import Fraction\nT = int ( input ( ) )\nfor test in range ( 1 , T + 1 ) :\n    people = [ ]\n    G = int ( input ( ) )\n    for g in range ( G ) :\n        di , hi , mi = [ int ( x ) for x in input ( ).split ( ) ]\n        for h in range ( hi ) :\n            people.append ( ( di , mi + h ) )\n    assert len ( people ) <= 2\n    d0 , m0 = people [ 0 ]\n    d1 , m1 = people [ 1 ]\n    t0 = Fraction ( ( 360 - d0 ) * m0 , 360 )\n    t1 = Fraction ( ( 360 - d1 ) * m1 , 360 )\n    t = max ( t0 , t1 )\n    prejde0 = t * 360 / m0\n    prejde1 = t * 360 / m1\n    if ( prejde0 >= 720 - d0 ) or ( prejde1 >= 720 - d1 ) :\n        print ( 'Case #{}: {}'.format ( test , 1 ) )\n    else :\n        print ( 'Case #{}: {}'.format ( test , 0 ) )\n", "python_code_tokenized": "from fractions import Fraction NEW_LINE T = int ( input ( ) ) NEW_LINE for test in range ( 1 , T + 1 ) : NEW_LINE INDENT people = [ ] NEW_LINE G = int ( input ( ) ) NEW_LINE for g in range ( G ) : NEW_LINE INDENT di , hi , mi = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE for h in range ( hi ) : NEW_LINE INDENT people . append ( ( di , mi + h ) ) NEW_LINE DEDENT DEDENT assert len ( people ) <= 2 NEW_LINE d0 , m0 = people [ 0 ] NEW_LINE d1 , m1 = people [ 1 ] NEW_LINE t0 = Fraction ( ( 360 - d0 ) * m0 , 360 ) NEW_LINE t1 = Fraction ( ( 360 - d1 ) * m1 , 360 ) NEW_LINE t = max ( t0 , t1 ) NEW_LINE prejde0 = t * 360 / m0 NEW_LINE prejde1 = t * 360 / m1 NEW_LINE if ( prejde0 >= 720 - d0 ) or ( prejde1 >= 720 - d1 ) : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( test , 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( test , 0 ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_3378_A", "sol": 0, "python_code": "def cntWays ( string , n ) :\n    x = n + 1 ;\n    ways = x * x * ( x * x - 1 ) // 12 ;\n    return ways ;\nif __name__ == \"__main__\" :\n    string = \"ab\" ;\n    n = len ( string ) ;\n    print ( cntWays ( string , n ) ) ;\n", "python_code_tokenized": "def cntWays ( string , n ) : NEW_LINE INDENT x = n + 1 ; NEW_LINE ways = x * x * ( x * x - 1 ) // 12 ; NEW_LINE return ways ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ab \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( cntWays ( string , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_573_A", "sol": 0, "python_code": "def count ( S , m , n ) :\n    table = [ [ 0 for x in range ( m ) ] for x in range ( n + 1 ) ]\n    for i in range ( m ) :\n        table [ 0 ] [ i ] = 1\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( m ) :\n            x = table [ i - S [ j ] ] [ j ] if i - S [ j ] >= 0 else 0\n            y = table [ i ] [ j - 1 ] if j >= 1 else 0\n            table [ i ] [ j ] = x + y\n    return table [ n ] [ m - 1 ]\narr = [ 1 , 2 , 3 ]\nm = len ( arr )\nn = 4\nprint ( count ( arr , m , n ) )\n", "python_code_tokenized": "def count ( S , m , n ) : NEW_LINE INDENT table = [ [ 0 for x in range ( m ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT table [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT x = table [ i - S [ j ] ] [ j ] if i - S [ j ] >= 0 else 0 NEW_LINE y = table [ i ] [ j - 1 ] if j >= 1 else 0 NEW_LINE table [ i ] [ j ] = x + y NEW_LINE DEDENT DEDENT return table [ n ] [ m - 1 ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE n = 4 NEW_LINE print ( count ( arr , m , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3432_A", "sol": 0, "python_code": "def count ( S , m , n ) :\n    table = [ [ 0 for x in range ( m ) ] for x in range ( n + 1 ) ]\n    for i in range ( m ) :\n        table [ 0 ] [ i ] = 1\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( m ) :\n            x = table [ i - S [ j ] ] [ j ] if i - S [ j ] >= 0 else 0\n            y = table [ i ] [ j - 1 ] if j >= 1 else 0\n            table [ i ] [ j ] = x + y\n    return table [ n ] [ m - 1 ]\narr = [ 1 , 2 , 3 ]\nm = len ( arr )\nn = 4\nprint ( count ( arr , m , n ) )\n", "python_code_tokenized": "def count ( S , m , n ) : NEW_LINE INDENT table = [ [ 0 for x in range ( m ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT table [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT x = table [ i - S [ j ] ] [ j ] if i - S [ j ] >= 0 else 0 NEW_LINE y = table [ i ] [ j - 1 ] if j >= 1 else 0 NEW_LINE table [ i ] [ j ] = x + y NEW_LINE DEDENT DEDENT return table [ n ] [ m - 1 ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE n = 4 NEW_LINE print ( count ( arr , m , n ) ) NEW_LINE"}
{"id": "codeforces_1344_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    l = list ( map ( int , input ( ).split ( ) ) )\n    d = { }\n    f = 0\n    for i in range ( n ) :\n        x = ( i + l [ i ] ) % n\n        if x in d :\n            f = 1\n            break\n        else :\n            d [ x ] = 1\n    if f == 1 :\n        print ( 'NO' )\n    else :\n        print ( 'YES' )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE f = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = ( i + l [ i ] ) % n NEW_LINE if x in d : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT d [ x ] = 1 NEW_LINE DEDENT DEDENT if f == 1 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4087_A", "sol": 0, "python_code": "def squareRoot ( number , precision ) :\n    start = 0\n    end , ans = number , 1\n    while ( start <= end ) :\n        mid = int ( ( start + end ) / 2 )\n        if ( mid * mid == number ) :\n            ans = mid\n            break\n        if ( mid * mid < number ) :\n            start = mid + 1\n        else :\n            end = mid - 1\n    increment = 0.1\n    for i in range ( 0 , precision ) :\n        while ( ans * ans <= number ) :\n            ans += increment\n        ans = ans - increment\n        increment = increment / 10\n    return ans\nprint ( round ( squareRoot ( 50 , 3 ) , 4 ) )\nprint ( round ( squareRoot ( 10 , 4 ) , 4 ) )\n", "python_code_tokenized": "def squareRoot ( number , precision ) : NEW_LINE INDENT start = 0 NEW_LINE end , ans = number , 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( mid * mid == number ) : NEW_LINE INDENT ans = mid NEW_LINE break NEW_LINE DEDENT if ( mid * mid < number ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT increment = 0.1 NEW_LINE for i in range ( 0 , precision ) : NEW_LINE INDENT while ( ans * ans <= number ) : NEW_LINE INDENT ans += increment NEW_LINE DEDENT ans = ans - increment NEW_LINE increment = increment / 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT print ( round ( squareRoot ( 50 , 3 ) , 4 ) ) NEW_LINE print ( round ( squareRoot ( 10 , 4 ) , 4 ) ) NEW_LINE"}
{"id": "codeforces_567_B", "sol": 0, "python_code": "from sys import stdin , stdout\nfrom os import path\nrd = lambda : stdin.readline ( ).strip ( )\nwr = stdout.write\nif ( path.exists ( 'input.txt' ) ) :\n    stdin = open ( \"input.txt\" , \"r\" )\nimport time , math\nx = int ( rd ( ) )\ncapacity = 0\nroomCount = 0\namr = dict ( )\nmx = - 1\nprev = - 1\nfor _ in range ( x ) :\n    sign , id = map ( str , rd ( ).split ( ) )\n    if sign == '+' :\n        roomCount += 1\n        capacity = max ( capacity , roomCount )\n    else :\n        if id in amr :\n            roomCount -= 1\n        else :\n            capacity += 1\n    amr [ id ] = 1\nprint ( capacity )\n", "python_code_tokenized": "from sys import stdin , stdout NEW_LINE from os import path NEW_LINE rd = lambda : stdin . readline ( ) . strip ( ) NEW_LINE wr = stdout . write NEW_LINE if ( path . exists ( ' input . txt ' ) ) : NEW_LINE INDENT stdin = open ( \" input . txt \" , \" r \" ) NEW_LINE DEDENT import time , math NEW_LINE x = int ( rd ( ) ) NEW_LINE capacity = 0 NEW_LINE roomCount = 0 NEW_LINE amr = dict ( ) NEW_LINE mx = - 1 NEW_LINE prev = - 1 NEW_LINE for _ in range ( x ) : NEW_LINE INDENT sign , id = map ( str , rd ( ) . split ( ) ) NEW_LINE if sign == ' + ' : NEW_LINE INDENT roomCount += 1 NEW_LINE capacity = max ( capacity , roomCount ) NEW_LINE DEDENT else : NEW_LINE INDENT if id in amr : NEW_LINE INDENT roomCount -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT capacity += 1 NEW_LINE DEDENT DEDENT amr [ id ] = 1 NEW_LINE DEDENT print ( capacity ) NEW_LINE"}
{"id": "geeksforgeeks_4470_A", "sol": 0, "python_code": "one = [ \"\" , \"one \" , \"two \" , \"three \" , \"four \" , \"five \" , \"six \" , \"seven \" , \"eight \" , \"nine \" , \"ten \" , \"eleven \" , \"twelve \" , \"thirteen \" , \"fourteen \" , \"fifteen \" , \"sixteen \" , \"seventeen \" , \"eighteen \" , \"nineteen \" ] ;\nten = [ \"\" , \"\" , \"twenty \" , \"thirty \" , \"forty \" , \"fifty \" , \"sixty \" , \"seventy \" , \"eighty \" , \"ninety \" ] ;\ndef numToWords ( n , s ) :\n    str = \"\" ;\n    if ( n > 19 ) :\n        str += ten [ n // 10 ] + one [ n % 10 ] ;\n    else :\n        str += one [ n ] ;\n    if ( n ) :\n        str += s ;\n    return str ;\ndef convertToWords ( n ) :\n    out = \"\" ;\n    out += numToWords ( ( n // 10000000 ) , \"crore \" ) ;\n    out += numToWords ( ( ( n // 100000 ) % 100 ) , \"lakh \" ) ;\n    out += numToWords ( ( ( n // 1000 ) % 100 ) , \"thousand \" ) ;\n    out += numToWords ( ( ( n // 100 ) % 10 ) , \"hundred \" ) ;\n    if ( n > 100 and n % 100 ) :\n        out += \"and \" ;\n    out += numToWords ( ( n % 100 ) , \"\" ) ;\n    return out ;\nn = 438237764 ;\nprint ( convertToWords ( n ) ) ;\n", "python_code_tokenized": "one = [ \" \" , \" one \u2581 \" , \" two \u2581 \" , \" three \u2581 \" , \" four \u2581 \" , \" five \u2581 \" , \" six \u2581 \" , \" seven \u2581 \" , \" eight \u2581 \" , \" nine \u2581 \" , \" ten \u2581 \" , \" eleven \u2581 \" , \" twelve \u2581 \" , \" thirteen \u2581 \" , \" fourteen \u2581 \" , \" fifteen \u2581 \" , \" sixteen \u2581 \" , \" seventeen \u2581 \" , \" eighteen \u2581 \" , \" nineteen \u2581 \" ] ; NEW_LINE ten = [ \" \" , \" \" , \" twenty \u2581 \" , \" thirty \u2581 \" , \" forty \u2581 \" , \" fifty \u2581 \" , \" sixty \u2581 \" , \" seventy \u2581 \" , \" eighty \u2581 \" , \" ninety \u2581 \" ] ; NEW_LINE def numToWords ( n , s ) : NEW_LINE INDENT str = \" \" ; NEW_LINE if ( n > 19 ) : NEW_LINE INDENT str += ten [ n // 10 ] + one [ n % 10 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT str += one [ n ] ; NEW_LINE DEDENT if ( n ) : NEW_LINE INDENT str += s ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT def convertToWords ( n ) : NEW_LINE INDENT out = \" \" ; NEW_LINE out += numToWords ( ( n // 10000000 ) , \" crore \u2581 \" ) ; NEW_LINE out += numToWords ( ( ( n // 100000 ) % 100 ) , \" lakh \u2581 \" ) ; NEW_LINE out += numToWords ( ( ( n // 1000 ) % 100 ) , \" thousand \u2581 \" ) ; NEW_LINE out += numToWords ( ( ( n // 100 ) % 10 ) , \" hundred \u2581 \" ) ; NEW_LINE if ( n > 100 and n % 100 ) : NEW_LINE INDENT out += \" and \u2581 \" ; NEW_LINE DEDENT out += numToWords ( ( n % 100 ) , \" \" ) ; NEW_LINE return out ; NEW_LINE DEDENT n = 438237764 ; NEW_LINE print ( convertToWords ( n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_566_A", "sol": 0, "python_code": "def check ( n ) :\n    sum = 0\n    while n != 0 :\n        sum += n % 10\n        n = n // 10\n    if sum % 7 == 0 :\n        return 1\n    else :\n        return 0\nif __name__ == \"__main__\" :\n    n = 25\n    print ( ( \"YES\" ) if check ( n ) == 1 else print ( \"NO\" ) )\n", "python_code_tokenized": "def check ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT if sum % 7 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 25 NEW_LINE print ( ( \" YES \" ) if check ( n ) == 1 else print ( \" NO \" ) ) NEW_LINE DEDENT"}
{"id": "projecteuler_p301_A", "sol": 0, "python_code": "def compute ( ) :\n    a = 0\n    b = 1\n    for i in range ( 32 ) :\n        a , b = b , a + b\n    return str ( a )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "def compute ( ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT a , b = b , a + b NEW_LINE DEDENT return str ( a ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2015_A", "sol": 0, "python_code": "def calculateSum ( n ) :\n    a1 = 1 ;\n    a2 = 2 ;\n    r = 2 ;\n    d = 1 ;\n    return ( ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( pow ( r , n ) - 1 ) / ( r - 1 ) ) ;\nn = 5 ;\nprint ( \"Sum =\" , int ( calculateSum ( n ) ) )\n", "python_code_tokenized": "def calculateSum ( n ) : NEW_LINE INDENT a1 = 1 ; NEW_LINE a2 = 2 ; NEW_LINE r = 2 ; NEW_LINE d = 1 ; NEW_LINE return ( ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( pow ( r , n ) - 1 ) / ( r - 1 ) ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( \" Sum \u2581 = \" , int ( calculateSum ( n ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_2030_A", "sol": 0, "python_code": "def check_digits ( n ) :\n    while ( n ) :\n        if ( ( n % 10 ) % 2 ) :\n            return 0\n        n = int ( n / 10 )\n    return 1\ndef smallest_number ( n ) :\n    for i in range ( n , 2401 ) :\n        if ( check_digits ( i ) == 1 ) :\n            return ( i )\nN = 2397\nprint ( str ( smallest_number ( N ) ) )\n", "python_code_tokenized": "def check_digits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT for i in range ( n , 2401 ) : NEW_LINE INDENT if ( check_digits ( i ) == 1 ) : NEW_LINE INDENT return ( i ) NEW_LINE DEDENT DEDENT DEDENT N = 2397 NEW_LINE print ( str ( smallest_number ( N ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_2232_A", "sol": 0, "python_code": "def check_digits ( n ) :\n    while ( n ) :\n        if ( ( n % 10 ) % 2 == 0 ) :\n            return 0\n        n = int ( n / 10 )\n    return 1\ndef smallest_number ( n ) :\n    i = n\n    while ( 1 ) :\n        if ( check_digits ( i ) ) :\n            return i\n        i += 1\nif __name__ == '__main__' :\n    N = 2397\n    print ( smallest_number ( N ) )\n", "python_code_tokenized": "def check_digits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT i = n NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( check_digits ( i ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2397 NEW_LINE print ( smallest_number ( N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1669_A", "sol": 0, "python_code": "def search ( a , k , x ) :\n    for j in range ( k - 1 , - 1 , - 1 ) :\n        if ( a [ j ] == x ) :\n            return j\n    return - 1\ndef genArray ( arr , N ) :\n    for i in range ( 0 , N - 1 , 1 ) :\n        if ( search ( arr , i , arr [ i ] ) == - 1 ) :\n            arr [ i + 1 ] = 0\n        else :\n            arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) )\nif __name__ == \"__main__\" :\n    N = 5\n    size = N + 1\n    a = [ 0 ] * N\n    genArray ( a , N )\n    print ( a )\n", "python_code_tokenized": "def search ( a , k , x ) : NEW_LINE INDENT for j in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ j ] == x ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def genArray ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N - 1 , 1 ) : NEW_LINE INDENT if ( search ( arr , i , arr [ i ] ) == - 1 ) : NEW_LINE INDENT arr [ i + 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 NEW_LINE size = N + 1 NEW_LINE a = [ 0 ] * N NEW_LINE genArray ( a , N ) NEW_LINE print ( a ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC149_A", "sol": 0, "python_code": "s , t = map ( str , input ( ).split ( ) )\na = t + s\nprint ( a )\n", "python_code_tokenized": "s , t = map ( str , input ( ) . split ( ) ) NEW_LINE a = t + s NEW_LINE print ( a ) NEW_LINE"}
{"id": "codeforces_1708_B", "sol": 0, "python_code": "from math import ceil\ndef solve ( ) :\n    n , l , r = map ( int , input ( ).split ( ) )\n    resp = [ ]\n    for i in range ( 1 , n + 1 ) :\n        if l <= ceil ( l / i ) * i <= r :\n            resp.append ( ceil ( l / i ) * i )\n            continue\n        elif l <= ( ceil ( l / i ) + 1 ) * i <= r :\n            resp.append ( ( ceil ( l / i ) + 1 ) * i )\n            continue\n        print ( 'NO' )\n        return\n    print ( 'YES' )\n    for ai in resp :\n        print ( ai , end = \" \" )\n    print ( )\nfor tc in range ( int ( input ( ) ) ) :\n    solve ( )\n", "python_code_tokenized": "from math import ceil NEW_LINE def solve ( ) : NEW_LINE INDENT n , l , r = map ( int , input ( ) . split ( ) ) NEW_LINE resp = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if l <= ceil ( l / i ) * i <= r : NEW_LINE INDENT resp . append ( ceil ( l / i ) * i ) NEW_LINE continue NEW_LINE DEDENT elif l <= ( ceil ( l / i ) + 1 ) * i <= r : NEW_LINE INDENT resp . append ( ( ceil ( l / i ) + 1 ) * i ) NEW_LINE continue NEW_LINE DEDENT print ( ' NO ' ) NEW_LINE return NEW_LINE DEDENT print ( ' YES ' ) NEW_LINE for ai in resp : NEW_LINE INDENT print ( ai , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT for tc in range ( int ( input ( ) ) ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"}
{"id": "codeforces_1694_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    s = input ( )\n    ans = n\n    for idx in range ( 1 , n ) :\n        if s [ idx - 1 ] != s [ idx ] :\n            ans += idx\n    print ( ans )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = n NEW_LINE for idx in range ( 1 , n ) : NEW_LINE INDENT if s [ idx - 1 ] != s [ idx ] : NEW_LINE INDENT ans += idx NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "codeforces_1674_A", "sol": 0, "python_code": "for i in range ( int ( input ( ) ) ) :\n    x , y = map ( int , input ( ).split ( ) )\n    a = 1\n    if y / x != y // x or x > y :\n        b = 0\n        a = 0\n    else :\n        b = y // x\n    print ( a , b )\n", "python_code_tokenized": "for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a = 1 NEW_LINE if y / x != y // x or x > y : NEW_LINE INDENT b = 0 NEW_LINE a = 0 NEW_LINE DEDENT else : NEW_LINE INDENT b = y // x NEW_LINE DEDENT print ( a , b ) NEW_LINE DEDENT"}
{"id": "codeforces_1705_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    arr = list ( map ( int , input ( ).split ( ) ) )\n    f = - 1\n    t = 0\n    for i in range ( n ) :\n        if arr [ i ] > 0 :\n            f = i\n            break\n    if f == n - 1 or f == - 1 :\n        print ( 0 )\n        continue\n    ans = 0\n    for i in range ( f , n - 1 ) :\n        if arr [ i ] > 0 :\n            ans += arr [ i ]\n        else :\n            ans += 1\n    print ( ans )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE f = - 1 NEW_LINE t = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT f = i NEW_LINE break NEW_LINE DEDENT DEDENT if f == n - 1 or f == - 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE continue NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( f , n - 1 ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "codeforces_978_B", "sol": 0, "python_code": "n = int ( input ( ) )\ns = input ( )\ni = 0\nx = 0\nans = 0\nfor j in range ( 1 , n ) :\n    if s [ j ] == s [ i ] == 'x' :\n        x += 1\n    else :\n        if x > 1 :\n            ans += x - 1\n        x = 0\n    i = j\nif x > 1 :\n    ans += x - 1\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE x = 0 NEW_LINE ans = 0 NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if s [ j ] == s [ i ] == ' x ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if x > 1 : NEW_LINE INDENT ans += x - 1 NEW_LINE DEDENT x = 0 NEW_LINE DEDENT i = j NEW_LINE DEDENT if x > 1 : NEW_LINE INDENT ans += x - 1 NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_1682_B", "sol": 0, "python_code": "from sys import maxsize\nt = int ( input ( ) )\nfor _ in range ( t ) :\n    n = int ( input ( ) )\n    p = list ( map ( int , input ( ).split ( ) ) )\n    a = maxsize\n    for i , j in enumerate ( p ) :\n        if i != j :\n            a &= j\n    print ( a )\n", "python_code_tokenized": "from sys import maxsize NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = maxsize NEW_LINE for i , j in enumerate ( p ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT a &= j NEW_LINE DEDENT DEDENT print ( a ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3864_A", "sol": 0, "python_code": "def check ( s ) :\n    for i in range ( len ( s ) - 1 ) :\n        if ( abs ( ord ( s [ i ] ) - ord ( s [ i + 1 ] ) ) == 1 ) :\n            return False\n    return True\ndef Rearrange ( Str ) :\n    odd , even = \"\" , \"\"\n    for i in range ( len ( Str ) ) :\n        if ( ord ( Str [ i ] ) % 2 == 0 ) :\n            even += Str [ i ]\n        else :\n            odd += Str [ i ]\n    odd = sorted ( odd )\n    even = sorted ( even )\n    if ( check ( odd + even ) ) :\n        print ( \"\".join ( odd + even ) )\n    elif ( check ( even + odd ) ) :\n        print ( \"\".join ( even + odd ) )\n    else :\n        print ( - 1 )\nStr = \"aabcd\"\nRearrange ( Str )\n", "python_code_tokenized": "def check ( s ) : NEW_LINE INDENT for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( abs ( ord ( s [ i ] ) - ord ( s [ i + 1 ] ) ) == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def Rearrange ( Str ) : NEW_LINE INDENT odd , even = \" \" , \" \" NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT if ( ord ( Str [ i ] ) % 2 == 0 ) : NEW_LINE INDENT even += Str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT odd += Str [ i ] NEW_LINE DEDENT DEDENT odd = sorted ( odd ) NEW_LINE even = sorted ( even ) NEW_LINE if ( check ( odd + even ) ) : NEW_LINE INDENT print ( \" \" . join ( odd + even ) ) NEW_LINE DEDENT elif ( check ( even + odd ) ) : NEW_LINE INDENT print ( \" \" . join ( even + odd ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT Str = \" aabcd \" NEW_LINE Rearrange ( Str ) NEW_LINE"}
{"id": "geeksforgeeks_3512_A", "sol": 0, "python_code": "def countways ( n ) :\n    if ( n == 1 ) :\n        return 0 ;\n    elif ( n % 2 == 0 ) :\n        return 1 + countways ( n / 2 ) ;\n    else :\n        return 1 + min ( countways ( n - 1 ) , countways ( n + 1 ) ) ;\nn = 15 ;\nprint ( countways ( n ) ) ;\n", "python_code_tokenized": "def countways ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return 1 + countways ( n / 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + min ( countways ( n - 1 ) , countways ( n + 1 ) ) ; NEW_LINE DEDENT DEDENT n = 15 ; NEW_LINE print ( countways ( n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_4870_A", "sol": 0, "python_code": "def Find_Sequence ( array , n ) :\n    inc_arr , dec_arr = [ ] , [ ]\n    inc , dec = - 1 , 1e7\n    for i in range ( n ) :\n        if inc < array [ i ] < dec :\n            if array [ i ] < array [ i + 1 ] :\n                inc = array [ i ]\n                inc_arr.append ( array [ i ] )\n            else :\n                dec = array [ i ]\n                dec_arr.append ( array [ i ] )\n        elif inc < array [ i ] :\n            inc = array [ i ]\n            inc_arr.append ( array [ i ] )\n        elif dec > array [ i ] :\n            dec = array [ i ]\n            dec_arr.append ( array [ i ] )\n        else :\n            print ( '-1' )\n            break\n    else :\n        print ( inc_arr , dec_arr )\narr = [ 5 , 1 , 3 , 6 , 8 , 2 , 9 , 0 , 10 ]\nn = len ( arr )\nFind_Sequence ( arr , n )\n", "python_code_tokenized": "def Find_Sequence ( array , n ) : NEW_LINE INDENT inc_arr , dec_arr = [ ] , [ ] NEW_LINE inc , dec = - 1 , 1e7 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if inc < array [ i ] < dec : NEW_LINE INDENT if array [ i ] < array [ i + 1 ] : NEW_LINE INDENT inc = array [ i ] NEW_LINE inc_arr . append ( array [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dec = array [ i ] NEW_LINE dec_arr . append ( array [ i ] ) NEW_LINE DEDENT DEDENT elif inc < array [ i ] : NEW_LINE INDENT inc = array [ i ] NEW_LINE inc_arr . append ( array [ i ] ) NEW_LINE DEDENT elif dec > array [ i ] : NEW_LINE INDENT dec = array [ i ] NEW_LINE dec_arr . append ( array [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( inc_arr , dec_arr ) NEW_LINE DEDENT DEDENT arr = [ 5 , 1 , 3 , 6 , 8 , 2 , 9 , 0 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE Find_Sequence ( arr , n ) NEW_LINE"}
{"id": "aizu_p00203_A", "sol": 0, "python_code": "def solve ( c ) :\n    w , h = len ( c [ 0 ] ) , len ( c )\n    dp = [ [ 0 ] * w for _ in range ( h ) ]\n    for x in range ( w ) :\n        if c [ 1 ] [ x ] == 0 :\n            dp [ 1 ] [ x ] = 1\n    for y in range ( 2 , h ) :\n        for x in range ( w ) :\n            if c [ y ] [ x ] == 1 :\n                continue\n            if c [ y - 2 ] [ x ] == 2 :\n                dp [ y ] [ x ] += dp [ y - 2 ] [ x ]\n            if c [ y - 1 ] [ x ] == 0 :\n                dp [ y ] [ x ] += dp [ y - 1 ] [ x ]\n            if c [ y ] [ x ] == 0 :\n                if c [ y - 1 ] [ x - 1 ] == 0 :\n                    dp [ y ] [ x ] += dp [ y - 1 ] [ x - 1 ]\n                if c [ y - 1 ] [ x + 1 ] == 0 :\n                    dp [ y ] [ x ] += dp [ y - 1 ] [ x + 1 ]\n    return sum ( dp [ - 1 ] ) + sum ( dp [ - 2 ] [ x ] for x in range ( w ) if c [ - 2 ] [ x ] == 2 )\nimport sys\nf = sys.stdin\nwhile True :\n    w , h = map ( int , f.readline ( ).split ( ) )\n    if w == 0 :\n        break\n    course = [ [ 1 ] * ( w + 2 ) ] + [ [ 1 ] + list ( map ( int , f.readline ( ).split ( ) ) ) + [ 1 ] for _ in range ( h ) ]\n    print ( solve ( course ) )\n", "python_code_tokenized": "def solve ( c ) : NEW_LINE INDENT w , h = len ( c [ 0 ] ) , len ( c ) NEW_LINE dp = [ [ 0 ] * w for _ in range ( h ) ] NEW_LINE for x in range ( w ) : NEW_LINE INDENT if c [ 1 ] [ x ] == 0 : NEW_LINE INDENT dp [ 1 ] [ x ] = 1 NEW_LINE DEDENT DEDENT for y in range ( 2 , h ) : NEW_LINE INDENT for x in range ( w ) : NEW_LINE INDENT if c [ y ] [ x ] == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if c [ y - 2 ] [ x ] == 2 : NEW_LINE INDENT dp [ y ] [ x ] += dp [ y - 2 ] [ x ] NEW_LINE DEDENT if c [ y - 1 ] [ x ] == 0 : NEW_LINE INDENT dp [ y ] [ x ] += dp [ y - 1 ] [ x ] NEW_LINE DEDENT if c [ y ] [ x ] == 0 : NEW_LINE INDENT if c [ y - 1 ] [ x - 1 ] == 0 : NEW_LINE INDENT dp [ y ] [ x ] += dp [ y - 1 ] [ x - 1 ] NEW_LINE DEDENT if c [ y - 1 ] [ x + 1 ] == 0 : NEW_LINE INDENT dp [ y ] [ x ] += dp [ y - 1 ] [ x + 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return sum ( dp [ - 1 ] ) + sum ( dp [ - 2 ] [ x ] for x in range ( w ) if c [ - 2 ] [ x ] == 2 ) NEW_LINE DEDENT import sys NEW_LINE f = sys . stdin NEW_LINE while True : NEW_LINE INDENT w , h = map ( int , f . readline ( ) . split ( ) ) NEW_LINE if w == 0 : NEW_LINE INDENT break NEW_LINE DEDENT course = [ [ 1 ] * ( w + 2 ) ] + [ [ 1 ] + list ( map ( int , f . readline ( ) . split ( ) ) ) + [ 1 ] for _ in range ( h ) ] NEW_LINE print ( solve ( course ) ) NEW_LINE DEDENT"}
{"id": "codeforces_440_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nt = 0\nfor i in range ( n ) :\n    t += a [ i ]\nt = t // n\ncnt = 0\nfor i in range ( n ) :\n    if a [ i ] > t :\n        a [ i + 1 ] += abs ( a [ i ] - t )\n        cnt += ( abs ( a [ i ] - t ) )\n    elif a [ i ] < t :\n        a [ i + 1 ] -= abs ( a [ i ] - t )\n        cnt += ( abs ( a [ i ] - t ) )\nprint ( cnt )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT t += a [ i ] NEW_LINE DEDENT t = t // n NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > t : NEW_LINE INDENT a [ i + 1 ] += abs ( a [ i ] - t ) NEW_LINE cnt += ( abs ( a [ i ] - t ) ) NEW_LINE DEDENT elif a [ i ] < t : NEW_LINE INDENT a [ i + 1 ] -= abs ( a [ i ] - t ) NEW_LINE cnt += ( abs ( a [ i ] - t ) ) NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE"}
{"id": "geeksforgeeks_2881_A", "sol": 0, "python_code": "def toDecimal ( binary , i = 0 ) :\n    n = len ( binary )\n    if ( i == n - 1 ) :\n        return int ( binary [ i ] ) - 0\n    return ( ( ( int ( binary [ i ] ) - 0 ) << ( n - i - 1 ) ) + toDecimal ( binary , i + 1 ) )\nif __name__ == \"__main__\" :\n    binary = \"1010\"\n    print ( toDecimal ( binary ) )\n", "python_code_tokenized": "def toDecimal ( binary , i = 0 ) : NEW_LINE INDENT n = len ( binary ) NEW_LINE if ( i == n - 1 ) : NEW_LINE INDENT return int ( binary [ i ] ) - 0 NEW_LINE DEDENT return ( ( ( int ( binary [ i ] ) - 0 ) << ( n - i - 1 ) ) + toDecimal ( binary , i + 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT binary = \"1010\" NEW_LINE print ( toDecimal ( binary ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_193_A", "sol": 0, "python_code": "def Circular ( n ) :\n    Result = 1\n    while n > 0 :\n        Result = Result * n\n        n -= 1\n    return Result\nif __name__ == \"__main__\" :\n    n = 4\n    print ( Circular ( n - 1 ) )\n", "python_code_tokenized": "def Circular ( n ) : NEW_LINE INDENT Result = 1 NEW_LINE while n > 0 : NEW_LINE INDENT Result = Result * n NEW_LINE n -= 1 NEW_LINE DEDENT return Result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE print ( Circular ( n - 1 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1121_A", "sol": 0, "python_code": "import math\ndef findMinValue ( arr , n ) :\n    arr.sort ( )\n    val = 0\n    for i in range ( n ) :\n        val += ( math.log ( arr [ i ] ) )\n    left = arr [ 0 ]\n    right = arr [ n - 1 ] + 1\n    while ( left <= right ) :\n        mid = ( left + right ) // 2\n        temp = n * ( math.log ( mid ) )\n        if ( val < temp ) :\n            ans = mid\n            right = mid - 1\n        else :\n            left = mid + 1\n    return ans\nif __name__ == \"__main__\" :\n    arr = [ 4 , 2 , 1 , 10 , 6 ]\n    n = len ( arr )\n    print ( findMinValue ( arr , n ) )\n", "python_code_tokenized": "import math NEW_LINE def findMinValue ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE val = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val += ( math . log ( arr [ i ] ) ) NEW_LINE DEDENT left = arr [ 0 ] NEW_LINE right = arr [ n - 1 ] + 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE temp = n * ( math . log ( mid ) ) NEW_LINE if ( val < temp ) : NEW_LINE INDENT ans = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 2 , 1 , 10 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinValue ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4464_A", "sol": 0, "python_code": "def power ( x , y ) :\n    if ( y == 0 ) :\n        return 1\n    elif ( y % 2 == 0 ) :\n        return ( power ( x , y // 2 ) * power ( x , y // 2 ) )\n    else :\n        return ( x * power ( x , y // 2 ) * power ( x , y // 2 ) )\ndef sieveOfEratosthenes ( n , isPrime ) :\n    isPrime [ 0 ] = isPrime [ 1 ] = False\n    for i in range ( 2 , n + 1 ) :\n        isPrime [ i ] = True\n    p = 2\n    while ( p * p <= n ) :\n        if ( isPrime [ p ] == True ) :\n            i = p * 2\n            while ( i <= n ) :\n                isPrime [ i ] = False\n                i = i + p\n        p = p + 1\ndef leftTruPrime ( n ) :\n    temp = n\n    cnt = 0\n    while ( temp != 0 ) :\n        cnt = cnt + 1\n        temp1 = temp % 10 ;\n        if ( temp1 == 0 ) :\n            return False\n        temp = temp // 10\n    isPrime = [ None ] * ( n + 1 )\n    sieveOfEratosthenes ( n , isPrime )\n    for i in range ( cnt , 0 , - 1 ) :\n        mod = power ( 10 , i )\n        if ( isPrime [ n % mod ] != True ) :\n            return False\n    return True\nn = 113\nif ( leftTruPrime ( n ) ) :\n    print ( n , \"is left truncatable prime\" )\nelse :\n    print ( n , \"is not left truncatable prime\" )\n", "python_code_tokenized": "def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y % 2 == 0 ) : NEW_LINE INDENT return ( power ( x , y // 2 ) * power ( x , y // 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * power ( x , y // 2 ) * power ( x , y // 2 ) ) NEW_LINE DEDENT DEDENT def sieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE i = i + p NEW_LINE DEDENT DEDENT p = p + 1 NEW_LINE DEDENT DEDENT def leftTruPrime ( n ) : NEW_LINE INDENT temp = n NEW_LINE cnt = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE temp1 = temp % 10 ; NEW_LINE if ( temp1 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = temp // 10 NEW_LINE DEDENT isPrime = [ None ] * ( n + 1 ) NEW_LINE sieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( cnt , 0 , - 1 ) : NEW_LINE INDENT mod = power ( 10 , i ) NEW_LINE if ( isPrime [ n % mod ] != True ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 113 NEW_LINE if ( leftTruPrime ( n ) ) : NEW_LINE INDENT print ( n , \" is \u2581 left \u2581 truncatable \u2581 prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , \" is \u2581 not \u2581 left \u2581 truncatable \u2581 prime \" ) NEW_LINE DEDENT"}
{"id": "codeforces_270_A", "sol": 0, "python_code": "for x in range ( int ( input ( ) ) ) :\n    a = int ( input ( ) )\n    if a > 59 and 360 % ( 180 - a ) == 0 :\n        print ( 'YES' )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "for x in range ( int ( input ( ) ) ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE if a > 59 and 360 % ( 180 - a ) == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1358_B", "sol": 0, "python_code": "for s in [ * open ( 0 ) ] [ 2 : : 2 ] :\n    i = r = 0\n    for x in sorted ( map ( int , s.split ( ) ) ) : i += 1 ; r = ( i , r ) [ x > i ]\n    print ( r + 1 )\n", "python_code_tokenized": "for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT i = r = 0 NEW_LINE for x in sorted ( map ( int , s . split ( ) ) ) : i += 1 ; r = ( i , r ) [ x > i ] NEW_LINE print ( r + 1 ) NEW_LINE DEDENT"}
{"id": "codeforces_1291_B", "sol": 0, "python_code": "caseNumber = int ( input ( ) )\nwhile caseNumber != 0 :\n    arraySize = int ( input ( ) )\n    array = input ( ).split ( \" \" )\n    positionCount = 0\n    middlePosition = int ( arraySize / 2 ) - 1\n    Pass = True\n    if arraySize % 2 == 0 :\n        if int ( array [ middlePosition ] ) < middlePosition + 1 and int ( array [ middlePosition + 1 ] ) < middlePosition + 1 :\n            Pass = False\n    for digit in array :\n        digit = int ( digit )\n        reversePositionCount = arraySize - 1 - positionCount\n        if reversePositionCount < positionCount :\n            relativePosition = reversePositionCount\n        else :\n            relativePosition = positionCount\n        if digit < relativePosition :\n            Pass = False\n            break\n        positionCount = positionCount + 1\n    if Pass == True :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n    caseNumber = caseNumber - 1\n", "python_code_tokenized": "caseNumber = int ( input ( ) ) NEW_LINE while caseNumber != 0 : NEW_LINE INDENT arraySize = int ( input ( ) ) NEW_LINE array = input ( ) . split ( \" \u2581 \" ) NEW_LINE positionCount = 0 NEW_LINE middlePosition = int ( arraySize / 2 ) - 1 NEW_LINE Pass = True NEW_LINE if arraySize % 2 == 0 : NEW_LINE INDENT if int ( array [ middlePosition ] ) < middlePosition + 1 and int ( array [ middlePosition + 1 ] ) < middlePosition + 1 : NEW_LINE INDENT Pass = False NEW_LINE DEDENT DEDENT for digit in array : NEW_LINE INDENT digit = int ( digit ) NEW_LINE reversePositionCount = arraySize - 1 - positionCount NEW_LINE if reversePositionCount < positionCount : NEW_LINE INDENT relativePosition = reversePositionCount NEW_LINE DEDENT else : NEW_LINE INDENT relativePosition = positionCount NEW_LINE DEDENT if digit < relativePosition : NEW_LINE INDENT Pass = False NEW_LINE break NEW_LINE DEDENT positionCount = positionCount + 1 NEW_LINE DEDENT if Pass == True : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT caseNumber = caseNumber - 1 NEW_LINE DEDENT"}
{"id": "codeforces_912_A", "sol": 0, "python_code": "y , n = map ( int , input ( ).split ( ) )\na , b , c = map ( int , input ( ).split ( ) )\nprint ( max ( 0 , 2 * a + b - y ) + max ( 0 , 3 * c + b - n ) )\n", "python_code_tokenized": "y , n = map ( int , input ( ) . split ( ) ) NEW_LINE a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( 0 , 2 * a + b - y ) + max ( 0 , 3 * c + b - n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2863_A", "sol": 0, "python_code": "def isPalindrome ( string : str , low : int , high : int ) -> bool :\n    while low < high :\n        if string [ low ] != string [ high ] :\n            return False\n        low += 1\n        high -= 1\n    return True\ndef possiblepalinByRemovingOneChar ( string : str ) -> int :\n    low = 0\n    high = len ( string ) - 1\n    while low < high :\n        if string [ low ] == string [ high ] :\n            low += 1\n            high -= 1\n        else :\n            if isPalindrome ( string , low + 1 , high ) :\n                return low\n            if isPalindrome ( string , low , high - 1 ) :\n                return high\n            return - 1\n    return - 2\nif __name__ == \"__main__\" :\n    string = \"abecbea\"\n    idx = possiblepalinByRemovingOneChar ( string )\n    if idx == - 1 :\n        print ( \"Not possible\" )\n    elif idx == - 2 :\n        print ( \"Possible without removig any character\" )\n    else :\n        print ( \"Possible by removing character at index\" , idx )\n", "python_code_tokenized": "def isPalindrome ( string : str , low : int , high : int ) -> bool : NEW_LINE INDENT while low < high : NEW_LINE INDENT if string [ low ] != string [ high ] : NEW_LINE INDENT return False NEW_LINE DEDENT low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def possiblepalinByRemovingOneChar ( string : str ) -> int : NEW_LINE INDENT low = 0 NEW_LINE high = len ( string ) - 1 NEW_LINE while low < high : NEW_LINE INDENT if string [ low ] == string [ high ] : NEW_LINE INDENT low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if isPalindrome ( string , low + 1 , high ) : NEW_LINE INDENT return low NEW_LINE DEDENT if isPalindrome ( string , low , high - 1 ) : NEW_LINE INDENT return high NEW_LINE DEDENT return - 1 NEW_LINE DEDENT DEDENT return - 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abecbea \" NEW_LINE idx = possiblepalinByRemovingOneChar ( string ) NEW_LINE if idx == - 1 : NEW_LINE INDENT print ( \" Not \u2581 possible \" ) NEW_LINE DEDENT elif idx == - 2 : NEW_LINE INDENT print ( \" Possible \u2581 without \u2581 removig \u2581 any \u2581 character \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Possible \u2581 by \u2581 removing \u2581 character \u2581 at \u2581 index \" , idx ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1471_A", "sol": 0, "python_code": "def shufleArray ( a , n ) :\n    n = n // 2\n    start = n + 1\n    j = n + 1\n    for done in range ( 2 * n - 2 ) :\n        if ( start == j ) :\n            start -= 1\n            j -= 1\n        i = j - n if j > n else j\n        j = 2 * i if j > n else 2 * i - 1\n        a [ start ] , a [ j ] = a [ j ] , a [ start ]\nif __name__ == \"__main__\" :\n    a = [ - 1 , 1 , 3 , 5 , 7 , 2 , 4 , 6 , 8 ]\n    n = len ( a )\n    shufleArray ( a , n )\n    for i in range ( 1 , n ) :\n        print ( a [ i ] , end = \" \" )\n", "python_code_tokenized": "def shufleArray ( a , n ) : NEW_LINE INDENT n = n // 2 NEW_LINE start = n + 1 NEW_LINE j = n + 1 NEW_LINE for done in range ( 2 * n - 2 ) : NEW_LINE INDENT if ( start == j ) : NEW_LINE INDENT start -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT i = j - n if j > n else j NEW_LINE j = 2 * i if j > n else 2 * i - 1 NEW_LINE a [ start ] , a [ j ] = a [ j ] , a [ start ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ - 1 , 1 , 3 , 5 , 7 , 2 , 4 , 6 , 8 ] NEW_LINE n = len ( a ) NEW_LINE shufleArray ( a , n ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1566_B", "sol": 0, "python_code": "t = int ( input ( ) )\nwhile t > 0 :\n    t -= 1\n    s = input ( )\n    stack = [ ]\n    check = 0\n    for i in range ( 0 , len ( s ) ) :\n        if s [ i ] == \"1\" :\n            if stack :\n                if stack [ - 1 ] == '0' :\n                    stack.append ( '1' )\n        if s [ i ] == '0' :\n            if stack :\n                if stack [ - 1 ] == '1' :\n                    check = 2\n            else :\n                stack.append ( '0' )\n    if check == 2 :\n        print ( check )\n    else :\n        if '0' in stack :\n            print ( 1 )\n        else :\n            print ( 0 )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE s = input ( ) NEW_LINE stack = [ ] NEW_LINE check = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == \"1\" : NEW_LINE INDENT if stack : NEW_LINE INDENT if stack [ - 1 ] == '0' : NEW_LINE INDENT stack . append ( '1' ) NEW_LINE DEDENT DEDENT DEDENT if s [ i ] == '0' : NEW_LINE INDENT if stack : NEW_LINE INDENT if stack [ - 1 ] == '1' : NEW_LINE INDENT check = 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT stack . append ( '0' ) NEW_LINE DEDENT DEDENT DEDENT if check == 2 : NEW_LINE INDENT print ( check ) NEW_LINE DEDENT else : NEW_LINE INDENT if '0' in stack : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_3627_A", "sol": 0, "python_code": "def knowPair ( a , b , n , s , m ) :\n    i = 0\n    rem = 0\n    count_b = 0\n    flag = 0\n    while ( i <= a ) :\n        rem = s - ( n * i )\n        count_b = rem // m\n        if ( rem % m == 0 and count_b <= b ) :\n            flag = 1\n        i += 1\n    if ( flag == 1 ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\nif __name__ == '__main__' :\n    A = 1\n    B = 2\n    n = 3\n    S = 4\n    m = 2\n    knowPair ( A , B , n , S , m )\n", "python_code_tokenized": "def knowPair ( a , b , n , s , m ) : NEW_LINE INDENT i = 0 NEW_LINE rem = 0 NEW_LINE count_b = 0 NEW_LINE flag = 0 NEW_LINE while ( i <= a ) : NEW_LINE INDENT rem = s - ( n * i ) NEW_LINE count_b = rem // m NEW_LINE if ( rem % m == 0 and count_b <= b ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 1 NEW_LINE B = 2 NEW_LINE n = 3 NEW_LINE S = 4 NEW_LINE m = 2 NEW_LINE knowPair ( A , B , n , S , m ) NEW_LINE DEDENT"}
{"id": "codeforces_794_A", "sol": 0, "python_code": "import math\nimport os\nimport random\nimport re\nimport sys\nfrom math import gcd\nfrom math import sqrt\nfrom collections import Counter\na , b , c = list ( map ( int , input ( ).split ( ) ) )\nn = int ( input ( ) )\narr = list ( map ( int , input ( ).split ( ) ) )\nli = [ ]\nfor i in arr :\n    if b < i < c :\n        li.append ( i )\nprint ( len ( li ) )\n", "python_code_tokenized": "import math NEW_LINE import os NEW_LINE import random NEW_LINE import re NEW_LINE import sys NEW_LINE from math import gcd NEW_LINE from math import sqrt NEW_LINE from collections import Counter NEW_LINE a , b , c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE li = [ ] NEW_LINE for i in arr : NEW_LINE INDENT if b < i < c : NEW_LINE INDENT li . append ( i ) NEW_LINE DEDENT DEDENT print ( len ( li ) ) NEW_LINE"}
{"id": "codeforces_1008_B", "sol": 0, "python_code": "num_tests = int ( input ( ) )\na , b = map ( int , input ( ).split ( ) )\nanswer = [ ]\nanswer.append ( max ( a , b ) )\nfor i in range ( num_tests - 1 ) :\n    two = list ( map ( int , input ( ).split ( ) ) )\n    if min ( two ) <= answer [ - 1 ] :\n        answer.append ( max ( [ i for i in two if i <= answer [ - 1 ] ] ) )\n    else :\n        print ( 'NO' )\n        break\nif len ( answer ) == num_tests :\n    print ( 'YES' )\n", "python_code_tokenized": "num_tests = int ( input ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE answer = [ ] NEW_LINE answer . append ( max ( a , b ) ) NEW_LINE for i in range ( num_tests - 1 ) : NEW_LINE INDENT two = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if min ( two ) <= answer [ - 1 ] : NEW_LINE INDENT answer . append ( max ( [ i for i in two if i <= answer [ - 1 ] ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE break NEW_LINE DEDENT DEDENT if len ( answer ) == num_tests : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2401_A", "sol": 0, "python_code": "N = 6\nEven = N // 2\nOdd = N - Even\nprint ( Even * Odd )\n", "python_code_tokenized": "N = 6 NEW_LINE Even = N // 2 NEW_LINE Odd = N - Even NEW_LINE print ( Even * Odd ) NEW_LINE"}
{"id": "codeforces_656_A", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nn = int ( input ( ) )\nif n <= 12 :\n    print ( 2 ** n )\nelse :\n    print ( 8092 * 2 ** ( n - 13 ) )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE if n <= 12 : NEW_LINE INDENT print ( 2 ** n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 8092 * 2 ** ( n - 13 ) ) NEW_LINE DEDENT"}
{"id": "codeforces_224_A", "sol": 0, "python_code": "import math\ndata = input ( ).split ( )\nA1 , A2 , A3 = int ( data [ 0 ] ) , int ( data [ 1 ] ) , int ( data [ 2 ] )\nH = int ( math.sqrt ( ( A2 * A3 ) // A1 ) )\nW = A3 // H\nL = A1 // W\nprint ( 4 * L + 4 * W + 4 * H )\n", "python_code_tokenized": "import math NEW_LINE data = input ( ) . split ( ) NEW_LINE A1 , A2 , A3 = int ( data [ 0 ] ) , int ( data [ 1 ] ) , int ( data [ 2 ] ) NEW_LINE H = int ( math . sqrt ( ( A2 * A3 ) // A1 ) ) NEW_LINE W = A3 // H NEW_LINE L = A1 // W NEW_LINE print ( 4 * L + 4 * W + 4 * H ) NEW_LINE"}
{"id": "geeksforgeeks_2333_A", "sol": 0, "python_code": "MAX = 200006\nCONS = 32766\ndef calc ( a , b , lr , q , n ) :\n    cc = 0\n    for i in range ( n - 1 ) :\n        a [ i + 1 ] += a [ i ]\n        b [ i + 1 ] += b [ i ]\n    while ( q > 0 ) :\n        l = lr [ cc ]\n        cc += 1\n        r = lr [ cc ]\n        cc += 1\n        l -= 2\n        r -= 1\n        suma = a [ r ]\n        sumb = b [ r ]\n        if ( l >= 0 ) :\n            suma -= a [ l ]\n            sumb -= b [ l ]\n        M = max ( CONS * suma + CONS * sumb , - CONS * suma - CONS * sumb )\n        M = max ( M , max ( CONS * suma - CONS * sumb , - CONS * suma + CONS * sumb ) )\n        m = min ( CONS * suma + CONS * sumb , - CONS * suma - CONS * sumb )\n        m = min ( m , min ( CONS * suma - CONS * sumb , - CONS * suma + CONS * sumb ) )\n        print ( M - m )\n        q -= 1\nif __name__ == \"__main__\" :\n    n = 5\n    q = 2\n    a = [ 0 , 7 , 3 , 4 , 5 ]\n    b = [ 0 , 3 , 1 , 2 , 3 ]\n    lr = [ 0 ] * ( q * 2 )\n    lr [ 0 ] = 1\n    lr [ 1 ] = 1\n    lr [ 2 ] = 1\n    lr [ 3 ] = 3\n    calc ( a , b , lr , q , n )\n", "python_code_tokenized": "MAX = 200006 NEW_LINE CONS = 32766 NEW_LINE def calc ( a , b , lr , q , n ) : NEW_LINE INDENT cc = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a [ i + 1 ] += a [ i ] NEW_LINE b [ i + 1 ] += b [ i ] NEW_LINE DEDENT while ( q > 0 ) : NEW_LINE INDENT l = lr [ cc ] NEW_LINE cc += 1 NEW_LINE r = lr [ cc ] NEW_LINE cc += 1 NEW_LINE l -= 2 NEW_LINE r -= 1 NEW_LINE suma = a [ r ] NEW_LINE sumb = b [ r ] NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT suma -= a [ l ] NEW_LINE sumb -= b [ l ] NEW_LINE DEDENT M = max ( CONS * suma + CONS * sumb , - CONS * suma - CONS * sumb ) NEW_LINE M = max ( M , max ( CONS * suma - CONS * sumb , - CONS * suma + CONS * sumb ) ) NEW_LINE m = min ( CONS * suma + CONS * sumb , - CONS * suma - CONS * sumb ) NEW_LINE m = min ( m , min ( CONS * suma - CONS * sumb , - CONS * suma + CONS * sumb ) ) NEW_LINE print ( M - m ) NEW_LINE q -= 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE q = 2 NEW_LINE a = [ 0 , 7 , 3 , 4 , 5 ] NEW_LINE b = [ 0 , 3 , 1 , 2 , 3 ] NEW_LINE lr = [ 0 ] * ( q * 2 ) NEW_LINE lr [ 0 ] = 1 NEW_LINE lr [ 1 ] = 1 NEW_LINE lr [ 2 ] = 1 NEW_LINE lr [ 3 ] = 3 NEW_LINE calc ( a , b , lr , q , n ) NEW_LINE DEDENT"}
{"id": "aizu_p02205_A", "sol": 0, "python_code": "N = int ( input ( ) )\nA , B = map ( int , input ( ).split ( ) )\nN %= 12\nfor i in range ( 1 , N + 1 ) :\n    if i % 2 == 1 :\n        A = A - B\n    else :\n        B = A + B\nprint ( A , B )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE A , B = map ( int , input ( ) . split ( ) ) NEW_LINE N %= 12 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT A = A - B NEW_LINE DEDENT else : NEW_LINE INDENT B = A + B NEW_LINE DEDENT DEDENT print ( A , B ) NEW_LINE"}
{"id": "codeforces_1692_B", "sol": 0, "python_code": "n_test_cases = int ( input ( ) )\nr = [ ]\nfor _ in range ( n_test_cases ) :\n    n = int ( input ( ) )\n    arr = [ int ( a ) for a in input ( ).split ( ) ]\n    d = { }\n    for a in arr :\n        if a in d :\n            d [ a ] += 1\n        else :\n            d [ a ] = 1\n    s = 0\n    for k , v in d.items ( ) :\n        if v > 1 :\n            s += v - 1\n    if s % 2 == 1 :\n        s += 1\n    r.append ( str ( n - s ) )\nprint ( '\\n'.join ( r ) )\n", "python_code_tokenized": "n_test_cases = int ( input ( ) ) NEW_LINE r = [ ] NEW_LINE for _ in range ( n_test_cases ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE d = { } NEW_LINE for a in arr : NEW_LINE INDENT if a in d : NEW_LINE INDENT d [ a ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ a ] = 1 NEW_LINE DEDENT DEDENT s = 0 NEW_LINE for k , v in d . items ( ) : NEW_LINE INDENT if v > 1 : NEW_LINE INDENT s += v - 1 NEW_LINE DEDENT DEDENT if s % 2 == 1 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT r . append ( str ( n - s ) ) NEW_LINE DEDENT print ( ' \\n ' . join ( r ) ) NEW_LINE"}
{"id": "geeksforgeeks_4064_A", "sol": 0, "python_code": "def fnMod ( n ) :\n    rem = n % 4\n    if ( rem == 0 or rem == 3 ) :\n        return 0\n    elif ( rem == 1 or rem == 2 ) :\n        return 1\nif __name__ == \"__main__\" :\n    n = 6\n    print ( fnMod ( n ) )\n", "python_code_tokenized": "def fnMod ( n ) : NEW_LINE INDENT rem = n % 4 NEW_LINE if ( rem == 0 or rem == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( rem == 1 or rem == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE print ( fnMod ( n ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC100_A", "sol": 0, "python_code": "import sys\na , b = map ( int , sys.stdin.readline ( ).split ( ) )\nif a <= 8 and b <= 8 :\n    print ( 'Yay!' )\nelse :\n    print ( \":(\" )\n", "python_code_tokenized": "import sys NEW_LINE a , b = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE if a <= 8 and b <= 8 : NEW_LINE INDENT print ( ' Yay ! ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" : ( \" ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC096_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\nif a <= b :\n    print ( a )\nelse :\n    print ( a - 1 )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a <= b : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a - 1 ) NEW_LINE DEDENT"}
{"id": "codeforces_81_A", "sol": 0, "python_code": "s = input ( )\nt = [ s [ 0 ] ]\nfor i in range ( 1 , len ( s ) ) :\n    if t and s [ i ] == t [ - 1 ] :\n        t.pop ( )\n    else :\n        t.append ( s [ i ] )\nprint ( * t , sep = '' )\n", "python_code_tokenized": "s = input ( ) NEW_LINE t = [ s [ 0 ] ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if t and s [ i ] == t [ - 1 ] : NEW_LINE INDENT t . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT t . append ( s [ i ] ) NEW_LINE DEDENT DEDENT print ( * t , sep = ' ' ) NEW_LINE"}
{"id": "leetcode_819_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def mostCommonWord ( self , paragraph , banned ) :\n        banned = set ( banned )\n        count = collections.Counter ( word for word in re.split ( '[ !?\\' , ;.] ' , paragraph.lower ( ) ) if word )\n        return max ( ( item for item in count.items ( ) if item [ 0 ] not in banned ) , key = operator.itemgetter ( 1 ) ) [ 0 ]\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def mostCommonWord ( self , paragraph , banned ) : NEW_LINE INDENT banned = set ( banned ) NEW_LINE count = collections . Counter ( word for word in re . split ( ' [ \u2581 ! ? \\ ' , ; . ] ' , paragraph . lower ( ) ) if word ) NEW_LINE return max ( ( item for item in count . items ( ) if item [ 0 ] not in banned ) , key = operator . itemgetter ( 1 ) ) [ 0 ] NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00265_A", "sol": 0, "python_code": "N , Q = list ( map ( int , input ( ).split ( ) ) )\nC = list ( map ( int , input ( ).split ( ) ) )\nM = max ( C ) + 1\nt1 = [ 0 ] * ( M )\nfor v in C :\n    t1 [ v ] = 1\nt2 = [ 0 ] * ( M )\nv = 0\nfor i in range ( M ) :\n    if t1 [ i ] :\n        v = i\n    t2 [ i ] = v\nfor i in range ( Q ) :\n    t = int ( input ( ) )\n    n_v = M - 1\n    m = 0\n    while n_v != 0 :\n        amr = n_v % t\n        m = max ( m , amr )\n        tmp = n_v - m - 1\n        if tmp <= 0 : break\n        n_v = t2 [ tmp ]\n    print ( m )\n", "python_code_tokenized": "N , Q = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE M = max ( C ) + 1 NEW_LINE t1 = [ 0 ] * ( M ) NEW_LINE for v in C : NEW_LINE INDENT t1 [ v ] = 1 NEW_LINE DEDENT t2 = [ 0 ] * ( M ) NEW_LINE v = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if t1 [ i ] : NEW_LINE INDENT v = i NEW_LINE DEDENT t2 [ i ] = v NEW_LINE DEDENT for i in range ( Q ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE n_v = M - 1 NEW_LINE m = 0 NEW_LINE while n_v != 0 : NEW_LINE INDENT amr = n_v % t NEW_LINE m = max ( m , amr ) NEW_LINE tmp = n_v - m - 1 NEW_LINE if tmp <= 0 : break NEW_LINE n_v = t2 [ tmp ] NEW_LINE DEDENT print ( m ) NEW_LINE DEDENT"}
{"id": "codeforces_779_A", "sol": 0, "python_code": "def _input ( ) : return map ( int , input ( ).split ( ) )\nn = int ( input ( ) )\nA = list ( _input ( ) )\nB = list ( _input ( ) )\na = [ A.count ( i + 1 ) for i in range ( 5 ) ]\nb = [ B.count ( i + 1 ) for i in range ( 5 ) ]\nr1 = r2 = 0\nfor i in range ( 5 ) :\n    if ( a [ i ] + b [ i ] ) % 2 != 0 : print ( - 1 ) ; exit ( )\n    r1 += abs ( a [ i ] - ( a [ i ] + b [ i ] ) // 2 )\n    r2 += abs ( b [ i ] - ( a [ i ] + b [ i ] ) // 2 )\nprint ( r1 // 2 if r1 == r2 else - 1 )\n", "python_code_tokenized": "def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE A = list ( _input ( ) ) NEW_LINE B = list ( _input ( ) ) NEW_LINE a = [ A . count ( i + 1 ) for i in range ( 5 ) ] NEW_LINE b = [ B . count ( i + 1 ) for i in range ( 5 ) ] NEW_LINE r1 = r2 = 0 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT if ( a [ i ] + b [ i ] ) % 2 != 0 : print ( - 1 ) ; exit ( ) NEW_LINE r1 += abs ( a [ i ] - ( a [ i ] + b [ i ] ) // 2 ) NEW_LINE r2 += abs ( b [ i ] - ( a [ i ] + b [ i ] ) // 2 ) NEW_LINE DEDENT print ( r1 // 2 if r1 == r2 else - 1 ) NEW_LINE"}
{"id": "atcoder_ABC097_B", "sol": 0, "python_code": "def main ( ) :\n    X = int ( input ( ) )\n    if X == 1 or X == 2 or X == 3 :\n        print ( 1 )\n    else :\n        li = [ ]\n        for p in range ( 2 , 10 ) :\n            for n in range ( 2 , 100 ) :\n                if n ** p <= X :\n                    li.append ( n ** p )\n                else :\n                    break\n        li.sort ( reverse = True )\n        print ( li [ 0 ] )\nif __name__ == \"__main__\" :\n    main ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT X = int ( input ( ) ) NEW_LINE if X == 1 or X == 2 or X == 3 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT li = [ ] NEW_LINE for p in range ( 2 , 10 ) : NEW_LINE INDENT for n in range ( 2 , 100 ) : NEW_LINE INDENT if n ** p <= X : NEW_LINE INDENT li . append ( n ** p ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT li . sort ( reverse = True ) NEW_LINE print ( li [ 0 ] ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC031_C", "sol": 0, "python_code": "import sys\nN , A , B = map ( int , input ( ).split ( ) )\nBIT = 0\nfor i in range ( N ) :\n    if ( 1 << i ) & A != ( 1 << i ) & B :\n        BIT += 1\nif BIT % 2 == 1 :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n    sys.exit ( )\ncheck = [ 0 ] * ( 1 << N )\nANS = [ ]\ncheck [ A ] = 1\ncheck [ B ] = 1\ndef route ( x , i , j ) :\n    NOW = x\n    ANS.append ( NOW )\n    check [ NOW ] = 1\n    for k in range ( 1 << j ) :\n        for l in range ( N ) :\n            if check [ NOW ^ ( 1 << l ) ] == 0 and l != i :\n                NOW = NOW ^ ( 1 << l )\n                check [ NOW ] = 1\n                ANS.append ( NOW )\n                break\n    return NOW ^ ( 1 << i )\ncheckbit = [ 0 ] * N\nfor i in range ( N - 1 , - 1 , - 1 ) :\n    for j in range ( N ) :\n        if ( 1 << j ) & A != ( 1 << j ) & B and checkbit [ j ] == 0 :\n            break\n    A = route ( A , j , i )\n    checkbit [ j ] = 1\nANS.append ( B )\nprint ( * ANS )\n", "python_code_tokenized": "import sys NEW_LINE N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE BIT = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( 1 << i ) & A != ( 1 << i ) & B : NEW_LINE INDENT BIT += 1 NEW_LINE DEDENT DEDENT if BIT % 2 == 1 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT check = [ 0 ] * ( 1 << N ) NEW_LINE ANS = [ ] NEW_LINE check [ A ] = 1 NEW_LINE check [ B ] = 1 NEW_LINE def route ( x , i , j ) : NEW_LINE INDENT NOW = x NEW_LINE ANS . append ( NOW ) NEW_LINE check [ NOW ] = 1 NEW_LINE for k in range ( 1 << j ) : NEW_LINE INDENT for l in range ( N ) : NEW_LINE INDENT if check [ NOW ^ ( 1 << l ) ] == 0 and l != i : NEW_LINE INDENT NOW = NOW ^ ( 1 << l ) NEW_LINE check [ NOW ] = 1 NEW_LINE ANS . append ( NOW ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return NOW ^ ( 1 << i ) NEW_LINE DEDENT checkbit = [ 0 ] * N NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( 1 << j ) & A != ( 1 << j ) & B and checkbit [ j ] == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT A = route ( A , j , i ) NEW_LINE checkbit [ j ] = 1 NEW_LINE DEDENT ANS . append ( B ) NEW_LINE print ( * ANS ) NEW_LINE"}
{"id": "codeforces_723_A", "sol": 0, "python_code": "n = input ( ).split ( )\nn [ 0 ] = int ( n [ 0 ] )\nn [ 1 ] = int ( n [ 1 ] )\nn [ 2 ] = int ( n [ 2 ] )\nn.sort ( )\nprint ( ( n [ 1 ] - n [ 0 ] ) + ( n [ 2 ] - n [ 1 ] ) )\n", "python_code_tokenized": "n = input ( ) . split ( ) NEW_LINE n [ 0 ] = int ( n [ 0 ] ) NEW_LINE n [ 1 ] = int ( n [ 1 ] ) NEW_LINE n [ 2 ] = int ( n [ 2 ] ) NEW_LINE n . sort ( ) NEW_LINE print ( ( n [ 1 ] - n [ 0 ] ) + ( n [ 2 ] - n [ 1 ] ) ) NEW_LINE"}
{"id": "codeforces_1320_A", "sol": 0, "python_code": "n = int ( input ( ) )\nb = list ( map ( int , input ( ).split ( ) ) )\nd = { }\nfor i in range ( n ) :\n    if i - b [ i ] in d :\n        d [ i - b [ i ] ].append ( i )\n    else :\n        d [ i - b [ i ] ] = [ i ]\nmx = 0\nfor x in d :\n    r = 0\n    for m in d [ x ] :\n        r += b [ m ]\n    mx = max ( mx , r )\nprint ( mx )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i - b [ i ] in d : NEW_LINE INDENT d [ i - b [ i ] ] . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT d [ i - b [ i ] ] = [ i ] NEW_LINE DEDENT DEDENT mx = 0 NEW_LINE for x in d : NEW_LINE INDENT r = 0 NEW_LINE for m in d [ x ] : NEW_LINE INDENT r += b [ m ] NEW_LINE DEDENT mx = max ( mx , r ) NEW_LINE DEDENT print ( mx ) NEW_LINE"}
{"id": "geeksforgeeks_1833_A", "sol": 0, "python_code": "def findNthTerm ( n ) :\n    if n % 2 == 0 :\n        n //= 2\n        print ( 3 ** ( n - 1 ) )\n    else :\n        n = ( n // 2 ) + 1\n        print ( 2 ** ( n - 1 ) )\nif __name__ == '__main__' :\n    N = 4\n    findNthTerm ( N )\n    N = 11\n    findNthTerm ( N )\n", "python_code_tokenized": "def findNthTerm ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT n //= 2 NEW_LINE print ( 3 ** ( n - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n = ( n // 2 ) + 1 NEW_LINE print ( 2 ** ( n - 1 ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE findNthTerm ( N ) NEW_LINE N = 11 NEW_LINE findNthTerm ( N ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4082_A", "sol": 0, "python_code": "from math import *\ndef numberOfSolutions ( n ) :\n    c = 0\n    while ( n ) :\n        c += n % 2\n        n //= 2\n    return int ( pow ( 2 , c ) )\nif __name__ == \"__main__\" :\n    n = 3\n    print ( numberOfSolutions ( n ) )\n", "python_code_tokenized": "from math import * NEW_LINE def numberOfSolutions ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n ) : NEW_LINE INDENT c += n % 2 NEW_LINE n //= 2 NEW_LINE DEDENT return int ( pow ( 2 , c ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( numberOfSolutions ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_367_A", "sol": 0, "python_code": "def maxProfit ( price , n , k ) :\n    profit = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ]\n    for i in range ( 1 , k + 1 ) :\n        prevDiff = float ( '-inf' )\n        for j in range ( 1 , n ) :\n            prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] )\n            profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff )\n    return profit [ k ] [ n - 1 ]\nif __name__ == \"__main__\" :\n    k = 3\n    price = [ 12 , 14 , 17 , 10 , 14 , 13 , 12 , 15 ]\n    n = len ( price )\n    print ( \"Maximum profit is:\" , maxProfit ( price , n , k ) )\n", "python_code_tokenized": "def maxProfit ( price , n , k ) : NEW_LINE INDENT profit = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT prevDiff = float ( ' - inf ' ) NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) NEW_LINE profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) NEW_LINE DEDENT DEDENT return profit [ k ] [ n - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 3 NEW_LINE price = [ 12 , 14 , 17 , 10 , 14 , 13 , 12 , 15 ] NEW_LINE n = len ( price ) NEW_LINE print ( \" Maximum \u2581 profit \u2581 is : \" , maxProfit ( price , n , k ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1688_A", "sol": 0, "python_code": "x = int ( input ( ) )\nfor jj in range ( x ) :\n    n = int ( input ( ) )\n    if n == 1 : print ( 3 )\n    else :\n        if n % 2 == 1 :\n            print ( 1 )\n        else :\n            p = 0\n            k = n\n            while n % 2 == 0 :\n                p += 1\n                n //= 2\n            t = 2 ** p\n            if t == k :\n                print ( t + 1 )\n            else :\n                print ( t )\n", "python_code_tokenized": "x = int ( input ( ) ) NEW_LINE for jj in range ( x ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 1 : print ( 3 ) NEW_LINE else : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT p = 0 NEW_LINE k = n NEW_LINE while n % 2 == 0 : NEW_LINE INDENT p += 1 NEW_LINE n //= 2 NEW_LINE DEDENT t = 2 ** p NEW_LINE if t == k : NEW_LINE INDENT print ( t + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_4712_A", "sol": 0, "python_code": "def calcDeterminant ( arr , n ) :\n    determinant = 0\n    for i in range ( n ) :\n        determinant += pow ( arr [ i ] , 3 )\n    determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ]\n    return determinant\narr = [ 4 , 5 , 3 ]\nn = len ( arr )\nprint ( calcDeterminant ( arr , n ) )\n", "python_code_tokenized": "def calcDeterminant ( arr , n ) : NEW_LINE INDENT determinant = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT determinant += pow ( arr [ i ] , 3 ) NEW_LINE DEDENT determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ] NEW_LINE return determinant NEW_LINE DEDENT arr = [ 4 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( calcDeterminant ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1819_A", "sol": 0, "python_code": "def even_or_odd ( N ) :\n    l = len ( N ) ;\n    if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' ) :\n        return ( \"Even\" )\n    else :\n        return ( \"Odd\" )\nN = \"735\"\nprint ( even_or_odd ( N ) )\n", "python_code_tokenized": "def even_or_odd ( N ) : NEW_LINE INDENT l = len ( N ) ; NEW_LINE if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' ) : NEW_LINE INDENT return ( \" Even \" ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( \" Odd \" ) NEW_LINE DEDENT DEDENT N = \"735\" NEW_LINE print ( even_or_odd ( N ) ) NEW_LINE"}
{"id": "codeforces_1730_B", "sol": 0, "python_code": "from math import fabs\nt = int ( input ( ) )\nfor i in range ( t ) :\n    n = int ( input ( ) )\n    line1 = input ( ).split ( \" \" )\n    line2 = input ( ).split ( \" \" )\n    intline = [ int ( x ) for x in line1 ]\n    intline2 = [ int ( x ) for x in line2 ]\n    x0 = intline [ 0 ]\n    s0 = intline2 [ 0 ]\n    for j in range ( 1 , len ( intline ) ) :\n        x1 = intline [ j ]\n        s1 = intline2 [ j ]\n        if x0 > x1 :\n            x0 , x1 = x1 , x0\n            s0 , s1 = s1 , s0\n        if ( x1 - x0 ) <= fabs ( s1 - s0 ) :\n            if s1 > s0 :\n                x0 = x1\n                s0 = s1\n            else :\n                pass\n        else :\n            x0 = ( x1 + x0 + ( s1 - s0 ) ) / 2\n            s0 = s1 + ( x1 - x0 )\n    if x0 % 1 == 0.0 :\n        print ( int ( x0 ) )\n    else :\n        print ( x0 )\n", "python_code_tokenized": "from math import fabs NEW_LINE t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE line1 = input ( ) . split ( \" \u2581 \" ) NEW_LINE line2 = input ( ) . split ( \" \u2581 \" ) NEW_LINE intline = [ int ( x ) for x in line1 ] NEW_LINE intline2 = [ int ( x ) for x in line2 ] NEW_LINE x0 = intline [ 0 ] NEW_LINE s0 = intline2 [ 0 ] NEW_LINE for j in range ( 1 , len ( intline ) ) : NEW_LINE INDENT x1 = intline [ j ] NEW_LINE s1 = intline2 [ j ] NEW_LINE if x0 > x1 : NEW_LINE INDENT x0 , x1 = x1 , x0 NEW_LINE s0 , s1 = s1 , s0 NEW_LINE DEDENT if ( x1 - x0 ) <= fabs ( s1 - s0 ) : NEW_LINE INDENT if s1 > s0 : NEW_LINE INDENT x0 = x1 NEW_LINE s0 = s1 NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT x0 = ( x1 + x0 + ( s1 - s0 ) ) / 2 NEW_LINE s0 = s1 + ( x1 - x0 ) NEW_LINE DEDENT DEDENT if x0 % 1 == 0.0 : NEW_LINE INDENT print ( int ( x0 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x0 ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4632_A", "sol": 0, "python_code": "def fibWord ( n ) :\n    Sn_1 = \"0\"\n    Sn = \"01\"\n    tmp = \"\"\n    for i in range ( 2 , n + 1 ) :\n        tmp = Sn\n        Sn += Sn_1\n        Sn_1 = tmp\n    return Sn\nn = 6\nprint ( fibWord ( n ) )\n", "python_code_tokenized": "def fibWord ( n ) : NEW_LINE INDENT Sn_1 = \"0\" NEW_LINE Sn = \"01\" NEW_LINE tmp = \" \" NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT tmp = Sn NEW_LINE Sn += Sn_1 NEW_LINE Sn_1 = tmp NEW_LINE DEDENT return Sn NEW_LINE DEDENT n = 6 NEW_LINE print ( fibWord ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3444_A", "sol": 0, "python_code": "import math\ndef isprime ( n ) :\n    i = 2\n    for i in range ( 2 , int ( ( math.sqrt ( n ) + 1 ) ) ) :\n        if n % i == 0 :\n            return False\n    return True\ndef LegendreConjecture ( n ) :\n    print ( \"Primes in the range \" , n * n , \" and \" , ( n + 1 ) * ( n + 1 ) , \" are:\" )\n    for i in range ( n * n , ( ( ( n + 1 ) * ( n + 1 ) ) + 1 ) ) :\n        if ( isprime ( i ) ) :\n            print ( i )\nn = 50\nLegendreConjecture ( n )\n", "python_code_tokenized": "import math NEW_LINE def isprime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE for i in range ( 2 , int ( ( math . sqrt ( n ) + 1 ) ) ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def LegendreConjecture ( n ) : NEW_LINE INDENT print ( \" Primes \u2581 in \u2581 the \u2581 range \u2581 \" , n * n , \" \u2581 and \u2581 \" , ( n + 1 ) * ( n + 1 ) , \" \u2581 are : \" ) NEW_LINE for i in range ( n * n , ( ( ( n + 1 ) * ( n + 1 ) ) + 1 ) ) : NEW_LINE INDENT if ( isprime ( i ) ) : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT DEDENT n = 50 NEW_LINE LegendreConjecture ( n ) NEW_LINE"}
{"id": "codeforces_835_A", "sol": 0, "python_code": "a , b , c , d , e = map ( int , input ( ).split ( ) )\nif a * b + 2 * d < a * c + 2 * e :\n    print ( \"First\" )\nelse :\n    if a * b + 2 * d != a * c + 2 * e :\n        print ( \"Second\" )\n    else :\n        print ( \"Friendship\" )\n", "python_code_tokenized": "a , b , c , d , e = map ( int , input ( ) . split ( ) ) NEW_LINE if a * b + 2 * d < a * c + 2 * e : NEW_LINE INDENT print ( \" First \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if a * b + 2 * d != a * c + 2 * e : NEW_LINE INDENT print ( \" Second \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Friendship \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1007_A", "sol": 0, "python_code": "def findMissing ( a , b , n , m ) :\n    s = dict ( )\n    for i in range ( m ) :\n        s [ b [ i ] ] = 1\n    for i in range ( n ) :\n        if a [ i ] not in s.keys ( ) :\n            print ( a [ i ] , end = \" \" )\na = [ 1 , 2 , 6 , 3 , 4 , 5 ]\nb = [ 2 , 4 , 3 , 1 , 0 ]\nn = len ( a )\nm = len ( b )\nfindMissing ( a , b , n , m )\n", "python_code_tokenized": "def findMissing ( a , b , n , m ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT s [ b [ i ] ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in s . keys ( ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT a = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEW_LINE b = [ 2 , 4 , 3 , 1 , 0 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE findMissing ( a , b , n , m ) NEW_LINE"}
{"id": "codeforces_651_A", "sol": 0, "python_code": "a1 , a2 = map ( int , input ( ).split ( ) )\nt = 0\nif a1 == 1 and a2 == 1 :\n    print ( 0 )\nelse :\n    while a1 > 0 and a2 > 0 :\n        if a1 > a2 :\n            a2 += 1\n            a1 -= 2\n        else :\n            a2 -= 2\n            a1 += 1\n        t += 1\n    print ( t )\n", "python_code_tokenized": "a1 , a2 = map ( int , input ( ) . split ( ) ) NEW_LINE t = 0 NEW_LINE if a1 == 1 and a2 == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT while a1 > 0 and a2 > 0 : NEW_LINE INDENT if a1 > a2 : NEW_LINE INDENT a2 += 1 NEW_LINE a1 -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT a2 -= 2 NEW_LINE a1 += 1 NEW_LINE DEDENT t += 1 NEW_LINE DEDENT print ( t ) NEW_LINE DEDENT"}
{"id": "codeforces_298_A", "sol": 0, "python_code": "n = int ( input ( ) )\npath = input ( )\nif 'L' in path and 'R' in path :\n    left = path.find ( 'R' ) + 1\n    right = path.find ( 'L' ) + 1\nelif 'L' in path :\n    left = path.rfind ( 'L' ) + 1\n    right = 1 if path.find ( 'L' ) == 0 else path.find ( 'L' )\nelse :\n    left = path.find ( 'R' ) + 1\n    right = n if path.rfind ( 'R' ) + 1 == n else path.rfind ( 'R' ) + 2\nprint ( left , right )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE path = input ( ) NEW_LINE if ' L ' in path and ' R ' in path : NEW_LINE INDENT left = path . find ( ' R ' ) + 1 NEW_LINE right = path . find ( ' L ' ) + 1 NEW_LINE DEDENT elif ' L ' in path : NEW_LINE INDENT left = path . rfind ( ' L ' ) + 1 NEW_LINE right = 1 if path . find ( ' L ' ) == 0 else path . find ( ' L ' ) NEW_LINE DEDENT else : NEW_LINE INDENT left = path . find ( ' R ' ) + 1 NEW_LINE right = n if path . rfind ( ' R ' ) + 1 == n else path . rfind ( ' R ' ) + 2 NEW_LINE DEDENT print ( left , right ) NEW_LINE"}
{"id": "codeforces_1304_B", "sol": 0, "python_code": "s = input ( ).split ( ' ' )\nn = int ( s [ 0 ] )\nm1 = int ( s [ 1 ] ) - 1\nm = m1\nl = [ ]\ns = \"\"\ndef f ( str1 ) :\n    i1 = m + 1\n    i2 = m\n    while i1 != 0 and i1 != 1 :\n        if str1 [ i2 ] != str1 [ m - i2 ] :\n            return False\n        else :\n            i2 -= 1\n            i1 -= 2\n    return True\nfor i in range ( n ) :\n    obj = input ( )\n    if f ( obj ) :\n        s = obj\n    else :\n        l.append ( obj )\nwhile len ( l ) != 0 :\n    for obj1 in l :\n        l.remove ( obj1 )\n        s1 = obj1 [ 0 ]\n        for obj2 in l :\n            m = m1\n            s2 = obj2 [ m ]\n            if s1 == s2 :\n                r = obj1 + obj2\n                m = len ( r ) - 1\n                if f ( r ) :\n                    s = obj1 + s + obj2\n                    l.remove ( obj2 )\nprint ( len ( s ) )\nprint ( s )\n", "python_code_tokenized": "s = input ( ) . split ( ' \u2581 ' ) NEW_LINE n = int ( s [ 0 ] ) NEW_LINE m1 = int ( s [ 1 ] ) - 1 NEW_LINE m = m1 NEW_LINE l = [ ] NEW_LINE s = \" \" NEW_LINE def f ( str1 ) : NEW_LINE INDENT i1 = m + 1 NEW_LINE i2 = m NEW_LINE while i1 != 0 and i1 != 1 : NEW_LINE INDENT if str1 [ i2 ] != str1 [ m - i2 ] : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT i2 -= 1 NEW_LINE i1 -= 2 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT obj = input ( ) NEW_LINE if f ( obj ) : NEW_LINE INDENT s = obj NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( obj ) NEW_LINE DEDENT DEDENT while len ( l ) != 0 : NEW_LINE INDENT for obj1 in l : NEW_LINE INDENT l . remove ( obj1 ) NEW_LINE s1 = obj1 [ 0 ] NEW_LINE for obj2 in l : NEW_LINE INDENT m = m1 NEW_LINE s2 = obj2 [ m ] NEW_LINE if s1 == s2 : NEW_LINE INDENT r = obj1 + obj2 NEW_LINE m = len ( r ) - 1 NEW_LINE if f ( r ) : NEW_LINE INDENT s = obj1 + s + obj2 NEW_LINE l . remove ( obj2 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( len ( s ) ) NEW_LINE print ( s ) NEW_LINE"}
{"id": "geeksforgeeks_2760_A", "sol": 0, "python_code": "def stringLen ( str ) :\n    m = dict ( )\n    m [ 0 ] = - 1\n    count_0 = 0\n    count_1 = 0\n    res = 0\n    for i in range ( len ( str ) ) :\n        if str [ i ] == '0' :\n            count_0 += 1\n        else :\n            count_1 += 1\n        if m.get ( count_1 - count_0 ) :\n            res = max ( res , i - m [ count_1 - count_0 ] )\n        else :\n            m [ count_1 - count_0 ] = i\n    return res\nstr = \"101001000\"\nprint ( \"Length of longest balanced\" \" sub string = \" , stringLen ( str ) )\n", "python_code_tokenized": "def stringLen ( str ) : NEW_LINE INDENT m = dict ( ) NEW_LINE m [ 0 ] = - 1 NEW_LINE count_0 = 0 NEW_LINE count_1 = 0 NEW_LINE res = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT count_0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT if m . get ( count_1 - count_0 ) : NEW_LINE INDENT res = max ( res , i - m [ count_1 - count_0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT m [ count_1 - count_0 ] = i NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT str = \"101001000\" NEW_LINE print ( \" Length \u2581 of \u2581 longest \u2581 balanced \" \" \u2581 sub \u2581 string \u2581 = \u2581 \" , stringLen ( str ) ) NEW_LINE"}
{"id": "codeforces_976_A", "sol": 0, "python_code": "n = input ( ) ; x = input ( )\nif set ( x ) != { '0' } : print ( '1' + ( x.count ( '0' ) * '0' ) )\nelse : print ( '0' )\n", "python_code_tokenized": "n = input ( ) ; x = input ( ) NEW_LINE if set ( x ) != { '0' } : print ( '1' + ( x . count ( '0' ) * '0' ) ) NEW_LINE else : print ( '0' ) NEW_LINE"}
{"id": "aizu_p02523_A", "sol": 0, "python_code": "import math\ndef distance ( p1x : float , p1y : float , p2x : float , p2y : float ) -> float :\n    x_distance_square = math.pow ( p2x - p1x , 2 )\n    y_distance_square = math.pow ( p2y - p1y , 2 )\n    distance_between_2points = math.sqrt ( x_distance_square + y_distance_square )\n    return distance_between_2points\nif __name__ == '__main__' :\n    x1 , y1 , x2 , y2 = map ( float , input ( ).split ( ) )\n    distance_1to2 = distance ( x1 , y1 , x2 , y2 )\n    print ( distance_1to2 )\n", "python_code_tokenized": "import math NEW_LINE def distance ( p1x : float , p1y : float , p2x : float , p2y : float ) -> float : NEW_LINE INDENT x_distance_square = math . pow ( p2x - p1x , 2 ) NEW_LINE y_distance_square = math . pow ( p2y - p1y , 2 ) NEW_LINE distance_between_2points = math . sqrt ( x_distance_square + y_distance_square ) NEW_LINE return distance_between_2points NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) NEW_LINE distance_1to2 = distance ( x1 , y1 , x2 , y2 ) NEW_LINE print ( distance_1to2 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3662_A", "sol": 0, "python_code": "def minRadius ( k , x , y , n ) :\n    dis = [ 0 ] * n\n    for i in range ( 0 , n ) :\n        dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ]\n    dis.sort ( )\n    return dis [ k - 1 ]\nk = 3\nx = [ 1 , - 1 , 1 ]\ny = [ 1 , - 1 , - 1 ]\nn = len ( x )\nprint ( minRadius ( k , x , y , n ) )\n", "python_code_tokenized": "def minRadius ( k , x , y , n ) : NEW_LINE INDENT dis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] NEW_LINE DEDENT dis . sort ( ) NEW_LINE return dis [ k - 1 ] NEW_LINE DEDENT k = 3 NEW_LINE x = [ 1 , - 1 , 1 ] NEW_LINE y = [ 1 , - 1 , - 1 ] NEW_LINE n = len ( x ) NEW_LINE print ( minRadius ( k , x , y , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1556_A", "sol": 0, "python_code": "def mergeIntervals ( arr ) :\n    arr.sort ( key = lambda x : x [ 0 ] )\n    m = [ ]\n    s = - 10000\n    max = - 100000\n    for i in range ( len ( arr ) ) :\n        a = arr [ i ]\n        if a [ 0 ] > max :\n            if i != 0 :\n                m.append ( [ s , max ] )\n            max = a [ 1 ]\n            s = a [ 0 ]\n        else :\n            if a [ 1 ] >= max :\n                max = a [ 1 ]\n    if max != - 100000 and [ s , max ] not in m :\n        m.append ( [ s , max ] )\n    print ( \"The Merged Intervals are :\" , end = \" \" )\n    for i in range ( len ( m ) ) :\n        print ( m [ i ] , end = \" \" )\narr = [ [ 6 , 8 ] , [ 1 , 9 ] , [ 2 , 4 ] , [ 4 , 7 ] ]\nmergeIntervals ( arr )\n", "python_code_tokenized": "def mergeIntervals ( arr ) : NEW_LINE INDENT arr . sort ( key = lambda x : x [ 0 ] ) NEW_LINE m = [ ] NEW_LINE s = - 10000 NEW_LINE max = - 100000 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT a = arr [ i ] NEW_LINE if a [ 0 ] > max : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT m . append ( [ s , max ] ) NEW_LINE DEDENT max = a [ 1 ] NEW_LINE s = a [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT if a [ 1 ] >= max : NEW_LINE INDENT max = a [ 1 ] NEW_LINE DEDENT DEDENT DEDENT if max != - 100000 and [ s , max ] not in m : NEW_LINE INDENT m . append ( [ s , max ] ) NEW_LINE DEDENT print ( \" The \u2581 Merged \u2581 Intervals \u2581 are \u2581 : \" , end = \" \u2581 \" ) NEW_LINE for i in range ( len ( m ) ) : NEW_LINE INDENT print ( m [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT arr = [ [ 6 , 8 ] , [ 1 , 9 ] , [ 2 , 4 ] , [ 4 , 7 ] ] NEW_LINE mergeIntervals ( arr ) NEW_LINE"}
{"id": "projecteuler_p047_A", "sol": 0, "python_code": "import eulerlib , itertools\ndef compute ( ) :\n    cond = lambda i : all ( ( count_distinct_prime_factors ( i + j ) == 4 ) for j in range ( 4 ) )\n    ans = next ( filter ( cond , itertools.count ( ) ) )\n    return str ( ans )\n@ eulerlib.memoize\ndef count_distinct_prime_factors ( n ) :\n    count = 0\n    while n > 1 :\n        count += 1\n        for i in range ( 2 , eulerlib.sqrt ( n ) + 1 ) :\n            if n % i == 0 :\n                while True :\n                    n //= i\n                    if n % i != 0 :\n                        break\n                break\n        else :\n            break\n    return count\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT cond = lambda i : all ( ( count_distinct_prime_factors ( i + j ) == 4 ) for j in range ( 4 ) ) NEW_LINE ans = next ( filter ( cond , itertools . count ( ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT @ eulerlib . memoize NEW_LINE def count_distinct_prime_factors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 1 : NEW_LINE INDENT count += 1 NEW_LINE for i in range ( 2 , eulerlib . sqrt ( n ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT while True : NEW_LINE INDENT n //= i NEW_LINE if n % i != 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1221_A", "sol": 0, "python_code": "def findHypotenuse ( side1 , side2 ) :\n    h = ( ( ( side1 * side1 ) + ( side2 * side2 ) ) ** ( 1 / 2 ) ) ;\n    return h ;\nside1 = 3 ;\nside2 = 4 ;\nprint ( findHypotenuse ( side1 , side2 ) ) ;\n", "python_code_tokenized": "def findHypotenuse ( side1 , side2 ) : NEW_LINE INDENT h = ( ( ( side1 * side1 ) + ( side2 * side2 ) ) ** ( 1 / 2 ) ) ; NEW_LINE return h ; NEW_LINE DEDENT side1 = 3 ; NEW_LINE side2 = 4 ; NEW_LINE print ( findHypotenuse ( side1 , side2 ) ) ; NEW_LINE"}
{"id": "codeforces_1621_B", "sol": 0, "python_code": "import sys\nfor _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    a = [ ]\n    best_l = 1e17\n    best_r = - 1\n    best_l_cost = 1e17\n    best_r_cost = 1e17\n    for _ in range ( n ) :\n        a.append ( list ( map ( int , input ( ).split ( ) ) ) )\n    o = { }\n    for i in range ( n ) :\n        item = a [ i ]\n        if item [ 0 ] < best_l :\n            best_l = item [ 0 ]\n            best_l_cost = item [ 2 ]\n        if item [ 0 ] == best_l :\n            best_l_cost = min ( best_l_cost , item [ 2 ] )\n        if item [ 1 ] > best_r :\n            best_r = item [ 1 ]\n            best_r_cost = item [ 2 ]\n        if item [ 1 ] == best_r :\n            best_r_cost = min ( best_r_cost , item [ 2 ] )\n        if o.get ( ( item [ 0 ] , item [ 1 ] ) ) :\n            o [ item [ 0 ] , item [ 1 ] ] = min ( o [ item [ 0 ] , item [ 1 ] ] , item [ 2 ] )\n        else :\n            o [ item [ 0 ] , item [ 1 ] ] = item [ 2 ]\n        k = o.get ( ( best_l , best_r ) )\n        if k == None : k = 1e17\n        print ( min ( best_l_cost + best_r_cost , k ) )\n", "python_code_tokenized": "import sys NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE best_l = 1e17 NEW_LINE best_r = - 1 NEW_LINE best_l_cost = 1e17 NEW_LINE best_r_cost = 1e17 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT o = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT item = a [ i ] NEW_LINE if item [ 0 ] < best_l : NEW_LINE INDENT best_l = item [ 0 ] NEW_LINE best_l_cost = item [ 2 ] NEW_LINE DEDENT if item [ 0 ] == best_l : NEW_LINE INDENT best_l_cost = min ( best_l_cost , item [ 2 ] ) NEW_LINE DEDENT if item [ 1 ] > best_r : NEW_LINE INDENT best_r = item [ 1 ] NEW_LINE best_r_cost = item [ 2 ] NEW_LINE DEDENT if item [ 1 ] == best_r : NEW_LINE INDENT best_r_cost = min ( best_r_cost , item [ 2 ] ) NEW_LINE DEDENT if o . get ( ( item [ 0 ] , item [ 1 ] ) ) : NEW_LINE INDENT o [ item [ 0 ] , item [ 1 ] ] = min ( o [ item [ 0 ] , item [ 1 ] ] , item [ 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT o [ item [ 0 ] , item [ 1 ] ] = item [ 2 ] NEW_LINE DEDENT k = o . get ( ( best_l , best_r ) ) NEW_LINE if k == None : k = 1e17 NEW_LINE print ( min ( best_l_cost + best_r_cost , k ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1093_A", "sol": 0, "python_code": "def perfectSquares ( l , r ) :\n    for i in range ( l , r + 1 ) :\n        if ( i ** (.5 ) == int ( i ** (.5 ) ) ) :\n            print ( i , end = \" \" )\nl = 2\nr = 24\nperfectSquares ( l , r )\n", "python_code_tokenized": "def perfectSquares ( l , r ) : NEW_LINE INDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i ** ( .5 ) == int ( i ** ( .5 ) ) ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT l = 2 NEW_LINE r = 24 NEW_LINE perfectSquares ( l , r ) NEW_LINE"}
{"id": "geeksforgeeks_1353_A", "sol": 0, "python_code": "def minIndex ( arr , n , pos ) :\n    num = arr [ pos ]\n    i = pos - 1\n    while ( i >= 0 ) :\n        if ( arr [ i ] != num ) :\n            break\n        i -= 1\n    return i + 1\narr = [ 2 , 1 , 1 , 1 , 5 , 2 ]\nn = len ( arr )\npos = 4\nprint ( minIndex ( arr , n , pos ) )\n", "python_code_tokenized": "def minIndex ( arr , n , pos ) : NEW_LINE INDENT num = arr [ pos ] NEW_LINE i = pos - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( arr [ i ] != num ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return i + 1 NEW_LINE DEDENT arr = [ 2 , 1 , 1 , 1 , 5 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE pos = 4 NEW_LINE print ( minIndex ( arr , n , pos ) ) NEW_LINE"}
{"id": "geeksforgeeks_2223_A", "sol": 0, "python_code": "def countDigits ( a , b ) :\n    count = 0\n    p = abs ( a * b )\n    if ( p == 0 ) :\n        return 1\n    while ( p > 0 ) :\n        count = count + 1\n        p = p // 10\n    return count\na = 33\nb = - 24\nprint ( \"Number of digits = \" , countDigits ( a , b ) )\n", "python_code_tokenized": "def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a * b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT a = 33 NEW_LINE b = - 24 NEW_LINE print ( \" Number \u2581 of \u2581 digits \u2581 = \u2581 \" , countDigits ( a , b ) ) NEW_LINE"}
{"id": "geeksforgeeks_365_A", "sol": 0, "python_code": "def y ( x ) :\n    num = 1 ;\n    denom = float ( 1.0 + x * x ) ;\n    return num / denom ;\ndef WeedleRule ( a , b ) :\n    h = ( b - a ) / 6 ;\n    sum = 0 ;\n    sum = sum + ( ( ( 3 * h ) / 10 ) * ( y ( a ) + y ( a + 2 * h ) + 5 * y ( a + h ) + 6 * y ( a + 3 * h ) + y ( a + 4 * h ) + 5 * y ( a + 5 * h ) + y ( a + 6 * h ) ) ) ;\n    return sum ;\nif __name__ == '__main__' :\n    a = 0 ;\n    b = 6 ;\n    num = WeedleRule ( a , b ) ;\n    print ( \"f(x) = {0:.6f}\".format ( num ) ) ;\n", "python_code_tokenized": "def y ( x ) : NEW_LINE INDENT num = 1 ; NEW_LINE denom = float ( 1.0 + x * x ) ; NEW_LINE return num / denom ; NEW_LINE DEDENT def WeedleRule ( a , b ) : NEW_LINE INDENT h = ( b - a ) / 6 ; NEW_LINE sum = 0 ; NEW_LINE sum = sum + ( ( ( 3 * h ) / 10 ) * ( y ( a ) + y ( a + 2 * h ) + 5 * y ( a + h ) + 6 * y ( a + 3 * h ) + y ( a + 4 * h ) + 5 * y ( a + 5 * h ) + y ( a + 6 * h ) ) ) ; NEW_LINE return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 0 ; NEW_LINE b = 6 ; NEW_LINE num = WeedleRule ( a , b ) ; NEW_LINE print ( \" f ( x ) \u2581 = \u2581 { 0 : . 6f } \" . format ( num ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2781_A", "sol": 0, "python_code": "import sys\ndef minimumChar ( S1 , S2 ) :\n    n , m = len ( S1 ) , len ( S2 )\n    ans = sys.maxsize\n    for i in range ( m - n + 1 ) :\n        minRemovedChar = 0\n        for j in range ( n ) :\n            if ( S1 [ j ] != S2 [ i + j ] ) :\n                minRemovedChar += 1\n        ans = min ( minRemovedChar , ans )\n    return ans\nif __name__ == '__main__' :\n    S1 = \"abc\"\n    S2 = \"paxzk\"\n    print ( minimumChar ( S1 , S2 ) )\n", "python_code_tokenized": "import sys NEW_LINE def minimumChar ( S1 , S2 ) : NEW_LINE INDENT n , m = len ( S1 ) , len ( S2 ) NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( m - n + 1 ) : NEW_LINE INDENT minRemovedChar = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( S1 [ j ] != S2 [ i + j ] ) : NEW_LINE INDENT minRemovedChar += 1 NEW_LINE DEDENT DEDENT ans = min ( minRemovedChar , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S1 = \" abc \" NEW_LINE S2 = \" paxzk \" NEW_LINE print ( minimumChar ( S1 , S2 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1445_A", "sol": 0, "python_code": "INT_MIN = - 1000000\ndef printMaxOfMin ( arr , n ) :\n    for k in range ( 1 , n + 1 ) :\n        maxOfMin = INT_MIN ;\n        for i in range ( n - k + 1 ) :\n            min = arr [ i ]\n            for j in range ( k ) :\n                if ( arr [ i + j ] < min ) :\n                    min = arr [ i + j ]\n            if ( min > maxOfMin ) :\n                maxOfMin = min\n        print ( maxOfMin , end = \" \" )\narr = [ 10 , 20 , 30 , 50 , 10 , 70 , 30 ]\nn = len ( arr )\nprintMaxOfMin ( arr , n )\n", "python_code_tokenized": "INT_MIN = - 1000000 NEW_LINE def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = INT_MIN ; NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( arr [ i + j ] < min ) : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > maxOfMin ) : NEW_LINE INDENT maxOfMin = min NEW_LINE DEDENT DEDENT print ( maxOfMin , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 50 , 10 , 70 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE printMaxOfMin ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_5174_A", "sol": 0, "python_code": "def findNumber ( n ) :\n    i = n - 1\n    while ( i >= 0 ) :\n        count = [ 0 for i in range ( 10 ) ]\n        x = i\n        count1 = 0\n        count2 = 0\n        while ( x ) :\n            count [ x % 10 ] += 1\n            x = int ( x / 10 )\n            count1 += 1\n        for j in range ( 0 , 10 , 1 ) :\n            if ( count [ j ] == 1 ) :\n                count2 += 1\n        if ( count1 == count2 ) :\n            return i\n        i -= 1\nif __name__ == '__main__' :\n    n = 8490\n    print ( findNumber ( n ) )\n", "python_code_tokenized": "def findNumber ( n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT count = [ 0 for i in range ( 10 ) ] NEW_LINE x = i NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE while ( x ) : NEW_LINE INDENT count [ x % 10 ] += 1 NEW_LINE x = int ( x / 10 ) NEW_LINE count1 += 1 NEW_LINE DEDENT for j in range ( 0 , 10 , 1 ) : NEW_LINE INDENT if ( count [ j ] == 1 ) : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT DEDENT if ( count1 == count2 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8490 NEW_LINE print ( findNumber ( n ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00475_A", "sol": 0, "python_code": "import sys\nfrom sys import stdin\ninput = stdin.readline\nx , y = [ ] , [ ]\nn = int ( input ( ) )\nfor i in range ( n ) :\n    a , b = map ( int , input ( ).split ( ) )\n    x.append ( a + b )\n    y.append ( a - b )\nxmin , xmax = min ( x ) , max ( x )\nymin , ymax = min ( y ) , max ( y )\nans1 = ans2 = 0\nfor i in range ( n ) :\n    d1 = max ( x [ i ] - xmin , y [ i ] - ymin )\n    d2 = max ( xmax - x [ i ] , ymax - y [ i ] )\n    ans1 = max ( ans1 , min ( d1 , d2 ) )\n    d1 = max ( x [ i ] - xmin , ymax - y [ i ] )\n    d2 = max ( xmax - x [ i ] , y [ i ] - ymin )\n    ans2 = max ( ans2 , min ( d1 , d2 ) )\nprint ( min ( ans1 , ans2 ) )\n", "python_code_tokenized": "import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE x , y = [ ] , [ ] NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE x . append ( a + b ) NEW_LINE y . append ( a - b ) NEW_LINE DEDENT xmin , xmax = min ( x ) , max ( x ) NEW_LINE ymin , ymax = min ( y ) , max ( y ) NEW_LINE ans1 = ans2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d1 = max ( x [ i ] - xmin , y [ i ] - ymin ) NEW_LINE d2 = max ( xmax - x [ i ] , ymax - y [ i ] ) NEW_LINE ans1 = max ( ans1 , min ( d1 , d2 ) ) NEW_LINE d1 = max ( x [ i ] - xmin , ymax - y [ i ] ) NEW_LINE d2 = max ( xmax - x [ i ] , y [ i ] - ymin ) NEW_LINE ans2 = max ( ans2 , min ( d1 , d2 ) ) NEW_LINE DEDENT print ( min ( ans1 , ans2 ) ) NEW_LINE"}
{"id": "atcoder_ABC162_C", "sol": 0, "python_code": "k = int ( input ( ) )\nfrom math import gcd\nsamu = 0\nfor i in range ( 1 , k + 1 ) :\n    for j in range ( 1 , k + 1 ) :\n        for k in range ( 1 , k + 1 ) :\n            samu += gcd ( gcd ( i , j ) , k )\nprint ( samu )\n", "python_code_tokenized": "k = int ( input ( ) ) NEW_LINE from math import gcd NEW_LINE samu = 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT for k in range ( 1 , k + 1 ) : NEW_LINE INDENT samu += gcd ( gcd ( i , j ) , k ) NEW_LINE DEDENT DEDENT DEDENT print ( samu ) NEW_LINE"}
{"id": "aizu_p01470_A", "sol": 0, "python_code": "m = 10000000019\nx = 0\ndef mod ( x ) : return ( x % m + m ) % m\ndef pow ( x , a ) :\n    ret = 1\n    while a :\n        if ( a & 1 ) : ret = mod ( x * ret )\n        x = mod ( x * x )\n        a >>= 1\n    return ret\nfor _ in range ( int ( input ( ) ) ) :\n    o , y = map ( int , input ( ).split ( ) )\n    if o == 1 : x = ( x + y ) % m\n    elif o == 2 : x = ( x - y ) % m\n    elif o == 3 : x = mod ( x * y )\n    else : x = mod ( x * pow ( y , m - 2 ) )\nprint ( x if x < ( 1 << 31 ) else x - m )\n", "python_code_tokenized": "m = 10000000019 NEW_LINE x = 0 NEW_LINE def mod ( x ) : return ( x % m + m ) % m NEW_LINE def pow ( x , a ) : NEW_LINE INDENT ret = 1 NEW_LINE while a : NEW_LINE INDENT if ( a & 1 ) : ret = mod ( x * ret ) NEW_LINE x = mod ( x * x ) NEW_LINE a >>= 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT o , y = map ( int , input ( ) . split ( ) ) NEW_LINE if o == 1 : x = ( x + y ) % m NEW_LINE elif o == 2 : x = ( x - y ) % m NEW_LINE elif o == 3 : x = mod ( x * y ) NEW_LINE else : x = mod ( x * pow ( y , m - 2 ) ) NEW_LINE DEDENT print ( x if x < ( 1 << 31 ) else x - m ) NEW_LINE"}
{"id": "geeksforgeeks_121_A", "sol": 0, "python_code": "from collections import defaultdict\ndef longestPermutation ( a , n ) :\n    freq = defaultdict ( int )\n    for i in range ( n ) :\n        freq [ a [ i ] ] += 1\n    length = 0\n    for i in range ( 1 , n + 1 ) :\n        if ( freq [ i ] == 0 ) :\n            break\n        length += 1\n    return length\nif __name__ == \"__main__\" :\n    arr = [ 3 , 2 , 1 , 6 , 5 ]\n    n = len ( arr )\n    print ( longestPermutation ( arr , n ) )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE def longestPermutation ( a , n ) : NEW_LINE INDENT freq = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT length = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT length += 1 NEW_LINE DEDENT return length NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 6 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestPermutation ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC152_E", "sol": 0, "python_code": "from fractions import gcd\ndef lcm ( a , b ) :\n    return a * b / gcd ( a , b )\nMOD = 10 ** 9 + 7\nN = int ( input ( ) )\nA = list ( map ( int , input ( ).split ( ) ) )\n_lcm = 1\nfor a in A :\n    _lcm = _lcm * a // gcd ( _lcm , a )\nans = _lcm * sum ( [ pow ( s , MOD - 2 , MOD ) for s in A ] ) % MOD\nprint ( int ( ans % MOD ) )\n", "python_code_tokenized": "from fractions import gcd NEW_LINE def lcm ( a , b ) : NEW_LINE INDENT return a * b / gcd ( a , b ) NEW_LINE DEDENT MOD = 10 ** 9 + 7 NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE _lcm = 1 NEW_LINE for a in A : NEW_LINE INDENT _lcm = _lcm * a // gcd ( _lcm , a ) NEW_LINE DEDENT ans = _lcm * sum ( [ pow ( s , MOD - 2 , MOD ) for s in A ] ) % MOD NEW_LINE print ( int ( ans % MOD ) ) NEW_LINE"}
{"id": "geeksforgeeks_1500_A", "sol": 0, "python_code": "def maxSubStr ( str , n ) :\n    count0 = 0\n    count1 = 0\n    cnt = 0\n    for i in range ( n ) :\n        if str [ i ] == '0' :\n            count0 += 1\n        else :\n            count1 += 1\n        if count0 == count1 :\n            cnt += 1\n    if count0 != count1 :\n        return - 1\n    return cnt\nstr = \"0100110101\"\nn = len ( str )\nprint ( maxSubStr ( str , n ) )\n", "python_code_tokenized": "def maxSubStr ( str , n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT if count0 == count1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if count0 != count1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT str = \"0100110101\" NEW_LINE n = len ( str ) NEW_LINE print ( maxSubStr ( str , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2445_A", "sol": 0, "python_code": "def previousNumber ( num1 ) :\n    n = len ( num1 ) ;\n    num = list ( num1 ) ;\n    if ( num1 == \"1\" ) :\n        return \"0\" ;\n    i = n - 1 ;\n    while ( i >= 0 ) :\n        if ( num [ i ] == '1' ) :\n            num [ i ] = '0' ;\n            break ;\n        else :\n            num [ i ] = '1' ;\n        i -= 1 ;\n    if ( i == 0 ) :\n        return num [ 1 : n ] ;\n    return ''.join ( num ) ;\nnum = \"10110\" ;\nprint ( \"Binary representation of previous number =\" , previousNumber ( num ) ) ;\n", "python_code_tokenized": "def previousNumber ( num1 ) : NEW_LINE INDENT n = len ( num1 ) ; NEW_LINE num = list ( num1 ) ; NEW_LINE if ( num1 == \"1\" ) : NEW_LINE INDENT return \"0\" ; NEW_LINE DEDENT i = n - 1 ; NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT num [ i ] = '0' ; NEW_LINE break ; NEW_LINE DEDENT else : NEW_LINE INDENT num [ i ] = '1' ; NEW_LINE DEDENT i -= 1 ; NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT return num [ 1 : n ] ; NEW_LINE DEDENT return ' ' . join ( num ) ; NEW_LINE DEDENT num = \"10110\" ; NEW_LINE print ( \" Binary \u2581 representation \u2581 of \u2581 previous \u2581 number \u2581 = \" , previousNumber ( num ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_3257_A", "sol": 0, "python_code": "def multiply ( A , B , C ) :\n    global V\n    for i in range ( V ) :\n        for j in range ( V ) :\n            C [ i ] [ j ] = 0\n            for k in range ( V ) :\n                C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ]\ndef getTrace ( graph ) :\n    global V\n    trace = 0\n    for i in range ( V ) :\n        trace += graph [ i ] [ i ]\n    return trace\ndef triangleInGraph ( graph ) :\n    global V\n    aux2 = [ [ None ] * V for i in range ( V ) ]\n    aux3 = [ [ None ] * V for i in range ( V ) ]\n    for i in range ( V ) :\n        for j in range ( V ) :\n            aux2 [ i ] [ j ] = aux3 [ i ] [ j ] = 0\n    multiply ( graph , graph , aux2 )\n    multiply ( graph , aux2 , aux3 )\n    trace = getTrace ( aux3 )\n    return trace // 6\nV = 4\ngraph = [ [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 1 , 1 ] , [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] ]\nprint ( \"Total number of Triangle in Graph :\" , triangleInGraph ( graph ) )\n", "python_code_tokenized": "def multiply ( A , B , C ) : NEW_LINE INDENT global V NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT C [ i ] [ j ] = 0 NEW_LINE for k in range ( V ) : NEW_LINE INDENT C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def getTrace ( graph ) : NEW_LINE INDENT global V NEW_LINE trace = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT trace += graph [ i ] [ i ] NEW_LINE DEDENT return trace NEW_LINE DEDENT def triangleInGraph ( graph ) : NEW_LINE INDENT global V NEW_LINE aux2 = [ [ None ] * V for i in range ( V ) ] NEW_LINE aux3 = [ [ None ] * V for i in range ( V ) ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT aux2 [ i ] [ j ] = aux3 [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT multiply ( graph , graph , aux2 ) NEW_LINE multiply ( graph , aux2 , aux3 ) NEW_LINE trace = getTrace ( aux3 ) NEW_LINE return trace // 6 NEW_LINE DEDENT V = 4 NEW_LINE graph = [ [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 1 , 1 ] , [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] ] NEW_LINE print ( \" Total \u2581 number \u2581 of \u2581 Triangle \u2581 in \u2581 Graph \u2581 : \" , triangleInGraph ( graph ) ) NEW_LINE"}
{"id": "atcoder_ABC089_C", "sol": 0, "python_code": "import itertools as i , collections as c\nb = c.Counter ( s [ 0 ] for s in open ( 0 ).readlines ( ) [ 1 : ] if s [ 0 ] in \"MARCH\" )\nprint ( sum ( p * q * r for p , q , r in i.combinations ( b.values ( ) , 3 ) ) )\n", "python_code_tokenized": "import itertools as i , collections as c NEW_LINE b = c . Counter ( s [ 0 ] for s in open ( 0 ) . readlines ( ) [ 1 : ] if s [ 0 ] in \" MARCH \" ) NEW_LINE print ( sum ( p * q * r for p , q , r in i . combinations ( b . values ( ) , 3 ) ) ) NEW_LINE"}
{"id": "codeforces_1497_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    x = int ( input ( ) )\n    y = list ( map ( int , input ( ).split ( ) ) )\n    sort = list ( sorted ( y ) )\n    dupli = [ ]\n    nondupli = [ sort [ 0 ] ]\n    for i in range ( 1 , x ) :\n        if sort [ i ] == sort [ i - 1 ] :\n            dupli.append ( sort [ i ] )\n        else :\n            nondupli.append ( sort [ i ] )\n    print ( * nondupli + dupli )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sort = list ( sorted ( y ) ) NEW_LINE dupli = [ ] NEW_LINE nondupli = [ sort [ 0 ] ] NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT if sort [ i ] == sort [ i - 1 ] : NEW_LINE INDENT dupli . append ( sort [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT nondupli . append ( sort [ i ] ) NEW_LINE DEDENT DEDENT print ( * nondupli + dupli ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_906_A", "sol": 0, "python_code": "def printConsecutive ( last , first ) :\n    print ( first , end = \"\" )\n    first += 1\n    for x in range ( first , last + 1 ) :\n        print ( \" +\" , x , end = \"\" )\ndef findConsecutive ( N ) :\n    for last in range ( 1 , N ) :\n        for first in range ( 0 , last ) :\n            if 2 * N == ( last - first ) * ( last + first + 1 ) :\n                print ( N , \"= \" , end = \"\" )\n                printConsecutive ( last , first + 1 )\n                return\n    print ( \"-1\" )\nn = 12\nfindConsecutive ( n )\n", "python_code_tokenized": "def printConsecutive ( last , first ) : NEW_LINE INDENT print ( first , end = \" \" ) NEW_LINE first += 1 NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( \" \u2581 + \" , x , end = \" \" ) NEW_LINE DEDENT DEDENT def findConsecutive ( N ) : NEW_LINE INDENT for last in range ( 1 , N ) : NEW_LINE INDENT for first in range ( 0 , last ) : NEW_LINE INDENT if 2 * N == ( last - first ) * ( last + first + 1 ) : NEW_LINE INDENT print ( N , \" = \u2581 \" , end = \" \" ) NEW_LINE printConsecutive ( last , first + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( \" - 1\" ) NEW_LINE DEDENT n = 12 NEW_LINE findConsecutive ( n ) NEW_LINE"}
{"id": "geeksforgeeks_3748_A", "sol": 0, "python_code": "def lexicoSmallestPermuatation ( arr , n ) :\n    cnt = [ 0 for i in range ( n + 1 ) ]\n    for i in range ( n ) :\n        cnt [ arr [ i ] ] += 1\n    ele = 1\n    replacement = 0\n    vis = [ 0 for i in range ( n + 1 ) ]\n    for i in range ( n ) :\n        if ( cnt [ arr [ i ] ] == 1 ) :\n            continue\n        while ( cnt [ ele ] ) :\n            ele += 1\n        if ( ele > arr [ i ] and vis [ arr [ i ] ] == 0 ) :\n            vis [ arr [ i ] ] = 1 ;\n        else :\n            cnt [ arr [ i ] ] -= 1\n            arr [ i ] = ele\n            replacement += 1\n            ele += 1\n    print ( replacement )\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \" \" )\nif __name__ == '__main__' :\n    arr = [ 2 , 3 , 4 , 3 , 2 ]\n    sz = len ( arr )\n    lexicoSmallestPermuatation ( arr , sz )\n", "python_code_tokenized": "def lexicoSmallestPermuatation ( arr , n ) : NEW_LINE INDENT cnt = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ arr [ i ] ] += 1 NEW_LINE DEDENT ele = 1 NEW_LINE replacement = 0 NEW_LINE vis = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( cnt [ arr [ i ] ] == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT while ( cnt [ ele ] ) : NEW_LINE INDENT ele += 1 NEW_LINE DEDENT if ( ele > arr [ i ] and vis [ arr [ i ] ] == 0 ) : NEW_LINE INDENT vis [ arr [ i ] ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ arr [ i ] ] -= 1 NEW_LINE arr [ i ] = ele NEW_LINE replacement += 1 NEW_LINE ele += 1 NEW_LINE DEDENT DEDENT print ( replacement ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 3 , 2 ] NEW_LINE sz = len ( arr ) NEW_LINE lexicoSmallestPermuatation ( arr , sz ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2963_A", "sol": 0, "python_code": "def Maximum_xor_Triplet ( n , a ) :\n    s = set ( )\n    for i in range ( 0 , n ) :\n        for j in range ( i , n ) :\n            s.add ( a [ i ] ^ a [ j ] )\n    ans = 0\n    for i in s :\n        for j in range ( 0 , n ) :\n            ans = max ( ans , i ^ a [ j ] )\n    print ( ans )\nif __name__ == \"__main__\" :\n    a = [ 1 , 3 , 8 , 15 ]\n    n = len ( a )\n    Maximum_xor_Triplet ( n , a )\n", "python_code_tokenized": "def Maximum_xor_Triplet ( n , a ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT s . add ( a [ i ] ^ a [ j ] ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in s : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT ans = max ( ans , i ^ a [ j ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 3 , 8 , 15 ] NEW_LINE n = len ( a ) NEW_LINE Maximum_xor_Triplet ( n , a ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3442_A", "sol": 0, "python_code": "def func ( x ) :\n    return ( float ( 1 ) / ( 1 + x * x ) )\ndef calculate ( lower_limit , upper_limit , interval_limit ) :\n    interval_size = ( float ( upper_limit - lower_limit ) / interval_limit )\n    sum = func ( lower_limit ) + func ( upper_limit ) ;\n    for i in range ( 1 , interval_limit ) :\n        if ( i % 3 == 0 ) :\n            sum = sum + 2 * func ( lower_limit + i * interval_size )\n        else :\n            sum = sum + 3 * func ( lower_limit + i * interval_size )\n    return ( ( float ( 3 * interval_size ) / 8 ) * sum )\ninterval_limit = 10\nlower_limit = 1\nupper_limit = 10\nintegral_res = calculate ( lower_limit , upper_limit , interval_limit )\nprint ( round ( integral_res , 6 ) )\n", "python_code_tokenized": "def func ( x ) : NEW_LINE INDENT return ( float ( 1 ) / ( 1 + x * x ) ) NEW_LINE DEDENT def calculate ( lower_limit , upper_limit , interval_limit ) : NEW_LINE INDENT interval_size = ( float ( upper_limit - lower_limit ) / interval_limit ) NEW_LINE sum = func ( lower_limit ) + func ( upper_limit ) ; NEW_LINE for i in range ( 1 , interval_limit ) : NEW_LINE INDENT if ( i % 3 == 0 ) : NEW_LINE INDENT sum = sum + 2 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + 3 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT DEDENT return ( ( float ( 3 * interval_size ) / 8 ) * sum ) NEW_LINE DEDENT interval_limit = 10 NEW_LINE lower_limit = 1 NEW_LINE upper_limit = 10 NEW_LINE integral_res = calculate ( lower_limit , upper_limit , interval_limit ) NEW_LINE print ( round ( integral_res , 6 ) ) NEW_LINE"}
{"id": "codeforces_990_A", "sol": 0, "python_code": "if __name__ == \"__main__\" :\n    x = list ( map ( int , input ( ).split ( ' ' ) ) )\n    if x [ 0 ] % x [ 1 ] == 0 :\n        print ( 0 )\n    else :\n        y = x [ 0 ] % x [ 1 ]\n        print ( min ( x [ 3 ] * y , ( x [ 1 ] - y ) * x [ 2 ] ) )\n", "python_code_tokenized": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE if x [ 0 ] % x [ 1 ] == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT y = x [ 0 ] % x [ 1 ] NEW_LINE print ( min ( x [ 3 ] * y , ( x [ 1 ] - y ) * x [ 2 ] ) ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC062_B", "sol": 0, "python_code": "H , W = map ( int , input ( ).split ( ) )\nA = [ input ( ).split ( ) for i in range ( H ) ]\nX = \"#\" * ( W + 2 )\nfor i in range ( H ) :\n    A [ i ] [ 0 ] = \"#\" + A [ i ] [ 0 ] + \"#\"\nprint ( X )\nfor i in range ( H ) :\n    print ( A [ i ] [ 0 ] )\nprint ( X )\n", "python_code_tokenized": "H , W = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ input ( ) . split ( ) for i in range ( H ) ] NEW_LINE X = \" # \" * ( W + 2 ) NEW_LINE for i in range ( H ) : NEW_LINE INDENT A [ i ] [ 0 ] = \" # \" + A [ i ] [ 0 ] + \" # \" NEW_LINE DEDENT print ( X ) NEW_LINE for i in range ( H ) : NEW_LINE INDENT print ( A [ i ] [ 0 ] ) NEW_LINE DEDENT print ( X ) NEW_LINE"}
{"id": "geeksforgeeks_606_A", "sol": 0, "python_code": "def countDigits ( n ) :\n    count = 0\n    while ( n > 0 ) :\n        count += 1\n        n = n // 10\n    return count\ndef checkPrime ( n ) :\n    if ( n <= 1 ) :\n        return - 1\n    if ( n <= 3 ) :\n        return 0\n    if ( n % 2 == 0 or n % 3 == 0 ) :\n        return - 1\n    i = 5\n    while i * i <= n :\n        if ( n % i == 0 or n % ( i + 2 ) == 0 ) :\n            return - 1\n        i += 6\n    return 0\ndef printPrimePoints ( n ) :\n    count = countDigits ( n )\n    if ( count == 1 or count == 2 ) :\n        print ( \"-1\" )\n        return\n    found = False\n    for i in range ( 1 , ( count - 1 ) ) :\n        left = n // ( pow ( 10 , count - i ) )\n        right = n % ( pow ( 10 , count - i - 1 ) )\n        if ( checkPrime ( left ) == 0 and checkPrime ( right ) == 0 ) :\n            print ( i , end = \" \" )\n            found = True\n    if ( found == False ) :\n        print ( \"-1\" )\nif __name__ == \"__main__\" :\n    n = 2317\n    printPrimePoints ( n )\n", "python_code_tokenized": "def countDigits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def checkPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def printPrimePoints ( n ) : NEW_LINE INDENT count = countDigits ( n ) NEW_LINE if ( count == 1 or count == 2 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT found = False NEW_LINE for i in range ( 1 , ( count - 1 ) ) : NEW_LINE INDENT left = n // ( pow ( 10 , count - i ) ) NEW_LINE right = n % ( pow ( 10 , count - i - 1 ) ) NEW_LINE if ( checkPrime ( left ) == 0 and checkPrime ( right ) == 0 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE found = True NEW_LINE DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2317 NEW_LINE printPrimePoints ( n ) NEW_LINE DEDENT"}
{"id": "codeforces_1395_B", "sol": 0, "python_code": "n , m , Sx , Sy = map ( int , input ( ).split ( ) )\nprint ( Sx , Sy )\nfor j in range ( m ) :\n    if j != Sy - 1 :\n        print ( Sx , j + 1 )\nfor j in range ( m - 1 , - 1 , - 1 ) :\n    if j % 2 == 0 :\n        for i in range ( n ) :\n            if i != Sx - 1 :\n                print ( i + 1 , j + 1 )\n    else :\n        for i in range ( n - 1 , - 1 , - 1 ) :\n            if i != Sx - 1 :\n                print ( i + 1 , j + 1 )\n", "python_code_tokenized": "n , m , Sx , Sy = map ( int , input ( ) . split ( ) ) NEW_LINE print ( Sx , Sy ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT if j != Sy - 1 : NEW_LINE INDENT print ( Sx , j + 1 ) NEW_LINE DEDENT DEDENT for j in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if i != Sx - 1 : NEW_LINE INDENT print ( i + 1 , j + 1 ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if i != Sx - 1 : NEW_LINE INDENT print ( i + 1 , j + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_526_A", "sol": 0, "python_code": "def printMinimumProduct ( arr , n ) :\n    first_min = min ( arr [ 0 ] , arr [ 1 ] )\n    second_min = max ( arr [ 0 ] , arr [ 1 ] )\n    for i in range ( 2 , n ) :\n        if ( arr [ i ] < first_min ) :\n            second_min = first_min\n            first_min = arr [ i ]\n        elif ( arr [ i ] < second_min ) :\n            second_min = arr [ i ]\n    return first_min * second_min\na = [ 11 , 8 , 5 , 7 , 5 , 100 ]\nn = len ( a )\nprint ( printMinimumProduct ( a , n ) )\n", "python_code_tokenized": "def printMinimumProduct ( arr , n ) : NEW_LINE INDENT first_min = min ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE second_min = max ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] < first_min ) : NEW_LINE INDENT second_min = first_min NEW_LINE first_min = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < second_min ) : NEW_LINE INDENT second_min = arr [ i ] NEW_LINE DEDENT DEDENT return first_min * second_min NEW_LINE DEDENT a = [ 11 , 8 , 5 , 7 , 5 , 100 ] NEW_LINE n = len ( a ) NEW_LINE print ( printMinimumProduct ( a , n ) ) NEW_LINE"}
{"id": "codeforces_624_A", "sol": 0, "python_code": "def solution ( d , l , v1 , v2 ) :\n    l = l - d\n    v = v1 + v2\n    print ( round ( l / v , 7 ) )\nd , l , v1 , v2 = [ int ( x ) for x in input ( ).strip ( ).split ( \" \" ) ]\nsolution ( d , l , v1 , v2 )\n", "python_code_tokenized": "def solution ( d , l , v1 , v2 ) : NEW_LINE INDENT l = l - d NEW_LINE v = v1 + v2 NEW_LINE print ( round ( l / v , 7 ) ) NEW_LINE DEDENT d , l , v1 , v2 = [ int ( x ) for x in input ( ) . strip ( ) . split ( \" \u2581 \" ) ] NEW_LINE solution ( d , l , v1 , v2 ) NEW_LINE"}
{"id": "codeforces_1692_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    l = list ( map ( int , input ( ).split ( ) ) )\n    c = 0\n    for i in range ( 1 , 4 ) :\n        if ( l [ i ] > l [ 0 ] ) :\n            c += 1\n    print ( c )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( 1 , 4 ) : NEW_LINE INDENT if ( l [ i ] > l [ 0 ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4772_A", "sol": 0, "python_code": "def flipBit ( a ) :\n    if ( ~ a == 0 ) :\n        return 8 * sizeof ( ) ;\n    currLen = 0 ;\n    prevLen = 0 ;\n    maxLen = 0 ;\n    while ( a > 0 ) :\n        if ( ( a & 1 ) == 1 ) :\n            currLen += 1 ;\n        elif ( ( a & 1 ) == 0 ) :\n            prevLen = 0 if ( ( a & 2 ) == 0 ) else currLen ;\n            currLen = 0 ;\n        maxLen = max ( prevLen + currLen , maxLen ) ;\n        a >>= 1 ;\n    return maxLen + 1 ;\nprint ( flipBit ( 13 ) ) ;\nprint ( flipBit ( 1775 ) ) ;\nprint ( flipBit ( 15 ) ) ;\n", "python_code_tokenized": "def flipBit ( a ) : NEW_LINE INDENT if ( ~ a == 0 ) : NEW_LINE INDENT return 8 * sizeof ( ) ; NEW_LINE DEDENT currLen = 0 ; NEW_LINE prevLen = 0 ; NEW_LINE maxLen = 0 ; NEW_LINE while ( a > 0 ) : NEW_LINE INDENT if ( ( a & 1 ) == 1 ) : NEW_LINE INDENT currLen += 1 ; NEW_LINE DEDENT elif ( ( a & 1 ) == 0 ) : NEW_LINE INDENT prevLen = 0 if ( ( a & 2 ) == 0 ) else currLen ; NEW_LINE currLen = 0 ; NEW_LINE DEDENT maxLen = max ( prevLen + currLen , maxLen ) ; NEW_LINE a >>= 1 ; NEW_LINE DEDENT return maxLen + 1 ; NEW_LINE DEDENT print ( flipBit ( 13 ) ) ; NEW_LINE print ( flipBit ( 1775 ) ) ; NEW_LINE print ( flipBit ( 15 ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_1524_A", "sol": 0, "python_code": "def minSwaps ( arr , n ) :\n    numberOfOnes = 0\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] == 1 ) :\n            numberOfOnes = numberOfOnes + 1\n    x = numberOfOnes\n    count_ones = 0\n    maxOnes = 0\n    for i in range ( 0 , x ) :\n        if ( arr [ i ] == 1 ) :\n            count_ones = count_ones + 1\n    maxOnes = count_ones\n    for i in range ( 1 , ( n - x + 1 ) ) :\n        if ( arr [ i - 1 ] == 1 ) :\n            count_ones = count_ones - 1\n        if ( arr [ i + x - 1 ] == 1 ) :\n            count_ones = count_ones + 1\n        if ( maxOnes < count_ones ) :\n            maxOnes = count_ones\n    numberOfZeroes = x - maxOnes\n    return numberOfZeroes\na = [ 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ]\nn = 9\nprint ( minSwaps ( a , n ) )\n", "python_code_tokenized": "def minSwaps ( arr , n ) : NEW_LINE INDENT numberOfOnes = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT numberOfOnes = numberOfOnes + 1 NEW_LINE DEDENT DEDENT x = numberOfOnes NEW_LINE count_ones = 0 NEW_LINE maxOnes = 0 NEW_LINE for i in range ( 0 , x ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count_ones = count_ones + 1 NEW_LINE DEDENT DEDENT maxOnes = count_ones NEW_LINE for i in range ( 1 , ( n - x + 1 ) ) : NEW_LINE INDENT if ( arr [ i - 1 ] == 1 ) : NEW_LINE INDENT count_ones = count_ones - 1 NEW_LINE DEDENT if ( arr [ i + x - 1 ] == 1 ) : NEW_LINE INDENT count_ones = count_ones + 1 NEW_LINE DEDENT if ( maxOnes < count_ones ) : NEW_LINE INDENT maxOnes = count_ones NEW_LINE DEDENT DEDENT numberOfZeroes = x - maxOnes NEW_LINE return numberOfZeroes NEW_LINE DEDENT a = [ 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ] NEW_LINE n = 9 NEW_LINE print ( minSwaps ( a , n ) ) NEW_LINE"}
{"id": "codeforces_1238_A", "sol": 0, "python_code": "def get ( ) :\n    return list ( map ( int , input ( ).split ( ) ) )\ndef intput ( ) :\n    return int ( input ( ) )\ndef main ( ) :\n    for _ in range ( intput ( ) ) :\n        a = get ( )\n        if ( a [ 0 ] - a [ 1 ] == 1 ) :\n            print ( 'NO' )\n        else :\n            print ( \"YES\" )\nmain ( )\n", "python_code_tokenized": "def get ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def intput ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT for _ in range ( intput ( ) ) : NEW_LINE INDENT a = get ( ) NEW_LINE if ( a [ 0 ] - a [ 1 ] == 1 ) : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_345_A", "sol": 0, "python_code": "def power ( x , y ) :\n    if ( y == 0 ) : return 1\n    temp = power ( x , int ( y / 2 ) )\n    if ( y % 2 == 0 ) :\n        return temp * temp\n    else :\n        if ( y > 0 ) : return x * temp * temp\n        else : return ( temp * temp ) / x\nx , y = 2 , - 3\nprint ( '%.6f' % ( power ( x , y ) ) )\n", "python_code_tokenized": "def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 1 NEW_LINE temp = power ( x , int ( y / 2 ) ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT if ( y > 0 ) : return x * temp * temp NEW_LINE else : return ( temp * temp ) / x NEW_LINE DEDENT DEDENT x , y = 2 , - 3 NEW_LINE print ( ' % .6f ' % ( power ( x , y ) ) ) NEW_LINE"}
{"id": "aizu_p00098_A", "sol": 0, "python_code": "from itertools import accumulate\nn = int ( input ( ) )\nmp = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( n ) ]\nacc_arr = [ list ( accumulate ( [ 0 ] + line ) ) for line in mp ]\nans = max ( [ max ( line ) for line in mp ] )\nfor i in range ( n + 1 ) :\n    for j in range ( i + 1 , n + 1 ) :\n        acc = 0\n        for k in range ( n ) :\n            add = acc_arr [ k ] [ j ] - acc_arr [ k ] [ i ]\n            if acc + add > 0 :\n                acc = acc + add\n                ans = max ( acc , ans )\n            else :\n                acc = 0\nprint ( ans )\n", "python_code_tokenized": "from itertools import accumulate NEW_LINE n = int ( input ( ) ) NEW_LINE mp = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE acc_arr = [ list ( accumulate ( [ 0 ] + line ) ) for line in mp ] NEW_LINE ans = max ( [ max ( line ) for line in mp ] ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT acc = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT add = acc_arr [ k ] [ j ] - acc_arr [ k ] [ i ] NEW_LINE if acc + add > 0 : NEW_LINE INDENT acc = acc + add NEW_LINE ans = max ( acc , ans ) NEW_LINE DEDENT else : NEW_LINE INDENT acc = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "aizu_p02469_A", "sol": 0, "python_code": "import fractions\nn = int ( input ( ) )\nx = list ( map ( int , input ( ).split ( ) ) )\ny = x [ 0 ]\nfor i in range ( 1 , n ) :\n    y = y * x [ i ] // fractions.gcd ( y , x [ i ] )\nprint ( y )\n", "python_code_tokenized": "import fractions NEW_LINE n = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE y = x [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT y = y * x [ i ] // fractions . gcd ( y , x [ i ] ) NEW_LINE DEDENT print ( y ) NEW_LINE"}
{"id": "geeksforgeeks_414_A", "sol": 0, "python_code": "import sys\nINT_MAX = sys.maxsize ;\nINT_MIN = - ( sys.maxsize - 1 ) ;\ndef countOfSubarrays ( arr , n ) :\n    count = 0 ;\n    v = [ 0 ] * ( n + 1 ) ;\n    for i in range ( n ) :\n        v [ arr [ i ] ] = i ;\n    maximum = INT_MIN ;\n    minimum = INT_MAX ;\n    for i in range ( 1 , n + 1 ) :\n        maximum = max ( maximum , v [ i ] ) ;\n        minimum = min ( minimum , v [ i ] ) ;\n        if ( maximum - minimum < i ) :\n            count = count + 1 ;\n    return count ;\nif __name__ == \"__main__\" :\n    arr = [ 4 , 1 , 3 , 2 , 5 , 6 ] ;\n    n = len ( arr ) ;\n    print ( countOfSubarrays ( arr , n ) ) ;\n", "python_code_tokenized": "import sys NEW_LINE INT_MAX = sys . maxsize ; NEW_LINE INT_MIN = - ( sys . maxsize - 1 ) ; NEW_LINE def countOfSubarrays ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE v = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ arr [ i ] ] = i ; NEW_LINE DEDENT maximum = INT_MIN ; NEW_LINE minimum = INT_MAX ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT maximum = max ( maximum , v [ i ] ) ; NEW_LINE minimum = min ( minimum , v [ i ] ) ; NEW_LINE if ( maximum - minimum < i ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 1 , 3 , 2 , 5 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countOfSubarrays ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4650_A", "sol": 0, "python_code": "from bisect import bisect_left\ndef fibMonaccianSearch ( arr , x , n ) :\n    fibMMm2 = 0\n    fibMMm1 = 1\n    fibM = fibMMm2 + fibMMm1\n    while ( fibM < n ) :\n        fibMMm2 = fibMMm1\n        fibMMm1 = fibM\n        fibM = fibMMm2 + fibMMm1\n    offset = - 1 ;\n    while ( fibM > 1 ) :\n        i = min ( offset + fibMMm2 , n - 1 )\n        if ( arr [ i ] < x ) :\n            fibM = fibMMm1\n            fibMMm1 = fibMMm2\n            fibMMm2 = fibM - fibMMm1\n            offset = i\n        elif ( arr [ i ] > x ) :\n            fibM = fibMMm2\n            fibMMm1 = fibMMm1 - fibMMm2\n            fibMMm2 = fibM - fibMMm1\n        else :\n            return i\n    if ( fibMMm1 and arr [ offset + 1 ] == x ) :\n        return offset + 1 ;\n    return - 1\narr = [ 10 , 22 , 35 , 40 , 45 , 50 , 80 , 82 , 85 , 90 , 100 ]\nn = len ( arr )\nx = 85\nprint ( \"Found at index:\" , fibMonaccianSearch ( arr , x , n ) )\n", "python_code_tokenized": "from bisect import bisect_left NEW_LINE def fibMonaccianSearch ( arr , x , n ) : NEW_LINE INDENT fibMMm2 = 0 NEW_LINE fibMMm1 = 1 NEW_LINE fibM = fibMMm2 + fibMMm1 NEW_LINE while ( fibM < n ) : NEW_LINE INDENT fibMMm2 = fibMMm1 NEW_LINE fibMMm1 = fibM NEW_LINE fibM = fibMMm2 + fibMMm1 NEW_LINE DEDENT offset = - 1 ; NEW_LINE while ( fibM > 1 ) : NEW_LINE INDENT i = min ( offset + fibMMm2 , n - 1 ) NEW_LINE if ( arr [ i ] < x ) : NEW_LINE INDENT fibM = fibMMm1 NEW_LINE fibMMm1 = fibMMm2 NEW_LINE fibMMm2 = fibM - fibMMm1 NEW_LINE offset = i NEW_LINE DEDENT elif ( arr [ i ] > x ) : NEW_LINE INDENT fibM = fibMMm2 NEW_LINE fibMMm1 = fibMMm1 - fibMMm2 NEW_LINE fibMMm2 = fibM - fibMMm1 NEW_LINE DEDENT else : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT if ( fibMMm1 and arr [ offset + 1 ] == x ) : NEW_LINE INDENT return offset + 1 ; NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 10 , 22 , 35 , 40 , 45 , 50 , 80 , 82 , 85 , 90 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE x = 85 NEW_LINE print ( \" Found \u2581 at \u2581 index : \" , fibMonaccianSearch ( arr , x , n ) ) NEW_LINE"}
{"id": "projecteuler_p130_A", "sol": 0, "python_code": "import eulerlib , itertools\ndef compute ( ) :\n    cond = lambda i : ( i % 5 != 0 ) and ( not eulerlib.is_prime ( i ) ) and ( ( i - 1 ) % find_least_divisible_repunit ( i ) == 0 )\n    ans = sum ( itertools.islice ( filter ( cond , itertools.count ( 7 , 2 ) ) , 25 ) )\n    return str ( ans )\ndef find_least_divisible_repunit ( n ) :\n    if n % 2 == 0 or n % 5 == 0 :\n        return 0\n    sum = 1\n    pow = 1\n    k = 1\n    while sum % n != 0 :\n        k += 1\n        pow = pow * 10 % n\n        sum = ( sum + pow ) % n\n    return k\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT cond = lambda i : ( i % 5 != 0 ) and ( not eulerlib . is_prime ( i ) ) and ( ( i - 1 ) % find_least_divisible_repunit ( i ) == 0 ) NEW_LINE ans = sum ( itertools . islice ( filter ( cond , itertools . count ( 7 , 2 ) ) , 25 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def find_least_divisible_repunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum = 1 NEW_LINE pow = 1 NEW_LINE k = 1 NEW_LINE while sum % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE pow = pow * 10 % n NEW_LINE sum = ( sum + pow ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2563_A", "sol": 0, "python_code": "def findNumbers ( n , b ) :\n    even = 0 ;\n    odd = 0 ;\n    if ( b % 2 == 0 ) :\n        even = pow ( b , n ) - 2 ;\n        odd = pow ( b , n ) - 1 ;\n    else :\n        even = pow ( b , n ) - 1 ;\n        odd = pow ( b , n ) - 2 ;\n    print ( \"Even Number = \" , int ( even ) ) ;\n    print ( \"Odd Number = \" , int ( odd ) ) ;\nif __name__ == '__main__' :\n    N = 2 ;\n    B = 5 ;\n    findNumbers ( N , B ) ;\n", "python_code_tokenized": "def findNumbers ( n , b ) : NEW_LINE INDENT even = 0 ; NEW_LINE odd = 0 ; NEW_LINE if ( b % 2 == 0 ) : NEW_LINE INDENT even = pow ( b , n ) - 2 ; NEW_LINE odd = pow ( b , n ) - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT even = pow ( b , n ) - 1 ; NEW_LINE odd = pow ( b , n ) - 2 ; NEW_LINE DEDENT print ( \" Even \u2581 Number \u2581 = \u2581 \" , int ( even ) ) ; NEW_LINE print ( \" Odd \u2581 Number \u2581 = \u2581 \" , int ( odd ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2 ; NEW_LINE B = 5 ; NEW_LINE findNumbers ( N , B ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_13_A", "sol": 0, "python_code": "def isDivisible ( n ) :\n    while n // 100 :\n        d = n % 10\n        n //= 10\n        n = abs ( n + ( d * 13 ) )\n    return ( n % 43 == 0 )\nif __name__ == \"__main__\" :\n    N = 2795\n    if ( isDivisible ( N ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n + ( d * 13 ) ) NEW_LINE DEDENT return ( n % 43 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 2795 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_16_A", "sol": 0, "python_code": "def isDivisible ( n ) :\n    while n // 100 :\n        d = n % 10\n        n //= 10\n        n = abs ( n - ( d * 3 ) )\n    return ( n % 31 == 0 )\nif __name__ == \"__main__\" :\n    n = 1922\n    if ( isDivisible ( n ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 3 ) ) NEW_LINE DEDENT return ( n % 31 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1922 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_18_A", "sol": 0, "python_code": "def isDivisible ( n ) :\n    while n // 100 :\n        d = n % 10\n        n //= 10\n        n = abs ( n - ( d * 7 ) )\n    return ( n % 71 == 0 )\nif __name__ == \"__main__\" :\n    N = 5041\n    if ( isDivisible ( N ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 7 ) ) NEW_LINE DEDENT return ( n % 71 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5041 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_15_A", "sol": 0, "python_code": "def isDivisible ( n ) :\n    while n // 100 :\n        d = n % 10\n        n //= 10\n        n = abs ( n - ( d * 14 ) )\n    return ( n % 47 == 0 )\nif __name__ == \"__main__\" :\n    n = 59173\n    if ( isDivisible ( n ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 59173 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_5053_A", "sol": 0, "python_code": "def findAllSequences ( diff , out , start , end ) :\n    if ( abs ( diff ) > ( end - start + 1 ) // 2 ) :\n        return ;\n    if ( start > end ) :\n        if ( diff == 0 ) :\n            print ( ''.join ( list ( out ) ) , end = \"\" ) ;\n        return ;\n    out [ start ] = '0' ;\n    out [ end ] = '1' ;\n    findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) ;\n    out [ start ] = out [ end ] = '1' ;\n    findAllSequences ( diff , out , start + 1 , end - 1 ) ;\n    out [ start ] = out [ end ] = '0' ;\n    findAllSequences ( diff , out , start + 1 , end - 1 ) ;\n    out [ start ] = '1' ;\n    out [ end ] = '0' ;\n    findAllSequences ( diff - 1 , out , start + 1 , end - 1 ) ;\nn = 2 ;\nout = [ \"\" ] * ( 2 * n ) ;\nfindAllSequences ( 0 , out , 0 , 2 * n - 1 ) ;\n", "python_code_tokenized": "def findAllSequences ( diff , out , start , end ) : NEW_LINE INDENT if ( abs ( diff ) > ( end - start + 1 ) // 2 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT if ( diff == 0 ) : NEW_LINE INDENT print ( ' ' . join ( list ( out ) ) , end = \" \u2581 \" ) ; NEW_LINE DEDENT return ; NEW_LINE DEDENT out [ start ] = '0' ; NEW_LINE out [ end ] = '1' ; NEW_LINE findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) ; NEW_LINE out [ start ] = out [ end ] = '1' ; NEW_LINE findAllSequences ( diff , out , start + 1 , end - 1 ) ; NEW_LINE out [ start ] = out [ end ] = '0' ; NEW_LINE findAllSequences ( diff , out , start + 1 , end - 1 ) ; NEW_LINE out [ start ] = '1' ; NEW_LINE out [ end ] = '0' ; NEW_LINE findAllSequences ( diff - 1 , out , start + 1 , end - 1 ) ; NEW_LINE DEDENT n = 2 ; NEW_LINE out = [ \" \" ] * ( 2 * n ) ; NEW_LINE findAllSequences ( 0 , out , 0 , 2 * n - 1 ) ; NEW_LINE"}
{"id": "aizu_p01370_A", "sol": 0, "python_code": "from collections import deque\nwhile True :\n    t , n = map ( int , input ( ).split ( ) )\n    if t == 0 : break\n    bans = { tuple ( map ( int , input ( ).split ( ) ) ) for _ in range ( n ) }\n    sx , sy = map ( int , input ( ).split ( ) )\n    vec = ( ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , 0 ) )\n    que = deque ( )\n    que.append ( ( t , sx , sy ) )\n    reached = set ( )\n    reached.add ( ( sx , sy ) )\n    while que :\n        turn , x , y = que.popleft ( )\n        if turn == 0 : continue\n        for dx , dy in vec :\n            nx , ny = x + dx , y + dy\n            if ( nx , ny ) not in reached and ( nx , ny ) not in bans :\n                reached.add ( ( nx , ny ) )\n                que.append ( ( turn - 1 , nx , ny ) )\n    print ( len ( reached ) )\n", "python_code_tokenized": "from collections import deque NEW_LINE while True : NEW_LINE INDENT t , n = map ( int , input ( ) . split ( ) ) NEW_LINE if t == 0 : break NEW_LINE bans = { tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) } NEW_LINE sx , sy = map ( int , input ( ) . split ( ) ) NEW_LINE vec = ( ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , 0 ) ) NEW_LINE que = deque ( ) NEW_LINE que . append ( ( t , sx , sy ) ) NEW_LINE reached = set ( ) NEW_LINE reached . add ( ( sx , sy ) ) NEW_LINE while que : NEW_LINE INDENT turn , x , y = que . popleft ( ) NEW_LINE if turn == 0 : continue NEW_LINE for dx , dy in vec : NEW_LINE INDENT nx , ny = x + dx , y + dy NEW_LINE if ( nx , ny ) not in reached and ( nx , ny ) not in bans : NEW_LINE INDENT reached . add ( ( nx , ny ) ) NEW_LINE que . append ( ( turn - 1 , nx , ny ) ) NEW_LINE DEDENT DEDENT DEDENT print ( len ( reached ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1333_A", "sol": 0, "python_code": "import math\nMAX = 10000 ;\nprimes = [ ] ;\ndef sieveSundaram ( ) :\n    marked = [ False ] * ( int ( MAX / 2 ) + 100 ) ;\n    for i in range ( 1 , int ( ( math.sqrt ( MAX ) - 1 ) / 2 ) + 1 ) :\n        for j in range ( ( i * ( i + 1 ) ) << 1 , int ( MAX / 2 ) + 1 , 2 * i + 1 ) :\n            marked [ j ] = True ;\n    primes.append ( 2 ) ;\n    for i in range ( 1 , int ( MAX / 2 ) + 1 ) :\n        if ( marked [ i ] == False ) :\n            primes.append ( 2 * i + 1 ) ;\ndef findPrimes ( n ) :\n    if ( n <= 2 or n % 2 != 0 ) :\n        print ( \"Invalid Input\" ) ;\n        return ;\n    i = 0 ;\n    while ( primes [ i ] <= n // 2 ) :\n        diff = n - primes [ i ] ;\n        if diff in primes :\n            print ( primes [ i ] , \"+\" , diff , \"=\" , n ) ;\n            return ;\n        i += 1 ;\nsieveSundaram ( ) ;\nfindPrimes ( 4 ) ;\nfindPrimes ( 38 ) ;\nfindPrimes ( 100 ) ;\n", "python_code_tokenized": "import math NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieveSundaram ( ) : NEW_LINE INDENT marked = [ False ] * ( int ( MAX / 2 ) + 100 ) ; NEW_LINE for i in range ( 1 , int ( ( math . sqrt ( MAX ) - 1 ) / 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , int ( MAX / 2 ) + 1 , 2 * i + 1 ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , int ( MAX / 2 ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def findPrimes ( n ) : NEW_LINE INDENT if ( n <= 2 or n % 2 != 0 ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \" ) ; NEW_LINE return ; NEW_LINE DEDENT i = 0 ; NEW_LINE while ( primes [ i ] <= n // 2 ) : NEW_LINE INDENT diff = n - primes [ i ] ; NEW_LINE if diff in primes : NEW_LINE INDENT print ( primes [ i ] , \" + \" , diff , \" = \" , n ) ; NEW_LINE return ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT sieveSundaram ( ) ; NEW_LINE findPrimes ( 4 ) ; NEW_LINE findPrimes ( 38 ) ; NEW_LINE findPrimes ( 100 ) ; NEW_LINE"}
{"id": "atcoder_ABC122_A", "sol": 0, "python_code": "import sys\ns = sys.stdin.readline ( )\nif 'A' in s :\n    print ( 'T' )\nelif 'G' in s :\n    print ( 'C' )\nelif 'C' in s :\n    print ( 'G' )\nelse :\n    print ( 'A' )\n", "python_code_tokenized": "import sys NEW_LINE s = sys . stdin . readline ( ) NEW_LINE if ' A ' in s : NEW_LINE INDENT print ( ' T ' ) NEW_LINE DEDENT elif ' G ' in s : NEW_LINE INDENT print ( ' C ' ) NEW_LINE DEDENT elif ' C ' in s : NEW_LINE INDENT print ( ' G ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' A ' ) NEW_LINE DEDENT"}
{"id": "codeforces_34_B", "sol": 0, "python_code": "def bubble ( list_nums ) :\n    swap_bool = True\n    while swap_bool :\n        swap_bool = False\n        for i in range ( len ( list_nums ) - 1 ) :\n            if abs ( int ( list_nums [ i ] ) ) < abs ( int ( list_nums [ i + 1 ] ) ) :\n                list_nums [ i ] , list_nums [ i + 1 ] = list_nums [ i + 1 ] , list_nums [ i ]\n                swap_bool = True\n    return list_nums\ndef main ( ) :\n    n = input ( ).split ( )\n    amount_of_TV = int ( n [ 0 ] )\n    max_TVs = int ( n [ 1 ] )\n    TVs = input ( ).split ( )\n    TVs_sorted = [ ]\n    for i in range ( len ( TVs ) ) :\n        if int ( TVs [ i ] ) < 0 :\n            TVs_sorted.append ( TVs [ i ] )\n    TVs_sorted = bubble ( TVs_sorted )\n    SUM = 0\n    if len ( TVs_sorted ) >= max_TVs :\n        for i in range ( max_TVs ) :\n            if int ( TVs_sorted [ i ] ) <= 0 :\n                SUM += abs ( int ( TVs_sorted [ i ] ) )\n    else :\n        for i in range ( len ( TVs_sorted ) ) :\n            if int ( TVs_sorted [ i ] ) <= 0 :\n                SUM += abs ( int ( TVs_sorted [ i ] ) )\n    print ( SUM )\nmain ( )\n", "python_code_tokenized": "def bubble ( list_nums ) : NEW_LINE INDENT swap_bool = True NEW_LINE while swap_bool : NEW_LINE INDENT swap_bool = False NEW_LINE for i in range ( len ( list_nums ) - 1 ) : NEW_LINE INDENT if abs ( int ( list_nums [ i ] ) ) < abs ( int ( list_nums [ i + 1 ] ) ) : NEW_LINE INDENT list_nums [ i ] , list_nums [ i + 1 ] = list_nums [ i + 1 ] , list_nums [ i ] NEW_LINE swap_bool = True NEW_LINE DEDENT DEDENT DEDENT return list_nums NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = input ( ) . split ( ) NEW_LINE amount_of_TV = int ( n [ 0 ] ) NEW_LINE max_TVs = int ( n [ 1 ] ) NEW_LINE TVs = input ( ) . split ( ) NEW_LINE TVs_sorted = [ ] NEW_LINE for i in range ( len ( TVs ) ) : NEW_LINE INDENT if int ( TVs [ i ] ) < 0 : NEW_LINE INDENT TVs_sorted . append ( TVs [ i ] ) NEW_LINE DEDENT DEDENT TVs_sorted = bubble ( TVs_sorted ) NEW_LINE SUM = 0 NEW_LINE if len ( TVs_sorted ) >= max_TVs : NEW_LINE INDENT for i in range ( max_TVs ) : NEW_LINE INDENT if int ( TVs_sorted [ i ] ) <= 0 : NEW_LINE INDENT SUM += abs ( int ( TVs_sorted [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( len ( TVs_sorted ) ) : NEW_LINE INDENT if int ( TVs_sorted [ i ] ) <= 0 : NEW_LINE INDENT SUM += abs ( int ( TVs_sorted [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT print ( SUM ) NEW_LINE DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_2896_A", "sol": 0, "python_code": "min1 = 10 ** 9\n_count = 0\ndef permutation ( str1 , i , n , p ) :\n    global min1 , _count\n    if ( i == n ) :\n        str1 = \"\".join ( str1 )\n        q = int ( str1 )\n        if ( q - p > 0 and q < min1 ) :\n            min1 = q\n            _count = 1\n    else :\n        for j in range ( i , n + 1 ) :\n            str1 [ i ] , str1 [ j ] = str1 [ j ] , str1 [ i ]\n            permutation ( str1 , i + 1 , n , p )\n            str1 [ i ] , str1 [ j ] = str1 [ j ] , str1 [ i ]\n    return min1\nA = 213\nB = 111\nstr2 = str ( A )\nstr1 = [ i for i in str2 ]\nle = len ( str1 )\nh = permutation ( str1 , 0 , le - 1 , B )\nif _count == 1 :\n    print ( h )\nelse :\n    print ( - 1 )\n", "python_code_tokenized": "min1 = 10 ** 9 NEW_LINE _count = 0 NEW_LINE def permutation ( str1 , i , n , p ) : NEW_LINE INDENT global min1 , _count NEW_LINE if ( i == n ) : NEW_LINE INDENT str1 = \" \" . join ( str1 ) NEW_LINE q = int ( str1 ) NEW_LINE if ( q - p > 0 and q < min1 ) : NEW_LINE INDENT min1 = q NEW_LINE _count = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT str1 [ i ] , str1 [ j ] = str1 [ j ] , str1 [ i ] NEW_LINE permutation ( str1 , i + 1 , n , p ) NEW_LINE str1 [ i ] , str1 [ j ] = str1 [ j ] , str1 [ i ] NEW_LINE DEDENT DEDENT return min1 NEW_LINE DEDENT A = 213 NEW_LINE B = 111 NEW_LINE str2 = str ( A ) NEW_LINE str1 = [ i for i in str2 ] NEW_LINE le = len ( str1 ) NEW_LINE h = permutation ( str1 , 0 , le - 1 , B ) NEW_LINE if _count == 1 : NEW_LINE INDENT print ( h ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"}
{"id": "aizu_p00670_A", "sol": 0, "python_code": "while 1 :\n    n , s = map ( int , input ( ).split ( ) )\n    if n == 0 : break\n    r = [ 0 ] * 101\n    for _ in [ 0 ] * n : r [ int ( input ( ) ) ] += 1\n    a = 0\n    for i in range ( 101 ) :\n        if i * 2 > s : a += ( r [ i ] ** 2 - r [ i ] ) // 2\n        a += r [ i ] * sum ( r [ j ] for j in range ( max ( i + 1 , s + 1 - i ) , 101 ) )\n    print ( a )\n", "python_code_tokenized": "while 1 : NEW_LINE INDENT n , s = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE r = [ 0 ] * 101 NEW_LINE for _ in [ 0 ] * n : r [ int ( input ( ) ) ] += 1 NEW_LINE a = 0 NEW_LINE for i in range ( 101 ) : NEW_LINE INDENT if i * 2 > s : a += ( r [ i ] ** 2 - r [ i ] ) // 2 NEW_LINE a += r [ i ] * sum ( r [ j ] for j in range ( max ( i + 1 , s + 1 - i ) , 101 ) ) NEW_LINE DEDENT print ( a ) NEW_LINE DEDENT"}
{"id": "codeforces_60_A", "sol": 0, "python_code": "n , m = [ int ( i ) for i in input ( ).split ( ) ]\ns , e = 1 , n\nans = 1\nfor i in range ( m ) :\n    t = input ( ).split ( )\n    if \"right\" in t : s = max ( s , int ( t [ - 1 ] ) + 1 )\n    else : e = min ( e , int ( t [ - 1 ] ) - 1 )\n    if s > e : ans = 0 ; break\nif ans : print ( e - s + 1 )\nelse : print ( - 1 )\n", "python_code_tokenized": "n , m = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE s , e = 1 , n NEW_LINE ans = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT t = input ( ) . split ( ) NEW_LINE if \" right \" in t : s = max ( s , int ( t [ - 1 ] ) + 1 ) NEW_LINE else : e = min ( e , int ( t [ - 1 ] ) - 1 ) NEW_LINE if s > e : ans = 0 ; break NEW_LINE DEDENT if ans : print ( e - s + 1 ) NEW_LINE else : print ( - 1 ) NEW_LINE"}
{"id": "aizu_p00141_A", "sol": 0, "python_code": "vector = ( ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) )\ndef make_guruguru ( d ) :\n    lst = [ [ \"#\" ] * ( d + 4 ) ]\n    for _ in range ( d + 2 ) :\n        lst.append ( [ \"#\" ] + [ \"\" ] * ( d + 2 ) + [ \"#\" ] )\n    lst.append ( [ \"#\" ] * ( d + 4 ) )\n    x , y = 2 , d + 1\n    lst [ y ] [ x ] = \"#\"\n    direct = 0\n    vx , vy = vector [ 0 ]\n    cnt = 1\n    while True :\n        while lst [ y + vy * 2 ] [ x + vx * 2 ] == \"\" :\n            lst [ y + vy ] [ x + vx ] = \"#\"\n            y += vy\n            x += vx\n            cnt += 1\n        if cnt <= 1 :\n            break\n        direct = ( direct + 1 ) % 4\n        vx , vy = vector [ direct ]\n        cnt = 0\n    for y in range ( 2 , d + 2 ) :\n        print ( \"\".join ( lst [ y ] [ 2 : - 2 ] ) )\nn = int ( input ( ) )\nmake_guruguru ( int ( input ( ) ) )\nfor _ in range ( n - 1 ) :\n    print ( )\n    make_guruguru ( int ( input ( ) ) )\n", "python_code_tokenized": "vector = ( ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ) NEW_LINE def make_guruguru ( d ) : NEW_LINE INDENT lst = [ [ \" # \" ] * ( d + 4 ) ] NEW_LINE for _ in range ( d + 2 ) : NEW_LINE INDENT lst . append ( [ \" # \" ] + [ \" \u2581 \" ] * ( d + 2 ) + [ \" # \" ] ) NEW_LINE DEDENT lst . append ( [ \" # \" ] * ( d + 4 ) ) NEW_LINE x , y = 2 , d + 1 NEW_LINE lst [ y ] [ x ] = \" # \" NEW_LINE direct = 0 NEW_LINE vx , vy = vector [ 0 ] NEW_LINE cnt = 1 NEW_LINE while True : NEW_LINE INDENT while lst [ y + vy * 2 ] [ x + vx * 2 ] == \" \u2581 \" : NEW_LINE INDENT lst [ y + vy ] [ x + vx ] = \" # \" NEW_LINE y += vy NEW_LINE x += vx NEW_LINE cnt += 1 NEW_LINE DEDENT if cnt <= 1 : NEW_LINE INDENT break NEW_LINE DEDENT direct = ( direct + 1 ) % 4 NEW_LINE vx , vy = vector [ direct ] NEW_LINE cnt = 0 NEW_LINE DEDENT for y in range ( 2 , d + 2 ) : NEW_LINE INDENT print ( \" \" . join ( lst [ y ] [ 2 : - 2 ] ) ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE make_guruguru ( int ( input ( ) ) ) NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT print ( ) NEW_LINE make_guruguru ( int ( input ( ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2674_A", "sol": 0, "python_code": "def lenDoubleString ( s ) :\n    l = len ( s )\n    first_half = s [ 0 : l // 2 ]\n    second_half = \"\"\n    if l % 2 == 0 :\n        second_half = s [ l // 2 : ]\n    else :\n        second_half = s [ l // 2 + 1 : ]\n    second_half = second_half [ : : - 1 ]\n    print ( first_half + second_half )\n    if l % 2 == 0 :\n        print ( l )\n    else :\n        print ( l - 1 )\nif __name__ == \"__main__\" :\n    n = \"abba\"\n    lenDoubleString ( n )\n    n = \"abcdedcba\"\n    lenDoubleString ( n )\n", "python_code_tokenized": "def lenDoubleString ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE first_half = s [ 0 : l // 2 ] NEW_LINE second_half = \" \" NEW_LINE if l % 2 == 0 : NEW_LINE INDENT second_half = s [ l // 2 : ] NEW_LINE DEDENT else : NEW_LINE INDENT second_half = s [ l // 2 + 1 : ] NEW_LINE DEDENT second_half = second_half [ : : - 1 ] NEW_LINE print ( first_half + second_half ) NEW_LINE if l % 2 == 0 : NEW_LINE INDENT print ( l ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l - 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = \" abba \" NEW_LINE lenDoubleString ( n ) NEW_LINE n = \" abcdedcba \" NEW_LINE lenDoubleString ( n ) NEW_LINE DEDENT"}
{"id": "codeforces_1660_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor x in range ( t ) :\n    n = int ( input ( ) )\n    a = list ( map ( int , input ( ).split ( ) ) )\n    if n > 1 :\n        g = max ( a )\n        a.pop ( a.index ( max ( a ) ) )\n        if g - max ( a ) > 1 :\n            print ( 'NO' )\n        else :\n            print ( 'YES' )\n    else :\n        if a [ 0 ] == 1 :\n            print ( 'YES' )\n        else :\n            print ( 'NO' )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for x in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n > 1 : NEW_LINE INDENT g = max ( a ) NEW_LINE a . pop ( a . index ( max ( a ) ) ) NEW_LINE if g - max ( a ) > 1 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ 0 ] == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "codeforces_129_A", "sol": 0, "python_code": "_ = int ( input ( ) )\nbags = [ int ( x ) for x in input ( ).split ( ) ]\npairs = [ x for x in bags if x % 2 == 0 ]\nimpairs = [ x for x in bags if x % 2 == 1 ]\nif sum ( bags ) % 2 == 0 :\n    print ( len ( pairs ) )\nelse :\n    print ( len ( impairs ) )\n", "python_code_tokenized": "_ = int ( input ( ) ) NEW_LINE bags = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE pairs = [ x for x in bags if x % 2 == 0 ] NEW_LINE impairs = [ x for x in bags if x % 2 == 1 ] NEW_LINE if sum ( bags ) % 2 == 0 : NEW_LINE INDENT print ( len ( pairs ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( len ( impairs ) ) NEW_LINE DEDENT"}
{"id": "codeforces_844_B", "sol": 0, "python_code": "n , m = [ int ( k ) for k in input ( ).split ( ) ]\nw = [ ]\nfor j in range ( n ) :\n    w.append ( [ int ( k ) for k in input ( ).split ( ) ] )\nres = n * m\nfor j in w :\n    c = sum ( j )\n    d = m - sum ( j )\n    res += max ( 2 ** c - c - 1 , 0 )\n    res += max ( 2 ** d - d - 1 , 0 )\nfor j in range ( m ) :\n    eta = [ w [ x ] [ j ] for x in range ( n ) ]\n    c = sum ( eta )\n    d = n - sum ( eta )\n    res += max ( 2 ** c - c - 1 , 0 )\n    res += max ( 2 ** d - d - 1 , 0 )\nprint ( res )\n", "python_code_tokenized": "n , m = [ int ( k ) for k in input ( ) . split ( ) ] NEW_LINE w = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT w . append ( [ int ( k ) for k in input ( ) . split ( ) ] ) NEW_LINE DEDENT res = n * m NEW_LINE for j in w : NEW_LINE INDENT c = sum ( j ) NEW_LINE d = m - sum ( j ) NEW_LINE res += max ( 2 ** c - c - 1 , 0 ) NEW_LINE res += max ( 2 ** d - d - 1 , 0 ) NEW_LINE DEDENT for j in range ( m ) : NEW_LINE INDENT eta = [ w [ x ] [ j ] for x in range ( n ) ] NEW_LINE c = sum ( eta ) NEW_LINE d = n - sum ( eta ) NEW_LINE res += max ( 2 ** c - c - 1 , 0 ) NEW_LINE res += max ( 2 ** d - d - 1 , 0 ) NEW_LINE DEDENT print ( res ) NEW_LINE"}
{"id": "codeforces_1651_B", "sol": 0, "python_code": "p = 10 ** 9\nfor _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    if pow ( 3 , n - 1 ) > p :\n        print ( \"NO\" )\n    else :\n        print ( \"YES\" )\n        print ( \" \".join ( [ str ( 3 ** x ) for x in range ( n ) ] ) )\n", "python_code_tokenized": "p = 10 ** 9 NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if pow ( 3 , n - 1 ) > p : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE print ( \" \u2581 \" . join ( [ str ( 3 ** x ) for x in range ( n ) ] ) ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1720_A", "sol": 0, "python_code": "def Centered_Trigunal_num ( n ) :\n    return ( 3 * n * n + 3 * n + 2 ) // 2\nif __name__ == '__main__' :\n    n = 3\n    print ( Centered_Trigunal_num ( n ) )\n    n = 12\n    print ( Centered_Trigunal_num ( n ) )\n", "python_code_tokenized": "def Centered_Trigunal_num ( n ) : NEW_LINE INDENT return ( 3 * n * n + 3 * n + 2 ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( Centered_Trigunal_num ( n ) ) NEW_LINE n = 12 NEW_LINE print ( Centered_Trigunal_num ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1791_A", "sol": 0, "python_code": "def evenPowerSum ( n ) :\n    return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ;\nn = 4 ;\nprint ( int ( evenPowerSum ( n ) ) ) ;\n", "python_code_tokenized": "def evenPowerSum ( n ) : NEW_LINE INDENT return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( int ( evenPowerSum ( n ) ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_3182_A", "sol": 0, "python_code": "def seriesSum ( n ) :\n    return int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 )\nn = 4\nprint ( seriesSum ( n ) )\n", "python_code_tokenized": "def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_840_A", "sol": 0, "python_code": "def angle ( n ) :\n    return 2 * n\nn = 30\nprint ( angle ( n ) )\n", "python_code_tokenized": "def angle ( n ) : NEW_LINE INDENT return 2 * n NEW_LINE DEDENT n = 30 NEW_LINE print ( angle ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_870_A", "sol": 0, "python_code": "def checksum ( n ) :\n    n = int ( n )\n    if n % 5 == 0 :\n        print ( int ( n / 5 - 2 ) , \" \" , int ( n / 5 - 1 ) , \" \" , int ( n / 5 ) , \" \" , int ( n / 5 + 1 ) , \" \" , int ( n / 5 + 2 ) )\n    else :\n        print ( \"-1\" )\nn = 15\nchecksum ( n )\n", "python_code_tokenized": "def checksum ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if n % 5 == 0 : NEW_LINE INDENT print ( int ( n / 5 - 2 ) , \" \u2581 \" , int ( n / 5 - 1 ) , \" \u2581 \" , int ( n / 5 ) , \" \u2581 \" , int ( n / 5 + 1 ) , \" \u2581 \" , int ( n / 5 + 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT n = 15 NEW_LINE checksum ( n ) NEW_LINE"}
{"id": "geeksforgeeks_1715_A", "sol": 0, "python_code": "def pentagon_pyramidal ( n ) :\n    return n * n * ( n + 1 ) / 2\nn = 4\nprint ( int ( pentagon_pyramidal ( n ) ) )\n", "python_code_tokenized": "def pentagon_pyramidal ( n ) : NEW_LINE INDENT return n * n * ( n + 1 ) / 2 NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( pentagon_pyramidal ( n ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_4818_A", "sol": 0, "python_code": "def weightedMean ( n ) :\n    return ( 2 * n + 1 ) / 3\nn = 10\nprint ( int ( weightedMean ( n ) ) )\n", "python_code_tokenized": "def weightedMean ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) / 3 NEW_LINE DEDENT n = 10 NEW_LINE print ( int ( weightedMean ( n ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_1718_A", "sol": 0, "python_code": "def centeredTridecagonalNum ( n ) :\n    return ( 13 * n * ( n - 1 ) + 2 ) // 2\nif __name__ == '__main__' :\n    n = 3\n    print ( centeredTridecagonalNum ( n ) )\n    n = 10\n    print ( centeredTridecagonalNum ( n ) )\n", "python_code_tokenized": "def centeredTridecagonalNum ( n ) : NEW_LINE INDENT return ( 13 * n * ( n - 1 ) + 2 ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( centeredTridecagonalNum ( n ) ) NEW_LINE n = 10 NEW_LINE print ( centeredTridecagonalNum ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4690_A", "sol": 0, "python_code": "def AvgofSquareN ( n ) :\n    return ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ;\nn = 2 ;\nprint ( AvgofSquareN ( n ) ) ;\n", "python_code_tokenized": "def AvgofSquareN ( n ) : NEW_LINE INDENT return ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; NEW_LINE DEDENT n = 2 ; NEW_LINE print ( AvgofSquareN ( n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_3258_A", "sol": 0, "python_code": "def countNumberOfTriangles ( n ) :\n    return ( n * ( n - 1 ) * ( n - 2 ) // 6 )\nif __name__ == '__main__' :\n    n = 4\n    print ( countNumberOfTriangles ( n ) )\n", "python_code_tokenized": "def countNumberOfTriangles ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) * ( n - 2 ) // 6 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( countNumberOfTriangles ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4649_A", "sol": 0, "python_code": "def getResult ( n ) :\n    if n & 1 :\n        return 1\n    return - 1\nn = 3\nprint ( getResult ( n ) )\n", "python_code_tokenized": "def getResult ( n ) : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT n = 3 NEW_LINE print ( getResult ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3959_A", "sol": 0, "python_code": "def heptagonalNumber ( n ) :\n    return ( ( 5 * n * n ) - ( 3 * n ) ) // 2\nif __name__ == '__main__' :\n    n = 2\n    print ( heptagonalNumber ( n ) )\n    n = 15\n    print ( heptagonalNumber ( n ) )\n", "python_code_tokenized": "def heptagonalNumber ( n ) : NEW_LINE INDENT return ( ( 5 * n * n ) - ( 3 * n ) ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( heptagonalNumber ( n ) ) NEW_LINE n = 15 NEW_LINE print ( heptagonalNumber ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3406_A", "sol": 0, "python_code": "def per ( n ) :\n    if ( n == 0 ) :\n        return 3 ;\n    if ( n == 1 ) :\n        return 0 ;\n    if ( n == 2 ) :\n        return 2 ;\n    return per ( n - 2 ) + per ( n - 3 ) ;\nn = 9 ;\nprint ( per ( n ) ) ;\n", "python_code_tokenized": "def per ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 3 ; NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT return per ( n - 2 ) + per ( n - 3 ) ; NEW_LINE DEDENT n = 9 ; NEW_LINE print ( per ( n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_21_A", "sol": 0, "python_code": "def leonardo ( n ) :\n    if ( n == 0 or n == 1 ) :\n        return 1\n    return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ) ;\nprint ( leonardo ( 3 ) )\n", "python_code_tokenized": "def leonardo ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ) ; NEW_LINE DEDENT print ( leonardo ( 3 ) ) NEW_LINE"}
{"id": "geeksforgeeks_2941_A", "sol": 0, "python_code": "import math\ndef binomialCoeffSum ( n ) :\n    return ( 1 << n ) ;\nn = 4\nprint ( binomialCoeffSum ( n ) )\n", "python_code_tokenized": "import math NEW_LINE def binomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << n ) ; NEW_LINE DEDENT n = 4 NEW_LINE print ( binomialCoeffSum ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3946_A", "sol": 0, "python_code": "def countStr ( n ) :\n    return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) // 2 ) )\nif __name__ == \"__main__\" :\n    n = 3\n    print ( countStr ( n ) )\n", "python_code_tokenized": "def countStr ( n ) : NEW_LINE INDENT return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) // 2 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( countStr ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1713_A", "sol": 0, "python_code": "def centeredTetrahedralNumber ( n ) :\n    return ( 2 * n + 1 ) * ( n * n + n + 3 ) // 3\nn = 6\nprint ( centeredTetrahedralNumber ( n ) )\n", "python_code_tokenized": "def centeredTetrahedralNumber ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 3 ) // 3 NEW_LINE DEDENT n = 6 NEW_LINE print ( centeredTetrahedralNumber ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1874_A", "sol": 0, "python_code": "def countSetBits ( n ) :\n    if ( n == 0 ) :\n        return 0\n    else :\n        return ( n & 1 ) + countSetBits ( n >> 1 )\nn = 9\nprint ( countSetBits ( n ) )\n", "python_code_tokenized": "def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n & 1 ) + countSetBits ( n >> 1 ) NEW_LINE DEDENT DEDENT n = 9 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1794_A", "sol": 0, "python_code": "def avgOfFirstN ( n ) :\n    return ( float ) ( 1 + n ) / 2 ;\nn = 20\nprint ( avgOfFirstN ( n ) )\n", "python_code_tokenized": "def avgOfFirstN ( n ) : NEW_LINE INDENT return ( float ) ( 1 + n ) / 2 ; NEW_LINE DEDENT n = 20 NEW_LINE print ( avgOfFirstN ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1876_A", "sol": 0, "python_code": "def countSetBits ( n ) :\n    if ( n == 0 ) :\n        return 0\n    else :\n        return 1 + countSetBits ( n & ( n - 1 ) )\nn = 9\nprint ( countSetBits ( n ) )\n", "python_code_tokenized": "def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countSetBits ( n & ( n - 1 ) ) NEW_LINE DEDENT DEDENT n = 9 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3513_A", "sol": 0, "python_code": "def fib ( n ) :\n    if ( n <= 1 ) :\n        return n\n    return fib ( n - 1 ) + fib ( n - 2 )\nif __name__ == '__main__' :\n    n = 6\n    print ( fib ( n ) )\n", "python_code_tokenized": "def fib ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( fib ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4665_A", "sol": 0, "python_code": "def series ( n ) :\n    print ( ( 8 * n ** 2 ) + 1 )\nseries ( 5 )\n", "python_code_tokenized": "def series ( n ) : NEW_LINE INDENT print ( ( 8 * n ** 2 ) + 1 ) NEW_LINE DEDENT series ( 5 ) NEW_LINE"}
{"id": "geeksforgeeks_3047_A", "sol": 0, "python_code": "def seriesSum ( n ) :\n    return int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 )\nn = 4\nprint ( seriesSum ( n ) )\n", "python_code_tokenized": "def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_908_A", "sol": 0, "python_code": "def checksum ( n ) :\n    n = int ( n )\n    if n % 3 == 0 :\n        print ( int ( n / 3 - 1 ) , \" \" , int ( n / 3 ) , \" \" , int ( n / 3 + 1 ) )\n    else :\n        print ( \"-1\" )\nn = 6\nchecksum ( n )\n", "python_code_tokenized": "def checksum ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if n % 3 == 0 : NEW_LINE INDENT print ( int ( n / 3 - 1 ) , \" \u2581 \" , int ( n / 3 ) , \" \u2581 \" , int ( n / 3 + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE checksum ( n ) NEW_LINE"}
{"id": "geeksforgeeks_1131_A", "sol": 0, "python_code": "def countIntegralSolutions ( n ) :\n    return int ( ( ( n + 1 ) * ( n + 2 ) ) / 2 )\nn = 3\nprint ( countIntegralSolutions ( n ) )\n", "python_code_tokenized": "def countIntegralSolutions ( n ) : NEW_LINE INDENT return int ( ( ( n + 1 ) * ( n + 2 ) ) / 2 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4478_A", "sol": 0, "python_code": "def findCullen ( n ) :\n    return ( 1 << n ) * n + 1\nn = 2\nprint ( findCullen ( n ) )\n", "python_code_tokenized": "def findCullen ( n ) : NEW_LINE INDENT return ( 1 << n ) * n + 1 NEW_LINE DEDENT n = 2 NEW_LINE print ( findCullen ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4793_A", "sol": 0, "python_code": "def avg_of_even_num ( n ) :\n    return n + 1\nn = 8\nprint ( avg_of_even_num ( n ) )\n", "python_code_tokenized": "def avg_of_even_num ( n ) : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT n = 8 NEW_LINE print ( avg_of_even_num ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_2420_A", "sol": 0, "python_code": "def findValueAtX ( n ) :\n    return ( n * n * n ) + n\nprint ( findValueAtX ( 10 ) )\nprint ( findValueAtX ( 2 ) )\n", "python_code_tokenized": "def findValueAtX ( n ) : NEW_LINE INDENT return ( n * n * n ) + n NEW_LINE DEDENT print ( findValueAtX ( 10 ) ) NEW_LINE print ( findValueAtX ( 2 ) ) NEW_LINE"}
{"id": "geeksforgeeks_2886_A", "sol": 0, "python_code": "def fnMod ( n ) :\n    if ( n % 5 == 1 ) :\n        return 4\n    else :\n        return 0\nn = 10\nprint ( fnMod ( n ) )\nn = 11\nprint ( fnMod ( n ) )\n", "python_code_tokenized": "def fnMod ( n ) : NEW_LINE INDENT if ( n % 5 == 1 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE print ( fnMod ( n ) ) NEW_LINE n = 11 NEW_LINE print ( fnMod ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4479_A", "sol": 0, "python_code": "def findStarNum ( n ) :\n    return ( 6 * n * ( n - 1 ) + 1 )\nn = 3\nprint ( findStarNum ( n ) )\n", "python_code_tokenized": "def findStarNum ( n ) : NEW_LINE INDENT return ( 6 * n * ( n - 1 ) + 1 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( findStarNum ( n ) ) NEW_LINE"}
{"id": "codeforces_274_A", "sol": 0, "python_code": "num , k = [ int ( x ) for x in input ( ).split ( ) ]\narr = [ int ( x ) for x in input ( ).split ( ) ]\ndifferent = set ( )\ntemp = 0\narr.sort ( )\nfor x in arr :\n    if ( x % k != 0 or not x // k in different ) :\n        different.add ( x )\n    temp = max ( len ( different ) , temp )\nprint ( temp )\n", "python_code_tokenized": "num , k = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE arr = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE different = set ( ) NEW_LINE temp = 0 NEW_LINE arr . sort ( ) NEW_LINE for x in arr : NEW_LINE INDENT if ( x % k != 0 or not x // k in different ) : NEW_LINE INDENT different . add ( x ) NEW_LINE DEDENT temp = max ( len ( different ) , temp ) NEW_LINE DEDENT print ( temp ) NEW_LINE"}
{"id": "geeksforgeeks_4472_A", "sol": 0, "python_code": "def isPossible ( A , n , H , K ) :\n    time = 0\n    for i in range ( n ) :\n        time += ( A [ i ] - 1 ) // K + 1\n    return time <= H\ndef minJobSpeed ( A , n , H ) :\n    if H < n :\n        return - 1\n    Max = max ( A )\n    lo , hi = 1 , Max\n    while lo < hi :\n        mi = lo + ( hi - lo ) // 2\n        if not isPossible ( A , n , H , mi ) :\n            lo = mi + 1\n        else :\n            hi = mi\n    return lo\nif __name__ == \"__main__\" :\n    A = [ 3 , 6 , 7 , 11 ]\n    H = 8\n    n = len ( A )\n    print ( minJobSpeed ( A , n , H ) )\n", "python_code_tokenized": "def isPossible ( A , n , H , K ) : NEW_LINE INDENT time = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT time += ( A [ i ] - 1 ) // K + 1 NEW_LINE DEDENT return time <= H NEW_LINE DEDENT def minJobSpeed ( A , n , H ) : NEW_LINE INDENT if H < n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT Max = max ( A ) NEW_LINE lo , hi = 1 , Max NEW_LINE while lo < hi : NEW_LINE INDENT mi = lo + ( hi - lo ) // 2 NEW_LINE if not isPossible ( A , n , H , mi ) : NEW_LINE INDENT lo = mi + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mi NEW_LINE DEDENT DEDENT return lo NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 3 , 6 , 7 , 11 ] NEW_LINE H = 8 NEW_LINE n = len ( A ) NEW_LINE print ( minJobSpeed ( A , n , H ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3890_A", "sol": 0, "python_code": "class Node :\n    def __init__ ( self , next = None , prev = None , data = None ) :\n        self.next = next\n        self.prev = prev\n        self.data = data\ndef push ( head , new_data ) :\n    new_node = Node ( data = new_data )\n    new_node.next = head\n    new_node.prev = None\n    if head is not None :\n        head.prev = new_node\n    head = new_node\n    return head\ndef printList ( head ) :\n    node = head\n    print ( \"Given linked list\" )\n    while ( node is not None ) :\n        print ( node.data , end = \" \" ) ,\n        last = node\n        node = node.next\ndef rotate ( start , N ) :\n    if N == 0 :\n        return\n    current = start\n    count = 1\n    while count < N and current != None :\n        current = current.next\n        count += 1\n    if current == None :\n        return\n    NthNode = current\n    while current.next != None :\n        current = current.next\n    current.next = start\n    start.prev = current\n    start = NthNode.next\n    start.prev = None\n    NthNode.next = None\n    return start\nif __name__ == \"__main__\" :\n    head = None\n    head = push ( head , 'e' )\n    head = push ( head , 'd' )\n    head = push ( head , 'c' )\n    head = push ( head , 'b' )\n    head = push ( head , 'a' )\n    printList ( head )\n    print ( \"\\n\" )\n    N = 2\n    head = rotate ( head , N )\n    printList ( head )\n", "python_code_tokenized": "class Node : NEW_LINE INDENT def __init__ ( self , next = None , prev = None , data = None ) : NEW_LINE INDENT self . next = next NEW_LINE self . prev = prev NEW_LINE self . data = data NEW_LINE DEDENT DEDENT def push ( head , new_data ) : NEW_LINE INDENT new_node = Node ( data = new_data ) NEW_LINE new_node . next = head NEW_LINE new_node . prev = None NEW_LINE if head is not None : NEW_LINE INDENT head . prev = new_node NEW_LINE DEDENT head = new_node NEW_LINE return head NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT node = head NEW_LINE print ( \" Given \u2581 linked \u2581 list \" ) NEW_LINE while ( node is not None ) : NEW_LINE INDENT print ( node . data , end = \" \u2581 \" ) , NEW_LINE last = node NEW_LINE node = node . next NEW_LINE DEDENT DEDENT def rotate ( start , N ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return NEW_LINE DEDENT current = start NEW_LINE count = 1 NEW_LINE while count < N and current != None : NEW_LINE INDENT current = current . next NEW_LINE count += 1 NEW_LINE DEDENT if current == None : NEW_LINE INDENT return NEW_LINE DEDENT NthNode = current NEW_LINE while current . next != None : NEW_LINE INDENT current = current . next NEW_LINE DEDENT current . next = start NEW_LINE start . prev = current NEW_LINE start = NthNode . next NEW_LINE start . prev = None NEW_LINE NthNode . next = None NEW_LINE return start NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT head = None NEW_LINE head = push ( head , ' e ' ) NEW_LINE head = push ( head , ' d ' ) NEW_LINE head = push ( head , ' c ' ) NEW_LINE head = push ( head , ' b ' ) NEW_LINE head = push ( head , ' a ' ) NEW_LINE printList ( head ) NEW_LINE print ( \" \\n \" ) NEW_LINE N = 2 NEW_LINE head = rotate ( head , N ) NEW_LINE printList ( head ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1433_A", "sol": 0, "python_code": "MAX = 100001 ;\nprefix = [ 0 ] * MAX ;\ndef sieve_modified ( ) :\n    for i in range ( 1 , MAX , 2 ) :\n        for j in range ( i , MAX , i ) :\n            prefix [ j ] += i ;\n    for i in range ( 1 , MAX ) :\n        prefix [ i ] += prefix [ i - 1 ] ;\ndef sumOddFactors ( L , R ) :\n    return ( prefix [ R ] - prefix [ L - 1 ] ) ;\nsieve_modified ( ) ;\nl = 6 ;\nr = 10 ;\nprint ( sumOddFactors ( l , r ) ) ;\n", "python_code_tokenized": "MAX = 100001 ; NEW_LINE prefix = [ 0 ] * MAX ; NEW_LINE def sieve_modified ( ) : NEW_LINE INDENT for i in range ( 1 , MAX , 2 ) : NEW_LINE INDENT for j in range ( i , MAX , i ) : NEW_LINE INDENT prefix [ j ] += i ; NEW_LINE DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT prefix [ i ] += prefix [ i - 1 ] ; NEW_LINE DEDENT DEDENT def sumOddFactors ( L , R ) : NEW_LINE INDENT return ( prefix [ R ] - prefix [ L - 1 ] ) ; NEW_LINE DEDENT sieve_modified ( ) ; NEW_LINE l = 6 ; NEW_LINE r = 10 ; NEW_LINE print ( sumOddFactors ( l , r ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_717_A", "sol": 0, "python_code": "def findpair ( l , r ) :\n    ans1 = l\n    ans2 = 2 * l\n    print ( ans1 , \", \" , ans2 )\nif __name__ == '__main__' :\n    l , r = 1 , 10\n    findpair ( l , r )\n", "python_code_tokenized": "def findpair ( l , r ) : NEW_LINE INDENT ans1 = l NEW_LINE ans2 = 2 * l NEW_LINE print ( ans1 , \" , \u2581 \" , ans2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l , r = 1 , 10 NEW_LINE findpair ( l , r ) NEW_LINE DEDENT"}
{"id": "aizu_p00516_A", "sol": 0, "python_code": "def main ( ) :\n    n , m = map ( int , input ( ).split ( ) )\n    A = [ int ( input ( ) ) for _ in range ( n ) ]\n    V = [ 0 for _ in range ( n ) ]\n    M = 0\n    ans = 0\n    for i in range ( m ) :\n        b = int ( input ( ) )\n        for j in range ( n ) :\n            if A [ j ] <= b :\n                V [ j ] += 1\n                if M < V [ j ] :\n                    M += 1\n                    ans = j\n                break\n    print ( ans + 1 )\nmain ( )\n", "python_code_tokenized": "def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE V = [ 0 for _ in range ( n ) ] NEW_LINE M = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT b = int ( input ( ) ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT if A [ j ] <= b : NEW_LINE INDENT V [ j ] += 1 NEW_LINE if M < V [ j ] : NEW_LINE INDENT M += 1 NEW_LINE ans = j NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT DEDENT print ( ans + 1 ) NEW_LINE DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_2405_A", "sol": 0, "python_code": "import sys\ndef solve ( arr , n , k ) :\n    m = { } ;\n    for i in range ( 0 , n - 1 ) :\n        if ( arr [ i ] in m.keys ( ) ) :\n            m [ arr [ i ] ] += 1 ;\n        else :\n            m [ arr [ i ] ] = 1 ;\n        i += 1 ;\n    max = sys.maxsize ;\n    for i in range ( 0 , n - 1 ) :\n        if ( m [ arr [ i ] ] == k and max == sys.maxsize ) :\n            max = arr [ i ] ;\n        elif ( m [ arr [ i ] ] == k and max < arr [ i ] ) :\n            max = arr [ i ] ;\n        i += 1\n    if ( max == sys.maxsize ) :\n        print ( \"No such element\" ) ;\n    else :\n        print ( max ) ;\narr = [ 1 , 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 , 6 , 6 ]\nk = 4 ;\nn = len ( arr )\nsolve ( arr , n , k )\n", "python_code_tokenized": "import sys NEW_LINE def solve ( arr , n , k ) : NEW_LINE INDENT m = { } ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] in m . keys ( ) ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT max = sys . maxsize ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( m [ arr [ i ] ] == k and max == sys . maxsize ) : NEW_LINE INDENT max = arr [ i ] ; NEW_LINE DEDENT elif ( m [ arr [ i ] ] == k and max < arr [ i ] ) : NEW_LINE INDENT max = arr [ i ] ; NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( max == sys . maxsize ) : NEW_LINE INDENT print ( \" No \u2581 such \u2581 element \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ) ; NEW_LINE DEDENT DEDENT arr = [ 1 , 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 , 6 , 6 ] NEW_LINE k = 4 ; NEW_LINE n = len ( arr ) NEW_LINE solve ( arr , n , k ) NEW_LINE"}
{"id": "leetcode_434_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def countSegments ( self , s ) :\n        segment_count = 0\n        for i in range ( len ( s ) ) :\n            if ( i == 0 or s [ i - 1 ] == ' ' ) and s [ i ] != ' ' :\n                segment_count += 1\n        return segment_count\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def countSegments ( self , s ) : NEW_LINE INDENT segment_count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( i == 0 or s [ i - 1 ] == ' \u2581 ' ) and s [ i ] != ' \u2581 ' : NEW_LINE INDENT segment_count += 1 NEW_LINE DEDENT DEDENT return segment_count NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00474_A", "sol": 0, "python_code": "def orderN ( N , L , ices ) :\n    upPeak = L - ices [ 0 ]\n    downPeak = L - ices [ 0 ]\n    peaks = [ ]\n    for i in xrange ( len ( ices ) ) :\n        if i < N - 1 :\n            if ices [ i ] < ices [ i + 1 ] :\n                peaks.append ( downPeak )\n                downPeak = L - ices [ i + 1 ]\n                upPeak += L - ices [ i + 1 ]\n            else :\n                peaks.append ( upPeak )\n                upPeak = L - ices [ i + 1 ]\n                downPeak += L - ices [ i + 1 ]\n        else :\n            peaks.append ( upPeak )\n            peaks.append ( downPeak )\n    print ( max ( peaks ) )\nN , L = map ( int , raw_input ( ).strip ( ).split ( ) )\nices = [ int ( raw_input ( ).strip ( ) ) for _ in xrange ( N ) ]\norderN ( N , L , ices )\n", "python_code_tokenized": "def orderN ( N , L , ices ) : NEW_LINE INDENT upPeak = L - ices [ 0 ] NEW_LINE downPeak = L - ices [ 0 ] NEW_LINE peaks = [ ] NEW_LINE for i in xrange ( len ( ices ) ) : NEW_LINE INDENT if i < N - 1 : NEW_LINE INDENT if ices [ i ] < ices [ i + 1 ] : NEW_LINE INDENT peaks . append ( downPeak ) NEW_LINE downPeak = L - ices [ i + 1 ] NEW_LINE upPeak += L - ices [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT peaks . append ( upPeak ) NEW_LINE upPeak = L - ices [ i + 1 ] NEW_LINE downPeak += L - ices [ i + 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT peaks . append ( upPeak ) NEW_LINE peaks . append ( downPeak ) NEW_LINE DEDENT DEDENT print ( max ( peaks ) ) NEW_LINE DEDENT N , L = map ( int , raw_input ( ) . strip ( ) . split ( ) ) NEW_LINE ices = [ int ( raw_input ( ) . strip ( ) ) for _ in xrange ( N ) ] NEW_LINE orderN ( N , L , ices ) NEW_LINE"}
{"id": "atcoder_ABC073_A", "sol": 0, "python_code": "N = str ( input ( ) )\ntry :\n    N.index ( \"9\" )\n    print ( \"Yes\" )\nexcept ValueError :\n    print ( \"No\" )\n", "python_code_tokenized": "N = str ( input ( ) ) NEW_LINE try : NEW_LINE INDENT N . index ( \"9\" ) NEW_LINE print ( \" Yes \" ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1149_A", "sol": 0, "python_code": "def isPossible ( A , n , k ) :\n    countOfTwo = 0\n    for i in range ( n ) :\n        if ( A [ i ] % 2 == 0 ) :\n            countOfTwo += 1\n    if ( k == 0 and countOfTwo == n ) :\n        print ( \"NO\\n\" )\n    elif ( countOfTwo >= k ) :\n        print ( \"Yes\\n\" )\n    else :\n        print ( \"No\\n\" )\nif __name__ == '__main__' :\n    arr = [ 1 , 2 , 4 , 5 ]\n    K = 2\n    N = len ( arr )\n    isPossible ( arr , N , K )\n", "python_code_tokenized": "def isPossible ( A , n , k ) : NEW_LINE INDENT countOfTwo = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT countOfTwo += 1 NEW_LINE DEDENT DEDENT if ( k == 0 and countOfTwo == n ) : NEW_LINE INDENT print ( \" NO \\n \" ) NEW_LINE DEDENT elif ( countOfTwo >= k ) : NEW_LINE INDENT print ( \" Yes \\n \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \\n \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 ] NEW_LINE K = 2 NEW_LINE N = len ( arr ) NEW_LINE isPossible ( arr , N , K ) NEW_LINE DEDENT"}
{"id": "codeforces_492_A", "sol": 0, "python_code": "cubes , high , count_cubes = int ( input ( ) ) , 0 , 0\nwhile count_cubes + ( high * ( high + 1 ) / 2 ) + high + 1 <= cubes :\n    high += 1\n    count_cubes += high * ( high + 1 ) / 2\nprint ( high )\n", "python_code_tokenized": "cubes , high , count_cubes = int ( input ( ) ) , 0 , 0 NEW_LINE while count_cubes + ( high * ( high + 1 ) / 2 ) + high + 1 <= cubes : NEW_LINE INDENT high += 1 NEW_LINE count_cubes += high * ( high + 1 ) / 2 NEW_LINE DEDENT print ( high ) NEW_LINE"}
{"id": "geeksforgeeks_2023_A", "sol": 0, "python_code": "def find_Solution ( x , n ) :\n    Sum = x\n    e = 2\n    o = 1\n    p = 1\n    for i in range ( 2 , n + 1 ) :\n        p += 2\n        Sum += ( o / e ) * ( pow ( x , p ) / p )\n        o = o * ( o + 2 )\n        e = e * ( e + 2 )\n    print ( round ( Sum , 10 ) )\nx = - 0.5\nif ( abs ( x ) >= 1 ) :\n    print ( \"Invalid Input\\n\" )\nn = 8\nfind_Solution ( x , n )\n", "python_code_tokenized": "def find_Solution ( x , n ) : NEW_LINE INDENT Sum = x NEW_LINE e = 2 NEW_LINE o = 1 NEW_LINE p = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT p += 2 NEW_LINE Sum += ( o / e ) * ( pow ( x , p ) / p ) NEW_LINE o = o * ( o + 2 ) NEW_LINE e = e * ( e + 2 ) NEW_LINE DEDENT print ( round ( Sum , 10 ) ) NEW_LINE DEDENT x = - 0.5 NEW_LINE if ( abs ( x ) >= 1 ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \\n \" ) NEW_LINE DEDENT n = 8 NEW_LINE find_Solution ( x , n ) NEW_LINE"}
{"id": "aizu_p00354_A", "sol": 0, "python_code": "days = [ \"thu\" , \"fri\" , \"sat\" , \"sun\" , \"mon\" , \"tue\" , \"wed\" ]\na = int ( input ( ) )\nprint ( days [ a % 7 ] )\n", "python_code_tokenized": "days = [ \" thu \" , \" fri \" , \" sat \" , \" sun \" , \" mon \" , \" tue \" , \" wed \" ] NEW_LINE a = int ( input ( ) ) NEW_LINE print ( days [ a % 7 ] ) NEW_LINE"}
{"id": "codeforces_701_B", "sol": 0, "python_code": "n , m = list ( map ( int , input ( ).split ( ) ) )\nr = set ( [ ] )\nc = set ( [ ] )\ns = \"\"\nfor i in range ( m ) :\n    x , y = list ( map ( int , input ( ).split ( ) ) )\n    r.add ( y )\n    c.add ( x )\n    t = n ** 2 - ( len ( r ) * n + len ( c ) * ( n - len ( r ) ) )\n    s += str ( t ) + \" \"\nprint ( s [ : - 1 ] )\n", "python_code_tokenized": "n , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = set ( [ ] ) NEW_LINE c = set ( [ ] ) NEW_LINE s = \" \" NEW_LINE for i in range ( m ) : NEW_LINE INDENT x , y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r . add ( y ) NEW_LINE c . add ( x ) NEW_LINE t = n ** 2 - ( len ( r ) * n + len ( c ) * ( n - len ( r ) ) ) NEW_LINE s += str ( t ) + \" \u2581 \" NEW_LINE DEDENT print ( s [ : - 1 ] ) NEW_LINE"}
{"id": "atcoder_ABC128_E", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nn , Q = map ( int , input ( ).split ( ) )\nb_num = 2 ** ( n - 1 ).bit_length ( )\nmx = 10 ** 9\nsegl = [ mx ] * 2 * b_num\ndef update ( k , x ) :\n    k += b_num - 1\n    segl [ k ] = x\n    while k + 1 :\n        k = ( k - 1 ) // 2\n        segl [ k ] = min ( segl [ k * 2 + 1 ] , segl [ k * 2 + 2 ] )\nif __name__ == '__main__' :\n    xs = [ ]\n    for i in range ( n ) :\n        s , t , x = map ( int , input ( ).split ( ) )\n        xs += [ ( s - x , True , x , i ) , ( t - x , False , x , i ) ]\n    qs = [ ]\n    for _ in range ( Q ) :\n        qs.append ( int ( input ( ) ) )\n    xs.sort ( key = lambda x : x [ 0 ] )\n    j = 0\n    for x in xs :\n        while Q - j :\n            if qs [ j ] < x [ 0 ] :\n                print ( segl [ 0 ] if segl [ 0 ] != mx else - 1 )\n                j += 1\n                continue\n            break\n        update ( x [ 3 ] , x [ 2 ] if x [ 1 ] else mx )\n    while Q - j :\n        print ( - 1 )\n        j += 1\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , Q = map ( int , input ( ) . split ( ) ) NEW_LINE b_num = 2 ** ( n - 1 ) . bit_length ( ) NEW_LINE mx = 10 ** 9 NEW_LINE segl = [ mx ] * 2 * b_num NEW_LINE def update ( k , x ) : NEW_LINE INDENT k += b_num - 1 NEW_LINE segl [ k ] = x NEW_LINE while k + 1 : NEW_LINE INDENT k = ( k - 1 ) // 2 NEW_LINE segl [ k ] = min ( segl [ k * 2 + 1 ] , segl [ k * 2 + 2 ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT xs = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , t , x = map ( int , input ( ) . split ( ) ) NEW_LINE xs += [ ( s - x , True , x , i ) , ( t - x , False , x , i ) ] NEW_LINE DEDENT qs = [ ] NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT qs . append ( int ( input ( ) ) ) NEW_LINE DEDENT xs . sort ( key = lambda x : x [ 0 ] ) NEW_LINE j = 0 NEW_LINE for x in xs : NEW_LINE INDENT while Q - j : NEW_LINE INDENT if qs [ j ] < x [ 0 ] : NEW_LINE INDENT print ( segl [ 0 ] if segl [ 0 ] != mx else - 1 ) NEW_LINE j += 1 NEW_LINE continue NEW_LINE DEDENT break NEW_LINE DEDENT update ( x [ 3 ] , x [ 2 ] if x [ 1 ] else mx ) NEW_LINE DEDENT while Q - j : NEW_LINE INDENT print ( - 1 ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT"}
{"id": "codejam_15_21", "sol": 0, "python_code": "def f ( n ) :\n    if n == 1 :\n        return 1\n    if str ( n ) [ - 1 ] == \"0\" :\n        return 1 + f ( n - 1 )\n    s = str ( n )\n    k = int ( \"1\" + ( len ( s ) - 1 ) * \"0\" )\n    a = - k\n    b = 0\n    for i in range ( len ( s ) ) :\n        a += int ( s [ ~ i ] ) * 10 ** i\n        b += int ( s [ ~ i ] ) * 10 ** min ( i , len ( s ) - i - 1 )\n    return min ( a , b ) + f ( k )\nwith open ( \"A-large.in\" ) as infile :\n    with open ( \"A.out\" , \"w\" ) as outfile :\n        ncases = int ( next ( infile ) )\n        for case in range ( 1 , ncases + 1 ) :\n            n = int ( next ( infile ) )\n            print ( \"Case #{}: {}\".format ( case , f ( n ) ) , file = outfile )\n", "python_code_tokenized": "def f ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if str ( n ) [ - 1 ] == \"0\" : NEW_LINE INDENT return 1 + f ( n - 1 ) NEW_LINE DEDENT s = str ( n ) NEW_LINE k = int ( \"1\" + ( len ( s ) - 1 ) * \"0\" ) NEW_LINE a = - k NEW_LINE b = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT a += int ( s [ ~ i ] ) * 10 ** i NEW_LINE b += int ( s [ ~ i ] ) * 10 ** min ( i , len ( s ) - i - 1 ) NEW_LINE DEDENT return min ( a , b ) + f ( k ) NEW_LINE DEDENT with open ( \" A - large . in \" ) as infile : NEW_LINE INDENT with open ( \" A . out \" , \" w \" ) as outfile : NEW_LINE INDENT ncases = int ( next ( infile ) ) NEW_LINE for case in range ( 1 , ncases + 1 ) : NEW_LINE INDENT n = int ( next ( infile ) ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case , f ( n ) ) , file = outfile ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_4988_A", "sol": 0, "python_code": "import math as mt\ndef solveQuery ( start , end , arr ) :\n    frequency = dict ( )\n    for i in range ( start , end + 1 ) :\n        if arr [ i ] in frequency.keys ( ) :\n            frequency [ arr [ i ] ] += 1\n        else :\n            frequency [ arr [ i ] ] = 1\n    count = 0\n    for x in frequency :\n        if x == frequency [ x ] :\n            count += 1\n    return count\nA = [ 1 , 2 , 2 , 3 , 3 , 3 ]\nn = len ( A )\nqueries = [ [ 0 , 1 ] , [ 1 , 1 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 3 , 5 ] , [ 0 , 5 ] ]\nq = len ( queries )\nfor i in range ( q ) :\n    start = queries [ i ] [ 0 ]\n    end = queries [ i ] [ 1 ]\n    print ( \"Answer for Query \" , ( i + 1 ) , \" = \" , solveQuery ( start , end , A ) )\n", "python_code_tokenized": "import math as mt NEW_LINE def solveQuery ( start , end , arr ) : NEW_LINE INDENT frequency = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] in frequency . keys ( ) : NEW_LINE INDENT frequency [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT frequency [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for x in frequency : NEW_LINE INDENT if x == frequency [ x ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT A = [ 1 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE n = len ( A ) NEW_LINE queries = [ [ 0 , 1 ] , [ 1 , 1 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 3 , 5 ] , [ 0 , 5 ] ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT start = queries [ i ] [ 0 ] NEW_LINE end = queries [ i ] [ 1 ] NEW_LINE print ( \" Answer \u2581 for \u2581 Query \u2581 \" , ( i + 1 ) , \" \u2581 = \u2581 \" , solveQuery ( start , end , A ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3858_A", "sol": 0, "python_code": "def No_Of_Pairs ( N ) :\n    i = 1 ;\n    while ( ( i * i * i ) + ( 2 * i * i ) + i <= N ) :\n        i += 1 ;\n    return ( i - 1 ) ;\ndef print_pairs ( pairs ) :\n    i = 1 ;\n    mul = 0 ;\n    for i in range ( 1 , pairs + 1 ) :\n        mul = i * ( i + 1 ) ;\n        print ( \"Pair no.\" , i , \" --> (\" , ( mul * i ) , \", \" , mul * ( i + 1 ) , \")\" ) ;\nN = 500 ;\ni = 1 ;\npairs = No_Of_Pairs ( N ) ;\nprint ( \"No.of pairs = \" , pairs ) ;\nprint_pairs ( pairs ) ;\n", "python_code_tokenized": "def No_Of_Pairs ( N ) : NEW_LINE INDENT i = 1 ; NEW_LINE while ( ( i * i * i ) + ( 2 * i * i ) + i <= N ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT return ( i - 1 ) ; NEW_LINE DEDENT def print_pairs ( pairs ) : NEW_LINE INDENT i = 1 ; NEW_LINE mul = 0 ; NEW_LINE for i in range ( 1 , pairs + 1 ) : NEW_LINE INDENT mul = i * ( i + 1 ) ; NEW_LINE print ( \" Pair \u2581 no . \" , i , \" \u2581 - - > \u2581 ( \" , ( mul * i ) , \" , \u2581 \" , mul * ( i + 1 ) , \" ) \" ) ; NEW_LINE DEDENT DEDENT N = 500 ; NEW_LINE i = 1 ; NEW_LINE pairs = No_Of_Pairs ( N ) ; NEW_LINE print ( \" No . \u2581 of \u2581 pairs \u2581 = \u2581 \" , pairs ) ; NEW_LINE print_pairs ( pairs ) ; NEW_LINE"}
{"id": "geeksforgeeks_4944_A", "sol": 0, "python_code": "def maxNumber ( string , n ) :\n    freq = [ 0 , 0 ]\n    for i in range ( n ) :\n        if ( string [ i ] == 'z' ) :\n            freq [ 0 ] += 1 ;\n        elif ( string [ i ] == 'n' ) :\n            freq [ 1 ] += 1 ;\n    num = \"\" ;\n    for i in range ( freq [ 1 ] ) :\n        num += '1' ;\n    for i in range ( freq [ 0 ] ) :\n        num += '0' ;\n    return num ;\nif __name__ == \"__main__\" :\n    string = \"roenenzooe\" ;\n    n = len ( string ) ;\n    print ( maxNumber ( string , n ) ) ;\n", "python_code_tokenized": "def maxNumber ( string , n ) : NEW_LINE INDENT freq = [ 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( string [ i ] == ' z ' ) : NEW_LINE INDENT freq [ 0 ] += 1 ; NEW_LINE DEDENT elif ( string [ i ] == ' n ' ) : NEW_LINE INDENT freq [ 1 ] += 1 ; NEW_LINE DEDENT DEDENT num = \" \" ; NEW_LINE for i in range ( freq [ 1 ] ) : NEW_LINE INDENT num += '1' ; NEW_LINE DEDENT for i in range ( freq [ 0 ] ) : NEW_LINE INDENT num += '0' ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" roenenzooe \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( maxNumber ( string , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_663_A", "sol": 0, "python_code": "st = set ( )\ndef generateNumbers ( n , num , a , b ) :\n    if ( num > 0 and num < n ) :\n        st.add ( num )\n    if ( num >= n ) :\n        return\n    if ( num * 10 + a > num ) :\n        generateNumbers ( n , num * 10 + a , a , b )\n    generateNumbers ( n , num * 10 + b , a , b )\ndef printNumbers ( n ) :\n    for i in range ( 10 ) :\n        for j in range ( i + 1 , 10 , 1 ) :\n            generateNumbers ( n , 0 , i , j )\n    print ( \"The numbers are:\" , end = \" \" )\n    l = list ( st )\n    for i in l :\n        print ( i , end = \" \" )\nif __name__ == '__main__' :\n    n = 12\n    printNumbers ( n )\n", "python_code_tokenized": "st = set ( ) NEW_LINE def generateNumbers ( n , num , a , b ) : NEW_LINE INDENT if ( num > 0 and num < n ) : NEW_LINE INDENT st . add ( num ) NEW_LINE DEDENT if ( num >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( num * 10 + a > num ) : NEW_LINE INDENT generateNumbers ( n , num * 10 + a , a , b ) NEW_LINE DEDENT generateNumbers ( n , num * 10 + b , a , b ) NEW_LINE DEDENT def printNumbers ( n ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( i + 1 , 10 , 1 ) : NEW_LINE INDENT generateNumbers ( n , 0 , i , j ) NEW_LINE DEDENT DEDENT print ( \" The \u2581 numbers \u2581 are : \" , end = \" \u2581 \" ) NEW_LINE l = list ( st ) NEW_LINE for i in l : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE printNumbers ( n ) NEW_LINE DEDENT"}
{"id": "codeforces_748_A", "sol": 0, "python_code": "[ num_lanes , num_rows , santa_desk ] = map ( int , input ( ).split ( ) )\nif santa_desk % 2 == 0 :\n    l_or_r = \"R\"\n    santa_desk //= 2\nelse :\n    l_or_r = \"L\"\n    santa_desk += 1\n    santa_desk //= 2\nif santa_desk % num_rows == 0 :\n    lane = santa_desk // num_rows\nelse :\n    lane = ( santa_desk // num_rows ) + 1\nrow = santa_desk - ( ( lane - 1 ) * num_rows )\nprint ( lane , end = \" \" )\nprint ( row , end = \" \" )\nprint ( l_or_r )\n", "python_code_tokenized": "[ num_lanes , num_rows , santa_desk ] = map ( int , input ( ) . split ( ) ) NEW_LINE if santa_desk % 2 == 0 : NEW_LINE INDENT l_or_r = \" R \" NEW_LINE santa_desk //= 2 NEW_LINE DEDENT else : NEW_LINE INDENT l_or_r = \" L \" NEW_LINE santa_desk += 1 NEW_LINE santa_desk //= 2 NEW_LINE DEDENT if santa_desk % num_rows == 0 : NEW_LINE INDENT lane = santa_desk // num_rows NEW_LINE DEDENT else : NEW_LINE INDENT lane = ( santa_desk // num_rows ) + 1 NEW_LINE DEDENT row = santa_desk - ( ( lane - 1 ) * num_rows ) NEW_LINE print ( lane , end = \" \u2581 \" ) NEW_LINE print ( row , end = \" \u2581 \" ) NEW_LINE print ( l_or_r ) NEW_LINE"}
{"id": "codeforces_1012_B", "sol": 0, "python_code": "from sys import stdin\ndef main ( ) :\n    n , m , q = map ( int , input ( ).split ( ) )\n    chm = list ( range ( n + m ) )\n    r = [ 0 ] * ( n + m )\n    n -= 1\n    res = n + m\n    for s in stdin.read ( ).splitlines ( ) :\n        a , b = map ( int , s.split ( ) )\n        a -= 1\n        b += n\n        l = [ ]\n        while a != chm [ a ] :\n            l.append ( a )\n            a = chm [ a ]\n        for c in l :\n            chm [ c ] = a\n        l = [ ]\n        while b != chm [ b ] :\n            l.append ( b )\n            b = chm [ b ]\n        for c in l :\n            chm [ c ] = b\n        if a != b :\n            if r [ a ] < r [ b ] :\n                chm [ a ] = b\n            elif r [ b ] < r [ a ] :\n                chm [ b ] = a\n            else :\n                chm [ a ] = b\n                r [ b ] += 1\n            res -= 1\n    print ( res )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "from sys import stdin NEW_LINE def main ( ) : NEW_LINE INDENT n , m , q = map ( int , input ( ) . split ( ) ) NEW_LINE chm = list ( range ( n + m ) ) NEW_LINE r = [ 0 ] * ( n + m ) NEW_LINE n -= 1 NEW_LINE res = n + m NEW_LINE for s in stdin . read ( ) . splitlines ( ) : NEW_LINE INDENT a , b = map ( int , s . split ( ) ) NEW_LINE a -= 1 NEW_LINE b += n NEW_LINE l = [ ] NEW_LINE while a != chm [ a ] : NEW_LINE INDENT l . append ( a ) NEW_LINE a = chm [ a ] NEW_LINE DEDENT for c in l : NEW_LINE INDENT chm [ c ] = a NEW_LINE DEDENT l = [ ] NEW_LINE while b != chm [ b ] : NEW_LINE INDENT l . append ( b ) NEW_LINE b = chm [ b ] NEW_LINE DEDENT for c in l : NEW_LINE INDENT chm [ c ] = b NEW_LINE DEDENT if a != b : NEW_LINE INDENT if r [ a ] < r [ b ] : NEW_LINE INDENT chm [ a ] = b NEW_LINE DEDENT elif r [ b ] < r [ a ] : NEW_LINE INDENT chm [ b ] = a NEW_LINE DEDENT else : NEW_LINE INDENT chm [ a ] = b NEW_LINE r [ b ] += 1 NEW_LINE DEDENT res -= 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_610_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nminV = min ( a )\nmI = [ i for i in range ( n ) if a [ i ] == minV ]\nnum = minV * n\nmaxDiff = 0\nfor i , j in enumerate ( mI ) :\n    b = min ( len ( mI ) - 1 , i + 1 )\n    if ( mI [ b ] - j > maxDiff ) :\n        maxDiff = mI [ b ] - j - 1\ndiff = max ( n - 1 - mI [ - 1 ] + mI [ 0 ] , maxDiff )\nprint ( num + diff )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE minV = min ( a ) NEW_LINE mI = [ i for i in range ( n ) if a [ i ] == minV ] NEW_LINE num = minV * n NEW_LINE maxDiff = 0 NEW_LINE for i , j in enumerate ( mI ) : NEW_LINE INDENT b = min ( len ( mI ) - 1 , i + 1 ) NEW_LINE if ( mI [ b ] - j > maxDiff ) : NEW_LINE INDENT maxDiff = mI [ b ] - j - 1 NEW_LINE DEDENT DEDENT diff = max ( n - 1 - mI [ - 1 ] + mI [ 0 ] , maxDiff ) NEW_LINE print ( num + diff ) NEW_LINE"}
{"id": "geeksforgeeks_5282_A", "sol": 0, "python_code": "def prime ( n ) :\n    for i in range ( 2 , n + 1 ) :\n        if i * i > n + 1 :\n            break\n        if ( n % i == 0 ) :\n            return False\n    return True\ndef thirdNumber ( a , b ) :\n    summ = 0\n    temp = 0\n    summ = a + b\n    temp = 1\n    if ( summ & 1 ) :\n        temp = 2\n    while ( prime ( summ + temp ) == False ) :\n        temp += 2\n    print ( temp )\na = 3\nb = 5\nthirdNumber ( a , b )\n", "python_code_tokenized": "def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n + 1 : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT summ = 0 NEW_LINE temp = 0 NEW_LINE summ = a + b NEW_LINE temp = 1 NEW_LINE if ( summ & 1 ) : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT while ( prime ( summ + temp ) == False ) : NEW_LINE INDENT temp += 2 NEW_LINE DEDENT print ( temp ) NEW_LINE DEDENT a = 3 NEW_LINE b = 5 NEW_LINE thirdNumber ( a , b ) NEW_LINE"}
{"id": "geeksforgeeks_1928_A", "sol": 0, "python_code": "def Findpermutation ( n ) :\n    a = [ 0 ] * ( n + 1 ) ;\n    a [ 1 ] = n ;\n    for i in range ( 2 , n + 1 ) :\n        a [ i ] = i - 1 ;\n    return a ;\nif __name__ == \"__main__\" :\n    n = 8 ;\n    v = Findpermutation ( n ) ;\n    for i in range ( 1 , n + 1 ) :\n        print ( v [ i ] , end = ' ' ) ;\n", "python_code_tokenized": "def Findpermutation ( n ) : NEW_LINE INDENT a = [ 0 ] * ( n + 1 ) ; NEW_LINE a [ 1 ] = n ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT a [ i ] = i - 1 ; NEW_LINE DEDENT return a ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 ; NEW_LINE v = Findpermutation ( n ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( v [ i ] , end = ' \u2581 ' ) ; NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_903_B", "sol": 0, "python_code": "import math\ninput_1 = input ( ).split ( )\n[ h_1 , a_1 , c_1 ] = list ( map ( int , input_1 ) )\ninput_2 = input ( ).split ( )\n[ h_2 , a_2 ] = list ( map ( int , input_2 ) )\nn_strike = math.ceil ( h_2 / a_1 )\nif n_strike > 1 :\n    n_heal = max ( [ math.ceil ( ( ( n_strike - 1 ) * a_2 - h_1 ) / ( c_1 - a_2 ) + 0.01 ) , 0 ] )\nelse :\n    n_heal = 0\nprint ( n_strike + n_heal )\nfor i in range ( n_heal ) :\n    print ( \"HEAL\" )\nfor i in range ( n_strike ) :\n    print ( \"STRIKE\" )\n", "python_code_tokenized": "import math NEW_LINE input_1 = input ( ) . split ( ) NEW_LINE [ h_1 , a_1 , c_1 ] = list ( map ( int , input_1 ) ) NEW_LINE input_2 = input ( ) . split ( ) NEW_LINE [ h_2 , a_2 ] = list ( map ( int , input_2 ) ) NEW_LINE n_strike = math . ceil ( h_2 / a_1 ) NEW_LINE if n_strike > 1 : NEW_LINE INDENT n_heal = max ( [ math . ceil ( ( ( n_strike - 1 ) * a_2 - h_1 ) / ( c_1 - a_2 ) + 0.01 ) , 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT n_heal = 0 NEW_LINE DEDENT print ( n_strike + n_heal ) NEW_LINE for i in range ( n_heal ) : NEW_LINE INDENT print ( \" HEAL \" ) NEW_LINE DEDENT for i in range ( n_strike ) : NEW_LINE INDENT print ( \" STRIKE \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1606_B", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\ndef solve ( ) :\n    n , k = map ( int , input ( ).split ( ) )\n    cnt = 1\n    ans = 0\n    while cnt <= k and cnt < n :\n        cnt *= 2\n        ans += 1\n    if cnt >= n :\n        return ans\n    else :\n        ans += ( n - cnt ) // k\n        ans += 1 if ( n - cnt ) % k else 0\n        return ans\nfor _ in range ( int ( input ( ) ) ) :\n    print ( solve ( ) )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE cnt = 1 NEW_LINE ans = 0 NEW_LINE while cnt <= k and cnt < n : NEW_LINE INDENT cnt *= 2 NEW_LINE ans += 1 NEW_LINE DEDENT if cnt >= n : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( n - cnt ) // k NEW_LINE ans += 1 if ( n - cnt ) % k else 0 NEW_LINE return ans NEW_LINE DEDENT DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( solve ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2652_A", "sol": 0, "python_code": "def isShuffledSubstring ( A , B ) :\n    n = len ( A )\n    m = len ( B )\n    if ( n > m ) :\n        return False\n    else :\n        A = sorted ( A )\n        for i in range ( m ) :\n            if ( i + n - 1 >= m ) :\n                return False\n            Str = \"\"\n            for j in range ( n ) :\n                Str += ( B [ i + j ] )\n            Str = sorted ( Str )\n            if ( Str == A ) :\n                return True\nif __name__ == '__main__' :\n    Str1 = \"geekforgeeks\"\n    Str2 = \"ekegorfkeegsgeek\"\n    a = isShuffledSubstring ( Str1 , Str2 )\n    if ( a ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "def isShuffledSubstring ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE m = len ( B ) NEW_LINE if ( n > m ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT A = sorted ( A ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( i + n - 1 >= m ) : NEW_LINE INDENT return False NEW_LINE DEDENT Str = \" \" NEW_LINE for j in range ( n ) : NEW_LINE INDENT Str += ( B [ i + j ] ) NEW_LINE DEDENT Str = sorted ( Str ) NEW_LINE if ( Str == A ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Str1 = \" geekforgeeks \" NEW_LINE Str2 = \" ekegorfkeegsgeek \" NEW_LINE a = isShuffledSubstring ( Str1 , Str2 ) NEW_LINE if ( a ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1237_B", "sol": 0, "python_code": "from sys import stdin\ninput = stdin.readline\ncars = int ( input ( ) ) ; enter = list ( map ( int , input ( ).split ( ) ) ) ; out = list ( map ( int , input ( ).split ( ) ) )\nsumm = 0 ; visited = set ( ) ; l = 0 ; r = 0\nwhile l < cars and r < cars :\n    if l > r :\n        r += 1\n    if enter [ l ] in visited :\n        l += 1 ; continue\n    if out [ r ] == enter [ l ] :\n        l += 1 ; r += 1\n    else :\n        visited.add ( out [ r ] ) ; r += 1 ; summ += 1\nprint ( summ )\n", "python_code_tokenized": "from sys import stdin NEW_LINE input = stdin . readline NEW_LINE cars = int ( input ( ) ) ; enter = list ( map ( int , input ( ) . split ( ) ) ) ; out = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE summ = 0 ; visited = set ( ) ; l = 0 ; r = 0 NEW_LINE while l < cars and r < cars : NEW_LINE INDENT if l > r : NEW_LINE INDENT r += 1 NEW_LINE DEDENT if enter [ l ] in visited : NEW_LINE INDENT l += 1 ; continue NEW_LINE DEDENT if out [ r ] == enter [ l ] : NEW_LINE INDENT l += 1 ; r += 1 NEW_LINE DEDENT else : NEW_LINE INDENT visited . add ( out [ r ] ) ; r += 1 ; summ += 1 NEW_LINE DEDENT DEDENT print ( summ ) NEW_LINE"}
{"id": "codeforces_902_B", "sol": 0, "python_code": "import sys\nimport math\ndef get_ints ( ) : return map ( int , sys.stdin.readline ( ).strip ( ).split ( ) )\ndef get_ls ( ) : return list ( map ( int , sys.stdin.readline ( ).strip ( ).split ( ) ) )\ndef test_ok ( ok ) : print ( \"YES\" if ok else \"NO\" )\ndef main ( ) :\n    n = int ( input ( ) )\n    p = get_ls ( )\n    c = get_ls ( )\n    ans = 0\n    for i in range ( 1 , n ) :\n        if c [ i ] != c [ p [ i - 1 ] - 1 ] :\n            ans += 1\n    print ( ans + 1 )\nif __name__ == \"__main__\" :\n    main ( )\n", "python_code_tokenized": "import sys NEW_LINE import math NEW_LINE def get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE def get_ls ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE def test_ok ( ok ) : print ( \" YES \" if ok else \" NO \" ) NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE p = get_ls ( ) NEW_LINE c = get_ls ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if c [ i ] != c [ p [ i - 1 ] - 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_567_A", "sol": 0, "python_code": "n = int ( input ( ) )\ncities = list ( map ( int , input ( ).split ( ) ) )\nfor i in range ( len ( cities ) ) :\n    if i == 0 :\n        print ( abs ( cities [ 0 ] - cities [ 1 ] ) , abs ( cities [ 0 ] - cities [ - 1 ] ) )\n    elif i == len ( cities ) - 1 :\n        print ( abs ( cities [ - 1 ] - cities [ i - 1 ] ) , abs ( cities [ 0 ] - cities [ - 1 ] ) )\n    else :\n        mn = min ( abs ( cities [ i ] - cities [ i - 1 ] ) , abs ( cities [ i ] - cities [ i + 1 ] ) )\n        mx = max ( abs ( cities [ i ] - cities [ 0 ] ) , abs ( cities [ i ] - cities [ - 1 ] ) )\n        print ( mn , mx )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE cities = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( len ( cities ) ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT print ( abs ( cities [ 0 ] - cities [ 1 ] ) , abs ( cities [ 0 ] - cities [ - 1 ] ) ) NEW_LINE DEDENT elif i == len ( cities ) - 1 : NEW_LINE INDENT print ( abs ( cities [ - 1 ] - cities [ i - 1 ] ) , abs ( cities [ 0 ] - cities [ - 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT mn = min ( abs ( cities [ i ] - cities [ i - 1 ] ) , abs ( cities [ i ] - cities [ i + 1 ] ) ) NEW_LINE mx = max ( abs ( cities [ i ] - cities [ 0 ] ) , abs ( cities [ i ] - cities [ - 1 ] ) ) NEW_LINE print ( mn , mx ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_505_A", "sol": 0, "python_code": "MAX = 100 ;\ndef findNature ( a , b , n ) :\n    seq = [ 0 ] * MAX ;\n    seq [ 0 ] = a ;\n    seq [ 1 ] = b ;\n    for i in range ( 2 , n + 1 ) :\n        seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ;\n    return ( seq [ n ] & 1 ) ;\na = 2 ;\nb = 4 ;\nn = 3 ;\nif ( findNature ( a , b , n ) ) :\n    print ( \"Odd\" ) ;\nelse :\n    print ( \"Even\" ) ;\n", "python_code_tokenized": "MAX = 100 ; NEW_LINE def findNature ( a , b , n ) : NEW_LINE INDENT seq = [ 0 ] * MAX ; NEW_LINE seq [ 0 ] = a ; NEW_LINE seq [ 1 ] = b ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; NEW_LINE DEDENT return ( seq [ n ] & 1 ) ; NEW_LINE DEDENT a = 2 ; NEW_LINE b = 4 ; NEW_LINE n = 3 ; NEW_LINE if ( findNature ( a , b , n ) ) : NEW_LINE INDENT print ( \" Odd \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Even \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1992_A", "sol": 0, "python_code": "def largestCoprime ( N ) :\n    if N == 6 :\n        return 1\n    elif N % 4 == 0 :\n        return N // 2 - 1\n    elif N % 2 == 0 :\n        return N // 2 - 2\n    else :\n        return ( N - 1 ) // 2\nif __name__ == \"__main__\" :\n    n = 50\n    print ( largestCoprime ( n ) )\n", "python_code_tokenized": "def largestCoprime ( N ) : NEW_LINE INDENT if N == 6 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif N % 4 == 0 : NEW_LINE INDENT return N // 2 - 1 NEW_LINE DEDENT elif N % 2 == 0 : NEW_LINE INDENT return N // 2 - 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( N - 1 ) // 2 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 50 NEW_LINE print ( largestCoprime ( n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3359_A", "sol": 0, "python_code": "def reverse ( string , length , l , r ) :\n    if ( l < 0 or r >= length or l > r ) :\n        return string ;\n    string = list ( string )\n    while ( l < r ) :\n        c = string [ l ] ;\n        string [ l ] = string [ r ] ;\n        string [ r ] = c ;\n        l += 1 ;\n        r -= 1 ;\n    return \"\".join ( string ) ;\nif __name__ == \"__main__\" :\n    string = \"geeksforgeeks\" ;\n    length = len ( string ) ;\n    l = 5 ; r = 7 ;\n    print ( reverse ( string , length , l , r ) ) ;\n", "python_code_tokenized": "def reverse ( string , length , l , r ) : NEW_LINE INDENT if ( l < 0 or r >= length or l > r ) : NEW_LINE INDENT return string ; NEW_LINE DEDENT string = list ( string ) NEW_LINE while ( l < r ) : NEW_LINE INDENT c = string [ l ] ; NEW_LINE string [ l ] = string [ r ] ; NEW_LINE string [ r ] = c ; NEW_LINE l += 1 ; NEW_LINE r -= 1 ; NEW_LINE DEDENT return \" \" . join ( string ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeksforgeeks \" ; NEW_LINE length = len ( string ) ; NEW_LINE l = 5 ; r = 7 ; NEW_LINE print ( reverse ( string , length , l , r ) ) ; NEW_LINE DEDENT"}
{"id": "aizu_p02404_A", "sol": 0, "python_code": "while True :\n    h , w = [ int ( x ) for x in input ( ).split ( ) ]\n    if h == 0 and w == 0 :\n        break\n    for i in range ( h ) :\n        if i == 0 or i == h - 1 :\n            print ( '#' * w )\n        else :\n            print ( '#' + '.' * ( w - 2 ) + '#' )\n    print ( )\n", "python_code_tokenized": "while True : NEW_LINE INDENT h , w = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if h == 0 and w == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( h ) : NEW_LINE INDENT if i == 0 or i == h - 1 : NEW_LINE INDENT print ( ' # ' * w ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' # ' + ' . ' * ( w - 2 ) + ' # ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5288_A", "sol": 0, "python_code": "def sum ( x , y , n ) :\n    sum1 = ( ( x ** 2 ) * ( x ** ( 2 * n ) - 1 ) ) // ( x ** 2 - 1 )\n    sum2 = ( x * y * ( x ** n * y ** n - 1 ) ) // ( x * y - 1 )\n    return ( sum1 + sum2 )\nif __name__ == '__main__' :\n    x = 2\n    y = 2\n    n = 2\n    print ( sum ( x , y , n ) )\n", "python_code_tokenized": "def sum ( x , y , n ) : NEW_LINE INDENT sum1 = ( ( x ** 2 ) * ( x ** ( 2 * n ) - 1 ) ) // ( x ** 2 - 1 ) NEW_LINE sum2 = ( x * y * ( x ** n * y ** n - 1 ) ) // ( x * y - 1 ) NEW_LINE return ( sum1 + sum2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 2 NEW_LINE y = 2 NEW_LINE n = 2 NEW_LINE print ( sum ( x , y , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3855_A", "sol": 0, "python_code": "def countPairs ( A1 , A2 , n1 , n2 , K ) :\n    res = 0\n    m = dict ( )\n    for i in range ( 0 , n1 ) :\n        if A1 [ i ] not in m.keys ( ) :\n            m [ A1 [ i ] ] = 1\n        else :\n            m [ A1 [ i ] ] = m [ A1 [ i ] ] + 1\n    for i in range ( 0 , n2 ) :\n        temp = K - A2 [ i ]\n        if temp in m.keys ( ) :\n            res = res + 1\n            m [ temp ] = m [ temp ] - 1\n    return res\nA1 = [ 1 , 1 , 3 , 4 , 5 , 6 , 6 ]\nA2 = [ 1 , 4 , 4 , 5 , 7 ]\nK = 10\nn1 = len ( A1 )\nn2 = len ( A2 )\nprint ( countPairs ( A1 , A2 , n1 , n2 , K ) )\n", "python_code_tokenized": "def countPairs ( A1 , A2 , n1 , n2 , K ) : NEW_LINE INDENT res = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT if A1 [ i ] not in m . keys ( ) : NEW_LINE INDENT m [ A1 [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ A1 [ i ] ] = m [ A1 [ i ] ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n2 ) : NEW_LINE INDENT temp = K - A2 [ i ] NEW_LINE if temp in m . keys ( ) : NEW_LINE INDENT res = res + 1 NEW_LINE m [ temp ] = m [ temp ] - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT A1 = [ 1 , 1 , 3 , 4 , 5 , 6 , 6 ] NEW_LINE A2 = [ 1 , 4 , 4 , 5 , 7 ] NEW_LINE K = 10 NEW_LINE n1 = len ( A1 ) NEW_LINE n2 = len ( A2 ) NEW_LINE print ( countPairs ( A1 , A2 , n1 , n2 , K ) ) NEW_LINE"}
{"id": "geeksforgeeks_1762_A", "sol": 0, "python_code": "def intersection ( a , b , n , m ) :\n    i = 0\n    j = 0\n    while ( i < n and j < m ) :\n        if ( a [ i ] > b [ j ] ) :\n            j += 1\n        else :\n            if ( b [ j ] > a [ i ] ) :\n                i += 1\n            else :\n                print ( a [ i ] , end = \" \" )\n                i += 1\n                j += 1\nif __name__ == \"__main__\" :\n    a = [ 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 ]\n    b = [ 3 , 3 , 5 ]\n    n = len ( a )\n    m = len ( b )\n    intersection ( a , b , n , m )\n", "python_code_tokenized": "def intersection ( a , b , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( a [ i ] > b [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( b [ j ] > a [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 ] NEW_LINE b = [ 3 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE intersection ( a , b , n , m ) NEW_LINE DEDENT"}
{"id": "codeforces_459_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = sorted ( list ( map ( int , input ( ).split ( ) ) ) )\nif ( a [ 0 ] == a [ - 1 ] ) :\n    x = a.count ( a [ 0 ] ) * ( a.count ( a [ - 1 ] ) - 1 ) // 2\nelse :\n    x = a.count ( a [ 0 ] ) * a.count ( a [ - 1 ] )\nprint ( a [ - 1 ] - a [ 0 ] , x )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE if ( a [ 0 ] == a [ - 1 ] ) : NEW_LINE INDENT x = a . count ( a [ 0 ] ) * ( a . count ( a [ - 1 ] ) - 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT x = a . count ( a [ 0 ] ) * a . count ( a [ - 1 ] ) NEW_LINE DEDENT print ( a [ - 1 ] - a [ 0 ] , x ) NEW_LINE"}
{"id": "geeksforgeeks_1856_A", "sol": 0, "python_code": "def printArr ( arr , n ) :\n    for i in range ( n ) :\n        print ( arr [ i ] , end = \"\" ) ;\ndef findArrangement ( arr , n ) :\n    if ( n < 2 ) :\n        print ( \"-1\" , end = \"\" ) ;\n        return ;\n    minVal = min ( arr ) ;\n    for i in range ( n ) :\n        if ( arr [ i ] == minVal ) :\n            arr [ i ] , arr [ n - 1 ] = arr [ n - 1 ] , arr [ i ] ;\n            break ;\n    andVal = arr [ 0 ] ;\n    for i in range ( 1 , n - 1 ) :\n        andVal &= arr [ i ] ;\n    if ( andVal == arr [ n - 1 ] ) :\n        printArr ( arr , n ) ;\n    else :\n        print ( \"-1\" ) ;\nif __name__ == \"__main__\" :\n    arr = [ 1 , 5 , 3 , 3 ] ;\n    n = len ( arr ) ;\n    findArrangement ( arr , n ) ;\n", "python_code_tokenized": "def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT def findArrangement ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT minVal = min ( arr ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == minVal ) : NEW_LINE INDENT arr [ i ] , arr [ n - 1 ] = arr [ n - 1 ] , arr [ i ] ; NEW_LINE break ; NEW_LINE DEDENT DEDENT andVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT andVal &= arr [ i ] ; NEW_LINE DEDENT if ( andVal == arr [ n - 1 ] ) : NEW_LINE INDENT printArr ( arr , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findArrangement ( arr , n ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_41_A", "sol": 0, "python_code": "def complement ( number ) :\n    for i in range ( 0 , len ( number ) ) :\n        if ( number [ i ] != '.' ) :\n            a = 9 - int ( number [ i ] )\n            number = ( number [ : i ] + str ( a ) + number [ i + 1 : ] )\n    print ( \"9's complement is : \" , number )\nif __name__ == '__main__' :\n    number = \"345.45\"\n    complement ( number )\n", "python_code_tokenized": "def complement ( number ) : NEW_LINE INDENT for i in range ( 0 , len ( number ) ) : NEW_LINE INDENT if ( number [ i ] != ' . ' ) : NEW_LINE INDENT a = 9 - int ( number [ i ] ) NEW_LINE number = ( number [ : i ] + str ( a ) + number [ i + 1 : ] ) NEW_LINE DEDENT DEDENT print ( \"9 ' s \u2581 complement \u2581 is \u2581 : \u2581 \" , number ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT number = \"345.45\" NEW_LINE complement ( number ) NEW_LINE DEDENT"}
{"id": "aizu_p00845_A", "sol": 0, "python_code": "import math\ndef solve_cos ( star , telescope ) :\n    inner = sum ( [ i * j for i , j in zip ( star , telescope ) ] )\n    dis_star = ( sum ( map ( lambda a : a * a , star ) ) ) ** ( 1 / 2 )\n    dis_telescope = ( sum ( map ( lambda a : a * a , telescope ) ) ) ** ( 1 / 2 )\n    return inner / ( dis_star * dis_telescope )\nwhile True :\n    n = int ( input ( ) )\n    if n == 0 :\n        break\n    stars = [ list ( map ( float , input ( ).split ( ) ) ) for i in range ( n ) ]\n    m = int ( input ( ) )\n    telescopes = [ list ( map ( float , input ( ).split ( ) ) ) for i in range ( m ) ]\n    count = 0\n    for star in stars :\n        for telescope in telescopes :\n            cos1 = solve_cos ( star , telescope [ : - 1 ] )\n            cos2 = math.cos ( telescope [ - 1 ] )\n            if cos2 <= cos1 :\n                count += 1\n                break\n    print ( count )\n", "python_code_tokenized": "import math NEW_LINE def solve_cos ( star , telescope ) : NEW_LINE INDENT inner = sum ( [ i * j for i , j in zip ( star , telescope ) ] ) NEW_LINE dis_star = ( sum ( map ( lambda a : a * a , star ) ) ) ** ( 1 / 2 ) NEW_LINE dis_telescope = ( sum ( map ( lambda a : a * a , telescope ) ) ) ** ( 1 / 2 ) NEW_LINE return inner / ( dis_star * dis_telescope ) NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT stars = [ list ( map ( float , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE m = int ( input ( ) ) NEW_LINE telescopes = [ list ( map ( float , input ( ) . split ( ) ) ) for i in range ( m ) ] NEW_LINE count = 0 NEW_LINE for star in stars : NEW_LINE INDENT for telescope in telescopes : NEW_LINE INDENT cos1 = solve_cos ( star , telescope [ : - 1 ] ) NEW_LINE cos2 = math . cos ( telescope [ - 1 ] ) NEW_LINE if cos2 <= cos1 : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_544_A", "sol": 0, "python_code": "def findPairs ( arr , n , x ) :\n    l = 0 ; r = n - 1\n    result = 0\n    while ( l < r ) :\n        if ( arr [ l ] + arr [ r ] < x ) :\n            result += ( r - l )\n            l += 1\n        else :\n            r -= 1\n    return result\narr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]\nn = len ( arr )\nx = 7\nprint ( findPairs ( arr , n , x ) )\n", "python_code_tokenized": "def findPairs ( arr , n , x ) : NEW_LINE INDENT l = 0 ; r = n - 1 NEW_LINE result = 0 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( arr [ l ] + arr [ r ] < x ) : NEW_LINE INDENT result += ( r - l ) NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE x = 7 NEW_LINE print ( findPairs ( arr , n , x ) ) NEW_LINE"}
{"id": "codeforces_552_B", "sol": 0, "python_code": "n = int ( input ( ) )\ni = 1\ncount = 0\nwhile ( i <= n ) :\n    count += n - i + 1\n    i *= 10\nprint ( count )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE i = 1 NEW_LINE count = 0 NEW_LINE while ( i <= n ) : NEW_LINE INDENT count += n - i + 1 NEW_LINE i *= 10 NEW_LINE DEDENT print ( count ) NEW_LINE"}
{"id": "geeksforgeeks_4151_A", "sol": 0, "python_code": "def SieveofEratosthenes ( prime , p_size ) :\n    prime [ 0 ] = False\n    prime [ 1 ] = False\n    for p in range ( 2 , p_size + 1 ) :\n        if prime [ p ] :\n            for i in range ( p * 2 , p_size + 1 , p ) :\n                prime [ i ] = False\ndef sumProdOfPrimeFreq ( s ) :\n    prime = [ True ] * ( len ( s ) + 2 )\n    SieveofEratosthenes ( prime , len ( s ) + 1 )\n    i = 0\n    j = 0\n    m = dict ( )\n    for i in range ( len ( s ) ) :\n        m [ s [ i ] ] = ( m [ s [ i ] ] + 1 ) if s [ i ] in m else 1\n    s = 0\n    product = 1\n    for it in m :\n        if prime [ m [ it ] ] :\n            s += m [ it ]\n            product *= m [ it ]\n    print ( \"Sum =\" , s )\n    print ( \"Product =\" , product )\nif __name__ == \"__main__\" :\n    s = \"geeksforgeeks\"\n    sumProdOfPrimeFreq ( s )\n", "python_code_tokenized": "def SieveofEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumProdOfPrimeFreq ( s ) : NEW_LINE INDENT prime = [ True ] * ( len ( s ) + 2 ) NEW_LINE SieveofEratosthenes ( prime , len ( s ) + 1 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] = ( m [ s [ i ] ] + 1 ) if s [ i ] in m else 1 NEW_LINE DEDENT s = 0 NEW_LINE product = 1 NEW_LINE for it in m : NEW_LINE INDENT if prime [ m [ it ] ] : NEW_LINE INDENT s += m [ it ] NEW_LINE product *= m [ it ] NEW_LINE DEDENT DEDENT print ( \" Sum \u2581 = \" , s ) NEW_LINE print ( \" Product \u2581 = \" , product ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE sumProdOfPrimeFreq ( s ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5172_A", "sol": 0, "python_code": "_MIN = - 2147483648\n_MAX = 2147483648\nclass newnode :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.left = None\n        self.right = None\ndef getDeepestLeftLeafNode ( root ) :\n    if ( not root ) :\n        return None\n    q = [ ]\n    q.append ( root )\n    result = None\n    while ( len ( q ) ) :\n        temp = q [ 0 ]\n        q.pop ( 0 )\n        if ( temp.left ) :\n            q.append ( temp.left )\n            if ( not temp.left.left and not temp.left.right ) :\n                result = temp.left\n        if ( temp.right ) :\n            q.append ( temp.right )\n    return result\nif __name__ == '__main__' :\n    root = newnode ( 1 )\n    root.left = newnode ( 2 )\n    root.right = newnode ( 3 )\n    root.left.Left = newnode ( 4 )\n    root.right.left = newnode ( 5 )\n    root.right.right = newnode ( 6 )\n    root.right.left.right = newnode ( 7 )\n    root.right.right.right = newnode ( 8 )\n    root.right.left.right.left = newnode ( 9 )\n    root.right.right.right.right = newnode ( 10 )\n    result = getDeepestLeftLeafNode ( root )\n    if result :\n        print ( \"Deepest Left Leaf Node ::\" , result.data )\n    else :\n        print ( \"No result, Left leaf not found\" )\n", "python_code_tokenized": "_MIN = - 2147483648 NEW_LINE _MAX = 2147483648 NEW_LINE class newnode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getDeepestLeftLeafNode ( root ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return None NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE result = None NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE if ( not temp . left . left and not temp . left . right ) : NEW_LINE INDENT result = temp . left NEW_LINE DEDENT DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newnode ( 1 ) NEW_LINE root . left = newnode ( 2 ) NEW_LINE root . right = newnode ( 3 ) NEW_LINE root . left . Left = newnode ( 4 ) NEW_LINE root . right . left = newnode ( 5 ) NEW_LINE root . right . right = newnode ( 6 ) NEW_LINE root . right . left . right = newnode ( 7 ) NEW_LINE root . right . right . right = newnode ( 8 ) NEW_LINE root . right . left . right . left = newnode ( 9 ) NEW_LINE root . right . right . right . right = newnode ( 10 ) NEW_LINE result = getDeepestLeftLeafNode ( root ) NEW_LINE if result : NEW_LINE INDENT print ( \" Deepest \u2581 Left \u2581 Leaf \u2581 Node \u2581 : : \" , result . data ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 result , \u2581 Left \u2581 leaf \u2581 not \u2581 found \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1273_A", "sol": 0, "python_code": "_MIN = - 2147483648\n_MAX = 2147483648\nclass newnode :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.left = None\n        self.right = None\ndef getDeepestRightLeafNode ( root ) :\n    if ( not root ) :\n        return None\n    q = [ ]\n    q.append ( root )\n    result = None\n    while ( len ( q ) ) :\n        temp = q [ 0 ]\n        q.pop ( 0 )\n        if ( temp.left ) :\n            q.append ( temp.left )\n        if ( temp.right ) :\n            q.append ( temp.right )\n            if ( not temp.right.left and not temp.right.right ) :\n                result = temp.right\n    return result\nif __name__ == '__main__' :\n    root = newnode ( 1 )\n    root.left = newnode ( 2 )\n    root.right = newnode ( 3 )\n    root.left.right = newnode ( 4 )\n    root.right.left = newnode ( 5 )\n    root.right.right = newnode ( 6 )\n    root.right.left.right = newnode ( 7 )\n    root.right.right.right = newnode ( 8 )\n    root.right.left.right.left = newnode ( 9 )\n    root.right.right.right.right = newnode ( 10 )\n    result = getDeepestRightLeafNode ( root )\n    if result :\n        print ( \"Deepest Right Leaf Node ::\" , result.data )\n    else :\n        print ( \"No result, right leaf not found\" )\n", "python_code_tokenized": "_MIN = - 2147483648 NEW_LINE _MAX = 2147483648 NEW_LINE class newnode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getDeepestRightLeafNode ( root ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return None NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE result = None NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE if ( not temp . right . left and not temp . right . right ) : NEW_LINE INDENT result = temp . right NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newnode ( 1 ) NEW_LINE root . left = newnode ( 2 ) NEW_LINE root . right = newnode ( 3 ) NEW_LINE root . left . right = newnode ( 4 ) NEW_LINE root . right . left = newnode ( 5 ) NEW_LINE root . right . right = newnode ( 6 ) NEW_LINE root . right . left . right = newnode ( 7 ) NEW_LINE root . right . right . right = newnode ( 8 ) NEW_LINE root . right . left . right . left = newnode ( 9 ) NEW_LINE root . right . right . right . right = newnode ( 10 ) NEW_LINE result = getDeepestRightLeafNode ( root ) NEW_LINE if result : NEW_LINE INDENT print ( \" Deepest \u2581 Right \u2581 Leaf \u2581 Node \u2581 : : \" , result . data ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 result , \u2581 right \u2581 leaf \u2581 not \u2581 found \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4343_A", "sol": 0, "python_code": "def twistedTOH ( n , first , middle , last ) :\n    if ( n == 1 ) :\n        print ( \"Move disk\" , n , \"from rod\" , first , \"to\" , middle , \"and then to\" , last )\n        return\n    twistedTOH ( n - 1 , first , middle , last )\n    print ( \"Move disk\" , n , \"from rod\" , first , \"to\" , middle )\n    twistedTOH ( n - 1 , last , middle , first )\n    print ( \"Move disk\" , n , \"from rod\" , middle , \"to\" , last )\n    twistedTOH ( n - 1 , first , middle , last )\nn = 2\ntwistedTOH ( n , 'A' , 'B' , 'C' )\n", "python_code_tokenized": "def twistedTOH ( n , first , middle , last ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( \" Move \u2581 disk \" , n , \" from \u2581 rod \" , first , \" to \" , middle , \" and \u2581 then \u2581 to \" , last ) NEW_LINE return NEW_LINE DEDENT twistedTOH ( n - 1 , first , middle , last ) NEW_LINE print ( \" Move \u2581 disk \" , n , \" from \u2581 rod \" , first , \" to \" , middle ) NEW_LINE twistedTOH ( n - 1 , last , middle , first ) NEW_LINE print ( \" Move \u2581 disk \" , n , \" from \u2581 rod \" , middle , \" to \" , last ) NEW_LINE twistedTOH ( n - 1 , first , middle , last ) NEW_LINE DEDENT n = 2 NEW_LINE twistedTOH ( n , ' A ' , ' B ' , ' C ' ) NEW_LINE"}
{"id": "geeksforgeeks_5247_A", "sol": 0, "python_code": "from math import log10 , ceil , pow\ndef findPermutation ( n ) :\n    len = ceil ( log10 ( n ) )\n    for i in range ( 0 , len , 1 ) :\n        if n % 2 != 0 :\n            return n\n        else :\n            n = ( ( n / 10 ) + ( n % 10 ) * pow ( 10 , len - i - 1 ) )\n            continue\n    return - 1\nif __name__ == '__main__' :\n    n = 132\n    print ( int ( findPermutation ( n ) ) )\n", "python_code_tokenized": "from math import log10 , ceil , pow NEW_LINE def findPermutation ( n ) : NEW_LINE INDENT len = ceil ( log10 ( n ) ) NEW_LINE for i in range ( 0 , len , 1 ) : NEW_LINE INDENT if n % 2 != 0 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT n = ( ( n / 10 ) + ( n % 10 ) * pow ( 10 , len - i - 1 ) ) NEW_LINE continue NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 132 NEW_LINE print ( int ( findPermutation ( n ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3449_A", "sol": 0, "python_code": "import math ;\nimport sys ;\ndef NthArmstrong ( n ) :\n    count = 0 ;\n    for i in range ( 1 , sys.maxsize ) :\n        num = i ;\n        rem = 0 ;\n        digit = 0 ;\n        sum = 0 ;\n        num = i ;\n        digit = int ( math.log10 ( num ) + 1 ) ;\n        while ( num > 0 ) :\n            rem = num % 10 ;\n            sum = sum + pow ( rem , digit ) ;\n            num = num // 10 ;\n        if ( i == sum ) :\n            count += 1 ;\n        if ( count == n ) :\n            return i ;\nn = 12 ;\nprint ( NthArmstrong ( n ) ) ;\n", "python_code_tokenized": "import math ; NEW_LINE import sys ; NEW_LINE def NthArmstrong ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , sys . maxsize ) : NEW_LINE INDENT num = i ; NEW_LINE rem = 0 ; NEW_LINE digit = 0 ; NEW_LINE sum = 0 ; NEW_LINE num = i ; NEW_LINE digit = int ( math . log10 ( num ) + 1 ) ; NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rem = num % 10 ; NEW_LINE sum = sum + pow ( rem , digit ) ; NEW_LINE num = num // 10 ; NEW_LINE DEDENT if ( i == sum ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT DEDENT n = 12 ; NEW_LINE print ( NthArmstrong ( n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_3845_A", "sol": 0, "python_code": "def noOfMoves ( arr , n ) :\n    cnt = 0\n    maxCnt = 0\n    for i in range ( n ) :\n        if ( arr [ i ] == 1 ) :\n            cnt += 1\n        else :\n            if ( cnt != 0 ) :\n                maxCnt = max ( maxCnt , cnt )\n                cnt = 0\n    print ( maxCnt )\nif __name__ == '__main__' :\n    arr = [ 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 ]\n    N = len ( arr )\n    noOfMoves ( arr , N )\n    arr1 = [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]\n    N = len ( arr1 )\n    noOfMoves ( arr1 , N )\n", "python_code_tokenized": "def noOfMoves ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE maxCnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( cnt != 0 ) : NEW_LINE INDENT maxCnt = max ( maxCnt , cnt ) NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT DEDENT print ( maxCnt ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE noOfMoves ( arr , N ) NEW_LINE arr1 = [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE N = len ( arr1 ) NEW_LINE noOfMoves ( arr1 , N ) NEW_LINE DEDENT"}
{"id": "aizu_p00513_A", "sol": 0, "python_code": "def isOddPrime ( n ) :\n    for i in range ( 3 , int ( n **.5 ) + 1 , 2 ) :\n        if n % i == 0 :\n            return False\n    return True\nans = 0\nfor i in range ( int ( input ( ) ) ) :\n    ans += isOddPrime ( 2 * int ( input ( ) ) + 1 )\nprint ( ans )\n", "python_code_tokenized": "def isOddPrime ( n ) : NEW_LINE INDENT for i in range ( 3 , int ( n ** .5 ) + 1 , 2 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT ans += isOddPrime ( 2 * int ( input ( ) ) + 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "aizu_p00501_A", "sol": 0, "python_code": "n = int ( input ( ) )\ns = input ( )\nt = [ input ( ) for i in range ( n ) ]\nc = 0\nfor tt in t :\n    f = False\n    for i in range ( len ( tt ) ) :\n        for j in range ( len ( tt ) ) [ 1 : ] :\n            f |= s == tt [ i : : j ] [ : len ( s ) ]\n    if f : c += 1\nprint ( c )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = [ input ( ) for i in range ( n ) ] NEW_LINE c = 0 NEW_LINE for tt in t : NEW_LINE INDENT f = False NEW_LINE for i in range ( len ( tt ) ) : NEW_LINE INDENT for j in range ( len ( tt ) ) [ 1 : ] : NEW_LINE INDENT f |= s == tt [ i : : j ] [ : len ( s ) ] NEW_LINE DEDENT DEDENT if f : c += 1 NEW_LINE DEDENT print ( c ) NEW_LINE"}
{"id": "codeforces_26_B", "sol": 0, "python_code": "from sys import stdin\ninput = stdin.readline\nstring = input ( ).strip ( ) ; lenth = 0 ; count = 0\nfor i in string :\n    if i == \"(\" :\n        count += 1\n    else :\n        if count > 0 :\n            count -= 1\n            lenth += 2\nprint ( lenth )\n", "python_code_tokenized": "from sys import stdin NEW_LINE input = stdin . readline NEW_LINE string = input ( ) . strip ( ) ; lenth = 0 ; count = 0 NEW_LINE for i in string : NEW_LINE INDENT if i == \" ( \" : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if count > 0 : NEW_LINE INDENT count -= 1 NEW_LINE lenth += 2 NEW_LINE DEDENT DEDENT DEDENT print ( lenth ) NEW_LINE"}
{"id": "geeksforgeeks_4677_A", "sol": 0, "python_code": "import math\ndef edgeCover ( n ) :\n    result = 0\n    result = math.ceil ( n / 2.0 )\n    return result\nif __name__ == \"__main__\" :\n    n = 5\n    print ( int ( edgeCover ( n ) ) )\n", "python_code_tokenized": "import math NEW_LINE def edgeCover ( n ) : NEW_LINE INDENT result = 0 NEW_LINE result = math . ceil ( n / 2.0 ) NEW_LINE return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE print ( int ( edgeCover ( n ) ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00444_A", "sol": 0, "python_code": "while True :\n    x = int ( input ( ) )\n    y = 1000 - x\n    if x == 0 :\n        break\n    else :\n        a = y // 500\n        b = y % 500\n        c = b // 100\n        d = b % 100\n        e = d // 50\n        f = d % 50\n        g = f // 10\n        h = f % 10\n        i = h // 5\n        j = h % 5\n        k = j // 1\n    print ( a + c + e + g + i + k )\n", "python_code_tokenized": "while True : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE y = 1000 - x NEW_LINE if x == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT a = y // 500 NEW_LINE b = y % 500 NEW_LINE c = b // 100 NEW_LINE d = b % 100 NEW_LINE e = d // 50 NEW_LINE f = d % 50 NEW_LINE g = f // 10 NEW_LINE h = f % 10 NEW_LINE i = h // 5 NEW_LINE j = h % 5 NEW_LINE k = j // 1 NEW_LINE DEDENT print ( a + c + e + g + i + k ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2334_A", "sol": 0, "python_code": "from fractions import gcd\nimport math\ndef LCM ( x , y , z ) :\n    ans = int ( ( x * y ) / ( gcd ( x , y ) ) )\n    return int ( ( z * ans ) / ( gcd ( ans , z ) ) )\ndef findDivisible ( n , x , y , z ) :\n    lcm = LCM ( x , y , z )\n    ndigitnumber = math.pow ( 10 , n - 1 )\n    reminder = ndigitnumber % lcm\n    if reminder == 0 :\n        return ndigitnumber\n    ndigitnumber += lcm - reminder\n    if ndigitnumber < math.pow ( 10 , n ) :\n        return int ( ndigitnumber )\n    else :\n        return 0\nn = 4\nx = 2\ny = 3\nz = 5\nres = findDivisible ( n , x , y , z )\nif res != 0 :\n    print ( res )\nelse :\n    print ( \"Not possible\" )\n", "python_code_tokenized": "from fractions import gcd NEW_LINE import math NEW_LINE def LCM ( x , y , z ) : NEW_LINE INDENT ans = int ( ( x * y ) / ( gcd ( x , y ) ) ) NEW_LINE return int ( ( z * ans ) / ( gcd ( ans , z ) ) ) NEW_LINE DEDENT def findDivisible ( n , x , y , z ) : NEW_LINE INDENT lcm = LCM ( x , y , z ) NEW_LINE ndigitnumber = math . pow ( 10 , n - 1 ) NEW_LINE reminder = ndigitnumber % lcm NEW_LINE if reminder == 0 : NEW_LINE INDENT return ndigitnumber NEW_LINE DEDENT ndigitnumber += lcm - reminder NEW_LINE if ndigitnumber < math . pow ( 10 , n ) : NEW_LINE INDENT return int ( ndigitnumber ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE x = 2 NEW_LINE y = 3 NEW_LINE z = 5 NEW_LINE res = findDivisible ( n , x , y , z ) NEW_LINE if res != 0 : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 possible \" ) NEW_LINE DEDENT"}
{"id": "codeforces_510_A", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\ntemp = 0 ;\nfor i in range ( n ) :\n    if i % 2 == 0 :\n        for j in range ( k ) :\n            print ( \"#\" , end = \"\" )\n        print ( '\\n' , end = \"\" )\n    else :\n        temp += 1\n        for j in range ( k ) :\n            if ( temp % 2 == 1 and j == k - 1 ) :\n                print ( \"#\" , end = \"\" )\n            elif ( temp % 2 == 0 and j == 0 ) :\n                print ( \"#\" , end = \"\" )\n            else :\n                print ( \".\" , end = \"\" )\n        print ( '\\n' , end = \"\" )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE temp = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT print ( \" # \" , end = \" \" ) NEW_LINE DEDENT print ( ' \\n ' , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT temp += 1 NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( temp % 2 == 1 and j == k - 1 ) : NEW_LINE INDENT print ( \" # \" , end = \" \" ) NEW_LINE DEDENT elif ( temp % 2 == 0 and j == 0 ) : NEW_LINE INDENT print ( \" # \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" . \" , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ' \\n ' , end = \" \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_63_A", "sol": 0, "python_code": "def maxOR ( L , R ) :\n    maximum = - 10 ** 9\n    for i in range ( L , R ) :\n        for j in range ( i + 1 , R + 1 ) :\n            maximum = max ( maximum , ( i | j ) )\n    return maximum\nL = 4\nR = 5\nprint ( maxOR ( L , R ) )\n", "python_code_tokenized": "def maxOR ( L , R ) : NEW_LINE INDENT maximum = - 10 ** 9 NEW_LINE for i in range ( L , R ) : NEW_LINE INDENT for j in range ( i + 1 , R + 1 ) : NEW_LINE INDENT maximum = max ( maximum , ( i | j ) ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT L = 4 NEW_LINE R = 5 NEW_LINE print ( maxOR ( L , R ) ) NEW_LINE"}
{"id": "aizu_p01803_A", "sol": 0, "python_code": "li_word = [ \"a\" , \"i\" , \"u\" , \"e\" , \"o\" ]\nwhile True :\n    num = int ( input ( ) )\n    if num == 0 :\n        break\n    else :\n        li = [ ]\n        for i in range ( num ) :\n            name = [ ]\n            airport = list ( input ( ) )\n            for i in range ( len ( airport ) ) :\n                if i == 0 or airport [ i - 1 ] in li_word :\n                    name.append ( airport [ i ] )\n            li.append ( tuple ( name ) )\n        li_set = list ( set ( li ) )\n        if len ( li ) != len ( li_set ) :\n            print ( - 1 )\n        else :\n            a = 0\n            while True :\n                a += 1\n                check = [ ]\n                for i in li :\n                    check.append ( i [ : a ] )\n                if len ( check ) == len ( list ( set ( check ) ) ) :\n                    print ( a )\n                    break\n", "python_code_tokenized": "li_word = [ \" a \" , \" i \" , \" u \" , \" e \" , \" o \" ] NEW_LINE while True : NEW_LINE INDENT num = int ( input ( ) ) NEW_LINE if num == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT li = [ ] NEW_LINE for i in range ( num ) : NEW_LINE INDENT name = [ ] NEW_LINE airport = list ( input ( ) ) NEW_LINE for i in range ( len ( airport ) ) : NEW_LINE INDENT if i == 0 or airport [ i - 1 ] in li_word : NEW_LINE INDENT name . append ( airport [ i ] ) NEW_LINE DEDENT DEDENT li . append ( tuple ( name ) ) NEW_LINE DEDENT li_set = list ( set ( li ) ) NEW_LINE if len ( li ) != len ( li_set ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT a = 0 NEW_LINE while True : NEW_LINE INDENT a += 1 NEW_LINE check = [ ] NEW_LINE for i in li : NEW_LINE INDENT check . append ( i [ : a ] ) NEW_LINE DEDENT if len ( check ) == len ( list ( set ( check ) ) ) : NEW_LINE INDENT print ( a ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT"}
{"id": "codeforces_591_B", "sol": 0, "python_code": "n , m = list ( map ( int , input ( ).split ( ) ) )\ns = input ( ) [ : n ]\nls = { }\nfor c in s :\n    ls [ c ] = c\nfor i in range ( m ) :\n    x , y = input ( ).split ( ) [ : 2 ]\n    if x not in ls :\n        ls [ x ] = x\n    if y not in ls :\n        ls [ y ] = y\n    ls [ x ] , ls [ y ] = ls [ y ] , ls [ x ]\nans = { }\nfor c , v in ls.items ( ) :\n    ans [ v ] = c\nprint ( \"\".join ( [ ans [ c ] for c in s ] ) )\n", "python_code_tokenized": "n , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = input ( ) [ : n ] NEW_LINE ls = { } NEW_LINE for c in s : NEW_LINE INDENT ls [ c ] = c NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT x , y = input ( ) . split ( ) [ : 2 ] NEW_LINE if x not in ls : NEW_LINE INDENT ls [ x ] = x NEW_LINE DEDENT if y not in ls : NEW_LINE INDENT ls [ y ] = y NEW_LINE DEDENT ls [ x ] , ls [ y ] = ls [ y ] , ls [ x ] NEW_LINE DEDENT ans = { } NEW_LINE for c , v in ls . items ( ) : NEW_LINE INDENT ans [ v ] = c NEW_LINE DEDENT print ( \" \" . join ( [ ans [ c ] for c in s ] ) ) NEW_LINE"}
{"id": "projecteuler_p052_A", "sol": 0, "python_code": "import itertools\ndef compute ( ) :\n    cond = lambda i : all ( sorted ( str ( i ) ) == sorted ( str ( j * i ) ) for j in range ( 2 , 7 ) )\n    ans = next ( i for i in itertools.count ( 1 ) if cond ( i ) )\n    return str ( ans )\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT cond = lambda i : all ( sorted ( str ( i ) ) == sorted ( str ( j * i ) ) for j in range ( 2 , 7 ) ) NEW_LINE ans = next ( i for i in itertools . count ( 1 ) if cond ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5162_A", "sol": 0, "python_code": "from math import pow\ndef no_of_characters ( M ) :\n    k = 1\n    while ( True ) :\n        if ( pow ( 2 , k + 1 ) - 2 < M ) :\n            k += 1\n        else :\n            break\n    return k\ndef print_string ( M ) :\n    k = no_of_characters ( M )\n    N = M - ( pow ( 2 , k ) - 2 )\n    while ( k > 0 ) :\n        num = pow ( 2 , k - 1 )\n        if ( num >= N ) :\n            print ( \"A\" , end = \"\" )\n        else :\n            print ( \"B\" , end = \"\" )\n            N -= num\n        k -= 1\n    print ( \"\\n\" , end = \"\" )\nif __name__ == '__main__' :\n    M = 30 ;\n    print_string ( M )\n    M = 55\n    print_string ( M )\n    M = 100\n    print_string ( M )\n", "python_code_tokenized": "from math import pow NEW_LINE def no_of_characters ( M ) : NEW_LINE INDENT k = 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( pow ( 2 , k + 1 ) - 2 < M ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT def print_string ( M ) : NEW_LINE INDENT k = no_of_characters ( M ) NEW_LINE N = M - ( pow ( 2 , k ) - 2 ) NEW_LINE while ( k > 0 ) : NEW_LINE INDENT num = pow ( 2 , k - 1 ) NEW_LINE if ( num >= N ) : NEW_LINE INDENT print ( \" A \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" B \" , end = \" \" ) NEW_LINE N -= num NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT print ( \" \\n \" , end = \" \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = 30 ; NEW_LINE print_string ( M ) NEW_LINE M = 55 NEW_LINE print_string ( M ) NEW_LINE M = 100 NEW_LINE print_string ( M ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC174_D", "sol": 0, "python_code": "N = int ( input ( ) )\nC = list ( input ( ) )\nRCnt = C.count ( \"R\" )\nRCnt2 = C [ : RCnt ].count ( \"R\" )\nprint ( RCnt - RCnt2 )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE C = list ( input ( ) ) NEW_LINE RCnt = C . count ( \" R \" ) NEW_LINE RCnt2 = C [ : RCnt ] . count ( \" R \" ) NEW_LINE print ( RCnt - RCnt2 ) NEW_LINE"}
{"id": "geeksforgeeks_401_A", "sol": 0, "python_code": "def __gcd ( a , b ) :\n    if ( a == 0 or b == 0 ) : return 0\n    if ( a == b ) : return a\n    if ( a > b ) :\n        return __gcd ( a - b , b )\n    return __gcd ( a , b - a )\ndef coprime ( a , b ) :\n    if ( __gcd ( a , b ) == 1 ) :\n        print ( \"Co-Prime\" )\n    else :\n        print ( \"Not Co-Prime\" )\na = 5 ; b = 6\ncoprime ( a , b )\na = 8 ; b = 16\ncoprime ( a , b )\n", "python_code_tokenized": "def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : return 0 NEW_LINE if ( a == b ) : return a NEW_LINE if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def coprime ( a , b ) : NEW_LINE INDENT if ( __gcd ( a , b ) == 1 ) : NEW_LINE INDENT print ( \" Co - Prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Co - Prime \" ) NEW_LINE DEDENT DEDENT a = 5 ; b = 6 NEW_LINE coprime ( a , b ) NEW_LINE a = 8 ; b = 16 NEW_LINE coprime ( a , b ) NEW_LINE"}
{"id": "geeksforgeeks_1187_A", "sol": 0, "python_code": "def minimumChanges ( arr , n ) :\n    changes = 0\n    i = 0\n    while i < n :\n        if arr [ i ] == 1 :\n            j = i + 1\n            while j < n :\n                if arr [ j ] == 0 :\n                    break\n                j += 1\n            i = j - 1\n            changes += 1\n        i += 1\n    return changes\nif __name__ == \"__main__\" :\n    arr = [ 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 ]\n    n = len ( arr )\n    print ( \"Minimum operations:\" , minimumChanges ( arr , n ) )\n", "python_code_tokenized": "def minimumChanges ( arr , n ) : NEW_LINE INDENT changes = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < n : NEW_LINE INDENT if arr [ j ] == 0 : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i = j - 1 NEW_LINE changes += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return changes NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum \u2581 operations : \" , minimumChanges ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_194_A", "sol": 0, "python_code": "def replaceDigit ( x , d1 , d2 ) :\n    result = 0 ;\n    multiply = 1 ;\n    while ( x % 10 > 0 ) :\n        remainder = x % 10 ;\n        if ( remainder == d1 ) :\n            result = ( result + d2 * multiply ) ;\n        else :\n            result = ( result + remainder * multiply ) ;\n        multiply *= 10 ;\n        x = int ( x / 10 ) ;\n    return result ;\nx = 645 ;\nd1 = 6 ;\nd2 = 5 ;\nprint ( replaceDigit ( x , d1 , d2 ) ) ;\n", "python_code_tokenized": "def replaceDigit ( x , d1 , d2 ) : NEW_LINE INDENT result = 0 ; NEW_LINE multiply = 1 ; NEW_LINE while ( x % 10 > 0 ) : NEW_LINE INDENT remainder = x % 10 ; NEW_LINE if ( remainder == d1 ) : NEW_LINE INDENT result = ( result + d2 * multiply ) ; NEW_LINE DEDENT else : NEW_LINE INDENT result = ( result + remainder * multiply ) ; NEW_LINE DEDENT multiply *= 10 ; NEW_LINE x = int ( x / 10 ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT x = 645 ; NEW_LINE d1 = 6 ; NEW_LINE d2 = 5 ; NEW_LINE print ( replaceDigit ( x , d1 , d2 ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_5202_A", "sol": 0, "python_code": "def farthest_min ( a , n ) :\n    suffix_min = [ 0 for i in range ( n ) ]\n    suffix_min [ n - 1 ] = a [ n - 1 ]\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        suffix_min [ i ] = min ( suffix_min [ i + 1 ] , a [ i ] )\n    for i in range ( n ) :\n        low = i + 1\n        high = n - 1\n        ans = - 1\n        while ( low <= high ) :\n            mid = ( low + high ) // 2\n            if ( suffix_min [ mid ] < a [ i ] ) :\n                ans = mid\n                low = mid + 1\n            else :\n                high = mid - 1\n        print ( ans , end = \" \" )\na = [ 3 , 1 , 5 , 2 , 4 ]\nn = len ( a )\nfarthest_min ( a , n )\n", "python_code_tokenized": "def farthest_min ( a , n ) : NEW_LINE INDENT suffix_min = [ 0 for i in range ( n ) ] NEW_LINE suffix_min [ n - 1 ] = a [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffix_min [ i ] = min ( suffix_min [ i + 1 ] , a [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT low = i + 1 NEW_LINE high = n - 1 NEW_LINE ans = - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( suffix_min [ mid ] < a [ i ] ) : NEW_LINE INDENT ans = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT print ( ans , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT a = [ 3 , 1 , 5 , 2 , 4 ] NEW_LINE n = len ( a ) NEW_LINE farthest_min ( a , n ) NEW_LINE"}
{"id": "geeksforgeeks_852_A", "sol": 0, "python_code": "def findOnBulbs ( numberOfBulbs ) :\n    onBulbs = 0\n    bulb = 1\n    person = 1\n    for bulb in range ( 1 , numberOfBulbs + 1 ) :\n        factors = 0\n        for person in range ( 1 , int ( numberOfBulbs ** ( 0.5 ) ) + 1 ) :\n            if bulb % person == 0 :\n                factors += 1\n                if bulb // person != person :\n                    factors += 1\n        if factors % 2 == 1 :\n            print ( \"Light bulb\" , bulb , \"will be on\" )\n            onBulbs += 1\n    return onBulbs\nif __name__ == \"__main__\" :\n    numberOfBulbs = 1000\n    onBulbs = findOnBulbs ( numberOfBulbs )\n    print ( \"Total\" , onBulbs , \"light bulbs will\" , \"be on in the end out of\" , numberOfBulbs , \"light bulbs\" )\n", "python_code_tokenized": "def findOnBulbs ( numberOfBulbs ) : NEW_LINE INDENT onBulbs = 0 NEW_LINE bulb = 1 NEW_LINE person = 1 NEW_LINE for bulb in range ( 1 , numberOfBulbs + 1 ) : NEW_LINE INDENT factors = 0 NEW_LINE for person in range ( 1 , int ( numberOfBulbs ** ( 0.5 ) ) + 1 ) : NEW_LINE INDENT if bulb % person == 0 : NEW_LINE INDENT factors += 1 NEW_LINE if bulb // person != person : NEW_LINE INDENT factors += 1 NEW_LINE DEDENT DEDENT DEDENT if factors % 2 == 1 : NEW_LINE INDENT print ( \" Light \u2581 bulb \" , bulb , \" will \u2581 be \u2581 on \" ) NEW_LINE onBulbs += 1 NEW_LINE DEDENT DEDENT return onBulbs NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT numberOfBulbs = 1000 NEW_LINE onBulbs = findOnBulbs ( numberOfBulbs ) NEW_LINE print ( \" Total \" , onBulbs , \" light \u2581 bulbs \u2581 will \" , \" be \u2581 on \u2581 in \u2581 the \u2581 end \u2581 out \u2581 of \" , numberOfBulbs , \" light \u2581 bulbs \" ) NEW_LINE DEDENT"}
{"id": "leetcode_700_A", "sol": 0, "python_code": "class Solution ( object ) :\n    def searchBST ( self , root , val ) :\n        while root :\n            if root.val == val :\n                return root\n            elif root.val > val :\n                root = root.left\n            else :\n                root = root.right\n        return root\n", "python_code_tokenized": "class Solution ( object ) : NEW_LINE INDENT def searchBST ( self , root , val ) : NEW_LINE INDENT while root : NEW_LINE INDENT if root . val == val : NEW_LINE INDENT return root NEW_LINE DEDENT elif root . val > val : NEW_LINE INDENT root = root . left NEW_LINE DEDENT else : NEW_LINE INDENT root = root . right NEW_LINE DEDENT DEDENT return root NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_911_A", "sol": 0, "python_code": "import math as mt\nN = 100005\ndef AMICABLE ( ) :\n    Sum = [ 0 for i in range ( N ) ]\n    for i in range ( 1 , N ) :\n        Sum [ i ] += 1\n        for j in range ( 2 , mt.ceil ( mt.sqrt ( i ) ) ) :\n            if ( i % j == 0 ) :\n                Sum [ i ] += j\n                if ( i // j != j ) :\n                    Sum [ i ] += i // j\n    s = set ( )\n    for i in range ( 2 , N ) :\n        if ( i != Sum [ i ] and Sum [ i ] < N and i == Sum [ Sum [ i ] ] and i not in s and Sum [ i ] not in s ) :\n            s.add ( i )\n            s.add ( Sum [ i ] )\n    return s\ndef SumOfAmicable ( n ) :\n    Sum = 0\n    s = AMICABLE ( )\n    s = sorted ( s )\n    for i in s :\n        if ( i <= n ) :\n            Sum += i\n        else :\n            break\n    return Sum\nn = 284\nprint ( SumOfAmicable ( n ) )\n", "python_code_tokenized": "import math as mt NEW_LINE N = 100005 NEW_LINE def AMICABLE ( ) : NEW_LINE INDENT Sum = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT Sum [ i ] += 1 NEW_LINE for j in range ( 2 , mt . ceil ( mt . sqrt ( i ) ) ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT Sum [ i ] += j NEW_LINE if ( i // j != j ) : NEW_LINE INDENT Sum [ i ] += i // j NEW_LINE DEDENT DEDENT DEDENT DEDENT s = set ( ) NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( i != Sum [ i ] and Sum [ i ] < N and i == Sum [ Sum [ i ] ] and i not in s and Sum [ i ] not in s ) : NEW_LINE INDENT s . add ( i ) NEW_LINE s . add ( Sum [ i ] ) NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT def SumOfAmicable ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE s = AMICABLE ( ) NEW_LINE s = sorted ( s ) NEW_LINE for i in s : NEW_LINE INDENT if ( i <= n ) : NEW_LINE INDENT Sum += i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT n = 284 NEW_LINE print ( SumOfAmicable ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4474_A", "sol": 0, "python_code": "def findPosition ( k , n ) :\n    f1 = 0\n    f2 = 1\n    i = 2 ;\n    while i != 0 :\n        f3 = f1 + f2 ;\n        f1 = f2 ;\n        f2 = f3 ;\n        if f2 % k == 0 :\n            return n * i\n        i += 1\n    return\nn = 5 ;\nk = 4 ;\nprint ( \"Position of n'th multiple of k in\" \"Fibonacci Seires is\" , findPosition ( k , n ) ) ;\n", "python_code_tokenized": "def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE i = 2 ; NEW_LINE while i != 0 : NEW_LINE INDENT f3 = f1 + f2 ; NEW_LINE f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE if f2 % k == 0 : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT n = 5 ; NEW_LINE k = 4 ; NEW_LINE print ( \" Position \u2581 of \u2581 n ' th \u2581 multiple \u2581 of \u2581 k \u2581 in \" \" Fibonacci \u2581 Seires \u2581 is \" , findPosition ( k , n ) ) ; NEW_LINE"}
{"id": "codeforces_18_A", "sol": 0, "python_code": "cor = list ( map ( int , input ( ).split ( ) ) )\nfdd = 0\ndef right ( aa ) :\n    xa , ya , xb , yb , xc , yc = ( aa [ j ] for j in range ( 6 ) )\n    a = ( xb - xa ) ** 2 + ( yb - ya ) ** 2\n    b = ( xc - xa ) ** 2 + ( yc - ya ) ** 2\n    c = ( xc - xb ) ** 2 + ( yc - yb ) ** 2\n    ver = 0\n    if a + b == c or a + c == b or b + c == a :\n        if a * b * c != 0 :\n            ver += 1\n    return ver\nfdd += right ( cor )\nif fdd != 0 :\n    print ( \"RIGHT\" )\nelse :\n    for i in range ( len ( cor ) ) :\n        cor [ i ] += 1\n        fdd += right ( cor )\n        cor [ i ] -= 2\n        fdd += right ( cor )\n        cor [ i ] += 1\n    if fdd != 0 :\n        print ( \"ALMOST\" )\n    else :\n        print ( \"NEITHER\" )\n", "python_code_tokenized": "cor = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE fdd = 0 NEW_LINE def right ( aa ) : NEW_LINE INDENT xa , ya , xb , yb , xc , yc = ( aa [ j ] for j in range ( 6 ) ) NEW_LINE a = ( xb - xa ) ** 2 + ( yb - ya ) ** 2 NEW_LINE b = ( xc - xa ) ** 2 + ( yc - ya ) ** 2 NEW_LINE c = ( xc - xb ) ** 2 + ( yc - yb ) ** 2 NEW_LINE ver = 0 NEW_LINE if a + b == c or a + c == b or b + c == a : NEW_LINE INDENT if a * b * c != 0 : NEW_LINE INDENT ver += 1 NEW_LINE DEDENT DEDENT return ver NEW_LINE DEDENT fdd += right ( cor ) NEW_LINE if fdd != 0 : NEW_LINE INDENT print ( \" RIGHT \" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( len ( cor ) ) : NEW_LINE INDENT cor [ i ] += 1 NEW_LINE fdd += right ( cor ) NEW_LINE cor [ i ] -= 2 NEW_LINE fdd += right ( cor ) NEW_LINE cor [ i ] += 1 NEW_LINE DEDENT if fdd != 0 : NEW_LINE INDENT print ( \" ALMOST \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NEITHER \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2871_A", "sol": 0, "python_code": "def areVowelsInOrder ( s ) :\n    n = len ( s )\n    c = chr ( 64 )\n    for i in range ( 1 , n ) :\n        if ( s [ i ] == 'a' or s [ i ] == 'e' or s [ i ] == 'i' or s [ i ] == 'o' or s [ i ] == 'u' ) :\n            if s [ i ] < c :\n                return False\n            else :\n                c = s [ i ]\n    return True\nif __name__ == \"__main__\" :\n    s = \"aabbbddeecc\"\n    if areVowelsInOrder ( s ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def areVowelsInOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = chr ( 64 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' or s [ i ] == ' e ' or s [ i ] == ' i ' or s [ i ] == ' o ' or s [ i ] == ' u ' ) : NEW_LINE INDENT if s [ i ] < c : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aabbbddeecc \" NEW_LINE if areVowelsInOrder ( s ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_54_A", "sol": 0, "python_code": "N = 10000 ;\narr = [ 0 ] * N ;\ndef seive ( ) :\n    i = 2 ;\n    while ( i * i < N ) :\n        if ( arr [ i ] == 0 ) :\n            j = 2 ;\n            while ( i * j < N ) :\n                arr [ i * j ] += i ;\n                j += 1 ;\n        i += 1 ;\ndef sum ( l , r ) :\n    seive ( ) ;\n    pref_arr = [ 0 ] * ( r + 1 ) ;\n    pref_arr [ 0 ] = arr [ 0 ] ;\n    for i in range ( 1 , r + 1 ) :\n        pref_arr [ i ] = pref_arr [ i - 1 ] + arr [ i ] ;\n    if ( l == 1 ) :\n        return ( pref_arr [ r ] ) ;\n    else :\n        return ( pref_arr [ r ] - pref_arr [ l - 1 ] ) ;\nl = 5 ;\nr = 10 ;\nprint ( sum ( l , r ) ) ;\n", "python_code_tokenized": "N = 10000 ; NEW_LINE arr = [ 0 ] * N ; NEW_LINE def seive ( ) : NEW_LINE INDENT i = 2 ; NEW_LINE while ( i * i < N ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT j = 2 ; NEW_LINE while ( i * j < N ) : NEW_LINE INDENT arr [ i * j ] += i ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT DEDENT def sum ( l , r ) : NEW_LINE INDENT seive ( ) ; NEW_LINE pref_arr = [ 0 ] * ( r + 1 ) ; NEW_LINE pref_arr [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT pref_arr [ i ] = pref_arr [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT if ( l == 1 ) : NEW_LINE INDENT return ( pref_arr [ r ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( pref_arr [ r ] - pref_arr [ l - 1 ] ) ; NEW_LINE DEDENT DEDENT l = 5 ; NEW_LINE r = 10 ; NEW_LINE print ( sum ( l , r ) ) ; NEW_LINE"}
{"id": "codeforces_389_A", "sol": 0, "python_code": "from collections import defaultdict , deque\nfrom functools import lru_cache\nfrom heapq import heappush , heappop\nfrom bisect import bisect_right , bisect_left\nimport math\nhpop = heappop\nhpush = heappush\nMOD = 10 ** 9 + 7\ndef solution ( ) :\n    n = int ( input ( ) )\n    arr = list ( map ( int , input ( ).split ( ) ) )\n    while min ( arr ) < max ( arr ) :\n        mn = min ( arr )\n        for i in range ( n ) :\n            if arr [ i ] > mn :\n                arr [ i ] -= mn\n    print ( sum ( arr ) )\ndef main ( ) :\n    t = 1\n    for _ in range ( t ) :\n        solution ( )\nmain ( )\n", "python_code_tokenized": "from collections import defaultdict , deque NEW_LINE from functools import lru_cache NEW_LINE from heapq import heappush , heappop NEW_LINE from bisect import bisect_right , bisect_left NEW_LINE import math NEW_LINE hpop = heappop NEW_LINE hpush = heappush NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def solution ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE while min ( arr ) < max ( arr ) : NEW_LINE INDENT mn = min ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > mn : NEW_LINE INDENT arr [ i ] -= mn NEW_LINE DEDENT DEDENT DEDENT print ( sum ( arr ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = 1 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT solution ( ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "codeforces_946_B", "sol": 0, "python_code": "import math\n[ a , b ] = list ( map ( int , input ( ).split ( ' ' ) ) )\nwhile a > 0 and b > 0 :\n    if a >= 2 * b :\n        a = a % ( 2 * b )\n    elif b >= 2 * a :\n        b = b % ( 2 * a )\n    else :\n        break\nprint ( f\"{a} {b}\" )\n", "python_code_tokenized": "import math NEW_LINE [ a , b ] = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE while a > 0 and b > 0 : NEW_LINE INDENT if a >= 2 * b : NEW_LINE INDENT a = a % ( 2 * b ) NEW_LINE DEDENT elif b >= 2 * a : NEW_LINE INDENT b = b % ( 2 * a ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( f \" { a } \u2581 { b } \" ) NEW_LINE"}
{"id": "codeforces_1295_B", "sol": 0, "python_code": "from collections import defaultdict\ndef balance_is_realizable ( imbalance , x , balance ) :\n    if imbalance >= 0 :\n        return ( x - balance ) >= 0\n    else :\n        return ( x - balance ) <= 0\ndef main ( ) :\n    t = int ( input ( ) )\n    for i in range ( t ) :\n        n , x = tuple ( int ( o ) for o in input ( ).split ( ) )\n        string = input ( )\n        balances_to_occurrences = defaultdict ( int )\n        imbalance = 0\n        s = 0\n        for char in string :\n            if char == '0' :\n                imbalance += 1\n            else :\n                imbalance -= 1\n            balances_to_occurrences [ imbalance ] += 1\n        if imbalance == 0 :\n            if ( x in balances_to_occurrences or x == 0 ) :\n                print ( - 1 )\n            else :\n                print ( 0 )\n        else :\n            for balance , occurrences in balances_to_occurrences.items ( ) :\n                if ( x - balance ) % imbalance == 0 and balance_is_realizable ( imbalance , x , balance ) :\n                    s += occurrences\n            if x == 0 :\n                s += 1\n            print ( s )\nif __name__ == \"__main__\" :\n    main ( )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE def balance_is_realizable ( imbalance , x , balance ) : NEW_LINE INDENT if imbalance >= 0 : NEW_LINE INDENT return ( x - balance ) >= 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( x - balance ) <= 0 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , x = tuple ( int ( o ) for o in input ( ) . split ( ) ) NEW_LINE string = input ( ) NEW_LINE balances_to_occurrences = defaultdict ( int ) NEW_LINE imbalance = 0 NEW_LINE s = 0 NEW_LINE for char in string : NEW_LINE INDENT if char == '0' : NEW_LINE INDENT imbalance += 1 NEW_LINE DEDENT else : NEW_LINE INDENT imbalance -= 1 NEW_LINE DEDENT balances_to_occurrences [ imbalance ] += 1 NEW_LINE DEDENT if imbalance == 0 : NEW_LINE INDENT if ( x in balances_to_occurrences or x == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for balance , occurrences in balances_to_occurrences . items ( ) : NEW_LINE INDENT if ( x - balance ) % imbalance == 0 and balance_is_realizable ( imbalance , x , balance ) : NEW_LINE INDENT s += occurrences NEW_LINE DEDENT DEDENT if x == 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1063_A", "sol": 0, "python_code": "def calculate ( a ) :\n    maximum = max ( a )\n    frequency = [ 0 for x in range ( maximum + 1 ) ]\n    for i in a :\n        frequency [ i ] += 1\n    answer = 0\n    for i in frequency :\n        answer = answer + i * ( i - 1 ) // 2\n    return answer\na = [ 1 , 2 , 1 , 2 , 4 ]\nprint ( calculate ( a ) )\n", "python_code_tokenized": "def calculate ( a ) : NEW_LINE INDENT maximum = max ( a ) NEW_LINE frequency = [ 0 for x in range ( maximum + 1 ) ] NEW_LINE for i in a : NEW_LINE INDENT frequency [ i ] += 1 NEW_LINE DEDENT answer = 0 NEW_LINE for i in frequency : NEW_LINE INDENT answer = answer + i * ( i - 1 ) // 2 NEW_LINE DEDENT return answer NEW_LINE DEDENT a = [ 1 , 2 , 1 , 2 , 4 ] NEW_LINE print ( calculate ( a ) ) NEW_LINE"}
{"id": "geeksforgeeks_5025_A", "sol": 0, "python_code": "import math\ndef fact ( n ) :\n    if ( n <= 1 ) :\n        return 1\n    return n * fact ( n - 1 )\ndef nPr ( n , r ) :\n    return math.floor ( fact ( n ) / fact ( n - r ) )\nn = 5\nr = 2\nprint ( n , \"P\" , r , \"=\" , nPr ( n , r ) )\n", "python_code_tokenized": "import math NEW_LINE def fact ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT def nPr ( n , r ) : NEW_LINE INDENT return math . floor ( fact ( n ) / fact ( n - r ) ) NEW_LINE DEDENT n = 5 NEW_LINE r = 2 NEW_LINE print ( n , \" P \" , r , \" = \" , nPr ( n , r ) ) NEW_LINE"}
{"id": "aizu_p00566_A", "sol": 0, "python_code": "import sys\nimport math\nimport string\nimport collections\nimport fractions\nimport random\nfrom operator import itemgetter\nimport itertools\nfrom collections import deque\nimport copy\nimport heapq\nimport bisect\nMOD = 10 ** 9 + 7\nINF = float ( 'inf' )\ninput = lambda : sys.stdin.readline ( ).strip ( )\nsys.setrecursionlimit ( 10 ** 8 )\nH , W = map ( int , input ( ).split ( ) )\nA = [ list ( map ( int , input ( ).split ( ) ) ) for _ in range ( H ) ]\nans = INF\nfor i in range ( H ) :\n    for j in range ( W ) :\n        temp_sum = 0\n        for l in range ( H ) :\n            for k in range ( W ) :\n                temp_sum += A [ l ] [ k ] * min ( abs ( l - i ) , abs ( k - j ) )\n        ans = min ( temp_sum , ans )\nprint ( ans )\n", "python_code_tokenized": "import sys NEW_LINE import math NEW_LINE import string NEW_LINE import collections NEW_LINE import fractions NEW_LINE import random NEW_LINE from operator import itemgetter NEW_LINE import itertools NEW_LINE from collections import deque NEW_LINE import copy NEW_LINE import heapq NEW_LINE import bisect NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE INF = float ( ' inf ' ) NEW_LINE input = lambda : sys . stdin . readline ( ) . strip ( ) NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE H , W = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( H ) ] NEW_LINE ans = INF NEW_LINE for i in range ( H ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT temp_sum = 0 NEW_LINE for l in range ( H ) : NEW_LINE INDENT for k in range ( W ) : NEW_LINE INDENT temp_sum += A [ l ] [ k ] * min ( abs ( l - i ) , abs ( k - j ) ) NEW_LINE DEDENT DEDENT ans = min ( temp_sum , ans ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_768_B", "sol": 0, "python_code": "import math\ndef count_1 ( n , l , r ) :\n    if ( r < L or l > R ) :\n        return 0\n    if ( n < 2 ) :\n        if ( l >= L and r <= R ) :\n            return n\n        else :\n            return 0\n    mid = ( l + r ) // 2\n    return count_1 ( n // 2 , l , mid - 1 ) + count_1 ( n % 2 , mid , mid ) + count_1 ( n // 2 , mid + 1 , r )\nif __name__ == \"__main__\" :\n    global N , L , R\n    N , L , R = [ int ( i ) for i in input ( ).split ( \" \" ) ]\n    len , exp , temp = 0 , 0 , N\n    while ( temp >= 1 ) :\n        len += 2 ** exp\n        exp += 1\n        temp = temp // 2\n    print ( count_1 ( N , 1 , len ) )\n", "python_code_tokenized": "import math NEW_LINE def count_1 ( n , l , r ) : NEW_LINE INDENT if ( r < L or l > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n < 2 ) : NEW_LINE INDENT if ( l >= L and r <= R ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT mid = ( l + r ) // 2 NEW_LINE return count_1 ( n // 2 , l , mid - 1 ) + count_1 ( n % 2 , mid , mid ) + count_1 ( n // 2 , mid + 1 , r ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT global N , L , R NEW_LINE N , L , R = [ int ( i ) for i in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE len , exp , temp = 0 , 0 , N NEW_LINE while ( temp >= 1 ) : NEW_LINE INDENT len += 2 ** exp NEW_LINE exp += 1 NEW_LINE temp = temp // 2 NEW_LINE DEDENT print ( count_1 ( N , 1 , len ) ) NEW_LINE DEDENT"}
{"id": "codeforces_389_B", "sol": 0, "python_code": "my = [ 0 , 1 , 1 , 1 , 2 ]\nmx = [ 0 , 0 , - 1 , 1 , 0 ]\nn = int ( input ( ) )\nboard = [ ]\nfor i in range ( n ) :\n    board.append ( list ( input ( ) ) )\nflag = True\nfor i in range ( n ) :\n    for j in range ( n ) :\n        if board [ i ] [ j ] == '#' :\n            for ( dy , dx ) in zip ( my , mx ) :\n                y = i + dy\n                x = j + dx\n                if y < 0 or y >= n or x < 0 or x >= n :\n                    flag = False\n                    break\n                if board [ y ] [ x ] == '.' :\n                    flag = False\n                board [ y ] [ x ] = '.'\n    if flag == False :\n        break\nprint ( 'YES' if flag else 'NO' )\n", "python_code_tokenized": "my = [ 0 , 1 , 1 , 1 , 2 ] NEW_LINE mx = [ 0 , 0 , - 1 , 1 , 0 ] NEW_LINE n = int ( input ( ) ) NEW_LINE board = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT board . append ( list ( input ( ) ) ) NEW_LINE DEDENT flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if board [ i ] [ j ] == ' # ' : NEW_LINE INDENT for ( dy , dx ) in zip ( my , mx ) : NEW_LINE INDENT y = i + dy NEW_LINE x = j + dx NEW_LINE if y < 0 or y >= n or x < 0 or x >= n : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT if board [ y ] [ x ] == ' . ' : NEW_LINE INDENT flag = False NEW_LINE DEDENT board [ y ] [ x ] = ' . ' NEW_LINE DEDENT DEDENT DEDENT if flag == False : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ' YES ' if flag else ' NO ' ) NEW_LINE"}
{"id": "geeksforgeeks_2824_A", "sol": 0, "python_code": "def countWords ( str ) :\n    count = 1\n    for i in range ( 1 , len ( str ) - 1 ) :\n        if ( str [ i ].isupper ( ) ) :\n            count += 1\n    return count\nstr = \"geeksForGeeks\" ;\nprint ( countWords ( str ) )\n", "python_code_tokenized": "def countWords ( str ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( 1 , len ( str ) - 1 ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT str = \" geeksForGeeks \" ; NEW_LINE print ( countWords ( str ) ) NEW_LINE"}
{"id": "codeforces_769_B", "sol": 0, "python_code": "n = int ( input ( ) )\ntemp = [ int ( x ) for x in input ( ).split ( ) ]\nl = [ ]\nf = [ False ] * n\nfor i in range ( 1 , n , 1 ) :\n    l.append ( [ temp [ i ] , i ] )\nl.sort ( reverse = True )\nl.insert ( 0 , [ temp [ 0 ] , 0 ] )\ni = 0\nj = 1\nresult = [ ]\nf [ 0 ] = True\nwhile ( i < n and j < n ) :\n    cap = l [ i ] [ 0 ]\n    per = l [ i ] [ 1 ]\n    if f [ per ] and cap > 0 :\n        while ( cap != 0 and j < n ) :\n            result.append ( [ per , l [ j ] [ 1 ] ] )\n            f [ l [ j ] [ 1 ] ] = True\n            cap -= 1\n            j += 1\n    else :\n        break\n    i += 1\nif j == n :\n    le = len ( result )\n    print ( le )\n    for i in range ( le ) :\n        print ( result [ i ] [ 0 ] + 1 , result [ i ] [ 1 ] + 1 )\nelse :\n    print ( - 1 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE temp = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE l = [ ] NEW_LINE f = [ False ] * n NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT l . append ( [ temp [ i ] , i ] ) NEW_LINE DEDENT l . sort ( reverse = True ) NEW_LINE l . insert ( 0 , [ temp [ 0 ] , 0 ] ) NEW_LINE i = 0 NEW_LINE j = 1 NEW_LINE result = [ ] NEW_LINE f [ 0 ] = True NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT cap = l [ i ] [ 0 ] NEW_LINE per = l [ i ] [ 1 ] NEW_LINE if f [ per ] and cap > 0 : NEW_LINE INDENT while ( cap != 0 and j < n ) : NEW_LINE INDENT result . append ( [ per , l [ j ] [ 1 ] ] ) NEW_LINE f [ l [ j ] [ 1 ] ] = True NEW_LINE cap -= 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if j == n : NEW_LINE INDENT le = len ( result ) NEW_LINE print ( le ) NEW_LINE for i in range ( le ) : NEW_LINE INDENT print ( result [ i ] [ 0 ] + 1 , result [ i ] [ 1 ] + 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1396_A", "sol": 0, "python_code": "def xorEqualsOrCount ( N ) :\n    count = 0\n    while ( N > 0 ) :\n        bit = N % 2\n        if bit == 0 :\n            count += 1\n        N //= 2\n    return int ( pow ( 2 , count ) )\nif __name__ == \"__main__\" :\n    N = 7\n    print ( xorEqualsOrCount ( N ) )\n", "python_code_tokenized": "def xorEqualsOrCount ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT bit = N % 2 NEW_LINE if bit == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT N //= 2 NEW_LINE DEDENT return int ( pow ( 2 , count ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 7 NEW_LINE print ( xorEqualsOrCount ( N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1138_A", "sol": 0, "python_code": "M = 3 ; N = 3 ;\ndef reverseArray ( arr ) :\n    for i in range ( M ) :\n        start = 0 ;\n        end = N - 1 ;\n        while ( start < end ) :\n            arr [ i ] [ start ] , arr [ i ] [ end ] = arr [ i ] [ end ] , arr [ i ] [ start ] ;\n            start += 1 ;\n            end -= 1 ;\n    for i in range ( M ) :\n        for j in range ( N ) :\n            print ( arr [ i ] [ j ] , end = ' ' ) ;\n        print ( ) ;\nif __name__ == \"__main__\" :\n    arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ;\n    reverseArray ( arr ) ;\n", "python_code_tokenized": "M = 3 ; N = 3 ; NEW_LINE def reverseArray ( arr ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT start = 0 ; NEW_LINE end = N - 1 ; NEW_LINE while ( start < end ) : NEW_LINE INDENT arr [ i ] [ start ] , arr [ i ] [ end ] = arr [ i ] [ end ] , arr [ i ] [ start ] ; NEW_LINE start += 1 ; NEW_LINE end -= 1 ; NEW_LINE DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = ' \u2581 ' ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; NEW_LINE reverseArray ( arr ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_384_A", "sol": 0, "python_code": "def solution ( a , b , n ) :\n    i = 0\n    while i * a <= n :\n        if ( n - ( i * a ) ) % b == 0 :\n            print ( \"x = \" , i , \", y = \" , int ( ( n - ( i * a ) ) / b ) )\n            return 0\n        i = i + 1\n    print ( \"No solution\" )\na = 2\nb = 3\nn = 7\nsolution ( a , b , n )\n", "python_code_tokenized": "def solution ( a , b , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i * a <= n : NEW_LINE INDENT if ( n - ( i * a ) ) % b == 0 : NEW_LINE INDENT print ( \" x \u2581 = \u2581 \" , i , \" , \u2581 y \u2581 = \u2581 \" , int ( ( n - ( i * a ) ) / b ) ) NEW_LINE return 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT print ( \" No \u2581 solution \" ) NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE n = 7 NEW_LINE solution ( a , b , n ) NEW_LINE"}
{"id": "codeforces_547_B", "sol": 0, "python_code": "n = int ( input ( ) )\narr = list ( map ( int , input ( ).split ( ) ) )\npse , nse = [ - 1 ] * n , [ n ] * n\nstack , stack2 = [ 0 ] , [ n - 1 ]\nfor i in range ( 1 , n ) :\n    while ( len ( stack ) and arr [ i ] < arr [ stack [ - 1 ] ] ) :\n        nse [ stack.pop ( ) ] = i\n    stack.append ( i )\n    while ( len ( stack2 ) and arr [ n - i - 1 ] < arr [ stack2 [ - 1 ] ] ) :\n        pse [ stack2.pop ( ) ] = n - i - 1\n    stack2.append ( n - i - 1 )\ndic = { }\nfor i in range ( n ) :\n    dic [ arr [ i ] ] = max ( dic.get ( arr [ i ] , 0 ) , ( nse [ i ] - pse [ i ] - 1 ) )\nout = [ 0 ] * ( n + 1 )\nfor i in dic :\n    out [ dic [ i ] ] = max ( out [ dic [ i ] ] , i )\ntemp = out [ - 1 ]\nfor i in range ( n - 1 , 0 , - 1 ) :\n    if out [ i ] < out [ i + 1 ] :\n        out [ i ] = out [ i + 1 ]\nprint ( ( \" \" ).join ( map ( str , out [ 1 : ] ) ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE pse , nse = [ - 1 ] * n , [ n ] * n NEW_LINE stack , stack2 = [ 0 ] , [ n - 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( stack ) and arr [ i ] < arr [ stack [ - 1 ] ] ) : NEW_LINE INDENT nse [ stack . pop ( ) ] = i NEW_LINE DEDENT stack . append ( i ) NEW_LINE while ( len ( stack2 ) and arr [ n - i - 1 ] < arr [ stack2 [ - 1 ] ] ) : NEW_LINE INDENT pse [ stack2 . pop ( ) ] = n - i - 1 NEW_LINE DEDENT stack2 . append ( n - i - 1 ) NEW_LINE DEDENT dic = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT dic [ arr [ i ] ] = max ( dic . get ( arr [ i ] , 0 ) , ( nse [ i ] - pse [ i ] - 1 ) ) NEW_LINE DEDENT out = [ 0 ] * ( n + 1 ) NEW_LINE for i in dic : NEW_LINE INDENT out [ dic [ i ] ] = max ( out [ dic [ i ] ] , i ) NEW_LINE DEDENT temp = out [ - 1 ] NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if out [ i ] < out [ i + 1 ] : NEW_LINE INDENT out [ i ] = out [ i + 1 ] NEW_LINE DEDENT DEDENT print ( ( \" \u2581 \" ) . join ( map ( str , out [ 1 : ] ) ) ) NEW_LINE"}
{"id": "atcoder_ABC169_A", "sol": 0, "python_code": "import sys\ndef main ( ) :\n    read = lambda : sys.stdin.readline ( ).rstrip ( )\n    b , c = map ( int , read ( ).split ( ) )\n    print ( b * c )\nif __name__ == \"__main__\" :\n    main ( )\n", "python_code_tokenized": "import sys NEW_LINE def main ( ) : NEW_LINE INDENT read = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE b , c = map ( int , read ( ) . split ( ) ) NEW_LINE print ( b * c ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_447_B", "sol": 0, "python_code": "k , n = input ( ) , int ( input ( ) )\nl = list ( map ( int , input ( ).split ( ) ) )\nprint ( sum ( [ i * ( l [ ord ( k [ i - 1 ] ) - 97 ] ) if i <= len ( k ) else max ( l ) * i for i in range ( 1 , len ( k ) + n + 1 ) ] ) )\n", "python_code_tokenized": "k , n = input ( ) , int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( sum ( [ i * ( l [ ord ( k [ i - 1 ] ) - 97 ] ) if i <= len ( k ) else max ( l ) * i for i in range ( 1 , len ( k ) + n + 1 ) ] ) ) NEW_LINE"}
{"id": "geeksforgeeks_2816_A", "sol": 0, "python_code": "def minOperations ( s , t , n ) :\n    ct0 = 0\n    ct1 = 0\n    for i in range ( n ) :\n        if ( s [ i ] == t [ i ] ) :\n            continue\n        if ( s [ i ] == '0' ) :\n            ct0 += 1\n        else :\n            ct1 += 1\n    return max ( ct0 , ct1 )\nif __name__ == \"__main__\" :\n    s = \"010\"\n    t = \"101\"\n    n = len ( s )\n    print ( minOperations ( s , t , n ) )\n", "python_code_tokenized": "def minOperations ( s , t , n ) : NEW_LINE INDENT ct0 = 0 NEW_LINE ct1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == t [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ct0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ct1 += 1 NEW_LINE DEDENT DEDENT return max ( ct0 , ct1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"010\" NEW_LINE t = \"101\" NEW_LINE n = len ( s ) NEW_LINE print ( minOperations ( s , t , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4934_A", "sol": 0, "python_code": "def maxRepeating ( str ) :\n    n = len ( str )\n    count = 0\n    res = str [ 0 ]\n    cur_count = 1\n    for i in range ( n ) :\n        if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) :\n            cur_count += 1\n        else :\n            if cur_count > count :\n                count = cur_count\n                res = str [ i ]\n            cur_count = 1\n    return res\nif __name__ == \"__main__\" :\n    str = \"aaaabbaaccde\"\n    print ( maxRepeating ( str ) )\n", "python_code_tokenized": "def maxRepeating ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE cur_count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT cur_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if cur_count > count : NEW_LINE INDENT count = cur_count NEW_LINE res = str [ i ] NEW_LINE DEDENT cur_count = 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" aaaabbaaccde \" NEW_LINE print ( maxRepeating ( str ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4933_A", "sol": 0, "python_code": "def maxRepeating ( str ) :\n    l = len ( str )\n    count = 0\n    res = str [ 0 ]\n    for i in range ( l ) :\n        cur_count = 1\n        for j in range ( i + 1 , l ) :\n            if ( str [ i ] != str [ j ] ) :\n                break\n            cur_count += 1\n        if cur_count > count :\n            count = cur_count\n            res = str [ i ]\n    return res\nif __name__ == \"__main__\" :\n    str = \"aaaabbaaccde\"\n    print ( maxRepeating ( str ) )\n", "python_code_tokenized": "def maxRepeating ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT cur_count = 1 NEW_LINE for j in range ( i + 1 , l ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT cur_count += 1 NEW_LINE DEDENT if cur_count > count : NEW_LINE INDENT count = cur_count NEW_LINE res = str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" aaaabbaaccde \" NEW_LINE print ( maxRepeating ( str ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4763_A", "sol": 0, "python_code": "def xor_all_elements ( n ) :\n    if n & 3 == 0 :\n        return n\n    elif n & 3 == 1 :\n        return 1\n    elif n & 3 == 2 :\n        return n + 1\n    else :\n        return 0\ndef findArray ( xorr , n ) :\n    arr = [ ]\n    xor_all = xor_all_elements ( n )\n    xor_adjacent = 0\n    for i in range ( 0 , n - 1 , 2 ) :\n        xor_adjacent = xor_adjacent ^ xorr [ i ]\n    last_element = xor_all ^ xor_adjacent\n    arr.append ( last_element )\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        last_element = xorr [ i ] ^ last_element\n        arr.append ( last_element )\n    return arr\nxorr = [ 7 , 5 , 3 , 7 ]\nn = 5\narr = findArray ( xorr , n )\nfor i in range ( n - 1 , - 1 , - 1 ) :\n    print ( arr [ i ] , end = \" \" )\n", "python_code_tokenized": "def xor_all_elements ( n ) : NEW_LINE INDENT if n & 3 == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT elif n & 3 == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n & 3 == 2 : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def findArray ( xorr , n ) : NEW_LINE INDENT arr = [ ] NEW_LINE xor_all = xor_all_elements ( n ) NEW_LINE xor_adjacent = 0 NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT xor_adjacent = xor_adjacent ^ xorr [ i ] NEW_LINE DEDENT last_element = xor_all ^ xor_adjacent NEW_LINE arr . append ( last_element ) NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT last_element = xorr [ i ] ^ last_element NEW_LINE arr . append ( last_element ) NEW_LINE DEDENT return arr NEW_LINE DEDENT xorr = [ 7 , 5 , 3 , 7 ] NEW_LINE n = 5 NEW_LINE arr = findArray ( xorr , n ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4426_A", "sol": 0, "python_code": "MAX = 100\ndef printDiagonalSums ( mat , n ) :\n    principal = 0\n    secondary = 0\n    for i in range ( 0 , n ) :\n        principal += mat [ i ] [ i ]\n        secondary += mat [ i ] [ n - i - 1 ]\n    print ( \"Principal Diagonal:\" , principal )\n    print ( \"Secondary Diagonal:\" , secondary )\na = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ]\nprintDiagonalSums ( a , 4 )\n", "python_code_tokenized": "MAX = 100 NEW_LINE def printDiagonalSums ( mat , n ) : NEW_LINE INDENT principal = 0 NEW_LINE secondary = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT principal += mat [ i ] [ i ] NEW_LINE secondary += mat [ i ] [ n - i - 1 ] NEW_LINE DEDENT print ( \" Principal \u2581 Diagonal : \" , principal ) NEW_LINE print ( \" Secondary \u2581 Diagonal : \" , secondary ) NEW_LINE DEDENT a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ] NEW_LINE printDiagonalSums ( a , 4 ) NEW_LINE"}
{"id": "geeksforgeeks_4425_A", "sol": 0, "python_code": "MAX = 100\ndef printDiagonalSums ( mat , n ) :\n    principal = 0\n    secondary = 0 ;\n    for i in range ( 0 , n ) :\n        for j in range ( 0 , n ) :\n            if ( i == j ) :\n                principal += mat [ i ] [ j ]\n            if ( ( i + j ) == ( n - 1 ) ) :\n                secondary += mat [ i ] [ j ]\n    print ( \"Principal Diagonal:\" , principal )\n    print ( \"Secondary Diagonal:\" , secondary )\na = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ]\nprintDiagonalSums ( a , 4 )\n", "python_code_tokenized": "MAX = 100 NEW_LINE def printDiagonalSums ( mat , n ) : NEW_LINE INDENT principal = 0 NEW_LINE secondary = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT principal += mat [ i ] [ j ] NEW_LINE DEDENT if ( ( i + j ) == ( n - 1 ) ) : NEW_LINE INDENT secondary += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( \" Principal \u2581 Diagonal : \" , principal ) NEW_LINE print ( \" Secondary \u2581 Diagonal : \" , secondary ) NEW_LINE DEDENT a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ] NEW_LINE printDiagonalSums ( a , 4 ) NEW_LINE"}
{"id": "aizu_p02288_A", "sol": 0, "python_code": "H = int ( input ( ) ) + 1\nA = [ 0 ] + list ( map ( int , input ( ).split ( ) ) )\ndef h ( i ) :\n    l = 2 * i ; r , g = l + 1 , [ i , l ] [ l < H and A [ i ] < A [ l ] ]\n    if r < H and A [ g ] < A [ r ] : g = r\n    if g != i : A [ i ] , A [ g ] = A [ g ] , A [ i ] ; h ( g )\nfor i in range ( H // 2 , 0 , - 1 ) : h ( i )\nprint ( ' ' + ' '.join ( map ( str , A [ 1 : ] ) ) )\n", "python_code_tokenized": "H = int ( input ( ) ) + 1 NEW_LINE A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def h ( i ) : NEW_LINE INDENT l = 2 * i ; r , g = l + 1 , [ i , l ] [ l < H and A [ i ] < A [ l ] ] NEW_LINE if r < H and A [ g ] < A [ r ] : g = r NEW_LINE if g != i : A [ i ] , A [ g ] = A [ g ] , A [ i ] ; h ( g ) NEW_LINE DEDENT for i in range ( H // 2 , 0 , - 1 ) : h ( i ) NEW_LINE print ( ' \u2581 ' + ' \u2581 ' . join ( map ( str , A [ 1 : ] ) ) ) NEW_LINE"}
{"id": "geeksforgeeks_4749_A", "sol": 0, "python_code": "def findOddPair ( A , N ) :\n    oddPair = 0\n    for i in range ( 0 , N ) :\n        for j in range ( i + 1 , N ) :\n            if ( ( A [ i ] ^ A [ j ] ) % 2 != 0 ) :\n                oddPair += 1\n    return oddPair\nif __name__ == '__main__' :\n    A = [ 5 , 4 , 7 , 2 , 1 ]\n    N = len ( A )\n    print ( findOddPair ( A , N ) )\n", "python_code_tokenized": "def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] ^ A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair += 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE N = len ( A ) NEW_LINE print ( findOddPair ( A , N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1686_A", "sol": 0, "python_code": "def findOddPair ( A , N ) :\n    oddPair = 0\n    for i in range ( 0 , N ) :\n        for j in range ( i + 1 , N ) :\n            if ( ( A [ i ] | A [ j ] ) % 2 != 0 ) :\n                oddPair += 1\n    return oddPair\ndef main ( ) :\n    A = [ 5 , 6 , 2 , 8 ]\n    N = len ( A )\n    print ( findOddPair ( A , N ) )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] | A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair += 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT A = [ 5 , 6 , 2 , 8 ] NEW_LINE N = len ( A ) NEW_LINE print ( findOddPair ( A , N ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_334_B", "sol": 0, "python_code": "fre_x = [ False ] * ( 10 ** 6 + 5 )\nfre_y = [ False ] * ( 10 ** 6 + 5 )\nunique_x = [ ]\nunique_y = [ ]\npoints = [ ]\nfor _ in range ( 8 ) :\n    x , y = map ( int , input ( ).split ( ) )\n    points.append ( ( x , y ) )\n    if not fre_x [ x ] :\n        fre_x [ x ] = True\n        unique_x.append ( x )\n    if not fre_y [ y ] :\n        fre_y [ y ] = True\n        unique_y.append ( y )\nif len ( unique_x ) != 3 or len ( unique_y ) != 3 :\n    print ( 'ugly' )\n    exit ( )\nunique_x.sort ( )\nunique_y.sort ( )\npoints.sort ( )\nindex = 0\ncount = 0\nfor i in range ( 3 ) :\n    for j in range ( 3 ) :\n        if i == j == 1 :\n            continue\n        count += 1\n        if unique_x [ i ] == points [ index ] [ 0 ] and unique_y [ j ] == points [ index ] [ 1 ] :\n            index += 1\n        else :\n            print ( 'ugly' )\n            exit ( )\nprint ( 'respectable' )\n", "python_code_tokenized": "fre_x = [ False ] * ( 10 ** 6 + 5 ) NEW_LINE fre_y = [ False ] * ( 10 ** 6 + 5 ) NEW_LINE unique_x = [ ] NEW_LINE unique_y = [ ] NEW_LINE points = [ ] NEW_LINE for _ in range ( 8 ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE points . append ( ( x , y ) ) NEW_LINE if not fre_x [ x ] : NEW_LINE INDENT fre_x [ x ] = True NEW_LINE unique_x . append ( x ) NEW_LINE DEDENT if not fre_y [ y ] : NEW_LINE INDENT fre_y [ y ] = True NEW_LINE unique_y . append ( y ) NEW_LINE DEDENT DEDENT if len ( unique_x ) != 3 or len ( unique_y ) != 3 : NEW_LINE INDENT print ( ' ugly ' ) NEW_LINE exit ( ) NEW_LINE DEDENT unique_x . sort ( ) NEW_LINE unique_y . sort ( ) NEW_LINE points . sort ( ) NEW_LINE index = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if i == j == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT count += 1 NEW_LINE if unique_x [ i ] == points [ index ] [ 0 ] and unique_y [ j ] == points [ index ] [ 1 ] : NEW_LINE INDENT index += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' ugly ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( ' respectable ' ) NEW_LINE"}
{"id": "geeksforgeeks_350_A", "sol": 0, "python_code": "import math\ndef areaOctagon ( side ) :\n    return ( 2 * ( 1 + ( math.sqrt ( 2 ) ) ) * side * side )\nside = 4\nprint ( \"Area of Regular Octagon =\" , round ( areaOctagon ( side ) , 4 ) )\n", "python_code_tokenized": "import math NEW_LINE def areaOctagon ( side ) : NEW_LINE INDENT return ( 2 * ( 1 + ( math . sqrt ( 2 ) ) ) * side * side ) NEW_LINE DEDENT side = 4 NEW_LINE print ( \" Area \u2581 of \u2581 Regular \u2581 Octagon \u2581 = \" , round ( areaOctagon ( side ) , 4 ) ) NEW_LINE"}
{"id": "aizu_p02175_A", "sol": 0, "python_code": "X , A , B = map ( int , input ( ).split ( ) )\nN = int ( input ( ) )\nfor i in range ( N ) :\n    word = input ( )\n    if word == \"nobiro\" :\n        X = X + A\n    elif word == \"tidime\" :\n        X = X + B\n    elif word == \"karero\" :\n        X = 0\n    if X < 0 :\n        X = 0\nprint ( X )\n", "python_code_tokenized": "X , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT word = input ( ) NEW_LINE if word == \" nobiro \" : NEW_LINE INDENT X = X + A NEW_LINE DEDENT elif word == \" tidime \" : NEW_LINE INDENT X = X + B NEW_LINE DEDENT elif word == \" karero \" : NEW_LINE INDENT X = 0 NEW_LINE DEDENT if X < 0 : NEW_LINE INDENT X = 0 NEW_LINE DEDENT DEDENT print ( X ) NEW_LINE"}
{"id": "geeksforgeeks_5003_A", "sol": 0, "python_code": "def countX ( n ) :\n    binary = \"{0:b}\".format ( n )\n    count = 0\n    for i in range ( len ( binary ) ) :\n        if ( binary [ i ] == '1' ) :\n            count += 1\n    answer = int ( pow ( 2 , count ) )\n    return answer\nif __name__ == \"__main__\" :\n    n = 5\n    answer = countX ( n )\n    print ( answer )\n", "python_code_tokenized": "def countX ( n ) : NEW_LINE INDENT binary = \" { 0 : b } \" . format ( n ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( binary ) ) : NEW_LINE INDENT if ( binary [ i ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT answer = int ( pow ( 2 , count ) ) NEW_LINE return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE answer = countX ( n ) NEW_LINE print ( answer ) NEW_LINE DEDENT"}
{"id": "aizu_p01389_A", "sol": 0, "python_code": "h , w = map ( int , input ( ).split ( ) )\nINF = 10 ** 20\ndp = [ [ INF ] * ( w + 1 ) ] + [ [ INF ] + [ 0 ] * w for _ in range ( h ) ]\ndp [ 0 ] [ 1 ] = 0\nfor y in range ( 1 , h + 1 ) :\n    line = list ( map ( int , list ( input ( ) ) ) )\n    for x in range ( 1 , w + 1 ) :\n        dp [ y ] [ x ] = min ( dp [ y - 1 ] [ x ] , dp [ y ] [ x - 1 ] ) + line [ x - 1 ]\nprint ( dp [ h ] [ w ] )\n", "python_code_tokenized": "h , w = map ( int , input ( ) . split ( ) ) NEW_LINE INF = 10 ** 20 NEW_LINE dp = [ [ INF ] * ( w + 1 ) ] + [ [ INF ] + [ 0 ] * w for _ in range ( h ) ] NEW_LINE dp [ 0 ] [ 1 ] = 0 NEW_LINE for y in range ( 1 , h + 1 ) : NEW_LINE INDENT line = list ( map ( int , list ( input ( ) ) ) ) NEW_LINE for x in range ( 1 , w + 1 ) : NEW_LINE INDENT dp [ y ] [ x ] = min ( dp [ y - 1 ] [ x ] , dp [ y ] [ x - 1 ] ) + line [ x - 1 ] NEW_LINE DEDENT DEDENT print ( dp [ h ] [ w ] ) NEW_LINE"}
{"id": "geeksforgeeks_2872_A", "sol": 0, "python_code": "def reArrange ( words , n ) :\n    mp = { }\n    for i in range ( n ) :\n        mp [ words [ i ] ] = i + 1\n    words.sort ( ) ;\n    for i in range ( n ) :\n        print ( mp [ words [ i ] ] , end = \" \" )\nwords = [ \"live\" , \"place\" , \"travel\" , \"word\" , \"sky\" ]\nn = len ( words )\nreArrange ( words , n ) ;\n", "python_code_tokenized": "def reArrange ( words , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ words [ i ] ] = i + 1 NEW_LINE DEDENT words . sort ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( mp [ words [ i ] ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT words = [ \" live \" , \" place \" , \" travel \" , \" word \" , \" sky \" ] NEW_LINE n = len ( words ) NEW_LINE reArrange ( words , n ) ; NEW_LINE"}
{"id": "geeksforgeeks_2411_A", "sol": 0, "python_code": "def calculateEvenSum ( n ) :\n    if n <= 0 :\n        return 0\n    fibo = [ 0 ] * ( 2 * n + 1 )\n    fibo [ 0 ] , fibo [ 1 ] = 0 , 1\n    sum = 0\n    for i in range ( 2 , 2 * n + 1 ) :\n        fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ]\n        if i % 2 == 0 :\n            sum += fibo [ i ]\n    return sum\nif __name__ == \"__main__\" :\n    n = 8\n    print ( \"Even indexed Fibonacci Sum upto\" , n , \"terms:\" , calculateEvenSum ( n ) )\n", "python_code_tokenized": "def calculateEvenSum ( n ) : NEW_LINE INDENT if n <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( 2 * n + 1 ) NEW_LINE fibo [ 0 ] , fibo [ 1 ] = 0 , 1 NEW_LINE sum = 0 NEW_LINE for i in range ( 2 , 2 * n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE if i % 2 == 0 : NEW_LINE INDENT sum += fibo [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 NEW_LINE print ( \" Even \u2581 indexed \u2581 Fibonacci \u2581 Sum \u2581 upto \" , n , \" terms : \" , calculateEvenSum ( n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_622_A", "sol": 0, "python_code": "from cmd import IDENTCHARS\nn = int ( input ( ) )\nl = 1\nr = n\nwhile ( l < r ) :\n    mid = l + ( r - l ) // 2\n    idxcnt = mid * ( mid + 1 ) / 2\n    if ( idxcnt < n ) :\n        l = mid + 1\n    else :\n        r = mid\nl -= 1\nidxcnt = l * ( l + 1 ) / 2\nprint ( int ( n - idxcnt ) )\n", "python_code_tokenized": "from cmd import IDENTCHARS NEW_LINE n = int ( input ( ) ) NEW_LINE l = 1 NEW_LINE r = n NEW_LINE while ( l < r ) : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE idxcnt = mid * ( mid + 1 ) / 2 NEW_LINE if ( idxcnt < n ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid NEW_LINE DEDENT DEDENT l -= 1 NEW_LINE idxcnt = l * ( l + 1 ) / 2 NEW_LINE print ( int ( n - idxcnt ) ) NEW_LINE"}
{"id": "geeksforgeeks_2927_A", "sol": 0, "python_code": "def printArray ( X , d , first_ele ) :\n    while ( X > 0 ) :\n        count_ele , pow_of_two = 0 , 2\n        while ( X - pow_of_two + 1 >= 0 ) :\n            count_ele += 1\n            pow_of_two *= 2\n        X = X - ( pow_of_two / 2 ) + 1\n        for j in range ( count_ele ) :\n            print ( first_ele , end = \" \" )\n        first_ele += d\nif __name__ == '__main__' :\n    d , X = 100 , 25\n    printArray ( X , d , 1 )\n", "python_code_tokenized": "def printArray ( X , d , first_ele ) : NEW_LINE INDENT while ( X > 0 ) : NEW_LINE INDENT count_ele , pow_of_two = 0 , 2 NEW_LINE while ( X - pow_of_two + 1 >= 0 ) : NEW_LINE INDENT count_ele += 1 NEW_LINE pow_of_two *= 2 NEW_LINE DEDENT X = X - ( pow_of_two / 2 ) + 1 NEW_LINE for j in range ( count_ele ) : NEW_LINE INDENT print ( first_ele , end = \" \u2581 \" ) NEW_LINE DEDENT first_ele += d NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT d , X = 100 , 25 NEW_LINE printArray ( X , d , 1 ) NEW_LINE DEDENT"}
{"id": "codejam_08_54", "sol": 0, "python_code": "rocks = { }\nnum_ways = { }\nmod = 10007\ndef num_u_ways ( r , c , H , W ) :\n    if ( r >= H or c >= W ) :\n        return 0\n    if ( ( r , c ) in rocks ) :\n        return 0\n    if ( r == H - 1 and c == W - 1 ) :\n        return 1\n    if ( ( r , c ) in num_ways ) :\n        return num_ways [ ( r , c ) ]\n    a = num_u_ways ( r + 2 , c + 1 , H , W )\n    b = num_u_ways ( r + 1 , c + 2 , H , W )\n    num_ways [ ( r , c ) ] = ( a + b ) % mod\n    return num_ways [ ( r , c ) ]\nfilename = \"D-small-attempt0.in\"\nf = open ( filename , 'r' )\nof = open ( \"D-small.out\" , 'w' )\nN = int ( f.readline ( ) )\nfor x in xrange ( N ) :\n    l = f.readline ( ).split ( ' ' )\n    H = int ( l [ 0 ] )\n    W = int ( l [ 1 ] )\n    R = int ( l [ 2 ] )\n    rocks = { }\n    for y in xrange ( R ) :\n        l = f.readline ( ).split ( ' ' )\n        rocks [ ( int ( l [ 0 ] ) - 1 , int ( l [ 1 ] ) - 1 ) ] = True\n    num_ways = { }\n    ans = num_u_ways ( 0 , 0 , H , W )\n    print >> of , \"Case #%d: %d\" % ( x + 1 , ans )\n", "python_code_tokenized": "rocks = { } NEW_LINE num_ways = { } NEW_LINE mod = 10007 NEW_LINE def num_u_ways ( r , c , H , W ) : NEW_LINE INDENT if ( r >= H or c >= W ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( r , c ) in rocks ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( r == H - 1 and c == W - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( ( r , c ) in num_ways ) : NEW_LINE INDENT return num_ways [ ( r , c ) ] NEW_LINE DEDENT a = num_u_ways ( r + 2 , c + 1 , H , W ) NEW_LINE b = num_u_ways ( r + 1 , c + 2 , H , W ) NEW_LINE num_ways [ ( r , c ) ] = ( a + b ) % mod NEW_LINE return num_ways [ ( r , c ) ] NEW_LINE DEDENT filename = \" D - small - attempt0 . in \" NEW_LINE f = open ( filename , ' r ' ) NEW_LINE of = open ( \" D - small . out \" , ' w ' ) NEW_LINE N = int ( f . readline ( ) ) NEW_LINE for x in xrange ( N ) : NEW_LINE INDENT l = f . readline ( ) . split ( ' \u2581 ' ) NEW_LINE H = int ( l [ 0 ] ) NEW_LINE W = int ( l [ 1 ] ) NEW_LINE R = int ( l [ 2 ] ) NEW_LINE rocks = { } NEW_LINE for y in xrange ( R ) : NEW_LINE INDENT l = f . readline ( ) . split ( ' \u2581 ' ) NEW_LINE rocks [ ( int ( l [ 0 ] ) - 1 , int ( l [ 1 ] ) - 1 ) ] = True NEW_LINE DEDENT num_ways = { } NEW_LINE ans = num_u_ways ( 0 , 0 , H , W ) NEW_LINE print >> of , \" Case \u2581 # % d : \u2581 % d \" % ( x + 1 , ans ) NEW_LINE DEDENT"}
{"id": "aizu_p00024_A", "sol": 0, "python_code": "import math\nimport sys\nfor e in sys.stdin :\n    print ( math.ceil ( float ( e ) ** 2 / 98 ) + 1 )\n", "python_code_tokenized": "import math NEW_LINE import sys NEW_LINE for e in sys . stdin : NEW_LINE INDENT print ( math . ceil ( float ( e ) ** 2 / 98 ) + 1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3147_A", "sol": 0, "python_code": "def sumDigits ( no ) :\n    return 0 if no == 0 else int ( no % 10 ) + sumDigits ( int ( no / 10 ) )\nprint ( sumDigits ( 687 ) )\n", "python_code_tokenized": "def sumDigits ( no ) : NEW_LINE INDENT return 0 if no == 0 else int ( no % 10 ) + sumDigits ( int ( no / 10 ) ) NEW_LINE DEDENT print ( sumDigits ( 687 ) ) NEW_LINE"}
{"id": "geeksforgeeks_3248_A", "sol": 0, "python_code": "def isArmstrong ( x , n ) :\n    sum1 = 0\n    temp = x\n    while temp > 0 :\n        digit = temp % 10\n        sum1 += digit ** n\n        temp //= 10\n    return sum1 == x\ndef CalculateXORandOR ( n ) :\n    CalculateXOR = 0\n    CalculateOR = 0\n    start = 10 ** ( n - 1 )\n    end = ( 10 ** n ) - 1\n    for i in range ( start , end + 1 ) :\n        if ( isArmstrong ( i , n ) ) :\n            CalculateXOR = CalculateXOR ^ i\n            CalculateOR = CalculateOR | i\n    print ( \"XOR = \" , CalculateXOR )\n    print ( \"OR = \" , CalculateOR )\nif __name__ == \"__main__\" :\n    n = 4 ;\n    CalculateXORandOR ( n ) ;\n", "python_code_tokenized": "def isArmstrong ( x , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE temp = x NEW_LINE while temp > 0 : NEW_LINE INDENT digit = temp % 10 NEW_LINE sum1 += digit ** n NEW_LINE temp //= 10 NEW_LINE DEDENT return sum1 == x NEW_LINE DEDENT def CalculateXORandOR ( n ) : NEW_LINE INDENT CalculateXOR = 0 NEW_LINE CalculateOR = 0 NEW_LINE start = 10 ** ( n - 1 ) NEW_LINE end = ( 10 ** n ) - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( isArmstrong ( i , n ) ) : NEW_LINE INDENT CalculateXOR = CalculateXOR ^ i NEW_LINE CalculateOR = CalculateOR | i NEW_LINE DEDENT DEDENT print ( \" XOR \u2581 = \u2581 \" , CalculateXOR ) NEW_LINE print ( \" OR \u2581 = \u2581 \" , CalculateOR ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE CalculateXORandOR ( n ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1409_B", "sol": 0, "python_code": "def solve ( min_v , max_v , min_limit , max_limit , n ) :\n    prev = min_v\n    min_v = max ( min_limit , min_v - n )\n    n -= prev - min_v\n    max_v = max ( max_limit , max_v - n )\n    return max_v * min_v\ndef main ( ) :\n    t = int ( input ( ) )\n    for _ in range ( t ) :\n        a , b , x , y , n = map ( int , input ( ).split ( ) )\n        if a >= b :\n            min_v = b\n            min_limit = y\n            max_v = a\n            max_limit = x\n        else :\n            min_v = a\n            min_limit = x\n            max_v = b\n            max_limit = y\n        m1 = solve ( min_v , max_v , min_limit , max_limit , n )\n        m2 = solve ( max_v , min_v , max_limit , min_limit , n )\n        print ( min ( m1 , m2 ) )\nmain ( )\n", "python_code_tokenized": "def solve ( min_v , max_v , min_limit , max_limit , n ) : NEW_LINE INDENT prev = min_v NEW_LINE min_v = max ( min_limit , min_v - n ) NEW_LINE n -= prev - min_v NEW_LINE max_v = max ( max_limit , max_v - n ) NEW_LINE return max_v * min_v NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b , x , y , n = map ( int , input ( ) . split ( ) ) NEW_LINE if a >= b : NEW_LINE INDENT min_v = b NEW_LINE min_limit = y NEW_LINE max_v = a NEW_LINE max_limit = x NEW_LINE DEDENT else : NEW_LINE INDENT min_v = a NEW_LINE min_limit = x NEW_LINE max_v = b NEW_LINE max_limit = y NEW_LINE DEDENT m1 = solve ( min_v , max_v , min_limit , max_limit , n ) NEW_LINE m2 = solve ( max_v , min_v , max_limit , min_limit , n ) NEW_LINE print ( min ( m1 , m2 ) ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"}
{"id": "geeksforgeeks_3830_A", "sol": 0, "python_code": "def printUnsorted ( arr , n ) :\n    e = n - 1\n    for s in range ( 0 , n - 1 ) :\n        if arr [ s ] > arr [ s + 1 ] :\n            break\n    if s == n - 1 :\n        print ( \"The complete array is sorted\" )\n        exit ( )\n    e = n - 1\n    while e > 0 :\n        if arr [ e ] < arr [ e - 1 ] :\n            break\n        e -= 1\n    max = arr [ s ]\n    min = arr [ s ]\n    for i in range ( s + 1 , e + 1 ) :\n        if arr [ i ] > max :\n            max = arr [ i ]\n        if arr [ i ] < min :\n            min = arr [ i ]\n    for i in range ( s ) :\n        if arr [ i ] > min :\n            s = i\n            break\n    i = n - 1\n    while i >= e + 1 :\n        if arr [ i ] < max :\n            e = i\n            break\n        i -= 1\n    print ( \"The unsorted subarray which makes the given array\" )\n    print ( \"sorted lies between the indexes %d and %d\" % ( s , e ) )\narr = [ 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 ]\narr_size = len ( arr )\nprintUnsorted ( arr , arr_size )\n", "python_code_tokenized": "def printUnsorted ( arr , n ) : NEW_LINE INDENT e = n - 1 NEW_LINE for s in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ s ] > arr [ s + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if s == n - 1 : NEW_LINE INDENT print ( \" The \u2581 complete \u2581 array \u2581 is \u2581 sorted \" ) NEW_LINE exit ( ) NEW_LINE DEDENT e = n - 1 NEW_LINE while e > 0 : NEW_LINE INDENT if arr [ e ] < arr [ e - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT e -= 1 NEW_LINE DEDENT max = arr [ s ] NEW_LINE min = arr [ s ] NEW_LINE for i in range ( s + 1 , e + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if arr [ i ] < min : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( s ) : NEW_LINE INDENT if arr [ i ] > min : NEW_LINE INDENT s = i NEW_LINE break NEW_LINE DEDENT DEDENT i = n - 1 NEW_LINE while i >= e + 1 : NEW_LINE INDENT if arr [ i ] < max : NEW_LINE INDENT e = i NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( \" The \u2581 unsorted \u2581 subarray \u2581 which \u2581 makes \u2581 the \u2581 given \u2581 array \" ) NEW_LINE print ( \" sorted \u2581 lies \u2581 between \u2581 the \u2581 indexes \u2581 % d \u2581 and \u2581 % d \" % ( s , e ) ) NEW_LINE DEDENT arr = [ 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printUnsorted ( arr , arr_size ) NEW_LINE"}
{"id": "geeksforgeeks_3224_A", "sol": 0, "python_code": "def minOperations ( n ) :\n    count = 0\n    d = 0\n    if ( n == 1 ) :\n        return 0\n    while ( n > 9 ) :\n        d = max ( n % 10 , d )\n        n //= 10\n        count += 10\n    d = max ( d , n - 1 )\n    count += abs ( d )\n    return count - 1\nif __name__ == '__main__' :\n    n = 240\n    print ( minOperations ( n ) )\n", "python_code_tokenized": "def minOperations ( n ) : NEW_LINE INDENT count = 0 NEW_LINE d = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n > 9 ) : NEW_LINE INDENT d = max ( n % 10 , d ) NEW_LINE n //= 10 NEW_LINE count += 10 NEW_LINE DEDENT d = max ( d , n - 1 ) NEW_LINE count += abs ( d ) NEW_LINE return count - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 240 NEW_LINE print ( minOperations ( n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_788_A", "sol": 0, "python_code": "n = int ( input ( ) )\narr = list ( map ( int , input ( ).split ( ) ) )\ndiff = [ abs ( arr [ i ] - arr [ i + 1 ] ) for i in range ( n - 1 ) ]\ndp = [ [ 0 , 0 , 0 ] for _ in range ( n - 1 ) ]\ndp [ 0 ] [ 1 ] = diff [ 0 ]\nfor i in range ( 1 , n - 1 ) :\n    dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] )\n    dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 2 ] + diff [ i ] , diff [ i ] )\n    dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - diff [ i ]\nprint ( max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] , dp [ n - 2 ] [ 2 ] ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE diff = [ abs ( arr [ i ] - arr [ i + 1 ] ) for i in range ( n - 1 ) ] NEW_LINE dp = [ [ 0 , 0 , 0 ] for _ in range ( n - 1 ) ] NEW_LINE dp [ 0 ] [ 1 ] = diff [ 0 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) NEW_LINE dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 2 ] + diff [ i ] , diff [ i ] ) NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - diff [ i ] NEW_LINE DEDENT print ( max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] , dp [ n - 2 ] [ 2 ] ) ) NEW_LINE"}
{"id": "codeforces_398_A", "sol": 0, "python_code": "a , b = [ int ( i ) for i in input ( ).split ( ) ]\nif ( a == 0 ) :\n    print ( - b ** 2 )\n    print ( 'x' * b )\nelif ( b == 0 ) :\n    print ( a ** 2 )\n    print ( 'o' * a )\nelif ( b == 1 ) :\n    print ( a ** 2 - 1 )\n    print ( 'x' + 'o' * a )\nelse :\n    ans = - float ( 'inf' )\n    gr_no = None\n    for i in range ( 2 , min ( a + 2 , b + 1 ) ) :\n        v1 = ( a + 2 - i ) ** 2 + i - 2\n        quo = b // i\n        rem = b % i\n        v2 = rem * ( ( quo + 1 ) ** 2 ) + ( i - rem ) * ( ( quo ** 2 ) )\n        if ( v1 - v2 > ans ) :\n            gr_no = i\n            ans = v1 - v2\n    quo = b // gr_no\n    rem = b % gr_no\n    if ( rem > 0 ) :\n        s = 'x' * ( quo + 1 ) + 'o' * ( a + 2 - gr_no )\n        rem -= 1\n    else :\n        s = 'x' * ( quo ) + 'o' * ( a + 2 - gr_no )\n    gr_no -= 1\n    s1 = 'x' * ( quo + 1 ) + 'o'\n    s2 = 'x' * quo + 'o'\n    for i in range ( rem ) :\n        s += s1\n    for i in range ( gr_no - rem - 1 ) :\n        s += s2\n    s += 'x' * ( quo )\n    print ( ans )\n    print ( s )\n", "python_code_tokenized": "a , b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if ( a == 0 ) : NEW_LINE INDENT print ( - b ** 2 ) NEW_LINE print ( ' x ' * b ) NEW_LINE DEDENT elif ( b == 0 ) : NEW_LINE INDENT print ( a ** 2 ) NEW_LINE print ( ' o ' * a ) NEW_LINE DEDENT elif ( b == 1 ) : NEW_LINE INDENT print ( a ** 2 - 1 ) NEW_LINE print ( ' x ' + ' o ' * a ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = - float ( ' inf ' ) NEW_LINE gr_no = None NEW_LINE for i in range ( 2 , min ( a + 2 , b + 1 ) ) : NEW_LINE INDENT v1 = ( a + 2 - i ) ** 2 + i - 2 NEW_LINE quo = b // i NEW_LINE rem = b % i NEW_LINE v2 = rem * ( ( quo + 1 ) ** 2 ) + ( i - rem ) * ( ( quo ** 2 ) ) NEW_LINE if ( v1 - v2 > ans ) : NEW_LINE INDENT gr_no = i NEW_LINE ans = v1 - v2 NEW_LINE DEDENT DEDENT quo = b // gr_no NEW_LINE rem = b % gr_no NEW_LINE if ( rem > 0 ) : NEW_LINE INDENT s = ' x ' * ( quo + 1 ) + ' o ' * ( a + 2 - gr_no ) NEW_LINE rem -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT s = ' x ' * ( quo ) + ' o ' * ( a + 2 - gr_no ) NEW_LINE DEDENT gr_no -= 1 NEW_LINE s1 = ' x ' * ( quo + 1 ) + ' o ' NEW_LINE s2 = ' x ' * quo + ' o ' NEW_LINE for i in range ( rem ) : NEW_LINE INDENT s += s1 NEW_LINE DEDENT for i in range ( gr_no - rem - 1 ) : NEW_LINE INDENT s += s2 NEW_LINE DEDENT s += ' x ' * ( quo ) NEW_LINE print ( ans ) NEW_LINE print ( s ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2038_A", "sol": 0, "python_code": "def power ( a , n ) :\n    if n == 0 :\n        return 1\n    p = power ( a , n // 2 ) % mod\n    p = ( p * p ) % mod\n    if n & 1 == 1 :\n        p = ( p * a ) % mod\n    return p\ndef computeSum ( arr , n ) :\n    arr.sort ( )\n    Sum = 0\n    for i in range ( 0 , n ) :\n        maxs = ( power ( 2 , i ) - 1 + mod ) % mod\n        maxs = ( maxs * arr [ i ] ) % mod\n        mins = ( power ( 2 , n - 1 - i ) - 1 + mod ) % mod\n        mins = ( mins * arr [ i ] ) % mod\n        V = ( maxs - mins + mod ) % mod\n        Sum = ( Sum + V ) % mod\n    return Sum\nif __name__ == \"__main__\" :\n    mod = 1000000007\n    arr = [ 4 , 3 , 1 ]\n    n = len ( arr )\n    print ( computeSum ( arr , n ) )\n", "python_code_tokenized": "def power ( a , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , n // 2 ) % mod NEW_LINE p = ( p * p ) % mod NEW_LINE if n & 1 == 1 : NEW_LINE INDENT p = ( p * a ) % mod NEW_LINE DEDENT return p NEW_LINE DEDENT def computeSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE Sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT maxs = ( power ( 2 , i ) - 1 + mod ) % mod NEW_LINE maxs = ( maxs * arr [ i ] ) % mod NEW_LINE mins = ( power ( 2 , n - 1 - i ) - 1 + mod ) % mod NEW_LINE mins = ( mins * arr [ i ] ) % mod NEW_LINE V = ( maxs - mins + mod ) % mod NEW_LINE Sum = ( Sum + V ) % mod NEW_LINE DEDENT return Sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mod = 1000000007 NEW_LINE arr = [ 4 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( computeSum ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3399_A", "sol": 0, "python_code": "def minOperations ( A , n ) :\n    if n & 1 :\n        return - 1\n    zeros , consZeros , ones = 0 , 0 , 0\n    for i in range ( n ) :\n        if A [ i ] :\n            zeros += 1\n        else :\n            ones += 1\n        if ( i + 1 < n ) :\n            if A [ i ] == 0 and A [ i + 1 ] == 0 :\n                consZeros += 1\n    if A [ 0 ] == A [ n - 1 ] and A [ 0 ] == 0 :\n        consZeros += 1\n    if zeros == ones :\n        return consZeros\n    else :\n        return - 1\nif __name__ == \"__main__\" :\n    A = [ 1 , 1 , 0 , 0 ]\n    n = len ( A )\n    print ( minOperations ( A , n ) )\n", "python_code_tokenized": "def minOperations ( A , n ) : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT zeros , consZeros , ones = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if A [ i ] : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT if ( i + 1 < n ) : NEW_LINE INDENT if A [ i ] == 0 and A [ i + 1 ] == 0 : NEW_LINE INDENT consZeros += 1 NEW_LINE DEDENT DEDENT DEDENT if A [ 0 ] == A [ n - 1 ] and A [ 0 ] == 0 : NEW_LINE INDENT consZeros += 1 NEW_LINE DEDENT if zeros == ones : NEW_LINE INDENT return consZeros NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 1 , 0 , 0 ] NEW_LINE n = len ( A ) NEW_LINE print ( minOperations ( A , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2366_A", "sol": 0, "python_code": "def countSubarray ( arr , n , k ) :\n    s = 0\n    i = 0\n    while ( i < n ) :\n        if ( arr [ i ] > k ) :\n            i = i + 1\n            continue\n        count = 0\n        while ( i < n and arr [ i ] <= k ) :\n            i = i + 1\n            count = count + 1\n        s = s + ( ( count * ( count + 1 ) ) // 2 )\n    return ( n * ( n + 1 ) // 2 - s )\narr = [ 1 , 2 , 3 ]\nk = 2\nn = len ( arr )\nprint ( countSubarray ( arr , n , k ) )\n", "python_code_tokenized": "def countSubarray ( arr , n , k ) : NEW_LINE INDENT s = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT count = 0 NEW_LINE while ( i < n and arr [ i ] <= k ) : NEW_LINE INDENT i = i + 1 NEW_LINE count = count + 1 NEW_LINE DEDENT s = s + ( ( count * ( count + 1 ) ) // 2 ) NEW_LINE DEDENT return ( n * ( n + 1 ) // 2 - s ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarray ( arr , n , k ) ) NEW_LINE"}
{"id": "codeforces_1190_A", "sol": 0, "python_code": "import sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\nn , m , k = map ( int , input ( ).split ( ) )\np = list ( map ( int , input ( ).split ( ) ) )\np = [ i - 1 for i in p ]\ni = 0\nans = 0\nwhile i < m :\n    j = i\n    x = ( p [ j ] - i ) // k\n    while j < m and x == ( p [ j ] - i ) // k :\n        j += 1\n    ans += 1\n    i = j\nprint ( ans )\n", "python_code_tokenized": "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p = [ i - 1 for i in p ] NEW_LINE i = 0 NEW_LINE ans = 0 NEW_LINE while i < m : NEW_LINE INDENT j = i NEW_LINE x = ( p [ j ] - i ) // k NEW_LINE while j < m and x == ( p [ j ] - i ) // k : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans += 1 NEW_LINE i = j NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_403_A", "sol": 0, "python_code": "def bsearch ( prefixsum , n , k ) :\n    ans , left , right = - 1 , 1 , n\n    while ( left <= right ) :\n        mid = ( left + right ) // 2\n        for i in range ( mid , n + 1 ) :\n            if ( prefixsum [ i ] - prefixsum [ i - mid ] > k ) :\n                i = i - 1\n                break\n        i = i + 1\n        if ( i == n + 1 ) :\n            left = mid + 1\n            ans = mid\n        else :\n            right = mid - 1\n    return ans ;\ndef maxSize ( arr , n , k ) :\n    prefixsum = [ 0 for x in range ( n + 1 ) ]\n    for i in range ( n ) :\n        prefixsum [ i + 1 ] = prefixsum [ i ] + arr [ i ]\n    return bsearch ( prefixsum , n , k ) ;\narr = [ 1 , 2 , 10 , 4 ]\nn = len ( arr )\nk = 14\nprint ( maxSize ( arr , n , k ) )\n", "python_code_tokenized": "def bsearch ( prefixsum , n , k ) : NEW_LINE INDENT ans , left , right = - 1 , 1 , n NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE for i in range ( mid , n + 1 ) : NEW_LINE INDENT if ( prefixsum [ i ] - prefixsum [ i - mid ] > k ) : NEW_LINE INDENT i = i - 1 NEW_LINE break NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE if ( i == n + 1 ) : NEW_LINE INDENT left = mid + 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT def maxSize ( arr , n , k ) : NEW_LINE INDENT prefixsum = [ 0 for x in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefixsum [ i + 1 ] = prefixsum [ i ] + arr [ i ] NEW_LINE DEDENT return bsearch ( prefixsum , n , k ) ; NEW_LINE DEDENT arr = [ 1 , 2 , 10 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 14 NEW_LINE print ( maxSize ( arr , n , k ) ) NEW_LINE"}
{"id": "atcoder_AGC021_A", "sol": 0, "python_code": "X = list ( map ( int , input ( ) ) )\nsn = [ ]\nfor i in range ( len ( X ) ) :\n    sn.append ( sum ( X [ 0 : i + 1 ] ) )\nssn = [ ]\nfor i in range ( len ( X ) ) :\n    if ( sn [ i ] != 0 ) :\n        ssn.append ( sn [ i ] - 1 + 9 * ( len ( X ) - 1 - i ) )\nssn.append ( sum ( X ) )\nprint ( max ( ssn ) )\n", "python_code_tokenized": "X = list ( map ( int , input ( ) ) ) NEW_LINE sn = [ ] NEW_LINE for i in range ( len ( X ) ) : NEW_LINE INDENT sn . append ( sum ( X [ 0 : i + 1 ] ) ) NEW_LINE DEDENT ssn = [ ] NEW_LINE for i in range ( len ( X ) ) : NEW_LINE INDENT if ( sn [ i ] != 0 ) : NEW_LINE INDENT ssn . append ( sn [ i ] - 1 + 9 * ( len ( X ) - 1 - i ) ) NEW_LINE DEDENT DEDENT ssn . append ( sum ( X ) ) NEW_LINE print ( max ( ssn ) ) NEW_LINE"}
{"id": "geeksforgeeks_1155_A", "sol": 0, "python_code": "def isVowel ( ch ) :\n    return ch.upper ( ) in [ 'A' , 'E' , 'I' , 'O' , 'U' ]\ndef countVowels ( str ) :\n    count = 0\n    for i in range ( len ( str ) ) :\n        if isVowel ( str [ i ] ) :\n            count += 1\n    return count\nstr = 'abc de'\nprint ( countVowels ( str ) )\n", "python_code_tokenized": "def isVowel ( ch ) : NEW_LINE INDENT return ch . upper ( ) in [ ' A ' , ' E ' , ' I ' , ' O ' , ' U ' ] NEW_LINE DEDENT def countVowels ( str ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if isVowel ( str [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT str = ' abc \u2581 de ' NEW_LINE print ( countVowels ( str ) ) NEW_LINE"}
{"id": "geeksforgeeks_1055_A", "sol": 0, "python_code": "def CountPairs ( arr , n ) :\n    twoCount = 0\n    twoGrCount = 0\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] == 2 ) :\n            twoCount += 1\n        elif ( arr [ i ] > 2 ) :\n            twoGrCount += 1\n    return ( ( twoCount * twoGrCount ) + ( twoGrCount * ( twoGrCount - 1 ) ) / 2 )\narr = [ 3 , 4 , 5 ]\nn = len ( arr )\nprint ( CountPairs ( arr , n ) )\n", "python_code_tokenized": "def CountPairs ( arr , n ) : NEW_LINE INDENT twoCount = 0 NEW_LINE twoGrCount = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT twoCount += 1 NEW_LINE DEDENT elif ( arr [ i ] > 2 ) : NEW_LINE INDENT twoGrCount += 1 NEW_LINE DEDENT DEDENT return ( ( twoCount * twoGrCount ) + ( twoGrCount * ( twoGrCount - 1 ) ) / 2 ) NEW_LINE DEDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountPairs ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_858_A", "sol": 0, "python_code": "import math\ndef digSum ( n ) :\n    sum = 0\n    while ( n > 0 or sum > 9 ) :\n        if ( n == 0 ) :\n            n = sum\n            sum = 0\n        sum += n % 10\n        n /= 10\n    return sum\nn = 1234\nprint ( digSum ( n ) )\n", "python_code_tokenized": "import math NEW_LINE def digSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 or sum > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = sum NEW_LINE sum = 0 NEW_LINE DEDENT sum += n % 10 NEW_LINE n /= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 1234 NEW_LINE print ( digSum ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1908_A", "sol": 0, "python_code": "MOD = 1000000007\ndef countStrings ( N ) :\n    dp = [ [ 0 ] * 3 for i in range ( N + 1 ) ]\n    dp [ 1 ] [ 0 ] = 1 ;\n    dp [ 1 ] [ 1 ] = 1 ;\n    dp [ 1 ] [ 2 ] = 0 ;\n    for i in range ( 2 , N + 1 ) :\n        dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD\n        dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD\n        dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD\n    ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD\n    return ans\nif __name__ == '__main__' :\n    N = 3\n    print ( countStrings ( N ) )\n", "python_code_tokenized": "MOD = 1000000007 NEW_LINE def countStrings ( N ) : NEW_LINE INDENT dp = [ [ 0 ] * 3 for i in range ( N + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 1 ; NEW_LINE dp [ 1 ] [ 1 ] = 1 ; NEW_LINE dp [ 1 ] [ 2 ] = 0 ; NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD NEW_LINE DEDENT ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( countStrings ( N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1102_A", "sol": 0, "python_code": "def SieveOfSundaram ( n ) :\n    nNew = int ( ( n - 2 ) / 2 ) ;\n    marked = [ 0 ] * ( nNew + 1 ) ;\n    for i in range ( 1 , nNew + 1 ) :\n        j = i ;\n        while ( ( i + j + 2 * i * j ) <= nNew ) :\n            marked [ i + j + 2 * i * j ] = 1 ;\n            j += 1 ;\n    if ( n > 2 ) :\n        print ( 2 , end = \" \" ) ;\n    for i in range ( 1 , nNew + 1 ) :\n        if ( marked [ i ] == 0 ) :\n            print ( ( 2 * i + 1 ) , end = \" \" ) ;\nn = 20 ;\nSieveOfSundaram ( n ) ;\n", "python_code_tokenized": "def SieveOfSundaram ( n ) : NEW_LINE INDENT nNew = int ( ( n - 2 ) / 2 ) ; NEW_LINE marked = [ 0 ] * ( nNew + 1 ) ; NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i ; NEW_LINE while ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = \" \u2581 \" ) ; NEW_LINE DEDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT DEDENT n = 20 ; NEW_LINE SieveOfSundaram ( n ) ; NEW_LINE"}
{"id": "atcoder_ARC068_A", "sol": 0, "python_code": "n = int ( input ( ) )\nif n <= 6 : print ( 1 )\nelif n <= 11 : print ( 2 )\nelse : print ( n // 11 * 2 + ( n % 11 + 5 ) // 6 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE if n <= 6 : print ( 1 ) NEW_LINE elif n <= 11 : print ( 2 ) NEW_LINE else : print ( n // 11 * 2 + ( n % 11 + 5 ) // 6 ) NEW_LINE"}
{"id": "geeksforgeeks_1257_A", "sol": 0, "python_code": "def findNumbers ( N ) :\n    i = 1\n    while ( i <= N ) :\n        print ( ( i * i * i ) , end = \" \" )\n        i += 1\nif __name__ == '__main__' :\n    N = 4\n    findNumbers ( N )\n", "python_code_tokenized": "def findNumbers ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= N ) : NEW_LINE INDENT print ( ( i * i * i ) , end = \" \u2581 \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE findNumbers ( N ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC016_A", "sol": 0, "python_code": "from sys import stdin\ns = stdin.readline ( ).rstrip ( )\nans = len ( s )\nfor c in range ( ord ( 'a' ) , ord ( 'z' ) + 1 ) :\n    cnt , cntMax = 0 , 0\n    for i in range ( 0 , len ( s ) ) :\n        if s [ i ] == chr ( c ) :\n            cntMax = max ( cnt , cntMax )\n            cnt = 0\n            continue\n        cnt += 1\n    cntMax = max ( cnt , cntMax )\n    ans = min ( ans , cntMax )\nprint ( ans , '\\n' )\n", "python_code_tokenized": "from sys import stdin NEW_LINE s = stdin . readline ( ) . rstrip ( ) NEW_LINE ans = len ( s ) NEW_LINE for c in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT cnt , cntMax = 0 , 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == chr ( c ) : NEW_LINE INDENT cntMax = max ( cnt , cntMax ) NEW_LINE cnt = 0 NEW_LINE continue NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT cntMax = max ( cnt , cntMax ) NEW_LINE ans = min ( ans , cntMax ) NEW_LINE DEDENT print ( ans , ' \\n ' ) NEW_LINE"}
{"id": "aizu_p02437_A", "sol": 0, "python_code": "import heapq\nn , q = map ( int , input ( ).split ( ) )\nQ = [ [ ] for i in range ( n ) ]\nqueries = list ( )\nfor i in range ( q ) :\n    queries.append ( list ( map ( int , input ( ).split ( ) ) ) )\nfor query in queries :\n    if query [ 0 ] == 0 :\n        heapq.heappush ( Q [ query [ 1 ] ] , - query [ 2 ] )\n    elif query [ 0 ] == 1 :\n        if Q [ query [ 1 ] ] :\n            print ( - Q [ query [ 1 ] ] [ 0 ] )\n    elif query [ 0 ] == 2 :\n        if Q [ query [ 1 ] ] :\n            heapq.heappop ( Q [ query [ 1 ] ] )\n", "python_code_tokenized": "import heapq NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE Q = [ [ ] for i in range ( n ) ] NEW_LINE queries = list ( ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT queries . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT for query in queries : NEW_LINE INDENT if query [ 0 ] == 0 : NEW_LINE INDENT heapq . heappush ( Q [ query [ 1 ] ] , - query [ 2 ] ) NEW_LINE DEDENT elif query [ 0 ] == 1 : NEW_LINE INDENT if Q [ query [ 1 ] ] : NEW_LINE INDENT print ( - Q [ query [ 1 ] ] [ 0 ] ) NEW_LINE DEDENT DEDENT elif query [ 0 ] == 2 : NEW_LINE INDENT if Q [ query [ 1 ] ] : NEW_LINE INDENT heapq . heappop ( Q [ query [ 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT"}
{"id": "geeksforgeeks_1716_A", "sol": 0, "python_code": "import math\ndef isPentagonal ( N ) :\n    i = 1\n    while True :\n        M = ( 3 * i * i - i ) / 2\n        i += 1\n        if ( M >= N ) :\n            break\n    return ( M == N )\nN = 12\nif ( isPentagonal ( N ) ) :\n    print ( N , end = ' ' )\n    print ( \"is pentagonal \" )\nelse :\n    print ( N , end = ' ' )\n    print ( \"is not pentagonal\" )\n", "python_code_tokenized": "import math NEW_LINE def isPentagonal ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while True : NEW_LINE INDENT M = ( 3 * i * i - i ) / 2 NEW_LINE i += 1 NEW_LINE if ( M >= N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ( M == N ) NEW_LINE DEDENT N = 12 NEW_LINE if ( isPentagonal ( N ) ) : NEW_LINE INDENT print ( N , end = ' \u2581 ' ) NEW_LINE print ( \" is \u2581 pentagonal \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , end = ' \u2581 ' ) NEW_LINE print ( \" is \u2581 not \u2581 pentagonal \" ) NEW_LINE DEDENT"}
{"id": "aizu_p00035_A", "sol": 0, "python_code": "import sys\nfor e in sys.stdin :\n    e = list ( map ( float , e.split ( ',' ) ) )\n    print ( [ 'YES','NO' ] [ sum ( ( e [ i ] - e [ ( 2 + i ) % 8 ] ) * ( e [ ( 5 + i ) % 8 ] - e [ ( 3 + i ) % 8 ] ) - ( e [ 1 + i ] - e [ ( 3 + i ) % 8 ] ) * ( e [ ( 4 + i ) % 8 ] - e [ ( 2 + i ) % 8 ] ) > 0 for i in range ( 0 , 8 , 2 ) ) % 4 > 0 ] )\n", "python_code_tokenized": "import sys NEW_LINE for e in sys . stdin : NEW_LINE INDENT e = list ( map ( float , e . split ( ' , ' ) ) ) NEW_LINE print ( [ ' YES ' , ' NO ' ] [ sum ( ( e [ i ] - e [ ( 2 + i ) % 8 ] ) * ( e [ ( 5 + i ) % 8 ] - e [ ( 3 + i ) % 8 ] ) - ( e [ 1 + i ] - e [ ( 3 + i ) % 8 ] ) * ( e [ ( 4 + i ) % 8 ] - e [ ( 2 + i ) % 8 ] ) > 0 for i in range ( 0 , 8 , 2 ) ) % 4 > 0 ] ) NEW_LINE DEDENT"}
{"id": "aizu_p00746_A", "sol": 0, "python_code": "dx = ( - 1 , 0 , 1 , 0 )\ndy = ( 0 , 1 , 0 , - 1 )\nwhile True :\n    n = int ( input ( ) )\n    if n == 0 :\n        break\n    x = list ( )\n    y = list ( )\n    x.append ( 0 )\n    y.append ( 0 )\n    for i in range ( n - 1 ) :\n        k , d = map ( int , input ( ).split ( ) )\n        x.append ( x [ k ] + dx [ d ] )\n        y.append ( y [ k ] + dy [ d ] )\n    print ( max ( x ) - min ( x ) + 1 , max ( y ) - min ( y ) + 1 )\n", "python_code_tokenized": "dx = ( - 1 , 0 , 1 , 0 ) NEW_LINE dy = ( 0 , 1 , 0 , - 1 ) NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT x = list ( ) NEW_LINE y = list ( ) NEW_LINE x . append ( 0 ) NEW_LINE y . append ( 0 ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT k , d = map ( int , input ( ) . split ( ) ) NEW_LINE x . append ( x [ k ] + dx [ d ] ) NEW_LINE y . append ( y [ k ] + dy [ d ] ) NEW_LINE DEDENT print ( max ( x ) - min ( x ) + 1 , max ( y ) - min ( y ) + 1 ) NEW_LINE DEDENT"}
{"id": "codeforces_548_B", "sol": 0, "python_code": "r = lambda : input ( ).split ( )\ng = lambda s : max ( map ( len , \"\".join ( s ).split ( '0' ) ) )\nn , m , q = map ( int , r ( ) )\na = [ r ( ) for t in range ( n ) ]\nb = list ( map ( g , a ) )\nfor c in range ( q ) :\n    x , y = map ( int , r ( ) )\n    a [ x - 1 ] [ y - 1 ] = str ( 1 - int ( a [ x - 1 ] [ y - 1 ] ) )\n    b [ x - 1 ] = g ( a [ x - 1 ] )\n    print ( max ( b ) )\n", "python_code_tokenized": "r = lambda : input ( ) . split ( ) NEW_LINE g = lambda s : max ( map ( len , \" \" . join ( s ) . split ( '0' ) ) ) NEW_LINE n , m , q = map ( int , r ( ) ) NEW_LINE a = [ r ( ) for t in range ( n ) ] NEW_LINE b = list ( map ( g , a ) ) NEW_LINE for c in range ( q ) : NEW_LINE INDENT x , y = map ( int , r ( ) ) NEW_LINE a [ x - 1 ] [ y - 1 ] = str ( 1 - int ( a [ x - 1 ] [ y - 1 ] ) ) NEW_LINE b [ x - 1 ] = g ( a [ x - 1 ] ) NEW_LINE print ( max ( b ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1775_A", "sol": 0, "python_code": "def area ( a , b ) :\n    if ( a < 0 or b < 0 ) :\n        return - 1\n    A = a * b\n    return A\nif __name__ == '__main__' :\n    a = 5\n    b = 2\n    print ( area ( a , b ) )\n", "python_code_tokenized": "def area ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = a * b NEW_LINE return A NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE b = 2 NEW_LINE print ( area ( a , b ) ) NEW_LINE DEDENT"}
{"id": "codeforces_270_B", "sol": 0, "python_code": "from collections import Counter\nfrom sys import *\nfrom collections import defaultdict as dd\nfrom math import *\ndef inp ( ) :\n    return int ( stdin.readline ( ).strip ( ) )\ndef vinp ( ) :\n    return map ( int , stdin.readline ( ).strip ( ).split ( ) )\ndef linp ( ) :\n    return list ( map ( int , stdin.readline ( ).strip ( ).split ( ) ) )\ndef sinp ( n = 1 ) :\n    if n == 1 :\n        return stdin.readline ( ).strip ( )\n    elif n == 2 :\n        return list ( stdin.readline ( ).strip ( ) )\n    else :\n        return list ( stdin.readline ( ).split ( ) )\ndef pr ( * x , end = \"\\n\" ) :\n    print ( * x , end = end )\ndef mod ( f , val = 1000000007 ) :\n    return f % val\ndef csort ( c ) :\n    sorted ( c.items ( ) , key = lambda pair : pair [ 1 ] , reverse = True )\ndef indc ( l , n ) :\n    c = { }\n    for i in range ( n ) :\n        c [ l [ i ] ] = c.get ( l [ i ] , [ ] ) + [ i + 1 ]\n    return c\nif __name__ == \"__main__\" :\n    n = inp ( )\n    l = linp ( )\n    f = n - 1\n    while f > 0 and l [ f - 1 ] < l [ f ] :\n        f -= 1\n    print ( f )\n", "python_code_tokenized": "from collections import Counter NEW_LINE from sys import * NEW_LINE from collections import defaultdict as dd NEW_LINE from math import * NEW_LINE def inp ( ) : NEW_LINE INDENT return int ( stdin . readline ( ) . strip ( ) ) NEW_LINE DEDENT def vinp ( ) : NEW_LINE INDENT return map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE DEDENT def linp ( ) : NEW_LINE INDENT return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE DEDENT def sinp ( n = 1 ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return stdin . readline ( ) . strip ( ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT return list ( stdin . readline ( ) . strip ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return list ( stdin . readline ( ) . split ( ) ) NEW_LINE DEDENT DEDENT def pr ( * x , end = \" \\n \" ) : NEW_LINE INDENT print ( * x , end = end ) NEW_LINE DEDENT def mod ( f , val = 1000000007 ) : NEW_LINE INDENT return f % val NEW_LINE DEDENT def csort ( c ) : NEW_LINE INDENT sorted ( c . items ( ) , key = lambda pair : pair [ 1 ] , reverse = True ) NEW_LINE DEDENT def indc ( l , n ) : NEW_LINE INDENT c = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ l [ i ] ] = c . get ( l [ i ] , [ ] ) + [ i + 1 ] NEW_LINE DEDENT return c NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = inp ( ) NEW_LINE l = linp ( ) NEW_LINE f = n - 1 NEW_LINE while f > 0 and l [ f - 1 ] < l [ f ] : NEW_LINE INDENT f -= 1 NEW_LINE DEDENT print ( f ) NEW_LINE DEDENT"}
{"id": "codeforces_594_A", "sol": 0, "python_code": "def read ( ) :\n    s = input ( )\n    return list ( map ( int , s.split ( ) ) )\ninput ( )\nx = read ( )\nx.sort ( )\nans = 104857610485761048576\nfor i in range ( len ( x ) // 2 ) :\n    ans = min ( ans , x [ i + len ( x ) // 2 ] - x [ i ] )\nprint ( ans )\n", "python_code_tokenized": "def read ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE return list ( map ( int , s . split ( ) ) ) NEW_LINE DEDENT input ( ) NEW_LINE x = read ( ) NEW_LINE x . sort ( ) NEW_LINE ans = 104857610485761048576 NEW_LINE for i in range ( len ( x ) // 2 ) : NEW_LINE INDENT ans = min ( ans , x [ i + len ( x ) // 2 ] - x [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "leetcode_541_A", "sol": 0, "python_code": "class Solution :\n    def reverseStr ( self , s : str , k : int ) -> str :\n        N = len ( s )\n        ans = \"\"\n        position = 0\n        while position < N :\n            nx = s [ position : position + k ]\n            ans = ans + nx [ : : - 1 ] + s [ position + k : position + 2 * k ]\n            position += 2 * k\n        return ans\ns1 = Solution ( )\ns = \"abcdefg\"\nk = 2\nprint ( s1.reverseStr ( s , k ) )\n", "python_code_tokenized": "class Solution : NEW_LINE INDENT def reverseStr ( self , s : str , k : int ) -> str : NEW_LINE INDENT N = len ( s ) NEW_LINE ans = \" \" NEW_LINE position = 0 NEW_LINE while position < N : NEW_LINE INDENT nx = s [ position : position + k ] NEW_LINE ans = ans + nx [ : : - 1 ] + s [ position + k : position + 2 * k ] NEW_LINE position += 2 * k NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT s1 = Solution ( ) NEW_LINE s = \" abcdefg \" NEW_LINE k = 2 NEW_LINE print ( s1 . reverseStr ( s , k ) ) NEW_LINE"}
{"id": "codeforces_1270_A", "sol": 0, "python_code": "t = int ( input ( ) )\nr = [ ]\nfor i in range ( t ) :\n    a = list ( map ( int , input ( ).split ( ) ) )\n    b = list ( map ( int , input ( ).split ( ) ) )\n    c = list ( map ( int , input ( ).split ( ) ) )\n    m = max ( b )\n    n = max ( c )\n    if m > n :\n        r.append ( \"YES\" )\n    else :\n        r.append ( \"NO\" )\nfor i in range ( len ( r ) ) :\n    print ( r [ i ] )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE r = [ ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = max ( b ) NEW_LINE n = max ( c ) NEW_LINE if m > n : NEW_LINE INDENT r . append ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT r . append ( \" NO \" ) NEW_LINE DEDENT DEDENT for i in range ( len ( r ) ) : NEW_LINE INDENT print ( r [ i ] ) NEW_LINE DEDENT"}
{"id": "codeforces_811_A", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\nn = int ( a ** 0.5 )\nif n * ( n + 1 ) <= b :\n    print ( \"Vladik\" )\nelse :\n    print ( \"Valera\" )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( a ** 0.5 ) NEW_LINE if n * ( n + 1 ) <= b : NEW_LINE INDENT print ( \" Vladik \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Valera \" ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC132_D", "sol": 0, "python_code": "N , K = map ( int , input ( ).split ( ) )\nbinom = [ [ 1 if j == 0 else 0 for j in range ( K + 1 ) ] for i in range ( N + 1 ) ]\nfor i in range ( 1 , N + 1 ) :\n    for j in range ( 1 , K + 1 ) :\n        binom [ i ] [ j ] = binom [ i - 1 ] [ j - 1 ] + binom [ i - 1 ] [ j ]\nfor i in range ( 1 , K + 1 ) :\n    print ( binom [ K - 1 ] [ i - 1 ] * binom [ N - K + 1 ] [ i ] % ( 10 ** 9 + 7 ) )\n", "python_code_tokenized": "N , K = map ( int , input ( ) . split ( ) ) NEW_LINE binom = [ [ 1 if j == 0 else 0 for j in range ( K + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , K + 1 ) : NEW_LINE INDENT binom [ i ] [ j ] = binom [ i - 1 ] [ j - 1 ] + binom [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT print ( binom [ K - 1 ] [ i - 1 ] * binom [ N - K + 1 ] [ i ] % ( 10 ** 9 + 7 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_246_A", "sol": 0, "python_code": "def findSplitPoint ( arr , n ) :\n    leftSum = 0\n    for i in range ( 0 , n ) :\n        leftSum += arr [ i ]\n        rightSum = 0\n        for j in range ( i + 1 , n ) :\n            rightSum += arr [ j ]\n        if ( leftSum == rightSum ) :\n            return i + 1\n    return - 1\ndef printTwoParts ( arr , n ) :\n    splitPo = findSplitPoint ( arr , n )\n    if ( splitPo == - 1 or splitPo == n ) :\n        print ( \"Not Possible\" )\n        return\n    for i in range ( 0 , n ) :\n        if ( splitPo == i ) :\n            print ( \"\" )\n        print ( str ( arr [ i ] ) + '' , end = '' )\narr = [ 1 , 2 , 3 , 4 , 5 , 5 ]\nn = len ( arr )\nprintTwoParts ( arr , n )\n", "python_code_tokenized": "def findSplitPoint ( arr , n ) : NEW_LINE INDENT leftSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT leftSum += arr [ i ] NEW_LINE rightSum = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT rightSum += arr [ j ] NEW_LINE DEDENT if ( leftSum == rightSum ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def printTwoParts ( arr , n ) : NEW_LINE INDENT splitPo = findSplitPoint ( arr , n ) NEW_LINE if ( splitPo == - 1 or splitPo == n ) : NEW_LINE INDENT print ( \" Not \u2581 Possible \" ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( splitPo == i ) : NEW_LINE INDENT print ( \" \" ) NEW_LINE DEDENT print ( str ( arr [ i ] ) + ' \u2581 ' , end = ' ' ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printTwoParts ( arr , n ) NEW_LINE"}
{"id": "geeksforgeeks_247_A", "sol": 0, "python_code": "def findSplitPoint ( arr , n ) :\n    leftSum = 0\n    for i in range ( 0 , n ) :\n        leftSum += arr [ i ]\n    rightSum = 0\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        rightSum += arr [ i ]\n        leftSum -= arr [ i ]\n        if ( rightSum == leftSum ) :\n            return i\n    return - 1\ndef printTwoParts ( arr , n ) :\n    splitPoint = findSplitPoint ( arr , n )\n    if ( splitPoint == - 1 or splitPoint == n ) :\n        print ( \"Not Possible\" )\n        return\n    for i in range ( 0 , n ) :\n        if ( splitPoint == i ) :\n            print ( \"\" )\n        print ( arr [ i ] , end = \" \" )\narr = [ 1 , 2 , 3 , 4 , 5 , 5 ]\nn = len ( arr )\nprintTwoParts ( arr , n )\n", "python_code_tokenized": "def findSplitPoint ( arr , n ) : NEW_LINE INDENT leftSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT leftSum += arr [ i ] NEW_LINE DEDENT rightSum = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT rightSum += arr [ i ] NEW_LINE leftSum -= arr [ i ] NEW_LINE if ( rightSum == leftSum ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def printTwoParts ( arr , n ) : NEW_LINE INDENT splitPoint = findSplitPoint ( arr , n ) NEW_LINE if ( splitPoint == - 1 or splitPoint == n ) : NEW_LINE INDENT print ( \" Not \u2581 Possible \" ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( splitPoint == i ) : NEW_LINE INDENT print ( \" \" ) NEW_LINE DEDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printTwoParts ( arr , n ) NEW_LINE"}
{"id": "atcoder_ABC176_A", "sol": 0, "python_code": "N , X , T = map ( int , input ( ).split ( ) )\nk = N // X\nif N % X :\n    k += 1\nprint ( k * T )\n", "python_code_tokenized": "N , X , T = map ( int , input ( ) . split ( ) ) NEW_LINE k = N // X NEW_LINE if N % X : NEW_LINE INDENT k += 1 NEW_LINE DEDENT print ( k * T ) NEW_LINE"}
{"id": "codeforces_1000_A", "sol": 0, "python_code": "import sys , os.path\nif ( os.path.exists ( 'input.txt' ) ) :\n    sys.stdin = open ( \"input.txt\" , \"r\" )\n    sys.stdout = open ( \"outpput.txt\" , \"w\" )\nn = int ( input ( ) )\nl1 = [ ]\nl2 = [ ]\nfor i in range ( 2 * n ) :\n    if i < n :\n        l1.append ( str ( input ( ) ) )\n    else :\n        l2.append ( str ( input ( ) ) )\nl1.sort ( )\nl2.sort ( )\nc = 0\nL1 = l1.count ( \"L\" )\nM1 = l1.count ( \"M\" )\nS1 = l1.count ( \"S\" )\nL2 = l2.count ( \"L\" )\nM2 = l2.count ( \"M\" )\nS2 = l2.count ( \"S\" )\nif l1 == l2 :\n    print ( 0 )\nelse :\n    for i in range ( n ) :\n        if l1 [ i ] != l2 [ i ] and len ( l1 [ i ] ) > 1 :\n            c += 1\n    print ( c + max ( abs ( L1 - L2 ) , abs ( M2 - M1 ) , abs ( S1 - S2 ) ) )\n", "python_code_tokenized": "import sys , os . path NEW_LINE if ( os . path . exists ( ' input . txt ' ) ) : NEW_LINE INDENT sys . stdin = open ( \" input . txt \" , \" r \" ) NEW_LINE sys . stdout = open ( \" outpput . txt \" , \" w \" ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE l1 = [ ] NEW_LINE l2 = [ ] NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if i < n : NEW_LINE INDENT l1 . append ( str ( input ( ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT l2 . append ( str ( input ( ) ) ) NEW_LINE DEDENT DEDENT l1 . sort ( ) NEW_LINE l2 . sort ( ) NEW_LINE c = 0 NEW_LINE L1 = l1 . count ( \" L \" ) NEW_LINE M1 = l1 . count ( \" M \" ) NEW_LINE S1 = l1 . count ( \" S \" ) NEW_LINE L2 = l2 . count ( \" L \" ) NEW_LINE M2 = l2 . count ( \" M \" ) NEW_LINE S2 = l2 . count ( \" S \" ) NEW_LINE if l1 == l2 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if l1 [ i ] != l2 [ i ] and len ( l1 [ i ] ) > 1 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c + max ( abs ( L1 - L2 ) , abs ( M2 - M1 ) , abs ( S1 - S2 ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_64_A", "sol": 0, "python_code": "MAX = 64 ;\ndef maxOR ( L , R ) :\n    if ( L == R ) :\n        return L ;\n    ans = 0 ;\n    for i in range ( MAX - 1 , - 1 , - 1 ) :\n        p = 1 << i ;\n        lbit = ( L >> i ) & 1 ;\n        rbit = ( R >> i ) & 1 ;\n        if ( ( rbit == 1 ) and ( lbit == 0 ) ) :\n            ans += ( p << 1 ) - 1 ;\n            break ;\n        if ( rbit == 1 ) :\n            ans += p ;\n    return ans ;\nif __name__ == \"__main__\" :\n    L = 4 ; R = 5 ;\n    print ( maxOR ( L , R ) ) ;\n", "python_code_tokenized": "MAX = 64 ; NEW_LINE def maxOR ( L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return L ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( MAX - 1 , - 1 , - 1 ) : NEW_LINE INDENT p = 1 << i ; NEW_LINE lbit = ( L >> i ) & 1 ; NEW_LINE rbit = ( R >> i ) & 1 ; NEW_LINE if ( ( rbit == 1 ) and ( lbit == 0 ) ) : NEW_LINE INDENT ans += ( p << 1 ) - 1 ; NEW_LINE break ; NEW_LINE DEDENT if ( rbit == 1 ) : NEW_LINE INDENT ans += p ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 4 ; R = 5 ; NEW_LINE print ( maxOR ( L , R ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_701_A", "sol": 0, "python_code": "def getTrailingZeroes ( n ) :\n    count = 0\n    val , powerTwo = 1 , 2\n    while ( val != 0 ) :\n        val = n // powerTwo\n        count += val\n        powerTwo *= 2\n    return ( count // 4 )\nn = 6\nprint ( getTrailingZeroes ( n ) )\n", "python_code_tokenized": "def getTrailingZeroes ( n ) : NEW_LINE INDENT count = 0 NEW_LINE val , powerTwo = 1 , 2 NEW_LINE while ( val != 0 ) : NEW_LINE INDENT val = n // powerTwo NEW_LINE count += val NEW_LINE powerTwo *= 2 NEW_LINE DEDENT return ( count // 4 ) NEW_LINE DEDENT n = 6 NEW_LINE print ( getTrailingZeroes ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_859_A", "sol": 0, "python_code": "def firstDigit ( x ) :\n    while ( x >= 10 ) :\n        x = x // 10\n    return x\nprint ( firstDigit ( 12345 ) )\nprint ( firstDigit ( 5432 ) )\n", "python_code_tokenized": "def firstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = x // 10 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( firstDigit ( 12345 ) ) NEW_LINE print ( firstDigit ( 5432 ) ) NEW_LINE"}
{"id": "geeksforgeeks_4688_A", "sol": 0, "python_code": "def summation ( n ) :\n    return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6\nif __name__ == '__main__' :\n    n = 10\n    print ( summation ( n ) )\n", "python_code_tokenized": "def summation ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( summation ( n ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC158_E", "sol": 0, "python_code": "from collections import defaultdict\nN , p = map ( int , input ( ).split ( ) )\nS = input ( )\nS = S [ : : - 1 ]\nd = defaultdict ( lambda : 0 )\nr = 0\nfor i in range ( N ) :\n    r += int ( S [ i ] ) * pow ( 10 , i , p )\n    r %= p\n    d [ r ] += 1\nans = 0\nfor r in d :\n    ans += d [ r ] * ( d [ r ] - 1 ) // 2\nans += d [ 0 ]\nif p == 2 or p == 5 :\n    S = S [ : : - 1 ]\n    ans = 0\n    for i in range ( N ) :\n        if int ( S [ i ] ) % p == 0 :\n            ans += i + 1\nprint ( ans )\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE N , p = map ( int , input ( ) . split ( ) ) NEW_LINE S = input ( ) NEW_LINE S = S [ : : - 1 ] NEW_LINE d = defaultdict ( lambda : 0 ) NEW_LINE r = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT r += int ( S [ i ] ) * pow ( 10 , i , p ) NEW_LINE r %= p NEW_LINE d [ r ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for r in d : NEW_LINE INDENT ans += d [ r ] * ( d [ r ] - 1 ) // 2 NEW_LINE DEDENT ans += d [ 0 ] NEW_LINE if p == 2 or p == 5 : NEW_LINE INDENT S = S [ : : - 1 ] NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if int ( S [ i ] ) % p == 0 : NEW_LINE INDENT ans += i + 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_1065_B", "sol": 0, "python_code": "def line2int ( linea ) :\n    temp = \"\"\n    for i in linea :\n        if i == \"\" :\n            if temp != \"\" :\n                val1 = int ( temp )\n                temp = \"\"\n        else :\n            temp = temp + i\n    val2 = int ( temp )\n    return ( val1 , val2 )\n( n , m ) = line2int ( input ( ) )\nif m == 0 :\n    minN = maxN = n\nelse :\n    minN = n - m * 2\n    if minN < 0 : minN = 0\n    i = 1\n    while m > 0 :\n        m = m - i\n        i = i + 1\n    maxN = n - i\nprint ( minN , maxN )\n", "python_code_tokenized": "def line2int ( linea ) : NEW_LINE INDENT temp = \" \" NEW_LINE for i in linea : NEW_LINE INDENT if i == \" \u2581 \" : NEW_LINE INDENT if temp != \" \" : NEW_LINE INDENT val1 = int ( temp ) NEW_LINE temp = \" \" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp = temp + i NEW_LINE DEDENT DEDENT val2 = int ( temp ) NEW_LINE return ( val1 , val2 ) NEW_LINE DEDENT ( n , m ) = line2int ( input ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT minN = maxN = n NEW_LINE DEDENT else : NEW_LINE INDENT minN = n - m * 2 NEW_LINE if minN < 0 : minN = 0 NEW_LINE i = 1 NEW_LINE while m > 0 : NEW_LINE INDENT m = m - i NEW_LINE i = i + 1 NEW_LINE DEDENT maxN = n - i NEW_LINE DEDENT print ( minN , maxN ) NEW_LINE"}
{"id": "aizu_p01635_A", "sol": 0, "python_code": "n , T = input ( ).split ( )\nf = input ( ).replace ( 'n' , n ).replace ( '^' , '**' )\nTL = 1000000000\nt = eval ( '{}*({})'.format ( T , f ) )\nprint ( t if t <= TL else 'TLE' )\n", "python_code_tokenized": "n , T = input ( ) . split ( ) NEW_LINE f = input ( ) . replace ( ' n ' , n ) . replace ( ' ^ ' , ' * * ' ) NEW_LINE TL = 1000000000 NEW_LINE t = eval ( ' { } * ( { } ) ' . format ( T , f ) ) NEW_LINE print ( t if t <= TL else ' TLE ' ) NEW_LINE"}
{"id": "geeksforgeeks_3889_A", "sol": 0, "python_code": "import math\nclass Node :\n    def __init__ ( self , data ) :\n        self.data = data\n        self.next = None\ndef getNode ( data ) :\n    new_node = Node ( data )\n    new_node.data = data\n    new_node.next = None\n    new_node.prev = None\n    return new_node\ndef push ( head_ref , new_node ) :\n    new_node.prev = None\n    new_node.next = head_ref\n    if ( head_ref != None ) :\n        head_ref.prev = new_node\n    head_ref = new_node\n    return head_ref\ndef reverseList ( head_ref ) :\n    if ( head_ref == None or ( head_ref ).next == None ) :\n        return None\n    new_head = None\n    curr = head_ref\n    while ( curr != None ) :\n        next = curr.next\n        new_head = push ( new_head , curr )\n        curr = next\n    head_ref = new_head\n    return head_ref\ndef prList ( head ) :\n    while ( head != None ) :\n        print ( head.data , end = \"\" )\n        head = head.next\nif __name__ == '__main__' :\n    head = None\n    head = push ( head , getNode ( 2 ) ) ;\n    head = push ( head , getNode ( 4 ) ) ;\n    head = push ( head , getNode ( 8 ) ) ;\n    head = push ( head , getNode ( 10 ) ) ;\n    print ( \"Original list: \" , end = \"\" )\n    prList ( head )\n    head = reverseList ( head )\n    print ( \"\\nReversed list: \" , end = \"\" )\n    prList ( head )\n", "python_code_tokenized": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def getNode ( data ) : NEW_LINE INDENT new_node = Node ( data ) NEW_LINE new_node . data = data NEW_LINE new_node . next = None NEW_LINE new_node . prev = None NEW_LINE return new_node NEW_LINE DEDENT def push ( head_ref , new_node ) : NEW_LINE INDENT new_node . prev = None NEW_LINE new_node . next = head_ref NEW_LINE if ( head_ref != None ) : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def reverseList ( head_ref ) : NEW_LINE INDENT if ( head_ref == None or ( head_ref ) . next == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT new_head = None NEW_LINE curr = head_ref NEW_LINE while ( curr != None ) : NEW_LINE INDENT next = curr . next NEW_LINE new_head = push ( new_head , curr ) NEW_LINE curr = next NEW_LINE DEDENT head_ref = new_head NEW_LINE return head_ref NEW_LINE DEDENT def prList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" \u2581 \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , getNode ( 2 ) ) ; NEW_LINE head = push ( head , getNode ( 4 ) ) ; NEW_LINE head = push ( head , getNode ( 8 ) ) ; NEW_LINE head = push ( head , getNode ( 10 ) ) ; NEW_LINE print ( \" Original \u2581 list : \u2581 \" , end = \" \" ) NEW_LINE prList ( head ) NEW_LINE head = reverseList ( head ) NEW_LINE print ( \" \\n Reversed \u2581 list : \u2581 \" , end = \" \" ) NEW_LINE prList ( head ) NEW_LINE DEDENT"}
{"id": "codeforces_1227_A", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\nfor _ in range ( int ( input ( ) ) ) :\n    n = int ( input ( ) )\n    c , d = 0 , 10 ** 9\n    for _ in range ( n ) :\n        a , b = map ( int , input ( ).split ( ) )\n        if a > c :\n            c = a\n        if b < d :\n            d = b\n    if c <= d :\n        print ( 0 )\n    else :\n        print ( c - d )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE c , d = 0 , 10 ** 9 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > c : NEW_LINE INDENT c = a NEW_LINE DEDENT if b < d : NEW_LINE INDENT d = b NEW_LINE DEDENT DEDENT if c <= d : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c - d ) NEW_LINE DEDENT DEDENT"}
{"id": "projecteuler_p100_A", "sol": 0, "python_code": "import eulerlib\ndef compute ( ) :\n    x0 = 3\n    y0 = 1\n    x = x0\n    y = y0\n    while True :\n        sqrt = eulerlib.sqrt ( y ** 2 * 8 + 1 )\n        if sqrt % 2 == 1 :\n            blue = ( sqrt + 1 ) // 2 + y\n            if blue + y > 10 ** 12 :\n                return str ( blue )\n        nextx = x * x0 + y * y0 * 8\n        nexty = x * y0 + y * x0\n        x = nextx\n        y = nexty\nif __name__ == \"__main__\" :\n    print ( compute ( ) )\n", "python_code_tokenized": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT x0 = 3 NEW_LINE y0 = 1 NEW_LINE x = x0 NEW_LINE y = y0 NEW_LINE while True : NEW_LINE INDENT sqrt = eulerlib . sqrt ( y ** 2 * 8 + 1 ) NEW_LINE if sqrt % 2 == 1 : NEW_LINE INDENT blue = ( sqrt + 1 ) // 2 + y NEW_LINE if blue + y > 10 ** 12 : NEW_LINE INDENT return str ( blue ) NEW_LINE DEDENT DEDENT nextx = x * x0 + y * y0 * 8 NEW_LINE nexty = x * y0 + y * x0 NEW_LINE x = nextx NEW_LINE y = nexty NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC146_F", "sol": 0, "python_code": "import sys\nsys.setrecursionlimit ( 10 ** 9 )\nINF = 10 ** 18\ndef input ( ) :\n    return sys.stdin.readline ( ).rstrip ( )\ndef main ( ) :\n    N , M = map ( int , input ( ).split ( ) )\n    S = list ( reversed ( list ( input ( ) ) ) )\n    i = 0\n    f = True\n    l = [ ]\n    while True :\n        num = 0\n        for j in range ( M ) :\n            if i + ( M - j ) >= N :\n                num = N - i\n                break\n            else :\n                if S [ i + ( M - j ) ] == '0' :\n                    num = M - j\n                    break\n                else :\n                    if j == M - 1 :\n                        f = False\n        l.append ( str ( num ) )\n        i += num\n        if f == False :\n            print ( - 1 )\n            exit ( )\n        if i >= N :\n            break\n    print ( ' '.join ( reversed ( l ) ) )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = 10 ** 18 NEW_LINE def input ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) . rstrip ( ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N , M = map ( int , input ( ) . split ( ) ) NEW_LINE S = list ( reversed ( list ( input ( ) ) ) ) NEW_LINE i = 0 NEW_LINE f = True NEW_LINE l = [ ] NEW_LINE while True : NEW_LINE INDENT num = 0 NEW_LINE for j in range ( M ) : NEW_LINE INDENT if i + ( M - j ) >= N : NEW_LINE INDENT num = N - i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT if S [ i + ( M - j ) ] == '0' : NEW_LINE INDENT num = M - j NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT if j == M - 1 : NEW_LINE INDENT f = False NEW_LINE DEDENT DEDENT DEDENT DEDENT l . append ( str ( num ) ) NEW_LINE i += num NEW_LINE if f == False : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if i >= N : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ' \u2581 ' . join ( reversed ( l ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC048_B", "sol": 0, "python_code": "abx = list ( map ( int , input ( ).split ( ) ) )\ndef d ( a , b ) :\n    if a < 0 :\n        return - 1\n    else :\n        return a // b\na = d ( abx [ 0 ] - 1 , abx [ 2 ] )\nb = d ( abx [ 1 ] , abx [ 2 ] )\nprint ( b - a )\n", "python_code_tokenized": "abx = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def d ( a , b ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return a // b NEW_LINE DEDENT DEDENT a = d ( abx [ 0 ] - 1 , abx [ 2 ] ) NEW_LINE b = d ( abx [ 1 ] , abx [ 2 ] ) NEW_LINE print ( b - a ) NEW_LINE"}
{"id": "aizu_p00505_A", "sol": 0, "python_code": "import sys\nfrom sys import stdin\nfrom math import asin , pi , sqrt , degrees\ninput = stdin.readline\ndef main ( args ) :\n    triangle = 0\n    right_triangle = 0\n    acute_triangle = 0\n    obtuse_triangle = 0\n    while True :\n        lines = [ int ( x ) for x in input ( ).split ( ) ]\n        lines.sort ( )\n        a , b , c = lines [ 0 ] , lines [ 1 ] , lines [ 2 ]\n        if a + b <= c :\n            break\n        triangle += 1\n        if a ** 2 + b ** 2 == c ** 2 :\n            right_triangle += 1\n            continue\n        s = ( a + b + c ) / 2\n        area = sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) )\n        h = ( 2 * area ) / c\n        A = degrees ( asin ( h / b ) )\n        B = degrees ( asin ( h / a ) )\n        C = 180 - ( A + B )\n        if A < 90 and B < 90 and C < 90 :\n            acute_triangle += 1\n        else :\n            obtuse_triangle += 1\n    print ( triangle , right_triangle , acute_triangle , obtuse_triangle )\nif __name__ == '__main__' :\n    main ( sys.argv [ 1 : ] )\n", "python_code_tokenized": "import sys NEW_LINE from sys import stdin NEW_LINE from math import asin , pi , sqrt , degrees NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT triangle = 0 NEW_LINE right_triangle = 0 NEW_LINE acute_triangle = 0 NEW_LINE obtuse_triangle = 0 NEW_LINE while True : NEW_LINE INDENT lines = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE lines . sort ( ) NEW_LINE a , b , c = lines [ 0 ] , lines [ 1 ] , lines [ 2 ] NEW_LINE if a + b <= c : NEW_LINE INDENT break NEW_LINE DEDENT triangle += 1 NEW_LINE if a ** 2 + b ** 2 == c ** 2 : NEW_LINE INDENT right_triangle += 1 NEW_LINE continue NEW_LINE DEDENT s = ( a + b + c ) / 2 NEW_LINE area = sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE h = ( 2 * area ) / c NEW_LINE A = degrees ( asin ( h / b ) ) NEW_LINE B = degrees ( asin ( h / a ) ) NEW_LINE C = 180 - ( A + B ) NEW_LINE if A < 90 and B < 90 and C < 90 : NEW_LINE INDENT acute_triangle += 1 NEW_LINE DEDENT else : NEW_LINE INDENT obtuse_triangle += 1 NEW_LINE DEDENT DEDENT print ( triangle , right_triangle , acute_triangle , obtuse_triangle ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3535_A", "sol": 0, "python_code": "def lcs ( X , Y , m , n ) :\n    if ( m == 0 or n == 0 ) :\n        return 0\n    if ( X [ m - 1 ] == Y [ n - 1 ] ) :\n        return 1 + lcs ( X , Y , m - 1 , n - 1 )\n    else :\n        return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) )\nif __name__ == '__main__' :\n    X = \"AGGTAB\"\n    Y = \"GXTXAYB\"\n    m = len ( X )\n    n = len ( Y )\n    print ( \"Length of LCS:\" , lcs ( X , Y , m , n ) )\n", "python_code_tokenized": "def lcs ( X , Y , m , n ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + lcs ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = \" AGGTAB \" NEW_LINE Y = \" GXTXAYB \" NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( \" Length \u2581 of \u2581 LCS : \" , lcs ( X , Y , m , n ) ) NEW_LINE DEDENT"}
{"id": "codeforces_224_B", "sol": 0, "python_code": "import sys\ninput = sys.stdin.readline\ndef inp ( ) :\n    return ( int ( input ( ) ) )\ndef inlt ( ) :\n    return ( list ( map ( int , input ( ).split ( ) ) ) )\ndef insr ( ) :\n    s = input ( )\n    return ( list ( s [ : len ( s ) - 1 ] ) )\ndef invr ( ) :\n    return ( map ( int , input ( ).split ( ) ) )\n[ n , k ] = inlt ( )\na = inlt ( )\nseen = { }\nfor i in range ( n ) :\n    seen [ a [ i ] ] = i + 1\n    if len ( seen ) == k :\n        break\nif len ( seen ) == k :\n    print ( min ( seen.values ( ) ) , max ( seen.values ( ) ) )\nelse :\n    print ( - 1 , - 1 )\n", "python_code_tokenized": "import sys NEW_LINE input = sys . stdin . readline NEW_LINE def inp ( ) : NEW_LINE INDENT return ( int ( input ( ) ) ) NEW_LINE DEDENT def inlt ( ) : NEW_LINE INDENT return ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT def insr ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE return ( list ( s [ : len ( s ) - 1 ] ) ) NEW_LINE DEDENT def invr ( ) : NEW_LINE INDENT return ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT [ n , k ] = inlt ( ) NEW_LINE a = inlt ( ) NEW_LINE seen = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT seen [ a [ i ] ] = i + 1 NEW_LINE if len ( seen ) == k : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if len ( seen ) == k : NEW_LINE INDENT print ( min ( seen . values ( ) ) , max ( seen . values ( ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 , - 1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3194_A", "sol": 0, "python_code": "def xorRange ( pre , l , r ) :\n    cntOnes = pre [ r ]\n    if ( l - 1 >= 0 ) :\n        cntOnes -= pre [ l - 1 ]\n    if ( cntOnes % 2 == 0 ) :\n        return 0\n    else :\n        return 1\ndef performQueries ( queries , q , a , n ) :\n    pre = [ 0 for i in range ( n ) ]\n    pre [ 0 ] = a [ 0 ]\n    for i in range ( 1 , n ) :\n        pre [ i ] = pre [ i - 1 ] + a [ i ]\n    for i in range ( q ) :\n        print ( xorRange ( pre , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) )\na = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 ]\nn = len ( a )\nqueries = [ [ 0 , 3 ] , [ 0 , 2 ] ]\nq = len ( queries )\nperformQueries ( queries , q , a , n )\n", "python_code_tokenized": "def xorRange ( pre , l , r ) : NEW_LINE INDENT cntOnes = pre [ r ] NEW_LINE if ( l - 1 >= 0 ) : NEW_LINE INDENT cntOnes -= pre [ l - 1 ] NEW_LINE DEDENT if ( cntOnes % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def performQueries ( queries , q , a , n ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE pre [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( xorRange ( pre , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT a = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE queries = [ [ 0 , 3 ] , [ 0 , 2 ] ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( queries , q , a , n ) NEW_LINE"}
{"id": "aizu_p00282_A", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nwhile n != 0 :\n    val = pow ( n , m )\n    x = [ \"\" , \"Man\" , \"Oku\" , \"Cho\" , \"Kei\" , \"Gai\" , \"Jo\" , \"Jou\" , \"Ko\" , \"Kan\" , \"Sei\" , \"Sai\" , \"Gok\" , \"Ggs\" , \"Asg\" , \"Nyt\" , \"Fks\" , \"Mts\" ]\n    ans = [ ]\n    for i in x :\n        if val % 10000 > 0 :\n            ans.append ( str ( val % 10000 ) + i )\n        val //= 10000\n    print ( ''.join ( ans [ : : - 1 ] ) )\n    n , m = map ( int , input ( ).split ( ) )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE while n != 0 : NEW_LINE INDENT val = pow ( n , m ) NEW_LINE x = [ \" \" , \" Man \" , \" Oku \" , \" Cho \" , \" Kei \" , \" Gai \" , \" Jo \" , \" Jou \" , \" Ko \" , \" Kan \" , \" Sei \" , \" Sai \" , \" Gok \" , \" Ggs \" , \" Asg \" , \" Nyt \" , \" Fks \" , \" Mts \" ] NEW_LINE ans = [ ] NEW_LINE for i in x : NEW_LINE INDENT if val % 10000 > 0 : NEW_LINE INDENT ans . append ( str ( val % 10000 ) + i ) NEW_LINE DEDENT val //= 10000 NEW_LINE DEDENT print ( ' ' . join ( ans [ : : - 1 ] ) ) NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT"}
{"id": "codeforces_358_A", "sol": 0, "python_code": "n = int ( input ( ) )\nx = list ( map ( int , input ( ).split ( ) ) )\nflag = True\nif n <= 3 :\n    print ( 'no' )\nelse :\n    for i in range ( 0 , n - 1 ) :\n        left = min ( x [ i ] , x [ i + 1 ] )\n        right = max ( x [ i ] , x [ i + 1 ] )\n        for idx in range ( i + 2 , n - 1 ) :\n            tmp_left = min ( x [ idx ] , x [ idx + 1 ] )\n            tmp_right = max ( x [ idx ] , x [ idx + 1 ] )\n            if ( left < tmp_left < right and right < tmp_right ) or ( left < tmp_right < right and left > tmp_left ) :\n                print ( 'yes' )\n                flag = False\n                break\n        if not flag :\n            break\n    if flag :\n        print ( 'no' )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE flag = True NEW_LINE if n <= 3 : NEW_LINE INDENT print ( ' no ' ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT left = min ( x [ i ] , x [ i + 1 ] ) NEW_LINE right = max ( x [ i ] , x [ i + 1 ] ) NEW_LINE for idx in range ( i + 2 , n - 1 ) : NEW_LINE INDENT tmp_left = min ( x [ idx ] , x [ idx + 1 ] ) NEW_LINE tmp_right = max ( x [ idx ] , x [ idx + 1 ] ) NEW_LINE if ( left < tmp_left < right and right < tmp_right ) or ( left < tmp_right < right and left > tmp_left ) : NEW_LINE INDENT print ( ' yes ' ) NEW_LINE flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( ' no ' ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_96_A", "sol": 0, "python_code": "x = input ( )\nif len ( x ) > 7 :\n    if \"0000000\" in x or \"1111111\" in x :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "x = input ( ) NEW_LINE if len ( x ) > 7 : NEW_LINE INDENT if \"0000000\" in x or \"1111111\" in x : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "aizu_p00760_A", "sol": 0, "python_code": "def days ( y , m , d ) :\n    cnt = 0\n    for i in range ( 1 , y ) :\n        if i % 3 == 0 :\n            cnt += 200\n        else :\n            cnt += 195\n    for i in range ( 1 , m ) :\n        if y % 3 == 0 :\n            cnt += 20\n        else :\n            if i % 2 == 0 :\n                cnt += 19\n            else :\n                cnt += 20\n    cnt += d - 1\n    return cnt\nn = int ( input ( ) )\nfor i in range ( n ) :\n    y , m , d = map ( int , input ( ).split ( ) )\n    print ( days ( 1000 , 1 , 1 ) - days ( y , m , d ) )\n", "python_code_tokenized": "def days ( y , m , d ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , y ) : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT cnt += 200 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 195 NEW_LINE DEDENT DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT if y % 3 == 0 : NEW_LINE INDENT cnt += 20 NEW_LINE DEDENT else : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT cnt += 19 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 20 NEW_LINE DEDENT DEDENT DEDENT cnt += d - 1 NEW_LINE return cnt NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT y , m , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( days ( 1000 , 1 , 1 ) - days ( y , m , d ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1627_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor _ in range ( t ) :\n    n , m , r , c = list ( map ( int , input ( ).split ( ) ) )\n    is_black = black_row = black_col = has_black = False\n    for i in range ( 1 , n + 1 ) :\n        row = input ( )\n        if i != r :\n            if row [ c - 1 ] == 'B' :\n                black_col = True\n        else :\n            if row [ c - 1 ] == 'B' :\n                is_black = True\n            if row != 'W' * m :\n                black_row = True\n        if row != 'W' * m :\n            has_black = True\n    if is_black :\n        print ( 0 )\n    elif black_row or black_col :\n        print ( 1 )\n    elif has_black :\n        print ( 2 )\n    else :\n        print ( - 1 )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m , r , c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE is_black = black_row = black_col = has_black = False NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT row = input ( ) NEW_LINE if i != r : NEW_LINE INDENT if row [ c - 1 ] == ' B ' : NEW_LINE INDENT black_col = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if row [ c - 1 ] == ' B ' : NEW_LINE INDENT is_black = True NEW_LINE DEDENT if row != ' W ' * m : NEW_LINE INDENT black_row = True NEW_LINE DEDENT DEDENT if row != ' W ' * m : NEW_LINE INDENT has_black = True NEW_LINE DEDENT DEDENT if is_black : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif black_row or black_col : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif has_black : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_56_B", "sol": 0, "python_code": "n = int ( input ( ) )\narr = list ( map ( int , input ( ).split ( ) ) )\nl , r = - 1 , - 1\nfor i in range ( n ) :\n    if arr [ i ] != i + 1 :\n        l = i\n        break\nfor i in range ( n - 1 , - 1 , - 1 ) :\n    if arr [ i ] != i + 1 :\n        r = i\n        break\ns = r + 1\nfor i in range ( l , s ) :\n    if arr [ i ] == s :\n        s -= 1\n        continue\n    else :\n        print ( 0 , 0 )\n        exit ( 0 )\nprint ( l + 1 , r + 1 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l , r = - 1 , - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != i + 1 : NEW_LINE INDENT l = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] != i + 1 : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT s = r + 1 NEW_LINE for i in range ( l , s ) : NEW_LINE INDENT if arr [ i ] == s : NEW_LINE INDENT s -= 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , 0 ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT print ( l + 1 , r + 1 ) NEW_LINE"}
{"id": "geeksforgeeks_826_A", "sol": 0, "python_code": "def maximumArea ( l , b , x , y ) :\n    left , right , above , below = 0 , 0 , 0 , 0\n    left = x * b\n    right = ( l - x - 1 ) * b\n    above = l * y\n    below = ( b - y - 1 ) * l\n    print ( max ( max ( left , right ) , max ( above , below ) ) )\nl = 8\nb = 8\nx = 0\ny = 0\nmaximumArea ( l , b , x , y )\n", "python_code_tokenized": "def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left , right , above , below = 0 , 0 , 0 , 0 NEW_LINE left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = ( b - y - 1 ) * l NEW_LINE print ( max ( max ( left , right ) , max ( above , below ) ) ) NEW_LINE DEDENT l = 8 NEW_LINE b = 8 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE maximumArea ( l , b , x , y ) NEW_LINE"}
{"id": "geeksforgeeks_4603_A", "sol": 0, "python_code": "def findNthNumber ( A , B , N ) :\n    sum = 0\n    for i in range ( 2 , N ) :\n        sum = A + B\n        A = B\n        B = sum\n    return sum\nif __name__ == '__main__' :\n    A = 5\n    B = 7\n    N = 10\n    print ( findNthNumber ( A , B , N ) )\n", "python_code_tokenized": "def findNthNumber ( A , B , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT sum = A + B NEW_LINE A = B NEW_LINE B = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 5 NEW_LINE B = 7 NEW_LINE N = 10 NEW_LINE print ( findNthNumber ( A , B , N ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1622_A", "sol": 0, "python_code": "def two_way_sort ( arr , arr_len ) :\n    l , r = 0 , arr_len - 1\n    k = 0\n    while ( l < r ) :\n        while ( arr [ l ] % 2 != 0 ) :\n            l += 1\n            k += 1\n        while ( arr [ r ] % 2 == 0 and l < r ) :\n            r -= 1\n        if ( l < r ) :\n            arr [ l ] , arr [ r ] = arr [ r ] , arr [ l ]\n    odd = arr [ : k ]\n    even = arr [ k : ]\n    odd.sort ( reverse = True )\n    even.sort ( )\n    odd.extend ( even )\n    return odd\narr_len = 6\narr = [ 1 , 3 , 2 , 7 , 5 , 4 ]\nresult = two_way_sort ( arr , arr_len )\nfor i in result :\n    print ( str ( i ) + \" \" ) ,\n", "python_code_tokenized": "def two_way_sort ( arr , arr_len ) : NEW_LINE INDENT l , r = 0 , arr_len - 1 NEW_LINE k = 0 NEW_LINE while ( l < r ) : NEW_LINE INDENT while ( arr [ l ] % 2 != 0 ) : NEW_LINE INDENT l += 1 NEW_LINE k += 1 NEW_LINE DEDENT while ( arr [ r ] % 2 == 0 and l < r ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT if ( l < r ) : NEW_LINE INDENT arr [ l ] , arr [ r ] = arr [ r ] , arr [ l ] NEW_LINE DEDENT DEDENT odd = arr [ : k ] NEW_LINE even = arr [ k : ] NEW_LINE odd . sort ( reverse = True ) NEW_LINE even . sort ( ) NEW_LINE odd . extend ( even ) NEW_LINE return odd NEW_LINE DEDENT arr_len = 6 NEW_LINE arr = [ 1 , 3 , 2 , 7 , 5 , 4 ] NEW_LINE result = two_way_sort ( arr , arr_len ) NEW_LINE for i in result : NEW_LINE INDENT print ( str ( i ) + \" \u2581 \" ) , NEW_LINE DEDENT"}
{"id": "atcoder_ABC155_C", "sol": 0, "python_code": "import collections\nN = int ( input ( ) )\nmoji = [ input ( ) for i in range ( N ) ]\nmoji_count = collections.Counter ( moji )\nmax_kv = max ( moji_count.items ( ) , key = lambda x : x [ 1 ] )\nmax_moji = [ ]\nfor i , j in moji_count.items ( ) :\n    if j == max_kv [ 1 ] :\n        max_moji.append ( i )\nmax_sort = sorted ( max_moji )\nfor i in max_sort :\n    print ( i )\n", "python_code_tokenized": "import collections NEW_LINE N = int ( input ( ) ) NEW_LINE moji = [ input ( ) for i in range ( N ) ] NEW_LINE moji_count = collections . Counter ( moji ) NEW_LINE max_kv = max ( moji_count . items ( ) , key = lambda x : x [ 1 ] ) NEW_LINE max_moji = [ ] NEW_LINE for i , j in moji_count . items ( ) : NEW_LINE INDENT if j == max_kv [ 1 ] : NEW_LINE INDENT max_moji . append ( i ) NEW_LINE DEDENT DEDENT max_sort = sorted ( max_moji ) NEW_LINE for i in max_sort : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3092_A", "sol": 0, "python_code": "class Graph :\n    def __init__ ( self , V ) :\n        self.V = V\n        self.adj = [ [ ] for i in range ( V ) ]\n    def addEdge ( self , v , w ) :\n        self.adj [ v ].append ( w )\n    def DFS ( self , s ) :\n        visited = [ False for i in range ( self.V ) ]\n        stack = [ ]\n        stack.append ( s )\n        while ( len ( stack ) ) :\n            s = stack [ - 1 ]\n            stack.pop ( )\n            if ( not visited [ s ] ) :\n                print ( s , end = ' ' )\n                visited [ s ] = True\n            for node in self.adj [ s ] :\n                if ( not visited [ node ] ) :\n                    stack.append ( node )\ng = Graph ( 5 ) ;\ng.addEdge ( 1 , 0 ) ;\ng.addEdge ( 0 , 2 ) ;\ng.addEdge ( 2 , 1 ) ;\ng.addEdge ( 0 , 3 ) ;\ng.addEdge ( 1 , 4 ) ;\nprint ( \"Following is Depth First Traversal\" )\ng.DFS ( 0 )\n", "python_code_tokenized": "class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def DFS ( self , s ) : NEW_LINE INDENT visited = [ False for i in range ( self . V ) ] NEW_LINE stack = [ ] NEW_LINE stack . append ( s ) NEW_LINE while ( len ( stack ) ) : NEW_LINE INDENT s = stack [ - 1 ] NEW_LINE stack . pop ( ) NEW_LINE if ( not visited [ s ] ) : NEW_LINE INDENT print ( s , end = ' \u2581 ' ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT for node in self . adj [ s ] : NEW_LINE INDENT if ( not visited [ node ] ) : NEW_LINE INDENT stack . append ( node ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( 5 ) ; NEW_LINE g . addEdge ( 1 , 0 ) ; NEW_LINE g . addEdge ( 0 , 2 ) ; NEW_LINE g . addEdge ( 2 , 1 ) ; NEW_LINE g . addEdge ( 0 , 3 ) ; NEW_LINE g . addEdge ( 1 , 4 ) ; NEW_LINE print ( \" Following \u2581 is \u2581 Depth \u2581 First \u2581 Traversal \" ) NEW_LINE g . DFS ( 0 ) NEW_LINE"}
{"id": "geeksforgeeks_3093_A", "sol": 0, "python_code": "class Graph :\n    def __init__ ( self , V ) :\n        self.V = V\n        self.adj = [ [ ] for i in range ( V ) ]\n    def addEdge ( self , v , w ) :\n        self.adj [ v ].append ( w )\n    def DFSUtil ( self , s , visited ) :\n        stack = [ ]\n        stack.append ( s )\n        while ( len ( stack ) != 0 ) :\n            s = stack.pop ( )\n            if ( not visited [ s ] ) :\n                print ( s , end = \" \" )\n                visited [ s ] = True\n            i = 0\n            while i < len ( self.adj [ s ] ) :\n                if ( not visited [ self.adj [ s ] [ i ] ] ) :\n                    stack.append ( self.adj [ s ] [ i ] )\n                i += 1\n    def DFS ( self ) :\n        visited = [ False ] * self.V\n        for i in range ( self.V ) :\n            if ( not visited [ i ] ) :\n                self.DFSUtil ( i , visited )\nif __name__ == '__main__' :\n    g = Graph ( 5 )\n    g.addEdge ( 1 , 0 )\n    g.addEdge ( 2 , 1 )\n    g.addEdge ( 3 , 4 )\n    g.addEdge ( 4 , 0 )\n    print ( \"Following is Depth First Traversal\" )\n    g.DFS ( )\n", "python_code_tokenized": "class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def DFSUtil ( self , s , visited ) : NEW_LINE INDENT stack = [ ] NEW_LINE stack . append ( s ) NEW_LINE while ( len ( stack ) != 0 ) : NEW_LINE INDENT s = stack . pop ( ) NEW_LINE if ( not visited [ s ] ) : NEW_LINE INDENT print ( s , end = \" \u2581 \" ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( self . adj [ s ] ) : NEW_LINE INDENT if ( not visited [ self . adj [ s ] [ i ] ] ) : NEW_LINE INDENT stack . append ( self . adj [ s ] [ i ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT def DFS ( self ) : NEW_LINE INDENT visited = [ False ] * self . V NEW_LINE for i in range ( self . V ) : NEW_LINE INDENT if ( not visited [ i ] ) : NEW_LINE INDENT self . DFSUtil ( i , visited ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT g = Graph ( 5 ) NEW_LINE g . addEdge ( 1 , 0 ) NEW_LINE g . addEdge ( 2 , 1 ) NEW_LINE g . addEdge ( 3 , 4 ) NEW_LINE g . addEdge ( 4 , 0 ) NEW_LINE print ( \" Following \u2581 is \u2581 Depth \u2581 First \u2581 Traversal \" ) NEW_LINE g . DFS ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5147_A", "sol": 0, "python_code": "def removeZeros ( a , n ) :\n    ind = - 1 ;\n    for i in range ( n ) :\n        if ( a [ i ] != 0 ) :\n            ind = i ;\n            break ;\n    if ( ind == - 1 ) :\n        print ( \"Array has leading zeros only\" ) ;\n        return ;\n    b = [ 0 ] * ( n - ind ) ;\n    for i in range ( n - ind ) :\n        b [ i ] = a [ ind + i ] ;\n    for i in range ( n - ind ) :\n        print ( b [ i ] , end = \" \" ) ;\na = [ 0 , 0 , 0 , 1 , 2 , 0 , 3 ] ;\nn = len ( a ) ;\nremoveZeros ( a , n ) ;\n", "python_code_tokenized": "def removeZeros ( a , n ) : NEW_LINE INDENT ind = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 0 ) : NEW_LINE INDENT ind = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( ind == - 1 ) : NEW_LINE INDENT print ( \" Array \u2581 has \u2581 leading \u2581 zeros \u2581 only \" ) ; NEW_LINE return ; NEW_LINE DEDENT b = [ 0 ] * ( n - ind ) ; NEW_LINE for i in range ( n - ind ) : NEW_LINE INDENT b [ i ] = a [ ind + i ] ; NEW_LINE DEDENT for i in range ( n - ind ) : NEW_LINE INDENT print ( b [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT a = [ 0 , 0 , 0 , 1 , 2 , 0 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE removeZeros ( a , n ) ; NEW_LINE"}
{"id": "codeforces_190_B", "sol": 0, "python_code": "x1 , y1 , r1 = map ( int , input ( ).split ( ) )\nx2 , y2 , r2 = map ( int , input ( ).split ( ) )\nd = ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** 0.5\nif d >= r1 + r2 :\n    print ( ( d - r1 - r2 ) / 2 )\nelse :\n    print ( max ( 0 , ( max ( r1 , r2 ) - d - min ( r1 , r2 ) ) ) / 2 )\n", "python_code_tokenized": "x1 , y1 , r1 = map ( int , input ( ) . split ( ) ) NEW_LINE x2 , y2 , r2 = map ( int , input ( ) . split ( ) ) NEW_LINE d = ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** 0.5 NEW_LINE if d >= r1 + r2 : NEW_LINE INDENT print ( ( d - r1 - r2 ) / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( 0 , ( max ( r1 , r2 ) - d - min ( r1 , r2 ) ) ) / 2 ) NEW_LINE DEDENT"}
{"id": "codeforces_1513_A", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n , k = map ( int , input ( ).split ( ) )\n    possible = 1 + ( n - 3 ) // 2\n    if k > possible :\n        print ( - 1 )\n    elif k == 0 :\n        print ( ' '.join ( map ( str , [ i + 1 for i in range ( n ) ] ) ) )\n    else :\n        re = 1\n        li = [ 1 , 3 , 2 ]\n        counter = 4\n        while re < k :\n            li.append ( counter + 1 )\n            li.append ( counter )\n            counter += 2\n            re += 1\n        for iii in range ( li [ - 2 ] + 1 , n + 1 ) :\n            li.append ( iii )\n        print ( ' '.join ( map ( str , li ) ) )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE possible = 1 + ( n - 3 ) // 2 NEW_LINE if k > possible : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif k == 0 : NEW_LINE INDENT print ( ' \u2581 ' . join ( map ( str , [ i + 1 for i in range ( n ) ] ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT re = 1 NEW_LINE li = [ 1 , 3 , 2 ] NEW_LINE counter = 4 NEW_LINE while re < k : NEW_LINE INDENT li . append ( counter + 1 ) NEW_LINE li . append ( counter ) NEW_LINE counter += 2 NEW_LINE re += 1 NEW_LINE DEDENT for iii in range ( li [ - 2 ] + 1 , n + 1 ) : NEW_LINE INDENT li . append ( iii ) NEW_LINE DEDENT print ( ' \u2581 ' . join ( map ( str , li ) ) ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ARC073_C", "sol": 0, "python_code": "n = int ( input ( ) )\nx , y = zip ( * sorted ( sorted ( map ( int , input ( ).split ( ) ) ) for _ in range ( n ) ) )\np = max ( range ( n ) , key = lambda i : y [ i ] )\nr = a = x [ - 1 ]\nb = d = 10 ** 9\nfor i in range ( p ) :\n    if b <= x [ i ] :\n        break\n    a = max ( a , y [ i ] )\n    b = min ( b , y [ i ] )\n    d = min ( d , a - min ( b , x [ i + 1 ] ) )\nprint ( min ( ( x [ - 1 ] - x [ 0 ] ) * ( y [ p ] - min ( y ) ) , ( y [ p ] - x [ 0 ] ) * d ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE x , y = zip ( * sorted ( sorted ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ) ) NEW_LINE p = max ( range ( n ) , key = lambda i : y [ i ] ) NEW_LINE r = a = x [ - 1 ] NEW_LINE b = d = 10 ** 9 NEW_LINE for i in range ( p ) : NEW_LINE INDENT if b <= x [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT a = max ( a , y [ i ] ) NEW_LINE b = min ( b , y [ i ] ) NEW_LINE d = min ( d , a - min ( b , x [ i + 1 ] ) ) NEW_LINE DEDENT print ( min ( ( x [ - 1 ] - x [ 0 ] ) * ( y [ p ] - min ( y ) ) , ( y [ p ] - x [ 0 ] ) * d ) ) NEW_LINE"}
{"id": "geeksforgeeks_954_A", "sol": 0, "python_code": "def countDistinct ( arr , n ) :\n    arr.sort ( ) ;\n    res = 0 ;\n    i = 0 ;\n    while ( i < n ) :\n        while ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) :\n            i += 1 ;\n        res += 1 ;\n        i += 1 ;\n    return res ;\narr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] ;\nn = len ( arr ) ;\nprint ( countDistinct ( arr , n ) ) ;\n", "python_code_tokenized": "def countDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT while ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT res += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countDistinct ( arr , n ) ) ; NEW_LINE"}
{"id": "atcoder_ABC101_B", "sol": 0, "python_code": "n = input ( )\nnStrSum = 0\nfor i in range ( len ( n ) ) :\n    nStrSum += int ( n [ i ] )\nprint ( \"Yes\" if int ( n ) % nStrSum == 0 else \"No\" )\n", "python_code_tokenized": "n = input ( ) NEW_LINE nStrSum = 0 NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT nStrSum += int ( n [ i ] ) NEW_LINE DEDENT print ( \" Yes \" if int ( n ) % nStrSum == 0 else \" No \" ) NEW_LINE"}
{"id": "codeforces_1608_B", "sol": 0, "python_code": "for _ in range ( int ( input ( ) ) ) :\n    n , a , b = [ int ( i ) for i in input ( ).split ( ) ]\n    p = [ i for i in range ( 1 , n + 1 ) ]\n    if a + b + 2 > n or abs ( a - b ) > 1 :\n        print ( - 1 )\n        continue\n    if b > a :\n        p = [ n - i + 1 for i in p ]\n    for i in range ( 1 , min ( a , b ) * 2 + 1 , 2 ) :\n        p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ]\n    if a != b :\n        p [ - 2 ] , p [ - 1 ] = p [ - 1 ] , p [ - 2 ]\n    print ( ' '.join ( [ str ( i ) for i in p ] ) )\n", "python_code_tokenized": "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , a , b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE p = [ i for i in range ( 1 , n + 1 ) ] NEW_LINE if a + b + 2 > n or abs ( a - b ) > 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE continue NEW_LINE DEDENT if b > a : NEW_LINE INDENT p = [ n - i + 1 for i in p ] NEW_LINE DEDENT for i in range ( 1 , min ( a , b ) * 2 + 1 , 2 ) : NEW_LINE INDENT p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] NEW_LINE DEDENT if a != b : NEW_LINE INDENT p [ - 2 ] , p [ - 1 ] = p [ - 1 ] , p [ - 2 ] NEW_LINE DEDENT print ( ' \u2581 ' . join ( [ str ( i ) for i in p ] ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1120_A", "sol": 0, "python_code": "def getElements ( a , arr , n ) :\n    elements = [ 1 for i in range ( n + 1 ) ]\n    elements [ 0 ] = a\n    for i in range ( n ) :\n        elements [ i + 1 ] = arr [ i ] ^ elements [ i ]\n    for i in range ( n + 1 ) :\n        print ( elements [ i ] , end = \" \" )\narr = [ 13 , 2 , 6 , 1 ]\nn = len ( arr )\na = 5\ngetElements ( a , arr , n )\n", "python_code_tokenized": "def getElements ( a , arr , n ) : NEW_LINE INDENT elements = [ 1 for i in range ( n + 1 ) ] NEW_LINE elements [ 0 ] = a NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ i + 1 ] = arr [ i ] ^ elements [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( elements [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT arr = [ 13 , 2 , 6 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE a = 5 NEW_LINE getElements ( a , arr , n ) NEW_LINE"}
{"id": "aizu_p00112_A", "sol": 0, "python_code": "while True :\n    n = int ( input ( ) )\n    if n == 0 :\n        break\n    a = sorted ( [ int ( input ( ) ) for i in range ( n ) ] )\n    print ( sum ( [ a [ i ] * ( n - i - 1 ) for i in range ( n - 1 ) ] ) )\n", "python_code_tokenized": "while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = sorted ( [ int ( input ( ) ) for i in range ( n ) ] ) NEW_LINE print ( sum ( [ a [ i ] * ( n - i - 1 ) for i in range ( n - 1 ) ] ) ) NEW_LINE DEDENT"}
{"id": "aizu_p00012_A", "sol": 0, "python_code": "import math\ndef tri ( x1 , y1 , x2 , y2 , x3 , y3 ) :\n    return math.fabs ( ( x2 - x1 ) * ( y3 - y1 ) - ( y2 - y1 ) * ( x3 - x1 ) ) / 2\nwhile True :\n    try :\n        x1 , y1 , x2 , y2 , x3 , y3 , x , y = map ( float , input ( ).split ( ) )\n    except :\n        break\n    abc = tri ( x1 , y1 , x2 , y2 , x3 , y3 )\n    abp = tri ( x1 , y1 , x2 , y2 , x , y )\n    acp = tri ( x1 , y1 , x3 , y3 , x , y )\n    bcp = tri ( x2 , y2 , x3 , y3 , x , y )\n    x , y = int ( abc * pow ( 10 , 5 ) ) , int ( ( abp + acp + bcp ) * pow ( 10 , 5 ) )\n    print ( \"YES\" if x >= y else \"NO\" )\n", "python_code_tokenized": "import math NEW_LINE def tri ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT return math . fabs ( ( x2 - x1 ) * ( y3 - y1 ) - ( y2 - y1 ) * ( x3 - x1 ) ) / 2 NEW_LINE DEDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT x1 , y1 , x2 , y2 , x3 , y3 , x , y = map ( float , input ( ) . split ( ) ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT abc = tri ( x1 , y1 , x2 , y2 , x3 , y3 ) NEW_LINE abp = tri ( x1 , y1 , x2 , y2 , x , y ) NEW_LINE acp = tri ( x1 , y1 , x3 , y3 , x , y ) NEW_LINE bcp = tri ( x2 , y2 , x3 , y3 , x , y ) NEW_LINE x , y = int ( abc * pow ( 10 , 5 ) ) , int ( ( abp + acp + bcp ) * pow ( 10 , 5 ) ) NEW_LINE print ( \" YES \" if x >= y else \" NO \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3866_A", "sol": 0, "python_code": "def Check_is_possible ( l , r , k ) :\n    div_count = ( r // k ) - ( l // k )\n    if l % k == 0 :\n        div_count += 1\n    return div_count > 1\nif __name__ == \"__main__\" :\n    l , r , k = 30 , 70 , 10\n    if Check_is_possible ( l , r , k ) == True :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "def Check_is_possible ( l , r , k ) : NEW_LINE INDENT div_count = ( r // k ) - ( l // k ) NEW_LINE if l % k == 0 : NEW_LINE INDENT div_count += 1 NEW_LINE DEDENT return div_count > 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l , r , k = 30 , 70 , 10 NEW_LINE if Check_is_possible ( l , r , k ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ARC102_A", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nN = [ i % k for i in range ( 1 , n + 1 ) ]\nif k % 2 == 0 :\n    print ( pow ( sum ( [ 1 for i in N if i == 0 ] ) , 3 ) + pow ( sum ( [ 1 for i in N if i == k // 2 ] ) , 3 ) )\nelse :\n    print ( pow ( sum ( [ 1 for i in N if i == 0 ] ) , 3 ) )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE N = [ i % k for i in range ( 1 , n + 1 ) ] NEW_LINE if k % 2 == 0 : NEW_LINE INDENT print ( pow ( sum ( [ 1 for i in N if i == 0 ] ) , 3 ) + pow ( sum ( [ 1 for i in N if i == k // 2 ] ) , 3 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( pow ( sum ( [ 1 for i in N if i == 0 ] ) , 3 ) ) NEW_LINE DEDENT"}
{"id": "codeforces_340_A", "sol": 0, "python_code": "def GCD ( a , b ) :\n    while a % b != 0 :\n        a , b = b , a % b\n    return b\ndef LCM ( a , b ) :\n    return a * b // GCD ( a , b )\nl = input ( ).split ( ' ' )\nx , y , a , b = int ( l [ 0 ] ) , int ( l [ 1 ] ) , int ( l [ 2 ] ) , int ( l [ 3 ] )\nlcm = LCM ( x , y )\nprint ( b // lcm - ( a - 1 ) // lcm )\n", "python_code_tokenized": "def GCD ( a , b ) : NEW_LINE INDENT while a % b != 0 : NEW_LINE INDENT a , b = b , a % b NEW_LINE DEDENT return b NEW_LINE DEDENT def LCM ( a , b ) : NEW_LINE INDENT return a * b // GCD ( a , b ) NEW_LINE DEDENT l = input ( ) . split ( ' \u2581 ' ) NEW_LINE x , y , a , b = int ( l [ 0 ] ) , int ( l [ 1 ] ) , int ( l [ 2 ] ) , int ( l [ 3 ] ) NEW_LINE lcm = LCM ( x , y ) NEW_LINE print ( b // lcm - ( a - 1 ) // lcm ) NEW_LINE"}
{"id": "atcoder_AGC001_D", "sol": 0, "python_code": "from sys import exit\nn , m = map ( int , input ( ).split ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nodd = [ ]\neven = [ ]\nfor x in a :\n    if x % 2 == 0 :\n        even.append ( x )\n    else :\n        odd.append ( x )\nif n % 2 == 0 :\n    if len ( odd ) > 2 :\n        print ( \"Impossible\" )\n        exit ( )\n    if len ( odd ) == 2 :\n        a = [ odd [ 0 ] ] + even + [ odd [ 1 ] ]\n        b = [ odd [ 0 ] + 1 ] + even + [ odd [ 1 ] - 1 ]\n        if b [ - 1 ] == 0 :\n            b.pop ( )\n    else :\n        a = even\n        b = [ 1 ] + even\n        b [ - 1 ] -= 1\n        if b [ - 1 ] == 0 :\n            b.pop ( )\nelse :\n    if len ( odd ) > 1 :\n        print ( \"Impossible\" )\n        exit ( )\n    if m == 1 :\n        b = [ 1 , n - 1 ]\n    else :\n        a = odd + even\n        b = [ odd [ 0 ] + 1 ] + even\n        b [ - 1 ] -= 1\n    if b [ - 1 ] == 0 :\n        b.pop ( )\nprint ( * a )\nprint ( len ( b ) )\nprint ( * b )\n", "python_code_tokenized": "from sys import exit NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE odd = [ ] NEW_LINE even = [ ] NEW_LINE for x in a : NEW_LINE INDENT if x % 2 == 0 : NEW_LINE INDENT even . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT odd . append ( x ) NEW_LINE DEDENT DEDENT if n % 2 == 0 : NEW_LINE INDENT if len ( odd ) > 2 : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE exit ( ) NEW_LINE DEDENT if len ( odd ) == 2 : NEW_LINE INDENT a = [ odd [ 0 ] ] + even + [ odd [ 1 ] ] NEW_LINE b = [ odd [ 0 ] + 1 ] + even + [ odd [ 1 ] - 1 ] NEW_LINE if b [ - 1 ] == 0 : NEW_LINE INDENT b . pop ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT a = even NEW_LINE b = [ 1 ] + even NEW_LINE b [ - 1 ] -= 1 NEW_LINE if b [ - 1 ] == 0 : NEW_LINE INDENT b . pop ( ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if len ( odd ) > 1 : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE exit ( ) NEW_LINE DEDENT if m == 1 : NEW_LINE INDENT b = [ 1 , n - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT a = odd + even NEW_LINE b = [ odd [ 0 ] + 1 ] + even NEW_LINE b [ - 1 ] -= 1 NEW_LINE DEDENT if b [ - 1 ] == 0 : NEW_LINE INDENT b . pop ( ) NEW_LINE DEDENT DEDENT print ( * a ) NEW_LINE print ( len ( b ) ) NEW_LINE print ( * b ) NEW_LINE"}
{"id": "geeksforgeeks_2307_A", "sol": 0, "python_code": "def isPossibleToMakeDivisible ( arr , n ) :\n    remainder = 0\n    for i in range ( 0 , n ) :\n        remainder = ( remainder + arr [ i ] ) % 3\n    return ( remainder == 0 )\narr = [ 40 , 50 , 90 ] ;\nn = 3\nif ( isPossibleToMakeDivisible ( arr , n ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def isPossibleToMakeDivisible ( arr , n ) : NEW_LINE INDENT remainder = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT remainder = ( remainder + arr [ i ] ) % 3 NEW_LINE DEDENT return ( remainder == 0 ) NEW_LINE DEDENT arr = [ 40 , 50 , 90 ] ; NEW_LINE n = 3 NEW_LINE if ( isPossibleToMakeDivisible ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_148_A", "sol": 0, "python_code": "import sys\ndef CalculateDifference ( arr , n ) :\n    max_val = - 1\n    for i in range ( 0 , n ) :\n        if ( arr [ i ] > max_val ) :\n            max_val = arr [ i ]\n    prime = [ True for i in range ( max_val + 1 ) ]\n    prime [ 0 ] = False\n    prime [ 1 ] = False\n    p = 2\n    while ( p * p <= max_val ) :\n        if prime [ p ] == True :\n            for i in range ( p * 2 , max_val + 1 , p ) :\n                prime [ i ] = False\n        p += 1\n    S1 = 0\n    S2 = 0\n    for i in range ( 0 , n ) :\n        if prime [ arr [ i ] ] :\n            S1 += arr [ i ]\n        elif arr [ i ] != 1 :\n            S2 += arr [ i ]\n    return abs ( S2 - S1 )\narr = [ 1 , 3 , 5 , 10 , 15 , 7 ]\nn = len ( arr )\nprint ( CalculateDifference ( arr , n ) )\n", "python_code_tokenized": "import sys NEW_LINE def CalculateDifference ( arr , n ) : NEW_LINE INDENT max_val = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_val ) : NEW_LINE INDENT max_val = arr [ i ] NEW_LINE DEDENT DEDENT prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= max_val ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT S1 = 0 NEW_LINE S2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT elif arr [ i ] != 1 : NEW_LINE INDENT S2 += arr [ i ] NEW_LINE DEDENT DEDENT return abs ( S2 - S1 ) NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 10 , 15 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CalculateDifference ( arr , n ) ) NEW_LINE"}
{"id": "geeksforgeeks_4186_A", "sol": 0, "python_code": "def isPossible ( w , h , x , y ) :\n    if ( x * 2 == w and y * 2 == h ) :\n        return True\n    return False\nif __name__ == '__main__' :\n    w = 1\n    h = 2\n    x = 1\n    y = 2\n    if ( isPossible ( w , h , x , y ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def isPossible ( w , h , x , y ) : NEW_LINE INDENT if ( x * 2 == w and y * 2 == h ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT w = 1 NEW_LINE h = 2 NEW_LINE x = 1 NEW_LINE y = 2 NEW_LINE if ( isPossible ( w , h , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "aizu_p00388_A", "sol": 0, "python_code": "h , a , b = map ( int , input ( ).split ( ) )\nans = 0\nfor i in range ( a , b + 1 ) :\n    if h % i == 0 :\n        ans += 1\nprint ( ans )\n", "python_code_tokenized": "h , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if h % i == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "atcoder_ABC158_C", "sol": 0, "python_code": "A , B = [ int ( i ) for i in input ( ).split ( ) ]\nFlag = False\nprice1 = int ( A // 0.08 ) + 1\nprice2 = int ( B // 0.1 ) + 1\nif price1 < price2 :\n    start = price1\n    end = price2\nelse :\n    start = price2\n    end = price1\nfor i in range ( start , end + 1 ) :\n    if int ( i * 0.08 ) == A and int ( i * 0.1 ) == B :\n        Flag = True\n        price = i\n        break\nif Flag == True :\n    print ( price )\nelse :\n    print ( - 1 )\n", "python_code_tokenized": "A , B = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE Flag = False NEW_LINE price1 = int ( A // 0.08 ) + 1 NEW_LINE price2 = int ( B // 0.1 ) + 1 NEW_LINE if price1 < price2 : NEW_LINE INDENT start = price1 NEW_LINE end = price2 NEW_LINE DEDENT else : NEW_LINE INDENT start = price2 NEW_LINE end = price1 NEW_LINE DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT if int ( i * 0.08 ) == A and int ( i * 0.1 ) == B : NEW_LINE INDENT Flag = True NEW_LINE price = i NEW_LINE break NEW_LINE DEDENT DEDENT if Flag == True : NEW_LINE INDENT print ( price ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"}
{"id": "atcoder_AGC011_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nsa = sorted ( a )\nr = [ ]\nsu = 0\nfor i in range ( n ) :\n    su += sa [ i ]\n    r.append ( su )\nans = 1\nfor i in range ( n - 1 ) :\n    if ( r [ ~ i - 1 ] * 2 >= sa [ ~ i ] ) :\n        ans += 1\n    else :\n        break\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sa = sorted ( a ) NEW_LINE r = [ ] NEW_LINE su = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT su += sa [ i ] NEW_LINE r . append ( su ) NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( r [ ~ i - 1 ] * 2 >= sa [ ~ i ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "codeforces_1415_B", "sol": 0, "python_code": "from collections import deque\nfrom math import *\nimport sys\nimport random\nfrom bisect import *\nfrom functools import reduce\nfor _ in range ( int ( input ( ) ) ) :\n    n , k = map ( int , input ( ).split ( ) )\n    arr = list ( map ( int , input ( ).split ( ) ) )\n    res = sys.maxsize\n    for color in range ( 1 , 101 ) :\n        i = 0\n        day = 0\n        while i < n :\n            if i < n and arr [ i ] != color :\n                i += k\n                day += 1\n            else :\n                i += 1\n        res = min ( res , day )\n    print ( res )\n", "python_code_tokenized": "from collections import deque NEW_LINE from math import * NEW_LINE import sys NEW_LINE import random NEW_LINE from bisect import * NEW_LINE from functools import reduce NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE res = sys . maxsize NEW_LINE for color in range ( 1 , 101 ) : NEW_LINE INDENT i = 0 NEW_LINE day = 0 NEW_LINE while i < n : NEW_LINE INDENT if i < n and arr [ i ] != color : NEW_LINE INDENT i += k NEW_LINE day += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT res = min ( res , day ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT"}
{"id": "codeforces_1152_B", "sol": 0, "python_code": "import sys , os , io\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\nx = int ( input ( ) )\npow2 = [ 1 ]\nfor _ in range ( 22 ) :\n    pow2.append ( 2 * pow2 [ - 1 ] )\ns = set ( )\nfor i in pow2 :\n    s.add ( i - 1 )\nt = 0\nn = [ ]\nwhile not x in s :\n    t += 1\n    n0 = x.bit_length ( )\n    n.append ( n0 )\n    x ^= ( pow2 [ n0 ] - 1 )\n    if x in s :\n        break\n    t += 1\n    x += 1\nprint ( t )\nif t :\n    sys.stdout.write ( \" \".join ( map ( str , n ) ) )\n", "python_code_tokenized": "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE x = int ( input ( ) ) NEW_LINE pow2 = [ 1 ] NEW_LINE for _ in range ( 22 ) : NEW_LINE INDENT pow2 . append ( 2 * pow2 [ - 1 ] ) NEW_LINE DEDENT s = set ( ) NEW_LINE for i in pow2 : NEW_LINE INDENT s . add ( i - 1 ) NEW_LINE DEDENT t = 0 NEW_LINE n = [ ] NEW_LINE while not x in s : NEW_LINE INDENT t += 1 NEW_LINE n0 = x . bit_length ( ) NEW_LINE n . append ( n0 ) NEW_LINE x ^= ( pow2 [ n0 ] - 1 ) NEW_LINE if x in s : NEW_LINE INDENT break NEW_LINE DEDENT t += 1 NEW_LINE x += 1 NEW_LINE DEDENT print ( t ) NEW_LINE if t : NEW_LINE INDENT sys . stdout . write ( \" \u2581 \" . join ( map ( str , n ) ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5119_A", "sol": 0, "python_code": "def check ( a , n ) :\n    if n % 2 == 1 :\n        return False\n    for i in range ( n // 2 ) :\n        if a [ i ] != a [ i + ( n // 2 ) ] :\n            return False\n    return True\nif __name__ == \"__main__\" :\n    a = [ 1 , 4 , 1 , 4 ]\n    n = len ( a )\n    if check ( a , n ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "def check ( a , n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n // 2 ) : NEW_LINE INDENT if a [ i ] != a [ i + ( n // 2 ) ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 4 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE if check ( a , n ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1857_A", "sol": 0, "python_code": "def check ( a , n ) :\n    for i in range ( n ) :\n        if ( a [ i ] ) :\n            return True\n    return False\nif __name__ == '__main__' :\n    a = [ 0 , 1 , 0 , 1 ]\n    n = len ( a )\n    if ( check ( a , n ) ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "def check ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 0 , 1 , 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE if ( check ( a , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_947_A", "sol": 0, "python_code": "def sumoflength ( arr , n ) :\n    s = [ ]\n    j = 0\n    ans = 0\n    for i in range ( n ) :\n        while ( j < n and ( arr [ j ] not in s ) ) :\n            s.append ( arr [ j ] )\n            j += 1\n        ans += ( ( j - i ) * ( j - i + 1 ) ) // 2\n        s.remove ( arr [ i ] )\n    return ans\nif __name__ == \"__main__\" :\n    arr = [ 1 , 2 , 3 , 4 ]\n    n = len ( arr )\n    print ( sumoflength ( arr , n ) )\n", "python_code_tokenized": "def sumoflength ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and ( arr [ j ] not in s ) ) : NEW_LINE INDENT s . append ( arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) // 2 NEW_LINE s . remove ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sumoflength ( arr , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2251_A", "sol": 0, "python_code": "def countWays ( n , arr ) :\n    if ( n == 0 ) :\n        return 1\n    no_ways = 0\n    for i in arr :\n        if ( n - i >= 0 ) :\n            no_ways = no_ways + countWays ( n - i , arr )\n    return no_ways\narr = [ 1 , 3 , 5 ]\nn = 5\nprint ( countWays ( n , arr ) )\n", "python_code_tokenized": "def countWays ( n , arr ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT no_ways = 0 NEW_LINE for i in arr : NEW_LINE INDENT if ( n - i >= 0 ) : NEW_LINE INDENT no_ways = no_ways + countWays ( n - i , arr ) NEW_LINE DEDENT DEDENT return no_ways NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] NEW_LINE n = 5 NEW_LINE print ( countWays ( n , arr ) ) NEW_LINE"}
{"id": "geeksforgeeks_1573_A", "sol": 0, "python_code": "import sys\ndef findLCM ( a , b ) :\n    lar = max ( a , b )\n    small = min ( a , b )\n    i = lar\n    while ( 1 ) :\n        if ( i % small == 0 ) :\n            return i\n        i += lar\na = 5\nb = 7\nprint ( \"LCM of \" , a , \" and \" , b , \" is \" , findLCM ( a , b ) , sep = \"\" )\n", "python_code_tokenized": "import sys NEW_LINE def findLCM ( a , b ) : NEW_LINE INDENT lar = max ( a , b ) NEW_LINE small = min ( a , b ) NEW_LINE i = lar NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( i % small == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += lar NEW_LINE DEDENT DEDENT a = 5 NEW_LINE b = 7 NEW_LINE print ( \" LCM \u2581 of \u2581 \" , a , \" \u2581 and \u2581 \" , b , \" \u2581 is \u2581 \" , findLCM ( a , b ) , sep = \" \" ) NEW_LINE"}
{"id": "codeforces_629_A", "sol": 0, "python_code": "n = int ( input ( ) )\npares = 0\nbolo = [ ]\nfor i in range ( n ) :\n    camada = input ( )\n    bolo.append ( camada )\nfor i in range ( n ) :\n    contador = 0\n    for j in range ( n ) :\n        if bolo [ i ] [ j ] == 'C' :\n            contador += 1\n    pares += ( ( contador * ( contador - 1 ) ) // 2 )\nfor j in range ( n ) :\n    contador = 0\n    for i in range ( n ) :\n        if bolo [ i ] [ j ] == 'C' :\n            contador += 1\n    pares += ( ( contador * ( contador - 1 ) ) // 2 )\nprint ( pares )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE pares = 0 NEW_LINE bolo = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT camada = input ( ) NEW_LINE bolo . append ( camada ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT contador = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if bolo [ i ] [ j ] == ' C ' : NEW_LINE INDENT contador += 1 NEW_LINE DEDENT DEDENT pares += ( ( contador * ( contador - 1 ) ) // 2 ) NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT contador = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if bolo [ i ] [ j ] == ' C ' : NEW_LINE INDENT contador += 1 NEW_LINE DEDENT DEDENT pares += ( ( contador * ( contador - 1 ) ) // 2 ) NEW_LINE DEDENT print ( pares ) NEW_LINE"}
{"id": "geeksforgeeks_2118_A", "sol": 0, "python_code": "def LongestSubarray ( arr , n , k ) :\n    count = 1\n    max_lenght = 1\n    prev_mod = arr [ 0 ] % k\n    for i in range ( 1 , n ) :\n        curr_mod = arr [ i ] % k\n        if curr_mod == prev_mod :\n            count += 1\n        else :\n            max_lenght = max ( max_lenght , count )\n            count = 1\n            prev_mod = curr_mod\n    return max_lenght\narr = [ 4 , 9 , 7 , 18 , 29 , 11 ]\nn = len ( arr )\nk = 11\nprint ( LongestSubarray ( arr , n , k ) )\n", "python_code_tokenized": "def LongestSubarray ( arr , n , k ) : NEW_LINE INDENT count = 1 NEW_LINE max_lenght = 1 NEW_LINE prev_mod = arr [ 0 ] % k NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_mod = arr [ i ] % k NEW_LINE if curr_mod == prev_mod : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_lenght = max ( max_lenght , count ) NEW_LINE count = 1 NEW_LINE prev_mod = curr_mod NEW_LINE DEDENT DEDENT return max_lenght NEW_LINE DEDENT arr = [ 4 , 9 , 7 , 18 , 29 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 11 NEW_LINE print ( LongestSubarray ( arr , n , k ) ) NEW_LINE"}
{"id": "geeksforgeeks_3048_A", "sol": 0, "python_code": "def firstDigit ( n ) :\n    while n >= 10 :\n        n = n / 10 ;\n    return int ( n )\ndef lastDigit ( n ) :\n    return ( n % 10 )\nn = 98562 ;\nprint ( firstDigit ( n ) , end = \" \" )\nprint ( lastDigit ( n ) )\n", "python_code_tokenized": "def firstDigit ( n ) : NEW_LINE INDENT while n >= 10 : NEW_LINE INDENT n = n / 10 ; NEW_LINE DEDENT return int ( n ) NEW_LINE DEDENT def lastDigit ( n ) : NEW_LINE INDENT return ( n % 10 ) NEW_LINE DEDENT n = 98562 ; NEW_LINE print ( firstDigit ( n ) , end = \" \u2581 \" ) NEW_LINE print ( lastDigit ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_476_A", "sol": 0, "python_code": "def minOperations ( x , y , p , q ) :\n    if ( y % x != 0 ) :\n        return - 1\n    d = y // x\n    a = 0\n    while ( d % p == 0 ) :\n        d //= p\n        a += 1\n    b = 0\n    while ( d % q == 0 ) :\n        d //= q\n        b += 1\n    if ( d != 1 ) :\n        return - 1\n    return ( a + b )\nx = 12\ny = 2592\np = 2\nq = 3\nprint ( minOperations ( x , y , p , q ) )\n", "python_code_tokenized": "def minOperations ( x , y , p , q ) : NEW_LINE INDENT if ( y % x != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = y // x NEW_LINE a = 0 NEW_LINE while ( d % p == 0 ) : NEW_LINE INDENT d //= p NEW_LINE a += 1 NEW_LINE DEDENT b = 0 NEW_LINE while ( d % q == 0 ) : NEW_LINE INDENT d //= q NEW_LINE b += 1 NEW_LINE DEDENT if ( d != 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( a + b ) NEW_LINE DEDENT x = 12 NEW_LINE y = 2592 NEW_LINE p = 2 NEW_LINE q = 3 NEW_LINE print ( minOperations ( x , y , p , q ) ) NEW_LINE"}
{"id": "codeforces_253_B", "sol": 0, "python_code": "def solve ( ) :\n    f = open ( 'input.txt' , 'r' )\n    n = int ( f.readline ( ) )\n    arr = list ( map ( int , f.readline ( ).split ( ) ) ) ; arr.sort ( )\n    l = 0 ; r = 0\n    while l < n :\n        if arr [ l ] > arr [ r ] * 2 : r += 1\n        l += 1\n    return r\nprint ( solve ( ) , file = open ( 'output.txt' , 'w' ) )\n", "python_code_tokenized": "def solve ( ) : NEW_LINE INDENT f = open ( ' input . txt ' , ' r ' ) NEW_LINE n = int ( f . readline ( ) ) NEW_LINE arr = list ( map ( int , f . readline ( ) . split ( ) ) ) ; arr . sort ( ) NEW_LINE l = 0 ; r = 0 NEW_LINE while l < n : NEW_LINE INDENT if arr [ l ] > arr [ r ] * 2 : r += 1 NEW_LINE l += 1 NEW_LINE DEDENT return r NEW_LINE DEDENT print ( solve ( ) , file = open ( ' output . txt ' , ' w ' ) ) NEW_LINE"}
{"id": "geeksforgeeks_3704_A", "sol": 0, "python_code": "def noOfTriples ( arr , n ) :\n    arr.sort ( )\n    count = 0\n    for i in range ( n ) :\n        if arr [ i ] == arr [ 2 ] :\n            count += 1\n    if arr [ 0 ] == arr [ 2 ] :\n        return ( count - 2 ) * ( count - 1 ) * ( count ) / 6\n    elif arr [ 1 ] == arr [ 2 ] :\n        return ( count - 1 ) * ( count ) / 2\n    return count\narr = [ 1 , 3 , 3 , 4 ]\nn = len ( arr )\nprint ( noOfTriples ( arr , n ) )\n", "python_code_tokenized": "def noOfTriples ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == arr [ 2 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if arr [ 0 ] == arr [ 2 ] : NEW_LINE INDENT return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 NEW_LINE DEDENT elif arr [ 1 ] == arr [ 2 ] : NEW_LINE INDENT return ( count - 1 ) * ( count ) / 2 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 1 , 3 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( noOfTriples ( arr , n ) ) NEW_LINE"}
{"id": "aizu_p00496_A", "sol": 0, "python_code": "n , t , s = map ( int , raw_input ( ).split ( ) )\nab = [ map ( int , raw_input ( ).split ( ) ) for _ in xrange ( n ) ]\ndp = [ [ 0 ] * ( t + 1 ) for _ in xrange ( n + 1 ) ]\nfor i in xrange ( n ) :\n    for j in xrange ( 1 , t + 1 ) :\n        if j < ab [ i ] [ 1 ] or j - ab [ i ] [ 1 ] < s < j :\n            dp [ i + 1 ] [ j ] = dp [ i ] [ j ]\n            continue\n        dp [ i + 1 ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j - ab [ i ] [ 1 ] ] + ab [ i ] [ 0 ] )\nprint ( max ( dp [ n ] ) )\n", "python_code_tokenized": "n , t , s = map ( int , raw_input ( ) . split ( ) ) NEW_LINE ab = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( n ) ] NEW_LINE dp = [ [ 0 ] * ( t + 1 ) for _ in xrange ( n + 1 ) ] NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT for j in xrange ( 1 , t + 1 ) : NEW_LINE INDENT if j < ab [ i ] [ 1 ] or j - ab [ i ] [ 1 ] < s < j : NEW_LINE INDENT dp [ i + 1 ] [ j ] = dp [ i ] [ j ] NEW_LINE continue NEW_LINE DEDENT dp [ i + 1 ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j - ab [ i ] [ 1 ] ] + ab [ i ] [ 0 ] ) NEW_LINE DEDENT DEDENT print ( max ( dp [ n ] ) ) NEW_LINE"}
{"id": "atcoder_ABC077_A", "sol": 0, "python_code": "c = [ ]\nfor i in range ( 2 ) :\n    c.append ( input ( ) )\nif c [ 0 ] [ 0 ] == c [ 1 ] [ 2 ] and c [ 0 ] [ 1 ] == c [ 1 ] [ 1 ] and c [ 0 ] [ 2 ] == c [ 1 ] [ 0 ] :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "c = [ ] NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT c . append ( input ( ) ) NEW_LINE DEDENT if c [ 0 ] [ 0 ] == c [ 1 ] [ 2 ] and c [ 0 ] [ 1 ] == c [ 1 ] [ 1 ] and c [ 0 ] [ 2 ] == c [ 1 ] [ 0 ] : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "codeforces_1303_B", "sol": 0, "python_code": "from collections import deque , defaultdict , Counter\nfrom heapq import heappush , heappop , heapify\nfrom math import inf , sqrt , ceil\nfrom functools import lru_cache\nfrom itertools import accumulate , combinations , permutations , product\nfrom typing import List\nfrom bisect import bisect_left , bisect_right\nimport sys\ninput = lambda : sys.stdin.readline ( ).strip ( '\\n' )\nmis = lambda : map ( int , input ( ).split ( ) )\nii = lambda : int ( input ( ) )\nT = ii ( )\nfor _ in range ( T ) :\n    N , G , B = mis ( )\n    m = ( N + 1 ) // 2\n    ans = ( m - 1 ) // G * ( G + B ) + ( m % G if m % G else G )\n    print ( max ( N , ans ) )\n", "python_code_tokenized": "from collections import deque , defaultdict , Counter NEW_LINE from heapq import heappush , heappop , heapify NEW_LINE from math import inf , sqrt , ceil NEW_LINE from functools import lru_cache NEW_LINE from itertools import accumulate , combinations , permutations , product NEW_LINE from typing import List NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE import sys NEW_LINE input = lambda : sys . stdin . readline ( ) . strip ( ' \\n ' ) NEW_LINE mis = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE ii = lambda : int ( input ( ) ) NEW_LINE T = ii ( ) NEW_LINE for _ in range ( T ) : NEW_LINE INDENT N , G , B = mis ( ) NEW_LINE m = ( N + 1 ) // 2 NEW_LINE ans = ( m - 1 ) // G * ( G + B ) + ( m % G if m % G else G ) NEW_LINE print ( max ( N , ans ) ) NEW_LINE DEDENT"}
{"id": "codeforces_221_B", "sol": 0, "python_code": "def chck ( x ) :\n    while ( x > 0 ) :\n        rem = x % 10\n        x //= 10\n        if ( num [ rem ] == 1 ) :\n            return True\n    return False\nx = int ( input ( ) )\nnum = [ 0 ] * 10\nx1 = x\nwhile ( x > 0 ) :\n    rem = x % 10\n    num [ rem ] = 1\n    x //= 10\nx = x1\nans = 0\nfor i in range ( 1 , int ( x ** 0.5 ) + 1 ) :\n    if ( x % i == 0 ) :\n        if ( chck ( i ) ) :\n            ans += 1\n        if ( i * i != x ) :\n            if ( chck ( x // i ) ) :\n                ans += 1\nprint ( ans )\n", "python_code_tokenized": "def chck ( x ) : NEW_LINE INDENT while ( x > 0 ) : NEW_LINE INDENT rem = x % 10 NEW_LINE x //= 10 NEW_LINE if ( num [ rem ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT x = int ( input ( ) ) NEW_LINE num = [ 0 ] * 10 NEW_LINE x1 = x NEW_LINE while ( x > 0 ) : NEW_LINE INDENT rem = x % 10 NEW_LINE num [ rem ] = 1 NEW_LINE x //= 10 NEW_LINE DEDENT x = x1 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , int ( x ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT if ( chck ( i ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( i * i != x ) : NEW_LINE INDENT if ( chck ( x // i ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_3671_A", "sol": 0, "python_code": "def CountSegments ( N , a ) :\n    frequency = [ 0 ] * 10001\n    c = 0\n    for i in range ( N ) :\n        frequency [ a [ i ] ] += 1\n    for i in range ( 10001 ) :\n        c = max ( c , frequency [ i ] )\n    print ( c )\nif __name__ == \"__main__\" :\n    N = 6\n    a = [ 1 , 3 , 4 , 3 , 2 , 3 ]\n    CountSegments ( N , a )\n", "python_code_tokenized": "def CountSegments ( N , a ) : NEW_LINE INDENT frequency = [ 0 ] * 10001 NEW_LINE c = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT frequency [ a [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 10001 ) : NEW_LINE INDENT c = max ( c , frequency [ i ] ) NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 NEW_LINE a = [ 1 , 3 , 4 , 3 , 2 , 3 ] NEW_LINE CountSegments ( N , a ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC057_D", "sol": 0, "python_code": "N , A , B = list ( map ( int , input ( ).split ( \" \" ) ) )\nV = list ( map ( int , input ( ).split ( \" \" ) ) )\nV.sort ( reverse = True )\nmax_avr = sum ( V [ : A ] ) / A\na_num = V.count ( V [ A - 1 ] )\na_pos = V [ : A ].count ( V [ A - 1 ] )\nimport math\ndef nCr ( n , r ) :\n    f = math.factorial\n    return f ( n ) // f ( r ) // f ( n - r )\nif V [ 0 ] == V [ A - 1 ] :\n    cnt = sum ( nCr ( a_num , i ) for i in range ( A , min ( B , a_num ) + 1 ) )\nelse :\n    cnt = nCr ( a_num , a_pos )\nprint ( \"{0:.10f}\".format ( max_avr ) )\nprint ( int ( cnt ) )\n", "python_code_tokenized": "N , A , B = list ( map ( int , input ( ) . split ( \" \u2581 \" ) ) ) NEW_LINE V = list ( map ( int , input ( ) . split ( \" \u2581 \" ) ) ) NEW_LINE V . sort ( reverse = True ) NEW_LINE max_avr = sum ( V [ : A ] ) / A NEW_LINE a_num = V . count ( V [ A - 1 ] ) NEW_LINE a_pos = V [ : A ] . count ( V [ A - 1 ] ) NEW_LINE import math NEW_LINE def nCr ( n , r ) : NEW_LINE INDENT f = math . factorial NEW_LINE return f ( n ) // f ( r ) // f ( n - r ) NEW_LINE DEDENT if V [ 0 ] == V [ A - 1 ] : NEW_LINE INDENT cnt = sum ( nCr ( a_num , i ) for i in range ( A , min ( B , a_num ) + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = nCr ( a_num , a_pos ) NEW_LINE DEDENT print ( \" { 0 : . 10f } \" . format ( max_avr ) ) NEW_LINE print ( int ( cnt ) ) NEW_LINE"}
{"id": "geeksforgeeks_1226_A", "sol": 0, "python_code": "def areaCube ( a ) :\n    return ( a * a * a )\ndef surfaceCube ( a ) :\n    return ( 6 * a * a )\na = 5\nprint ( \"Area =\" , areaCube ( a ) )\nprint ( \"Total surface area =\" , surfaceCube ( a ) )\n", "python_code_tokenized": "def areaCube ( a ) : NEW_LINE INDENT return ( a * a * a ) NEW_LINE DEDENT def surfaceCube ( a ) : NEW_LINE INDENT return ( 6 * a * a ) NEW_LINE DEDENT a = 5 NEW_LINE print ( \" Area \u2581 = \" , areaCube ( a ) ) NEW_LINE print ( \" Total \u2581 surface \u2581 area \u2581 = \" , surfaceCube ( a ) ) NEW_LINE"}
{"id": "geeksforgeeks_1662_A", "sol": 0, "python_code": "def digitWell ( n , m , k ) :\n    cnt = 0\n    while ( n > 0 ) :\n        if ( n % 10 == m ) :\n            cnt = cnt + 1 ;\n        n = ( int ) ( n / 10 ) ;\n    return cnt == k ;\ndef findInt ( n , m , k ) :\n    i = n + 1 ;\n    while ( True ) :\n        if ( digitWell ( i , m , k ) ) :\n            return i ;\n        i = i + 1 ;\nn = 111 ; m = 2 ; k = 2 ;\nprint ( findInt ( n , m , k ) ) ;\n", "python_code_tokenized": "def digitWell ( n , m , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == m ) : NEW_LINE INDENT cnt = cnt + 1 ; NEW_LINE DEDENT n = ( int ) ( n / 10 ) ; NEW_LINE DEDENT return cnt == k ; NEW_LINE DEDENT def findInt ( n , m , k ) : NEW_LINE INDENT i = n + 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( digitWell ( i , m , k ) ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i = i + 1 ; NEW_LINE DEDENT DEDENT n = 111 ; m = 2 ; k = 2 ; NEW_LINE print ( findInt ( n , m , k ) ) ; NEW_LINE"}
{"id": "codeforces_1338_B", "sol": 0, "python_code": "import io , os\ninput = io.BytesIO ( os.read ( 0 , os.fstat ( 0 ).st_size ) ).readline\nfrom collections import deque\nn = int ( input ( ) )\nneigh = [ [ ] for i in range ( n ) ]\nfor i in range ( n - 1 ) :\n    u , v = map ( int , input ( ).split ( ) )\n    neigh [ v - 1 ].append ( u - 1 )\n    neigh [ u - 1 ].append ( v - 1 )\nfor i in range ( n ) :\n    if len ( neigh [ i ] ) == 1 :\n        root = i\n        break\nqueue = deque ( )\nvisited = [ False ] * n\nvisited [ root ] = True\nqueue.append ( [ root , 0 ] )\nleafneigh = { }\nmaximum = n - 1\nodd = 0\neven = 0\nwhile queue :\n    [ index , d ] = queue.popleft ( )\n    if len ( neigh [ index ] ) == 1 :\n        if neigh [ index ] [ 0 ] not in leafneigh :\n            leafneigh [ neigh [ index ] [ 0 ] ] = d\n            if d % 2 == 0 : odd += 1\n            else : even += 1\n        else : maximum -= 1\n    for ele in neigh [ index ] :\n        if visited [ ele ] : continue\n        visited [ ele ] = True\n        queue.append ( [ ele , d + 1 ] )\nif min ( odd , even ) == 0 : minimum = 1\nelse : minimum = 3\nprint ( minimum , maximum )\n", "python_code_tokenized": "import io , os NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE from collections import deque NEW_LINE n = int ( input ( ) ) NEW_LINE neigh = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT u , v = map ( int , input ( ) . split ( ) ) NEW_LINE neigh [ v - 1 ] . append ( u - 1 ) NEW_LINE neigh [ u - 1 ] . append ( v - 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if len ( neigh [ i ] ) == 1 : NEW_LINE INDENT root = i NEW_LINE break NEW_LINE DEDENT DEDENT queue = deque ( ) NEW_LINE visited = [ False ] * n NEW_LINE visited [ root ] = True NEW_LINE queue . append ( [ root , 0 ] ) NEW_LINE leafneigh = { } NEW_LINE maximum = n - 1 NEW_LINE odd = 0 NEW_LINE even = 0 NEW_LINE while queue : NEW_LINE INDENT [ index , d ] = queue . popleft ( ) NEW_LINE if len ( neigh [ index ] ) == 1 : NEW_LINE INDENT if neigh [ index ] [ 0 ] not in leafneigh : NEW_LINE INDENT leafneigh [ neigh [ index ] [ 0 ] ] = d NEW_LINE if d % 2 == 0 : odd += 1 NEW_LINE else : even += 1 NEW_LINE DEDENT else : maximum -= 1 NEW_LINE DEDENT for ele in neigh [ index ] : NEW_LINE INDENT if visited [ ele ] : continue NEW_LINE visited [ ele ] = True NEW_LINE queue . append ( [ ele , d + 1 ] ) NEW_LINE DEDENT DEDENT if min ( odd , even ) == 0 : minimum = 1 NEW_LINE else : minimum = 3 NEW_LINE print ( minimum , maximum ) NEW_LINE"}
{"id": "geeksforgeeks_4048_A", "sol": 0, "python_code": "def getCount ( A , B2 , C ) :\n    count = 0\n    i = 1\n    while ( i < A ) :\n        j = ( B2 // i ) + 1\n        if ( C >= j ) :\n            count = count + C - j + 1\n        if ( A >= j and C >= i ) :\n            count = count + ( C - i + 1 ) * ( A - j + 1 )\n        if ( A >= j ) :\n            A = j - 1\n        i += 1\n    return count\ndef countTriplets ( A , B , C ) :\n    ans = 0\n    for i in range ( 1 , B + 1 ) :\n        ans = ( ans + getCount ( A , i * i , C ) )\n    return ans\nA = 3\nB = 2\nC = 2\nprint ( countTriplets ( A , B , C ) )\n", "python_code_tokenized": "def getCount ( A , B2 , C ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while ( i < A ) : NEW_LINE INDENT j = ( B2 // i ) + 1 NEW_LINE if ( C >= j ) : NEW_LINE INDENT count = count + C - j + 1 NEW_LINE DEDENT if ( A >= j and C >= i ) : NEW_LINE INDENT count = count + ( C - i + 1 ) * ( A - j + 1 ) NEW_LINE DEDENT if ( A >= j ) : NEW_LINE INDENT A = j - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countTriplets ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , B + 1 ) : NEW_LINE INDENT ans = ( ans + getCount ( A , i * i , C ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT A = 3 NEW_LINE B = 2 NEW_LINE C = 2 NEW_LINE print ( countTriplets ( A , B , C ) ) NEW_LINE"}
{"id": "geeksforgeeks_4696_A", "sol": 0, "python_code": "import sys ;\ndef rotateRec ( n , L , B ) :\n    m = sys.maxsize ;\n    for i in range ( n ) :\n        if ( max ( L [ i ] , B [ i ] ) <= m ) :\n            m = max ( L [ i ] , B [ i ] ) ;\n        elif ( min ( L [ i ] , B [ i ] ) <= m ) :\n            m = min ( L [ i ] , B [ i ] ) ;\n        else :\n            return 0 ;\n    return 1 ;\nn = 3 ;\nL = [ 5 , 5 , 6 ] ;\nB = [ 6 , 7 , 8 ] ;\nif ( rotateRec ( n , L , B ) == 1 ) :\n    print ( \"YES\" ) ;\nelse :\n    print ( \"NO\" ) ;\n", "python_code_tokenized": "import sys ; NEW_LINE def rotateRec ( n , L , B ) : NEW_LINE INDENT m = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max ( L [ i ] , B [ i ] ) <= m ) : NEW_LINE INDENT m = max ( L [ i ] , B [ i ] ) ; NEW_LINE DEDENT elif ( min ( L [ i ] , B [ i ] ) <= m ) : NEW_LINE INDENT m = min ( L [ i ] , B [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT n = 3 ; NEW_LINE L = [ 5 , 5 , 6 ] ; NEW_LINE B = [ 6 , 7 , 8 ] ; NEW_LINE if ( rotateRec ( n , L , B ) == 1 ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"}
{"id": "aizu_p00993_A", "sol": 0, "python_code": "import sys\nn = int ( input ( ) )\nif n == 1 : print ( 4 , 2 , sep = '\\n' ) ; sys.exit ( 0 )\nans = 1\nfor i in range ( 2 , n + 2 ) : ans *= i\nprint ( ans + 2 )\nfor i in range ( 2 , n + 2 ) : print ( i )\n", "python_code_tokenized": "import sys NEW_LINE n = int ( input ( ) ) NEW_LINE if n == 1 : print ( 4 , 2 , sep = ' \\n ' ) ; sys . exit ( 0 ) NEW_LINE ans = 1 NEW_LINE for i in range ( 2 , n + 2 ) : ans *= i NEW_LINE print ( ans + 2 ) NEW_LINE for i in range ( 2 , n + 2 ) : print ( i ) NEW_LINE"}
{"id": "atcoder_ARC087_A", "sol": 0, "python_code": "n = int ( input ( ) )\na = map ( int , input ( ).split ( ) )\nans = 0\ncnt = [ 0 ] * n + [ 0 ]\nfor i in a :\n    if i > n :\n        ans += 1\n    else :\n        cnt [ i ] += 1\nfor i in range ( n + 1 ) :\n    ans += cnt [ i ] - i if cnt [ i ] >= i else cnt [ i ]\nprint ( ans )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE cnt = [ 0 ] * n + [ 0 ] NEW_LINE for i in a : NEW_LINE INDENT if i > n : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT ans += cnt [ i ] - i if cnt [ i ] >= i else cnt [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_1806_A", "sol": 0, "python_code": "def isBinary ( number ) :\n    while ( number > 0 ) :\n        digit = number % 10\n        if ( digit > 1 ) :\n            return False\n        number //= 10\n    return True\nif __name__ == \"__main__\" :\n    n = 1000111\n    if ( isBinary ( n ) == 1 ) :\n        print ( \"true\" )\n    else :\n        print ( \"false\" )\n", "python_code_tokenized": "def isBinary ( number ) : NEW_LINE INDENT while ( number > 0 ) : NEW_LINE INDENT digit = number % 10 NEW_LINE if ( digit > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT number //= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1000111 NEW_LINE if ( isBinary ( n ) == 1 ) : NEW_LINE INDENT print ( \" true \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" false \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1622_A", "sol": 0, "python_code": "for i in range ( int ( input ( ) ) ) :\n    a , b , c = sorted ( map ( int , input ( ).split ( ) ) )\n    s = [ a , b , c , a , b ]\n    print ( [ 'NO' , 'YES' ] [ c == a + b or any ( s [ i ] == s [ i + 1 ] and s [ i + 2 ] % 2 == 0 for i in range ( 3 ) ) ] )\n", "python_code_tokenized": "for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = [ a , b , c , a , b ] NEW_LINE print ( [ ' NO ' , ' YES ' ] [ c == a + b or any ( s [ i ] == s [ i + 1 ] and s [ i + 2 ] % 2 == 0 for i in range ( 3 ) ) ] ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC097_C", "sol": 0, "python_code": "s = input ( )\nK = int ( input ( ) )\nl = len ( s )\nsubstr = [ ]\nfor i in range ( l ) :\n    for k in range ( K ) :\n        substr.append ( s [ i : i + k + 1 ] )\n        if i + k + 1 >= l : break\nsubstr = list ( set ( substr ) )\nsubstr.sort ( )\nprint ( substr [ K - 1 ] )\n", "python_code_tokenized": "s = input ( ) NEW_LINE K = int ( input ( ) ) NEW_LINE l = len ( s ) NEW_LINE substr = [ ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT for k in range ( K ) : NEW_LINE INDENT substr . append ( s [ i : i + k + 1 ] ) NEW_LINE if i + k + 1 >= l : break NEW_LINE DEDENT DEDENT substr = list ( set ( substr ) ) NEW_LINE substr . sort ( ) NEW_LINE print ( substr [ K - 1 ] ) NEW_LINE"}
{"id": "geeksforgeeks_3805_A", "sol": 0, "python_code": "M = 100\ndef minAdjustmentCost ( A , n , target ) :\n    dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ]\n    for j in range ( M + 1 ) :\n        dp [ 0 ] [ j ] = abs ( j - A [ 0 ] )\n    for i in range ( 1 , n ) :\n        for j in range ( M + 1 ) :\n            dp [ i ] [ j ] = 100000000\n            for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) :\n                dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) )\n    res = 10000000\n    for j in range ( M + 1 ) :\n        res = min ( res , dp [ n - 1 ] [ j ] )\n    return res\narr = [ 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 ]\nn = len ( arr )\ntarget = 10\nprint ( \"Minimum adjustment cost is\" , minAdjustmentCost ( arr , n , target ) , sep = ' ' )\n", "python_code_tokenized": "M = 100 NEW_LINE def minAdjustmentCost ( A , n , target ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 100000000 NEW_LINE for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) NEW_LINE DEDENT DEDENT DEDENT res = 10000000 NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT res = min ( res , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 ] NEW_LINE n = len ( arr ) NEW_LINE target = 10 NEW_LINE print ( \" Minimum \u2581 adjustment \u2581 cost \u2581 is \" , minAdjustmentCost ( arr , n , target ) , sep = ' \u2581 ' ) NEW_LINE"}
{"id": "aizu_p01939_A", "sol": 0, "python_code": "MOD = 10 ** 9 + 7\ndef sum ( a , d , n ) :\n    return n * ( 2 * a + ( n - 1 ) * d ) // 2\ndef main ( ) :\n    n , m = map ( int , input ( ).split ( ) )\n    s = 0\n    if n == 1 :\n        s = m + 1\n    else :\n        s = sum ( m + 1 , - n + 1 , 1 + m // ( n - 1 ) )\n        s *= 2\n        s -= ( m + 1 )\n    print ( s % MOD )\nif __name__ == '__main__' :\n    main ( )\n", "python_code_tokenized": "MOD = 10 ** 9 + 7 NEW_LINE def sum ( a , d , n ) : NEW_LINE INDENT return n * ( 2 * a + ( n - 1 ) * d ) // 2 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = 0 NEW_LINE if n == 1 : NEW_LINE INDENT s = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT s = sum ( m + 1 , - n + 1 , 1 + m // ( n - 1 ) ) NEW_LINE s *= 2 NEW_LINE s -= ( m + 1 ) NEW_LINE DEDENT print ( s % MOD ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"id": "codeforces_1016_B", "sol": 0, "python_code": "n , m , q = ( map ( int , input ( \"\" ).split ( ) ) )\ns = input ( )\nt = input ( )\npositions = ''\nfor i in range ( n - m + 1 ) :\n    if s [ i : i + m ] == t :\n        positions += \"1\"\n    else :\n        positions += \"0\"\nfor i in range ( q ) :\n    l , r = map ( int , input ( \"\" ).split ( ) )\n    if r - l + 1 >= m :\n        print ( positions [ l - 1 : r - m + 1 ].count ( \"1\" ) )\n    else :\n        print ( 0 )\n", "python_code_tokenized": "n , m , q = ( map ( int , input ( \" \" ) . split ( ) ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE positions = ' ' NEW_LINE for i in range ( n - m + 1 ) : NEW_LINE INDENT if s [ i : i + m ] == t : NEW_LINE INDENT positions += \"1\" NEW_LINE DEDENT else : NEW_LINE INDENT positions += \"0\" NEW_LINE DEDENT DEDENT for i in range ( q ) : NEW_LINE INDENT l , r = map ( int , input ( \" \" ) . split ( ) ) NEW_LINE if r - l + 1 >= m : NEW_LINE INDENT print ( positions [ l - 1 : r - m + 1 ] . count ( \"1\" ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_5267_A", "sol": 0, "python_code": "def findMostOccurringChar ( string ) :\n    hash = [ 0 ] * 26 ;\n    for i in range ( len ( string ) ) :\n        for j in range ( len ( string [ i ] ) ) :\n            hash [ ord ( string [ i ] [ j ] ) - ord ( 'a' ) ] += 1 ;\n    max = 0 ;\n    for i in range ( 26 ) :\n        max = i if hash [ i ] > hash [ max ] else max ;\n    print ( ( chr ) ( max + 97 ) ) ;\nif __name__ == \"__main__\" :\n    string = [ ] ;\n    string.append ( \"animal\" ) ;\n    string.append ( \"zebra\" ) ;\n    string.append ( \"lion\" ) ;\n    string.append ( \"giraffe\" ) ;\n    findMostOccurringChar ( string ) ;\n", "python_code_tokenized": "def findMostOccurringChar ( string ) : NEW_LINE INDENT hash = [ 0 ] * 26 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT for j in range ( len ( string [ i ] ) ) : NEW_LINE INDENT hash [ ord ( string [ i ] [ j ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT DEDENT max = 0 ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT max = i if hash [ i ] > hash [ max ] else max ; NEW_LINE DEDENT print ( ( chr ) ( max + 97 ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = [ ] ; NEW_LINE string . append ( \" animal \" ) ; NEW_LINE string . append ( \" zebra \" ) ; NEW_LINE string . append ( \" lion \" ) ; NEW_LINE string . append ( \" giraffe \" ) ; NEW_LINE findMostOccurringChar ( string ) ; NEW_LINE DEDENT"}
{"id": "codeforces_1013_A", "sol": 0, "python_code": "n = int ( input ( ) )\nX = [ int ( x ) for x in input ( ).split ( ) ]\nY = [ int ( x ) for x in input ( ).split ( ) ]\nprint ( 'Yes' if sum ( Y ) <= sum ( X ) else 'No' )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE X = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE Y = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( ' Yes ' if sum ( Y ) <= sum ( X ) else ' No ' ) NEW_LINE"}
{"id": "geeksforgeeks_2268_A", "sol": 0, "python_code": "def nCr ( n , k ) :\n    C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ]\n    for i in range ( n + 1 ) :\n        for j in range ( min ( i , k ) + 1 ) :\n            if ( j == 0 or j == i ) :\n                C [ i ] [ j ] = 1\n            else :\n                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]\n    return C [ n ] [ k ]\ndef resultOfAllSubsets ( arr , N ) :\n    result = 0.0\n    sum = 0\n    for i in range ( N ) :\n        sum += arr [ i ]\n    for n in range ( 1 , N + 1 ) :\n        result += ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n\n    return result\narr = [ 2 , 3 , 5 , 7 ]\nN = len ( arr )\nprint ( resultOfAllSubsets ( arr , N ) )\n", "python_code_tokenized": "def nCr ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def resultOfAllSubsets ( arr , N ) : NEW_LINE INDENT result = 0.0 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for n in range ( 1 , N + 1 ) : NEW_LINE INDENT result += ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 7 ] NEW_LINE N = len ( arr ) NEW_LINE print ( resultOfAllSubsets ( arr , N ) ) NEW_LINE"}
{"id": "geeksforgeeks_3483_A", "sol": 0, "python_code": "N = 4\ndef MaximumDecimalValue ( mat , n ) :\n    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]\n    if ( mat [ 0 ] [ 0 ] == 1 ) :\n        dp [ 0 ] [ 0 ] = 1\n    for i in range ( 1 , n ) :\n        if ( mat [ 0 ] [ i ] == 1 ) :\n            dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 ** i\n        else :\n            dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ]\n    for i in range ( 1 , n ) :\n        if ( mat [ i ] [ 0 ] == 1 ) :\n            dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i\n    else :\n        dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ]\n    for i in range ( 1 , n ) :\n        for j in range ( 1 , n ) :\n            if ( mat [ i ] [ j ] == 1 ) :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 ** ( i + j ) )\n            else :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )\n    return dp [ n - 1 ] [ n - 1 ]\nif __name__ == '__main__' :\n    mat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 ] ]\n    print ( MaximumDecimalValue ( mat , 4 ) )\n", "python_code_tokenized": "N = 4 NEW_LINE def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 ** i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 ** ( i + j ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 ] ] NEW_LINE print ( MaximumDecimalValue ( mat , 4 ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1197_B", "sol": 0, "python_code": "n = int ( input ( ) )\narr = list ( map ( int , input ( ).split ( ) ) )\na = sorted ( arr )\nb = sorted ( arr , reverse = True )\nk = len ( arr )\nif arr == a or arr == b :\n    print ( \"YES\" )\nelse :\n    i = 0\n    while i < k - 1 and arr [ i + 1 ] >= arr [ i ] :\n        i += 1\n    while i < k - 1 and arr [ i + 1 ] <= arr [ i ] :\n        i += 1\n    if i == k - 1 :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = sorted ( arr ) NEW_LINE b = sorted ( arr , reverse = True ) NEW_LINE k = len ( arr ) NEW_LINE if arr == a or arr == b : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT i = 0 NEW_LINE while i < k - 1 and arr [ i + 1 ] >= arr [ i ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while i < k - 1 and arr [ i + 1 ] <= arr [ i ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == k - 1 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1287_B", "sol": 0, "python_code": "def predictFeature ( a , b ) :\n    if a == b :\n        return a\n    else :\n        if 'S' in ( a , b ) :\n            pass\n        else :\n            return 'S'\n        if 'T' in ( a , b ) :\n            pass\n        else :\n            return 'T'\n        return 'E'\ndef hyperSet ( n , k , l ) :\n    d = { }\n    for x in l :\n        if x not in d :\n            d [ x ] = 1\n        else :\n            d [ x ] += 1\n    ans = 0\n    for i in range ( n ) :\n        for j in range ( n ) :\n            if i != j :\n                w = ''\n                for x in range ( k ) :\n                    w += predictFeature ( l [ i ] [ x ] , l [ j ] [ x ] )\n                if w in d :\n                    c = 0\n                    if w == l [ i ] :\n                        c += 1\n                    if w == l [ j ] :\n                        c += 1\n                    ans += d [ w ] - c\n    return ans // 6\nn , k = map ( int , input ( ).split ( ) )\nl = [ ]\nfor _ in range ( n ) :\n    l.append ( input ( ) )\nprint ( hyperSet ( n , k , l ) )\n", "python_code_tokenized": "def predictFeature ( a , b ) : NEW_LINE INDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT if ' S ' in ( a , b ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT return ' S ' NEW_LINE DEDENT if ' T ' in ( a , b ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT return ' T ' NEW_LINE DEDENT return ' E ' NEW_LINE DEDENT DEDENT def hyperSet ( n , k , l ) : NEW_LINE INDENT d = { } NEW_LINE for x in l : NEW_LINE INDENT if x not in d : NEW_LINE INDENT d [ x ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ x ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT w = ' ' NEW_LINE for x in range ( k ) : NEW_LINE INDENT w += predictFeature ( l [ i ] [ x ] , l [ j ] [ x ] ) NEW_LINE DEDENT if w in d : NEW_LINE INDENT c = 0 NEW_LINE if w == l [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if w == l [ j ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT ans += d [ w ] - c NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans // 6 NEW_LINE DEDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT l . append ( input ( ) ) NEW_LINE DEDENT print ( hyperSet ( n , k , l ) ) NEW_LINE"}
{"id": "codeforces_1328_B", "sol": 0, "python_code": "def go ( n , k ) :\n    i = 1\n    i2 = 0\n    while k >= i :\n        i2 += 1\n        i += i2\n    i -= i2\n    k -= i\n    print ( \"a\" * ( n - i2 - 1 ) + \"b\" + \"a\" * ( n - ( n - i2 - 1 ) - k - 2 ) + \"b\" + \"a\" * ( k ) )\nt = int ( input ( ) )\nfor j in range ( t ) :\n    n , k = [ int ( i ) for i in input ( ).split ( ) ]\n    go ( n , k )\n", "python_code_tokenized": "def go ( n , k ) : NEW_LINE INDENT i = 1 NEW_LINE i2 = 0 NEW_LINE while k >= i : NEW_LINE INDENT i2 += 1 NEW_LINE i += i2 NEW_LINE DEDENT i -= i2 NEW_LINE k -= i NEW_LINE print ( \" a \" * ( n - i2 - 1 ) + \" b \" + \" a \" * ( n - ( n - i2 - 1 ) - k - 2 ) + \" b \" + \" a \" * ( k ) ) NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for j in range ( t ) : NEW_LINE INDENT n , k = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE go ( n , k ) NEW_LINE DEDENT"}
{"id": "aizu_p01499_A", "sol": 0, "python_code": "import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools\nsys.setrecursionlimit ( 10 ** 7 )\ninf = 10 ** 20\neps = 1.0 / 10 ** 10\nmod = 10 ** 9 + 7\ndd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ]\nddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ]\ndef LI ( ) : return [ int ( x ) for x in sys.stdin.readline ( ).split ( ) ]\ndef LI_ ( ) : return [ int ( x ) - 1 for x in sys.stdin.readline ( ).split ( ) ]\ndef LF ( ) : return [ float ( x ) for x in sys.stdin.readline ( ).split ( ) ]\ndef LS ( ) : return sys.stdin.readline ( ).split ( )\ndef I ( ) : return int ( sys.stdin.readline ( ) )\ndef F ( ) : return float ( sys.stdin.readline ( ) )\ndef S ( ) : return input ( )\ndef pf ( s ) : return print ( s , flush = True )\ndef main ( ) :\n    n , t = LI ( )\n    a = sorted ( [ I ( ) for _ in range ( n ) ] )\n    r = 1\n    i = 0\n    for j in range ( n ) :\n        while a [ i ] < a [ j ] - t :\n            i += 1\n        r *= j - i + 1\n        r %= mod\n    return r\nprint ( main ( ) )\n", "python_code_tokenized": "import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 / 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] NEW_LINE ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT n , t = LI ( ) NEW_LINE a = sorted ( [ I ( ) for _ in range ( n ) ] ) NEW_LINE r = 1 NEW_LINE i = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT while a [ i ] < a [ j ] - t : NEW_LINE INDENT i += 1 NEW_LINE DEDENT r *= j - i + 1 NEW_LINE r %= mod NEW_LINE DEDENT return r NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"}
{"id": "geeksforgeeks_685_A", "sol": 0, "python_code": "MAXN = 100\ndef maxValue ( n , m , x , y , a ) :\n    c = [ [ 0 for x in range ( MAXN ) ] for y in range ( MAXN ) ]\n    for i in range ( m ) :\n        for p in range ( n ) :\n            for q in range ( n ) :\n                dx = abs ( p - x [ i ] )\n                dy = abs ( q - y [ i ] )\n                d = max ( dx , dy )\n                c [ p ] [ q ] += max ( 0 , a [ i ] - d )\n    res = 0\n    for i in range ( n ) :\n        for j in range ( n ) :\n            res = max ( res , c [ i ] [ j ] )\n    return res\nif __name__ == \"__main__\" :\n    n = 10\n    m = 2\n    x = [ 3 , 7 ]\n    y = [ 3 , 7 ]\n    a = [ 4 , 3 ]\n    print ( maxValue ( n , m , x , y , a ) )\n", "python_code_tokenized": "MAXN = 100 NEW_LINE def maxValue ( n , m , x , y , a ) : NEW_LINE INDENT c = [ [ 0 for x in range ( MAXN ) ] for y in range ( MAXN ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for p in range ( n ) : NEW_LINE INDENT for q in range ( n ) : NEW_LINE INDENT dx = abs ( p - x [ i ] ) NEW_LINE dy = abs ( q - y [ i ] ) NEW_LINE d = max ( dx , dy ) NEW_LINE c [ p ] [ q ] += max ( 0 , a [ i ] - d ) NEW_LINE DEDENT DEDENT DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT res = max ( res , c [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE m = 2 NEW_LINE x = [ 3 , 7 ] NEW_LINE y = [ 3 , 7 ] NEW_LINE a = [ 4 , 3 ] NEW_LINE print ( maxValue ( n , m , x , y , a ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_871_A", "sol": 0, "python_code": "def nthRoot ( A , N ) :\n    xPre = 7\n    eps = 1e-3\n    delX = 10 ** 9\n    xK = 0\n    while ( delX > eps ) :\n        xK = ( ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ) / N\n        delX = abs ( xK - xPre )\n        xPre = xK\n    return xK\ndef check ( no , k ) :\n    kth_root = nthRoot ( no , k )\n    num = int ( kth_root )\n    if ( abs ( num - kth_root ) < 1e-4 ) :\n        return True\n    return False\ndef printExpo ( arr , n , k ) :\n    for i in range ( n ) :\n        if ( check ( arr [ i ] , k ) ) :\n            print ( arr [ i ] , end = \" \" )\nif __name__ == '__main__' :\n    K = 6\n    arr = [ 46656 , 64 , 256 , 729 , 16 , 1000 ]\n    n = len ( arr )\n    printExpo ( arr , n , K )\n", "python_code_tokenized": "def nthRoot ( A , N ) : NEW_LINE INDENT xPre = 7 NEW_LINE eps = 1e-3 NEW_LINE delX = 10 ** 9 NEW_LINE xK = 0 NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ) / N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT def check ( no , k ) : NEW_LINE INDENT kth_root = nthRoot ( no , k ) NEW_LINE num = int ( kth_root ) NEW_LINE if ( abs ( num - kth_root ) < 1e-4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def printExpo ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] , k ) ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K = 6 NEW_LINE arr = [ 46656 , 64 , 256 , 729 , 16 , 1000 ] NEW_LINE n = len ( arr ) NEW_LINE printExpo ( arr , n , K ) NEW_LINE DEDENT"}
{"id": "leetcode_007_A", "sol": 0, "python_code": "class Solution :\n    def reverse ( self , x ) :\n        res , isPos = 0 , 1\n        if x < 0 :\n            isPos = - 1\n            x = - 1 * x\n        while x != 0 :\n            res = res * 10 + x % 10\n            if res > 2147483647 :\n                return 0\n            x /= 10\n        return res * isPos\n", "python_code_tokenized": "class Solution : NEW_LINE INDENT def reverse ( self , x ) : NEW_LINE INDENT res , isPos = 0 , 1 NEW_LINE if x < 0 : NEW_LINE INDENT isPos = - 1 NEW_LINE x = - 1 * x NEW_LINE DEDENT while x != 0 : NEW_LINE INDENT res = res * 10 + x % 10 NEW_LINE if res > 2147483647 : NEW_LINE INDENT return 0 NEW_LINE DEDENT x /= 10 NEW_LINE DEDENT return res * isPos NEW_LINE DEDENT DEDENT"}
{"id": "atcoder_ABC141_E", "sol": 0, "python_code": "N = int ( input ( ) )\nS = input ( )\nres = 0\ndp = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ]\nfor i in reversed ( range ( N ) ) :\n    for j in reversed ( range ( i + 1 , N ) ) :\n        if S [ i ] == S [ j ] :\n            dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i + 1 ] [ j + 1 ] + 1 )\n        res = max ( res , min ( dp [ i ] [ j ] , j - i ) )\nprint ( res )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE S = input ( ) NEW_LINE res = 0 NEW_LINE dp = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] NEW_LINE for i in reversed ( range ( N ) ) : NEW_LINE INDENT for j in reversed ( range ( i + 1 , N ) ) : NEW_LINE INDENT if S [ i ] == S [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i + 1 ] [ j + 1 ] + 1 ) NEW_LINE DEDENT res = max ( res , min ( dp [ i ] [ j ] , j - i ) ) NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE"}
{"id": "codeforces_318_A", "sol": 0, "python_code": "n , j = list ( map ( int , input ( ).split ( ) ) )\nif ( n % 2 == 0 ) :\n    odd = n // 2\nelse :\n    odd = ( n + 1 ) // 2\nif ( j <= odd ) :\n    print ( ( 2 * j ) - 1 )\nelse :\n    print ( ( j - odd ) * 2 )\n", "python_code_tokenized": "n , j = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT odd = n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT odd = ( n + 1 ) // 2 NEW_LINE DEDENT if ( j <= odd ) : NEW_LINE INDENT print ( ( 2 * j ) - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( j - odd ) * 2 ) NEW_LINE DEDENT"}
{"id": "codeforces_29_A", "sol": 0, "python_code": "n = int ( input ( ) )\nl = [ ]\nfor i in range ( n ) :\n    spot = list ( map ( int , input ( ).split ( ) ) )\n    l.append ( spot )\nbol = False\nfor i in range ( n - 1 ) :\n    for j in range ( i + 1 , n ) :\n        if l [ i ] [ 0 ] + l [ i ] [ 1 ] == l [ j ] [ 0 ] and l [ i ] [ 0 ] == l [ j ] [ 0 ] + l [ j ] [ 1 ] :\n            print ( 'YES' )\n            bol = True\n            break\n        else :\n            pass\n    if bol == True :\n        break\n    else :\n        pass\nif bol == True :\n    pass\nelse :\n    print ( 'NO' )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT spot = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . append ( spot ) NEW_LINE DEDENT bol = False NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if l [ i ] [ 0 ] + l [ i ] [ 1 ] == l [ j ] [ 0 ] and l [ i ] [ 0 ] == l [ j ] [ 0 ] + l [ j ] [ 1 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE bol = True NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT if bol == True : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT if bol == True : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1240_A", "sol": 0, "python_code": "def __gcd ( a , b ) :\n    if ( a == 0 or b == 0 ) :\n        return 0 ;\n    if ( a == b ) :\n        return a ;\n    if ( a > b ) :\n        return __gcd ( a - b , b ) ;\n    return __gcd ( a , b - a ) ;\ndef NumberOfSquares ( x , y ) :\n    s = __gcd ( x , y ) ;\n    ans = ( x * y ) / ( s * s ) ;\n    return int ( ans ) ;\nm = 385 ;\nn = 60 ;\nprint ( NumberOfSquares ( m , n ) ) ;\n", "python_code_tokenized": "def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) ; NEW_LINE DEDENT return __gcd ( a , b - a ) ; NEW_LINE DEDENT def NumberOfSquares ( x , y ) : NEW_LINE INDENT s = __gcd ( x , y ) ; NEW_LINE ans = ( x * y ) / ( s * s ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT m = 385 ; NEW_LINE n = 60 ; NEW_LINE print ( NumberOfSquares ( m , n ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_1647_A", "sol": 0, "python_code": "def checkArray ( a , b , n ) :\n    operations = 0 ;\n    i = 0 ;\n    while ( i < n ) :\n        if ( a [ i ] - b [ i ] == 0 ) :\n            i += 1 ;\n            continue ;\n        diff = a [ i ] - b [ i ] ;\n        i += 1 ;\n        while ( i < n and a [ i ] - b [ i ] == diff ) :\n            i += 1 ;\n        operations += 1 ;\n    print ( operations ) ;\nif __name__ == \"__main__\" :\n    a = [ 3 , 7 , 1 , 4 , 1 , 2 ] ;\n    b = [ 3 , 7 , 3 , 6 , 3 , 2 ] ;\n    size = len ( a ) ;\n    checkArray ( a , b , size ) ;\n", "python_code_tokenized": "def checkArray ( a , b , n ) : NEW_LINE INDENT operations = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( a [ i ] - b [ i ] == 0 ) : NEW_LINE INDENT i += 1 ; NEW_LINE continue ; NEW_LINE DEDENT diff = a [ i ] - b [ i ] ; NEW_LINE i += 1 ; NEW_LINE while ( i < n and a [ i ] - b [ i ] == diff ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT operations += 1 ; NEW_LINE DEDENT print ( operations ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 3 , 7 , 1 , 4 , 1 , 2 ] ; NEW_LINE b = [ 3 , 7 , 3 , 6 , 3 , 2 ] ; NEW_LINE size = len ( a ) ; NEW_LINE checkArray ( a , b , size ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_887_A", "sol": 0, "python_code": "N = 100005\nphi = [ 0 ] * N\nS = [ 0 ] * N\ndef computeTotient ( ) :\n    for i in range ( 1 , N ) :\n        phi [ i ] = i\n    for p in range ( 2 , N ) :\n        if ( phi [ p ] == p ) :\n            phi [ p ] = p - 1\n            for i in range ( 2 * p , N , p ) :\n                phi [ i ] = ( phi [ i ] // p ) * ( p - 1 )\ndef CoPrimes ( ) :\n    computeTotient ( )\n    for i in range ( 1 , N ) :\n        S [ i ] = S [ i - 1 ] + phi [ i ]\nif __name__ == \"__main__\" :\n    CoPrimes ( )\n    q = [ 3 , 4 ]\n    n = len ( q )\n    for i in range ( n ) :\n        print ( \"Number of unordered coprime\\n\" + \"pairs of integers from 1 to \" , q [ i ] , \" are \" , S [ q [ i ] ] )\n", "python_code_tokenized": "N = 100005 NEW_LINE phi = [ 0 ] * N NEW_LINE S = [ 0 ] * N NEW_LINE def computeTotient ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , N ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , N , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def CoPrimes ( ) : NEW_LINE INDENT computeTotient ( ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT S [ i ] = S [ i - 1 ] + phi [ i ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT CoPrimes ( ) NEW_LINE q = [ 3 , 4 ] NEW_LINE n = len ( q ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( \" Number \u2581 of \u2581 unordered \u2581 coprime \\n \" + \" pairs \u2581 of \u2581 integers \u2581 from \u2581 1 \u2581 to \u2581 \" , q [ i ] , \" \u2581 are \u2581 \" , S [ q [ i ] ] ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1148_B", "sol": 0, "python_code": "def search ( a , x ) :\n    lo = 0\n    hi = len ( a )\n    while hi > lo :\n        mid = ( lo + hi ) // 2\n        if a [ mid ] < x :\n            lo = mid + 1\n        else :\n            hi = mid\n    return hi\nn , m , ta , tb , k = map ( int , input ( ).split ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nb = list ( map ( int , input ( ).split ( ) ) )\nz = - 1\nflag = 0\nif k >= len ( a ) :\n    print ( - 1 )\n    flag = 1\nfor i in range ( min ( k + 1 , len ( a ) ) ) :\n    v = search ( b , a [ i ] + ta )\n    if ( v + k - i ) >= m :\n        if flag == 0 :\n            print ( - 1 )\n        flag = 1\n        break\n    z = max ( z , b [ v + k - i ] + tb )\nif flag == 0 :\n    print ( z )\n", "python_code_tokenized": "def search ( a , x ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = len ( a ) NEW_LINE while hi > lo : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE if a [ mid ] < x : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid NEW_LINE DEDENT DEDENT return hi NEW_LINE DEDENT n , m , ta , tb , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE z = - 1 NEW_LINE flag = 0 NEW_LINE if k >= len ( a ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE flag = 1 NEW_LINE DEDENT for i in range ( min ( k + 1 , len ( a ) ) ) : NEW_LINE INDENT v = search ( b , a [ i ] + ta ) NEW_LINE if ( v + k - i ) >= m : NEW_LINE INDENT if flag == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT flag = 1 NEW_LINE break NEW_LINE DEDENT z = max ( z , b [ v + k - i ] + tb ) NEW_LINE DEDENT if flag == 0 : NEW_LINE INDENT print ( z ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4336_A", "sol": 0, "python_code": "N = 4\ndef subtract ( A , B , C ) :\n    for i in range ( N ) :\n        for j in range ( N ) :\n            C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ]\nA = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ]\nB = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ]\nC = A [ : ] [ : ]\nsubtract ( A , B , C )\nprint ( \"Result matrix is\" )\nfor i in range ( N ) :\n    for j in range ( N ) :\n        print ( C [ i ] [ j ] , \" \" , end = '' )\n    print ( )\n", "python_code_tokenized": "N = 4 NEW_LINE def subtract ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE C = A [ : ] [ : ] NEW_LINE subtract ( A , B , C ) NEW_LINE print ( \" Result \u2581 matrix \u2581 is \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( C [ i ] [ j ] , \" \u2581 \" , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4337_A", "sol": 0, "python_code": "N = 4\ndef add ( A , B , C ) :\n    for i in range ( N ) :\n        for j in range ( N ) :\n            C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ]\nA = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ]\nB = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ]\nC = A [ : ] [ : ]\nadd ( A , B , C )\nprint ( \"Result matrix is\" )\nfor i in range ( N ) :\n    for j in range ( N ) :\n        print ( C [ i ] [ j ] , \" \" , end = '' )\n    print ( )\n", "python_code_tokenized": "N = 4 NEW_LINE def add ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE C = A [ : ] [ : ] NEW_LINE add ( A , B , C ) NEW_LINE print ( \" Result \u2581 matrix \u2581 is \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( C [ i ] [ j ] , \" \u2581 \" , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"id": "codeforces_556_A", "sol": 0, "python_code": "cnt = cnt2 = 0\nn = int ( input ( ) )\ns = str ( input ( ) )\nfor i in range ( len ( s ) ) :\n    if ( s [ i ] == '0' ) :\n        cnt += 1\n    elif ( s [ i ] == '1' ) :\n        cnt2 += 1\nprint ( abs ( cnt - cnt2 ) )\n", "python_code_tokenized": "cnt = cnt2 = 0 NEW_LINE n = int ( input ( ) ) NEW_LINE s = str ( input ( ) ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif ( s [ i ] == '1' ) : NEW_LINE INDENT cnt2 += 1 NEW_LINE DEDENT DEDENT print ( abs ( cnt - cnt2 ) ) NEW_LINE"}
{"id": "codeforces_350_A", "sol": 0, "python_code": "n , m = map ( int , input ( ).split ( ) )\nct = [ int ( c ) for c in input ( ).split ( \" \" , n - 1 ) ]\nwt = [ int ( w ) for w in input ( ).split ( \" \" , m - 1 ) ]\np = min ( ct )\nq = max ( ct )\nr = min ( wt )\nk = max ( 2 * p , q )\nif k >= r :\n    print ( - 1 )\nelse :\n    print ( k )\n", "python_code_tokenized": "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE ct = [ int ( c ) for c in input ( ) . split ( \" \u2581 \" , n - 1 ) ] NEW_LINE wt = [ int ( w ) for w in input ( ) . split ( \" \u2581 \" , m - 1 ) ] NEW_LINE p = min ( ct ) NEW_LINE q = max ( ct ) NEW_LINE r = min ( wt ) NEW_LINE k = max ( 2 * p , q ) NEW_LINE if k >= r : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1159_A", "sol": 0, "python_code": "def isVowel ( c ) :\n    c = c.lower ( )\n    if ( c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' ) :\n        return True\n    return False\ndef firstXvowels ( s , x ) :\n    result = \"\"\n    for i in range ( 0 , len ( s ) , 1 ) :\n        if ( isVowel ( s [ i ] ) ) :\n            result += s [ i ]\n        if ( len ( result ) == x ) :\n            return result\n    return \"-1\"\nif __name__ == '__main__' :\n    str = \"GeeksForGeeks\"\n    x = 3\n    print ( firstXvowels ( str , x ) )\n", "python_code_tokenized": "def isVowel ( c ) : NEW_LINE INDENT c = c . lower ( ) NEW_LINE if ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def firstXvowels ( s , x ) : NEW_LINE INDENT result = \" \" NEW_LINE for i in range ( 0 , len ( s ) , 1 ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) ) : NEW_LINE INDENT result += s [ i ] NEW_LINE DEDENT if ( len ( result ) == x ) : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT return \" - 1\" NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" GeeksForGeeks \" NEW_LINE x = 3 NEW_LINE print ( firstXvowels ( str , x ) ) NEW_LINE DEDENT"}
{"id": "codeforces_149_A", "sol": 0, "python_code": "k = int ( input ( ) )\narr = list ( map ( int , input ( ).split ( ) ) )\narr.sort ( reverse = True )\nres = 0\ns = 0\nfor i in range ( 12 ) :\n    if s >= k : break\n    else :\n        s += arr [ i ]\n        res += 1\nif s < k : print ( - 1 )\nelse : print ( res )\n", "python_code_tokenized": "k = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE s = 0 NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT if s >= k : break NEW_LINE else : NEW_LINE INDENT s += arr [ i ] NEW_LINE res += 1 NEW_LINE DEDENT DEDENT if s < k : print ( - 1 ) NEW_LINE else : print ( res ) NEW_LINE"}
{"id": "geeksforgeeks_2304_A", "sol": 0, "python_code": "def maxProd ( N ) :\n    if ( N == 0 ) :\n        return 1\n    if ( N < 10 ) :\n        return N\n    return max ( maxProd ( N // 10 ) * ( N % 10 ) , maxProd ( N // 10 - 1 ) * 9 )\nN = 390\nprint ( maxProd ( N ) )\n", "python_code_tokenized": "def maxProd ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N < 10 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( maxProd ( N // 10 ) * ( N % 10 ) , maxProd ( N // 10 - 1 ) * 9 ) NEW_LINE DEDENT N = 390 NEW_LINE print ( maxProd ( N ) ) NEW_LINE"}
{"id": "codeforces_1355_A", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    a , k = input ( ).split ( )\n    k1 = int ( k )\n    while k1 > 1 and '0' not in a : a = str ( int ( a ) + int ( min ( a ) ) * int ( max ( a ) ) ) ; k1 -= 1\n    print ( a )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , k = input ( ) . split ( ) NEW_LINE k1 = int ( k ) NEW_LINE while k1 > 1 and '0' not in a : a = str ( int ( a ) + int ( min ( a ) ) * int ( max ( a ) ) ) ; k1 -= 1 NEW_LINE print ( a ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4443_A", "sol": 0, "python_code": "def missingK ( a , k , n ) :\n    difference = 0\n    ans = 0\n    count = k\n    flag = 0\n    for i in range ( 0 , n - 1 ) :\n        difference = 0\n        if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) :\n            difference += ( a [ i + 1 ] - a [ i ] ) - 1\n            if ( difference >= count ) :\n                ans = a [ i ] + count\n                flag = 1\n                break\n            else :\n                count -= difference\n    if ( flag ) :\n        return ans\n    else :\n        return - 1\na = [ 1 , 5 , 11 , 19 ]\nk = 11\nn = len ( a )\nmissing = missingK ( a , k , n )\nprint ( missing )\n", "python_code_tokenized": "def missingK ( a , k , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE count = k NEW_LINE flag = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT difference = 0 NEW_LINE if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) : NEW_LINE INDENT difference += ( a [ i + 1 ] - a [ i ] ) - 1 NEW_LINE if ( difference >= count ) : NEW_LINE INDENT ans = a [ i ] + count NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT count -= difference NEW_LINE DEDENT DEDENT DEDENT if ( flag ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT a = [ 1 , 5 , 11 , 19 ] NEW_LINE k = 11 NEW_LINE n = len ( a ) NEW_LINE missing = missingK ( a , k , n ) NEW_LINE print ( missing ) NEW_LINE"}
{"id": "codeforces_32_B", "sol": 0, "python_code": "s = input ( )\nresult = \"\"\ni = 0\nwhile i < len ( s ) :\n    if s [ i ] == \".\" :\n        result += '0'\n    else :\n        i += 1\n        if s [ i ] == \".\" :\n            result += '1'\n        else :\n            result += '2'\n    i += 1\nprint ( result )\n", "python_code_tokenized": "s = input ( ) NEW_LINE result = \" \" NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if s [ i ] == \" . \" : NEW_LINE INDENT result += '0' NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE if s [ i ] == \" . \" : NEW_LINE INDENT result += '1' NEW_LINE DEDENT else : NEW_LINE INDENT result += '2' NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( result ) NEW_LINE"}
{"id": "geeksforgeeks_5211_A", "sol": 0, "python_code": "def maxValue ( arr , n , moves ) :\n    for i in range ( n - 2 , - 1 , - 1 ) :\n        if ( arr [ i ] > 0 ) :\n            distance = n - 1 - i\n            if ( moves < distance ) :\n                break\n            can_take = moves // distance\n            take = min ( arr [ i ] , can_take )\n            arr [ n - 1 ] += take\n            moves -= take * distance\n    return arr [ n - 1 ]\nif __name__ == '__main__' :\n    arr = [ 2 , 3 , 0 , 1 ]\n    M = 5\n    N = len ( arr )\n    print ( maxValue ( arr , N , M ) )\n", "python_code_tokenized": "def maxValue ( arr , n , moves ) : NEW_LINE INDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT distance = n - 1 - i NEW_LINE if ( moves < distance ) : NEW_LINE INDENT break NEW_LINE DEDENT can_take = moves // distance NEW_LINE take = min ( arr [ i ] , can_take ) NEW_LINE arr [ n - 1 ] += take NEW_LINE moves -= take * distance NEW_LINE DEDENT DEDENT return arr [ n - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 0 , 1 ] NEW_LINE M = 5 NEW_LINE N = len ( arr ) NEW_LINE print ( maxValue ( arr , N , M ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3438_A", "sol": 0, "python_code": "def indexedSequentialSearch ( arr , n , k ) :\n    elements = [ 0 ] * 20\n    indices = [ 0 ] * 20\n    j , ind = 0 , 0\n    for i in range ( 0 , n , 3 ) :\n        elements [ ind ] = arr [ i ]\n        indices [ ind ] = i\n        ind += 1\n    if k < elements [ 0 ] :\n        print ( \"Not found\" )\n        exit ( 0 )\n    else :\n        for i in range ( 1 , ind + 1 ) :\n            if k < elements [ i ] :\n                start = indices [ i - 1 ]\n                end = indices [ i ]\n                break\n    for i in range ( start , end + 1 ) :\n        if k == arr [ i ] :\n            j = 1\n            break\n    if j == 1 :\n        print ( \"Found at index\" , i )\n    else :\n        print ( \"Not found\" )\nif __name__ == \"__main__\" :\n    arr = [ 6 , 7 , 8 , 9 , 10 ]\n    n = len ( arr )\n    k = 8\n    indexedSequentialSearch ( arr , n , k )\n", "python_code_tokenized": "def indexedSequentialSearch ( arr , n , k ) : NEW_LINE INDENT elements = [ 0 ] * 20 NEW_LINE indices = [ 0 ] * 20 NEW_LINE j , ind = 0 , 0 NEW_LINE for i in range ( 0 , n , 3 ) : NEW_LINE INDENT elements [ ind ] = arr [ i ] NEW_LINE indices [ ind ] = i NEW_LINE ind += 1 NEW_LINE DEDENT if k < elements [ 0 ] : NEW_LINE INDENT print ( \" Not \u2581 found \" ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , ind + 1 ) : NEW_LINE INDENT if k < elements [ i ] : NEW_LINE INDENT start = indices [ i - 1 ] NEW_LINE end = indices [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT if k == arr [ i ] : NEW_LINE INDENT j = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if j == 1 : NEW_LINE INDENT print ( \" Found \u2581 at \u2581 index \" , i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 found \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 8 NEW_LINE indexedSequentialSearch ( arr , n , k ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3795_A", "sol": 0, "python_code": "def solve ( Array , N , K ) :\n    count_Arr = [ 0 ] * ( N + 2 ) ;\n    factor = 1 ;\n    size = N ;\n    while ( size ) :\n        start = 1 ;\n        end = size ;\n        count_Arr [ 1 ] += factor * N ;\n        count_Arr [ end + 1 ] -= factor * N ;\n        factor += 1 ;\n        size //= 2 ;\n    for i in range ( 2 , N + 1 ) :\n        count_Arr [ i ] += count_Arr [ i - 1 ] ;\n    element = [ ] ;\n    for i in range ( N ) :\n        element.append ( ( Array [ i ] , count_Arr [ i + 1 ] ) ) ;\n    element.sort ( ) ;\n    start = 1 ;\n    for i in range ( N ) :\n        end = start + element [ i ] [ 1 ] - 1 ;\n        if ( K >= start and K <= end ) :\n            return element [ i ] [ 0 ] ;\n        start += element [ i ] [ 1 ] ;\n    return - 1 ;\nif __name__ == \"__main__\" :\n    arr = [ 2 , 4 , 5 , 1 ] ;\n    N = len ( arr ) ;\n    K = 13 ;\n    print ( solve ( arr , N , K ) ) ;\n", "python_code_tokenized": "def solve ( Array , N , K ) : NEW_LINE INDENT count_Arr = [ 0 ] * ( N + 2 ) ; NEW_LINE factor = 1 ; NEW_LINE size = N ; NEW_LINE while ( size ) : NEW_LINE INDENT start = 1 ; NEW_LINE end = size ; NEW_LINE count_Arr [ 1 ] += factor * N ; NEW_LINE count_Arr [ end + 1 ] -= factor * N ; NEW_LINE factor += 1 ; NEW_LINE size //= 2 ; NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT count_Arr [ i ] += count_Arr [ i - 1 ] ; NEW_LINE DEDENT element = [ ] ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT element . append ( ( Array [ i ] , count_Arr [ i + 1 ] ) ) ; NEW_LINE DEDENT element . sort ( ) ; NEW_LINE start = 1 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT end = start + element [ i ] [ 1 ] - 1 ; NEW_LINE if ( K >= start and K <= end ) : NEW_LINE INDENT return element [ i ] [ 0 ] ; NEW_LINE DEDENT start += element [ i ] [ 1 ] ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 5 , 1 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE K = 13 ; NEW_LINE print ( solve ( arr , N , K ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2541_A", "sol": 0, "python_code": "MAX = 1000000\nMOD = 10 ** 9 + 7\nresult = [ 0 for i in range ( MAX + 1 ) ]\nfact = [ 0 for i in range ( MAX + 1 ) ]\ndef preCompute ( ) :\n    fact [ 0 ] = 1\n    result [ 0 ] = 1\n    for i in range ( 1 , MAX + 1 ) :\n        fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD\n        result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD\ndef performQueries ( q , n ) :\n    preCompute ( )\n    for i in range ( n ) :\n        print ( result [ q [ i ] ] )\nq = [ 4 , 5 ]\nn = len ( q )\nperformQueries ( q , n )\n", "python_code_tokenized": "MAX = 1000000 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE result = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE fact = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD NEW_LINE result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD NEW_LINE DEDENT DEDENT def performQueries ( q , n ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( result [ q [ i ] ] ) NEW_LINE DEDENT DEDENT q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE"}
{"id": "codeforces_1443_B", "sol": 0, "python_code": "def miner ( a , b , mines ) :\n    s = 0\n    j = 0\n    while j < len ( mines ) and mines [ j ] != \"1\" :\n        j += 1\n    if j == len ( mines ) :\n        return 0\n    for i in range ( j + 1 , len ( mines ) ) :\n        if mines [ i ] == \"0\" and mines [ i - 1 ] == \"1\" :\n            r1 = i - 1\n        elif mines [ i ] == \"1\" and mines [ i - 1 ] == \"0\" :\n            s += min ( b * ( i - r1 - 1 ) , a )\n    s += a\n    return s\nt = int ( input ( ) )\nfor _ in range ( t ) :\n    a , b = map ( int , input ( ).split ( ) )\n    mines = input ( )\n    print ( miner ( a , b , mines ) )\n", "python_code_tokenized": "def miner ( a , b , mines ) : NEW_LINE INDENT s = 0 NEW_LINE j = 0 NEW_LINE while j < len ( mines ) and mines [ j ] != \"1\" : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if j == len ( mines ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( j + 1 , len ( mines ) ) : NEW_LINE INDENT if mines [ i ] == \"0\" and mines [ i - 1 ] == \"1\" : NEW_LINE INDENT r1 = i - 1 NEW_LINE DEDENT elif mines [ i ] == \"1\" and mines [ i - 1 ] == \"0\" : NEW_LINE INDENT s += min ( b * ( i - r1 - 1 ) , a ) NEW_LINE DEDENT DEDENT s += a NEW_LINE return s NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE mines = input ( ) NEW_LINE print ( miner ( a , b , mines ) ) NEW_LINE DEDENT"}
{"id": "codeforces_1268_A", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nstr = input ( )\na = [ ]\nb = [ ]\nfor i in range ( n ) :\n    a.append ( int ( str [ i ] ) )\n    b.append ( int ( str [ i ] ) )\ndef check ( x ) :\n    for i in range ( n ) :\n        if x [ i ] > b [ i ] :\n            return True\n        elif x [ i ] < b [ i ] :\n            return False\n    return True\nfor i in range ( k ) :\n    for j in range ( i , n , k ) :\n        a [ j ] = a [ i ]\nif check ( a ) is False :\n    a [ k - 1 ] += 1\n    for i in range ( k - 1 + k , n , k ) :\n        a [ i ] = a [ k - 1 ]\nfor i in range ( n - 1 , - 1 , - 1 ) :\n    if a [ i ] == 10 :\n        a [ i - 1 ] += 1\n        a [ i ] = 0\nfor i in range ( k ) :\n    for j in range ( i , n , k ) :\n        a [ j ] = a [ i ]\nprint ( n )\nfor i in range ( n ) :\n    print ( a [ i ] , end = '' )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE str = input ( ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( int ( str [ i ] ) ) NEW_LINE b . append ( int ( str [ i ] ) ) NEW_LINE DEDENT def check ( x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if x [ i ] > b [ i ] : NEW_LINE INDENT return True NEW_LINE DEDENT elif x [ i ] < b [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT for j in range ( i , n , k ) : NEW_LINE INDENT a [ j ] = a [ i ] NEW_LINE DEDENT DEDENT if check ( a ) is False : NEW_LINE INDENT a [ k - 1 ] += 1 NEW_LINE for i in range ( k - 1 + k , n , k ) : NEW_LINE INDENT a [ i ] = a [ k - 1 ] NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] == 10 : NEW_LINE INDENT a [ i - 1 ] += 1 NEW_LINE a [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT for j in range ( i , n , k ) : NEW_LINE INDENT a [ j ] = a [ i ] NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = ' ' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3185_A", "sol": 0, "python_code": "from math import * ;\ndef maxResult ( n , a , b , c ) :\n    maxVal = 0 ;\n    for i in range ( 0 , n + 1 , a ) :\n        for j in range ( 0 , n - i + 1 , b ) :\n            z = ( n - ( i + j ) ) / c ;\n            if ( floor ( z ) == ceil ( z ) ) :\n                x = i // a ;\n                y = j // b ;\n                maxVal = max ( maxVal , x + y + int ( z ) ) ;\n    return maxVal ;\nif __name__ == \"__main__\" :\n    n = 10\n    a = 5\n    b = 3\n    c = 4\n    print ( maxResult ( n , a , b , c ) ) ;\n", "python_code_tokenized": "from math import * ; NEW_LINE def maxResult ( n , a , b , c ) : NEW_LINE INDENT maxVal = 0 ; NEW_LINE for i in range ( 0 , n + 1 , a ) : NEW_LINE INDENT for j in range ( 0 , n - i + 1 , b ) : NEW_LINE INDENT z = ( n - ( i + j ) ) / c ; NEW_LINE if ( floor ( z ) == ceil ( z ) ) : NEW_LINE INDENT x = i // a ; NEW_LINE y = j // b ; NEW_LINE maxVal = max ( maxVal , x + y + int ( z ) ) ; NEW_LINE DEDENT DEDENT DEDENT return maxVal ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE a = 5 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE print ( maxResult ( n , a , b , c ) ) ; NEW_LINE DEDENT"}
{"id": "atcoder_ABC178_A", "sol": 0, "python_code": "x = int ( input ( ) )\nif x == 1 :\n    print ( 0 )\nelse :\n    print ( 1 )\n", "python_code_tokenized": "x = int ( input ( ) ) NEW_LINE if x == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC159_C", "sol": 0, "python_code": "L = int ( input ( ) )\nans = ( L / 3 ) ** 3\nprint ( ans )\n", "python_code_tokenized": "L = int ( input ( ) ) NEW_LINE ans = ( L / 3 ) ** 3 NEW_LINE print ( ans ) NEW_LINE"}
{"id": "geeksforgeeks_822_A", "sol": 0, "python_code": "from math import *\ndef find_angle ( x , y , z ) :\n    volume = x * x * y ;\n    ans = 0 ;\n    if ( z < volume // 2 ) :\n        d = ( x * y * y ) / ( 2.0 * z ) ;\n        ans = atan ( d ) ;\n    else :\n        z = volume - z ;\n        d = ( 2 * z ) / ( float ) ( x * x * x ) ;\n        ans = atan ( d ) ;\n    ans = ( ans * 180 ) / 3.14159265 ;\n    return round ( ans , 4 ) ;\nif __name__ == \"__main__\" :\n    x = 12 ;\n    y = 21 ;\n    z = 10 ;\n    print ( find_angle ( x , y , z ) ) ;\n", "python_code_tokenized": "from math import * NEW_LINE def find_angle ( x , y , z ) : NEW_LINE INDENT volume = x * x * y ; NEW_LINE ans = 0 ; NEW_LINE if ( z < volume // 2 ) : NEW_LINE INDENT d = ( x * y * y ) / ( 2.0 * z ) ; NEW_LINE ans = atan ( d ) ; NEW_LINE DEDENT else : NEW_LINE INDENT z = volume - z ; NEW_LINE d = ( 2 * z ) / ( float ) ( x * x * x ) ; NEW_LINE ans = atan ( d ) ; NEW_LINE DEDENT ans = ( ans * 180 ) / 3.14159265 ; NEW_LINE return round ( ans , 4 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 12 ; NEW_LINE y = 21 ; NEW_LINE z = 10 ; NEW_LINE print ( find_angle ( x , y , z ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3050_A", "sol": 0, "python_code": "def Square ( row , column , moves ) :\n    a = 0 ; b = 0 ; c = 0 ;\n    d = 0 ; total = 0 ;\n    a = row - moves ;\n    b = row + moves ;\n    c = column - moves ;\n    d = column + moves ;\n    if ( a < 1 ) :\n        a = 1 ;\n    if ( c < 1 ) :\n        c = 1 ;\n    if ( b > 8 ) :\n        b = 8 ;\n    if ( d > 8 ) :\n        d = 8 ;\n    total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ;\n    return total ;\nif __name__ == \"__main__\" :\n    R = 4 ; C = 5 ; M = 2 ;\n    print ( Square ( R , C , M ) ) ;\n", "python_code_tokenized": "def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 ; b = 0 ; c = 0 ; NEW_LINE d = 0 ; total = 0 ; NEW_LINE a = row - moves ; NEW_LINE b = row + moves ; NEW_LINE c = column - moves ; NEW_LINE d = column + moves ; NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 ; NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 ; NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 ; NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 ; NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; NEW_LINE return total ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT R = 4 ; C = 5 ; M = 2 ; NEW_LINE print ( Square ( R , C , M ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3400_A", "sol": 0, "python_code": "def countdig ( m ) :\n    if ( m == 0 ) :\n        return 0\n    else :\n        return 1 + countdig ( m // 10 )\ndef countSteps ( x ) :\n    c = 0\n    last = x\n    while ( last ) :\n        digits = countdig ( last )\n        digits -= 1\n        divisor = pow ( 10 , digits )\n        first = last // divisor\n        lastnumber = first * divisor\n        skipped = ( last - lastnumber ) // first\n        skipped += 1\n        c += skipped\n        last = last - ( first * skipped )\n    return c\nn = 14\nprint ( countSteps ( n ) )\n", "python_code_tokenized": "def countdig ( m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countdig ( m // 10 ) NEW_LINE DEDENT DEDENT def countSteps ( x ) : NEW_LINE INDENT c = 0 NEW_LINE last = x NEW_LINE while ( last ) : NEW_LINE INDENT digits = countdig ( last ) NEW_LINE digits -= 1 NEW_LINE divisor = pow ( 10 , digits ) NEW_LINE first = last // divisor NEW_LINE lastnumber = first * divisor NEW_LINE skipped = ( last - lastnumber ) // first NEW_LINE skipped += 1 NEW_LINE c += skipped NEW_LINE last = last - ( first * skipped ) NEW_LINE DEDENT return c NEW_LINE DEDENT n = 14 NEW_LINE print ( countSteps ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_1693_A", "sol": 0, "python_code": "def isMultipleOf3 ( n ) :\n    odd_count = 0\n    even_count = 0\n    if ( n < 0 ) :\n        n = - n\n    if ( n == 0 ) :\n        return 1\n    if ( n == 1 ) :\n        return 0\n    while ( n ) :\n        if ( n & 1 ) :\n            odd_count += 1\n        if ( n & 2 ) :\n            even_count += 1\n        n = n >> 2\n    return isMultipleOf3 ( abs ( odd_count - even_count ) )\nnum = 24\nif ( isMultipleOf3 ( num ) ) :\n    print ( num , 'is multiple of 3' )\nelse :\n    print ( num , 'is not a multiple of 3' )\n", "python_code_tokenized": "def isMultipleOf3 ( n ) : NEW_LINE INDENT odd_count = 0 NEW_LINE even_count = 0 NEW_LINE if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT if ( n & 2 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n >> 2 NEW_LINE DEDENT return isMultipleOf3 ( abs ( odd_count - even_count ) ) NEW_LINE DEDENT num = 24 NEW_LINE if ( isMultipleOf3 ( num ) ) : NEW_LINE INDENT print ( num , ' is \u2581 multiple \u2581 of \u2581 3' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( num , ' is \u2581 not \u2581 a \u2581 multiple \u2581 of \u2581 3' ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2398_A", "sol": 0, "python_code": "x = 26\nmod = 3001\ndef CntSubstr ( s , l ) :\n    hash = 0 ;\n    for i in range ( l ) :\n        hash = ( hash * x + ( ord ( s [ i ] ) - 97 ) ) % mod ;\n    pow_l = 1 ;\n    for i in range ( l - 1 ) :\n        pow_l = ( pow_l * x ) % mod ;\n    result = set ( ) ;\n    result.add ( hash ) ;\n    for i in range ( l , len ( s ) ) :\n        hash = ( ( hash - pow_l * ( ord ( s [ i - l ] ) - 97 ) + 2 * mod ) * x + ( ord ( s [ i ] ) - 97 ) ) % mod ;\n        result.add ( hash ) ;\n    print ( len ( result ) ) ;\nif __name__ == \"__main__\" :\n    s = \"abcba\" ;\n    l = 2 ;\n    CntSubstr ( s , l ) ;\n", "python_code_tokenized": "x = 26 NEW_LINE mod = 3001 NEW_LINE def CntSubstr ( s , l ) : NEW_LINE INDENT hash = 0 ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT hash = ( hash * x + ( ord ( s [ i ] ) - 97 ) ) % mod ; NEW_LINE DEDENT pow_l = 1 ; NEW_LINE for i in range ( l - 1 ) : NEW_LINE INDENT pow_l = ( pow_l * x ) % mod ; NEW_LINE DEDENT result = set ( ) ; NEW_LINE result . add ( hash ) ; NEW_LINE for i in range ( l , len ( s ) ) : NEW_LINE INDENT hash = ( ( hash - pow_l * ( ord ( s [ i - l ] ) - 97 ) + 2 * mod ) * x + ( ord ( s [ i ] ) - 97 ) ) % mod ; NEW_LINE result . add ( hash ) ; NEW_LINE DEDENT print ( len ( result ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abcba \" ; NEW_LINE l = 2 ; NEW_LINE CntSubstr ( s , l ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5240_A", "sol": 0, "python_code": "def countPiles ( n , a ) :\n    occ = dict ( )\n    for i in a :\n        if i in occ.keys ( ) :\n            occ [ i ] += 1\n        else :\n            occ [ i ] = 1\n    pile = 0\n    while ( len ( occ ) > 0 ) :\n        pile += 1\n        size = 0\n        toRemove = dict ( )\n        for tm in occ :\n            mx = tm\n            ct = occ [ tm ]\n            use = min ( ct , mx - size + 1 )\n            occ [ mx ] -= use\n            size += use\n            if ( occ [ mx ] == 0 ) :\n                toRemove [ mx ] = 1\n        for tm in toRemove :\n            del occ [ tm ]\n    return pile\na = [ 0 , 0 , 1 , 1 , 2 ]\nn = len ( a )\nprint ( countPiles ( n , a ) )\n", "python_code_tokenized": "def countPiles ( n , a ) : NEW_LINE INDENT occ = dict ( ) NEW_LINE for i in a : NEW_LINE INDENT if i in occ . keys ( ) : NEW_LINE INDENT occ [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT occ [ i ] = 1 NEW_LINE DEDENT DEDENT pile = 0 NEW_LINE while ( len ( occ ) > 0 ) : NEW_LINE INDENT pile += 1 NEW_LINE size = 0 NEW_LINE toRemove = dict ( ) NEW_LINE for tm in occ : NEW_LINE INDENT mx = tm NEW_LINE ct = occ [ tm ] NEW_LINE use = min ( ct , mx - size + 1 ) NEW_LINE occ [ mx ] -= use NEW_LINE size += use NEW_LINE if ( occ [ mx ] == 0 ) : NEW_LINE INDENT toRemove [ mx ] = 1 NEW_LINE DEDENT DEDENT for tm in toRemove : NEW_LINE INDENT del occ [ tm ] NEW_LINE DEDENT DEDENT return pile NEW_LINE DEDENT a = [ 0 , 0 , 1 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( countPiles ( n , a ) ) NEW_LINE"}
{"id": "geeksforgeeks_214_A", "sol": 0, "python_code": "def flipsPossible ( a , n ) :\n    count_odd = 0 ; count_even = 0 ;\n    for i in range ( n ) :\n        if ( a [ i ] & 1 ) :\n            count_odd += 1 ;\n        else :\n            count_even += 1 ;\n    if ( count_odd % 2 and count_even % 2 ) :\n        return False ;\n    else :\n        return True ;\nif __name__ == \"__main__\" :\n    a = [ 1 , 0 , 1 , 1 , 0 , 1 ] ;\n    n = len ( a ) ;\n    if ( flipsPossible ( a , n ) ) :\n        print ( \"Yes\" ) ;\n    else :\n        print ( \"No\" ) ;\n", "python_code_tokenized": "def flipsPossible ( a , n ) : NEW_LINE INDENT count_odd = 0 ; count_even = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] & 1 ) : NEW_LINE INDENT count_odd += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 ; NEW_LINE DEDENT DEDENT if ( count_odd % 2 and count_even % 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 0 , 1 , 1 , 0 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( flipsPossible ( a , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_4084_A", "sol": 0, "python_code": "def checkdigit ( n , k ) :\n    while ( n ) :\n        rem = n % 10\n        if ( rem == k ) :\n            return 1\n        n = n / 10\n    return 0\ndef findNthNumber ( n , k ) :\n    i = k + 1\n    count = 1\n    while ( count < n ) :\n        if ( checkdigit ( i , k ) or ( i % k == 0 ) ) :\n            count += 1\n        if ( count == n ) :\n            return i\n        i += 1\n    return - 1\nn = 10\nk = 2\nprint ( findNthNumber ( n , k ) )\n", "python_code_tokenized": "def checkdigit ( n , k ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT rem = n % 10 NEW_LINE if ( rem == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT n = n / 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def findNthNumber ( n , k ) : NEW_LINE INDENT i = k + 1 NEW_LINE count = 1 NEW_LINE while ( count < n ) : NEW_LINE INDENT if ( checkdigit ( i , k ) or ( i % k == 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE print ( findNthNumber ( n , k ) ) NEW_LINE"}
{"id": "aizu_p01967_A", "sol": 0, "python_code": "n = int ( input ( ) )\nC = list ( map ( int , input ( ).split ( ) ) )\nq = int ( input ( ) )\ndata = [ ]\nfor _ in range ( q ) :\n    t , x , d = map ( int , input ( ).split ( ) )\n    data.append ( [ t , x , d ] )\napple = [ 0 ] * n\nfor D in data :\n    t , x , d = D\n    if t == 1 :\n        apple [ x - 1 ] += d\n        if apple [ x - 1 ] > C [ x - 1 ] :\n            print ( x )\n            break\n    else :\n        apple [ x - 1 ] -= d\n        if apple [ x - 1 ] < 0 :\n            print ( x )\n            break\nelse :\n    print ( 0 )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE C = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE data = [ ] NEW_LINE for _ in range ( q ) : NEW_LINE INDENT t , x , d = map ( int , input ( ) . split ( ) ) NEW_LINE data . append ( [ t , x , d ] ) NEW_LINE DEDENT apple = [ 0 ] * n NEW_LINE for D in data : NEW_LINE INDENT t , x , d = D NEW_LINE if t == 1 : NEW_LINE INDENT apple [ x - 1 ] += d NEW_LINE if apple [ x - 1 ] > C [ x - 1 ] : NEW_LINE INDENT print ( x ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT apple [ x - 1 ] -= d NEW_LINE if apple [ x - 1 ] < 0 : NEW_LINE INDENT print ( x ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC066_C", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( input ( ).split ( ) )\nprint ( ' '.join ( a [ : : - 2 ] + a [ n % 2 : : 2 ] ) )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( input ( ) . split ( ) ) NEW_LINE print ( ' \u2581 ' . join ( a [ : : - 2 ] + a [ n % 2 : : 2 ] ) ) NEW_LINE"}
{"id": "geeksforgeeks_4030_A", "sol": 0, "python_code": "def isValidString ( str , n ) :\n    idx = str.find ( \"b\" )\n    if ( idx == 0 ) :\n        return False\n    while ( idx != - 1 ) :\n        if ( str [ idx - 1 ] != 'a' ) :\n            return False\n        if ( idx + 1 < n and str [ idx + 1 ] != 'b' ) :\n            return False\n        if ( idx + 2 < n and str [ idx + 2 ] == 'b' ) :\n            return False\n        if ( idx == n - 1 ) :\n            return False\n        idx = str.find ( \"b\" , idx + 2 )\n    return True\nif __name__ == \"__main__\" :\n    str = \"abbaaabbabba\"\n    n = len ( str )\n    print ( isValidString ( str , n ) )\n", "python_code_tokenized": "def isValidString ( str , n ) : NEW_LINE INDENT idx = str . find ( \" b \" ) NEW_LINE if ( idx == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( idx != - 1 ) : NEW_LINE INDENT if ( str [ idx - 1 ] != ' a ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( idx + 1 < n and str [ idx + 1 ] != ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( idx + 2 < n and str [ idx + 2 ] == ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( idx == n - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT idx = str . find ( \" b \" , idx + 2 ) NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" abbaaabbabba \" NEW_LINE n = len ( str ) NEW_LINE print ( isValidString ( str , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1182_A", "sol": 0, "python_code": "def minVal ( a , b ) :\n    setBits = bin ( b ).count ( '1' ) ;\n    ans = 0 ;\n    for i in range ( 30 , - 1 , - 1 ) :\n        mask = ( 1 << i ) ;\n        s = ( a & mask ) ;\n        if ( s and setBits > 0 ) :\n            ans |= ( 1 << i ) ;\n            setBits -= 1 ;\n    return ans ;\nif __name__ == \"__main__\" :\n    a = 3 ; b = 5 ;\n    print ( minVal ( a , b ) ) ;\n", "python_code_tokenized": "def minVal ( a , b ) : NEW_LINE INDENT setBits = bin ( b ) . count ( '1' ) ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( 30 , - 1 , - 1 ) : NEW_LINE INDENT mask = ( 1 << i ) ; NEW_LINE s = ( a & mask ) ; NEW_LINE if ( s and setBits > 0 ) : NEW_LINE INDENT ans |= ( 1 << i ) ; NEW_LINE setBits -= 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 ; b = 5 ; NEW_LINE print ( minVal ( a , b ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2622_A", "sol": 0, "python_code": "def findNthTerm ( N ) :\n    ans = 0\n    for i in range ( N ) :\n        if ( i % 2 == 0 ) :\n            ans = ans + 6\n        else :\n            ans = ans + 2\n    print ( ans )\nif __name__ == '__main__' :\n    N = 3\n    findNthTerm ( N )\n", "python_code_tokenized": "def findNthTerm ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ans = ans + 6 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE findNthTerm ( N ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4357_A", "sol": 0, "python_code": "M = 3\nN = 3\nmatrix = [ [ 12 , 23 , 34 ] , [ 45 , 56 , 67 ] , [ 78 , 89 , 91 ] ]\ndef rotateMatrix ( k ) :\n    global M , N , matrix\n    temp = [ 0 ] * M\n    k = k % M\n    for i in range ( 0 , N ) :\n        for t in range ( 0 , M - k ) :\n            temp [ t ] = matrix [ i ] [ t ]\n        for j in range ( M - k , M ) :\n            matrix [ i ] [ j - M + k ] = matrix [ i ] [ j ]\n        for j in range ( k , M ) :\n            matrix [ i ] [ j ] = temp [ j - k ]\ndef displayMatrix ( ) :\n    global M , N , matrix\n    for i in range ( 0 , N ) :\n        for j in range ( 0 , M ) :\n            print ( \"{} \".format ( matrix [ i ] [ j ] ) , end = \"\" )\n        print ( )\nk = 2\nrotateMatrix ( k )\ndisplayMatrix ( )\n", "python_code_tokenized": "M = 3 NEW_LINE N = 3 NEW_LINE matrix = [ [ 12 , 23 , 34 ] , [ 45 , 56 , 67 ] , [ 78 , 89 , 91 ] ] NEW_LINE def rotateMatrix ( k ) : NEW_LINE INDENT global M , N , matrix NEW_LINE temp = [ 0 ] * M NEW_LINE k = k % M NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for t in range ( 0 , M - k ) : NEW_LINE INDENT temp [ t ] = matrix [ i ] [ t ] NEW_LINE DEDENT for j in range ( M - k , M ) : NEW_LINE INDENT matrix [ i ] [ j - M + k ] = matrix [ i ] [ j ] NEW_LINE DEDENT for j in range ( k , M ) : NEW_LINE INDENT matrix [ i ] [ j ] = temp [ j - k ] NEW_LINE DEDENT DEDENT DEDENT def displayMatrix ( ) : NEW_LINE INDENT global M , N , matrix NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , M ) : NEW_LINE INDENT print ( \" { } \u2581 \" . format ( matrix [ i ] [ j ] ) , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT k = 2 NEW_LINE rotateMatrix ( k ) NEW_LINE displayMatrix ( ) NEW_LINE"}
{"id": "geeksforgeeks_2115_A", "sol": 0, "python_code": "def findSubsequence ( arr , n ) :\n    length = 1 ;\n    dp = [ 0 ] * 10 ;\n    tmp = arr [ 0 ] ;\n    while ( tmp > 0 ) :\n        dp [ tmp % 10 ] = 1 ;\n        tmp //= 10 ;\n    for i in range ( 1 , n ) :\n        tmp = arr [ i ] ;\n        locMax = 1 ;\n        cnt = [ 0 ] * 10\n        while ( tmp > 0 ) :\n            cnt [ tmp % 10 ] = 1 ;\n            tmp //= 10 ;\n        for d in range ( 10 ) :\n            if ( cnt [ d ] ) :\n                dp [ d ] += 1 ;\n                locMax = max ( locMax , dp [ d ] ) ;\n        for d in range ( 10 ) :\n            if ( cnt [ d ] ) :\n                dp [ d ] = locMax ;\n        length = max ( length , locMax ) ;\n    return length ;\nif __name__ == \"__main__\" :\n    arr = [ 1 , 12 , 44 , 29 , 33 , 96 , 89 ] ;\n    n = len ( arr )\n    print ( findSubsequence ( arr , n ) ) ;\n", "python_code_tokenized": "def findSubsequence ( arr , n ) : NEW_LINE INDENT length = 1 ; NEW_LINE dp = [ 0 ] * 10 ; NEW_LINE tmp = arr [ 0 ] ; NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT dp [ tmp % 10 ] = 1 ; NEW_LINE tmp //= 10 ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] ; NEW_LINE locMax = 1 ; NEW_LINE cnt = [ 0 ] * 10 NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 ; NEW_LINE tmp //= 10 ; NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] += 1 ; NEW_LINE locMax = max ( locMax , dp [ d ] ) ; NEW_LINE DEDENT DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] = locMax ; NEW_LINE DEDENT DEDENT length = max ( length , locMax ) ; NEW_LINE DEDENT return length ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 12 , 44 , 29 , 33 , 96 , 89 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( findSubsequence ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3782_A", "sol": 0, "python_code": "def countSegments ( a , n , x ) :\n    flag = False\n    count = 0\n    for i in range ( n ) :\n        if ( a [ i ] > x ) :\n            flag = True\n        else :\n            if ( flag ) :\n                count += 1\n            flag = False\n    if ( flag ) :\n        count += 1\n    return count\nif __name__ == '__main__' :\n    a = [ 8 , 25 , 10 , 19 , 19 , 18 , 20 , 11 , 18 ]\n    n = len ( a )\n    x = 13\n    print ( countSegments ( a , n , x ) )\n", "python_code_tokenized": "def countSegments ( a , n , x ) : NEW_LINE INDENT flag = False NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT else : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT flag = False NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 8 , 25 , 10 , 19 , 19 , 18 , 20 , 11 , 18 ] NEW_LINE n = len ( a ) NEW_LINE x = 13 NEW_LINE print ( countSegments ( a , n , x ) ) NEW_LINE DEDENT"}
{"id": "codeforces_122_A", "sol": 0, "python_code": "n = int ( input ( ) )\nif ( n % 4 == 0 or n % 7 == 0 or n % 44 == 0 or n % 47 == 0 or n % 74 == 0 or n % 77 == 0 or n % 444 == 0 or n % 447 == 0 or n % 474 == 0 or n % 477 == 0 or n % 744 == 0 or n % 747 == 0 or n % 774 == 0 or n % 777 == 0 ) :\n    print ( \"YES\" )\nelse :\n    print ( \"NO\" )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE if ( n % 4 == 0 or n % 7 == 0 or n % 44 == 0 or n % 47 == 0 or n % 74 == 0 or n % 77 == 0 or n % 444 == 0 or n % 447 == 0 or n % 474 == 0 or n % 477 == 0 or n % 744 == 0 or n % 747 == 0 or n % 774 == 0 or n % 777 == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1529_A", "sol": 0, "python_code": "def pivotedBinarySearch ( arr , n , key ) :\n    pivot = findPivot ( arr , 0 , n - 1 ) ;\n    if pivot == - 1 :\n        return binarySearch ( arr , 0 , n - 1 , key ) ;\n    if arr [ pivot ] == key :\n        return pivot\n    if arr [ 0 ] <= key :\n        return binarySearch ( arr , 0 , pivot - 1 , key ) ;\n    return binarySearch ( arr , pivot + 1 , n - 1 , key ) ;\ndef findPivot ( arr , low , high ) :\n    if high < low :\n        return - 1\n    if high == low :\n        return low\n    mid = int ( ( low + high ) / 2 )\n    if mid < high and arr [ mid ] > arr [ mid + 1 ] :\n        return mid\n    if mid > low and arr [ mid ] < arr [ mid - 1 ] :\n        return ( mid - 1 )\n    if arr [ low ] >= arr [ mid ] :\n        return findPivot ( arr , low , mid - 1 )\n    return findPivot ( arr , mid + 1 , high )\ndef binarySearch ( arr , low , high , key ) :\n    if high < low :\n        return - 1\n    mid = int ( ( low + high ) / 2 )\n    if key == arr [ mid ] :\n        return mid\n    if key > arr [ mid ] :\n        return binarySearch ( arr , ( mid + 1 ) , high , key ) ;\n    return binarySearch ( arr , low , ( mid - 1 ) , key ) ;\narr1 = [ 5 , 6 , 7 , 8 , 9 , 10 , 1 , 2 , 3 ]\nn = len ( arr1 )\nkey = 3\nprint ( \"Index of the element is : \" , pivotedBinarySearch ( arr1 , n , key ) )\n", "python_code_tokenized": "def pivotedBinarySearch ( arr , n , key ) : NEW_LINE INDENT pivot = findPivot ( arr , 0 , n - 1 ) ; NEW_LINE if pivot == - 1 : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key ) ; NEW_LINE DEDENT if arr [ pivot ] == key : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ 0 ] <= key : NEW_LINE INDENT return binarySearch ( arr , 0 , pivot - 1 , key ) ; NEW_LINE DEDENT return binarySearch ( arr , pivot + 1 , n - 1 , key ) ; NEW_LINE DEDENT def findPivot ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if mid < high and arr [ mid ] > arr [ mid + 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if arr [ low ] >= arr [ mid ] : NEW_LINE INDENT return findPivot ( arr , low , mid - 1 ) NEW_LINE DEDENT return findPivot ( arr , mid + 1 , high ) NEW_LINE DEDENT def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if key == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if key > arr [ mid ] : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) ; NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) ; NEW_LINE DEDENT arr1 = [ 5 , 6 , 7 , 8 , 9 , 10 , 1 , 2 , 3 ] NEW_LINE n = len ( arr1 ) NEW_LINE key = 3 NEW_LINE print ( \" Index \u2581 of \u2581 the \u2581 element \u2581 is \u2581 : \u2581 \" , pivotedBinarySearch ( arr1 , n , key ) ) NEW_LINE"}
{"id": "aizu_p00158_A", "sol": 0, "python_code": "while True :\n    x = int ( input ( ) )\n    if x == 0 :\n        break\n    c = 0\n    while True :\n        if x == 1 :\n            break\n        elif x % 2 == 0 :\n            x = x // 2\n        else :\n            x = x * 3 + 1\n        c += 1\n    print ( c )\n", "python_code_tokenized": "while True : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE if x == 0 : NEW_LINE INDENT break NEW_LINE DEDENT c = 0 NEW_LINE while True : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT break NEW_LINE DEDENT elif x % 2 == 0 : NEW_LINE INDENT x = x // 2 NEW_LINE DEDENT else : NEW_LINE INDENT x = x * 3 + 1 NEW_LINE DEDENT c += 1 NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC167_D", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\na = list ( map ( lambda x : int ( x ) - 1 , input ( ).split ( ) ) )\nts = [ [ ] for _ in range ( n ) ]\np = 0\nt = 0\nwhile True :\n    ts [ p ].append ( t )\n    if t == k :\n        print ( p + 1 )\n        exit ( )\n    if len ( ts [ p ] ) == 2 :\n        if ( k - ts [ p ] [ 0 ] ) % ( ts [ p ] [ 1 ] - ts [ p ] [ 0 ] ) == 0 :\n            print ( p + 1 )\n            exit ( )\n    p = a [ p ]\n    t += 1\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) NEW_LINE ts = [ [ ] for _ in range ( n ) ] NEW_LINE p = 0 NEW_LINE t = 0 NEW_LINE while True : NEW_LINE INDENT ts [ p ] . append ( t ) NEW_LINE if t == k : NEW_LINE INDENT print ( p + 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if len ( ts [ p ] ) == 2 : NEW_LINE INDENT if ( k - ts [ p ] [ 0 ] ) % ( ts [ p ] [ 1 ] - ts [ p ] [ 0 ] ) == 0 : NEW_LINE INDENT print ( p + 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT p = a [ p ] NEW_LINE t += 1 NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3005_A", "sol": 0, "python_code": "def summ ( h ) :\n    return pow ( 2 , h - 1 )\nL = 3\nprint ( summ ( L ) )\n", "python_code_tokenized": "def summ ( h ) : NEW_LINE INDENT return pow ( 2 , h - 1 ) NEW_LINE DEDENT L = 3 NEW_LINE print ( summ ( L ) ) NEW_LINE"}
{"id": "geeksforgeeks_2772_A", "sol": 0, "python_code": "def findSum ( str1 ) :\n    temp = \"\"\n    Sum = 0\n    for ch in str1 :\n        if ( ch.isdigit ( ) ) :\n            temp += ch\n        else :\n            Sum += int ( temp )\n            temp = \"0\"\n    return Sum + int ( temp )\nstr1 = \"12abc20yz68\"\nprint ( findSum ( str1 ) )\n", "python_code_tokenized": "def findSum ( str1 ) : NEW_LINE INDENT temp = \" \" NEW_LINE Sum = 0 NEW_LINE for ch in str1 : NEW_LINE INDENT if ( ch . isdigit ( ) ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT Sum += int ( temp ) NEW_LINE temp = \"0\" NEW_LINE DEDENT DEDENT return Sum + int ( temp ) NEW_LINE DEDENT str1 = \"12abc20yz68\" NEW_LINE print ( findSum ( str1 ) ) NEW_LINE"}
{"id": "codeforces_1084_B", "sol": 0, "python_code": "def check ( x ) :\n    sum = 0\n    for i in range ( 0 , n ) :\n        sum += v [ i ] - x\n    if sum >= s :\n        return True\n    else :\n        return False\nt = 1\nwhile t > 0 :\n    t -= 1\n    n , s = ( int ( _ ) for _ in input ( ).strip ( ).split ( ' ' ) )\n    v = list ( map ( int , input ( ).split ( ) ) )\n    sum = 0\n    l = 0\n    r = 0x3f3f3f3f\n    for i in range ( 0 , n ) :\n        sum += v [ i ]\n        r = min ( v [ i ] , r )\n    if sum < s :\n        print ( - 1 )\n    else :\n        while l < r :\n            mid = ( l + r + 1 ) >> 1\n            if check ( mid ) == True :\n                l = mid\n            else :\n                r = mid - 1\n        print ( l )\n", "python_code_tokenized": "def check ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += v [ i ] - x NEW_LINE DEDENT if sum >= s : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT t = 1 NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE n , s = ( int ( _ ) for _ in input ( ) . strip ( ) . split ( ' \u2581 ' ) ) NEW_LINE v = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum = 0 NEW_LINE l = 0 NEW_LINE r = 0x3f3f3f3f NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += v [ i ] NEW_LINE r = min ( v [ i ] , r ) NEW_LINE DEDENT if sum < s : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT while l < r : NEW_LINE INDENT mid = ( l + r + 1 ) >> 1 NEW_LINE if check ( mid ) == True : NEW_LINE INDENT l = mid NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT print ( l ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2155_A", "sol": 0, "python_code": "def countSquares ( row , column ) :\n    topLeft = min ( row , column ) - 1\n    bottomRight = 8 - max ( row , column )\n    topRight = min ( row , 9 - column ) - 1\n    bottomLeft = 8 - max ( row , 9 - column )\n    return ( topLeft + topRight + bottomRight + bottomLeft )\nrow = 4\ncolumn = 4\nprint ( countSquares ( row , column ) )\n", "python_code_tokenized": "def countSquares ( row , column ) : NEW_LINE INDENT topLeft = min ( row , column ) - 1 NEW_LINE bottomRight = 8 - max ( row , column ) NEW_LINE topRight = min ( row , 9 - column ) - 1 NEW_LINE bottomLeft = 8 - max ( row , 9 - column ) NEW_LINE return ( topLeft + topRight + bottomRight + bottomLeft ) NEW_LINE DEDENT row = 4 NEW_LINE column = 4 NEW_LINE print ( countSquares ( row , column ) ) NEW_LINE"}
{"id": "geeksforgeeks_190_A", "sol": 0, "python_code": "def findNumbers ( n , w ) :\n    x = 0 ;\n    sum = 0 ;\n    if ( w >= 0 and w <= 8 ) :\n        x = 9 - w ;\n    elif ( w >= - 9 and w <= - 1 ) :\n        x = 10 + w ;\n    sum = pow ( 10 , n - 2 ) ;\n    sum = ( x * sum ) ;\n    return sum ;\nn = 3 ;\nw = 4 ;\nprint ( findNumbers ( n , w ) ) ;\n", "python_code_tokenized": "def findNumbers ( n , w ) : NEW_LINE INDENT x = 0 ; NEW_LINE sum = 0 ; NEW_LINE if ( w >= 0 and w <= 8 ) : NEW_LINE INDENT x = 9 - w ; NEW_LINE DEDENT elif ( w >= - 9 and w <= - 1 ) : NEW_LINE INDENT x = 10 + w ; NEW_LINE DEDENT sum = pow ( 10 , n - 2 ) ; NEW_LINE sum = ( x * sum ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 3 ; NEW_LINE w = 4 ; NEW_LINE print ( findNumbers ( n , w ) ) ; NEW_LINE"}
{"id": "geeksforgeeks_1644_A", "sol": 0, "python_code": "def sumFirst ( a , n ) :\n    mp = { i : 0 for i in range ( 7 ) }\n    suf = 0\n    i = n - 1\n    while ( i >= 0 ) :\n        suf += a [ i ]\n        mp [ suf ] = i\n        i -= 1\n    pre = 0\n    maxi = - 1\n    for i in range ( n ) :\n        pre += a [ i ]\n        if ( mp [ pre ] > i ) :\n            if ( pre > maxi ) :\n                maxi = pre\n    if ( maxi == - 1 ) :\n        return 0\n    else :\n        return maxi\nif __name__ == '__main__' :\n    a = [ 1 , 3 , 2 , 1 , 4 ]\n    n = len ( a )\n    print ( sumFirst ( a , n ) )\n", "python_code_tokenized": "def sumFirst ( a , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 7 ) } NEW_LINE suf = 0 NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT suf += a [ i ] NEW_LINE mp [ suf ] = i NEW_LINE i -= 1 NEW_LINE DEDENT pre = 0 NEW_LINE maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre += a [ i ] NEW_LINE if ( mp [ pre ] > i ) : NEW_LINE INDENT if ( pre > maxi ) : NEW_LINE INDENT maxi = pre NEW_LINE DEDENT DEDENT DEDENT if ( maxi == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return maxi NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 3 , 2 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( sumFirst ( a , n ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4654_A", "sol": 0, "python_code": "MAX_CHAR = 256\ndef isPresent ( s , q ) :\n    freq = [ 0 ] * MAX_CHAR\n    for i in range ( 0 , len ( s ) ) :\n        freq [ ord ( s [ i ] ) ] += 1\n    for i in range ( 0 , len ( q ) ) :\n        freq [ ord ( q [ i ] ) ] -= 1\n        if ( freq [ ord ( q [ i ] ) ] < 0 ) :\n            return False\n    return True\ns = \"abctd\"\nq = \"cat\"\nif ( isPresent ( s , q ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "MAX_CHAR = 256 NEW_LINE def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE if ( freq [ ord ( q [ i ] ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = \" abctd \" NEW_LINE q = \" cat \" NEW_LINE if ( isPresent ( s , q ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1137_A", "sol": 0, "python_code": "def cal_speed ( dist , time ) :\n    print ( \" Distance(km) :\" , dist ) ;\n    print ( \" Time(hr) :\" , time ) ;\n    return dist / time ;\ndef cal_dis ( speed , time ) :\n    print ( \" Time(hr) :\" , time ) ;\n    print ( \" Speed(km / hr) :\" , speed ) ;\n    return speed * time ;\ndef cal_time ( dist , speed ) :\n    print ( \" Distance(km) :\" , dist ) ;\n    print ( \" Speed(km / hr) :\" , speed ) ;\n    return speed * dist ;\nprint ( \" The calculated Speed(km / hr) is :\" , cal_speed ( 45.9 , 2.0 ) ) ;\nprint ( \"\" ) ;\nprint ( \" The calculated Distance(km) :\" , cal_dis ( 62.9 , 2.5 ) ) ;\nprint ( \"\" ) ;\nprint ( \" The calculated Time(hr) :\" , cal_time ( 48.0 , 4.5 ) ) ;\n", "python_code_tokenized": "def cal_speed ( dist , time ) : NEW_LINE INDENT print ( \" \u2581 Distance ( km ) \u2581 : \" , dist ) ; NEW_LINE print ( \" \u2581 Time ( hr ) \u2581 : \" , time ) ; NEW_LINE return dist / time ; NEW_LINE DEDENT def cal_dis ( speed , time ) : NEW_LINE INDENT print ( \" \u2581 Time ( hr ) \u2581 : \" , time ) ; NEW_LINE print ( \" \u2581 Speed ( km \u2581 / \u2581 hr ) \u2581 : \" , speed ) ; NEW_LINE return speed * time ; NEW_LINE DEDENT def cal_time ( dist , speed ) : NEW_LINE INDENT print ( \" \u2581 Distance ( km ) \u2581 : \" , dist ) ; NEW_LINE print ( \" \u2581 Speed ( km \u2581 / \u2581 hr ) \u2581 : \" , speed ) ; NEW_LINE return speed * dist ; NEW_LINE DEDENT print ( \" \u2581 The \u2581 calculated \u2581 Speed ( km \u2581 / \u2581 hr ) \u2581 is \u2581 : \" , cal_speed ( 45.9 , 2.0 ) ) ; NEW_LINE print ( \" \" ) ; NEW_LINE print ( \" \u2581 The \u2581 calculated \u2581 Distance ( km ) \u2581 : \" , cal_dis ( 62.9 , 2.5 ) ) ; NEW_LINE print ( \" \" ) ; NEW_LINE print ( \" \u2581 The \u2581 calculated \u2581 Time ( hr ) \u2581 : \" , cal_time ( 48.0 , 4.5 ) ) ; NEW_LINE"}
{"id": "aizu_p00889_A", "sol": 0, "python_code": "from collections import defaultdict\ndef gen ( N , S , W ) :\n    g = S\n    for i in range ( N ) :\n        yield ( g // 7 ) % 10\n        if g % 2 == 0 :\n            g //= 2\n        else :\n            g = ( g // 2 ) ^ W\ndef solve ( ) :\n    N , S , W , Q = map ( int , input ( ).split ( ) )\n    if N == 0 :\n        return False\n    bs = list ( gen ( N , S , W ) )\n    ans = 0\n    if Q == 2 or Q == 5 :\n        cnt = 0\n        for i in range ( N ) :\n            b = bs [ i ]\n            if b != 0 :\n                cnt += 1\n            if b % Q == 0 :\n                ans += cnt\n    else :\n        rev10 = pow ( 10 , Q - 2 , Q )\n        D = defaultdict ( int )\n        D [ 0 ] = 1\n        s = 0 ; v = 1\n        first = 1\n        for i in range ( N ) :\n            b = bs [ i ]\n            if first and b == 0 :\n                continue\n            s = ( s + v * b ) % Q\n            v = v * rev10 % Q\n            ans += D [ s ]\n            if i < N - 1 and bs [ i + 1 ] != 0 :\n                D [ s ] += 1\n            first = 0\n    print ( ans )\n    return True\nwhile solve ( ) :\n   ...\n", "python_code_tokenized": "from collections import defaultdict NEW_LINE def gen ( N , S , W ) : NEW_LINE INDENT g = S NEW_LINE for i in range ( N ) : NEW_LINE INDENT yield ( g // 7 ) % 10 NEW_LINE if g % 2 == 0 : NEW_LINE INDENT g //= 2 NEW_LINE DEDENT else : NEW_LINE INDENT g = ( g // 2 ) ^ W NEW_LINE DEDENT DEDENT DEDENT def solve ( ) : NEW_LINE INDENT N , S , W , Q = map ( int , input ( ) . split ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT bs = list ( gen ( N , S , W ) ) NEW_LINE ans = 0 NEW_LINE if Q == 2 or Q == 5 : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT b = bs [ i ] NEW_LINE if b != 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if b % Q == 0 : NEW_LINE INDENT ans += cnt NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT rev10 = pow ( 10 , Q - 2 , Q ) NEW_LINE D = defaultdict ( int ) NEW_LINE D [ 0 ] = 1 NEW_LINE s = 0 ; v = 1 NEW_LINE first = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT b = bs [ i ] NEW_LINE if first and b == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT s = ( s + v * b ) % Q NEW_LINE v = v * rev10 % Q NEW_LINE ans += D [ s ] NEW_LINE if i < N - 1 and bs [ i + 1 ] != 0 : NEW_LINE INDENT D [ s ] += 1 NEW_LINE DEDENT first = 0 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE return True NEW_LINE DEDENT while solve ( ) : NEW_LINE INDENT ... NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5066_A", "sol": 0, "python_code": "def canBeBalanced ( s , n ) :\n    count = 0\n    count_1 = 0\n    for i in range ( n ) :\n        if ( s [ i ] == '(' ) :\n            count += 1\n        else :\n            count -= 1\n        count_1 = min ( count_1 , count )\n    if ( count_1 >= - 1 and count == 0 ) :\n        return True\n    return False\ns = \"())()(\"\nn = len ( s )\nif ( canBeBalanced ( s , n ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def canBeBalanced ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE count_1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT count_1 = min ( count_1 , count ) NEW_LINE DEDENT if ( count_1 >= - 1 and count == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT s = \" ( ) ) ( ) ( \" NEW_LINE n = len ( s ) NEW_LINE if ( canBeBalanced ( s , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "atcoder_ABC099_B", "sol": 0, "python_code": "a , b = map ( int , input ( ).split ( ) )\ndif = b - a\ndef hgt ( x ) :\n    return round ( ( x + 1 ) * x / 2 )\nprint ( hgt ( b - a ) - b )\n", "python_code_tokenized": "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE dif = b - a NEW_LINE def hgt ( x ) : NEW_LINE INDENT return round ( ( x + 1 ) * x / 2 ) NEW_LINE DEDENT print ( hgt ( b - a ) - b ) NEW_LINE"}
{"id": "geeksforgeeks_1487_A", "sol": 0, "python_code": "def getNumber ( n , k ) :\n    if ( n % 2 == 0 ) :\n        pos = n // 2 ;\n    else :\n        pos = ( n // 2 ) + 1 ;\n    if ( k <= pos ) :\n        return ( k * 2 - 1 ) ;\n    else :\n        return ( ( k - pos ) * 2 ) ;\nif __name__ == \"__main__\" :\n    n = 8 ; k = 5 ;\n    print ( getNumber ( n , k ) ) ;\n", "python_code_tokenized": "def getNumber ( n , k ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT pos = n // 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT pos = ( n // 2 ) + 1 ; NEW_LINE DEDENT if ( k <= pos ) : NEW_LINE INDENT return ( k * 2 - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( k - pos ) * 2 ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 8 ; k = 5 ; NEW_LINE print ( getNumber ( n , k ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_929_A", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nx = list ( map ( int , input ( ).split ( ) ) )\nc = 0\np = 0\nr = 0\nwhile c != n - 1 :\n    m = x [ c ] + k\n    i = c\n    while x [ i ] < m :\n        i += 1\n        if i == n :\n            break\n    if i == n :\n        c = i - 1\n        r += 1\n        break\n    if x [ i ] == m :\n        c = i\n    else :\n        c = i - 1\n    r += 1\n    if c == p :\n        break\n    else :\n        p = c\nif c == n - 1 :\n    print ( r )\nelse :\n    print ( - 1 )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE p = 0 NEW_LINE r = 0 NEW_LINE while c != n - 1 : NEW_LINE INDENT m = x [ c ] + k NEW_LINE i = c NEW_LINE while x [ i ] < m : NEW_LINE INDENT i += 1 NEW_LINE if i == n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == n : NEW_LINE INDENT c = i - 1 NEW_LINE r += 1 NEW_LINE break NEW_LINE DEDENT if x [ i ] == m : NEW_LINE INDENT c = i NEW_LINE DEDENT else : NEW_LINE INDENT c = i - 1 NEW_LINE DEDENT r += 1 NEW_LINE if c == p : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT p = c NEW_LINE DEDENT DEDENT if c == n - 1 : NEW_LINE INDENT print ( r ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4926_A", "sol": 0, "python_code": "def findCount ( str ) :\n    result = 0\n    for i in range ( len ( str ) ) :\n        if ( ( i == ord ( str [ i ] ) - ord ( 'a' ) ) or ( i == ord ( str [ i ] ) - ord ( 'A' ) ) ) :\n            result += 1\n    return result\nstr = 'AbgdeF'\nprint ( findCount ( str ) )\n", "python_code_tokenized": "def findCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ( i == ord ( str [ i ] ) - ord ( ' a ' ) ) or ( i == ord ( str [ i ] ) - ord ( ' A ' ) ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT str = ' AbgdeF ' NEW_LINE print ( findCount ( str ) ) NEW_LINE"}
{"id": "geeksforgeeks_4555_A", "sol": 0, "python_code": "mod = 1e9 + 7 ;\ndef ways ( i , arr , n ) :\n    if ( i == n - 1 ) :\n        return 1 ;\n    sum = 0 ;\n    for j in range ( 1 , arr [ i ] + 1 ) :\n        if ( i + j < n ) :\n            sum += ( ways ( i + j , arr , n ) ) % mod ;\n            sum %= mod ;\n    return int ( sum % mod ) ;\nif __name__ == '__main__' :\n    arr = [ 5 , 3 , 1 , 4 , 3 ] ;\n    n = len ( arr ) ;\n    print ( ways ( 0 , arr , n ) ) ;\n", "python_code_tokenized": "mod = 1e9 + 7 ; NEW_LINE def ways ( i , arr , n ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT sum += ( ways ( i + j , arr , n ) ) % mod ; NEW_LINE sum %= mod ; NEW_LINE DEDENT DEDENT return int ( sum % mod ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 1 , 4 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ways ( 0 , arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_366_B", "sol": 0, "python_code": "n , k = map ( int , input ( ).split ( ) )\nl = list ( map ( int , input ( ).split ( ) ) )\nmn = 10000000000\nidx = 0\nfor i in range ( k ) :\n    x = 0\n    for j in range ( i , n , k ) :\n        x += l [ j ]\n    if x < mn : idx = i ; mn = x\nprint ( idx + 1 )\n", "python_code_tokenized": "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mn = 10000000000 NEW_LINE idx = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT x = 0 NEW_LINE for j in range ( i , n , k ) : NEW_LINE INDENT x += l [ j ] NEW_LINE DEDENT if x < mn : idx = i ; mn = x NEW_LINE DEDENT print ( idx + 1 ) NEW_LINE"}
{"id": "aizu_p02255_A", "sol": 0, "python_code": "N = int ( input ( ) )\nl = list ( map ( int , input ( ).split ( ) ) )\nfor i in range ( N ) :\n    t = l [ i ]\n    j = i - 1\n    while j >= 0 and l [ j ] > t :\n        l [ j + 1 ] , l [ j ] = l [ j ] , l [ j + 1 ]\n        j -= 1\n    print ( * l )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = l [ i ] NEW_LINE j = i - 1 NEW_LINE while j >= 0 and l [ j ] > t : NEW_LINE INDENT l [ j + 1 ] , l [ j ] = l [ j ] , l [ j + 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT print ( * l ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2140_A", "sol": 0, "python_code": "def search ( mat , m , n , x ) :\n    i , j = m - 1 , 0\n    while ( i >= 0 and j < n ) :\n        if ( mat [ i ] [ j ] == x ) :\n            return True ;\n        if ( mat [ i ] [ j ] > x ) :\n            i -= 1\n        else :\n            j += 1\n    return False\nif __name__ == '__main__' :\n    mat = [ [ 10 , 20 , 30 , 40 ] , [ 15 , 25 , 35 , 45 ] , [ 27 , 29 , 37 , 48 ] , [ 32 , 33 , 39 , 50 ] , [ 50 , 60 , 70 , 80 ] ]\n    if ( search ( mat , 5 , 4 , 29 ) ) :\n        print ( \"Yes\" )\n    else :\n        print ( \"No\" )\n", "python_code_tokenized": "def search ( mat , m , n , x ) : NEW_LINE INDENT i , j = m - 1 , 0 NEW_LINE while ( i >= 0 and j < n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == x ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( mat [ i ] [ j ] > x ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 10 , 20 , 30 , 40 ] , [ 15 , 25 , 35 , 45 ] , [ 27 , 29 , 37 , 48 ] , [ 32 , 33 , 39 , 50 ] , [ 50 , 60 , 70 , 80 ] ] NEW_LINE if ( search ( mat , 5 , 4 , 29 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_1340_A", "sol": 0, "python_code": "def isPossible ( x , y ) :\n    if ( ( x - y ) == 1 ) :\n        return False\n    return True\nx = 100\ny = 98\nif ( isPossible ( x , y ) ) :\n    print ( \"Yes\" )\nelse :\n    print ( \"No\" )\n", "python_code_tokenized": "def isPossible ( x , y ) : NEW_LINE INDENT if ( ( x - y ) == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT x = 100 NEW_LINE y = 98 NEW_LINE if ( isPossible ( x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_66_A", "sol": 0, "python_code": "import numpy as np\nimport sys\nINT_MIN = - ( sys.maxsize - 1 )\ndef maxSum ( a , n ) :\n    sum = 0 ;\n    for i in range ( n ) :\n        sum += a [ i ] ;\n    limit = 2 * sum + 1 ;\n    dp = np.zeros ( ( n + 1 , limit ) ) ;\n    for i in range ( n + 1 ) :\n        for j in range ( limit ) :\n            dp [ i ] [ j ] = INT_MIN ;\n    dp [ 0 ] [ sum ] = 0 ;\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( limit ) :\n            if ( ( j - a [ i - 1 ] ) >= 0 and dp [ i - 1 ] [ j - a [ i - 1 ] ] != INT_MIN ) :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ;\n            if ( ( j + a [ i - 1 ] ) < limit and dp [ i - 1 ] [ j + a [ i - 1 ] ] != INT_MIN ) :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ;\n            if ( dp [ i - 1 ] [ j ] != INT_MIN ) :\n                dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ;\n    return dp [ n ] [ sum ] ;\nif __name__ == \"__main__\" :\n    n = 4 ;\n    a = [ 1 , 2 , 3 , 6 ] ;\n    print ( maxSum ( a , n ) ) ;\n", "python_code_tokenized": "import numpy as np NEW_LINE import sys NEW_LINE INT_MIN = - ( sys . maxsize - 1 ) NEW_LINE def maxSum ( a , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT limit = 2 * sum + 1 ; NEW_LINE dp = np . zeros ( ( n + 1 , limit ) ) ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( limit ) : NEW_LINE INDENT dp [ i ] [ j ] = INT_MIN ; NEW_LINE DEDENT DEDENT dp [ 0 ] [ sum ] = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( limit ) : NEW_LINE INDENT if ( ( j - a [ i - 1 ] ) >= 0 and dp [ i - 1 ] [ j - a [ i - 1 ] ] != INT_MIN ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ; NEW_LINE DEDENT if ( ( j + a [ i - 1 ] ) < limit and dp [ i - 1 ] [ j + a [ i - 1 ] ] != INT_MIN ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ; NEW_LINE DEDENT if ( dp [ i - 1 ] [ j ] != INT_MIN ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ sum ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE a = [ 1 , 2 , 3 , 6 ] ; NEW_LINE print ( maxSum ( a , n ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5124_A", "sol": 0, "python_code": "def smallestIndexsum ( arr , n ) :\n    i = n - 1 ;\n    while ( i >= 0 and arr [ i ] % 2 == 1 ) :\n        i -= 1 ;\n    sum = 0 ;\n    for j in range ( 0 , i + 1 ) :\n        sum += arr [ j ] ;\n    return sum ;\nif __name__ == '__main__' :\n    arr = [ 2 , 3 , 5 , 6 , 3 , 3 ] ;\n    n = len ( arr ) ;\n    print ( smallestIndexsum ( arr , n ) ) ;\n", "python_code_tokenized": "def smallestIndexsum ( arr , n ) : NEW_LINE INDENT i = n - 1 ; NEW_LINE while ( i >= 0 and arr [ i ] % 2 == 1 ) : NEW_LINE INDENT i -= 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for j in range ( 0 , i + 1 ) : NEW_LINE INDENT sum += arr [ j ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 6 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( smallestIndexsum ( arr , n ) ) ; NEW_LINE DEDENT"}
{"id": "codeforces_794_B", "sol": 0, "python_code": "n , h = map ( int , input ( ).split ( ) )\nans = [ ]\nfor i in range ( 1 , n ) :\n    ans.append ( h * ( ( i / n ) ** 0.5 ) )\nprint ( * ans )\n", "python_code_tokenized": "n , h = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans . append ( h * ( ( i / n ) ** 0.5 ) ) NEW_LINE DEDENT print ( * ans ) NEW_LINE"}
{"id": "atcoder_ABC134_D", "sol": 0, "python_code": "import sys\nfrom collections import deque , defaultdict\nfrom math import sqrt , factorial , gcd , ceil , atan , pi\ndef input ( ) : return sys.stdin.readline ( ) [ : - 1 ]\nimport string\nfrom bisect import bisect_left , bisect_right\nfrom functools import lru_cache\nMOD = int ( 1e9 ) + 7\nINF = float ( 'inf' )\ndef solve ( ) :\n    n = int ( input ( ) )\n    a = [ int ( x ) for x in input ( ).split ( ) ]\n    xd = [ 0 ] * n\n    ans = [ ]\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        cnt = 0\n        for j in range ( i , n , i + 1 ) :\n            cnt += xd [ j ]\n        cnt %= 2\n        if cnt != a [ i ] :\n            ans.append ( i + 1 )\n            xd [ i ] = 1\n    ans.reverse ( )\n    print ( len ( ans ) )\n    if ans :\n        print ( * ans )\nt = 1\nfor case in range ( 1 , t + 1 ) :\n    ans = solve ( )\n", "python_code_tokenized": "import sys NEW_LINE from collections import deque , defaultdict NEW_LINE from math import sqrt , factorial , gcd , ceil , atan , pi NEW_LINE def input ( ) : return sys . stdin . readline ( ) [ : - 1 ] NEW_LINE import string NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE from functools import lru_cache NEW_LINE MOD = int ( 1e9 ) + 7 NEW_LINE INF = float ( ' inf ' ) NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE xd = [ 0 ] * n NEW_LINE ans = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( i , n , i + 1 ) : NEW_LINE INDENT cnt += xd [ j ] NEW_LINE DEDENT cnt %= 2 NEW_LINE if cnt != a [ i ] : NEW_LINE INDENT ans . append ( i + 1 ) NEW_LINE xd [ i ] = 1 NEW_LINE DEDENT DEDENT ans . reverse ( ) NEW_LINE print ( len ( ans ) ) NEW_LINE if ans : NEW_LINE INDENT print ( * ans ) NEW_LINE DEDENT DEDENT t = 1 NEW_LINE for case in range ( 1 , t + 1 ) : NEW_LINE INDENT ans = solve ( ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_327_A", "sol": 0, "python_code": "def CountSubSet ( arr , n , X ) :\n    N = 2 ** n ;\n    count = 0 ;\n    for i in range ( N ) :\n        for j in range ( n ) :\n            if ( i & ( 1 << j ) ) :\n                if ( arr [ j ] == X ) :\n                    count += 1 ;\n    return count ;\nif __name__ == \"__main__\" :\n    arr = [ 4 , 5 , 6 , 7 ] ;\n    X = 5 ;\n    n = len ( arr ) ;\n    print ( CountSubSet ( arr , n , X ) ) ;\n", "python_code_tokenized": "def CountSubSet ( arr , n , X ) : NEW_LINE INDENT N = 2 ** n ; NEW_LINE count = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT if ( arr [ j ] == X ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 5 , 6 , 7 ] ; NEW_LINE X = 5 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( CountSubSet ( arr , n , X ) ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_909_A", "sol": 0, "python_code": "def two_factor ( n ) :\n    twocount = 0\n    while n % 2 == 0 :\n        twocount += 1\n        n = int ( n / 2 )\n    return twocount\ndef five_factor ( n ) :\n    fivecount = 0\n    while n % 5 == 0 :\n        fivecount += 1\n        n = int ( n / 5 )\n    return fivecount\ndef find_con_zero ( arr , n ) :\n    twocount = 0\n    fivecount = 0\n    for i in range ( n ) :\n        twocount += two_factor ( arr [ i ] )\n        fivecount += five_factor ( arr [ i ] )\n    if twocount < fivecount :\n        return twocount\n    else :\n        return fivecount\narr = [ 100 , 10 , 5 , 25 , 35 , 14 ]\nn = 6\nprint ( find_con_zero ( arr , n ) )\n", "python_code_tokenized": "def two_factor ( n ) : NEW_LINE INDENT twocount = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT twocount += 1 NEW_LINE n = int ( n / 2 ) NEW_LINE DEDENT return twocount NEW_LINE DEDENT def five_factor ( n ) : NEW_LINE INDENT fivecount = 0 NEW_LINE while n % 5 == 0 : NEW_LINE INDENT fivecount += 1 NEW_LINE n = int ( n / 5 ) NEW_LINE DEDENT return fivecount NEW_LINE DEDENT def find_con_zero ( arr , n ) : NEW_LINE INDENT twocount = 0 NEW_LINE fivecount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twocount += two_factor ( arr [ i ] ) NEW_LINE fivecount += five_factor ( arr [ i ] ) NEW_LINE DEDENT if twocount < fivecount : NEW_LINE INDENT return twocount NEW_LINE DEDENT else : NEW_LINE INDENT return fivecount NEW_LINE DEDENT DEDENT arr = [ 100 , 10 , 5 , 25 , 35 , 14 ] NEW_LINE n = 6 NEW_LINE print ( find_con_zero ( arr , n ) ) NEW_LINE"}
{"id": "atcoder_ABC063_C", "sol": 0, "python_code": "N = int ( input ( ) )\nS = [ int ( input ( ) ) for _ in range ( N ) ]\nS.sort ( )\nans = sum ( S )\nfor s in S :\n    if ans % 10 == 0 :\n        if s % 10 != 0 :\n            ans -= s\n            break\n        elif s == S [ - 1 ] :\n            ans = 0\n    else :\n        break\nprint ( ans )\n", "python_code_tokenized": "N = int ( input ( ) ) NEW_LINE S = [ int ( input ( ) ) for _ in range ( N ) ] NEW_LINE S . sort ( ) NEW_LINE ans = sum ( S ) NEW_LINE for s in S : NEW_LINE INDENT if ans % 10 == 0 : NEW_LINE INDENT if s % 10 != 0 : NEW_LINE INDENT ans -= s NEW_LINE break NEW_LINE DEDENT elif s == S [ - 1 ] : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"}
{"id": "aizu_p01268_A", "sol": 0, "python_code": "sieve = [ True ] * 110000\nprimes = [ ]\nfor i in range ( 2 , 110000 ) :\n    if sieve [ i ] == True :\n        primes.append ( i )\n        for j in range ( 2 * i , 110000 , i ) :\n            sieve [ j ] = False\nwhile True :\n    n , p = map ( int , input ( ).split ( ) )\n    if n == - 1 and p == - 1 : break\n    cnt = 0\n    for i in primes :\n        if n < i :\n            break\n        else :\n            cnt += 1\n    psum = sorted ( [ primes [ i ] + primes [ j ] for j in range ( cnt , cnt + p ) for i in range ( j , cnt + p ) ] )\n    print ( psum [ p - 1 ] )\n", "python_code_tokenized": "sieve = [ True ] * 110000 NEW_LINE primes = [ ] NEW_LINE for i in range ( 2 , 110000 ) : NEW_LINE INDENT if sieve [ i ] == True : NEW_LINE INDENT primes . append ( i ) NEW_LINE for j in range ( 2 * i , 110000 , i ) : NEW_LINE INDENT sieve [ j ] = False NEW_LINE DEDENT DEDENT DEDENT while True : NEW_LINE INDENT n , p = map ( int , input ( ) . split ( ) ) NEW_LINE if n == - 1 and p == - 1 : break NEW_LINE cnt = 0 NEW_LINE for i in primes : NEW_LINE INDENT if n < i : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT psum = sorted ( [ primes [ i ] + primes [ j ] for j in range ( cnt , cnt + p ) for i in range ( j , cnt + p ) ] ) NEW_LINE print ( psum [ p - 1 ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_5041_A", "sol": 0, "python_code": "def makePermutation ( a , n ) :\n    count = dict ( )\n    for i in range ( n ) :\n        if count.get ( a [ i ] ) :\n            count [ a [ i ] ] += 1\n        else :\n            count [ a [ i ] ] = 1 ;\n    next_missing = 1\n    for i in range ( n ) :\n        if count [ a [ i ] ] != 1 or a [ i ] > n or a [ i ] < 1 :\n            count [ a [ i ] ] -= 1\n            while count.get ( next_missing ) :\n                next_missing += 1\n            a [ i ] = next_missing\n            count [ next_missing ] = 1\nA = [ 2 , 2 , 3 , 3 ]\nn = len ( A )\nmakePermutation ( A , n )\nfor i in range ( n ) :\n    print ( A [ i ] , end = \" \" )\n", "python_code_tokenized": "def makePermutation ( a , n ) : NEW_LINE INDENT count = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count . get ( a [ i ] ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ a [ i ] ] = 1 ; NEW_LINE DEDENT DEDENT next_missing = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count [ a [ i ] ] != 1 or a [ i ] > n or a [ i ] < 1 : NEW_LINE INDENT count [ a [ i ] ] -= 1 NEW_LINE while count . get ( next_missing ) : NEW_LINE INDENT next_missing += 1 NEW_LINE DEDENT a [ i ] = next_missing NEW_LINE count [ next_missing ] = 1 NEW_LINE DEDENT DEDENT DEDENT A = [ 2 , 2 , 3 , 3 ] NEW_LINE n = len ( A ) NEW_LINE makePermutation ( A , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( A [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_3973_A", "sol": 0, "python_code": "def printTwoOdd ( arr , size ) :\n    xor2 = arr [ 0 ]\n    set_bit_no = 0\n    n = size - 2\n    x , y = 0 , 0\n    for i in range ( 1 , size ) :\n        xor2 = xor2 ^ arr [ i ]\n    set_bit_no = xor2 & ~ ( xor2 - 1 )\n    for i in range ( size ) :\n        if ( arr [ i ] & set_bit_no ) :\n            x = x ^ arr [ i ]\n        else :\n            y = y ^ arr [ i ]\n    print ( \"The two ODD elements are\" , x , \"&\" , y )\narr = [ 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 ]\narr_size = len ( arr )\nprintTwoOdd ( arr , arr_size )\n", "python_code_tokenized": "def printTwoOdd ( arr , size ) : NEW_LINE INDENT xor2 = arr [ 0 ] NEW_LINE set_bit_no = 0 NEW_LINE n = size - 2 NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor2 ^ arr [ i ] NEW_LINE DEDENT set_bit_no = xor2 & ~ ( xor2 - 1 ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( \" The \u2581 two \u2581 ODD \u2581 elements \u2581 are \" , x , \" & \" , y ) NEW_LINE DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printTwoOdd ( arr , arr_size ) NEW_LINE"}
{"id": "aizu_p00848_A", "sol": 0, "python_code": "p = [ ]\nfor i in range ( 2 , 1121 ) :\n    for j in range ( 2 , int ( i ** 0.5 ) + 1 ) :\n        if not i % j : break\n    else : p += [ i ]\ndp = [ [ 0 ] * 1121 for _ in range ( 15 ) ]\ndp [ 0 ] [ 0 ] = 1\nfor x , y in enumerate ( p ) :\n    for i in range ( min ( x + 1 , 14 ) , 0 , - 1 ) :\n        for j in range ( y , 1121 ) :\n            dp [ i ] [ j ] += dp [ i - 1 ] [ j - y ]\nwhile 1 :\n    n , k = map ( int , input ( ).split ( ) )\n    if n == 0 : break\n    print ( dp [ k ] [ n ] )\n", "python_code_tokenized": "p = [ ] NEW_LINE for i in range ( 2 , 1121 ) : NEW_LINE INDENT for j in range ( 2 , int ( i ** 0.5 ) + 1 ) : NEW_LINE INDENT if not i % j : break NEW_LINE DEDENT else : p += [ i ] NEW_LINE DEDENT dp = [ [ 0 ] * 1121 for _ in range ( 15 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for x , y in enumerate ( p ) : NEW_LINE INDENT for i in range ( min ( x + 1 , 14 ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( y , 1121 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j - y ] NEW_LINE DEDENT DEDENT DEDENT while 1 : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE print ( dp [ k ] [ n ] ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_1787_A", "sol": 0, "python_code": "from math import floor , ceil , log2\ndef powOfPositive ( n ) :\n    pos = floor ( log2 ( n ) ) ;\n    return 2 ** pos ;\ndef powOfNegative ( n ) :\n    pos = ceil ( log2 ( n ) ) ;\n    return ( - 1 * pow ( 2 , pos ) ) ;\ndef highestPowerOf2 ( n ) :\n    if ( n > 0 ) :\n        print ( powOfPositive ( n ) ) ;\n    else :\n        n = - n ;\n        print ( powOfNegative ( n ) ) ;\nif __name__ == \"__main__\" :\n    n = - 24 ;\n    highestPowerOf2 ( n ) ;\n", "python_code_tokenized": "from math import floor , ceil , log2 NEW_LINE def powOfPositive ( n ) : NEW_LINE INDENT pos = floor ( log2 ( n ) ) ; NEW_LINE return 2 ** pos ; NEW_LINE DEDENT def powOfNegative ( n ) : NEW_LINE INDENT pos = ceil ( log2 ( n ) ) ; NEW_LINE return ( - 1 * pow ( 2 , pos ) ) ; NEW_LINE DEDENT def highestPowerOf2 ( n ) : NEW_LINE INDENT if ( n > 0 ) : NEW_LINE INDENT print ( powOfPositive ( n ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT n = - n ; NEW_LINE print ( powOfNegative ( n ) ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = - 24 ; NEW_LINE highestPowerOf2 ( n ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_634_A", "sol": 0, "python_code": "import numpy as np\nn = 6 ; m = 6 ;\ndef maxSum ( arr ) :\n    dp = np.zeros ( ( n + 1 , 3 ) ) ;\n    for i in range ( n ) :\n        m1 = 0 ; m2 = 0 ; m3 = 0 ;\n        for j in range ( m ) :\n            if ( ( j // ( m // 3 ) ) == 0 ) :\n                m1 = max ( m1 , arr [ i ] [ j ] ) ;\n            elif ( ( j // ( m // 3 ) ) == 1 ) :\n                m2 = max ( m2 , arr [ i ] [ j ] ) ;\n            elif ( ( j // ( m // 3 ) ) == 2 ) :\n                m3 = max ( m3 , arr [ i ] [ j ] ) ;\n        dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ;\n        dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ;\n        dp [ i + 1 ] [ 2 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ;\n    print ( max ( max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) ) ;\nif __name__ == \"__main__\" :\n    arr = [ [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] ] ;\n    maxSum ( arr ) ;\n", "python_code_tokenized": "import numpy as np NEW_LINE n = 6 ; m = 6 ; NEW_LINE def maxSum ( arr ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , 3 ) ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m1 = 0 ; m2 = 0 ; m3 = 0 ; NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( ( j // ( m // 3 ) ) == 0 ) : NEW_LINE INDENT m1 = max ( m1 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT elif ( ( j // ( m // 3 ) ) == 1 ) : NEW_LINE INDENT m2 = max ( m2 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT elif ( ( j // ( m // 3 ) ) == 2 ) : NEW_LINE INDENT m3 = max ( m3 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT DEDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; NEW_LINE dp [ i + 1 ] [ 2 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; NEW_LINE DEDENT print ( max ( max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] ] ; NEW_LINE maxSum ( arr ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2060_A", "sol": 0, "python_code": "import math\ndef numberOfMinutes ( S , S1 ) :\n    Min = 0 ;\n    Min = ( ( S - S1 ) / math.floor ( S ) ) * 60 ;\n    return int ( Min ) ;\nif __name__ == '__main__' :\n    S , S1 = 30 , 10 ;\n    print ( numberOfMinutes ( S , S1 ) , \"min\" ) ;\n", "python_code_tokenized": "import math NEW_LINE def numberOfMinutes ( S , S1 ) : NEW_LINE INDENT Min = 0 ; NEW_LINE Min = ( ( S - S1 ) / math . floor ( S ) ) * 60 ; NEW_LINE return int ( Min ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S , S1 = 30 , 10 ; NEW_LINE print ( numberOfMinutes ( S , S1 ) , \" min \" ) ; NEW_LINE DEDENT"}
{"id": "geeksforgeeks_2987_A", "sol": 0, "python_code": "def factorial ( start , end ) :\n    res = 1\n    for i in range ( start , end + 1 ) :\n        res *= i\n    return res\ndef sumofsquare ( n ) :\n    return int ( factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) )\nn = 4\nprint ( sumofsquare ( n ) )\n", "python_code_tokenized": "def factorial ( start , end ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT def sumofsquare ( n ) : NEW_LINE INDENT return int ( factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) ) NEW_LINE DEDENT n = 4 NEW_LINE print ( sumofsquare ( n ) ) NEW_LINE"}
{"id": "geeksforgeeks_3643_A", "sol": 0, "python_code": "from math import *\ndef findRadiusOfcircumcircle ( n , a ) :\n    if n < 0 or a < 0 :\n        return - 1\n    radius = a / sqrt ( 2 - ( 2 * cos ( 360 / n ) ) )\n    return radius\nif __name__ == \"__main__\" :\n    n , a = 5 , 6\n    print ( round ( findRadiusOfcircumcircle ( n , a ) , 5 ) )\n", "python_code_tokenized": "from math import * NEW_LINE def findRadiusOfcircumcircle ( n , a ) : NEW_LINE INDENT if n < 0 or a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT radius = a / sqrt ( 2 - ( 2 * cos ( 360 / n ) ) ) NEW_LINE return radius NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , a = 5 , 6 NEW_LINE print ( round ( findRadiusOfcircumcircle ( n , a ) , 5 ) ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4507_A", "sol": 0, "python_code": "def snoob ( x ) :\n    next = 0\n    if ( x ) :\n        rightOne = x & - ( x )\n        nextHigherOneBit = x + int ( rightOne )\n        rightOnesPattern = x ^ int ( nextHigherOneBit )\n        rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) )\n        rightOnesPattern = int ( rightOnesPattern ) >> 2\n        next = nextHigherOneBit | rightOnesPattern\n    return next\nx = 156\nprint ( \"Next higher number with \" + \"same number of set bits is\" , snoob ( x ) )\n", "python_code_tokenized": "def snoob ( x ) : NEW_LINE INDENT next = 0 NEW_LINE if ( x ) : NEW_LINE INDENT rightOne = x & - ( x ) NEW_LINE nextHigherOneBit = x + int ( rightOne ) NEW_LINE rightOnesPattern = x ^ int ( nextHigherOneBit ) NEW_LINE rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) ) NEW_LINE rightOnesPattern = int ( rightOnesPattern ) >> 2 NEW_LINE next = nextHigherOneBit | rightOnesPattern NEW_LINE DEDENT return next NEW_LINE DEDENT x = 156 NEW_LINE print ( \" Next \u2581 higher \u2581 number \u2581 with \u2581 \" + \" same \u2581 number \u2581 of \u2581 set \u2581 bits \u2581 is \" , snoob ( x ) ) NEW_LINE"}
{"id": "aizu_p00685_A", "sol": 0, "python_code": "def combi ( k ) :\n    global ans\n    if k == 9 :\n        ans += 1\n        return\n    for y in range ( 4 ) :\n        for x in range ( 4 ) :\n            if arr [ y ] [ x ] : continue\n            arr [ y ] [ x ] = k\n            for i in range ( 4 ) :\n                x2 , y2 = x + a [ i << 1 ] , y + a [ ( i << 1 ) + 1 ]\n                if x2 < 0 or x2 >= 4 or y2 < 0 or y2 >= 4 or arr [ y2 ] [ x2 ] : continue\n                arr [ y2 ] [ x2 ] = k\n                combi ( k + 1 )\n                arr [ y2 ] [ x2 ] = 0\n            arr [ y ] [ x ] = 0\n            return ;\nwhile True :\n    a = list ( map ( int , input ( ).split ( ) ) )\n    if len ( a ) == 1 : break\n    arr = [ [ 0 for i in range ( 4 ) ] for j in range ( 4 ) ]\n    ans = 0\n    arr [ 0 ] [ 0 ] = 1\n    for i in range ( 4 ) :\n        x , y = a [ i << 1 ] , a [ ( i << 1 ) + 1 ]\n        if x >= 0 and y >= 0 :\n            arr [ y ] [ x ] = 1\n            combi ( 2 )\n            arr [ y ] [ x ] = 0\n    print ( ans )\n", "python_code_tokenized": "def combi ( k ) : NEW_LINE INDENT global ans NEW_LINE if k == 9 : NEW_LINE INDENT ans += 1 NEW_LINE return NEW_LINE DEDENT for y in range ( 4 ) : NEW_LINE INDENT for x in range ( 4 ) : NEW_LINE INDENT if arr [ y ] [ x ] : continue NEW_LINE arr [ y ] [ x ] = k NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT x2 , y2 = x + a [ i << 1 ] , y + a [ ( i << 1 ) + 1 ] NEW_LINE if x2 < 0 or x2 >= 4 or y2 < 0 or y2 >= 4 or arr [ y2 ] [ x2 ] : continue NEW_LINE arr [ y2 ] [ x2 ] = k NEW_LINE combi ( k + 1 ) NEW_LINE arr [ y2 ] [ x2 ] = 0 NEW_LINE DEDENT arr [ y ] [ x ] = 0 NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT while True : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if len ( a ) == 1 : break NEW_LINE arr = [ [ 0 for i in range ( 4 ) ] for j in range ( 4 ) ] NEW_LINE ans = 0 NEW_LINE arr [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT x , y = a [ i << 1 ] , a [ ( i << 1 ) + 1 ] NEW_LINE if x >= 0 and y >= 0 : NEW_LINE INDENT arr [ y ] [ x ] = 1 NEW_LINE combi ( 2 ) NEW_LINE arr [ y ] [ x ] = 0 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"}
{"id": "codeforces_1662_A", "sol": 0, "python_code": "def pr ( x ) :\n    pass\nt = int ( input ( ) )\nfor i in range ( t ) :\n    n = int ( input ( ) )\n    pr ( \"probl\u00e8me {}: {} probl\u00e8mes\".format ( i + 1 , n ) )\n    B = [ 0 ] * 11\n    for k in range ( n ) :\n        s = input ( )\n        b , d = tuple ( int ( x ) for x in s.split ( ) )\n        B [ d ] = max ( B [ d ] , b )\n    pr ( \"B = {}\".format ( B ) )\n    if any ( B [ d ] == 0 for d in range ( 1 , 11 ) ) :\n        print ( \"MOREPROBLEMS\" )\n    else :\n        print ( sum ( B [ d ] for d in range ( 1 , 11 ) ) )\n", "python_code_tokenized": "def pr ( x ) : NEW_LINE INDENT pass NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE pr ( \" probl\u00e8me \u2581 { } : \u2581 { } \u2581 probl\u00e8mes \" . format ( i + 1 , n ) ) NEW_LINE B = [ 0 ] * 11 NEW_LINE for k in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE b , d = tuple ( int ( x ) for x in s . split ( ) ) NEW_LINE B [ d ] = max ( B [ d ] , b ) NEW_LINE DEDENT pr ( \" B \u2581 = \u2581 { } \" . format ( B ) ) NEW_LINE if any ( B [ d ] == 0 for d in range ( 1 , 11 ) ) : NEW_LINE INDENT print ( \" MOREPROBLEMS \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sum ( B [ d ] for d in range ( 1 , 11 ) ) ) NEW_LINE DEDENT DEDENT"}
{"id": "codeforces_1716_B", "sol": 0, "python_code": "t = int ( input ( ) )\nfor i in range ( t ) :\n    n = int ( input ( ) )\n    l = [ ]\n    for i in range ( n ) :\n        l.append ( i + 1 )\n    print ( n )\n    c = 0\n    i = 0\n    while i < n :\n        if i != 0 :\n            l [ c ] , l [ c + 1 ] = l [ c + 1 ] , l [ c ]\n            c += 1\n        for each in l :\n            print ( each , end = ' ' )\n        i += 1\n        print ( )\n", "python_code_tokenized": "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE DEDENT print ( n ) NEW_LINE c = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT l [ c ] , l [ c + 1 ] = l [ c + 1 ] , l [ c ] NEW_LINE c += 1 NEW_LINE DEDENT for each in l : NEW_LINE INDENT print ( each , end = ' \u2581 ' ) NEW_LINE DEDENT i += 1 NEW_LINE print ( ) NEW_LINE DEDENT DEDENT"}
{"id": "geeksforgeeks_2427_A", "sol": 0, "python_code": "from math import ceil , floor\ndef sum ( N , X , Y ) :\n    S1 = floor ( floor ( N / X ) * floor ( 2 * X + floor ( N / X - 1 ) * X ) / 2 )\n    S2 = floor ( floor ( N / Y ) ) * floor ( 2 * Y + floor ( N / Y - 1 ) * Y ) / 2\n    S3 = floor ( floor ( N / ( X * Y ) ) ) * floor ( 2 * ( X * Y ) + floor ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2\n    return S1 + S2 - S3\nif __name__ == '__main__' :\n    N = 14\n    X = 3\n    Y = 5\n    print ( int ( sum ( N , X , Y ) ) )\n", "python_code_tokenized": "from math import ceil , floor NEW_LINE def sum ( N , X , Y ) : NEW_LINE INDENT S1 = floor ( floor ( N / X ) * floor ( 2 * X + floor ( N / X - 1 ) * X ) / 2 ) NEW_LINE S2 = floor ( floor ( N / Y ) ) * floor ( 2 * Y + floor ( N / Y - 1 ) * Y ) / 2 NEW_LINE S3 = floor ( floor ( N / ( X * Y ) ) ) * floor ( 2 * ( X * Y ) + floor ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 NEW_LINE return S1 + S2 - S3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 14 NEW_LINE X = 3 NEW_LINE Y = 5 NEW_LINE print ( int ( sum ( N , X , Y ) ) ) NEW_LINE DEDENT"}
{"id": "codeforces_612_B", "sol": 0, "python_code": "n = int ( input ( ) )\na = list ( map ( int , input ( ).split ( ) ) )\nb = [ 0 ] * n\nfor i in range ( n ) :\n    b [ a [ i ] - 1 ] = i\nres = 0\nfor i in range ( 1 , n ) :\n    res += abs ( b [ i ] - b [ i - 1 ] )\nprint ( res )\n", "python_code_tokenized": "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ a [ i ] - 1 ] = i NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res += abs ( b [ i ] - b [ i - 1 ] ) NEW_LINE DEDENT print ( res ) NEW_LINE"}
{"id": "codeforces_137_A", "sol": 0, "python_code": "s = input ( )\nprint ( sum ( [ ( len ( i ) + 4 ) // 5 for i in ( s.split ( 'C' ) + s.split ( 'P' ) ) ] ) )\n", "python_code_tokenized": "s = input ( ) NEW_LINE print ( sum ( [ ( len ( i ) + 4 ) // 5 for i in ( s . split ( ' C ' ) + s . split ( ' P ' ) ) ] ) ) NEW_LINE"}
{"id": "geeksforgeeks_737_A", "sol": 0, "python_code": "def isSubsetAndZero ( array , length , N ) :\n    arrAnd = array [ 0 ]\n    for i in range ( 1 , length ) :\n        arrAnd = arrAnd & array [ i ]\n    if ( ( arrAnd & N ) == 0 ) :\n        print ( \"YES\" )\n    else :\n        print ( \"NO\" )\nif __name__ == \"__main__\" :\n    array = [ 1 , 2 , 4 ]\n    length = len ( array )\n    N = 3\n    isSubsetAndZero ( array , length , N )\n", "python_code_tokenized": "def isSubsetAndZero ( array , length , N ) : NEW_LINE INDENT arrAnd = array [ 0 ] NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT arrAnd = arrAnd & array [ i ] NEW_LINE DEDENT if ( ( arrAnd & N ) == 0 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT array = [ 1 , 2 , 4 ] NEW_LINE length = len ( array ) NEW_LINE N = 3 NEW_LINE isSubsetAndZero ( array , length , N ) NEW_LINE DEDENT"}
{"id": "codeforces_1277_A", "sol": 0, "python_code": "from ast import Pow\nfrom cmath import *\nfrom decimal import *\nfrom operator import index\nfrom re import I\nimport sys\nfrom tkinter import N\ninput_ = sys.stdin.readline\ndef _input ( ) : return map ( int , input ( ).split ( ) )\ndef _list ( ) : return list ( map ( int , input ( ).split ( ) ) )\ndef solves ( ) :\n    n = input ( )\n    if ( int ( n ) < 10 ) :\n        print ( n )\n    else :\n        ans = ( len ( n ) - 1 ) * 9\n        if int ( '9' * len ( n ) ) == int ( n ) :\n            ans += 9\n        elif int ( '8' * len ( n ) ) <= int ( n ) :\n            ans += 8\n        elif int ( '7' * len ( n ) ) <= int ( n ) :\n            ans += 7\n        elif int ( '6' * len ( n ) ) <= int ( n ) :\n            ans += 6\n        elif int ( '5' * len ( n ) ) <= int ( n ) :\n            ans += 5\n        elif int ( '4' * len ( n ) ) <= int ( n ) :\n            ans += 4\n        elif int ( '3' * len ( n ) ) <= int ( n ) :\n            ans += 3\n        elif int ( '2' * len ( n ) ) <= int ( n ) :\n            ans += 2\n        elif int ( '1' * len ( n ) ) <= int ( n ) :\n            ans += 1\n        print ( ans )\nt = 1\nt = int ( input ( ) )\nfor _ in range ( 0 , t ) :\n    solves ( )\n", "python_code_tokenized": "from ast import Pow NEW_LINE from cmath import * NEW_LINE from decimal import * NEW_LINE from operator import index NEW_LINE from re import I NEW_LINE import sys NEW_LINE from tkinter import N NEW_LINE input_ = sys . stdin . readline NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def _list ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def solves ( ) : NEW_LINE INDENT n = input ( ) NEW_LINE if ( int ( n ) < 10 ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( len ( n ) - 1 ) * 9 NEW_LINE if int ( '9' * len ( n ) ) == int ( n ) : NEW_LINE INDENT ans += 9 NEW_LINE DEDENT elif int ( '8' * len ( n ) ) <= int ( n ) : NEW_LINE INDENT ans += 8 NEW_LINE DEDENT elif int ( '7' * len ( n ) ) <= int ( n ) : NEW_LINE INDENT ans += 7 NEW_LINE DEDENT elif int ( '6' * len ( n ) ) <= int ( n ) : NEW_LINE INDENT ans += 6 NEW_LINE DEDENT elif int ( '5' * len ( n ) ) <= int ( n ) : NEW_LINE INDENT ans += 5 NEW_LINE DEDENT elif int ( '4' * len ( n ) ) <= int ( n ) : NEW_LINE INDENT ans += 4 NEW_LINE DEDENT elif int ( '3' * len ( n ) ) <= int ( n ) : NEW_LINE INDENT ans += 3 NEW_LINE DEDENT elif int ( '2' * len ( n ) ) <= int ( n ) : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT elif int ( '1' * len ( n ) ) <= int ( n ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT t = 1 NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( 0 , t ) : NEW_LINE INDENT solves ( ) NEW_LINE DEDENT"}
{"id": "aizu_p02278_A", "sol": 0, "python_code": "def MCS ( A , n ) :\n    B = sorted ( A )\n    B0 = B [ 0 ]\n    cost = 0\n    for i in range ( n - 1 ) :\n        Bi , t_cost , count = B [ i ] , 0 , 0\n        si = A.index ( Bi )\n        while si != i :\n            bsi = B [ si ]\n            sj = A.index ( bsi )\n            A [ si ] , A [ sj ] = bsi , Bi\n            t_cost += Bi + bsi\n            count += 1\n            si = sj\n        if count :\n            cost += min ( t_cost , ( Bi + B0 ) * 2 + t_cost - ( Bi - B0 ) * count )\n    print ( cost )\nif __name__ == \"__main__\" :\n    n = int ( input ( ) )\n    A = input ( ).split ( \" \" )\n    for i in range ( n ) :\n        A [ i ] = int ( A [ i ] )\n    MCS ( A , n )\n", "python_code_tokenized": "def MCS ( A , n ) : NEW_LINE INDENT B = sorted ( A ) NEW_LINE B0 = B [ 0 ] NEW_LINE cost = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT Bi , t_cost , count = B [ i ] , 0 , 0 NEW_LINE si = A . index ( Bi ) NEW_LINE while si != i : NEW_LINE INDENT bsi = B [ si ] NEW_LINE sj = A . index ( bsi ) NEW_LINE A [ si ] , A [ sj ] = bsi , Bi NEW_LINE t_cost += Bi + bsi NEW_LINE count += 1 NEW_LINE si = sj NEW_LINE DEDENT if count : NEW_LINE INDENT cost += min ( t_cost , ( Bi + B0 ) * 2 + t_cost - ( Bi - B0 ) * count ) NEW_LINE DEDENT DEDENT print ( cost ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE A = input ( ) . split ( \" \u2581 \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT A [ i ] = int ( A [ i ] ) NEW_LINE DEDENT MCS ( A , n ) NEW_LINE DEDENT"}
{"id": "geeksforgeeks_4729_A", "sol": 0, "python_code": "def ksmallest ( arr , n , k ) :\n    for i in range ( n ) :\n        if ( arr [ i ] <= k ) :\n            k = k + 1 ;\n        else :\n            break ;\n    return k ;\nk = 1 ;\narr = [ 1 ] ;\nn = len ( arr ) ;\nprint ( ksmallest ( arr , n , k ) ) ;\n", "python_code_tokenized": "def ksmallest ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= k ) : NEW_LINE INDENT k = k + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return k ; NEW_LINE DEDENT k = 1 ; NEW_LINE arr = [ 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ksmallest ( arr , n , k ) ) ; NEW_LINE"}
{"id": "codeforces_271_B", "sol": 0, "python_code": "from bisect import bisect_left\na = [ 1 for i in range ( 110001 ) ]\nb = [ ]\na [ 0 ] = 0\na [ 1 ] = 0\nfor i in range ( 2 , 110001 ) :\n    if ( a [ i ] == 1 ) :\n        for j in range ( i * i , 110001 , i ) :\n            a [ j ] = 0\n        b += [ i ]\nn , m = map ( int , input ( ).split ( ) )\na = [ ]\nfor i in range ( n ) :\n    a += [ list ( map ( int , input ( ).split ( ) ) ) ]\nma = 9999999\nfor i in range ( n ) :\n    cnt = 0\n    for j in range ( m ) :\n        x = bisect_left ( b , a [ i ] [ j ] )\n        cnt += b [ x ] - a [ i ] [ j ]\n    ma = min ( ma , cnt )\nfor i in range ( m ) :\n    cnt = 0\n    for j in range ( n ) :\n        x = bisect_left ( b , a [ j ] [ i ] )\n        cnt += b [ x ] - a [ j ] [ i ]\n    ma = min ( ma , cnt )\nprint ( ma )\n", "python_code_tokenized": "from bisect import bisect_left NEW_LINE a = [ 1 for i in range ( 110001 ) ] NEW_LINE b = [ ] NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 0 NEW_LINE for i in range ( 2 , 110001 ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i * i , 110001 , i ) : NEW_LINE INDENT a [ j ] = 0 NEW_LINE DEDENT b += [ i ] NEW_LINE DEDENT DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a += [ list ( map ( int , input ( ) . split ( ) ) ) ] NEW_LINE DEDENT ma = 9999999 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT x = bisect_left ( b , a [ i ] [ j ] ) NEW_LINE cnt += b [ x ] - a [ i ] [ j ] NEW_LINE DEDENT ma = min ( ma , cnt ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT x = bisect_left ( b , a [ j ] [ i ] ) NEW_LINE cnt += b [ x ] - a [ j ] [ i ] NEW_LINE DEDENT ma = min ( ma , cnt ) NEW_LINE DEDENT print ( ma ) NEW_LINE"}
